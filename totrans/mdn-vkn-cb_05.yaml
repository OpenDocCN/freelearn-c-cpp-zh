- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Deciphering Order-Independent Transparency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密无序透明度
- en: Rendering transparent objects isn’t always easy. While opaque objects can be
    rendered in any order, transparent objects need to be rendered from farthest to
    nearest relative to the camera, which implies an extra sorting step before performing
    the actual rendering. This depth sorting ensures that more distant objects are
    blended into the frame buffer first, followed by nearer objects, allowing for
    accurate composition of transparent layers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染透明物体并不总是容易。虽然不透明物体可以按任何顺序渲染，但透明物体需要根据它们相对于摄像机的距离从远到近进行渲染，这意味着在执行实际渲染之前需要额外的排序步骤。这种深度排序确保了更远的物体首先被混合到帧缓冲区中，然后是较近的物体，从而允许准确组合透明层。
- en: Sorting can become computationally expensive and error-prone, especially when
    dealing with complex scenes, intersecting objects, or real-time rendering scenarios.
    Additionally, sorting fails to solve the problem of cyclic overlaps, where multiple
    objects interpenetrate in such a way that no single depth-sorting order can accurately
    represent their visual appearance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 排序可能会变得计算密集且容易出错，尤其是在处理复杂场景、相交物体或实时渲染场景时。此外，排序无法解决循环重叠的问题，其中多个物体以这种方式相互穿透，以至于没有任何单个深度排序顺序可以准确地表示它们的视觉外观。
- en: Order-independent transparency techniques try to solve these problems by accumulating
    transparency information in a way that doesn’t depend on the order in which objects
    are processed. This chapter delves into the complexities and challenges of rendering
    transparent objects, a task that requires precision and careful execution. In
    contrast to opaque objects, which can be rendered in any order, transparent objects
    necessitate rendering based on their depth in relation to the camera, from the
    farthest to the nearest. This involves an additional sorting step, which, while
    ensuring accurate composition of transparent layers, can prove to be computationally
    intensive and prone to errors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无序透明度技术试图通过以不依赖于对象处理顺序的方式累积透明度信息来解决这些问题。本章深入探讨了渲染透明对象的复杂性和挑战，这项任务需要精确和细致的执行。与可以按任何顺序渲染的不透明物体不同，透明物体需要根据它们相对于摄像机的深度进行渲染，从最远到最近。这涉及到一个额外的排序步骤，虽然确保了透明层的准确组合，但可能会变得计算密集且容易出错。
- en: 'In this chapter we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Implementing Depth-Peeling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现深度剥离
- en: Implementing Dual Depth-Peeling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现双重深度剥离
- en: Implementing Linked-List Order-Independent Transparency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现链表无序透明度
- en: Implementing Weighted Order-Independent Transparency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现加权无序透明度
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Basic familiarity with the C++ programming language and an
    understanding of OpenGL or any other graphics API will be useful. Please revisit
    [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan Core Concepts*, under
    the *Technical requirements* section for details on setting up and building executables
    for this chapter. All recipes for this chapter are encapsulated in a single executable
    and can be launched using `Chapter05_Transparency.exe` executable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要确保你已经安装了VS 2022以及Vulkan SDK。对C++编程语言的基本熟悉程度以及对OpenGL或任何其他图形API的理解将很有用。请回顾*第1章*[*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*，*Vulkan核心概念*，在*技术要求*部分中有关设置和构建本章可执行文件的具体细节。本章的所有配方都封装在一个单独的可执行文件中，可以使用`Chapter05_Transparency.exe`可执行文件启动。
- en: Implementing Depth-Peeling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现深度剥离
- en: '**Depth Peeling** was introduced in 2001 by Cass Everitt as a solution to render
    semi-transparent geometry without the need to sort the geometry from back-to-front.
    The technique consists of rendering the scene multiple times (passes). At each
    pass, only the nearest fragments to the camera are rendered and their depth is
    collected to be used on the next pass. On each pass, except for the first pass,
    fragments closer than the ones in the depth pass collected in the previous iteration
    are discarded. This process *peels* the scene into consecutive layers, from front
    to back. At the end of the process, all layers are blended into one final image,
    which is then blended once more with the background.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度剥离**技术由 Cass Everitt 在 2001 年提出，作为渲染半透明几何形状的解决方案，无需从后向前排序几何形状。该技术包括多次渲染场景（遍历）。在每次遍历中，仅渲染离相机最近的片段，并收集其深度以供下一次遍历使用。在每次遍历中（除了第一次遍历），丢弃比前一次迭代中收集的深度遍历中的片段更近的片段。这个过程将场景*剥离*成连续的层，从前面到后面。在过程结束时，所有层都混合成一张最终图像，然后再次与背景混合。'
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository mentioned in *Technical requirements*, the Depth Peeling algorithm
    is implemented by the `DepthPeeling` class, located in `source/enginecore/passes/DepthPeeling.hpp`
    and `cpp` files. In this recipe, you will learn how to peel away or progressively
    remove layers of transparent objects in your rendering process. This technique
    ensures accurate rendering by handling each layer individually from the farthest
    to the nearest, thus improving the overall visual quality of scenes with complex
    overlapping transparencies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在*技术要求*中提到的仓库中，深度剥离算法是通过`DepthPeeling`类实现的，该类位于`source/enginecore/passes/DepthPeeling.hpp`和`cpp`文件中。在本教程中，您将学习如何在渲染过程中剥离或逐步移除透明物体的层。这项技术通过从最远到最近逐个处理每一层，确保了准确的渲染，从而提高了具有复杂重叠透明度的场景的整体视觉质量。
- en: 'The algorithm consists of rendering the scene repeatedly, storing the depth
    map at the end of each pass. The fragments nearest to the camera are blended with
    the previous pass (or an empty framebuffer for the first pass). The current pass
    fragment depth is discarded if it is smaller than the depth from the last pass,
    as summarized in *Figure 5**.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法包括反复渲染场景，在每个遍历结束时存储深度图。离相机最近的片段与上一个遍历（或第一个遍历的空帧缓冲区）混合。如果当前遍历片段的深度小于上一个遍历的深度，则丢弃当前遍历片段的深度，如图*图
    5.1*所示：
- en: '![Figure 5.1 –Depth Peeling algorithm with 3 planes](img/B18491_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 –具有 3 个平面的深度剥离算法](img/B18491_05_01.jpg)'
- en: Figure 5.1 –Depth Peeling algorithm with 3 planes
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 –具有 3 个平面的深度剥离算法
- en: We’ve provided a foundational understanding of this technique in the preceding
    section. Moving forward, we will delve deeper, guiding you through a detailed,
    step-by-step process on how to practically implement this technique using Vulkan.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经提供了对这个技术的基础理解。接下来，我们将深入探讨，通过详细的、分步的过程指导您如何使用 Vulkan 实际实现这项技术。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The algorithm uses two sets of depth maps and two sets of color attachments
    to perform a ping-pong operation between passes. The depth map obtained during
    one pass is used as a reference depth map on the next, while a second depth map
    is then used as a depth attachment. The same thing is done with two color attachments:
    one is used to store the blending of the current pass, while the other is used
    as the reference, generated in the previous pass. The subsequent steps will guide
    you through the actual execution of these operations. With the help of a detailed
    diagram provided below, you will be able to visualize and better understand the
    intricate workings of this algorithm.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法使用两组深度图和两组颜色附件来在遍历之间执行乒乓操作。在一次遍历期间获得的深度图用作下一次遍历的参考深度图，而第二个深度图则用作深度附件。对于两个颜色附件也做同样处理：一个用于存储当前遍历的混合效果，而另一个用作参考，由前一个遍历生成。接下来的步骤将指导您了解这些操作的执行过程。借助下面提供的详细图表，您将能够可视化并更好地理解该算法的复杂工作原理。
- en: '*Figure 5**.2* effectively illustrates the described process, aiding in your
    comprehension and application of this intricate technique:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2*有效地说明了所描述的过程，有助于您理解和应用这项复杂的技术：'
- en: '![Figure 5.2 – Depth peeling algorithm](img/B18491_05_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 –深度剥离算法](img/B18491_05_02.jpg)'
- en: Figure 5.2 – Depth peeling algorithm
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 –深度剥离算法
- en: Now we will go through steps on how to perform this recipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步讲解如何执行这个配方。
- en: 'The algorithm is performed by the `DepthPeeling::draw` method, which starts
    by clearing the depth map 1 and both color attachments:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法通过`DepthPeeling::draw`方法执行，它首先清除深度图1和两个颜色附件：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both the color and depth attachments start with the color and depth attachments
    with index equal to 0:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 颜色和深度附件都从索引为0的颜色和深度附件开始：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The algorithm repeats a number of times, equal to the number of passes. Care
    must be taken to transition each attachment to the correct layout, obeying the
    ping-ponging mechanism: a texture used as a color attachment before needs to be
    transitioned to a texture that will be read by a shader and vice-versa:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法重复多次，次数等于通道数。必须注意将每个附件转换为正确的布局，遵守乒乓机制：在之前用作颜色附件的纹理需要转换为将被着色器读取的纹理，反之亦然：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we begin the render pass, issue the draw call, and end the pass:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们开始渲染通道，发出绘制调用，并结束通道：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The images are transitioned to the correct layout by the render pass, so all
    we need to do is copy the result of the current pass into the other texture that
    will be used as the color attachment during the next pass:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过渲染通道，图像被转换为正确的布局，因此我们只需要将当前通道的结果复制到下一个通道中将用作颜色附件的另一个纹理中：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The vertex fragment is not special for depth peeling, but the fragment shader
    must discard fragments that are closer to the camera than the fragments collected
    in the previous pass. The fragment shader also performs the blending into the
    current attachment:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点片段对于深度剥离来说并不特殊，但片段着色器必须丢弃比之前通道中收集的片段更靠近摄像机的片段。片段着色器还执行当前附件的混合：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The blending equation is a special one, used for front-to-back compositing,
    as described by Louis Bavoil and Kevin Myers in 2008 in their *Order Independent
    Transparency with Dual Depth Peeling* paper. The blending equation is:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 混合方程是一个特殊的方程，用于前后合成，如路易斯·巴沃伊和凯文·迈尔斯在2008年发表的*使用双深度剥离的独立顺序透明度*论文中所述。混合方程如下：
- en: C dst = A dst(A src C src)+ C dst
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C dst = A dst(A src C src)+ C dst
- en: A dst = (1 − A src) A dst
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A dst = (1 − A src) A dst
- en: In the following recipe, we will explore how to enhance the depth-peeling technique,
    making it more efficient.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的配方中，我们将探讨如何增强深度剥离技术，使其更高效。
- en: Implementing Dual Depth-Peeling
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现双深度剥离
- en: One of the main drawbacks of the Depth Peeling algorithm is that it requires
    multiple passes, each of which may consist of rasterizing the entire scene. The
    **Dual Depth-Peeling** algorithm extends the original Depth Peeling algorithm
    by peeling two layers at the same time, almost effectively cutting the number
    of passes by half. In this recipe, we will focus on implementing the Dual Depth-Peeling
    algorithm. We will address one of the key limitations of the Depth Peeling algorithm,
    namely its requirement for multiple passes which may involve rasterizing the entire
    scene. You’ll learn how the Dual Depth-Peeling algorithm improves upon the original
    by peeling two layers concurrently, thus potentially reducing the number of passes
    by nearly half. This insight will empower you to handle complex scenes with greater
    efficiency and speed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 深度剥离算法的主要缺点之一是它需要多次传递，每次传递可能包括对整个场景进行光栅化。**双深度剥离**算法通过同时剥离两层来扩展原始的深度剥离算法，几乎有效地将传递次数减半。在本配方中，我们将专注于实现双深度剥离算法。我们将解决深度剥离算法的一个关键限制，即其需要多次传递，可能涉及对整个场景进行光栅化。您将了解双深度剥离算法如何通过同时剥离两层来改进原始算法，从而可能将传递次数减少近一半。这一见解将使您能够以更高的效率和速度处理复杂场景。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, the Depth Peeling algorithm is implemented by the `DualDepthPeeling`
    class, located in `source/enginecore/passes/DualDepthPeeling.hpp` and `cpp` files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，深度剥离算法由`DualDepthPeeling`类实现，位于`source/enginecore/passes/DualDepthPeeling.hpp`和`cpp`文件中。
- en: Before we begin, we need to set the `VkPhysicalDeviceFeatures::independentBlend`
    property to true. This property allows us to use different blending equations
    for each attachment associated with a graphics pipeline.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要将`VkPhysicalDeviceFeatures::independentBlend`属性设置为true。此属性允许我们为与图形管道关联的每个附件使用不同的混合方程。
- en: On each pass, a depth map with two components, R and G (in the code we use the
    `VK_FORMAT_R32G32_SFLOAT` format), is used to store both the front and the back
    peels simultaneously. The blend equation used with the map is `VK_BLEND_OP_MAX`.
    When storing the current fragment’s depth, we encode it as `vec2(-depth, depth)`.
    The R component stores the negative depth of the front peel, while the G component
    stores the actual depth of the back peel, The `Max` blending equation ensures
    that we only store the nearest front peel by negating it. The back peels are guaranteed
    to always be the farthest because they are stored as positive depths.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个通道上，使用具有两个组件R和G（在代码中我们使用`VK_FORMAT_R32G32_SFLOAT`格式）的深度图，同时存储前剥离和后剥离。与图一起使用的混合方程式是`VK_BLEND_OP_MAX`。当存储当前片段的深度时，我们将其编码为`vec2(-depth,
    depth)`。R组件存储前剥离的负深度，而G组件存储后剥离的实际深度。`Max`混合方程式确保我们只存储最近的前剥离，通过取负值来实现。后剥离始终保证是最远的，因为它们以正深度存储。
- en: 'The front peel is blended with the modified blend equation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前剥离与修改后的混合方程式混合：
- en: C dst = A dst(A src C src)+ C dst
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C dst = A dst(A src C src)+ C dst
- en: A dst = (1 − A src) A dst
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: A dst = (1 − A src) A dst
- en: While the back peel is blended with the regular back-to-front blend equation
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当后剥离与常规的从后向前混合方程式混合时
- en: C dst = A src C src + (1 − A src) C dst
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C dst = A src C src + (1 − A src) C dst
- en: With the preparatory steps outlined, you are now ready to delve into the implementation
    of the Dual Depth-Peeling algorithm. In the next section, we will guide you through
    the step-by-step process of executing this algorithm, using the insights and techniques
    discussed above.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在概述了准备步骤之后，你现在可以深入到双深度剥离算法的实现中。在下一节中，我们将引导你逐步执行此算法，使用上面讨论的见解和技术。
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The algorithm in Vulkan consists of using 2 color attachments, one for the front
    peel and one for the back peel. It also uses 2 depth buffers with the same format.
    One is used for the even numbered passes, while the other for the odd even passes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan中的算法包括使用2个颜色附件，一个用于前剥离，一个用于后剥离。它还使用2个具有相同格式的深度缓冲区。一个用于偶数通道，另一个用于奇数通道。
- en: 'We start by specifying the blend operations for each attachment:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先指定每个附件的混合操作：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These instances of the `VkPipelineColorBlendAttachmentState` structure are added
    to the `VkPipelineColorBlendStateCreateInfo` structure when creating a graphics
    pipeline and are provided in the order the attachments will be set in the framebuffers.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些`VkPipelineColorBlendAttachmentState`结构实例在创建图形管线时添加到`VkPipelineColorBlendStateCreateInfo`结构中，并且按照在帧缓冲区中设置附件的顺序提供。
- en: 'The algorithm, implemented by `DualDepthPeeling::draw` method, starts by clearing
    the depth buffers and the color attachments:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由`DualDepthPeeling::draw`方法实现的算法首先清除深度缓冲区和颜色附件：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The depth textures are then transitioned for the first pass:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将深度纹理转换为第一个通道：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Both the front and back textures are bound as attachments and are loaded and
    stored for each pass. One of the depth textures is also bound as an attachment
    and is cleared to `(-99,999; 99,999)` and stored after each pass. The other depth
    texture is bound as a texture for read by the fragment shader:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前后纹理都被绑定为附件，并在每个通道中加载和存储。一个深度纹理也被绑定为一个附件，并在每个通道后清除到`(-99,999; 99,999)`并存储。另一个深度纹理被绑定为一个供片段着色器读取的纹理：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For each pass we start by transitioning the color and depth attachments to
    the correct layouts:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个通道，我们首先将颜色和深度附件转换为正确的布局：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The attachments are provided for the render pass using dynamic rendering, the
    scene is rendered, and the pass is completed:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用动态渲染为渲染通道提供附件，渲染场景，并完成通道：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once all the passes are completed, one last step remains which is consists of
    blending the last front and back peels. The front peel is provided as a color
    attachment and as a texture for the shader, while the back color is only provided
    as a texture for reading by the shader.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有通道都完成，最后一步是混合最后一个前剥离和后剥离。前剥离作为颜色附件和着色器的纹理提供，而后颜色仅作为着色器读取的纹理提供。
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This last pass consists of drawing a rectangle the size of the viewport and
    used solely for blending the two peels
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个通道包括绘制一个与视口大小相同的矩形，仅用于混合两个剥离层
- en: 'The main dual depth peeling fragment shader reads the depth value of the fragment
    output from the previous pass, decodes it, and decided whether the fragment should
    be discarded or not:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要的双深度剥离片段着色器读取前一个传递输出的片段深度值，对其进行解码，并决定是否丢弃该片段：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final pass, where the front and back peels are blended, uses a simple fragment
    shader:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的传递，其中前表面和后表面的剥离被混合，使用一个简单的片段着色器：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having delved into the intricacies of the Dual Depth-Peeling algorithm, we will
    now shift our focus to another advanced technique in the next recipe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究双深度剥离算法的复杂性之后，我们将现在将注意力转向下一道菜谱中的另一种高级技术。
- en: Implementing Linked-List Order-Independent Transparency
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现链表无序透明度
- en: '**Order Independent Transparency** uses a per pixel linked list to handle transparency,
    it makes use of data structures, specifically linked lists, to store fragments
    for each pixel. Each node of the list contains information about a fragment’s
    color and depth value, and the nodes are connected in a way that follows the order
    of fragments arrival, thus making sorting unnecessary.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**无序透明度**使用每个像素的链表来处理透明度，它利用数据结构，特别是链表，来存储每个像素的片段。链表的每个节点包含有关片段颜色和深度值的信息，节点以遵循片段到达顺序的方式连接，从而使得排序变得不必要。'
- en: This approach effectively eliminates overdrawing, and artifacts associated with
    depth sorting. By focusing on the depth value of each fragment, the approach provides
    a more accurate, visually pleasing representation of transparent objects. In this
    recipe, we will delve into the detailed process of implementing the Linked-List
    **Order-Independent Transparency** (**OIT**) technique. You’ll learn how this
    technique leverages per pixel linked lists to efficiently manage transparency,
    eliminating the issues of overdrawing and depth sorting artifacts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效地消除了过度绘制和与深度排序相关的伪影。通过关注每个片段的深度值，这种方法提供了更准确、视觉上更令人愉悦的透明物体表示。在本菜谱中，我们将深入了解实现链表无序透明度（**OIT**）技术的详细过程。您将了解这种技术如何利用每个像素的链表来有效地管理透明度，消除过度绘制和深度排序伪影的问题。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, the Linked list algorithm is implemented by the `OitLinkedListPass`
    class, located in `source/enginecore/passes/` `OitLinkedListPass.hpp` and `cpp`
    files. The corresponding shaders are `source/enginecore/resources/shaders/OitLinkedListBuildPass.frag`
    and `source/enginecore/resources/shaders/ OITLinkedListCompositePass.frag`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，链表算法是通过位于 `source/enginecore/passes/` 的 `OitLinkedListPass.hpp` 和 `cpp`
    文件中的 `OitLinkedListPass` 类实现的。相应的着色器是 `source/enginecore/resources/shaders/OitLinkedListBuildPass.frag`
    和 `source/enginecore/resources/shaders/OITLinkedListCompositePass.frag`
- en: The algorithm begins by initializing an empty list for each pixel, and as the
    scene is rendered, it adds nodes to the list in the order in which they are processed.
    This is done in a two-pass rendering stage. In the first pass, also known as the
    build pass, each fragment’s depth, color, and next-node pointer are written into
    a buffer. The second pass, also known as resolve or composite pass, goes through
    the list from back-to-front for each pixel and blends the colors based on depth
    values, resulting in the final pixel color.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先为每个像素初始化一个空列表，并在场景渲染过程中，按照它们被处理的顺序将节点添加到列表中。这是在两个渲染阶段中完成的。在第一个传递，也称为构建传递，每个片段的深度、颜色和下一个节点指针被写入缓冲区。第二个传递，也称为解析或合成传递，为每个像素从前到后遍历列表，并根据深度值混合颜色，从而得到最终的像素颜色。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To implement a per pixel linked list, we need to maintain various buffers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现每个像素的链表，我们需要维护各种缓冲区。
- en: The `OitLinkedListPass::init` method is tasked with initializing a variety of
    resources. It establishes both the Build pass and the Composite pass pipelines.
    Furthermore, it arranges the necessary resources for the Build pass pipeline.
    The code snippet below highlights some key resources configured during the initialization
    phase.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OitLinkedListPass::init` 方法负责初始化各种资源。它建立了构建传递和合成传递管道。此外，它为构建传递管道安排必要的资源。下面的代码片段突出了初始化阶段配置的一些关键资源。'
- en: '`atomicCounterBuffer_`: This buffer is created to hold an atomic counter. The
    counter is used to allocate slots in the linked list buffer for storing new fragments.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`atomicCounterBuffer_`：此缓冲区创建用于存储原子计数器。计数器用于在链表缓冲区中为存储新片段分配槽位。'
- en: '`linkedListBuffer_`: This is the main buffer that holds the linked lists of
    fragments for each pixel. Each pixel can have multiple fragments, and each fragment
    is represented as a `Node` in the linked list. The size of this buffer is determined
    by the number of pixels in the swapchain’s extent (its width and height), the
    number of slots per pixel, and the size of the Node structure.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`linkedListBuffer_`：这是主要的缓冲区，它存储了每个像素的片段链表。每个像素可以有多个片段，每个片段都作为链表中的一个 `Node`
    表示。这个缓冲区的大小由交换链的范围（其宽度和高度）、每个像素的槽位数和 Node 结构的大小决定。'
- en: '`linkedListHeadPtrTexture_`: This buffer stores the head pointers for the linked
    lists of each pixel. A head pointer points to the first Node of a linked list.
    This buffer is created as a 2D texture (image) because it needs to store a pointer
    for each pixel in the swapchain’s extents. The format `VK_FORMAT_R32_UINT` indicates
    that each element in the texture is a 32-bit unsigned integer, which is suitable
    for representing a pointer.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`linkedListHeadPtrTexture_`：这个缓冲区存储了每个像素的链表的头指针。头指针指向链表中的第一个 Node。因为这个缓冲区需要存储交换链中每个像素的指针，所以它被创建为一个二维纹理（图像）。格式
    `VK_FORMAT_R32_UINT` 表示纹理中的每个元素都是一个 32 位无符号整数，这对于表示指针是合适的。'
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The actual magic of the algorithm happens during the `draw` function. As a first
    step, we are setting the pixels in `linkedListHeadPtrTexture_` to zero with `vkCmdClearColorImage`
    function, and filling the `linkedListBuffer_` and `atomicCounterBuffer_` with
    zeros using `vkCmdFillBuffer`, just to reset everything to null state before we
    begin writing to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法的实际魔法发生在 `draw` 函数期间。作为第一步，我们使用 `vkCmdClearColorImage` 函数将 `linkedListHeadPtrTexture_`
    中的像素设置为零，并使用 `vkCmdFillBuffer` 函数将 `linkedListBuffer_` 和 `atomicCounterBuffer_`
    填充为零，只是为了在我们开始写入之前将一切重置为空状态。
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to set up correct memory barriers. These barriers ensure that
    all clear operations finish before the shader starts reading from or writing to
    the buffers. The first barrier is a memory barrier:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置正确的内存屏障。这些屏障确保在着色器开始从或向缓冲区读取或写入之前，所有清除操作都已完成。第一个屏障是一个内存屏障：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The other two barriers are buffer barriers, one for the linked list buffer
    and one for the atomic counter buffer:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外两个屏障是缓冲区屏障，一个用于链表缓冲区，一个用于原子计数器缓冲区：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the next step descriptor sets are bound, updated, and the vertex and index
    buffers are bound to the pipeline. Then the indexed draw command is issued for
    each mesh.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，绑定描述符集，更新，并将顶点和索引缓冲区绑定到管线。然后对每个网格发出索引绘制命令。
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The vertex fragment is not special, but the fragment shader must maintain a
    linked list along with head pointer. Below we present the code breakdown for `OitLinkedListBuildPass.frag`
    which is responsible for the build pass of the linked list OIT algorithm:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点片段并不特殊，但片段着色器必须维护一个与头指针一起的链表。以下是我们对 `OitLinkedListBuildPass.frag` 的代码分解，它负责链表
    OIT 算法的构建传递：
- en: We start by defining a Node struct, which represents a node in a linked list
    for handling transparency. It contains the color and the index of the previous
    node. Afterwards, we declare several uniform and buffer variables, used for object
    properties, an atomic counter, a linked list of nodes, and an image for head pointers.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个 Node 结构体，它代表用于处理透明度的链表中的一个节点。它包含颜色和前一个节点的索引。之后，我们声明了几个统一和缓冲区变量，用于对象属性、一个原子计数器、一个节点链表和一个头指针图像。
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The main function performs an atomic add operation on the atomic counter to
    get a unique index for each fragment. After calculating the size of the image
    and ensuring the new node index doesn’t exceed the maximum size of the linked
    list, it performs an atomic exchange operation to insert the new node at the beginning
    of the linked list. Finally, it sets the properties of the new node in the linked
    list.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主函数对原子计数器执行原子加操作，为每个片段获取一个唯一的索引。在计算图像大小并确保新的节点索引不超过链表的最大大小时，它执行原子交换操作以将新节点插入链表的开始位置。最后，它设置链表中新节点的属性。
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next and final step is to draw a full screen quad. Before performing the
    full screen quad pass, we set up memory and buffer barriers to ensure synchronization
    for the `linkedListBuffer_` and the `linkedListHeadPtrTexture_` since these resources
    are used during the composite pass.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来和最后一步是绘制一个全屏四边形。在执行全屏四边形传递之前，我们设置内存和缓冲区屏障以确保 `linkedListBuffer_` 和 `linkedListHeadPtrTexture_`
    的同步，因为这些资源在合成传递期间被使用。
- en: 'Lastly, the composite pass fragment shader starts by first getting the head
    of the linked list for the current pixel. The list is stored in a buffer, and
    each pixel corresponds to the first node of a linked list of all fragments that
    affect that pixel. An array to temporarily store the nodes for sorting is created.
    We then iterate over the linked list, retrieving each node and storing it in the
    temporary array. It continues until it reaches the end of the list (denoted by
    `nodeIndex` being 0) or when it has retrieved 20 nodes:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，复合通行片段着色器首先获取当前像素的链表头。该列表存储在缓冲区中，每个像素对应于影响该像素的所有片段链表中的第一个节点。创建一个数组来临时存储用于排序的节点。然后我们遍历链表，检索每个节点并将其存储在临时数组中。这个过程一直持续到达到列表的末尾（由`nodeIndex`为0表示）或者已经检索了20个节点：
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The nodes in the array are sorted in descending order based on their depth
    values using a simple bubble sort algorithm. This ensures that the nodes closest
    to the camera are blended last:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的冒泡排序算法根据节点的深度值按降序对数组中的节点进行排序。这确保了离相机最近的节点最后被混合：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the colors of each node are blended from back to front using the mix
    function:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用混合函数从后向前混合每个节点的颜色：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This algorithm gives a very good result and is an excellent option if you value
    correctness. It’s a bit slower than the one presented in the next recipe, but
    it is by far the most intuitive algorithm amongst all the different algorithms
    we discussed in this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法给出了非常好的结果，如果你重视正确性，它是一个极好的选择。它比下一道菜谱中介绍的要慢一些，但它是我们在本章讨论的所有不同算法中最直观的算法。
- en: There’s more…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We would like to note an additional technique, known as **Tail Blending**, that
    can be effectively combined with the technique discussed above. One of the limitations
    of our approach is the maximum number of fragments that can be accommodated for
    each pixel, which is typically dictated by the anticipated depth complexity of
    the scene and the memory available. In more intricate scenes with numerous overlapping
    transparent objects, the fragment count for a pixel may surpass this limit. That’s
    when Tail Blending becomes handy. When a linked list reaches its capacity, any
    extra fragments are directly blended with the color of the last node in the list,
    also known as the *tail*, hence the term *Tail Blending*. The benefit of tail
    blending is its ability to process scenes with extremely high depth complexity
    without the need to expand the maximum length of the linked list, thereby conserving
    memory. However, a potential drawback is that it might yield less precise results
    since blending is order-dependent and the fragments blended with the tail aren’t
    arranged in relation to the other fragments in the list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想指出一种额外的技术，称为**尾部混合**，它可以有效地与上述技术结合。我们方法的一个局限性是每个像素可以容纳的片段的最大数量，这通常由场景预期的深度复杂性和可用的内存决定。在具有许多重叠透明物体的复杂场景中，像素的片段数可能会超过这个限制。这时尾部混合就派上用场了。当一个链表达到其容量时，任何额外的片段都会直接与列表中最后一个节点（也称为*尾部*）的颜色混合，因此得名*尾部混合*。尾部混合的好处是它能够处理具有极高深度复杂性的场景，而无需扩展链表的最大长度，从而节省内存。然而，一个潜在的缺点是它可能产生不太精确的结果，因为混合是顺序相关的，并且与列表中其他片段无关的尾部片段被混合。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Please see the following link on:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下链接：
- en: 'Exploring and Expanding the Continuum of OIT Algorithms: [http://cwyman.org/papers/hpg16_oitContinuum.pdf](http://cwyman.org/papers/hpg16_oitContinuum.pdf)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和扩展OIT算法的连续性：[http://cwyman.org/papers/hpg16_oitContinuum.pdf](http://cwyman.org/papers/hpg16_oitContinuum.pdf)
- en: Implementing Weighted Order-Independent Transparency
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现加权顺序无关透明度
- en: '**Weighted Order-Independent Transparency** (**WOIT**) uses a different idea
    to tackle transparency, by using the concept of weighted averages rather than
    using data structures like linked lists or layers like depth peeling.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**加权顺序无关透明度**（**WOIT**）通过使用加权平均的概念来处理透明度，而不是使用像链表或深度剥离这样的数据结构或层。'
- en: This method doesn’t require sorting or linked lists or multiple passes, reducing
    the overhead associated with those operations. The final color is calculated by
    normalizing the color buffer with the weight buffer, which provides an aggregate
    view of the colors and their weights. Although it may not be as accurate as per-pixel
    linked lists in complex scenarios, WOIT offers a performance-efficient solution
    for handling transparency in scenes with lower depth complexity. In this recipe,
    you will gain an understanding of the WOIT technique. We will explore how this
    method employs weighted averages to handle transparency, eschewing the need for
    data structures like linked lists or multiple passes, thereby reducing associated
    overhead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不需要排序或链表或多个传递，从而减少了与这些操作相关的开销。最终颜色是通过将颜色缓冲区与权重缓冲区归一化来计算的，这提供了颜色及其权重的汇总视图。尽管在复杂场景中可能不如按像素链表精确，但
    WOIT 为处理具有较低深度复杂性的场景中的透明度提供了一个性能高效的解决方案。在本食谱中，您将了解 WOIT 技术。我们将探讨这种方法如何使用加权平均值来处理透明度，避免使用链表或多个传递等数据结构，从而减少相关的开销。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, the WOIT algorithm is implemented by the `OitWeightedPass`
    class, located in source `/enginecore/passes/` `OitWeightedPass.hpp` and `cpp`
    files. The corresponding shaders are `source/enginecore/resources/shaders/OitWeighted.frag`
    and `source/enginecore/resources/shaders/ OITWeightedComposite.frag`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，WOIT 算法由 `OitWeightedPass` 类实现，位于源代码 `/enginecore/passes/` `OitWeightedPass.hpp`
    和 `cpp` 文件中。相应的着色器是 `source/enginecore/resources/shaders/OitWeighted.frag` 和 `source/enginecore/resources/shaders/OITWeightedComposite.frag`
- en: The WOIT algorithm begins by initializing two empty buffers for each pixel,
    one for accumulating color and the other for accumulating weights. As the scene
    is rendered, the algorithm processes each transparent fragment and updates these
    buffers in a single rendering pass. During this pass, each fragment’s color is
    multiplied by its alpha value (the weight) and added to the color buffer, while
    the alpha value itself is added to the weight buffer. This process continues for
    all fragments, accumulating and blending their contributions based on their opacity.
    Once all fragments are processed, a final composite step is performed where the
    accumulated color in the color buffer is divided by the total weight in the weight
    buffer. This results in the final pixel color, providing a composite view of all
    transparent fragments based on their weights.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: WOIT 算法首先为每个像素初始化两个空缓冲区，一个用于累积颜色，另一个用于累积权重。随着场景的渲染，算法处理每个透明片段，并在单个渲染传递中更新这些缓冲区。在此传递期间，每个片段的颜色乘以其
    alpha 值（权重）并添加到颜色缓冲区，而 alpha 值本身则添加到权重缓冲区。这个过程对所有片段持续进行，根据它们的透明度累积和混合它们的贡献。一旦处理完所有片段，就会执行一个最终的复合步骤，其中颜色缓冲区中累积的颜色除以权重缓冲区中的总权重。这产生了最终的像素颜色，根据它们的权重提供了一个所有透明片段的复合视图。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: The following steps provides a guide on implementing the WOIT technique using
    the Vulkan API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤提供了使用 Vulkan API 实现WOIT技术的指南。
- en: The `OitWeightedPass::init` method is tasked with initializing a variety of
    resources. It establishes both the Accumulation pass and the Composite pass pipelines.
    Furthermore, it arranges the necessary resources for the accumulation pass pipeline.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OitWeightedPass::init` 方法负责初始化各种资源。它建立了累积传递和复合传递管道。此外，它为累积传递管道安排必要的资源。'
- en: 'The `colorTexture_` uses the `VK_FORMAT_R16G16B16A16_SFLOAT` format. This format
    represents 4 channels (R, G, B, A) of 16-bit floating point numbers, providing
    high precision for color representation. It’s important for the color buffer to
    have a high precision format because during the accumulation pass, colors from
    various fragments are added together:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`colorTexture_` 使用 `VK_FORMAT_R16G16B16A16_SFLOAT` 格式。这种格式表示 4 个通道（R、G、B、A）的
    16 位浮点数，为颜色表示提供了高精度。对于颜色缓冲区来说，具有高精度格式很重要，因为在累积传递期间，来自各个片段的颜色会相加：'
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `alphaTexture`_ uses the `VK_FORMAT_R16_SFLOAT` format, which is a single
    16-bit floating point number. This is adequate because we’re only storing the
    alpha (opacity) value:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alphaTexture`_ 使用 `VK_FORMAT_R16_SFLOAT` 格式，这是一个单一的 16 位浮点数。这足够了，因为我们只存储 alpha（不透明度）值：'
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since WOIT depends upon blending, it’s important to set up blending attachments
    correctly. The pipeline descriptor `gpDesc` below is created with two `VkPipelineColorBlendAttachmentState`
    structures, one for each attachment. For the first blend attachment (corresponding
    to the color texture), the blend factors are set to `VK_BLEND_FACTOR_ONE` for
    both the source and destination, and the blend operation is `VK_BLEND_OP_ADD`.
    This effectively implements additive blending, where the new fragment’s color
    is added to the existing color in the color buffer.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于WOIT依赖于混合，因此正确设置混合附件非常重要。下面的管道描述符 `gpDesc` 是使用两个 `VkPipelineColorBlendAttachmentState`
    结构创建的，每个附件一个。对于第一个混合附件（对应于颜色纹理），源和目的地的混合因子都设置为 `VK_BLEND_FACTOR_ONE`，混合操作为 `VK_BLEND_OP_ADD`。这有效地实现了加法混合，其中新片段的颜色被添加到颜色缓冲区中现有的颜色。
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the second blend attachment (corresponding to the alpha texture), the source
    alpha blend factor is `VK_BLEND_FACTOR_ZERO`, and the destination alpha blend
    factor is `VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR`. This configuration ensures that
    the new fragment’s alpha (or weight) is accumulated in the alpha buffer:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个混合附件（对应于alpha纹理），源alpha混合因子为 `VK_BLEND_FACTOR_ZERO`，目的alpha混合因子为 `VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR`。这种配置确保新片段的alpha（或权重）在alpha缓冲区中累积：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, we need to initialize the composite pipeline. This could be implemented
    as a Vulkan subpass, but for simplicity we have kept it as a separate pass. The
    composite pipeline is created with `VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA` as `srcColorBlendFactor`
    and `VK_BLEND_FACTOR_SRC_ALPHA` as `dstColorBlendFactor`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化合成管道。这可以作为一个Vulkan子通道实现，但为了简单起见，我们将其保留为单独的通道。合成管道使用 `VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA`
    作为 `srcColorBlendFactor` 和 `VK_BLEND_FACTOR_SRC_ALPHA` 作为 `dstColorBlendFactor`
    创建。
- en: This configuration causes the incoming fragment’s color and alpha values to
    be blended with the current color and alpha in the frame buffer, with the incoming
    fragment’s alpha value controlling how much of the incoming color overwrites the
    existing color.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种配置会导致传入片段的颜色和alpha值与帧缓冲区中当前的颜色和alpha值混合，传入片段的alpha值控制传入颜色覆盖现有颜色的程度。
- en: The draw function is where the actual rendering occurs, the implementation is
    straightforward and uses `vkCmdDrawIndexed` to draw multiple meshes. Below we
    present the fragment shader used during this step. In this fragment shader, the
    view-space depth is scaled to provide depth weight; closer fragments are assigned
    larger weights. Then, the maximum color component multiplied by alpha is calculated
    to weigh vibrant pixels more. The calculated color weight is ensured to be no
    more than 1.0 and compared with the alpha to take the maximum value. The depth
    weight is then calculated and clamped within a specific range. The final weight
    is the product of color and depth weights. The color is then premultiplied by
    its alpha value to prevent over-saturation during blending. This shader outputs
    the weighted color and the original alpha of the fragment.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制函数是实际渲染发生的地方，其实现简单，使用 `vkCmdDrawIndexed` 来绘制多个网格。下面我们展示在此步骤中使用的片段着色器。在这个片段着色器中，视图空间的深度被缩放以提供深度权重；距离较近的片段被分配更大的权重。然后，计算最大颜色分量乘以alpha的值，以使鲜艳的像素具有更大的权重。计算出的颜色权重确保不超过1.0，并与alpha值比较以取最大值。然后计算深度权重，并将其限制在特定范围内。最终的权重是颜色和深度权重的乘积。然后，颜色通过其alpha值进行预乘，以防止混合过程中的过度饱和。这个着色器输出加权颜色和片段的原始alpha值。
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The final step is drawing a full screen quad using composite pipeline, it reads
    the accumulated color and alpha from two textures (`colorData` and `alphaData`)
    for the current fragment. The accumulated color (`accumulateColor`) is the sum
    of the product of color, alpha, and weight for each fragment from the previous
    step. The alpha value (alpha) is the original alpha value of the fragment. In
    the output color (`outColor`), the RGB components of the accumulated color are
    divided by the accumulated alpha value to normalize them, with a minimum limit
    of 0.0001 to prevent division by zero. This is because the accumulated color was
    premultiplied by the alpha value (and weight) in the previous steps.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用合成管道绘制全屏四边形，它从两个纹理（`colorData` 和 `alphaData`）中读取当前片段累积的颜色和alpha值。累积颜色（`accumulateColor`）是前一步中每个片段的颜色、alpha和权重的乘积之和。alpha值（alpha）是片段的原始alpha值。在输出颜色（`outColor`）中，累积颜色的RGB分量被除以累积alpha值以归一化，最小限制为0.0001以防止除以零。这是因为累积颜色在前一步中已经通过alpha值（和权重）进行了预乘。
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This technique is faster than the linked-list one presented in recipe *Implementing
    Linked-List Order-Independent Transparency*, but it has its drawbacks, such as
    the weighting function which is prone to add artifacts to the result if not well
    designed and tested.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术比在“实现链表顺序无关透明度”菜谱中提到的链表技术更快，但它有其缺点，例如权重函数，如果设计不当或测试不足，可能会向结果添加伪影。
- en: There’s more…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this chapter, we have explored various techniques for handling transparency.
    The following table highlights the advantages and disadvantages of each method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了处理透明度的各种技术。下表突出了每种方法的优缺点：
- en: '| **Technique** | **Memory** | **Performance** | **Physically correct** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **技术** | **内存** | **性能** | **物理正确性** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Linked list OIT | High, depends upon scene complexity as well as maintained
    LinkedList size | Moderate speed, only requires two passes | Highly accurate,
    handles complex overlapping geometry very well |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 链表OIT | 高，取决于场景复杂性和维护的链表大小 | 中等速度，只需要两次遍历 | 高精度，处理复杂重叠几何形状非常好 |'
- en: '| Dual Depth Peeling OIT | Moderate, requires storage of two depth buffer |
    Slower, since it requires multiple passes | Moderate accuracy, struggles with
    highly complex scene. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 双深度剥离OIT | 中等，需要存储两个深度缓冲区 | 较慢，因为它需要多次遍历 | 中等精度，难以处理高度复杂的场景。 |'
- en: '| WOIT | Low, only needs to store weights & colors for each fragment. | Fast,
    since only single pass is required | Low accuracy, requires careful weight management
    that can depend upon scene. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| WOIT | 低，只需存储每个片段的权重和颜色。 | 快速，因为只需要单次遍历 | 低精度，需要仔细管理权重，这可能会依赖于场景。 |'
- en: Table 5.1 – Comparison of various techniques
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 各种技术的比较
- en: We hope *Table 5.1* will help you decide which technique to use based upon your
    use case.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望表5.1能帮助你根据你的用例决定使用哪种技术。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Please see following link for more details on WOIT:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下链接以获取有关WOIT的更多详细信息：
- en: 'WOIT: https://jcgt.org/published/0002/02/09/'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'WOIT: https://jcgt.org/published/0002/02/09/'
