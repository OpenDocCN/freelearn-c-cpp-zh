<html><head></head><body>
		<div id="_idContainer050">
			<h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor108"/>5</h1>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor109"/>Making an Online Quiz Game</h1>
			<p>In this chapter, we will dive into the fascinating realm of creating an online quiz game using the powerful Network API offered by Godot Engine 4.0. We will explore how to leverage Godot Engine’s Network API to create an engaging and interactive quiz game that can be played with friends or strangers online. We will cover the fundamental concepts of online multiplayer game development, including client-server architecture, game synchronization, and <span class="No-Break">player interactions.</span></p>
			<p>Here, we won’t go through the game design aspects of this type of game: scoring, managing incentives, balancing, and so on; instead, we are going to focus on the engineering side of the equation: how to sync answers, prevent players from answering when another player has already answered, update question data for both players, and <span class="No-Break">so on.</span></p>
			<p>We will start by setting up the server side of the quiz game, including creating a dedicated server that can handle incoming connections and answers from multiple clients. We will then move on to designing the gameplay’s core functionalities, including handling player input, and managing answers and quiz questions, while also handling communication between the clients and <span class="No-Break">the server.</span></p>
			<p>Throughout this chapter, we will learn how to use Godot Engine’s <strong class="bold">RPCs</strong> to manage connections, handle data synchronization, and implement real-time multiplayer gameplay mechanics. We will also cover topics such as managing the <span class="No-Break">game state.</span></p>
			<p>We will cover the following topics in <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>Introducing the online <span class="No-Break">quiz game</span></li>
				<li>Setting up a lobby for the <span class="No-Break">quiz game</span></li>
				<li>Implementing <span class="No-Break">online turns</span></li>
				<li>Turning local mechanics into <span class="No-Break">remote gameplay</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how to create an online quiz game using Godot Engine 4.0’s Network API. You will have learned the key concepts and techniques to make online asynchronous games, including server-side setup, client-side implementation, and network communication. The following screenshot showcases the end result of our online <span class="No-Break">quiz game:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 5.1 – The online quiz gameplay screen displaying a question and its options" src="image/Figure_05.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The online quiz gameplay screen displaying a question and its options</p>
			<p>In the next section, we are going to discuss the components of the quiz game so that we can pinpoint where we, as network engineers, have to implement the necessary features to turn the local multiplayer version of the game into an online <span class="No-Break">multiplayer one.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor110"/>Introducing the online quiz game</h1>
			<p>Welcome, network engineer! Our <a id="_idIndexMarker149"/>studio needs you to turn our quiz game into an online multiplayer experience! We have already gone through various challenges to create a captivating quiz game. Now, it’s time to take it to the next level by adding online <span class="No-Break">multiplayer functionality.</span></p>
			<p>Imagine players from around the world competing against each other in real time, testing their knowledge and skills. In this chapter, you’ll dive into the world of networking in game development and learn how to implement multiplayer features using GDScript. So, let’s get started and make our quiz game an unforgettable <span class="No-Break">multiplayer experience!</span></p>
			<p>One of the <a id="_idIndexMarker150"/>key features of our online multiplayer quiz game is the dynamic loading of questions from a JSON database. Each question in the database contains all the necessary data, such as the question itself and four alternatives for players to choose from. Only one of the alternatives is the correct answer, and this information is stored in the database as well, ensuring fair and <span class="No-Break">consistent gameplay.</span></p>
			<p>To provide a simple and intuitive user interface, our game features four buttons, each representing an answer to the question displayed on the screen. A panel with a label displays game messages, including the current question that players must answer to score in the round. The game’s interface is designed to provide a seamless experience for players as they navigate through the questions <span class="No-Break">and answers.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 5.2 – The quiz screen displaying the round’s question and available answers" src="image/Figure_05.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The quiz screen displaying the round’s question and available answers</p>
			<p>As players correctly answer questions, they progress through the rounds. When a player wins a round, the game updates the question and answer options, ensuring that players are constantly challenged with new questions. The game continues until there are no more questions left to answer, making for an engaging and competitive <span class="No-Break">multiplayer experience.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 5.3 – The quiz screen displaying the round winner" src="image/Figure_5.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The quiz screen displaying the round winner</p>
			<p>In the <a id="_idIndexMarker151"/>next section, we will delve into the lobby of our quiz game. We will explore how to create a seamless multiplayer lobby system, allowing players to join games and compete in a fun and engaging <span class="No-Break">multiplayer environment.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor111"/>Setting up a lobby for the quiz game</h1>
			<p>In the <a id="_idIndexMarker152"/>upcoming section, we will be delving into the process of setting up a lobby for our quiz game. The <strong class="source-inline">QuizLobby</strong> scene serves as the hub for players to interact and prepare for <span class="No-Break">the game.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 5.4 – The login screen displaying the username and password fields and the players in the match" src="image/Figure_5.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The login screen displaying the username and password fields and the players in the match</p>
			<p>The process of authenticating players is similar to what we have done in previous chapters, utilizing data submitted by players and matching it against <strong class="source-inline">FakeDatabase</strong>. This ensures that only registered players with valid credentials are allowed to access <span class="No-Break">the lobby.</span></p>
			<p>Once a player successfully logs in, their name will appear for other players, providing visibility of the players currently present in the lobby. You can optionally add the previous chat to this scene as well to allow players to interact before the match starts. This will create a sense of community and allow players to connect and interact with each other while waiting for the game <span class="No-Break">to start.</span></p>
			<p>The <strong class="source-inline">QuizLobby</strong> scene is<a id="_idIndexMarker153"/> similar to our previous lobbies. So, in this section, we are going to focus on the core features it adds on top of the lobby we created in <a href="B18527_03.xhtml#_idTextAnchor065"><em class="italic">chapter 3</em></a>, <em class="italic">Making a Lobby to Gather </em><span class="No-Break"><em class="italic">Players Together</em></span><span class="No-Break">.</span></p>
			<p>In the following section, we will create and understand the additional features in this new lobby iteration. For that, open the script at <strong class="source-inline">res://05.quiz-online/QuizLobby.gd</strong> and move on to the <span class="No-Break"><strong class="source-inline">add_logged_player()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor112"/>Displaying new players</h2>
			<p>One of the <a id="_idIndexMarker154"/>new features we will have in this updated lobby is the ability to see all the players who joined the current match. To implement that, let’s take the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Inside the <strong class="source-inline">add_logged_player()</strong> method, set the <strong class="source-inline">logged_players_label.text</strong> property to <strong class="source-inline">player_name</strong>; this function receives an argument. The resulting text should append the <strong class="source-inline">player_name</strong> below the current content. For that, we concatenate the string with a placeholder string that skips a line and formats the placeholder <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">player_name</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc
func add_logged_player(player_name):
    logged_players_label.text = logged_players_
        label.text + "\n%s" % player_name</pre></li>				<li>After that, move on to the <strong class="source-inline">start_game()</strong> method and add the <strong class="source-inline">"authority"</strong> and <strong class="source-inline">"call_local"</strong> options to the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">rpc</strong></span><span class="No-Break"> annotation:</span><pre class="source-code">
@rpc("authority", "call_local")
func start_game():
    pass</pre></li>				<li>Then, inside the function, let’s tell the SceneTree to change the current scene to <strong class="source-inline">quiz_screen_scene</strong>, which is a variable that points <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">QuizScreenClient.tscn</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc("authority", "call_local")
func start_game():
    get_tree().change_scene_to_file(quiz_screen_scene)</pre></li>				<li>Finally, on<a id="_idIndexMarker155"/> the <strong class="source-inline">_on_StartButton_pressed()</strong> callback, we will make a direct RPC to the multiplayer authority’s <strong class="source-inline">start_game()</strong> method without calling <span class="No-Break">it locally:</span><pre class="source-code">
func _on_StartButton_pressed():
    rpc_id(get_multiplayer_authority(), "start_game")</pre></li>			</ol>
			<p>In game development, ensuring fair gameplay and providing an enjoyable experience for players are critical aspects of creating a successful game. This involves implementing various features and functionalities that make the game engaging and dynamic. One such feature is adding a player to the match when they join the game. This can be achieved by creating a panel that displays the names of all the players currently participating in <span class="No-Break">the game.</span></p>
			<p>In a multiplayer game, communication between the server and clients is crucial. It’s essential to ensure that only authorized entities can perform specific actions. This ensures that the game’s mechanics and flow are consistent and reliable for <span class="No-Break">all players.</span></p>
			<p>Finally, once all the players are in the game, and the match is about to begin, the next step is to move them and the server to the next game screen. This screen will display all the necessary information about the game, such as the objective, rules, and <span class="No-Break">game mechanics.</span></p>
			<p>This ensures that all the players are on the same page and know what to expect from the game. Overall, implementing these features ensures that the game runs smoothly and that the players have a positive <span class="No-Break">gaming experience.</span></p>
			<p>With that, every time <a id="_idIndexMarker156"/>a player joins the match, their name will be added to the <strong class="bold">Players in Match</strong> panel. Note that regarding the <strong class="source-inline">start_game()</strong> method, only the multiplayer authority can make a remote call to it, right? We are about to see something new in <span class="No-Break">a moment.</span></p>
			<p>On the server side, we will have a different implementation of this method. In the upcoming section, we will see how the match actually starts and why we move all players and the server to the next <span class="No-Break">game scre<a id="_idTextAnchor113"/>en.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor114"/>Starting the match</h2>
			<p>This implementation works that <a id="_idIndexMarker157"/>way to prevent one player from calling the <strong class="source-inline">start_game()</strong> method on the other players, or on itself, without other players also starting the game. The idea is that the player who presses the <strong class="bold">Start</strong> button will ask the multiplayer authority to start <span class="No-Break">the game.</span></p>
			<p>In turn, the multiplayer authority, which is the server in this case, will tell every player to also start the match. It does that by calling the <strong class="source-inline">start_game()</strong> method on each player. Let’s see how this <span class="No-Break">is done:</span></p>
			<ol>
				<li>Open the script at <strong class="source-inline">res://05.online-quiz/QuizServer.gd</strong> and find the <span class="No-Break"><strong class="source-inline">start_game()</strong></span><span class="No-Break"> method.</span></li>
				<li>In the <strong class="source-inline">@rpc</strong> annotation line, add the <strong class="source-inline">"any_peer"</strong> and the <strong class="source-inline">"call_remote"</strong> options. This will allow any peer on the network to make a remote call to <span class="No-Break">this method:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func start_game():</pre></li>				<li>Then, tell the SceneTree to change to <strong class="source-inline">quiz_screen_scene_path</strong> using the <strong class="source-inline">get_tree().change_scene_to_file()</strong> method. This will tell the server to also update its context to the one in the <strong class="source-inline">QuizScreenServer</strong> scene. This will be necessary for the actual game <span class="No-Break">to run:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func start_game():
get_tree().change_scene_to_file(quiz_screen_scene_path)</pre></li>				<li>Finally, and <a id="_idIndexMarker158"/>most importantly, make an RPC call to other peers’ <strong class="source-inline">start_game</strong> method, so everyone in the network moves on to their respective <span class="No-Break"><strong class="source-inline">QuizScreenClient</strong></span><span class="No-Break"> scene:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func start_game():
    get_tree().change_scene_to_file
        (quiz_screen_scene_path)
    rpc("start_game")</pre></li>			</ol>
			<p>The lobby system is <a id="_idIndexMarker159"/>a vital component of any online multiplayer game, as it serves as the gateway for players to connect and prepare for the match. In our quiz game, we have successfully implemented the lobby system using Godot’s built-in <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) functionality. This<a id="_idIndexMarker160"/> feature allows us to establish a reliable two-way communication channel between the client and server, ensuring that all players are <span class="No-Break">in sync.</span></p>
			<p>With the lobby system in place, players can join the match and their names will be added to the <strong class="bold">Players in Match</strong> panel. It is important to note that the <strong class="source-inline">start_game()</strong> method can only be called by the multiplayer authority, preventing unauthorized calls and ensuring the integrity of the game. The server-side implementation of this method will be different, and we will explore this in the <span class="No-Break">upcoming section.</span></p>
			<p>If you want to add more features to the lobby system, you can create a countdown timer similar to the ones found in games such as <em class="italic">Warcraft III: Reign of Chaos</em>. This feature adds excitement and anticipation to the match and can help players prepare mentally for the upcoming game. However, for our quiz game, we are ready to move on to the <span class="No-Break">next step.</span></p>
			<p>With that, we have the lobby part of our quiz game ready to gather some players together and set them up, ready to start the match. We saw how to use the options that Godot provides for the <strong class="source-inline">@rpc</strong> annotation to create a two-sided communication that we can use to sync players and move them all together to the <span class="No-Break">actual game.</span></p>
			<p>The lobby system is <a id="_idIndexMarker161"/>a crucial part of any online multiplayer game, and we have successfully implemented it in our quiz game using Godot’s built-in RPC functionality. The system allows players to join the match and sync their data with the server, ensuring that the game is fair and consistent. While we can add more features to the lobby system, such as a countdown timer, we are now ready to move on to the next stage <span class="No-Break">of development.</span></p>
			<p>In the next section, we are going to create a mechanism to disable players’ actions when another player has already selected the correct answer. With that, you can even create a <em class="italic">turn-based</em> mechanism if you want, which is what we are going to do in <a href="B18527_06.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Building an Online </em><span class="No-Break"><em class="italic">Checke<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/>rs Game</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor117"/>Implementing online turns</h1>
			<p>When designing a quiz <a id="_idIndexMarker162"/>game, it’s important to ensure that players can only provide one answer to a given question. This can be especially challenging when creating a multiplayer game, as multiple players may attempt to answer the question at the <span class="No-Break">same time.</span></p>
			<p>To prevent this, it’s necessary to implement a system that disables players’ ability to answer the question once a valid answer has been provided by <span class="No-Break">another player.</span></p>
			<p>One common approach to implementing this system is to disable the buttons representing the potential answers once a player has provided a response. This can be accomplished using code that identifies which button was pressed and compares it to the correct answer stored in the game’s database. Once an answer has been identified, the code can disable the buttons and prevent other players from answering <span class="No-Break">the question.</span></p>
			<p>To further improve the player experience, it’s also common to include a brief pause after an answer has been provided. During this time, players can review the questions and answers, and the game can display feedback on whether the answer was correct or not. This can help to build tension and excitement in the game, while also giving players a chance to reflect on their performance and improve <span class="No-Break">their skills.</span></p>
			<p>We need to prevent players’ from answering the same question after another player already answered it. To do that, we can disable the buttons that represent answers once a valid response is provided. And for a better experience, we can add a brief pause before changing to the <span class="No-Break">next question.</span></p>
			<p>In this section, we are going to understand how we can prevent players’ actions, ultimately creating a <span class="No-Break">pseudo-turn-based mechanism.</span></p>
			<p>Let’s understand how to<a id="_idIndexMarker163"/> achieve that <span class="No-Break">pseudo-turn-based mechanism:</span></p>
			<ol>
				<li>Open the <strong class="source-inline">res://05.online-quiz/QuizScreenServer.gd</strong> script and let’s implement its <span class="No-Break">main methods.</span></li>
				<li>First of all, let’s add <strong class="source-inline">"any_peer"</strong> to the <strong class="source-inline">answered()</strong> method’s <strong class="source-inline">@rpc</strong> annotation. This will allow any player to trigger the behavior we are about to describe when they answer a <span class="No-Break">question correctly.</span></li>
				<li>Inside the <strong class="source-inline">answered()</strong> method, we will tell <strong class="source-inline">quiz_panel</strong> to update the round’s winner, making an RPC to the <strong class="source-inline">"update_winner"</strong> method and passing the player’s name, which is stored in the database. This will update every peer’s <strong class="source-inline">QuizPanel</strong> about the <span class="No-Break">round’s winner:</span><pre class="source-code">
@rpc("any_peer")
func answered(user):
    quiz_panel.rpc("update_winner", database[user]
        ["name"])</pre></li>				<li>Then, we start a local timer that should wait for enough time to allow players to digest the round’s winner. We also make an RPC on <strong class="source-inline">wait_label</strong> so everyone’s <strong class="source-inline">WaitLabel</strong> displays the correct waiting time <span class="No-Break">as well:</span><pre class="source-code">
@rpc("any_peer")
func answered(user):
    quiz_panel.rpc("update_winner", database[user]
        ["name"])
    timer.start(turn_delay_in_seconds)
    wait_label.rpc("wait", turn_delay_in_seconds)</pre></li>				<li>Now let’s do the same thing on the <strong class="source-inline">missed()</strong> method. But we will make an RPC to <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">player_missed"</strong></span><span class="No-Break"> instead:</span><pre class="source-code">
@rpc("any_peer")
func missed(user):
    quiz_panel.rpc("player_missed", database[user]
        ["name"])
    timer.start(turn_delay_in_seconds)
    wait_label.rpc("wait", turn_delay_in_seconds)</pre></li>			</ol>
			<p>With that, <strong class="source-inline">QuizScreenServer</strong> handles both game states when a player wins or loses the round. Using <a id="_idIndexMarker164"/>RPCs, we can update all peers about what’s happening in the game and set them ready for the next round. But we haven’t seen how this actually works yet. Coming next, let’s see what happens in <strong class="source-inline">QuizPanel</strong> when we call the <strong class="source-inline">update_winner()</strong> and <span class="No-Break"><strong class="source-inline">player_missed()</strong></span><span class="No-Break"> methods.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor118"/>Updating players about the round</h2>
			<p>In a multiplayer quiz <a id="_idIndexMarker165"/>game, it’s crucial to keep all players in sync with the game state, especially when someone has already answered a question correctly. The <strong class="source-inline">QuizScreenServer</strong> Main node is responsible for updating the game state and informing all the connected players about what just happened in the current round. To achieve this, the <strong class="source-inline">QuizScreenServer</strong> Main node makes an RPC to all the peers’ QuizPanels. The <strong class="source-inline">QuizPanel</strong> node on each player’s side will update the game state locally and prevent any further interaction until the next <span class="No-Break">round begins.</span></p>
			<p>The implementation of these methods ensures that all players are on the same page, and there are no discrepancies in the game state between players. With this approach, we can provide a fair and consistent gaming experience for all the players in <span class="No-Break">the game.</span></p>
			<p>Open the <strong class="source-inline">res://05.online-quiz/QuizPanel.gd</strong> file and let’s implement the <strong class="source-inline">update_winner()</strong> and <strong class="source-inline">player_missed()</strong> methods, together with their auxiliary methods as well, such as <strong class="source-inline">lock_answers()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">unlock_answers()</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>Find the <strong class="source-inline">update_winner()</strong> method and add the <strong class="source-inline">"call_local"</strong> option to its <strong class="source-inline">@rpc</strong> annotation. We do that because when we make this RPC on the server, it should also update its own <strong class="source-inline">QuizPanel</strong> node <span class="No-Break">as well:</span><pre class="source-code">
@rpc("call_local")
func update_winner(winner_name):</pre></li>				<li>Then, inside the <strong class="source-inline">update_winner()</strong> method, update the <strong class="source-inline">question_label.text</strong> property to display a message <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">winner_name</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc("call_local")
func update_winner(winner_name):
    question_label.text = "%s won the round!!" %
        winner_name</pre></li>				<li>Finally, we will <a id="_idIndexMarker166"/>make a call to the <strong class="source-inline">lock_answers()</strong> method. This will make players wait for the next round, as we’ll <span class="No-Break">see soon:</span><pre class="source-code">
@rpc("call_local")
func update_winner(winner_name):
    question_label.text = "%s won the round!!" %
        winner_name
    lock_answers()</pre></li>				<li>We can do the exact same thing in the <strong class="source-inline">player_missed()</strong> method. But here, we’ll display a different message, communicating that the player missed <span class="No-Break">the answer:</span><pre class="source-code">
@rpc("call_local")
func player_missed(loser_name):
    question_label.text = "%s missed the question!!" %
        loser_name
    lock_answers()</pre><p class="list-inset">With that, we have our user interface updating the players about their peers’ actions. If a player answered right, they will know it, if a player answered wrong, they will know it. Now is the time to get them ready for the next round. Let’s look at the <strong class="source-inline">lock_answers()</strong> and <span class="No-Break"><strong class="source-inline">unlock_answers()</strong></span><span class="No-Break"> methods.</span></p></li>				<li>In the <strong class="source-inline">lock_answers()</strong> method, we are going to run through all <strong class="source-inline">AnswerButtons</strong>, which are children of the <strong class="source-inline">Answers</strong> node, and disable them. This way, players won’t be able to interact with these buttons anymore, preventing them from answering <span class="No-Break">the question:</span><pre class="source-code">
func lock_answers():
    for answer in answer_container.get_children():
        answer.disabled = true</pre></li>				<li>We do the opposite in the <strong class="source-inline">unlock_answers()</strong> method, toggling off the disabled property on <a id="_idIndexMarker167"/>each <span class="No-Break"><strong class="source-inline">AnswerButton</strong></span><span class="No-Break"> node:</span><pre class="source-code">
func unlock_answers():
    for answer in answer_container.get_children():
        answer.disabled = false</pre></li>			</ol>
			<p>This will prevent and allow player interactions with the available answers to the current question. We can use this same approach to create an actual turn-based system where players take turns trying to answer one question at a time. Here’s a challenge for you, our network engineer. As an exercise, implement a turn-based system using the knowledge you just acquired. You have everything necessary at <span class="No-Break">your disposal.</span></p>
			<p>A turn-based system is a way of structuring gameplay where each player takes a turn to make their move, before passing control to the next player. This is in contrast to real-time gameplay, where all players are acting at the same time. Turn-based systems are often used in strategy games, where players need to carefully plan <span class="No-Break">their moves.</span></p>
			<p>To implement a turn-based system in your quiz game, you will need to modify the existing code to add a new layer of logic. One approach would be to create a queue of players, with each player taking their turn in order. When it’s a player’s turn, they are allowed to answer the question, while the other players are locked out. Once they have answered, their turn is over, and the next player in the queue takes <span class="No-Break">their turn.</span></p>
			<p>To create this system, you <a id="_idIndexMarker168"/>could turn <strong class="source-inline">lock_answer()</strong> and <strong class="source-inline">unlock_answer()</strong> into RPC methods and use the <strong class="source-inline">rpc_id()</strong> method to directly lock or unlock the players’ answer options based on whether they are the current <span class="No-Break">active player.</span></p>
			<p>In the next section, we’ll understand how we can take the fundamental mechanics of a quiz game and make them work in an online context. It’s going to be the core of this chapter as we will see how we evaluate whether the player answered the question correctly and how we load new questions, ensuring that all peers are looking at the<a id="_idTextAnchor119"/><a id="_idTextAnchor120"/> <span class="No-Break">same question.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor121"/>Turning local mechanics into remote gameplay</h1>
			<p>Now that we <a id="_idIndexMarker169"/>can manage players’ interactions and communicate the game state to players, it’s time to implement the core features of a quiz. Coming up, we are going to implement the questions and answers. For that, we are going to use a questions database where we store them with their possible answers and the correct <span class="No-Break">answer index.</span></p>
			<p>Here, we will see how we load and deserialize these questions into <strong class="source-inline">QuizPanel</strong>. On top of that, we’ll also understand how we make use of RPCs to keep everyone in sync. And of course, we will also implement the logic behind both when players choose the correct and the <span class="No-Break">incorrect answer.</span></p>
			<p>When a player chooses an answer, we need to compare it with the correct answer index, and if it’s correct, we should notify <strong class="source-inline">QuizScreenServer</strong> about the correct answer. We’ll also need to make use of RPCs to keep everyone in sync regarding the current question and <span class="No-Break">answer status.</span></p>
			<p>Moreover, we need to implement the logic behind what happens when a player chooses the incorrect answer. We can use the same locking mechanism that we used previously to prevent players from answering if someone has already provided a valid answer. Once we handle the incorrect answer, we need to notify <strong class="source-inline">QuizScreenServer</strong> about the incorrect answer and move on to the <span class="No-Break">next round.</span></p>
			<p>By implementing all of<a id="_idIndexMarker170"/> these features, we can create a robust and engaging quiz game that can be played by multiple players simultaneously. By using the database to load questions, we can make the game dynamic and varied. And by using RPCs and locking mechanisms, we can ensure that the game runs smoothly and that everyone is on the <span class="No-Break">same page.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor122"/>Understanding the questions database</h2>
			<p>First of all, let’s start by taking<a id="_idIndexMarker171"/> a look at our questions database. Open the file at <strong class="source-inline">res://05.online-quiz/QuizQuestions.json</strong>. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
    "question_01":
        {
            "text": "Which of the following is not a
                Node?",
            "alternatives": ["Sprite2D", "Line2D",
                "Area3D", "PackedScene"],
            "correct_answer_index" : 3
        },
    "question_02":
        {
            "text": "Which of the following is an image
                file?",
            "alternatives": ["Bot.png", "Landscape.txt",
                "BeautifulTown.json", "UglyDuck.md"],
            "correct_answer_index" : 0
        },
    "question_03":
        {
            "text": "Which of the following is a sound
                file?",
            "alternatives": ["Scream.txt", "Blabla.ogg",
                "Laser.gd", "Music.svg"],
            "correct_answer_index": 1
        }
}</pre>			<p>Notice that we represent each question as a <em class="italic">key</em> that is also a dictionary. Each question has three keys as well: <strong class="source-inline">"text"</strong>, <strong class="source-inline">"alternatives"</strong>, and <strong class="source-inline">"correct_answer_index"</strong>. The <strong class="source-inline">"text"</strong> key is the actual question statement, <strong class="source-inline">"alternatives"</strong> is an array of possible answers that we will turn into <strong class="source-inline">AnswerButtons</strong>, and <strong class="source-inline">"correct_answer_index"</strong> is the index in the <strong class="source-inline">"alternatives"</strong> array of the <span class="No-Break">correct answer.</span></p>
			<p>Knowing that, you <a id="_idIndexMarker172"/>can go ahead and create some questions on your own. Keep in mind that, by default, we have four <strong class="source-inline">AnswerButtons</strong>, so try to provide four values in the <strong class="source-inline">"alternatives"</strong> key. Otherwise, you’d need to implement an <strong class="source-inline">AnswerButtons</strong> factory to dynamically create them based on how many answers we load<a id="_idTextAnchor123"/> from <span class="No-Break">the question.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor124"/>Loading and updating questions</h2>
			<p>Now, let’s understand <a id="_idIndexMarker173"/>how this process works under the hood of <strong class="source-inline">QuizPanel</strong>. Open the script at <strong class="source-inline">res://05.online-quiz/QuizPanel.gd</strong> and find the <strong class="source-inline">update_question()</strong> method. The first thing you’ll notice is that it has an <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">rpc</strong></span><span class="No-Break"> annotation.</span></p>
			<p>This is because we design it in such a way that it’s the server who calls it and tells it which question to load. We will see that in a moment, but for now, let’s implement this <span class="No-Break">method’s logic:</span></p>
			<ol>
				<li>Create a variable called <strong class="source-inline">question</strong> and set it equal to the result of calling the <strong class="source-inline">pop_at()</strong> method on <strong class="source-inline">available_questions</strong> with the <strong class="source-inline">new_question_index</strong> argument passed in. With that, we’ll remove the current question from the list of available questions and store it so we can use it <span class="No-Break">moving on:</span><pre class="source-code">
func update_question(new_question_index):
    var question = available_questions.pop_at
        (new_question_index)</pre></li>				<li>Check whether the question is not equal to null. Since the <strong class="source-inline">pop_at()</strong> method returns <strong class="source-inline">null</strong> when it can’t find a value in the index provided, we check that to know if there are still questions that we didn’t use yet, in other words, if <strong class="source-inline">available_questions</strong> <span class="No-Break">is empty:</span><pre class="source-code">
    if not question == null:</pre></li>				<li>If the question we got is not null, set the <strong class="source-inline">question_label.text</strong> property to the <strong class="source-inline">'text'</strong> property of the question dictionary stored in the questions array. This is how we display the <span class="No-Break">question’s statement:</span><pre class="source-code">
    question_label.text = questions[question]['text']</pre></li>				<li>Create a variable called <strong class="source-inline">correct_answer</strong> and set its value to the <strong class="source-inline">'correct_answer_index'</strong> property of the question dictionary stored in the questions array. Doing that, we keep the correct answer stored so we can compare it when <span class="No-Break">players answer:</span><pre class="source-code">
    correct_answer = questions[question]
        ['correct_answer_index']</pre></li>				<li>Loop through the <a id="_idIndexMarker174"/>numbers <strong class="source-inline">0</strong> through <strong class="source-inline">3</strong>, inclusive, using the <strong class="source-inline">range()</strong> function and the <strong class="source-inline">for</strong> loop. For each iteration, create a variable called <strong class="source-inline">alternative</strong> and set it equal to <strong class="source-inline">i</strong>, which is the current element of the <strong class="source-inline">'alternatives'</strong> array stored in the question dictionary. Set the text of the current child node of the <strong class="source-inline">answer_container</strong> node to <strong class="source-inline">alternative</strong>. With that, we display the alternative’s text on its <span class="No-Break">respective </span><span class="No-Break"><strong class="source-inline">AnswerButton</strong></span><span class="No-Break">:</span><pre class="source-code">
    for i in range(0, 4):
        var alternative = questions[question]
            ['alternatives'][i]
        answer_container.get_child(i).text =
            alternative</pre></li>				<li>After loading<a id="_idIndexMarker175"/> the question and its answers, let’s call the <strong class="source-inline">unlock_answers()</strong> function. This basically starts the current round, allowing players to interact with <span class="No-Break"><strong class="source-inline">QuizPanel</strong></span><span class="No-Break"> again:</span><pre class="source-code">
        unlock_answers()</pre></li>				<li>If <strong class="source-inline">question</strong> is <strong class="source-inline">null</strong>, meaning we don’t have any questions left to play the quiz, we need to loop through each child node of the <strong class="source-inline">answer_container</strong> node using the <strong class="source-inline">for</strong> loop. For each iteration, we’ll set the text of the <strong class="source-inline">question_label</strong> node to <strong class="source-inline">'No </strong><span class="No-Break"><strong class="source-inline">more questions'</strong></span><span class="No-Break">:</span><pre class="source-code">
    else:
        for answer in answer_container.get_children():
            question_label.text = "No more questions"</pre></li>				<li>Since we reached the end of our quiz match, we can call the <strong class="source-inline">lock_answers()</strong> function to prevent any <span class="No-Break">further interactions:</span><pre class="source-code">
            lock_answers()</pre></li>			</ol>
			<p>After these steps, the <strong class="source-inline">update_question()</strong> method should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
@rpc
func update_question(new_question_index):
    var question = available_questions.pop_at
        (new_question_index)
    if not question == null:
        question_label.text = questions[question]['text']
        correct_answer = questions[question]
            ['correct_answer_index']
        for i in range(0, 4):
            var alternative = questions[question]
                ['alternatives'][i]
            answer_container.get_child(i).text =
                alternative
        unlock_answers()
    else:
        for answer in answer_container.get_children():
            question_label.text = "No more questions"
        lock_answers()</pre>			<p>With that, we have our main<a id="_idIndexMarker176"/> quiz mechanism set up. We can pick one of the questions we have in our database and display it to our players. You can check the <strong class="source-inline">_ready()</strong> callback to understand how we load the questions in memory and assign them to the <span class="No-Break"><strong class="source-inline">available_questions</strong></span><span class="No-Break"> variable.</span></p>
			<p>As mentioned before, we are going to focus on the essentials here. Talking about the essentials, we are still missing one mechanic, which is how we validate the answers, right? Find the <strong class="source-inline">evaluate_answer()</strong> method and let’s <span class="No-Break">implement that:</span></p>
			<ol>
				<li>Inside the <strong class="source-inline">evaluate_answer()</strong> method, create a variable called <strong class="source-inline">is_answer_correct</strong> and set it equal to the comparison between the <strong class="source-inline">answer_index</strong> and <strong class="source-inline">correct_answer</strong> variables. This will check whether the given answer index matches the index of the <span class="No-Break">correct answer:</span><pre class="source-code">
    var is_answer_correct = answer_index == correct_answer</pre></li>				<li>Emit a signal called <strong class="source-inline">answered</strong> with the <strong class="source-inline">is_answer_correct</strong> variable as an argument. This signal will be used by other parts of the quiz to tell whether the player’s answer was correct <span class="No-Break">or not:</span><pre class="source-code">
    answered.emit(is_answer_correct)</pre><p class="list-inset">In the end, our <strong class="source-inline">evaluate_answer()</strong> method is quite simple and does just what we need to know whether the player answered the current <span class="No-Break">question correctly:</span></p><pre class="source-code">func evaluate_answer(answer_index):
    var is_answer_correct = answer_index == correct_answer
    answered.emit(is_answer_correct)</pre></li>			</ol>
			<p>You may have noticed<a id="_idIndexMarker177"/> that the <strong class="source-inline">evaluate_answer()</strong> method isn’t an RPC function, right? It essentially emits a signal that tells us whether the player’s answer was correct or not. So how does the server <span class="No-Break">manage that?</span></p>
			<p>In the upcoming section, we will understand how this information is passed around between the client and the server impl<a id="_idTextAnchor125"/>ementations of <span class="No-Break">our quiz.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor126"/>Sending players’ answers to the server</h2>
			<p>Now, let’s understand the<a id="_idIndexMarker178"/> final piece of our mechanics and how it behaves in a multiplayer network. In the previous section, we ended up with an evaluation of the player’s answer that led to the emission of the <span class="No-Break"><strong class="source-inline">answered</strong></span><span class="No-Break"> signal.</span></p>
			<p>The <strong class="source-inline">answered</strong> signal needs to be handled in a specific way to ensure that all players are kept in sync and that the game state is consistent across all peers. When a player submits their answer, the <strong class="source-inline">answered</strong> signal is emitted, and the server updates all peers about it through an <span class="No-Break">RPC call.</span></p>
			<p>The <strong class="source-inline">answered</strong> signal and its associated methods are crucial for maintaining the integrity of the game state across all players in a multiplayer network. Without them, players might see different game states and have different experiences, which would make the game less enjoyable and <span class="No-Break">potentially unfair.</span></p>
			<p>In this section, we will understand how this signal propagates through the network and updates all peers about the <span class="No-Break">players’ answers.</span></p>
			<p>Open the <strong class="source-inline">res://05.online-quiz/QuizScreenClient.gd</strong> script and you will notice that, right at the beginning, we have a callback to the <span class="No-Break"><strong class="source-inline">QuizPanel.answered</strong></span><span class="No-Break"> signal.</span></p>
			<p>Let’s implement <span class="No-Break">this callback:</span></p>
			<ol>
				<li>Inside the method’s body, use an <strong class="source-inline">if</strong> statement to check whether <strong class="source-inline">is_answer_correct</strong> <span class="No-Break">is true:</span><pre class="source-code">
func _on_quiz_panel_answered(is_answer_correct):
    if is_answer_correct:</pre></li>				<li>If <strong class="source-inline">is_answer_correct</strong> is <strong class="source-inline">true</strong>, make an RPC call to the answered method on the server using the <strong class="source-inline">rpc_id()</strong> method. With that, the server will update all peers about<a id="_idIndexMarker179"/> the <span class="No-Break">round winner:</span><pre class="source-code">
func _on_quiz_panel_answered(is_answer_correct):
    if is_answer_correct:
       rpc_id(
           get_multiplayer_authority(),
           "answered",
           AuthenticationCredentials.user
       )</pre></li>				<li>If <strong class="source-inline">is_answer_correct</strong> is <strong class="source-inline">false</strong>, make an RPC call to the missed method on the server using the <strong class="source-inline">rpc_id()</strong> method. Finally, if the player chose the wrong answer, the server updates all peers <span class="No-Break">about it:</span><pre class="source-code">
    else:
       rpc_id(
           get_multiplayer_authority(),
           "missed",
           AuthenticationCredentials.user
       )</pre></li>			</ol>
			<p>The whole <strong class="source-inline">_on_quiz_panel_answered()</strong> implementation should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func _on_quiz_panel_answered(is_answer_correct):
    if is_answer_correct:
       rpc_id(
           get_multiplayer_authority(),
           "answered",
           AuthenticationCredentials.user
       )
    else:
       rpc_id(
           get_multiplayer_authority(),
           "missed",
           AuthenticationCredentials.user
       )</pre>			<p>With that, the client <a id="_idIndexMarker180"/>implementation will notify the server about the players’ interactions. In turn, the server will update the game state and tell all peers to also update their game states to match the server’s. After that, we have the missing network pieces in place and our online quiz game is ready. Feel free to test it out and expe<a id="_idTextAnchor127"/><a id="_idTextAnchor128"/>riment with <span class="No-Break">more questions!</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor129"/>Summary</h1>
			<p>In this chapter, we saw how to create an online quiz game using the Godot Engine 4.0 Network API. We covered the fundamental concepts of online multiplayer game development, including client-server architecture, game synchronization, and player interactions. Using the quiz game, we saw how to feature dynamic loading of questions from a JSON database, and how to display the current players in a quiz match. We created a mechanism to prevent players from answering questions when another player has already provided one, creating a pseudo-turn-based mechanism. Finally, we saw how to manage players’ interactions and communicate the game state to players and how to implement the logic behind both correct and incorrect answers, loading new questions one round after another until there are no more questions <span class="No-Break">to display.</span></p>
			<p>In the next chapter’s projects, we will dive deeper into implementing a turn-based mechanism for our online quiz game. As we saw in this chapter, we can use a similar approach to what we did with the pseudo-turn-based mechanism, but with some modifications to make it a true <span class="No-Break">turn-based system.</span></p>
			<p>Additionally, we will explore how to pass information about players’ turns, such as who is currently taking their turn, what happened during the opponent’s turn, and more. We will also learn how to set up win and lose conditions and update peers about them, which will be essential for creating a sense of accomplishment<a id="_idTextAnchor130"/> and challenge in <span class="No-Break">our game.</span></p>
			<p>By the end of the next chapter, you will have a deeper understanding of the game development process, including how to create engaging online multiplayer game mechanics and implement them using the Godot Engine 4.0 Network API. See <span class="No-Break">you there!</span></p>
		</div>
	</body></html>