["```cpp\n// Assume Person class exists with its usual implementation\nclass Student: public Person  // Notice that Student is now\n{                             // an abstract class\nprivate:\n    float gpa = 0.0;  // in-class initialization\n    string currentCourse;\n    const string studentId;\n    static int numStudents;\npublic:\n    Student();  // default constructor\n    Student(const string &, const string &, char, \n       const string &, float, const string &, \n       const string &);\n    Student(const Student &);  // copy constructor\n    ~Student() override;  // virtual destructor\n    float GetGpa() const { return gpa; }\n    const string &GetCurrentCourse() const \n       { return currentCourse; }\n    const string &GetStudentId() const \n       { return studentId; }\n    void SetCurrentCourse(const string &); // proto. only\n    void Print() const override;\n    string IsA() const override { return \"Student\"; }\n    virtual void Graduate() = 0;  // Student is abstract\n    // Create a derived Student type based on degree sought\n    static Student *MatriculateStudent(const string &,\n       const string &, const string &, char, \n       const string &, float, const string &, \n       const string &);\n    static int GetNumStudents() { return numStudents; }\n};\n// Assume all the usual Student member functions exist \n```", "```cpp\nclass GradStudent: public Student\n{\nprivate:\n    string degree;  // PhD, MS, MA, etc.\npublic:\n    GradStudent() = default;// default constructor\n    GradStudent(const string &, const string &, \n       const string &, char, const string &, float, \n       const string &, const string &);\n    // Prototyping default copy constructor isn't necessary\n    // GradStudent(const GradStudent &) = default;\n    // Since the most base class has virt dtor prototyped,\n    // it is not necessary to prototype default destructor\n    // ~GradStudent() override = default; // virtual dtor\n    void EarnPhD();\n    string IsA() const override { return \"GradStudent\"; }\n    void Graduate() override;\n};\n// Assume alternate constructor is implemented\n// as expected. See online code for full implementation.\nvoid GradStudent::EarnPhD()\n{\n    if (!degree.compare(\"PhD\")) // only PhD candidates can \n        ModifyTitle(\"Dr.\");     // EarnPhd(), not MA and MS \n}                               // candidates\nvoid GradStudent::Graduate()\n{   // Here, we can check that the required num of credits\n    // have been met with a passing gpa, and that their \n    // doctoral or master's thesis has been completed.\n    EarnPhD(); // Will change title only if a PhD candidate\n    cout << \"GradStudent::Graduate()\" << endl;\n}\n```", "```cpp\nclass UnderGradStudent: public Student\n{\nprivate:\n    string degree;  // BS, BA, etc\npublic:\n    UnderGradStudent() = default;// default constructor\n    UnderGradStudent(const string &, const string &, \n       const string &, char, const string &, float, \n       const string &, const string &);\n    // Prototyping default copy constructor isn't necessary\n    // UnderGradStudent(const UnderGradStudent &) =default; \n    // Since the most base class has virt dtor prototyped,\n    // it is not necessary to prototype default destructor\n    // ~UnderGradStudent() override = default; // virt dtor\n    string IsA() const override \n       { return \"UnderGradStudent\"; }\n    void Graduate() override;\n};\n// Assume alternate constructor is implemented\n// as expected. See online code for full implementation.\nvoid UnderGradStudent::Graduate()\n{   // Verify that num of credits and gpa requirements have\n    // been met for major and any minors or concentrations.\n    // Have all applicable university fees been paid?\n    cout << \"UnderGradStudent::Graduate()\" << endl;\n}\n```", "```cpp\nclass NonDegreeStudent: public Student\n{\npublic:\n    NonDegreeStudent() = default;  // default constructor\n    NonDegreeStudent(const string &, const string &, char, \n       const string &, float, const string &, \n       const string &);\n    // Prototyping default copy constructor isn't necessary\n    // NonDegreeStudent(const NonDegreeStudent &s)\n    //     =default;\n    // Since the most base class has virt dtor prototyped,\n    // it is not necessary to prototype default destructor\n    // ~NonDegreeStudent() override = default; // virt dtor\n    string IsA() const override  \n       { return \"NonDegreeStudent\"; }\n    void Graduate() override;\n};\n// Assume alternate constructor is implemented as expected.\n// See online code for full implementation.\nvoid NonDegreeStudent::Graduate()\n{   // Check if applicable tuition has been paid. \n    // There is no credit or gpa requirement.\n    cout << \"NonDegreeStudent::Graduate()\" << endl;\n}\n```", "```cpp\n// Creates a Student based on the degree they seek\n// This is a static Student method (keyword in prototype)\nStudent *Student::MatriculateStudent(const string &degree, \n    const string &fn, const string &ln, char mi, \n    const string &t, float avg, const string &course, \n    const string &id)\n{\n    if (!degree.compare(\"PhD\") || !degree.compare(\"MS\") \n        || !degree.compare(\"MA\"))\n        return new GradStudent(degree, fn, ln, mi, t, avg,\n                               course, id);\n    else if (!degree.compare(\"BS\") || \n             !degree.compare(\"BA\"))\n        return new UnderGradStudent(degree, fn, ln, mi, t,\n                                    avg, course, id);\n    else if (!degree.compare(\"None\"))\n        return new NonDegreeStudent(fn, ln, mi, t, avg,\n                                    course, id);\n}\n```", "```cpp\nint main()\n{\n    Student *scholars[MAX] = { }; // init. to nullptrs\n    // Student is now abstract; cannot instantiate directly\n    // Use Factory Method to make derived types uniformly\n    scholars[0] = Student::MatriculateStudent(\"PhD\", \n       \"Sara\", \"Kato\", 'B', \"Ms.\", 3.9, \"C++\", \"272PSU\");\n    scholars[1] = Student::MatriculateStudent(\"BS\", \n       \"Ana\", \"Sato\", 'U', \"Ms.\", 3.8, \"C++\", \"178PSU\");\n    scholars[2] = Student::MatriculateStudent(\"None\", \n       \"Elle\", \"LeBrun\", 'R', \"Miss\", 3.5, \"C++\", \"111BU\");\n    for (auto *oneStudent : scholars)\n    {\n       oneStudent->Graduate();\n       oneStudent->Print();\n    }\n    for (auto *oneStudent : scholars)\n       delete oneStudent;   // engage virt dtor sequence\n    return 0;\n}\n```", "```cpp\nGradStudent::Graduate()\n  Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++\nUnderGradStudent::Graduate()\n  Ms. Ana U. Sato with id: 178PSU GPA:  3.8 Course: C++\nNonDegreeStudent::Graduate()\n  Miss Elle R. LeBrun with id: 111BU GPA:  3.5 Course: C++\n```", "```cpp\n// Assume Person class exists with its usual implementation\nclass Student: public Person   // Notice Student is \n{                              // an abstract class\nprivate:\n    float gpa = 0.0;   // in-class initialization\n    string currentCourse;\n    const string studentId;\n    static int numStudents; // Remember, static data mbrs \n                // are also shared by all derived instances\npublic:          \n    Student();  // default constructor\n    Student(const string &, const string &, char, \n       const string &, float, const string &, \n       const string &);\n    Student(const Student &);  // copy constructor\n    ~Student() override;  // destructor\n    float GetGpa() const { return gpa; }\n    const string &GetCurrentCourse() const \n       { return currentCourse; }\n    const string &GetStudentId() const \n       { return studentId; }\n    void SetCurrentCourse(const string &); // proto. only\n    void Print() const override;\n    string IsA() const override { return \"Student\"; }\n    virtual void Graduate() = 0;  // Student is abstract\n    static int GetNumStudents() { return numStudents; }\n};\n```", "```cpp\nclass GradStudent: public Student\n{   // Implemented as in our last example\n};\nclass UnderGradStudent: public Student\n{   // Implemented as in our last example\n};\nclass NonDegreeStudent: public Student\n{   // Implemented as in our last example\n};\n```", "```cpp\nclass StudentFactory    // Object Factory class\n{\npublic:   \n   // Factory Method creates Student based on degree sought\n    Student *MatriculateStudent(const string &degree, \n       const string &fn, const string &ln, char mi, \n       const string &t, float avg, const string &course, \n       const string &id)\n    {\n        if (!degree.compare(\"PhD\") || !degree.compare(\"MS\") \n            || !degree.compare(\"MA\"))\n            return new GradStudent(degree, fn, ln, mi, t, \n                                   avg, course, id);\n        else if (!degree.compare(\"BS\") || \n                 !degree.compare(\"BA\"))\n            return new UnderGradStudent(degree, fn, ln, mi,\n                                       t, avg, course, id);\n        else if (!degree.compare(\"None\"))\n            return new NonDegreeStudent(fn, ln, mi, t, avg,\n                                        course, id);\n    }\n};\n```", "```cpp\nint main()\n{\n    Student *scholars[MAX] = { }; // init. to nullptrs\n    // Create an Object Factory for Students\n    StudentFactory *UofD = new StudentFactory();\n    // Student is now abstract, cannot instantiate directly\n    // Ask the Object Factory to create a Student\n    scholars[0] = UofD->MatriculateStudent(\"PhD\", \"Sara\", \n               \"Kato\", 'B', \"Ms.\", 3.9, \"C++\", \"272PSU\");\n    scholars[1] = UofD->MatriculateStudent(\"BS\", \"Ana\", \n               \"Sato\", 'U', \"Dr.\", 3.8, \"C++\", \"178PSU\");\n    scholars[2] = UofD->MatriculateStudent(\"None\", \"Elle\",\n               \"LeBrun\", 'R', \"Miss\", 3.5, \"C++\", \"111BU\");\n    for (auto *oneStudent : scholars)\n    {\n       oneStudent->Graduate();\n       oneStudent->Print();\n    }\n    for (auto *oneStudent : scholars)\n       delete oneStudent;   // engage virt dtor sequence\n    delete UofD; // delete factory that created various \n    return 0;    // types of students\n}\n```"]