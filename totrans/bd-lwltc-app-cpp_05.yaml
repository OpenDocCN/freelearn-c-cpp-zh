- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Designing Our Trading Ecosystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的交易生态系统
- en: The previous chapter jumped into some hands-on, low-latency development in C++,
    where we built some basic building blocks to be used throughout the rest of this
    book. Now we are ready to start designing our electronic trading ecosystem, which
    will be our main project for the rest of this book, where we will learn about
    low-latency application development principles in practice. First, we will discuss
    the high-level design and architecture of the different low-latency components
    or applications that we will be building for the end-to-end electronic trading
    ecosystem. We will also design the abstractions, components, and interactions
    between them, which we will implement in the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章我们直接进入了C++的实战、低延迟开发，其中我们构建了一些将在本书剩余部分使用的基石。现在我们准备开始设计我们的电子交易生态系统，这将是本书剩余部分的主要项目，我们将学习低延迟应用开发的实际原则。首先，我们将讨论我们将为端到端电子交易生态系统构建的不同低延迟组件或应用程序的高层次设计和架构。我们还将设计它们之间的抽象、组件和交互，这些将在本书的其余部分实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the layout of the electronic trading ecosystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解电子交易生态系统的布局
- en: Designing the C++ matching engine in a trading exchange
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交易交易所设计C++撮合引擎
- en: Understanding how an exchange publishes information to participants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解交易所如何向参与者发布信息
- en: Building a market participant’s interface to the exchange
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建市场参与者与交易所的接口
- en: Designing a framework for low-latency C++ trading algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计低延迟C++交易算法的框架
- en: Let us kick off this chapter by describing the high-level topology of the electronic
    trading ecosystem we will design and build in the rest of this book. We will briefly
    introduce the different components in the next section and then have a much more
    detailed discussion in the rest of this chapter. One thing to keep in mind is
    that the electronic trading ecosystem we will be building in this book is a simplified
    version of what is found in practice. Not only is it a simplified version but
    it is also a subset of all the components you would need in practice to build
    and run a full electronic trading ecosystem. The components we will build in this
    book were chosen because they are the most latency-sensitive components, and we
    try to keep our focus on low-latency application development. We would like to
    mention that, in practice, you will find components such as historical data capture
    at the exchange and client ends, connections to clearing brokers, backend systems
    for transaction processing, accounting and reconciliation at both the exchange
    and trading client’s ends, backtesting frameworks (testing against historical
    data), and many others.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述我们将在这本书的剩余部分设计和构建的电子交易生态系统的整体拓扑结构来开启这一章。我们将在下一节简要介绍不同的组件，然后在本章的其余部分进行更详细的讨论。有一点需要记住的是，我们将在本书中构建的电子交易生态系统是实践中存在的简化版本。这不仅是一个简化版本，而且它还是所有实际构建和运行完整电子交易生态系统所需组件的一个子集。我们选择在本书中构建的组件是因为它们是最对延迟敏感的组件，我们试图将我们的重点放在低延迟应用开发上。我们想提一下，在实践中，你将发现诸如在交易所和客户端端的历史数据捕获、与清算经纪人的连接、交易处理、会计和结算的后端系统、针对历史数据的回测框架（测试）以及许多其他组件。
- en: Understanding the layout of the electronic trading ecosystem
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解电子交易生态系统的布局
- en: First, we start by providing the higher-level layout of the electronic trading
    ecosystem we will be building in the rest of this book. Before we get into the
    details, we start with the disclaimer that this is a simplified design of what
    happens in practice in electronic trading markets. Simplification was necessary
    to limit the scope to what can be covered in this book; however, it is still an
    accurate but simplified representation of what you will find in practice. The
    other thing to note is that the goal here is to understand the design and implementation
    of low-latency applications, so we ask you to focus more on the application of
    C++ and computer science principles that we apply and less on the details of the
    trading ecosystem itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始提供本书其余部分将要构建的电子交易生态系统的更高层次布局。在深入细节之前，我们首先声明这是一个简化的设计，它代表了电子交易市场实际发生的情况。简化是必要的，以便将范围限制在本书可以涵盖的内容内；然而，这仍然是对实践中发现内容的准确但简化的表示。需要注意的是，这里的目的是理解低延迟应用程序的设计和实现，因此我们要求您更多地关注我们应用C++和计算机科学原理的应用，而不是交易生态系统本身的细节。
- en: Now, let us kick off this introduction by defining and explaining the overall
    topology of the electronic trading ecosystem and the components involved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过定义和解释电子交易生态系统及其组成部分的整体拓扑结构来开始这次介绍。
- en: Defining the topology of the electronic trading ecosystem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义电子交易生态系统的拓扑结构
- en: 'Let us first provide a bird’s eye view of the system with the diagram presented
    here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过以下图表提供一个系统的鸟瞰图：
- en: "![Figure 5.1 – Topology of a \uFEFFsimple electronic trading ecosystem](img/B19434_05_01.jpg)"
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 简单电子交易生态系统的拓扑结构](img/B19434_05_01.jpg)'
- en: Figure 5.1 – Topology of a simple electronic trading ecosystem
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 简单电子交易生态系统的拓扑结构
- en: The major components, as laid out in the preceding diagram, are the following,
    split at a high level depending on whether it belongs on the exchange side or
    the trading client/market-participant side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 主要组成部分，如前图所示，如下所示，根据其属于交易所侧还是交易客户端/市场参与者侧进行高级别划分。
- en: 'These are the exchange components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是交易所组件：
- en: Matching engine at the electronic trading exchange
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子交易交易所的匹配引擎
- en: Order gateway server and protocol encoder and decoder at the trading exchange
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易交易所的订单网关服务器和协议编码器/解码器
- en: Market data encoder and publisher at the exchange
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易所的市场数据编码器和发布者
- en: 'These are the trading client components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是交易客户端组件：
- en: Market data consumer and decoder for a market participant interested in this
    market data
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对该市场数据感兴趣的市场参与者使用的市场数据消费者和解码器
- en: Order gateway encoder and decoder client in the market participant’s system
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场参与者系统中的订单网关编码器和解码器客户端
- en: Trading engine inside the participant’s system
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者系统内的交易引擎
- en: We will quickly introduce each one of these components in the next section and
    then discuss them in detail in the rest of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中快速介绍这些组件中的每一个，然后在本书的其余部分详细讨论它们。
- en: Introducing the components of the electronic trading ecosystem
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍电子交易生态系统的组成部分
- en: Here, we will quickly introduce the different components that make up the electronic
    trading ecosystem. One thing to keep in mind is that each one of these components
    in a competitive ecosystem needs to be designed such that they can process events
    and data with the lowest latencies possible. Also note that during periods of
    heightened volatility, these systems must be able to keep up with and react to
    large bursts in market activity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速介绍构成电子交易生态系统的不同组件。需要注意的是，在竞争性生态系统中，每个组件都需要设计成能够以尽可能低的延迟处理事件和数据。另外，请注意，在市场波动加剧的时期，这些系统必须能够跟上并反应市场活动的大幅波动。
- en: Introducing the market data publisher
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍市场数据发布者
- en: The market data publisher at the trading exchange is responsible for communicating
    every change to the limit order book maintained by the matching engine to the
    market participants. Compared to the order gateway, the difference here is that
    the market data publisher publishes public data meant for all participants, and
    it typically hides details of which order belongs to which participant to maintain
    fairness. Another difference is that the order gateway infrastructure only communicates
    order updates to the market participants whose orders were impacted by the change
    and not to all market participants. The market data publisher can use TCP or UDP
    to publish market data, but given the large volume of market data updates, UDP
    multicast is the preferred network-level protocol. The market data publisher is
    also responsible for converting the internal matching engine format into the market
    data format before publishing the updates.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 交易交易所的市场数据发布者负责将匹配引擎维护的限价订单簿的每一项变更传达给市场参与者。与订单网关相比，这里的区别在于市场数据发布者发布的是面向所有参与者的公共数据，并且通常隐藏哪些订单属于哪个参与者的细节，以保持公平性。另一个区别是，订单网关基础设施只向受变更影响的订单所属的市场参与者传达订单更新，而不是所有市场参与者。市场数据发布者可以使用TCP或UDP来发布市场数据，但鉴于市场数据更新的量大，UDP组播是首选的网络层协议。市场数据发布者还负责在发布更新之前将内部匹配引擎格式转换为市场数据格式。
- en: Introducing the matching engine
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍匹配引擎
- en: The matching engine at the electronic trading exchange is the most critical
    piece of the trading exchange. It is responsible for handling requests from market
    participants for their orders and updating the limit order book that it maintains.
    These requests are generated when the clients want to add a new order, replace
    an existing order, cancel an existing order, and so on. The limit order book is
    a collection of all orders sent by all participants aggregated into a central
    single book consisting of bids (buy orders) and asks (sell orders). The matching
    engine is also responsible for performing matches between orders that cross in
    price (i.e., matching buy orders with sell orders when the buy price is higher
    than or equal to the sell price). During special market states such as **PreOpen**
    (right before the market opens), **Auction**/**Opening** (right at the moment
    at which the market opens), **PreOpenNoCancel** (orders can be entered but not
    canceled), and so on, the rules are slightly different, but we will not worry
    about those rules or implement them to keep the focus on low-latency application
    development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 电子交易交易所的匹配引擎是交易交易所最关键的部分。它负责处理市场参与者对其订单的请求，并更新其维护的限价订单簿。这些请求是在客户想要添加新订单、替换现有订单、取消现有订单等情况下生成的。限价订单簿是由所有参与者发送的所有订单汇总到一个中央单一簿中，包括出价（买入订单）和要价（卖出订单）。匹配引擎还负责执行跨价格匹配的订单（即，当买入价格高于或等于卖出价格时，将买入订单与卖出订单匹配）。在特殊市场状态，如**PreOpen**（市场开盘前），**Auction**/**Opening**（市场开盘的瞬间），**PreOpenNoCancel**（可以输入订单但不能取消），等等，规则略有不同，但我们不会担心这些规则或实现它们，以保持对低延迟应用开发的关注。
- en: Introducing the order gateway server at the exchange
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍交易所的订单网关服务器
- en: The order gateway server at the exchange is responsible for accepting connections
    from market participants so that they can send requests for orders and receive
    notifications when there are updates to their respective orders. The order gateway
    server is also responsible for translating messages between the matching engine
    format and the order gateway messaging protocol. The network protocol used for
    the order gateway server is always TCP to enforce in-order delivery of messages
    and reliability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所的订单网关服务器负责接受市场参与者的连接，以便他们可以发送订单请求并在其相应订单有更新时接收通知。订单网关服务器还负责在匹配引擎格式和订单网关消息协议之间翻译消息。用于订单网关服务器的网络协议始终是TCP，以确保消息的有序交付和可靠性。
- en: Introducing the market data consumer at the market participant level
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在市场参与者层面引入市场数据消费者
- en: The market data consumer is the complement of the exchange market data publisher
    component on the market participants’ side. This component is responsible for
    subscribing to the UDP stream or the TCP server set up by the market data publisher,
    consuming the market data updates, and decoding the market data protocol into
    an internal format used by the rest of the trading engine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据消费者是市场参与者侧交易所市场数据发布组件的补充。该组件负责订阅由市场数据发布者设置的上UDP流或TCP服务器，消费市场数据更新，并将市场数据协议解码成交易引擎其他部分使用的内部格式。
- en: Introducing the order gateway encoder and decoder client
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍订单网关编解码器客户端
- en: The order gateway client component is the complement of the exchange order gateway
    server on the market participants’ side. The responsibility of this component
    is to establish and maintain TCP connections with the exchange’s order gateway
    infrastructure. It is also responsible for encoding strategy order requests in
    the correct exchange order messaging protocol and decoding exchange responses
    into an internal format that the trading engine uses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 订单网关客户端组件是市场参与者侧交易所订单网关服务器的补充。该组件的职责是建立并维护与交易所订单网关基础设施的TCP连接。它还负责将策略订单请求编码为正确的交易所订单消息协议，并将交易所响应解码成交易引擎使用的内部格式。
- en: Introducing the trading engine in the market participants’ systems
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在市场参与者系统中介绍交易引擎
- en: The trading engine is the brain of a market participant’s trading system. This
    is where intelligence resides, and where the trading decisions are made. This
    component is responsible for consuming the normalized market data updates from
    the market data consumer component. It will usually also build the complete limit
    order book to reflect the state of the market or, at the very least, a simplified
    variant of the order book, depending on the requirements of the trading strategies.
    It usually also builds analytics on top of the liquidity and prices from the order
    book and makes automated trading decisions. This component uses the order gateway
    client component to communicate with the trading exchange.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 交易引擎是市场参与者交易系统的核心。这是智能所在之处，也是交易决策做出的地方。该组件负责从市场数据消费者组件中消费标准化市场数据更新。它通常还会构建完整的限价订单簿，以反映市场状态，或者至少是订单簿的简化版本，这取决于交易策略的要求。它通常还会在订单簿的流动性和价格基础上构建分析，并做出自动化的交易决策。该组件使用订单网关客户端组件与交易交易所进行通信。
- en: Now that we have introduced the major components involved in our electronic
    trading ecosystem, we will look at these components in greater detail. First,
    we will start with the matching engine, which resides in the electronic trading
    exchange system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了电子交易生态系统中涉及的主要组件，我们将更详细地研究这些组件。首先，我们将从位于电子交易交易所系统中的匹配引擎开始。
- en: Designing the C++ matching engine in a trading exchange
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在交易交易所设计 C++ 匹配引擎
- en: In this section, we will discuss the matching engine component inside the electronic
    trading exchange system introduced in the previous section. The first thing we
    will do is understand what purpose the matching engine serves and why it is needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论上一节中介绍的电子交易交易所系统内的匹配引擎组件。我们首先要做的是理解匹配引擎的作用以及为什么需要它。
- en: Understanding the purpose of the matching engine
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解匹配引擎的目的
- en: In the electronic trading ecosystem consisting of a single trading exchange,
    generally, there is a single exchange that is responsible for accepting and managing
    orders from numerous market participants. The matching engine in this case accepts
    different kinds of orders that the participants are allowed to send for any given
    trading instrument. An **order** is simply a request sent by any market participant
    to the trading exchange to convey their interest in buying or selling a tradeable
    product. Every time a new order is received by the matching engine from the order
    gateway server infrastructure, it checks to see whether this new order crosses
    an existing order with an opposite side to see whether a trade occurs. For this
    book’s purposes, we will assume the market participants only send **limit orders**
    and specify the side of the order, quantity, and price. Limit orders are orders
    that can only execute at a price that is at, or better than, the price specified
    by the market participant.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在由单一交易交易所组成的电子交易生态系统中，通常情况下，有一个交易所负责接受和管理来自众多市场参与者的订单。在这种情况下，匹配引擎接受参与者可以为任何给定交易工具发送的不同类型的订单。**订单**是任何市场参与者向交易交易所发送的请求，以传达他们对购买或出售可交易产品的兴趣。每当匹配引擎从订单网关服务器基础设施接收到新订单时，它会检查这个新订单是否与现有订单的相反方交叉，以确定是否发生交易。对于本书的目的，我们假设市场参与者只发送**限价订单**并指定订单方向、数量和价格。限价订单是只能以市场参与者指定的价格或更好的价格执行的订单。
- en: It should be obvious by now that the matching engine performs the most critical
    task of performing matches between orders from different market participants and
    does so correctly and fairly. By fairness, we mean that the orders that reach
    the exchange first are processed first, and this **first in, first out** (**FIFO**)
    ordering is handled in the order gateway infrastructure, which we will discuss
    shortly. Orders that do not match immediately rest in the book and are referred
    to as **passive orders**. These orders are eligible for matching when new orders
    come in with prices that cross the passive orders. Such orders that cross the
    prices on passive orders are known as **aggressive orders**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该很明显，匹配引擎执行的是最关键的任务，即在不同市场参与者之间执行订单匹配，并且正确、公平地执行。这里的公平是指首先处理到达交易所的订单，这种**先进先出**（FIFO）的排序在订单网关基础设施中处理，我们将在稍后讨论。那些未能立即匹配的订单留在簿中，被称为**被动订单**。当新的订单以跨过被动订单的价格进入时，这些订单才有资格进行匹配。这种跨过被动订单价格的订单被称为**积极订单**。
- en: The matching engine arranges all the passive orders sent by all market participants
    into a data structure that is aptly named the **order book**. The details of this
    order book will be the topic of our next discussion.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配引擎将所有市场参与者发送的所有被动订单排列到一个称为**订单簿**的数据结构中。这个订单簿的细节将是我们下次讨论的主题。
- en: Understanding the exchange order book
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解交易所订单簿
- en: The limit order book contains all the passive limit orders across all market
    participants for a single trading instrument. These are typically arranged from
    the highest buy price to the lowest buy price for passive buy orders, and from
    the lowest sell price to the highest sell price for passive sell orders. This
    ordering is intuitive and natural because passive buy orders are matched from
    highest to lowest buy prices and passive sell orders are matched from lowest to
    highest sell prices. For orders that have the same side and the same price, they
    are arranged in FIFO order based on when they were sent. Note that FIFO is just
    one ordering criterion; modern electronic trading markets have different types
    of matching algorithms, such as **Pro Rata** and some mix of FIFO and Pro Rata.
    Pro Rata is simply a matching algorithm where larger orders get larger fills from
    aggressive orders regardless of where they are in the FIFO queue. For our matching
    engine, we will only implement the FIFO matching algorithm.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 限价订单簿包含了所有市场参与者针对单一交易工具的所有被动限价订单。这些订单通常按照从最高买入价到最低买入价排列被动买入订单，以及从最低卖出价到最高卖出价排列被动卖出订单。这种排序方式直观且自然，因为被动买入订单是从最高买入价到最低买入价进行匹配，而被动卖出订单是从最低卖出价到最高卖出价进行匹配。对于同一方和相同价格的订单，它们将根据发送时间按照先进先出（FIFO）的顺序排列。请注意，FIFO只是排序标准之一；现代电子交易市场有不同的匹配算法类型，例如**按比例分配**（Pro
    Rata）以及一些FIFO和按比例分配的混合。按比例分配是一种匹配算法，其中较大的订单无论在FIFO队列中的位置如何，都会从积极订单中获得更大的成交量。对于我们的匹配引擎，我们只将实现FIFO匹配算法。
- en: To fully understand how the order book works, we will look at a few scenarios
    that happen in the market and how they impact the order book. Let us first establish
    the starting state of the order book. Let us assume there are orders belonging
    to three different market participants – clients A, B, and C on the buy and sell
    sides.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解订单簿的工作原理，我们将查看市场发生的一些场景以及它们如何影响订单簿。让我们首先确定订单簿的初始状态。假设有三个不同的市场参与者——客户A、B和C在买卖双方有订单。
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | Client B OrderId 5 SELL 10 @ 11.00 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号1买入20 @ 10.90 | 客户B订单号5卖出10 @ 11.00 |'
- en: '| Client A OrderId 2 BUY 10 @ 10.80 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号2买入10 @ 10.80 | 客户C订单号6卖出5 @ 11.00 |'
- en: '| Client B OrderId 3 BUY 5 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 客户B订单号3买入5 @ 10.80 | 客户B订单号7卖出5 @ 11.10 |'
- en: '| Client C OrderId 4 BUY 100 @ 10.70 |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 客户C订单号4买入100 @ 10.70 |  |'
- en: Table 5.1 – Initial state of the limit order book consisting of some orders
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 包含一些订单的初始限价订单簿状态
- en: Here, client A has 2 passive buy orders of quantities of 20 and 10 at prices
    of 10.90 and 10.80, respectively. Client B has a buy order of a quantity of 5
    at 10.80, and 2 sell orders of quantities of 10 and 5 at prices of 11.00 and 11.10,
    respectively. Client C has 2 passive orders – a buy of a quantity of 5 at 10.80
    and a sell of a quantity of 5 at 11.00, respectively. Now, let us assume client
    A sends a new buy order of a quantity of 10 at the price of 10.90 and client B
    sends a new sell order of a quantity of 10 at the price of 11.20\. The updated
    order book is shown in the following table and the new orders are highlighted.
    Due to the FIFO ordering, the new buy order of *OrderId=8* is behind the buy order
    of *OrderId=1* at the same price.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户A有2个被动买入订单，数量分别为20和10，价格分别为10.90和10.80。客户B有一个数量为5的买入订单，价格为10.80，以及2个卖出订单，数量分别为10和5，价格分别为11.00和11.10。客户C有2个被动订单，分别是数量为5的买入订单和数量为5的卖出订单，价格分别为10.80和11.00。现在，假设客户A发送一个新的买入订单，数量为10，价格为10.90，而客户B发送一个新的卖出订单，数量为10，价格为11.20。更新的订单簿如下表所示，新的订单被突出显示。由于FIFO排序，新的订单号*OrderId=8*在相同价格下位于订单号*OrderId=1*的买入订单之后。
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | Client B OrderId 5 SELL 10 @ 11.00 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号1买入20 @ 10.90 | 客户B订单号5卖出10 @ 11.00 |'
- en: '| **Client A OrderId 8 BUY 10 @** **10.90** | Client C OrderId 6 Sell 5 @ 11.00
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **客户A订单号8买入10 @** **10.90** | 客户C订单号6卖出5 @ 11.00 |'
- en: '| Client A OrderId 2 BUY 10 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号2买入10 @ 10.80 | 客户B订单号7卖出5 @ 11.10 |'
- en: '| Client B OrderId 3 BUY 5 @ 10.80 | **Client B OrderId 9 SELL 10 @** **11.20**
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 客户B订单号3买入5 @ 10.80 | **客户B订单号9卖出10 @** **11.20** |'
- en: '| Client C OrderId 4 BUY 100 @ 10.70 |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 客户C订单号4买入100 @ 10.70 |  |'
- en: Table 5.2 – Updated order book with newly added orders
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 – 新增订单后的更新订单簿
- en: 'Now let us assume that client A modifies the order with *OrderId=2* to go from
    a quantity of 10 to a quantity of 20\. When an order’s quantity is increased in
    such a manner, the order loses priority in the FIFO ordering and goes to the back
    of the queue at that price level. Let us also assume that client B modifies the
    order of *OrderId=5* to reduce the order’s quantity from 10 to 1\. Note that per
    the rules of the market, when an order’s quantity is reduced, it does not lose
    its priority in the queue and still stays where it is. The updated order book
    is shown next, and the orders that are impacted are highlighted:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设客户A将订单号*OrderId=2*的数量从10增加到20。当以这种方式增加订单的数量时，该订单在FIFO排序中会失去优先级，并移至该价格级别的队列末尾。我们还假设客户B将订单号*OrderId=5*的数量从10减少到1。请注意，根据市场规则，当减少订单的数量时，它不会失去队列中的优先级，并且仍然保持在原位。更新的订单簿如下所示，受影响的订单被突出显示：
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | **Client B OrderId 5 SELL 1 @** **11.00**
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号1买入20 @ 10.90 | **客户B订单号5卖出1 @** **11.00** |'
- en: '| Client A OrderId 8 BUY 10 @ 10.90 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号8买入10 @ 10.90 | 客户C订单号6卖出5 @ 11.00 |'
- en: '| Client A OrderId 3 BUY 5 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 客户A订单号3买入5 @ 10.80 | 客户B订单号7卖出5 @ 11.10 |'
- en: '| **Client B OrderId 2 BUY 20 @** **10.80** | Client B OrderId 9 SELL 10 @
    11.20 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **客户B订单号2买入20 @** **10.80** | 客户B订单号9卖出10 @ 11.20 |'
- en: '| Client C OrderId 4 BUY 100 @ 10.70 |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 客户C订单号4买入100 @ 10.70 |  |'
- en: Table 5.3 – State of the order book after the modification of an order
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3 – 修改订单后的订单簿状态
- en: 'Finally, let us assume that client A modifies the buy order with *OrderId=4*
    from a price of 10.70 to a price of 10.90 with no changes to quantity. The impact
    of this order action is equivalent to canceling the order and sending a new order
    at the new price. Let us also assume that client B decides that they no longer
    want the sell order of *OrderId=9* and sends a cancel for it. The updated order
    book due to these two actions is shown next, with the modified order highlighted
    and the canceled order removed from the order book:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们假设客户端A将订单ID为4的买入订单从10.70的价格修改为10.90的价格，数量没有变化。此订单操作的影响相当于取消订单并以新价格发送新订单。让我们还假设客户端B决定他们不再需要订单ID为9的卖出订单，并发送了取消请求。由于这两个操作，下一个显示的更新订单簿中，修改后的订单被突出显示，取消的订单已从订单簿中移除：
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | **Client B OrderId 5 SELL 1 @** **11.00**
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 客户端A订单ID 1 买入 20 @ 10.90 **客户端B订单ID 5 卖出 1 @** **11.00** |'
- en: '| Client A OrderId 8 BUY 10 @ 10.90 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 客户端A订单ID 8 买入 10 @ 10.90 客户端C订单ID 6 卖出 5 @ 11.00 |'
- en: '| **Client C OrderId 4 BUY 100 @** **10.90** | Client B OrderId 7 SELL 5 @
    11.10 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **客户端C订单ID 4 买入 100 @** **10.90** 客户端B订单ID 7 卖出 5 @ 11.10 |'
- en: '| Client A OrderId 3 BUY 5 @ 10.80 |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 客户端A订单ID 3 买入 5 @ 10.80 |  |'
- en: '| Client B OrderId 2 BUY 20 @ 10.80 |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 客户端B订单ID 2 买入 20 @ 10.80 |  |'
- en: Table 5.4 – Limit order book state after the modification and cancellation actions
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.4 – 修改和取消操作后的限价订单簿状态
- en: So far in the scenarios we discussed, there has not been a trade because the
    order activity has been such that all buy orders have prices lower than all sell
    orders. Let us further this discussion in the next section and see what happens
    when there is an aggressive order that can cross the buy or sell order prices
    and what that does.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们讨论的场景中，还没有发生交易，因为订单活动是这样的，所有买入订单的价格都低于所有卖出订单的价格。让我们在下一节中继续讨论，看看当有一个可以跨越买入或卖出订单价格的积极订单时会发生什么，以及它会产生什么影响。
- en: 'Two things to note here as far as order modification is concerned are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于订单修改，有两点需要注意如下：
- en: When orders are modified to reduce the quantity, the priority or position of
    the order in the queue does not change
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订单修改以减少数量时，订单在队列中的优先级或位置不会改变
- en: When orders are modified to increase the quantity or the price of the order
    is modified, it has the equivalent effect of canceling the order and sending the
    order with the new price and quantity values (i.e., a new priority will be assigned
    to it)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订单修改以增加数量或修改订单价格时，它具有取消订单并发送带有新价格和数量值的订单的等效效果（即，将分配一个新的优先级）
- en: In the next section, we will look at the next big task that a matching engine
    needs to perform – matching participant orders that cross each other.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨匹配引擎需要执行的下一个大任务——匹配相互交叉的参与者订单。
- en: Matching participant orders
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配参与者订单
- en: In this section, we will understand what happens when a market participant modifies
    an existing order or sends a new order in such a way that the price on this order
    will cause a match against an existing passive order on the other side. In such
    a scenario, the matching engine matches this aggressive order against passive
    orders in order from most aggressive to least aggressive price. This means passive
    bids are matched from highest to lowest buy prices, and passive asks are matched
    from lowest to highest sell prices. In cases where the passive orders are not
    fully matched because the aggressive order has a smaller quantity than the passive
    liquidity available on the other side, then the remaining liquidity on the passive
    orders stays in the book. In cases where the aggressive order is not fully matched
    because the passive liquidity available on the other side is less than the quantity
    on the aggressive order, then the remaining quantity on the aggressive order rests
    in the book as a passive order.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解当市场参与者修改现有订单或以某种方式发送新订单，使得该订单的价格将导致与另一侧的现有被动订单匹配时会发生什么。在这种情况下，匹配引擎将此积极订单与从最积极到最不积极的价位的被动订单进行匹配。这意味着被动买单从最高到最低的买入价格进行匹配，被动卖单从最低到最高的卖出价格进行匹配。在被动订单未完全匹配，因为积极订单的数量小于另一侧的被动流动性时，剩余的流动性将保留在订单簿中。在积极订单未完全匹配，因为另一侧的被动流动性少于积极订单的数量时，剩余的数量将作为被动订单保留在订单簿中。
- en: 'Let us understand the different cases of matching participant orders and let
    us assume the state of the order book is where we left it in the last section,
    as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解匹配参与订单的不同情况，并假设订单簿的状态是我们在上一个部分留下的，如下所示：
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | Client B OrderId 5 SELL 1 @ 11.00 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 客户 A 订单号 1 买入 20 @ 10.90 | 客户 B 订单号 5 卖出 1 @ 11.00 |'
- en: '| Client A OrderId 8 BUY 10 @ 10.90 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 客户 A 订单号 8 买入 10 @ 10.90 | 客户 C 订单号 6 卖出 5 @ 11.00 |'
- en: '| Client C OrderId 4 BUY 100 @ 10.90 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 客户 C 订单号 4 买入 100 @ 10.90 | 客户 B 订单号 7 卖出 5 @ 11.10 |'
- en: '| Client A OrderId 3 BUY 5 @ 10.80 |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 客户 A 订单号 3 买入 5 @ 10.80 |  |'
- en: '| Client B OrderId 2 BUY 20 @ 10.80 |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 客户 B 订单号 2 买入 20 @ 10.80 |  |'
- en: Table 5.5 – Starting state of the order book before any order matches
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.5 – 任何订单匹配之前的订单簿初始状态
- en: 'Now, let us assume client C sends a sell order of a quantity of 50 at a sell
    price of 10.90\. This will cause the sell order to match against the buy orders
    with *OrderId=1* and *OrderId=8*, which are fully matched, and *OrderId=4*, which
    is partially matched for a quantity of 20 and has the remaining quantity of 80\.
    The orders that are fully matched are removed from the order book and the partially-matched
    order is modified to the new remaining quantity. The updated order book after
    this matching transaction is shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设客户 C 发送了一个数量为 50，卖出价格为 10.90 的卖出订单。这将导致卖出订单与 *订单号=1* 和 *订单号=8* 的买入订单完全匹配，并且与
    *订单号=4* 的买入订单部分匹配，数量为 20，剩余数量为 80。完全匹配的订单将从订单簿中移除，部分匹配的订单将修改为新剩余数量。这次匹配交易后的更新订单簿如下所示：
- en: '| **Client C OrderId 4 BUY 80 @** **10.90** | Client B OrderId 5 SELL 1 @ 11.00
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **客户 C 订单号 4 买入** **80 @** **10.90** | 客户 B 订单号 5 卖出 1 @ 11.00 |'
- en: '| Client A OrderId 3 BUY 5 @ 10.80 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 客户 A 订单号 3 买入 5 @ 10.80 | 客户 C 订单号 6 卖出 5 @ 11.00 |'
- en: '| Client B OrderId 2 BUY 20 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 客户 B 订单号 2 买入 20 @ 10.80 | 客户 B 订单号 7 卖出 5 @ 11.10 |'
- en: Table 5.6 – Order book reflecting the impact of the aggressive order and partial
    executions
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.6 – 反映激进订单和部分执行影响的订单簿
- en: 'Now, let us assume client A sends a buy order of a quantity of 10 at a buy
    price of 11.00\. This fully matches the sell orders with *OrderId=5* and *OrderId=6*,
    and the remaining unmatched quantity on the aggressive buy order rests in the
    book as a passive bid order. The updated order book after this matching transaction
    is shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设客户 A 发送了一个数量为 10，买入价格为 11.00 的买入订单。这将完全匹配 *订单号=5* 和 *订单号=6* 的卖出订单，并且激进买入订单上的剩余未匹配数量作为被动买入订单留在簿中。这次匹配交易后的更新订单簿如下所示：
- en: '| **Client A OrderId 9 BUY 4 @** **11.00** | Client B OrderId 7 SELL 5 @ 11.10
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **客户 A 订单号 9 买入** **4 @** **11.00** | 客户 B 订单号 7 卖出 5 @ 11.10 |'
- en: '| Client C OrderId 4 BUY 80 @ 10.90 |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 客户 C 订单号 4 买入 80 @ 10.90 |  |'
- en: '| Client A OrderId 3 BUY 5 @ 10.80 |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 客户 A 订单号 3 买入 5 @ 10.80 |  |'
- en: '| Client B OrderId 2 BUY 20 @ 10.80 |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 客户 B 订单号 2 买入 20 @ 10.80 |  |'
- en: Table 5.7 – Order book after full execution and resting quantity from the aggressor
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.7 – 完全执行后的订单簿和激进方剩余数量
- en: Now that we understand a lot of the common interactions that we will encounter
    in the matching engine and how those are handled, as well as how they interact
    with the limit order book, we can design the matching engine we will build in
    this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在匹配引擎中会遇到的大量常见交互以及它们是如何处理的，以及它们与限价订单簿的交互方式，我们可以设计本书中将要构建的匹配引擎。
- en: Designing our matching engine
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计我们的匹配引擎
- en: 'We will spend the rest of this book implementing each one of the C++ electronic
    trading ecosystem components we discussed in this chapter. However, before we
    get started on the next chapter, it is important to understand the architecture
    of these components to make the implementation details easier and clearer later
    on. We present only the matching engine component from *Figure 5**.1* here so
    we can discuss the design of our matching engine in a little more detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的剩余部分实现本章中讨论的每个 C++ 电子商务生态系统组件。然而，在我们开始下一章之前，了解这些组件的架构对于使实现细节更容易和更清晰是很重要的。我们在这里只展示了
    *图 5**.1* 中的匹配引擎组件，这样我们可以更详细地讨论我们的匹配引擎设计：
- en: '![Figure 5.2 – Design of our matching engine component](img/B19434_05_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 匹配引擎组件设计](img/B19434_05_02.jpg)'
- en: Figure 5.2 – Design of our matching engine component
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 匹配引擎组件设计
- en: We present a few more details in this diagram compared to *Figure 5**.1* by
    discussing the major design choices for the matching engine next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与*图5**.1*相比，我们在本图中提供了更多细节，接下来我们将讨论匹配引擎的主要设计选择。
- en: Threading model
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程模型
- en: In our system, the matching engine, the market data publisher, and the order
    gateway server will be independent threads. This is intentional so that each one
    of these components can operate independently, and during periods of bursts in
    market activity, the entire system can achieve maximum throughput. Also, there
    are other tasks that each component needs to perform – for example, the order
    gateway server must maintain connectivity with all market participants, even when
    the matching engine is busy. Similarly, let us assume the market data publisher
    is busy sending out market data on the network; we do not want the matching engine
    or the order gateway server to slow down. We already saw how to create threads,
    set affinity on them, and assign tasks for them to do in the previous chapter,
    *Building the C++ Building Blocks for Low-Latency Applications*, in the *C++ threading
    for multi-threaded low-latency* *applications* section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统中，匹配引擎、市场数据发布者和订单网关服务器将是独立的线程。这是故意的，以便每个组件都可以独立运行，在市场活动高峰期间，整个系统可以达到最大吞吐量。此外，每个组件还需要执行其他任务——例如，订单网关服务器必须与所有市场参与者保持连接，即使匹配引擎正忙也是如此。同样，让我们假设市场数据发布者正忙于在网络中发送市场数据；我们不希望匹配引擎或订单网关服务器减慢速度。我们已经在上一章的“为低延迟应用构建C++构建块”部分中的“C++多线程低延迟应用”部分中看到了如何创建线程、设置它们的亲和性以及为它们分配任务。
- en: Communication between threads
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程间的通信
- en: Another important thing to discuss here is the communication between the matching
    engine and the order gateway server infrastructure. The order gateway server serializes
    the order requests coming in from the market participants and forwards them to
    the matching engine for processing. The matching engine needs to generate a response
    for order requests and send them back to the order gateway server. Additionally,
    it also needs to inform the order gateway server about executions that happen
    on the participant’s orders so that they can be informed about the trades. So,
    it needs a bi-directional queue, or one queue from the order gateway server to
    the matching engine and another queue from the matching engine to the order gateway
    server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要讨论的另一件重要事情是匹配引擎与订单网关服务器基础设施之间的通信。订单网关服务器将来自市场参与者的订单请求序列化，并将它们转发给匹配引擎进行处理。匹配引擎需要为订单请求生成响应并将它们发送回订单网关服务器。此外，它还需要通知订单网关服务器参与者订单上的执行情况，以便他们可以了解交易情况。因此，需要一个双向队列，或者从订单网关服务器到匹配引擎的一个队列，以及从匹配引擎到订单网关服务器的一个队列。
- en: Another communication channel is when the matching engine generates and sends
    market data updates to reflect the updated state of the limit order book for the
    public market data publisher component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通信渠道是当匹配引擎生成并发送市场数据更新，以反映公共市场数据发布组件的限价订单簿更新状态时。
- en: Finally, since the matching engine, the order gateway server, and the market
    data publisher are all different threads, here we find a perfect case for a lock-free
    queue. We will use the lock-free FIFO queue we created in the previous chapter
    in the *Transferring data using lock-free* *queues* section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于匹配引擎、订单网关服务器和市场数据发布者都是不同的线程，这里我们找到了一个无锁队列的完美案例。我们将使用我们在上一章的“使用无锁队列传输数据”部分中创建的无锁FIFO队列。
- en: Limit order book
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限价订单簿
- en: Finally, for the limit order book, we will use a couple of different data structures
    to implement it efficiently. Without diving into specific implementation details
    (which we will look at in the next chapter), we need to maintain the bids and
    asks in the correct sorted order on both sides to facilitate efficient matching
    when aggressive orders come in. We need to be able to efficiently insert and remove
    orders from the price levels to support operations such as adding, modifying,
    and deleting orders based on client requests. One other particularly important
    consideration here is that the data structures we use and the order objects themselves
    must avoid dynamic memory allocations and copy as little data around as possible.
    We will make heavy use of the memory pool we created in the previous chapter in
    the *Designing C++ memory pools to avoid dynamic memory* *allocations* section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于限价订单簿，我们将使用几种不同的数据结构来高效地实现它。在不深入具体实现细节（我们将在下一章中探讨）的情况下，我们需要在双方都保持正确的排序顺序来维护买卖报价，以便在积极订单到来时进行高效的匹配。我们需要能够高效地在价格级别中插入和删除订单，以支持基于客户请求的添加、修改和删除订单等操作。在这里，另一个特别重要的考虑因素是，我们使用的数据结构和订单对象本身必须避免动态内存分配，并尽可能少地复制数据。我们将在上一章的“设计C++内存池以避免动态内存分配”部分中大量使用我们创建的内存池。
- en: Understanding how an exchange publishes information to participants
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解交易所如何向参与者发布信息
- en: The previous section was dedicated to discussing the details of the matching
    engine, and in that discussion, we assumed that the matching engine receives market
    participants’ order requests from the order gateway server infrastructure. We
    also implicitly assumed that the matching engine would communicate changes to
    the limit order book it maintains to all the market participants listening to
    the market data feed. In this section, we will discuss the market data publisher
    and the order gateway server components that the matching engine relies on to
    communicate with the market participants.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节专门讨论了匹配引擎的细节，在讨论中，我们假设匹配引擎从订单网关服务器基础设施接收市场参与者的订单请求。我们还隐含地假设匹配引擎会将其维护的限价订单簿的变化通知给所有监听市场数据馈送的市场参与者。在本节中，我们将讨论匹配引擎依赖以与市场参与者通信的市场数据发布者和订单网关服务器组件。
- en: Communicating market events through markets data
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过市场数据通信市场事件
- en: Let us discuss the market data publisher component first. This component is
    responsible for converting the updates to the limit order book maintained by the
    matching engine. We mentioned before that the market data network level protocol
    can be TCP or UDP but generally, the preferred protocol in practice is UDP, and
    that is the protocol we will be using in our market data publisher as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论市场数据发布者组件。这个组件负责将匹配引擎维护的限价订单簿的更新转换为。我们之前提到，市场数据网络层协议可以是TCP或UDP，但通常，实践中首选的协议是UDP，我们将在我们的市场数据发布者中也使用这个协议。
- en: In simple terms, the market data protocol represents the format of the messages
    that the market data publisher publishes over the UDP (or in some cases TCP) protocol.
    **FIX Adapted for STreaming** (**FAST**) is the most well-known and popular messaging
    format for market data that is currently used by a lot of electronic trading exchanges.
    There are other protocols, such as **ITCH**, **PITCH**, **Enhanced Order Book
    Interface** (**EOBI**), **Simple Binary Encoding** (**SBE**), and many others,
    but for the purposes of this book, we will create a simple custom binary protocol
    such as EOBI or SBE that we will use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，市场数据协议代表了市场数据发布者通过UDP（或在某些情况下TCP）协议发布消息的格式。**FIX Adapted for STreaming**（**FAST**）是目前许多电子交易交易所使用的最知名和最受欢迎的市场数据消息格式。还有其他协议，如**ITCH**、**PITCH**、**Enhanced
    Order Book Interface**（**EOBI**）、**Simple Binary Encoding**（**SBE**）等，但为了本书的目的，我们将创建一个简单的自定义二进制协议，如EOBI或SBE，我们将使用它。
- en: Since FIX is the most common protocol used in financial applications, we will
    present a few details here. FIX data is organized as a set of `TAG`=`VALUE` style
    fields. It will be easier to understand this with a simple example, so for a hypothetical
    market data update, you might receive the following collection of fields to convey
    all the data for that update. This hypothetical market data update corresponds
    to a new buy order of a quantity of 1,000 being added for the Apple company stock
    (stock symbol AAPL and numeric security ID 68475) at a price of 175.16.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FIX是金融应用中最常用的协议，我们将在此处介绍一些细节。FIX数据组织成一系列`标签`=`值`样式的字段。通过一个简单的例子更容易理解这一点，所以对于一个假设的市场数据更新，你可能收到以下一系列字段来传达该更新的所有数据。这个假设的市场数据更新对应于向苹果公司股票（股票代码AAPL，数值安全ID
    68475）添加一个数量为1,000的新买盘订单，价格为175.16。
- en: '| **TAG** | **FIX NAME** | **VALUE** | **DESCRIPTION** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **修正名称** | **值** | **描述** |'
- en: '| 268 | NoMDEntries | 1 | Number of market data updates |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 268 | NoMDEntries | 1 | 市场数据更新数量 |'
- en: '| 279 | MDUpdateAction | 0 (New) | Type of market data update |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 279 | MDUpdateAction | 0 (New) | 市场数据更新类型 |'
- en: '| 269 | MDEntryType | 0 (Bid) | Type of market data entry |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 269 | MDEntryType | 0 (Bid) | 市场数据条目类型 |'
- en: '| 48 | SecurityID | 68475 (AAPL) | Integer identifier for the trading product
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 48 | SecurityID | 68475 (AAPL) | 交易产品的整数标识符 |'
- en: '| 270 | MDEntryPx | 175.16 | Price of this market data update |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 270 | MDEntryPx | 175.16 | 本市场数据更新的价格 |'
- en: '| 271 | MDEntrySize | 1000 | Quantity of this market data update |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 271 | MDEntrySize | 1000 | 本市场数据更新的数量 |'
- en: '| ... | ... | ... | ... |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... | ... |'
- en: Table 5.8 – An example of a FIX message corresponding to a hypothetical market
    data update
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.8 – 一个对应于假设市场数据更新的FIX消息示例
- en: 'The different kinds of messages that make up the market data protocol are roughly
    categorized into the following categories:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构成市场数据协议的不同类型的信息大致可以分为以下几类：
- en: '![Figure 5.3 – Different market updates that an exchange sends out](img/B19434_05_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 交易所发送的不同市场更新](img/B19434_05_03.jpg)'
- en: Figure 5.3 – Different market updates that an exchange sends out
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 交易所发送的不同市场更新
- en: Let us discuss these next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来讨论这些内容。
- en: Market state changes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 市场状态变化
- en: These messages notify the market participants about changes in the market and/or
    matching engine state. Typically, markets go through states such as **Closed**
    for trading, **Pre-open** (market state before regular trading sessions), **Opening**
    (when markets transition from the Pre-open to Trading states), and **Trading**
    (regular trading session).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息通知市场参与者关于市场变化和/或撮合引擎状态的变化。通常，市场会经历诸如**关闭**（用于交易）、**开盘前**（常规交易会话前的市场状态）、**开盘**（当市场从开盘前状态过渡到交易状态时）和**交易**（常规交易会话）等状态。
- en: Instrument updates
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器更新
- en: 'The exchange uses instrument update messages to inform market participants
    about the different instruments available for trading. Some exchanges support
    special types of instruments that the market participants can create on the fly,
    and these messages are used to inform participants about changes to such instruments.
    Usually, these messages are used to inform participants about instrument metadata
    such as minimum price increments, tick size value, and more. The **minimum price
    increment** is the minimum price difference in order prices. In the examples we
    have seen so far, we assumed the minimum price increment to be 0.10 (i.e., valid
    prices are multiples of 0.10). The **tick size value** is the amount of money
    made or lost when we buy and sell at prices that are apart by a single minimum
    price increment. Very often, for products such as stocks, **Exchange Traded Fund**
    (**ETF**s), and so on, the tick size multiplier is just 1, meaning the profit
    or loss is simply the sell price minus the buy price for a pair of trades. ETFs
    are securities that trade at the exchange and are an investment option which consists
    of a basket of securities, i.e., by investing in an ETF, you invest in a bunch
    of assets that make up that ETF. But for some leveraged products such as futures,
    options, and so on, this tick size multiplier can be something other than 1, and
    the final profit or loss is computed as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所使用仪器更新消息来通知市场参与者关于可用于交易的不同仪器。一些交易所支持市场参与者可以即时创建的特殊类型的仪器，并且这些消息用于通知参与者此类仪器的变更。通常，这些消息用于通知参与者有关仪器元数据，例如最小价格增量、刻度值等。**最小价格增量**是订单价格之间的最小价格差异。在我们迄今为止看到的例子中，我们假设最小价格增量是
    0.10（即有效价格是 0.10 的倍数）。**刻度值**是我们以比单个最小价格增量大的价格买卖时，所赚取或亏损的金额。非常常见的是，对于股票、**交易所交易基金**（**ETF**）等产品，刻度乘数仅为
    1，这意味着盈亏仅仅是买卖价格之差。ETF 是在交易所交易的证券，是一种投资选择，由一篮子证券组成，即通过投资 ETF，你投资的是构成该 ETF 的资产组合。但对于一些杠杆产品，如期货、期权等，这个刻度乘数可能不是
    1，最终的盈亏计算如下：
- en: '`((sell-price – buy-price) / min-price-increment) * trade-qty *` `tick-size`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`((sell-price – buy-price) / min-price-increment) * trade-qty *` `tick-size`.'
- en: Order updates
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单更新
- en: 'The market data publisher uses order update messages to communicate changes
    to the orders in the limit order book maintained by the matching engine – specifically,
    updates to the order book similar to what we discussed in the *Understanding the
    exchange order book* subsection in the *Designing the C++ matching engine in a
    trading exchange* section. Generally, the different kinds of order updates messages
    are the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据发布者使用订单更新消息来传达对匹配引擎维护的限价订单簿中订单的变化——具体来说，是对我们在“设计交易交易所中的 C++ 匹配引擎”部分的“理解交易所订单簿”子节中讨论的类似订单簿的更新。通常，不同类型的订单更新消息如下：
- en: '`instrument-id`, `order-id`, `price`, `side`, `quantity`, and `priority`. The
    `priority` field here is used to specify the position of the order in the FIFO
    queue of orders at that price.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument-id`、`order-id`、`price`、`side`、`quantity` 和 `priority`。这里的 `priority`
    字段用于指定订单在该价格下的 FIFO 队列中的位置。'
- en: '**Order Modify** – This is used by the exchange to let the participants know
    that a passive order was modified in price or quantity or both. This message has
    similar fields as an Order Add message. As mentioned before, in most cases (except
    when the order quantity is reduced), a new order priority value will be assigned
    for Order Modify events.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单修改** – 交易所使用此消息让参与者知道一个被动订单在价格或数量或两者都进行了修改。此消息具有与订单添加消息类似的字段。如前所述，在大多数情况下（除非订单数量减少），将为订单修改事件分配一个新的订单优先级值。'
- en: '`instrument-id` and `order-id` to specify the order being deleted from the
    order book.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument-id` 和 `order-id` 用于指定从订单簿中删除的订单。'
- en: Trade messages
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易消息
- en: Trade messages are used by the exchange to notify the market participants that
    a match happened in the market. Generally, the attributes here are `instrument-id`,
    side of the aggressive order, execution price of the trade, and the traded quantity.
    Generally, when trades happen, the exchange also publishes as many Order Delete,
    Order Modify, and Order Add messages as needed to communicate information about
    which orders were fully and/or partially executed and need to be removed from
    the book or modified to reflect the new state of the order book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 交易消息由交易所用于通知市场参与者市场发生了匹配。通常，这里的属性包括`instrument-id`、积极订单的一侧、交易的执行价格和交易量。通常，当发生交易时，交易所还会发布所需数量的订单删除、订单修改和订单添加消息，以传达有关哪些订单已完全执行和/或部分执行，需要从簿中删除或修改以反映订单簿的新状态。
- en: Market statistics
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 市场统计数据
- en: These are optional messages that some exchanges publish to communicate different
    types of statistics about trading instruments. These statistics can be information
    about traded volume for an instrument, open interest for the instrument, the highest,
    lowest, opening, and closing prices for the instrument, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是某些交易所发布的一些可选消息，用于传达有关交易工具的不同类型的统计数据。这些统计数据可以是有关交易工具的交易量、未平仓合约、最高价、最低价、开盘价和收盘价等信息。
- en: We covered a lot of details about the market data messaging types and the information
    they try to convey. Now we are ready to design the market data publisher we will
    build in our electronic trading exchange next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了关于市场数据消息类型及其试图传达的信息的许多细节。现在，我们准备设计我们将在我们的电子交易交易所中构建的市场数据发布器。
- en: Designing the market data publisher
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计市场数据发布器
- en: Let us discuss a few design details for the market data publisher we will implement
    in our electronic exchange. We present only the market data publisher from *Figure
    5**.1* here so we can discuss the design in greater detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们将在我们的电子交易所中实施的几个市场数据发布器设计细节。在这里，我们只展示了*图5.1*中的市场数据发布器，以便我们可以更详细地讨论设计。
- en: '![Figure 5.4 – Design of our market data publisher infrastructure](img/B19434_05_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 我们市场数据发布器基础设施的设计](img/B19434_05_04.jpg)'
- en: Figure 5.4 – Design of our market data publisher infrastructure
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 我们市场数据发布器基础设施的设计
- en: There are two main components of the market data publisher infrastructure. Both
    use the socket utilities we built in the previous chapter in the *C++ network
    programming using sockets* section to put the market data on the wire. This is
    in addition to the threading library we built, which will be used to create, launch,
    and run the market data publisher thread.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据发布器基础设施有两个主要组件。它们都使用我们在上一章的*使用套接字的C++网络编程*部分中构建的套接字实用程序，将市场数据放在线上。这还包括我们构建的线程库，它将被用于创建、启动和运行市场数据发布器线程。
- en: Market data protocol encoder
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 市场数据协议编码器
- en: The market data protocol encoder component inside the market data publisher
    infrastructure is responsible for encoding the market data updates published by
    the matching engine. The market data encoder consumes market data updates that
    reflect changes to the order book and converts them into the public market data
    messaging format with some additional information. This component also publishes
    the incremental market data updates to the UDP multicast stream configured for
    incremental streams. Remember that the incremental stream only contains market
    updates that can be used to update the order book, assuming the participant had
    an accurate view of the limit order book prior to the incremental update. The
    encoded market data updates are also published to the snapshot synthesizer component,
    which we will discuss in more detail in the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据发布器基础设施内部的协议编码器组件负责对由匹配引擎发布的市场数据更新进行编码。市场数据编码器消耗反映订单簿变化的订单簿更新，并将它们转换为带有一些附加信息的公共市场数据消息格式。此组件还将增量市场数据更新发布到为增量流配置的UDP多播流。请记住，增量流仅包含可用于更新订单簿的市场更新，前提是参与者在增量更新之前对限价订单簿有准确的看法。编码后的市场数据更新还会发布到快照合成器组件，我们将在下一节中更详细地讨论。
- en: The market data stream is generally very high volume in terms of network traffic
    and experiences large bursts in activity, especially during periods of high volatility
    in the market. Since the TCP protocol adds extra bandwidth due to acknowledgments
    of message receipts and retransmissions of lost data, typically, UDP is the network
    protocol of choice for market data. Multicast streaming over UDP is also preferred
    since the market data can be disseminated on the multicast streams once and all
    interested subscribers can subscribe to that stream instead of having a one-to-one
    connection with each market data consumer over TCP. This design is not without
    some drawbacks, namely the possibility of market data consumers dropping UDP packets
    due to network congestion, slow hardware or software, and so on. When that happens,
    the order book that the trading client is maintaining is incorrect since they
    might have lost an update corresponding to a new order being added, an order being
    modified or canceled, and so on. This is the problem that the snapshot multicast
    streams solve, which we will explore with examples in subsequent chapters as we
    implement our market data consumers, but we will briefly introduce the snapshot
    synthesizer component in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据流在网络流量方面通常非常大，并且在市场波动性高的时期会经历大量的活动爆发。由于TCP协议因为消息收到的确认和丢失数据的重传而增加了额外的带宽，通常情况下，UDP是市场数据的首选网络协议。通过UDP的多播流进行流式传输也是首选，因为市场数据可以在多播流中一次性分发，所有感兴趣的订阅者都可以订阅该流，而不是通过TCP与每个市场数据消费者建立一对一的连接。这种设计并非没有缺点，即市场数据消费者可能会因为网络拥塞、硬件或软件缓慢等原因丢弃UDP数据包。当这种情况发生时，交易客户端维护的订单簿是不正确的，因为他们可能丢失了一个与新增订单、修改或取消订单等相对应的更新。这正是快照多播流解决的问题，我们将在后续章节中通过示例来探讨，但在下一节中，我们将简要介绍快照合成器组件。
- en: Snapshot synthesizer
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快照合成器
- en: The snapshot synthesizer consumes the encoded market date updates published
    by the market data protocol encoder, synthesizes the latest snapshot of the limit
    order book, and publishes the snapshot periodically to the snapshot multicast
    stream. The important point here is that the snapshot synthesis does not interfere
    with the incremental stream publishing so that incremental updates to the order
    book can be published as quickly as possible. It is a separate thread of execution,
    and the sole responsibility here is to generate an accurate snapshot of the order
    book based on the incremental updates. This component also adds the correct sequence
    information on the snapshot updates to facilitate synchronization at the client’s
    end before publishing it on the snapshot UDP multicast stream. What this means
    is that in the snapshot messages it sends out, it will provide the last sequence
    number from the incremental stream that was used to synthesize this snapshot message.
    This is important because the downstream market data consumer clients can use
    this sequence number of the last update in the incremental stream to perform successful
    synchronization/catch-up. This will become very clear when we build our market
    data publisher and market data consumer components because we will cover all the
    details with examples then. Another thing to understand is that the low-latency
    criteria that apply to the other components in our system do not apply here since
    this is a delayed and sub-sampled stream of information anyway. Additionally,
    packet drops are expected to be extremely rare on the client’s end and the snapshot
    synchronization process is slow on the client’s end, so trying to make this component
    super low latency is unnecessary. For our snapshot synthesizer component, we will
    also use the UDP protocol to keep it simple, but in practice, this is often a
    combination of TCP and UDP protocols. For low-latency market participants, packet
    drops on the UDP stream are expected to be rare because typically, the network
    connection to the exchange and switches along the way have a large bandwidth capacity
    and low switching latencies. Additionally, the participants invest resources into
    procuring and installing super-fast servers, building low-latency market data
    consumer software, and using special **Network Interface Cards** (**NICs**) to
    handle large volumes of market data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 快照合成器消费由市场数据协议编码器发布的编码市场数据更新，合成最新的限价订单簿快照，并将快照定期发布到快照多播流中。这里的重要点是快照合成不会干扰增量流发布，以便尽可能快地发布订单簿的增量更新。这是一个独立的执行线程，其唯一责任是根据增量更新生成订单簿的准确快照。此组件还在快照更新上添加正确的序列信息，以便在发布到快照UDP多播流之前在客户端端同步。这意味着在它发送的快照消息中，它将提供用于合成此快照消息的增量流中的最后一个序列号。这很重要，因为下游市场数据消费者客户端可以使用增量流中最后更新的这个序列号来执行成功的同步/追赶。当我们构建我们的市场数据发布器和市场数据消费者组件时，这一点将变得非常清楚，因为那时我们将通过示例涵盖所有细节。另一件需要理解的事情是，适用于我们系统中其他组件的低延迟标准不适用于这里，因为这是一个延迟和子采样的信息流。此外，客户端端预期数据包丢失将极为罕见，客户端端的快照同步过程较慢，因此尝试使此组件超低延迟是不必要的。对于我们的快照合成器组件，我们也将使用UDP协议以保持简单，但在实践中，这通常是TCP和UDP协议的组合。对于低延迟的市场参与者，预期UDP流中的数据包丢失将很少，因为通常，到交易所的网络连接以及沿途的交换机具有大带宽容量和低交换延迟。此外，参与者投入资源采购和安装超级快速的服务器，构建低延迟的市场数据消费者软件，并使用特殊的**网络接口卡**（**NICs**）来处理大量市场数据。
- en: This concludes our high-level design of the market data publisher infrastructure
    we will build in this book. Next, we need to discuss the other channel that the
    exchange uses to notify market participants about responses to their order requests
    as well as when their orders get executed – the order gateway interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中我们将构建的市场数据发布器基础设施的高级设计到此结束。接下来，我们需要讨论交易所用来通知市场参与者关于其订单请求响应以及订单何时被执行的其他渠道——订单网关接口。
- en: Notifying market participants through the order gateway interfaces
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过订单网关接口通知市场参与者
- en: We discussed that the market data consumer is used by the electronic trading
    exchange to disseminate public information about changes to the order book and
    matches happening for the different trading instruments available at the exchange.
    The point here is that this is public market data that is available to everyone
    that has access to and is subscribed to the market data stream. This section will
    discuss the other interface that the exchange uses to communicate with market
    participants about updates for their orders – the order gateway interface.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了市场数据消费者被电子交易交易所用来传播有关订单簿变化和交易所提供的不同交易工具匹配情况等公共信息。这里的要点是，这是对所有人开放的公共市场数据，只要他们能够访问并订阅市场数据流，就可以获取这些数据。本节将讨论交易所用来与市场参与者沟通其订单更新情况的另一个接口——订单网关接口。
- en: There are a few key differences between the information provided by the public
    market data feed and the information provided by the order gateway infrastructure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 公共市场数据馈送提供的信息与订单网关基础设施提供的信息之间有几个关键区别。
- en: Understanding the difference in network protocols
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解网络协议的差异
- en: We mentioned this before but we will reiterate here that typically, market data
    publishers use the UDP protocol at the network level, and the order gateway infrastructure
    uses the TCP protocol at the network level in their connections with market participants.
    This is because the data published by market data publishers is very voluminous
    and needs to be published as quickly as possible, hence the choice of UDP over
    TCP. There are generally additional synchronization mechanisms available on the
    market data publisher to deal with rare packet drops over UDP. The order gateway
    infrastructure relies on TCP because it needs a reliable method of communicating
    with the clients, and packet drops here are difficult to handle gracefully without
    TCP. Intuitively, it should be clear that it would be a major headache if clients
    were not sure that their orders reached the exchange or if clients weren’t sure
    they received immediate notifications when their orders are updated or matched.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经提到过，但在这里我们将再次强调，通常，市场数据发布者在网络层面使用UDP协议，而订单网关基础设施在其与市场参与者的连接中使用TCP协议。这是因为市场数据发布者发布的数据量非常大，需要尽可能快地发布，因此选择了UDP而不是TCP。市场数据发布者通常有额外的同步机制来处理UDP上罕见的包丢失。订单网关基础设施依赖于TCP，因为它需要一个可靠的方法与客户端通信，没有TCP，这里的包丢失很难优雅地处理。直观上，如果客户端不确定他们的订单是否到达了交易所，或者不确定他们的订单更新或匹配时是否立即收到了通知，这将是一个大问题。
- en: Differentiating between public and private information
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分公共信息和私人信息
- en: Perhaps the biggest difference between the market data publisher and the order
    gateway infrastructure is that the market data publisher publishes public information
    while hiding some sensitive information, such as which client an order belongs
    to or which clients participated in a matching transaction. This information is
    also published for all market participants and is meant to be used to construct
    the limit order book to reflect the state of a trading instrument. The order gateway
    server, on the other hand, only publishes order update notifications to the clients
    who own the orders that are being updated. Another way to think about this is
    that to receive and process public market data, a participant does not need to
    have any orders in the order book. But to receive private order gateway notifications
    the participant must have orders in the book, otherwise, there is nothing for
    the exchange to notify the client privately about.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据发布者与订单网关基础设施之间可能最大的区别是，市场数据发布者发布公共信息，同时隐藏一些敏感信息，例如订单属于哪个客户或哪些客户参与了匹配交易。这些信息也对所有市场参与者公开，目的是用来构建限价订单簿，以反映交易工具的状态。另一方面，订单网关服务器只向拥有正在更新的订单的客户发布订单更新通知。另一种思考方式是，为了接收和处理公共市场数据，参与者不需要在订单簿中有任何订单。但为了接收私人订单网关通知，参与者必须在订单簿中有订单，否则，交易所没有可以私下通知客户的内容。
- en: Sending order requests for participants’ orders
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为参与者发送订单请求
- en: Another major difference that should be obvious by now is that the order gateway
    component sending facilitates a bi-directional communication channel. What this
    means is that clients can send order requests to the exchange such as new orders,
    modify orders, cancel orders, and so on. On the other hand, as we discussed, the
    exchange uses the order gateway infrastructure to send private notifications for
    market participants’ orders. The market data publisher infrastructure does not
    generally service any client requests (i.e., the communication path is from the
    exchange to market data subscribers only).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很明显的一个主要区别是，订单网关组件发送促进了双向通信通道。这意味着客户端可以向交易所发送订单请求，如新订单、修改订单、取消订单等。另一方面，正如我们讨论的那样，交易所使用订单网关基础设施向市场参与者发送订单的私有通知。市场数据发布者基础设施通常不处理任何客户端请求（即，通信路径仅从交易所到市场数据订阅者）。
- en: The final sending component we need to design on the side of the electronic
    trading exchange is the order gateway infrastructure we just discussed; let us
    do that in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在电子交易交换的一侧设计最后一个发送组件，即我们刚才讨论的订单网关基础设施；让我们在下一节中完成这项工作。
- en: Designing the order gateway server
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计订单网关服务器
- en: Let us discuss a few design details for the order gateway server we will implement
    in our electronic exchange. We present only the order gateway server infrastructure
    from *Figure 5**.1* here so we can discuss the design of our order gateway server
    in a little more detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们将在电子交易所中实现的订单网关服务器的一些设计细节。在这里，我们只展示了*图5.1*的订单网关服务器基础设施，以便我们可以更详细地讨论我们的订单网关服务器的设计。
- en: '![Figure 5.5 – Design of our order gateway server infrastructure](img/B19434_05_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 我们订单网关服务器基础设施的设计](img/B19434_05_05.jpg)'
- en: Figure 5.5 – Design of our order gateway server infrastructure
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 我们订单网关服务器基础设施的设计
- en: We present a few more details in this diagram compared to *Figure 5**.1* and
    break down some details about the subcomponents for the order gateway server infrastructure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与*图5.1*相比，此图提供了更多细节，并分解了订单网关服务器基础设施子组件的一些细节。
- en: TCP connection server/manager
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP连接服务器/管理器
- en: The first component inside the order gateway infrastructure is the TCP connection
    manager. This component is responsible for setting up a TCP server that listens
    to and accepts incoming TCP connections from market participants’ order gateway
    clients. It is also responsible for detecting clients who disconnect and removing
    them from the list of active connections. Finally, this component needs to forward
    order responses from the matching engine to the correct client for which the response
    is meant. We will use the socket utilities, TCP socket, and TCP server functionality
    we implemented in the *C++ network programming using sockets* section in the previous
    chapter, *Building the C++ Building Blocks for* *Low-Latency Applications*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 订单网关基础设施内部的第一组件是TCP连接管理器。该组件负责设置一个TCP服务器，该服务器监听并接受来自市场参与者订单网关客户端的传入TCP连接。它还负责检测断开连接的客户端并将它们从活动连接列表中移除。最后，该组件需要将来自撮合引擎的订单响应转发给正确的客户端。我们将使用在前一章“为低延迟应用构建C++构建块”中实现的套接字工具、TCP套接字和TCP服务器功能。
- en: FIFO sequencer
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FIFO序列器
- en: Another important task this component needs to do is maintain fairness when
    processing requests from market participants. As mentioned previously, to maintain
    fairness, client responses must be processed in the exact order they were received
    at the exchange infrastructure. So, the FIFO sequencer must ensure that it forwards
    client requests to the matching engine across the different client connections
    that the TCP connection manager maintains in the order in which they are received.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这个组件需要完成的任务是在处理市场参与者的请求时保持公平性。如前所述，为了保持公平性，客户端响应必须按照它们在交易所基础设施中接收的确切顺序进行处理。因此，FIFO序列器必须确保它按照接收顺序将客户端请求转发给匹配引擎，这些请求是通过TCP连接管理器维护的不同客户端连接发送的。
- en: Exchange messaging protocol decoder and encoder
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易所消息协议解码器和编码器
- en: The encoder-decoder component is responsible for translating between the exchange
    messaging protocol and whatever internal structures the matching engine expects
    client requests in and publishes client responses in. Depending on the complexity
    of the exchange protocol, this can be as straightforward as packaging and extracting
    the correct fields into and from a packed binary structure. If the exchange messaging
    format is more complicated, then there will be additional encoding and decoding
    steps involved. For this book’s purposes, we will have a simple exchange order
    messaging protocol that uses packed binary structures and has additional information
    on top of the format the exchange matching engine uses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器-解码器组件负责在交换消息协议和匹配引擎期望客户端请求的内部结构之间进行转换，并发布客户端响应。根据交换协议的复杂性，这可以简单到将正确的字段打包和提取到打包的二进制结构中。如果交换消息格式更复杂，那么将涉及额外的编码和解码步骤。对于本书的目的，我们将有一个简单的交换订单消息协议，它使用打包的二进制结构，并在交换匹配引擎使用的格式之上包含额外的信息。
- en: This concludes our discussion of the electronic trading exchange, and now we
    can move on to building the client-side infrastructure for a market participant
    that wishes to trade on this exchange.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对电子交易交易所的讨论，现在我们可以继续构建一个希望在这个交易所进行交易的参与者的客户端基础设施。
- en: Building a market participant’s interface to the exchange
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建市场参与者对交易所的接口
- en: We will now discuss the purpose and design of the components in the market participants’
    systems. Specifically, we will start by discussing the market data consumer in
    the client’s trading system, which subscribes to, consumes, and decodes the public
    market data published by the exchange. We will also discuss the order gateway
    client infrastructure in the client’s trading system, which connects to the exchange
    order gateway server. The order gateway client is also responsible for sending
    order requests to the exchange and receiving and decoding responses for the client’s
    orders.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论市场参与者系统中组件的目的和设计。具体来说，我们将从讨论客户端交易系统中的市场数据消费者开始，它订阅、消费并解码交易所发布的公共市场数据。我们还将讨论客户端交易系统中的订单网关客户端基础设施，它连接到交易所订单网关服务器。订单网关客户端还负责向交易所发送订单请求并接收和解析客户端订单的响应。
- en: Understanding the market data consumer infrastructure
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解市场数据消费者基础设施
- en: The market data consumer component in a market participant’s trading system
    is the direct complement of the market data publisher component in the electronic
    trading exchange. It is responsible for subscribing to and consuming the multicast
    network traffic that the exchange publishes, decoding and normalizing the market
    data it reads from the exchange protocol to an internal format, and implementing
    packet drop-related synchronization mechanisms.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据消费者组件是电子交易交易所中市场数据发布组件的直接补充。它负责订阅和消费交易所发布的多播网络流量，解码和标准化从交易所协议读取的市场数据到内部格式，并实现与数据包丢失相关的同步机制。
- en: Subscribing to and consuming UDP multicast traffic
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅和消费UDP多播流量
- en: The first and most obvious task is to subscribe to the multicast stream that
    the exchange is publishing market data on. Typically, in the interest of load
    balancing, the exchange groups different trading instruments on different multicast
    stream addresses. This lets clients choose a subset of all the data that the exchange
    is publishing, depending on the trading instrument and products that the client
    is interested in. Typically, this involves the clients joining the correct multicast
    streams, the addresses of which are public information available from the exchange.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项也是最为明显的任务是订阅交易所发布市场数据的多播流。通常，为了负载均衡，交易所将不同的交易工具分组在不同的多播流地址上。这使得客户端可以根据客户感兴趣的交易工具和产品选择交易所发布的数据的子集。通常，这涉及到客户端加入正确的多播流，这些地址是交易所公开的信息。
- en: Decoding and normalizing from exchange protocol
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从交易所协议解码和标准化
- en: The next thing the market data consumer needs to do is convert from the exchange
    market data protocol into an internal format that the rest of the components in
    the participant’s system use. Depending on the exchange market data protocol,
    this part of the component can vary in complexity and performance latencies. The
    fastest protocols are the ones where minimal decoding is required, such as EOBI
    and SBE, which are just binary-packed structures. What this means is that the
    market data format is such that decoding the stream just involves reinterpreting
    the byte stream as the binary-packed structure we expect to find in the stream
    and is as fast as it gets. More complicated protocols such as FAST generally take
    longer to decode and normalize.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据消费者接下来需要做的是将交易所市场数据协议转换为参与者系统中其他组件使用的内部格式。根据交易所市场数据协议的不同，这个组件的部分可能在复杂性和性能延迟方面有所不同。最快的协议是那些需要最小解码的协议，如EOBI和SBE，它们只是二进制打包的结构。这意味着市场数据格式是这样的，解码流仅仅涉及将字节流重新解释为我们期望在流中找到的二进制打包结构，并且速度是最快的。更复杂的协议，如FAST，通常需要更长的时间来解码和标准化。
- en: Synchronizing on startup and packet drops
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动同步和包丢失同步
- en: Remember that we discussed that usually exchanges prefer UDP to be the network
    protocol to deliver market data to the participants. While this speeds up the
    delivery of data to clients and achieves higher throughput, this also leaves us
    open to packet drops and out-of-order delivery due to the unreliable nature of
    UDP. To make sure that market participants see market data packets in the correct
    order, as well as detect packet drops when they occur, typically, there are packet-level
    and instrument-level sequence numbers that the participants should check.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们讨论过，通常交易所更倾向于使用UDP作为网络协议来向参与者传输市场数据。虽然这加快了数据向客户端的传输并实现了更高的吞吐量，但这同时也使我们容易受到UDP不可靠性导致的包丢失和乱序交付的影响。为了确保市场参与者能够以正确的顺序看到市场数据包，并在发生时检测到包丢失，通常，参与者需要检查包级和工具级序列号。
- en: Another thing that needs to be designed, both on the exchange market data publisher
    and the participants’ market data consumers, is a mechanism to recover from such
    packet drops. This same mechanism is also used by participants who join the market
    data stream after the markets are already open or if the participants need to
    restart their market data consumer components for any reason. In all such cases,
    the market data consumers in the client’s trading system needs to perform some
    synchronization to get the current and complete state of the limit order book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在交易所市场数据发布者和参与者市场数据消费者之间设计的一个机制是，从这样的包丢失中恢复。这个相同的机制也被在市场已经开放后加入市场数据流或如果参与者需要出于任何原因重新启动他们的市场数据消费者组件的参与者所使用。在所有这些情况下，客户端交易系统中的市场数据消费者需要进行一些同步，以获取当前和完整的限价订单簿状态。
- en: The commonly used design to achieve this synchronization is explained in this
    section. Usually, the exchange market data streams are broken down into two major
    groups – **snapshot streams** and **incremental streams**. We will explain the
    reason for having these two streams and how they help market participants handle
    cases of packet drops next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了实现这种同步的常用设计。通常，交易所市场数据流被分为两大组——**快照流**和**增量流**。我们将解释为什么会有这两个流以及它们如何帮助市场参与者处理包丢失的情况。
- en: Incremental market data streams
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 增量市场数据流
- en: The incremental market data stream assumes that the market participant already
    has the correct view of the limit order book maintained by the matching engine,
    and this stream only publishes incremental updates to the previous state of the
    order book. This means that this stream is much lower in bandwidth requirements
    since it publishes only incremental updates to the book. Typically, under normal
    operating conditions, it is expected that market participants only be subscribed
    to the incremental streams to maintain the correct state of the order book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 增量市场数据流假设市场参与者已经拥有由撮合引擎维护的正确视图的限价订单簿，并且这个流只发布订单簿之前状态的增量更新。这意味着这个流的带宽需求要低得多，因为它只发布对簿的增量更新。通常，在正常运营条件下，预期市场参与者只订阅增量流以维护订单簿的正确状态。
- en: If the client drops a packet from this stream, then the state of the order book
    that they maintain might be inconsistent with what the matching engine has. The
    mechanism to handle this failure is to clear or reset the order book that the
    participant maintains. Then it needs to subscribe to the snapshot stream, which
    contains data for the full state of the entire order book (instead of only incremental
    updates) to synchronize to the correct state of the book once again. The protocol
    here is to clear the book, start queuing up incremental updates received from
    the incremental stream and wait to build the full state of the order book, and
    then apply the incremental updates to that full order book to finish the synchronization.
    Now, let us understand a few more details of what is published by the exchange
    on the snapshot market data streams.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端从这个流中丢弃一个数据包，那么他们维护的订单簿状态可能与匹配引擎所拥有的状态不一致。处理这种故障的机制是清除或重置参与者维护的订单簿。然后它需要订阅快照流，该流包含整个订单簿完整状态的数据（而不是只有增量更新）以再次同步到订单簿的正确状态。这里的协议是清除订单簿，开始排队从增量流接收到的增量更新，并等待构建订单簿的完整状态，然后将增量更新应用到该完整订单簿以完成同步。现在，让我们了解一些交易所发布的快照市场数据流的一些更多细节。
- en: Snapshot market data streams
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快照市场数据流
- en: As we mentioned before, the snapshot market data stream contains data that can
    be used to build the full order book from a completely empty state. Usually, this
    stream just contains a thorough list of *Order Add* messages corresponding to
    every single passive order that exists in the order book. The exchange usually
    throttles how often this list is updated and published, meaning it might only
    send out a stream of snapshot messages every couple of seconds or so. This is
    because, since this stream contains information about all the orders in the order
    book for every single trading instrument, it can become quite bandwidth-heavy.
    Additionally, since packet drops are an exceedingly rare occurrence and participants
    do not mind waiting a few seconds when they first start up to grab the correct
    state of the order book, the throttling does not usually have a large negative
    impact.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，快照市场数据流包含可以从完全空状态构建完整订单簿的数据。通常，这个流只包含一个详尽的列表，对应于订单簿中存在的每个被动订单的“订单添加”消息。交易所通常会限制这个列表更新的频率和发布，这意味着它可能每几秒钟才发送一次快照消息流。这是因为，由于这个流包含关于每个交易工具订单簿中所有订单的信息，它可能会变得相当带宽密集。此外，由于数据包丢失极为罕见，并且参与者不介意在启动时等待几秒钟以获取订单簿的正确状态，因此节流通常不会产生很大的负面影响。
- en: This concludes the discussion of the market data protocols and the synchronization
    process, so now we can design the market data consumer that we will implement.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了市场数据协议和同步过程的讨论，因此现在我们可以设计我们将要实现的市场数据消费者。
- en: Designing the market data consumer
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计市场数据消费者
- en: Let us discuss a few design details for the market data consumer we will implement
    in our market participant’s trading system. We present only the market data consumer
    from *Figure 5**.1* here so we can discuss the design in greater detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们将在我们的市场参与者交易系统中实现的市场数据消费者的一些设计细节。我们在这里只展示 *图 5.1* 中的市场数据消费者，以便我们可以更详细地讨论设计。
- en: '![Figure 5.6 – Design of our market data consumer infrastructure](img/B19434_05_06.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 我们市场数据消费者基础设施的设计](img/B19434_05_06.jpg)'
- en: Figure 5.6 – Design of our market data consumer infrastructure
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 我们市场数据消费者基础设施的设计
- en: Let us discuss the two primary subcomponents when it comes to the design of
    the market data consumer infrastructure in a market participant’s trading system.
    Both use the socket utilities we built in the previous chapter in the *C++ network
    programming using sockets* section to subscribe to and consume the market data
    from the network.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论市场参与者交易系统中市场数据消费者基础设施设计时的两个主要子组件。它们都使用我们在上一章的 *C++ 网络编程使用套接字* 部分中构建的套接字实用程序来订阅和消费网络上的市场数据。
- en: Snapshot and incremental stream synchronizer
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快照和增量流同步器
- en: The market data consumer needs to have a subcomponent that can be used to subscribe
    to the snapshot stream in addition to being subscribed to the incremental stream.
    Remember that we explained that when a market participant’s system first starts
    up or needs to restart in the middle of the day or drops a market data packet
    from the incremental stream, it does not have the correct view of the limit order
    book. In such a scenario, the correct recovery/synchronization procedure is to
    clear the limit order book, subscribe to the snapshot stream, and wait till a
    full snapshot of the order book is received. Additionally, the updates that continue
    to come in over the incremental market data stream need to be queued up. Once
    the full snapshot is received and all incremental updates starting from the sequence
    number of the last update in the snapshot are also queued up and available, we
    are done. At this point, the limit order book is reconstructed from the snapshot
    stream, and all queued-up incremental updates are applied to this book to synchronize/catch
    up with the exchange. At this point, the consumer can stop consuming data from
    the snapshot stream and leave the snapshot stream, and only consume data from
    the incremental stream. The component in the market data consumer infrastructure
    responsible for this synchronization mechanism is what we will refer to as the
    snapshot and incremental stream synchronization subcomponent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据消费者需要有一个子组件，除了订阅增量流外，还可以订阅快照流。记住，我们解释过，当市场参与者的系统首次启动或在白天中需要重启，或者从增量流中丢失市场数据包时，它没有正确的限价订单簿视图。在这种情况下，正确的恢复/同步程序是清除限价订单簿，订阅快照流，并等待收到完整的订单簿快照。此外，继续通过增量市场数据流传入的更新需要排队。一旦收到完整的快照，并且从快照中最后更新的序列号开始的全部增量更新都已排队并可用，我们就算完成了。此时，限价订单簿将从快照流中重建，并将所有排队的增量更新应用到这本书上以同步/赶上交易所。此时，消费者可以停止从快照流中消费数据并离开快照流，只从增量流中消费数据。负责此同步机制的市场数据消费者基础设施中的组件，我们将称之为快照和增量流同步子组件。
- en: Market data protocol decoder
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 市场数据协议解码器
- en: The other subcomponent is responsible for decoding the stream of data coming
    in from the snapshot and/or the incremental market data streams. This component
    translates the data from the exchange feed format to the internal format of the
    trading strategy framework. This is usually a subset of the fields that the exchange
    provides and is often normalized across different trading exchanges to make the
    trading strategy framework independent of exchange-specific details. For our market
    data consumer infrastructure, we will keep this component quite simple since we
    will be using a packed binary structure, but as mentioned before, in practice,
    this can be a much more complicated format such as FAST.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个子组件负责解码来自快照和/或增量市场数据流的传入数据流。该组件将数据从交易所数据源格式转换为交易策略框架的内部格式。这通常是交易所提供的字段的一个子集，并且通常在不同交易交易所之间进行标准化，以使交易策略框架独立于交易所特定的细节。对于我们的市场数据消费者基础设施，我们将保持此组件相当简单，因为我们将会使用打包的二进制结构，但如前所述，在实践中，这可以是一个更复杂的格式，例如FAST。
- en: We discussed the details and design of how a market participant’s system consumes
    the public market data feed from the exchange. We can move on to the order gateway
    client infrastructure, which the participant uses to send order requests and receive
    responses and execution notifications.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了市场参与者系统如何从交易所消费公共市场数据流的细节和设计。我们可以继续讨论订单网关客户端基础设施，参与者使用它来发送订单请求并接收响应和执行通知。
- en: Understanding the order gateway client infrastructure
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解订单网关客户端基础设施
- en: The order gateway client infrastructure in the market participant’s trading
    system is a TCP client that connects to the exchange’s order gateway server. The
    other task that this component performs is receiving updates from the exchange
    on this TCP connection, decoding the messages received from the exchange order
    messaging protocol into a normalized internal format for use by the rest of the
    system. Finally, the order gateway client component is also responsible for taking
    the order actions requested by the trading framework and encoding them in the
    order messaging format that the exchange understands and sending it through to
    the exchange.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者交易系统中的订单网关客户端基础设施是一个连接到交易所订单网关服务器的TCP客户端。该组件执行的另一项任务是接收通过此TCP连接从交易所发送的更新，将接收到的交易所订单消息协议解码成用于整个系统的标准化内部格式。最后，订单网关客户端组件还负责接收交易框架请求的订单操作，并将它们编码成交易所理解的订单消息格式，然后将其发送到交易所。
- en: The important thing to remember here is that the order gateway client must always
    maintain a reliable TCP connection to the exchange. This is to make sure that
    the exchange does not miss any order request from the client and that the client
    does not miss any updates to its orders from the exchange. In addition to the
    reliability mechanisms implemented by the TCP networking protocol itself, there
    usually exists an application-level reliability mechanism implemented by the exchange
    and the participants. This application-level reliability mechanism usually consists
    of strictly incrementing sequence numbers on the messages sent from exchange to
    client and from client to exchange. Additionally, there can be heart-beating mechanisms
    in place, which are simply messages sent from exchange to client and client to
    exchange to check whether a connection is still active during periods of low activity.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的重要事情是，订单网关客户端必须始终与交易所保持可靠的TCP连接。这是为了确保交易所不会错过任何来自客户端的订单请求，并且客户端不会错过来自交易所的任何订单更新。除了TCP网络协议本身实现的可靠性机制外，通常还存在着由交易所和参与者实现的应用级可靠性机制。这种应用级可靠性机制通常包括在从交易所发送到客户端和从客户端发送到交易所的消息上严格递增序列号。此外，还可以实施心跳机制，这些机制简单地说就是从交易所发送到客户端和从客户端发送到交易所的消息，以检查在低活动期间连接是否仍然活跃。
- en: Additionally, there are mechanisms to authenticate and identify clients when
    they first connect, and this is usually implemented as a handshake mechanism with
    user identification and password, and so on. There can be additional administrative
    messages, such as the logon authentication message, and it depends on the exchange
    and can have a wide range of purposes. For this book’s purposes, we will limit
    the scope to not focus on these administrative messages since they do not matter
    to our low latency goals.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当客户端首次连接时，存在一些机制来验证和识别客户端，这通常是通过握手机制实现的，包括用户识别和密码等。还可能有额外的管理消息，例如登录认证消息，这取决于交换方式，并且可以有多种用途。对于本书的目的，我们将限制范围，不关注这些管理消息，因为它们对我们低延迟的目标无关紧要。
- en: Next, let us design our order gateway client infrastructure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设计我们的订单网关客户端基础设施。
- en: Designing the order gateway client infrastructure
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计订单网关客户端基础设施
- en: Let us discuss a few design details for the market data publisher we will implement
    in our market participant’s trading system. We present only the order gateway
    client from *Figure 5**.1* here so we can discuss the design in greater detail.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们讨论一下我们将在市场参与者交易系统中实现的市场数据发布者的设计细节。在这里，我们只展示了*图5.1*中的订单网关客户端，以便我们可以更详细地讨论设计。 '
- en: '![Figure 5.7 – Design of our order gateway client infrastructure](img/B19434_05_07.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 我们订单网关客户端基础设施的设计](img/B19434_05_07.jpg)'
- en: Figure 5.7 – Design of our order gateway client infrastructure
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 我们订单网关客户端基础设施的设计
- en: There are two simple components that make up the order gateway client inside
    the market participant’s trading system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者交易系统中的订单网关客户端由两个简单的组件组成。
- en: TCP connection manager
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP连接管理器
- en: The order gateway client in a market participant’s trading system oversees connecting
    to the exchange order gateway server and managing that connection. In practice,
    a single participant will have multiple connections to the exchange for load balancing,
    redundancy, and latency reasons. But in the electronic trading ecosystem that
    we will be building, we will design it such that an order gateway client creates
    a single connection to the exchange order gateway server. We will use the TCP
    socket client library we built in the previous chapter under the *C++ network
    programming using* *sockets* section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者交易系统中的订单网关客户端负责连接到交易所订单网关服务器并管理该连接。在实践中，单个参与者可能会出于负载均衡、冗余和延迟的原因与交易所建立多个连接。但在我们将要构建的电子交易生态系统中，我们将设计它，使得订单网关客户端仅与交易所订单网关服务器建立一个连接。我们将使用上一章在“使用套接字进行C++网络编程”部分构建的TCP套接字客户端库。
- en: Order gateway protocol encoder and decoder
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单网关协议编码器和解码器
- en: The order messaging format encoder and decoder translate order requests from
    the internal format that the trading strategy uses to the exchange format and
    translate order responses and execution notifications from the exchange to an
    internal format for the strategy framework. This component can vary in complexity
    depending on the exchange format, but for our trading system, we will keep the
    encoding and decoding complexity low by using a binary-packed structure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 订单消息格式编码器和解码器将交易策略使用的内部格式转换为交易所格式，并将交易所的订单响应和执行通知转换为策略框架的内部格式。这个组件的复杂性会根据交易所格式而变化，但为了我们的交易系统，我们将通过使用二进制打包结构来保持编码和解码的复杂性较低。
- en: Next, we move away from our discussion of the order gateway infrastructure and
    on to the most complex (and most interesting) component of the participant’s system
    – the trading strategy framework.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从对订单网关基础设施的讨论转向参与者系统中最复杂（也是最有趣）的组件——交易策略框架。
- en: Designing a framework for low-latency C++ trading algorithms
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计低延迟C++交易算法框架
- en: Now that we have discussed the market data consumer and order gateway client
    components on the market participants’ trading systems, the last component we
    need to discuss is the framework that makes trading decisions. This component
    is one of the most important components in a trading system since this is where
    intelligence lies. By intelligence, we mean the system that processes normalized
    market data updates, builds a view into the market conditions, and computes trading
    analytics to find trading opportunities and execute trades. Obviously, this component
    relies on the market data consumer to receive decoded and normalized market data
    updates and uses the order gateway client component to send order requests to
    and receive order responses from the exchange in a decoded and normalized format.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了市场数据消费者和订单网关客户端组件在市场参与者交易系统中的应用，接下来我们需要讨论的是做出交易决策的框架。这个组件是交易系统中最重要的组件之一，因为这里才是智能所在。所谓智能，我们指的是处理标准化市场数据更新的系统，构建市场状况视图，并计算交易分析以寻找交易机会并执行交易的系统。显然，这个组件依赖于市场数据消费者接收解码和标准化的市场数据更新，并使用订单网关客户端组件以解码和标准化的格式向交易所发送订单请求并接收订单响应。
- en: Building the order book
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建订单簿
- en: The market participant needs to construct the limit order book based on the
    market data that the exchange publishes. Note that it is not strictly necessary
    that the client must build the entire order book, especially if the trading strategies
    do not require information that is that granular. For this book’s purposes, we
    will build a full order book in our trading framework, but we just wanted to point
    out that it is not strictly necessary in all cases. A simple example of such a
    case would be strategies that only care about knowing the prices and/or quantity
    of the most aggressively priced orders – that is, the highest bid price and lowest
    offer price (known as **Top Of Book** (**TOB**) or **Best Bid and Offer** (**BBO**)).
    Another example would be strategies that only rely on trade prices to make decisions
    and do not require a view into the full order book.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者需要根据交易所发布的市场数据构建限价订单簿。请注意，客户构建整个订单簿并不是严格必要的，特别是如果交易策略不需要那么细粒度的信息。为了本书的目的，我们将在我们的交易框架中构建完整的订单簿，但我们只是想指出，在所有情况下这并不是严格必要的。这样一个简单的例子就是只关心了解最积极定价订单的价格和/或数量的策略——即最高出价价格和最低要价价格（称为**订单簿顶部**（**TOB**）或**最佳出价和要价**（**BBO**））。另一个例子是只依赖交易价格做出决策且不需要查看完整订单簿的策略。
- en: One thing to reiterate here is that the order book that the client builds is
    slightly different from the one that the exchange maintains because the client
    does not usually know which order belongs to which market participant. Additionally,
    depending on the exchange, a few more pieces of information might be hidden from
    the market participants, such as which orders are icebergs, which new orders are
    stop orders, self-match-prevention considerations, and so on. **Iceberg orders**
    are orders that have a larger hidden quantity than what is displayed in the public
    market data. **Stop orders** are orders that lie dormant and then become active
    when a specific price trades. **Self-match prevention** (**SMP**) is a constraint
    that prevents a client from trading against themselves, which some exchanges choose
    to enforce in the matching engine. For the purposes of this book, we will ignore
    and not implement such special functionality. Another thing to understand is that
    the book that the trading participants have is a slightly delayed version of the
    order book that the matching engine has. This is because there is some latency
    between the matching engine updating its order book to the trading client getting
    the market updates corresponding to the changes and updating their book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要重申的一点是，客户构建的订单簿与交易所维护的订单簿略有不同，因为客户通常不知道哪个订单属于哪个市场参与者。此外，根据交易所的不同，可能还有更多信息对市场参与者隐藏，例如哪些订单是冰山订单，哪些新订单是停止订单，自我匹配预防考虑等因素。**冰山订单**是指隐藏数量大于公开市场数据中显示数量的订单。**停止订单**是指处于休眠状态的订单，当达到特定价格时才会变为活跃状态。**自我匹配预防**（**SMP**）是一种约束，防止客户与自己交易，一些交易所选择在撮合引擎中实施此约束。在本书的范围内，我们将忽略并实现此类特殊功能。另一件需要理解的事情是，交易参与者拥有的订单簿是撮合引擎订单簿的一个略微延迟版本。这是因为撮合引擎更新其订单簿到交易客户端获取与变化相对应的市场更新之间存在一些延迟。
- en: Building a feature engine
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建功能引擎
- en: Sophisticated trading strategies need to build additional intelligence over
    just the order book. These trading strategies need to implement various trading
    signals and intelligence on top of the prices, liquidity, trade transactions,
    and order book published by the exchange. The idea here is to build intelligence,
    which can be a combination of technical analysis style indicators, statistical
    predictive signals and models, and market microstructure-related statistical edges.
    A detailed discussion of various kinds of trading signals and predictive analysis
    is outside the scope of this book, but there are plenty of texts dedicated to
    this topic. There are many different terms used in practice for such predictive
    edges – trading signals, indicators, features, and so on. The component inside
    the trading system that constructs and wires together a collection of such predictive
    signals is often referred to as a feature/signal/indicator engine. In this book,
    we will build a minimal feature engine for our trading strategies, but we reiterate
    here that feature engines can get quite sophisticated and complicated depending
    on the strategy’s complexity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的交易策略需要在仅仅订单簿的基础上构建额外的智能。这些交易策略需要在交易所发布的价格、流动性、交易交易和订单簿之上实现各种交易信号和智能。这里的想法是构建智能，这可能包括技术分析风格的指标、统计预测信号和模型，以及与市场微观结构相关的统计优势。关于各种交易信号和预测分析的详细讨论超出了本书的范围，但有许多专门讨论这个主题的文本。在实际应用中，对于这样的预测优势有许多不同的术语——交易信号、指标、特征等等。在交易系统中构建和连接这些预测信号集合的组件通常被称为特征/信号/指标引擎。在本书中，我们将为我们的交易策略构建一个最小的特征引擎，但在此我们重申，特征引擎可以根据策略的复杂性变得相当复杂和复杂。
- en: Developing the execution logic
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发执行逻辑
- en: After building the order book and deriving some trading signals from the current
    state of the market, if the trading strategies find an opportunity, they still
    need to execute their orders at the exchange. This is achieved by sending new
    orders, modifying existing orders to either move them to a more aggressive or
    less aggressive price, and/or canceling existing orders to avoid getting filled
    on them. The subcomponent in the trading infrastructure responsible for sending,
    modifying, and canceling orders – basically, managing a strategy’s orders at the
    exchange – is called the execution system. For the execution systems, the ability
    to react quickly to market data and order responses coming from the exchange and
    send out order requests as quickly as possible is extremely important. A large
    part of a high-frequency trading system’s profitability and sustainability depends
    on achieving the lowest possible latencies in the execution systems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建订单簿并从当前市场状态中推导出一些交易信号之后，如果交易策略发现了机会，它们仍然需要在交易所执行它们的订单。这是通过发送新订单、修改现有订单以将它们移动到更激进或更保守的价格，以及/或者取消现有订单以避免被填充来实现的。负责发送、修改和取消订单的子组件，基本上是管理策略在交易所的订单，被称为执行系统。对于执行系统来说，能够快速对来自交易所的市场数据和订单响应做出反应，并尽可能快地发送订单请求，这一点非常重要。高频交易系统的盈利能力和可持续性很大一部分取决于在执行系统中实现尽可能低的延迟。
- en: Understanding the risk management systems
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解风险管理系统
- en: 'The risk management system is an important piece of the trading strategy infrastructure.
    Technically speaking, in practice, there are multiple layers of risk management
    systems in a modern electronic trading ecosystem. In practice, there are risk
    management systems in the client’s trading strategy framework, order gateway clients
    in the market participant’s system, and backend systems at the clearing broker’s
    end. For this book’s purposes, we will only implement a minimal risk management
    system in the trading strategy framework. Risk management systems try to manage
    the different forms of risk, as depicted in the following diagram:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 风险管理系统是交易策略基础设施的重要组成部分。从技术角度讲，在实践中，现代电子交易生态系统中存在多层风险管理系统。在实践中，客户交易策略框架中存在风险管理系统，市场参与者的系统中存在订单网关客户端，以及清算经纪商端的后端系统。为了本书的目的，我们将在交易策略框架中仅实现一个最小风险管理系统。风险管理系统试图管理不同形式的风险，如下面的图所示：
- en: '![Figure 5.8 – Different risk metrics in an automated risk management system](img/B19434_05_08.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 自动化风险管理系统中的不同风险指标](img/B19434_05_08.jpg)'
- en: Figure 5.8 – Different risk metrics in an automated risk management system
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 自动化风险管理系统中的不同风险指标
- en: Let us discuss these risk measures in more detail next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这些风险指标。
- en: Risk based on order quantities
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于订单数量的风险
- en: One measure that a lot of trading systems care about is the maximum possible
    quantity that the algorithm is allowed to send for a single order. This is mostly
    to prevent bugs and user errors in the system where the algorithm ends up accidentally
    sending an order much larger than expected. These types of errors in practice
    are referred to as **Fat Finger** errors, to refer to what would happen if a user
    accidentally pressed more keys than intended.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 许多交易系统关注的一个衡量标准是算法允许发送的单个订单的最大可能数量。这主要是为了防止系统中的错误和用户错误，导致算法意外发送比预期更大的订单。在实践中，这类错误被称为**大拇指错误**，指的是用户意外按下比预期更多的键的情况。
- en: Risk based on firm positions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于公司头寸的风险
- en: An obvious measure of risk is the position that a strategy has in a certain
    trading instrument. The size of the position directly dictates how much money
    is lost if the market prices change a certain amount. This is why the realized
    position that a strategy or a firm has in a certain trading instrument is an extremely
    important one and is closely monitored to make sure it falls within agreed-upon
    limits. Note that realized position is the position that the strategy currently
    holds, and this ignores additional orders that the strategy might have, which
    might increase or decrease the position on execution.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 风险的一个明显衡量标准是策略在某一交易工具中的头寸位置。头寸的大小直接决定了如果市场价格变动一定幅度，将损失多少资金。这就是为什么策略或公司在某一交易工具中的实际头寸非常重要，并且需要密切监控以确保其不超过约定的限制。请注意，实际头寸是指策略当前持有的头寸，并且这忽略了策略可能有的额外订单，这些订单可能会在执行时增加或减少头寸。
- en: Risk based on worst-case position
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于最坏情况头寸的风险
- en: Note that in the last section, we mentioned that realized position metrics ignore
    how many additional live orders exist in the market. The worst-case scenario position
    metric tracks what the position would be considering the live orders on the side
    that would increase the realized position along with the actual realized position.
    This means if the strategy or firm is long (position from buying an instrument),
    then it will also check how much additional unexecuted buy quantity the strategy
    has in the market to compute the absolute worst-case position. This is important
    because some strategies might never build up to large positions but might always
    have a lot of active orders in the market. The perfect example of such a strategy
    is a market-making strategy, which we will see later in this book, but the point
    here is that it is important to think about worst-case scenarios when it comes
    to risk management.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上一节中，我们提到实际头寸指标忽略了市场上存在的额外活跃订单数量。最坏情况头寸指标跟踪的是考虑到会增加实际头寸的活跃订单，以及实际头寸本身，头寸将会达到的位置。这意味着如果策略或公司是多头（从购买工具中获得头寸），那么它还会检查策略在市场上未执行的多头购买数量，以计算绝对最坏情况头寸。这很重要，因为一些策略可能永远不会积累到大的头寸，但可能始终在市场上有很多活跃订单。这种策略的完美例子是市场做市策略，我们将在本书的后面看到，但这里的重点是，在风险管理方面，考虑最坏情况是很重要的。
- en: Risk to manage realized and unrealized loss
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理实现和未实现损失的风险
- en: This is what most people think of when they think of risk in the context of
    electronic trading. This risk metric tracks and imposes limits on how much money
    a strategy or firm has lost. If that value crosses a certain threshold, then depending
    on how much the firm has in its brokerage account, how much collateral they have,
    and so on, there can be consequences for the firm. Not only is it important to
    track the realized losses for a strategy when the strategy opens and closes positions
    but it is also important to track the open positions against the market prices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是人们在考虑电子交易中的风险时通常会想到的内容。这个风险指标跟踪并限制策略或公司损失的资金量。如果这个值超过某个阈值，那么根据公司在其经纪账户中的资金量、抵押品数量等因素，公司可能会面临后果。不仅需要跟踪策略在开仓和关仓时的实际损失，还需要跟踪未平仓头寸与市场价格的关系。
- en: 'To understand this, let us explain the following scenario: a strategy buys
    a certain quantity of an instrument and then sells the same amount of quantity
    back at a lower price where the strategy has a realized loss and no open position.
    Now, let us say the strategy buys some amount of the trading instrument, and then
    after the purchase where the strategy has a long position, the price of the instrument
    in the market moves lower. Here, this strategy not only has the realized loss
    it is carrying from the previous set of trades but now it also has an unrealized
    loss on this most recently opened long position. The risk management system needs
    to compute realized and unrealized losses in near real time to get an accurate
    view of the actual risk.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们解释以下场景：一个策略购买了一定数量的工具，然后以较低的价格卖出相同数量的数量，此时策略有实际损失且没有开放头寸。现在，让我们假设策略购买了一些交易工具，然后在购买后，策略持有长期头寸，市场中的工具价格下跌。在这里，这个策略不仅携带了之前一系列交易中的实际损失，现在它还在这最近开仓的长期头寸上有未实现损失。风险管理系统需要几乎实时地计算实现和未实现损失，以获得实际风险的准确视图。
- en: Risk based on traded volumes
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于交易量的风险
- en: This measure is not necessarily a risk; a strategy that trades a lot of volume
    on a certain day or in general is not a problem in itself. This risk metric seeks
    mostly to prevent runaway algorithms from overtrading in the market in cases of
    software or configuration bugs or just unexpected market conditions. This can
    be implemented in many ways, but the simplest implementation would be to have
    a cap on how much volume a strategy is allowed to trade for a trading instrument
    before it automatically stops sending any new orders or trading further. Usually,
    at this point, an external human operator needs to make sure that the algorithm
    behavior is as expected and then resume the trading strategy or stop it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标不一定是一个风险；一个策略在某个特定日子或通常情况下交易大量体积本身并不是问题。这个风险指标主要旨在防止软件或配置错误或意外市场条件下失控算法在市场中过度交易。这可以通过许多方式实现，但最简单的实现方式是在策略自动停止发送任何新订单或进一步交易之前，对策略允许交易的交易工具的量进行上限控制。通常，在这种情况下，外部人工操作员需要确保算法行为符合预期，然后继续交易策略或停止它。
- en: Risk to manage rate of orders, trades, and losses
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理订单、交易和损失的风险比率
- en: The risk metrics we will discuss in this subsection fall into the **rate-based**
    risk management category. What we mean by rate-based is that the risk is computed
    for sliding windows of time to make sure that the strategy does not send too many
    orders in each window, does not trade too much in each time window, does not lose
    too much money in each window, and so on. Again, these metrics are to prevent
    trading strategy behavior that is unexpected or resembles an out-of-control or
    runaway algorithm. These are implemented by either resetting the counters for
    the underlying metric (number of orders or number of trades or traded volume or
    loss) at the end of the time-period window or using a rolling counter of these
    metrics. These risk metrics also implicitly prevent the trading strategy from
    behaving unexpectedly during periods of super-heightened volatility or flash crash-style
    scenarios.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中我们将讨论的风险指标属于**基于比率**的风险管理类别。我们所说的基于比率是指风险是根据滑动时间窗口计算的，以确保策略在每一个窗口中不会发送过多的订单，不会在每个时间窗口中进行过多的交易，不会在每个窗口中损失过多的资金，等等。再次强调，这些指标是为了防止交易策略出现意外行为或类似失控或失控算法的行为。这些是通过在时间窗口结束时重置基础指标的计数器（订单数量或交易数量或交易量或损失）或使用这些指标的滚动计数器来实现的。这些风险指标还隐含地防止交易策略在超级高度波动的时期或闪崩式场景中出现意外行为。
- en: Finally, we will design the last major component in our electronic trading ecosystem.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设计我们电子交易生态系统中最后一个主要组件。
- en: Designing our trading strategy framework
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计我们的交易策略框架
- en: Let us discuss a few design details for the trading strategy framework we will
    implement in our participant’s trading system. We present only the trading strategy
    framework from *Figure 5**.1* here so we can discuss the design in greater detail.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们将在参与者的交易系统中实施的交易策略框架的一些设计细节。在这里，我们只展示*图5.1*中的交易策略框架，以便我们可以更详细地讨论设计。
- en: '![Figure 5.9 – Design of our trading strategy framework](img/B19434_05_09.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 我们交易策略框架的设计](img/B19434_05_09.jpg)'
- en: Figure 5.9 – Design of our trading strategy framework
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 我们交易策略框架的设计
- en: Now we will discuss the design of the major subcomponents in the trading strategy
    framework we will build in this book. Note that we use the terms **trading strategy
    framework** and **trading engine** interchangeably and they mean the same thing
    in the context of this book – a collection of components to house and run automated
    trading algorithms.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论我们将在本书中构建的交易策略框架的主要子组件的设计。请注意，我们使用“交易策略框架”和“交易引擎”这两个术语可以互换使用，在本书的上下文中它们意味着相同的东西——一个组件集合，用于容纳和运行自动化交易算法。
- en: Limit order book
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限价订单簿
- en: The limit order book in the trading strategy framework is similar to the one
    that the exchange matching engine builds. Obviously, the goal here is not to perform
    matching between orders but instead to build, maintain, and update the limit order
    book from the market data updates consumed by the market data consumer via the
    lock-free queue. The requirement to support efficient insertion, modification,
    and deletion of orders into this book still applies here. The other goal here
    is to also make this order book accessible for use cases that the feature engine
    and trading strategy components require. There can be various use cases; one example
    is being able to synthesize a BBO or TOB quickly and efficiently for components
    that only need the best prices and quantities. Another example would be the ability
    to track the strategy’s own orders in the limit order book to find where they
    are in the FIFO queue at a price level. Yet another example would be the ability
    to detect executions on a strategy’s orders from the public market data feed,
    which can be a big boost during times when the private order feed is lagging behind
    the public market data feed. Implementing these details in the trading strategies
    we build in this book is out of the scope of what we can cover. But in practice,
    these details are extremely important since the advantage one gains from detecting
    executions from both the order responses and market data can be tens, hundreds,
    or even thousands of microseconds in latency. Here, we will use the lock-free
    queue that we built in the *Transferring data using lock-free queues* section
    and the memory pool we built in the *Designing C++ memory pools to avoid dynamic
    memory allocations* section in the previous chapter, *Building the C++ Building
    Blocks for* *Low-Latency Applications*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 交易策略框架中的限价订单簿与交易所匹配引擎构建的类似。显然，这里的目的是不是执行订单之间的匹配，而是从通过无锁队列由市场数据消费者消耗的市场数据更新中构建、维护和更新限价订单簿。支持高效地向此簿中插入、修改和删除订单的要求仍然适用。这里的另一个目标是使此订单簿可供功能引擎和交易策略组件所需的用例使用。可能有各种用例；一个例子是能够快速有效地为仅需要最佳价格和数量的组件合成BBO或TOB。另一个例子是能够跟踪策略在限价订单簿中的自身订单，以找到它们在FIFO队列中的价格水平。另一个例子是能够从公开市场数据源检测策略订单的执行，这在私有订单源落后于公开市场数据源时可以提供很大的帮助。在我们这本书中构建的交易策略中实现这些细节超出了我们所能涵盖的范围。但在实践中，这些细节非常重要，因为从订单响应和市场数据中检测执行所获得的优势可以在延迟上达到数十、数百甚至数千微秒。在这里，我们将使用我们在“使用无锁队列传输数据”部分构建的无锁队列，以及我们在上一章“为低延迟应用构建C++构建块”中构建的内存池。
- en: Feature engine
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能引擎
- en: We mentioned before that we will be building a minimal feature engine in this
    book. Our feature engine will only support a single feature computed from the
    data available from our order book, and this single feature will be used to drive
    our trading strategies. This feature will be updated when there are substantial
    changes to the order book in terms of price or liquidity and as trades occur in
    the market. When the feature is updated, the trading strategy can use the new
    feature value to re-evaluate its position, live orders, and so on to make a trading
    decision.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，在这本书中我们将构建一个最小功能引擎。我们的功能引擎将只支持从我们的订单簿中可用的数据计算出的单个特征，并且这个单一特征将用于驱动我们的交易策略。当订单簿在价格或流动性方面发生实质性变化，以及市场发生交易时，这个特征将被更新。当特征更新时，交易策略可以使用新的特征值来重新评估其头寸、实时订单等，以做出交易决策。
- en: Trading strategy
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易策略
- en: The trading strategy is the component that finally makes the trading decisions
    based on a multitude of factors. The trading decisions depend on the trading algorithm
    itself, the feature values from the feature engine, the state of the order book,
    the prices and FIFO position of the strategy’s orders in the order book, risk
    evaluations from the risk manager, the state of the live orders from the order
    manager, and so on. This is where most of the complexity of the trading strategy
    framework resides because it needs to handle a lot of different conditions and
    execute the orders safely and profitably. In this book, we will build two distinct
    kinds of basic trading algorithms – **market-making**, also known as **liquidity-providing
    strategies**, and **taking strategies**, also known as **liquidity-removing strategies**.
    Market-making strategies have passive orders in the book and rely on other market
    participants crossing the spread to trade against us. Liquidity-taking strategies
    are the strategies that cross the spread and send aggressive orders to take out
    passive liquidity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 交易策略是最终基于众多因素做出交易决策的组件。交易决策取决于交易算法本身、特征引擎的特征值、订单簿的状态、策略订单在订单簿中的价格和FIFO位置、风险管理器的风险评估、订单管理器中活跃订单的状态等等。这就是交易策略框架的大部分复杂性所在，因为它需要处理许多不同的条件，并安全且有利可图地执行订单。在这本书中，我们将构建两种不同类型的基本交易算法——**做市商**，也称为**流动性提供策略**，以及**套利策略**，也称为**流动性移除策略**。做市商策略在订单簿中有被动订单，并依赖于其他市场参与者跨价差与我们交易。流动性移除策略是跨价差并发送主动订单以移除被动流动性的策略。
- en: Order manager
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单管理器
- en: The order manager component is an abstraction that hides the lower-level details
    of sending order requests, managing the states of active orders, handling **in-flight
    conditions** (we will explain this shortly) for these orders, handling responses
    from the exchange, handling scenarios around partial and full executions of orders,
    and managing positions. The order manager also builds and maintains a couple of
    different data structures to track the state of the strategy’s orders. In some
    sense, the order manager is like the limit order book, except it manages a tiny
    subset of the orders that belong to the strategy.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理器组件是一个抽象层，它隐藏了发送订单请求、管理活跃订单状态、处理**在途条件**（我们稍后会解释）以及这些订单的响应、处理订单部分和全部执行的场景，以及管理头寸的底层细节。订单管理器还构建并维护了一些不同的数据结构来跟踪策略订单的状态。在某种程度上，订单管理器类似于限价订单簿，但它只管理属于策略的订单的一个小子集。
- en: On the other hand, there is some additional complexity in the order management
    since there are some cases where order requests are in-flight from the market
    participant to the exchange and some events happen in the exchange matching engine
    at the same time. An example of an in-flight condition would be the scenario where
    the client tries to cancel an active order and sends a cancel request to the exchange.
    But while this cancel request is in-flight to the exchange, the matching engine
    at the exchange executes the order because an aggressor that would match this
    order shows up. Then, by the time the cancel request finally reaches the matching
    engine, the order is already executed and removed from the limit order book at
    the exchange, resulting in a cancel reject for this request. The order manager
    needs to be able to handle all different scenarios like this one accurately and
    efficiently.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，订单管理中存在一些额外的复杂性，因为有些情况下，市场参与者向交易所发送的订单请求是在途的，同时交易所的匹配引擎发生了一些事件。一个在途条件的例子是，当客户端试图取消一个活跃订单并向交易所发送取消请求时。但是，当这个取消请求在途时，由于一个会匹配这个订单的对手方出现，交易所的匹配引擎会执行这个订单。然后，当取消请求最终到达匹配引擎时，订单已经被执行并从交易所的限价订单簿中移除，导致这个请求被拒绝。订单管理器需要能够准确且高效地处理所有这类不同场景。
- en: In this book, we will build an order manager that can be used to manage passive
    and aggressive orders and can handle all these different conditions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将构建一个订单管理器，它可以用来管理被动和主动订单，并能够处理所有这些不同的条件。
- en: Risk manager
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 风险管理器
- en: The risk manager tracks the different risk metrics we described in the previous
    section, *Understanding the risk management systems*. Additionally, the risk manager
    needs to notify the trading strategy about events where risk limits are breached
    so that the trading strategy can reduce risk and/or shut down safely. In our trading
    infrastructure, we will implement a few basic risk metrics, such as position,
    total loss, and messaging rates for order requests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 风险经理跟踪我们在上一节“理解风险管理系统”中描述的不同风险指标。此外，风险经理还需要通知交易策略关于风险限制被突破的事件，以便交易策略可以降低风险或安全地关闭。在我们的交易基础设施中，我们将实施一些基本的风险指标，例如头寸、总损失和订单请求的消息速率。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes our discussion of the details and design of the major components
    in our electronic trading ecosystem. Let us summarize the concepts, components,
    and interactions we discussed, as well as the design of the components that build
    the electronic trading ecosystem we will build.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对电子交易生态系统主要组件的细节和设计的讨论。让我们总结一下我们讨论的概念、组件和交互，以及构建我们将要构建的电子交易生态系统的组件设计。
- en: We started off by presenting the topology of the electronic trading ecosystem.
    This consists of the electronic trading exchange and many market participants
    that want to trade on that exchange. The electronic trading exchange infrastructure
    itself consists of three major components at a high level – the matching engine,
    the market data publisher, and the order gateway server infrastructure. From a
    market participant’s perspective, the major components are the market data subscriber
    and consumer, the trading strategy framework with all its subcomponents, and the
    order gateway client infrastructure.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了电子交易生态系统的拓扑结构。这包括电子交易交易所和许多想要在该交易所进行交易的市场参与者。从高层次来看，电子交易交易所基础设施本身由三个主要组件组成——匹配引擎、市场数据发布者和订单网关服务器基础设施。从市场参与者的角度来看，主要组件包括市场数据订阅者和消费者、包含所有子组件的交易策略框架以及订单网关客户端基础设施。
- en: Next, we performed a deep dive into the exchange matching engine details. We
    explained the responsibilities of this component and how it builds, maintains,
    and updates the limit order book and matches participant orders that cross against
    each other. We concluded that section by designing our simplified matching engine
    component and its subcomponents, which we will implement in the next chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了交易所匹配引擎的细节。我们解释了该组件的职责以及它是如何构建、维护和更新限价订单簿并匹配相互交叉的参与者订单的。我们在那一节结束时设计了我们的简化匹配引擎组件及其子组件，这些将在下一章中实现。
- en: The next topics of discussion were the market data publisher and the order gateway
    server infrastructure at the exchange. We described in great detail the different
    messages that the market data feed is composed of, the market data feed protocol,
    as well as designing the components inside the market data publisher. We also
    discussed the order gateway server, which the exchange hosts as an endpoint for
    the market participants to connect to, forward order requests, and receive order
    responses and notifications for their orders getting executed by the matching
    engine. We presented the design of the order gateway server with all its subcomponents,
    which we will implement in later chapters of this book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的讨论主题是交易所的市场数据发布者和订单网关服务器基础设施。我们详细描述了市场数据馈送由哪些不同消息组成，市场数据馈送协议，以及设计市场数据发布者内部的组件。我们还讨论了订单网关服务器，这是交易所作为市场参与者连接到、转发订单请求并接收订单响应和通知的端点。我们展示了包含所有子组件的订单网关服务器的设计，这些将在本书的后续章节中实现。
- en: The section following that took a look at the market participants’ trading systems.
    First, we discussed the details for the market data consumer and the order gateway
    client infrastructure, which the participants use to consume the public market
    data feed from the exchange and connect to and communicate with the exchange.
    We also presented and discussed the design of the market data consumer we will
    build, as well as how it synchronizes and decodes the exchange market data feed.
    Finally, we designed the order gateway client infrastructure, which the trading
    system will use to connect to and communicate with the exchange’s order gateway
    server infrastructure.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后的部分，我们考察了市场参与者的交易系统。首先，我们讨论了市场数据消费者和订单网关客户端基础设施的细节，这些是参与者用来从交易所消费公共市场数据流并连接到以及与交易所通信的基础设施。我们还介绍了我们将要构建的市场数据消费者的设计，以及它是如何同步和解码交易所市场数据流的。最后，我们设计了订单网关客户端基础设施，这是交易系统将要用来连接到以及与交易所的订单网关服务器基础设施通信的。
- en: The final section of this chapter was dedicated to describing and designing
    the framework for trading strategies. We described the major components we will
    need to build this framework – the order book, the feature engine, the execution
    logic framework, and the risk management subcomponent. Finally, we laid out the
    design of the trading infrastructure we will build so that you can understand
    the higher-level design of this component before we dive into the lower-level
    details in subsequent chapters.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分致力于描述和设计交易策略框架。我们描述了我们将需要构建此框架的主要组件——订单簿、功能引擎、执行逻辑框架以及风险管理子组件。最后，我们概述了我们将要构建的交易基础设施的设计，以便您在我们深入到后续章节中的底层细节之前，可以理解此组件的高级设计。
- en: The next chapter jumps into the implementation details of the matching engine
    framework we designed in this chapter. Note that we will reuse a lot of the basic
    building blocks we built in the previous chapter moving forward as we implement
    our electronic trading ecosystem. The motivation for building the basic building
    blocks will become clearer as we implement the rest of the system, starting in
    the next chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将跳入我们本章设计的匹配引擎框架的实现细节。请注意，在实现我们的电子交易生态系统时，我们将重用我们在上一章中构建的大量基本构建块。随着我们开始实现系统的其余部分，构建基本构建块的动力将变得更加清晰。
