- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Designing Our Trading Ecosystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的交易生态系统
- en: The previous chapter jumped into some hands-on, low-latency development in C++,
    where we built some basic building blocks to be used throughout the rest of this
    book. Now we are ready to start designing our electronic trading ecosystem, which
    will be our main project for the rest of this book, where we will learn about
    low-latency application development principles in practice. First, we will discuss
    the high-level design and architecture of the different low-latency components
    or applications that we will be building for the end-to-end electronic trading
    ecosystem. We will also design the abstractions, components, and interactions
    between them, which we will implement in the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章我们直接进入了C++的实战、低延迟开发，其中我们构建了一些将在本书剩余部分使用的基石。现在我们准备开始设计我们的电子交易生态系统，这将是本书剩余部分的主要项目，我们将学习低延迟应用开发的实际原则。首先，我们将讨论我们将为端到端电子交易生态系统构建的不同低延迟组件或应用程序的高层次设计和架构。我们还将设计它们之间的抽象、组件和交互，这些将在本书的其余部分实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the layout of the electronic trading ecosystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解电子交易生态系统的布局
- en: Designing the C++ matching engine in a trading exchange
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交易交易所设计C++撮合引擎
- en: Understanding how an exchange publishes information to participants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解交易所如何向参与者发布信息
- en: Building a market participant’s interface to the exchange
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建市场参与者与交易所的接口
- en: Designing a framework for low-latency C++ trading algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计低延迟C++交易算法的框架
- en: Let us kick off this chapter by describing the high-level topology of the electronic
    trading ecosystem we will design and build in the rest of this book. We will briefly
    introduce the different components in the next section and then have a much more
    detailed discussion in the rest of this chapter. One thing to keep in mind is
    that the electronic trading ecosystem we will be building in this book is a simplified
    version of what is found in practice. Not only is it a simplified version but
    it is also a subset of all the components you would need in practice to build
    and run a full electronic trading ecosystem. The components we will build in this
    book were chosen because they are the most latency-sensitive components, and we
    try to keep our focus on low-latency application development. We would like to
    mention that, in practice, you will find components such as historical data capture
    at the exchange and client ends, connections to clearing brokers, backend systems
    for transaction processing, accounting and reconciliation at both the exchange
    and trading client’s ends, backtesting frameworks (testing against historical
    data), and many others.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述我们将在这本书的剩余部分设计和构建的电子交易生态系统的整体拓扑结构来开启这一章。我们将在下一节简要介绍不同的组件，然后在本章的其余部分进行更详细的讨论。有一点需要记住的是，我们将在本书中构建的电子交易生态系统是实践中存在的简化版本。这不仅是一个简化版本，而且它还是所有实际构建和运行完整电子交易生态系统所需组件的一个子集。我们选择在本书中构建的组件是因为它们是最对延迟敏感的组件，我们试图将我们的重点放在低延迟应用开发上。我们想提一下，在实践中，你将发现诸如在交易所和客户端端的历史数据捕获、与清算经纪人的连接、交易处理、会计和结算的后端系统、针对历史数据的回测框架（测试）以及许多其他组件。
- en: Understanding the layout of the electronic trading ecosystem
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解电子交易生态系统的布局
- en: First, we start by providing the higher-level layout of the electronic trading
    ecosystem we will be building in the rest of this book. Before we get into the
    details, we start with the disclaimer that this is a simplified design of what
    happens in practice in electronic trading markets. Simplification was necessary
    to limit the scope to what can be covered in this book; however, it is still an
    accurate but simplified representation of what you will find in practice. The
    other thing to note is that the goal here is to understand the design and implementation
    of low-latency applications, so we ask you to focus more on the application of
    C++ and computer science principles that we apply and less on the details of the
    trading ecosystem itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始提供本书其余部分将要构建的电子交易生态系统的更高层次布局。在深入细节之前，我们首先声明这是一个简化的设计，它代表了电子交易市场实际发生的情况。简化是必要的，以便将范围限制在本书可以涵盖的内容内；然而，这仍然是对实践中发现内容的准确但简化的表示。需要注意的是，这里的目的是理解低延迟应用程序的设计和实现，因此我们要求您更多地关注我们应用C++和计算机科学原理的应用，而不是交易生态系统本身的细节。
- en: Now, let us kick off this introduction by defining and explaining the overall
    topology of the electronic trading ecosystem and the components involved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过定义和解释电子交易生态系统及其组成部分的整体拓扑结构来开始这次介绍。
- en: Defining the topology of the electronic trading ecosystem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义电子交易生态系统的拓扑结构
- en: 'Let us first provide a bird’s eye view of the system with the diagram presented
    here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过以下图表提供一个系统的鸟瞰图：
- en: "![Figure 5.1 – Topology of a \uFEFFsimple electronic trading ecosystem](img/B19434_05_01.jpg)"
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 简单电子交易生态系统的拓扑结构](img/B19434_05_01.jpg)'
- en: Figure 5.1 – Topology of a simple electronic trading ecosystem
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 简单电子交易生态系统的拓扑结构
- en: The major components, as laid out in the preceding diagram, are the following,
    split at a high level depending on whether it belongs on the exchange side or
    the trading client/market-participant side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 主要组成部分，如前图所示，如下所示，根据其属于交易所侧还是交易客户端/市场参与者侧进行高级别划分。
- en: 'These are the exchange components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是交易所组件：
- en: Matching engine at the electronic trading exchange
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子交易交易所的匹配引擎
- en: Order gateway server and protocol encoder and decoder at the trading exchange
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易交易所的订单网关服务器和协议编码器/解码器
- en: Market data encoder and publisher at the exchange
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易所的市场数据编码器和发布者
- en: 'These are the trading client components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是交易客户端组件：
- en: Market data consumer and decoder for a market participant interested in this
    market data
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对该市场数据感兴趣的市场参与者使用的市场数据消费者和解码器
- en: Order gateway encoder and decoder client in the market participant’s system
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场参与者系统中的订单网关编码器和解码器客户端
- en: Trading engine inside the participant’s system
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者系统内的交易引擎
- en: We will quickly introduce each one of these components in the next section and
    then discuss them in detail in the rest of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中快速介绍这些组件中的每一个，然后在本书的其余部分详细讨论它们。
- en: Introducing the components of the electronic trading ecosystem
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍电子交易生态系统的组成部分
- en: Here, we will quickly introduce the different components that make up the electronic
    trading ecosystem. One thing to keep in mind is that each one of these components
    in a competitive ecosystem needs to be designed such that they can process events
    and data with the lowest latencies possible. Also note that during periods of
    heightened volatility, these systems must be able to keep up with and react to
    large bursts in market activity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速介绍构成电子交易生态系统的不同组件。需要注意的是，在竞争性生态系统中，每个组件都需要设计成能够以尽可能低的延迟处理事件和数据。另外，请注意，在市场波动加剧的时期，这些系统必须能够跟上并反应市场活动的大幅波动。
- en: Introducing the market data publisher
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍市场数据发布者
- en: The market data publisher at the trading exchange is responsible for communicating
    every change to the limit order book maintained by the matching engine to the
    market participants. Compared to the order gateway, the difference here is that
    the market data publisher publishes public data meant for all participants, and
    it typically hides details of which order belongs to which participant to maintain
    fairness. Another difference is that the order gateway infrastructure only communicates
    order updates to the market participants whose orders were impacted by the change
    and not to all market participants. The market data publisher can use TCP or UDP
    to publish market data, but given the large volume of market data updates, UDP
    multicast is the preferred network-level protocol. The market data publisher is
    also responsible for converting the internal matching engine format into the market
    data format before publishing the updates.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the matching engine
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The matching engine at the electronic trading exchange is the most critical
    piece of the trading exchange. It is responsible for handling requests from market
    participants for their orders and updating the limit order book that it maintains.
    These requests are generated when the clients want to add a new order, replace
    an existing order, cancel an existing order, and so on. The limit order book is
    a collection of all orders sent by all participants aggregated into a central
    single book consisting of bids (buy orders) and asks (sell orders). The matching
    engine is also responsible for performing matches between orders that cross in
    price (i.e., matching buy orders with sell orders when the buy price is higher
    than or equal to the sell price). During special market states such as **PreOpen**
    (right before the market opens), **Auction**/**Opening** (right at the moment
    at which the market opens), **PreOpenNoCancel** (orders can be entered but not
    canceled), and so on, the rules are slightly different, but we will not worry
    about those rules or implement them to keep the focus on low-latency application
    development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the order gateway server at the exchange
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order gateway server at the exchange is responsible for accepting connections
    from market participants so that they can send requests for orders and receive
    notifications when there are updates to their respective orders. The order gateway
    server is also responsible for translating messages between the matching engine
    format and the order gateway messaging protocol. The network protocol used for
    the order gateway server is always TCP to enforce in-order delivery of messages
    and reliability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the market data consumer at the market participant level
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The market data consumer is the complement of the exchange market data publisher
    component on the market participants’ side. This component is responsible for
    subscribing to the UDP stream or the TCP server set up by the market data publisher,
    consuming the market data updates, and decoding the market data protocol into
    an internal format used by the rest of the trading engine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据消费者是市场参与者侧交易所市场数据发布组件的补充。该组件负责订阅由市场数据发布者设置的上UDP流或TCP服务器，消费市场数据更新，并将市场数据协议解码成交易引擎其他部分使用的内部格式。
- en: Introducing the order gateway encoder and decoder client
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍订单网关编解码器客户端
- en: The order gateway client component is the complement of the exchange order gateway
    server on the market participants’ side. The responsibility of this component
    is to establish and maintain TCP connections with the exchange’s order gateway
    infrastructure. It is also responsible for encoding strategy order requests in
    the correct exchange order messaging protocol and decoding exchange responses
    into an internal format that the trading engine uses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 订单网关客户端组件是市场参与者侧交易所订单网关服务器的补充。该组件的职责是建立并维护与交易所订单网关基础设施的TCP连接。它还负责将策略订单请求编码为正确的交易所订单消息协议，并将交易所响应解码成交易引擎使用的内部格式。
- en: Introducing the trading engine in the market participants’ systems
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在市场参与者系统中介绍交易引擎
- en: The trading engine is the brain of a market participant’s trading system. This
    is where intelligence resides, and where the trading decisions are made. This
    component is responsible for consuming the normalized market data updates from
    the market data consumer component. It will usually also build the complete limit
    order book to reflect the state of the market or, at the very least, a simplified
    variant of the order book, depending on the requirements of the trading strategies.
    It usually also builds analytics on top of the liquidity and prices from the order
    book and makes automated trading decisions. This component uses the order gateway
    client component to communicate with the trading exchange.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 交易引擎是市场参与者交易系统的核心。这是智能所在之处，也是交易决策做出的地方。该组件负责从市场数据消费者组件中消费标准化市场数据更新。它通常还会构建完整的限价订单簿，以反映市场状态，或者至少是订单簿的简化版本，这取决于交易策略的要求。它通常还会在订单簿的流动性和价格基础上构建分析，并做出自动化的交易决策。该组件使用订单网关客户端组件与交易交易所进行通信。
- en: Now that we have introduced the major components involved in our electronic
    trading ecosystem, we will look at these components in greater detail. First,
    we will start with the matching engine, which resides in the electronic trading
    exchange system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了电子交易生态系统中涉及的主要组件，我们将更详细地研究这些组件。首先，我们将从位于电子交易交易所系统中的匹配引擎开始。
- en: Designing the C++ matching engine in a trading exchange
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在交易交易所设计 C++ 匹配引擎
- en: In this section, we will discuss the matching engine component inside the electronic
    trading exchange system introduced in the previous section. The first thing we
    will do is understand what purpose the matching engine serves and why it is needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论上一节中介绍的电子交易交易所系统内的匹配引擎组件。我们首先要做的是理解匹配引擎的作用以及为什么需要它。
- en: Understanding the purpose of the matching engine
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解匹配引擎的目的
- en: In the electronic trading ecosystem consisting of a single trading exchange,
    generally, there is a single exchange that is responsible for accepting and managing
    orders from numerous market participants. The matching engine in this case accepts
    different kinds of orders that the participants are allowed to send for any given
    trading instrument. An **order** is simply a request sent by any market participant
    to the trading exchange to convey their interest in buying or selling a tradeable
    product. Every time a new order is received by the matching engine from the order
    gateway server infrastructure, it checks to see whether this new order crosses
    an existing order with an opposite side to see whether a trade occurs. For this
    book’s purposes, we will assume the market participants only send **limit orders**
    and specify the side of the order, quantity, and price. Limit orders are orders
    that can only execute at a price that is at, or better than, the price specified
    by the market participant.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: It should be obvious by now that the matching engine performs the most critical
    task of performing matches between orders from different market participants and
    does so correctly and fairly. By fairness, we mean that the orders that reach
    the exchange first are processed first, and this **first in, first out** (**FIFO**)
    ordering is handled in the order gateway infrastructure, which we will discuss
    shortly. Orders that do not match immediately rest in the book and are referred
    to as **passive orders**. These orders are eligible for matching when new orders
    come in with prices that cross the passive orders. Such orders that cross the
    prices on passive orders are known as **aggressive orders**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The matching engine arranges all the passive orders sent by all market participants
    into a data structure that is aptly named the **order book**. The details of this
    order book will be the topic of our next discussion.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the exchange order book
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The limit order book contains all the passive limit orders across all market
    participants for a single trading instrument. These are typically arranged from
    the highest buy price to the lowest buy price for passive buy orders, and from
    the lowest sell price to the highest sell price for passive sell orders. This
    ordering is intuitive and natural because passive buy orders are matched from
    highest to lowest buy prices and passive sell orders are matched from lowest to
    highest sell prices. For orders that have the same side and the same price, they
    are arranged in FIFO order based on when they were sent. Note that FIFO is just
    one ordering criterion; modern electronic trading markets have different types
    of matching algorithms, such as **Pro Rata** and some mix of FIFO and Pro Rata.
    Pro Rata is simply a matching algorithm where larger orders get larger fills from
    aggressive orders regardless of where they are in the FIFO queue. For our matching
    engine, we will only implement the FIFO matching algorithm.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand how the order book works, we will look at a few scenarios
    that happen in the market and how they impact the order book. Let us first establish
    the starting state of the order book. Let us assume there are orders belonging
    to three different market participants – clients A, B, and C on the buy and sell
    sides.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | Client B OrderId 5 SELL 10 @ 11.00 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 2 BUY 10 @ 10.80 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| Client B OrderId 3 BUY 5 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| Client C OrderId 4 BUY 100 @ 10.70 |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Initial state of the limit order book consisting of some orders
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Here, client A has 2 passive buy orders of quantities of 20 and 10 at prices
    of 10.90 and 10.80, respectively. Client B has a buy order of a quantity of 5
    at 10.80, and 2 sell orders of quantities of 10 and 5 at prices of 11.00 and 11.10,
    respectively. Client C has 2 passive orders – a buy of a quantity of 5 at 10.80
    and a sell of a quantity of 5 at 11.00, respectively. Now, let us assume client
    A sends a new buy order of a quantity of 10 at the price of 10.90 and client B
    sends a new sell order of a quantity of 10 at the price of 11.20\. The updated
    order book is shown in the following table and the new orders are highlighted.
    Due to the FIFO ordering, the new buy order of *OrderId=8* is behind the buy order
    of *OrderId=1* at the same price.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | Client B OrderId 5 SELL 10 @ 11.00 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| **Client A OrderId 8 BUY 10 @** **10.90** | Client C OrderId 6 Sell 5 @ 11.00
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 2 BUY 10 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| Client B OrderId 3 BUY 5 @ 10.80 | **Client B OrderId 9 SELL 10 @** **11.20**
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| Client C OrderId 4 BUY 100 @ 10.70 |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: Table 5.2 – Updated order book with newly added orders
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us assume that client A modifies the order with *OrderId=2* to go from
    a quantity of 10 to a quantity of 20\. When an order’s quantity is increased in
    such a manner, the order loses priority in the FIFO ordering and goes to the back
    of the queue at that price level. Let us also assume that client B modifies the
    order of *OrderId=5* to reduce the order’s quantity from 10 to 1\. Note that per
    the rules of the market, when an order’s quantity is reduced, it does not lose
    its priority in the queue and still stays where it is. The updated order book
    is shown next, and the orders that are impacted are highlighted:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | **Client B OrderId 5 SELL 1 @** **11.00**
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 8 BUY 10 @ 10.90 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 3 BUY 5 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| **Client B OrderId 2 BUY 20 @** **10.80** | Client B OrderId 9 SELL 10 @
    11.20 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| Client C OrderId 4 BUY 100 @ 10.70 |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: Table 5.3 – State of the order book after the modification of an order
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us assume that client A modifies the buy order with *OrderId=4*
    from a price of 10.70 to a price of 10.90 with no changes to quantity. The impact
    of this order action is equivalent to canceling the order and sending a new order
    at the new price. Let us also assume that client B decides that they no longer
    want the sell order of *OrderId=9* and sends a cancel for it. The updated order
    book due to these two actions is shown next, with the modified order highlighted
    and the canceled order removed from the order book:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | **Client B OrderId 5 SELL 1 @** **11.00**
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 8 BUY 10 @ 10.90 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| **Client C OrderId 4 BUY 100 @** **10.90** | Client B OrderId 7 SELL 5 @
    11.10 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 3 BUY 5 @ 10.80 |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| Client B OrderId 2 BUY 20 @ 10.80 |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: Table 5.4 – Limit order book state after the modification and cancellation actions
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: So far in the scenarios we discussed, there has not been a trade because the
    order activity has been such that all buy orders have prices lower than all sell
    orders. Let us further this discussion in the next section and see what happens
    when there is an aggressive order that can cross the buy or sell order prices
    and what that does.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things to note here as far as order modification is concerned are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: When orders are modified to reduce the quantity, the priority or position of
    the order in the queue does not change
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When orders are modified to increase the quantity or the price of the order
    is modified, it has the equivalent effect of canceling the order and sending the
    order with the new price and quantity values (i.e., a new priority will be assigned
    to it)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at the next big task that a matching engine
    needs to perform – matching participant orders that cross each other.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Matching participant orders
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will understand what happens when a market participant modifies
    an existing order or sends a new order in such a way that the price on this order
    will cause a match against an existing passive order on the other side. In such
    a scenario, the matching engine matches this aggressive order against passive
    orders in order from most aggressive to least aggressive price. This means passive
    bids are matched from highest to lowest buy prices, and passive asks are matched
    from lowest to highest sell prices. In cases where the passive orders are not
    fully matched because the aggressive order has a smaller quantity than the passive
    liquidity available on the other side, then the remaining liquidity on the passive
    orders stays in the book. In cases where the aggressive order is not fully matched
    because the passive liquidity available on the other side is less than the quantity
    on the aggressive order, then the remaining quantity on the aggressive order rests
    in the book as a passive order.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us understand the different cases of matching participant orders and let
    us assume the state of the order book is where we left it in the last section,
    as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '| Client A OrderId 1 BUY 20 @ 10.90 | Client B OrderId 5 SELL 1 @ 11.00 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 8 BUY 10 @ 10.90 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| Client C OrderId 4 BUY 100 @ 10.90 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 3 BUY 5 @ 10.80 |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| Client B OrderId 2 BUY 20 @ 10.80 |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: Table 5.5 – Starting state of the order book before any order matches
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us assume client C sends a sell order of a quantity of 50 at a sell
    price of 10.90\. This will cause the sell order to match against the buy orders
    with *OrderId=1* and *OrderId=8*, which are fully matched, and *OrderId=4*, which
    is partially matched for a quantity of 20 and has the remaining quantity of 80\.
    The orders that are fully matched are removed from the order book and the partially-matched
    order is modified to the new remaining quantity. The updated order book after
    this matching transaction is shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '| **Client C OrderId 4 BUY 80 @** **10.90** | Client B OrderId 5 SELL 1 @ 11.00
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 3 BUY 5 @ 10.80 | Client C OrderId 6 Sell 5 @ 11.00 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| Client B OrderId 2 BUY 20 @ 10.80 | Client B OrderId 7 SELL 5 @ 11.10 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: Table 5.6 – Order book reflecting the impact of the aggressive order and partial
    executions
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us assume client A sends a buy order of a quantity of 10 at a buy
    price of 11.00\. This fully matches the sell orders with *OrderId=5* and *OrderId=6*,
    and the remaining unmatched quantity on the aggressive buy order rests in the
    book as a passive bid order. The updated order book after this matching transaction
    is shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '| **Client A OrderId 9 BUY 4 @** **11.00** | Client B OrderId 7 SELL 5 @ 11.10
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| Client C OrderId 4 BUY 80 @ 10.90 |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| Client A OrderId 3 BUY 5 @ 10.80 |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| Client B OrderId 2 BUY 20 @ 10.80 |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: Table 5.7 – Order book after full execution and resting quantity from the aggressor
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand a lot of the common interactions that we will encounter
    in the matching engine and how those are handled, as well as how they interact
    with the limit order book, we can design the matching engine we will build in
    this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Designing our matching engine
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will spend the rest of this book implementing each one of the C++ electronic
    trading ecosystem components we discussed in this chapter. However, before we
    get started on the next chapter, it is important to understand the architecture
    of these components to make the implementation details easier and clearer later
    on. We present only the matching engine component from *Figure 5**.1* here so
    we can discuss the design of our matching engine in a little more detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Design of our matching engine component](img/B19434_05_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Design of our matching engine component
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We present a few more details in this diagram compared to *Figure 5**.1* by
    discussing the major design choices for the matching engine next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Threading model
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our system, the matching engine, the market data publisher, and the order
    gateway server will be independent threads. This is intentional so that each one
    of these components can operate independently, and during periods of bursts in
    market activity, the entire system can achieve maximum throughput. Also, there
    are other tasks that each component needs to perform – for example, the order
    gateway server must maintain connectivity with all market participants, even when
    the matching engine is busy. Similarly, let us assume the market data publisher
    is busy sending out market data on the network; we do not want the matching engine
    or the order gateway server to slow down. We already saw how to create threads,
    set affinity on them, and assign tasks for them to do in the previous chapter,
    *Building the C++ Building Blocks for Low-Latency Applications*, in the *C++ threading
    for multi-threaded low-latency* *applications* section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Communication between threads
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important thing to discuss here is the communication between the matching
    engine and the order gateway server infrastructure. The order gateway server serializes
    the order requests coming in from the market participants and forwards them to
    the matching engine for processing. The matching engine needs to generate a response
    for order requests and send them back to the order gateway server. Additionally,
    it also needs to inform the order gateway server about executions that happen
    on the participant’s orders so that they can be informed about the trades. So,
    it needs a bi-directional queue, or one queue from the order gateway server to
    the matching engine and another queue from the matching engine to the order gateway
    server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Another communication channel is when the matching engine generates and sends
    market data updates to reflect the updated state of the limit order book for the
    public market data publisher component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since the matching engine, the order gateway server, and the market
    data publisher are all different threads, here we find a perfect case for a lock-free
    queue. We will use the lock-free FIFO queue we created in the previous chapter
    in the *Transferring data using lock-free* *queues* section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Limit order book
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, for the limit order book, we will use a couple of different data structures
    to implement it efficiently. Without diving into specific implementation details
    (which we will look at in the next chapter), we need to maintain the bids and
    asks in the correct sorted order on both sides to facilitate efficient matching
    when aggressive orders come in. We need to be able to efficiently insert and remove
    orders from the price levels to support operations such as adding, modifying,
    and deleting orders based on client requests. One other particularly important
    consideration here is that the data structures we use and the order objects themselves
    must avoid dynamic memory allocations and copy as little data around as possible.
    We will make heavy use of the memory pool we created in the previous chapter in
    the *Designing C++ memory pools to avoid dynamic memory* *allocations* section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how an exchange publishes information to participants
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section was dedicated to discussing the details of the matching
    engine, and in that discussion, we assumed that the matching engine receives market
    participants’ order requests from the order gateway server infrastructure. We
    also implicitly assumed that the matching engine would communicate changes to
    the limit order book it maintains to all the market participants listening to
    the market data feed. In this section, we will discuss the market data publisher
    and the order gateway server components that the matching engine relies on to
    communicate with the market participants.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Communicating market events through markets data
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us discuss the market data publisher component first. This component is
    responsible for converting the updates to the limit order book maintained by the
    matching engine. We mentioned before that the market data network level protocol
    can be TCP or UDP but generally, the preferred protocol in practice is UDP, and
    that is the protocol we will be using in our market data publisher as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, the market data protocol represents the format of the messages
    that the market data publisher publishes over the UDP (or in some cases TCP) protocol.
    **FIX Adapted for STreaming** (**FAST**) is the most well-known and popular messaging
    format for market data that is currently used by a lot of electronic trading exchanges.
    There are other protocols, such as **ITCH**, **PITCH**, **Enhanced Order Book
    Interface** (**EOBI**), **Simple Binary Encoding** (**SBE**), and many others,
    but for the purposes of this book, we will create a simple custom binary protocol
    such as EOBI or SBE that we will use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Since FIX is the most common protocol used in financial applications, we will
    present a few details here. FIX data is organized as a set of `TAG`=`VALUE` style
    fields. It will be easier to understand this with a simple example, so for a hypothetical
    market data update, you might receive the following collection of fields to convey
    all the data for that update. This hypothetical market data update corresponds
    to a new buy order of a quantity of 1,000 being added for the Apple company stock
    (stock symbol AAPL and numeric security ID 68475) at a price of 175.16.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '| **TAG** | **FIX NAME** | **VALUE** | **DESCRIPTION** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| 268 | NoMDEntries | 1 | Number of market data updates |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| 279 | MDUpdateAction | 0 (New) | Type of market data update |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| 269 | MDEntryType | 0 (Bid) | Type of market data entry |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| 48 | SecurityID | 68475 (AAPL) | Integer identifier for the trading product
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| 270 | MDEntryPx | 175.16 | Price of this market data update |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| 271 | MDEntrySize | 1000 | Quantity of this market data update |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| ... | ... | ... | ... |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: Table 5.8 – An example of a FIX message corresponding to a hypothetical market
    data update
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The different kinds of messages that make up the market data protocol are roughly
    categorized into the following categories:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Different market updates that an exchange sends out](img/B19434_05_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Different market updates that an exchange sends out
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Let us discuss these next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Market state changes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These messages notify the market participants about changes in the market and/or
    matching engine state. Typically, markets go through states such as **Closed**
    for trading, **Pre-open** (market state before regular trading sessions), **Opening**
    (when markets transition from the Pre-open to Trading states), and **Trading**
    (regular trading session).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Instrument updates
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The exchange uses instrument update messages to inform market participants
    about the different instruments available for trading. Some exchanges support
    special types of instruments that the market participants can create on the fly,
    and these messages are used to inform participants about changes to such instruments.
    Usually, these messages are used to inform participants about instrument metadata
    such as minimum price increments, tick size value, and more. The **minimum price
    increment** is the minimum price difference in order prices. In the examples we
    have seen so far, we assumed the minimum price increment to be 0.10 (i.e., valid
    prices are multiples of 0.10). The **tick size value** is the amount of money
    made or lost when we buy and sell at prices that are apart by a single minimum
    price increment. Very often, for products such as stocks, **Exchange Traded Fund**
    (**ETF**s), and so on, the tick size multiplier is just 1, meaning the profit
    or loss is simply the sell price minus the buy price for a pair of trades. ETFs
    are securities that trade at the exchange and are an investment option which consists
    of a basket of securities, i.e., by investing in an ETF, you invest in a bunch
    of assets that make up that ETF. But for some leveraged products such as futures,
    options, and so on, this tick size multiplier can be something other than 1, and
    the final profit or loss is computed as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`((sell-price – buy-price) / min-price-increment) * trade-qty *` `tick-size`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Order updates
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The market data publisher uses order update messages to communicate changes
    to the orders in the limit order book maintained by the matching engine – specifically,
    updates to the order book similar to what we discussed in the *Understanding the
    exchange order book* subsection in the *Designing the C++ matching engine in a
    trading exchange* section. Generally, the different kinds of order updates messages
    are the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`instrument-id`, `order-id`, `price`, `side`, `quantity`, and `priority`. The
    `priority` field here is used to specify the position of the order in the FIFO
    queue of orders at that price.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order Modify** – This is used by the exchange to let the participants know
    that a passive order was modified in price or quantity or both. This message has
    similar fields as an Order Add message. As mentioned before, in most cases (except
    when the order quantity is reduced), a new order priority value will be assigned
    for Order Modify events.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instrument-id` and `order-id` to specify the order being deleted from the
    order book.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trade messages
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trade messages are used by the exchange to notify the market participants that
    a match happened in the market. Generally, the attributes here are `instrument-id`,
    side of the aggressive order, execution price of the trade, and the traded quantity.
    Generally, when trades happen, the exchange also publishes as many Order Delete,
    Order Modify, and Order Add messages as needed to communicate information about
    which orders were fully and/or partially executed and need to be removed from
    the book or modified to reflect the new state of the order book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Market statistics
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are optional messages that some exchanges publish to communicate different
    types of statistics about trading instruments. These statistics can be information
    about traded volume for an instrument, open interest for the instrument, the highest,
    lowest, opening, and closing prices for the instrument, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We covered a lot of details about the market data messaging types and the information
    they try to convey. Now we are ready to design the market data publisher we will
    build in our electronic trading exchange next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Designing the market data publisher
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us discuss a few design details for the market data publisher we will implement
    in our electronic exchange. We present only the market data publisher from *Figure
    5**.1* here so we can discuss the design in greater detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Design of our market data publisher infrastructure](img/B19434_05_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Design of our market data publisher infrastructure
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: There are two main components of the market data publisher infrastructure. Both
    use the socket utilities we built in the previous chapter in the *C++ network
    programming using sockets* section to put the market data on the wire. This is
    in addition to the threading library we built, which will be used to create, launch,
    and run the market data publisher thread.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Market data protocol encoder
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The market data protocol encoder component inside the market data publisher
    infrastructure is responsible for encoding the market data updates published by
    the matching engine. The market data encoder consumes market data updates that
    reflect changes to the order book and converts them into the public market data
    messaging format with some additional information. This component also publishes
    the incremental market data updates to the UDP multicast stream configured for
    incremental streams. Remember that the incremental stream only contains market
    updates that can be used to update the order book, assuming the participant had
    an accurate view of the limit order book prior to the incremental update. The
    encoded market data updates are also published to the snapshot synthesizer component,
    which we will discuss in more detail in the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The market data stream is generally very high volume in terms of network traffic
    and experiences large bursts in activity, especially during periods of high volatility
    in the market. Since the TCP protocol adds extra bandwidth due to acknowledgments
    of message receipts and retransmissions of lost data, typically, UDP is the network
    protocol of choice for market data. Multicast streaming over UDP is also preferred
    since the market data can be disseminated on the multicast streams once and all
    interested subscribers can subscribe to that stream instead of having a one-to-one
    connection with each market data consumer over TCP. This design is not without
    some drawbacks, namely the possibility of market data consumers dropping UDP packets
    due to network congestion, slow hardware or software, and so on. When that happens,
    the order book that the trading client is maintaining is incorrect since they
    might have lost an update corresponding to a new order being added, an order being
    modified or canceled, and so on. This is the problem that the snapshot multicast
    streams solve, which we will explore with examples in subsequent chapters as we
    implement our market data consumers, but we will briefly introduce the snapshot
    synthesizer component in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据流在网络流量方面通常非常大，并且在市场波动性高的时期会经历大量的活动爆发。由于TCP协议因为消息收到的确认和丢失数据的重传而增加了额外的带宽，通常情况下，UDP是市场数据的首选网络协议。通过UDP的多播流进行流式传输也是首选，因为市场数据可以在多播流中一次性分发，所有感兴趣的订阅者都可以订阅该流，而不是通过TCP与每个市场数据消费者建立一对一的连接。这种设计并非没有缺点，即市场数据消费者可能会因为网络拥塞、硬件或软件缓慢等原因丢弃UDP数据包。当这种情况发生时，交易客户端维护的订单簿是不正确的，因为他们可能丢失了一个与新增订单、修改或取消订单等相对应的更新。这正是快照多播流解决的问题，我们将在后续章节中通过示例来探讨，但在下一节中，我们将简要介绍快照合成器组件。
- en: Snapshot synthesizer
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快照合成器
- en: The snapshot synthesizer consumes the encoded market date updates published
    by the market data protocol encoder, synthesizes the latest snapshot of the limit
    order book, and publishes the snapshot periodically to the snapshot multicast
    stream. The important point here is that the snapshot synthesis does not interfere
    with the incremental stream publishing so that incremental updates to the order
    book can be published as quickly as possible. It is a separate thread of execution,
    and the sole responsibility here is to generate an accurate snapshot of the order
    book based on the incremental updates. This component also adds the correct sequence
    information on the snapshot updates to facilitate synchronization at the client’s
    end before publishing it on the snapshot UDP multicast stream. What this means
    is that in the snapshot messages it sends out, it will provide the last sequence
    number from the incremental stream that was used to synthesize this snapshot message.
    This is important because the downstream market data consumer clients can use
    this sequence number of the last update in the incremental stream to perform successful
    synchronization/catch-up. This will become very clear when we build our market
    data publisher and market data consumer components because we will cover all the
    details with examples then. Another thing to understand is that the low-latency
    criteria that apply to the other components in our system do not apply here since
    this is a delayed and sub-sampled stream of information anyway. Additionally,
    packet drops are expected to be extremely rare on the client’s end and the snapshot
    synchronization process is slow on the client’s end, so trying to make this component
    super low latency is unnecessary. For our snapshot synthesizer component, we will
    also use the UDP protocol to keep it simple, but in practice, this is often a
    combination of TCP and UDP protocols. For low-latency market participants, packet
    drops on the UDP stream are expected to be rare because typically, the network
    connection to the exchange and switches along the way have a large bandwidth capacity
    and low switching latencies. Additionally, the participants invest resources into
    procuring and installing super-fast servers, building low-latency market data
    consumer software, and using special **Network Interface Cards** (**NICs**) to
    handle large volumes of market data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 快照合成器消费由市场数据协议编码器发布的编码市场数据更新，合成最新的限价订单簿快照，并将快照定期发布到快照多播流中。这里的重要点是快照合成不会干扰增量流发布，以便尽可能快地发布订单簿的增量更新。这是一个独立的执行线程，其唯一责任是根据增量更新生成订单簿的准确快照。此组件还在快照更新上添加正确的序列信息，以便在发布到快照UDP多播流之前在客户端端同步。这意味着在它发送的快照消息中，它将提供用于合成此快照消息的增量流中的最后一个序列号。这很重要，因为下游市场数据消费者客户端可以使用增量流中最后更新的这个序列号来执行成功的同步/追赶。当我们构建我们的市场数据发布器和市场数据消费者组件时，这一点将变得非常清楚，因为那时我们将通过示例涵盖所有细节。另一件需要理解的事情是，适用于我们系统中其他组件的低延迟标准不适用于这里，因为这是一个延迟和子采样的信息流。此外，客户端端预期数据包丢失将极为罕见，客户端端的快照同步过程较慢，因此尝试使此组件超低延迟是不必要的。对于我们的快照合成器组件，我们也将使用UDP协议以保持简单，但在实践中，这通常是TCP和UDP协议的组合。对于低延迟的市场参与者，预期UDP流中的数据包丢失将很少，因为通常，到交易所的网络连接以及沿途的交换机具有大带宽容量和低交换延迟。此外，参与者投入资源采购和安装超级快速的服务器，构建低延迟的市场数据消费者软件，并使用特殊的**网络接口卡**（**NICs**）来处理大量市场数据。
- en: This concludes our high-level design of the market data publisher infrastructure
    we will build in this book. Next, we need to discuss the other channel that the
    exchange uses to notify market participants about responses to their order requests
    as well as when their orders get executed – the order gateway interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中我们将构建的市场数据发布器基础设施的高级设计到此结束。接下来，我们需要讨论交易所用来通知市场参与者关于其订单请求响应以及订单何时被执行的其他渠道——订单网关接口。
- en: Notifying market participants through the order gateway interfaces
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过订单网关接口通知市场参与者
- en: We discussed that the market data consumer is used by the electronic trading
    exchange to disseminate public information about changes to the order book and
    matches happening for the different trading instruments available at the exchange.
    The point here is that this is public market data that is available to everyone
    that has access to and is subscribed to the market data stream. This section will
    discuss the other interface that the exchange uses to communicate with market
    participants about updates for their orders – the order gateway interface.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了市场数据消费者被电子交易交易所用来传播有关订单簿变化和交易所提供的不同交易工具匹配情况等公共信息。这里的要点是，这是对所有人开放的公共市场数据，只要他们能够访问并订阅市场数据流，就可以获取这些数据。本节将讨论交易所用来与市场参与者沟通其订单更新情况的另一个接口——订单网关接口。
- en: There are a few key differences between the information provided by the public
    market data feed and the information provided by the order gateway infrastructure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 公共市场数据馈送提供的信息与订单网关基础设施提供的信息之间有几个关键区别。
- en: Understanding the difference in network protocols
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解网络协议的差异
- en: We mentioned this before but we will reiterate here that typically, market data
    publishers use the UDP protocol at the network level, and the order gateway infrastructure
    uses the TCP protocol at the network level in their connections with market participants.
    This is because the data published by market data publishers is very voluminous
    and needs to be published as quickly as possible, hence the choice of UDP over
    TCP. There are generally additional synchronization mechanisms available on the
    market data publisher to deal with rare packet drops over UDP. The order gateway
    infrastructure relies on TCP because it needs a reliable method of communicating
    with the clients, and packet drops here are difficult to handle gracefully without
    TCP. Intuitively, it should be clear that it would be a major headache if clients
    were not sure that their orders reached the exchange or if clients weren’t sure
    they received immediate notifications when their orders are updated or matched.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经提到过，但在这里我们将再次强调，通常，市场数据发布者在网络层面使用UDP协议，而订单网关基础设施在其与市场参与者的连接中使用TCP协议。这是因为市场数据发布者发布的数据量非常大，需要尽可能快地发布，因此选择了UDP而不是TCP。市场数据发布者通常有额外的同步机制来处理UDP上罕见的包丢失。订单网关基础设施依赖于TCP，因为它需要一个可靠的方法与客户端通信，没有TCP，这里的包丢失很难优雅地处理。直观上，如果客户端不确定他们的订单是否到达了交易所，或者不确定他们的订单更新或匹配时是否立即收到了通知，这将是一个大问题。
- en: Differentiating between public and private information
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分公共信息和私人信息
- en: Perhaps the biggest difference between the market data publisher and the order
    gateway infrastructure is that the market data publisher publishes public information
    while hiding some sensitive information, such as which client an order belongs
    to or which clients participated in a matching transaction. This information is
    also published for all market participants and is meant to be used to construct
    the limit order book to reflect the state of a trading instrument. The order gateway
    server, on the other hand, only publishes order update notifications to the clients
    who own the orders that are being updated. Another way to think about this is
    that to receive and process public market data, a participant does not need to
    have any orders in the order book. But to receive private order gateway notifications
    the participant must have orders in the book, otherwise, there is nothing for
    the exchange to notify the client privately about.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据发布者与订单网关基础设施之间可能最大的区别是，市场数据发布者发布公共信息，同时隐藏一些敏感信息，例如订单属于哪个客户或哪些客户参与了匹配交易。这些信息也对所有市场参与者公开，目的是用来构建限价订单簿，以反映交易工具的状态。另一方面，订单网关服务器只向拥有正在更新的订单的客户发布订单更新通知。另一种思考方式是，为了接收和处理公共市场数据，参与者不需要在订单簿中有任何订单。但为了接收私人订单网关通知，参与者必须在订单簿中有订单，否则，交易所没有可以私下通知客户的内容。
- en: Sending order requests for participants’ orders
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为参与者发送订单请求
- en: Another major difference that should be obvious by now is that the order gateway
    component sending facilitates a bi-directional communication channel. What this
    means is that clients can send order requests to the exchange such as new orders,
    modify orders, cancel orders, and so on. On the other hand, as we discussed, the
    exchange uses the order gateway infrastructure to send private notifications for
    market participants’ orders. The market data publisher infrastructure does not
    generally service any client requests (i.e., the communication path is from the
    exchange to market data subscribers only).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The final sending component we need to design on the side of the electronic
    trading exchange is the order gateway infrastructure we just discussed; let us
    do that in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Designing the order gateway server
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us discuss a few design details for the order gateway server we will implement
    in our electronic exchange. We present only the order gateway server infrastructure
    from *Figure 5**.1* here so we can discuss the design of our order gateway server
    in a little more detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Design of our order gateway server infrastructure](img/B19434_05_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Design of our order gateway server infrastructure
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We present a few more details in this diagram compared to *Figure 5**.1* and
    break down some details about the subcomponents for the order gateway server infrastructure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: TCP connection server/manager
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first component inside the order gateway infrastructure is the TCP connection
    manager. This component is responsible for setting up a TCP server that listens
    to and accepts incoming TCP connections from market participants’ order gateway
    clients. It is also responsible for detecting clients who disconnect and removing
    them from the list of active connections. Finally, this component needs to forward
    order responses from the matching engine to the correct client for which the response
    is meant. We will use the socket utilities, TCP socket, and TCP server functionality
    we implemented in the *C++ network programming using sockets* section in the previous
    chapter, *Building the C++ Building Blocks for* *Low-Latency Applications*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: FIFO sequencer
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important task this component needs to do is maintain fairness when
    processing requests from market participants. As mentioned previously, to maintain
    fairness, client responses must be processed in the exact order they were received
    at the exchange infrastructure. So, the FIFO sequencer must ensure that it forwards
    client requests to the matching engine across the different client connections
    that the TCP connection manager maintains in the order in which they are received.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Exchange messaging protocol decoder and encoder
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The encoder-decoder component is responsible for translating between the exchange
    messaging protocol and whatever internal structures the matching engine expects
    client requests in and publishes client responses in. Depending on the complexity
    of the exchange protocol, this can be as straightforward as packaging and extracting
    the correct fields into and from a packed binary structure. If the exchange messaging
    format is more complicated, then there will be additional encoding and decoding
    steps involved. For this book’s purposes, we will have a simple exchange order
    messaging protocol that uses packed binary structures and has additional information
    on top of the format the exchange matching engine uses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the electronic trading exchange, and now we
    can move on to building the client-side infrastructure for a market participant
    that wishes to trade on this exchange.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Building a market participant’s interface to the exchange
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now discuss the purpose and design of the components in the market participants’
    systems. Specifically, we will start by discussing the market data consumer in
    the client’s trading system, which subscribes to, consumes, and decodes the public
    market data published by the exchange. We will also discuss the order gateway
    client infrastructure in the client’s trading system, which connects to the exchange
    order gateway server. The order gateway client is also responsible for sending
    order requests to the exchange and receiving and decoding responses for the client’s
    orders.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the market data consumer infrastructure
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The market data consumer component in a market participant’s trading system
    is the direct complement of the market data publisher component in the electronic
    trading exchange. It is responsible for subscribing to and consuming the multicast
    network traffic that the exchange publishes, decoding and normalizing the market
    data it reads from the exchange protocol to an internal format, and implementing
    packet drop-related synchronization mechanisms.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to and consuming UDP multicast traffic
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first and most obvious task is to subscribe to the multicast stream that
    the exchange is publishing market data on. Typically, in the interest of load
    balancing, the exchange groups different trading instruments on different multicast
    stream addresses. This lets clients choose a subset of all the data that the exchange
    is publishing, depending on the trading instrument and products that the client
    is interested in. Typically, this involves the clients joining the correct multicast
    streams, the addresses of which are public information available from the exchange.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and normalizing from exchange protocol
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the market data consumer needs to do is convert from the exchange
    market data protocol into an internal format that the rest of the components in
    the participant’s system use. Depending on the exchange market data protocol,
    this part of the component can vary in complexity and performance latencies. The
    fastest protocols are the ones where minimal decoding is required, such as EOBI
    and SBE, which are just binary-packed structures. What this means is that the
    market data format is such that decoding the stream just involves reinterpreting
    the byte stream as the binary-packed structure we expect to find in the stream
    and is as fast as it gets. More complicated protocols such as FAST generally take
    longer to decode and normalize.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing on startup and packet drops
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we discussed that usually exchanges prefer UDP to be the network
    protocol to deliver market data to the participants. While this speeds up the
    delivery of data to clients and achieves higher throughput, this also leaves us
    open to packet drops and out-of-order delivery due to the unreliable nature of
    UDP. To make sure that market participants see market data packets in the correct
    order, as well as detect packet drops when they occur, typically, there are packet-level
    and instrument-level sequence numbers that the participants should check.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that needs to be designed, both on the exchange market data publisher
    and the participants’ market data consumers, is a mechanism to recover from such
    packet drops. This same mechanism is also used by participants who join the market
    data stream after the markets are already open or if the participants need to
    restart their market data consumer components for any reason. In all such cases,
    the market data consumers in the client’s trading system needs to perform some
    synchronization to get the current and complete state of the limit order book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The commonly used design to achieve this synchronization is explained in this
    section. Usually, the exchange market data streams are broken down into two major
    groups – **snapshot streams** and **incremental streams**. We will explain the
    reason for having these two streams and how they help market participants handle
    cases of packet drops next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Incremental market data streams
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The incremental market data stream assumes that the market participant already
    has the correct view of the limit order book maintained by the matching engine,
    and this stream only publishes incremental updates to the previous state of the
    order book. This means that this stream is much lower in bandwidth requirements
    since it publishes only incremental updates to the book. Typically, under normal
    operating conditions, it is expected that market participants only be subscribed
    to the incremental streams to maintain the correct state of the order book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If the client drops a packet from this stream, then the state of the order book
    that they maintain might be inconsistent with what the matching engine has. The
    mechanism to handle this failure is to clear or reset the order book that the
    participant maintains. Then it needs to subscribe to the snapshot stream, which
    contains data for the full state of the entire order book (instead of only incremental
    updates) to synchronize to the correct state of the book once again. The protocol
    here is to clear the book, start queuing up incremental updates received from
    the incremental stream and wait to build the full state of the order book, and
    then apply the incremental updates to that full order book to finish the synchronization.
    Now, let us understand a few more details of what is published by the exchange
    on the snapshot market data streams.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot market data streams
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we mentioned before, the snapshot market data stream contains data that can
    be used to build the full order book from a completely empty state. Usually, this
    stream just contains a thorough list of *Order Add* messages corresponding to
    every single passive order that exists in the order book. The exchange usually
    throttles how often this list is updated and published, meaning it might only
    send out a stream of snapshot messages every couple of seconds or so. This is
    because, since this stream contains information about all the orders in the order
    book for every single trading instrument, it can become quite bandwidth-heavy.
    Additionally, since packet drops are an exceedingly rare occurrence and participants
    do not mind waiting a few seconds when they first start up to grab the correct
    state of the order book, the throttling does not usually have a large negative
    impact.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the discussion of the market data protocols and the synchronization
    process, so now we can design the market data consumer that we will implement.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Designing the market data consumer
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us discuss a few design details for the market data consumer we will implement
    in our market participant’s trading system. We present only the market data consumer
    from *Figure 5**.1* here so we can discuss the design in greater detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Design of our market data consumer infrastructure](img/B19434_05_06.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Design of our market data consumer infrastructure
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Let us discuss the two primary subcomponents when it comes to the design of
    the market data consumer infrastructure in a market participant’s trading system.
    Both use the socket utilities we built in the previous chapter in the *C++ network
    programming using sockets* section to subscribe to and consume the market data
    from the network.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot and incremental stream synchronizer
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The market data consumer needs to have a subcomponent that can be used to subscribe
    to the snapshot stream in addition to being subscribed to the incremental stream.
    Remember that we explained that when a market participant’s system first starts
    up or needs to restart in the middle of the day or drops a market data packet
    from the incremental stream, it does not have the correct view of the limit order
    book. In such a scenario, the correct recovery/synchronization procedure is to
    clear the limit order book, subscribe to the snapshot stream, and wait till a
    full snapshot of the order book is received. Additionally, the updates that continue
    to come in over the incremental market data stream need to be queued up. Once
    the full snapshot is received and all incremental updates starting from the sequence
    number of the last update in the snapshot are also queued up and available, we
    are done. At this point, the limit order book is reconstructed from the snapshot
    stream, and all queued-up incremental updates are applied to this book to synchronize/catch
    up with the exchange. At this point, the consumer can stop consuming data from
    the snapshot stream and leave the snapshot stream, and only consume data from
    the incremental stream. The component in the market data consumer infrastructure
    responsible for this synchronization mechanism is what we will refer to as the
    snapshot and incremental stream synchronization subcomponent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数据消费者需要有一个子组件，除了订阅增量流外，还可以订阅快照流。记住，我们解释过，当市场参与者的系统首次启动或在白天中需要重启，或者从增量流中丢失市场数据包时，它没有正确的限价订单簿视图。在这种情况下，正确的恢复/同步程序是清除限价订单簿，订阅快照流，并等待收到完整的订单簿快照。此外，继续通过增量市场数据流传入的更新需要排队。一旦收到完整的快照，并且从快照中最后更新的序列号开始的全部增量更新都已排队并可用，我们就算完成了。此时，限价订单簿将从快照流中重建，并将所有排队的增量更新应用到这本书上以同步/赶上交易所。此时，消费者可以停止从快照流中消费数据并离开快照流，只从增量流中消费数据。负责此同步机制的市场数据消费者基础设施中的组件，我们将称之为快照和增量流同步子组件。
- en: Market data protocol decoder
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 市场数据协议解码器
- en: The other subcomponent is responsible for decoding the stream of data coming
    in from the snapshot and/or the incremental market data streams. This component
    translates the data from the exchange feed format to the internal format of the
    trading strategy framework. This is usually a subset of the fields that the exchange
    provides and is often normalized across different trading exchanges to make the
    trading strategy framework independent of exchange-specific details. For our market
    data consumer infrastructure, we will keep this component quite simple since we
    will be using a packed binary structure, but as mentioned before, in practice,
    this can be a much more complicated format such as FAST.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个子组件负责解码来自快照和/或增量市场数据流的传入数据流。该组件将数据从交易所数据源格式转换为交易策略框架的内部格式。这通常是交易所提供的字段的一个子集，并且通常在不同交易交易所之间进行标准化，以使交易策略框架独立于交易所特定的细节。对于我们的市场数据消费者基础设施，我们将保持此组件相当简单，因为我们将会使用打包的二进制结构，但如前所述，在实践中，这可以是一个更复杂的格式，例如FAST。
- en: We discussed the details and design of how a market participant’s system consumes
    the public market data feed from the exchange. We can move on to the order gateway
    client infrastructure, which the participant uses to send order requests and receive
    responses and execution notifications.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了市场参与者系统如何从交易所消费公共市场数据流的细节和设计。我们可以继续讨论订单网关客户端基础设施，参与者使用它来发送订单请求并接收响应和执行通知。
- en: Understanding the order gateway client infrastructure
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解订单网关客户端基础设施
- en: The order gateway client infrastructure in the market participant’s trading
    system is a TCP client that connects to the exchange’s order gateway server. The
    other task that this component performs is receiving updates from the exchange
    on this TCP connection, decoding the messages received from the exchange order
    messaging protocol into a normalized internal format for use by the rest of the
    system. Finally, the order gateway client component is also responsible for taking
    the order actions requested by the trading framework and encoding them in the
    order messaging format that the exchange understands and sending it through to
    the exchange.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember here is that the order gateway client must always
    maintain a reliable TCP connection to the exchange. This is to make sure that
    the exchange does not miss any order request from the client and that the client
    does not miss any updates to its orders from the exchange. In addition to the
    reliability mechanisms implemented by the TCP networking protocol itself, there
    usually exists an application-level reliability mechanism implemented by the exchange
    and the participants. This application-level reliability mechanism usually consists
    of strictly incrementing sequence numbers on the messages sent from exchange to
    client and from client to exchange. Additionally, there can be heart-beating mechanisms
    in place, which are simply messages sent from exchange to client and client to
    exchange to check whether a connection is still active during periods of low activity.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there are mechanisms to authenticate and identify clients when
    they first connect, and this is usually implemented as a handshake mechanism with
    user identification and password, and so on. There can be additional administrative
    messages, such as the logon authentication message, and it depends on the exchange
    and can have a wide range of purposes. For this book’s purposes, we will limit
    the scope to not focus on these administrative messages since they do not matter
    to our low latency goals.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us design our order gateway client infrastructure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Designing the order gateway client infrastructure
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us discuss a few design details for the market data publisher we will implement
    in our market participant’s trading system. We present only the order gateway
    client from *Figure 5**.1* here so we can discuss the design in greater detail.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Design of our order gateway client infrastructure](img/B19434_05_07.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Design of our order gateway client infrastructure
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: There are two simple components that make up the order gateway client inside
    the market participant’s trading system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: TCP connection manager
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order gateway client in a market participant’s trading system oversees connecting
    to the exchange order gateway server and managing that connection. In practice,
    a single participant will have multiple connections to the exchange for load balancing,
    redundancy, and latency reasons. But in the electronic trading ecosystem that
    we will be building, we will design it such that an order gateway client creates
    a single connection to the exchange order gateway server. We will use the TCP
    socket client library we built in the previous chapter under the *C++ network
    programming using* *sockets* section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Order gateway protocol encoder and decoder
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order messaging format encoder and decoder translate order requests from
    the internal format that the trading strategy uses to the exchange format and
    translate order responses and execution notifications from the exchange to an
    internal format for the strategy framework. This component can vary in complexity
    depending on the exchange format, but for our trading system, we will keep the
    encoding and decoding complexity low by using a binary-packed structure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move away from our discussion of the order gateway infrastructure and
    on to the most complex (and most interesting) component of the participant’s system
    – the trading strategy framework.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Designing a framework for low-latency C++ trading algorithms
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed the market data consumer and order gateway client
    components on the market participants’ trading systems, the last component we
    need to discuss is the framework that makes trading decisions. This component
    is one of the most important components in a trading system since this is where
    intelligence lies. By intelligence, we mean the system that processes normalized
    market data updates, builds a view into the market conditions, and computes trading
    analytics to find trading opportunities and execute trades. Obviously, this component
    relies on the market data consumer to receive decoded and normalized market data
    updates and uses the order gateway client component to send order requests to
    and receive order responses from the exchange in a decoded and normalized format.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Building the order book
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The market participant needs to construct the limit order book based on the
    market data that the exchange publishes. Note that it is not strictly necessary
    that the client must build the entire order book, especially if the trading strategies
    do not require information that is that granular. For this book’s purposes, we
    will build a full order book in our trading framework, but we just wanted to point
    out that it is not strictly necessary in all cases. A simple example of such a
    case would be strategies that only care about knowing the prices and/or quantity
    of the most aggressively priced orders – that is, the highest bid price and lowest
    offer price (known as **Top Of Book** (**TOB**) or **Best Bid and Offer** (**BBO**)).
    Another example would be strategies that only rely on trade prices to make decisions
    and do not require a view into the full order book.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者需要根据交易所发布的市场数据构建限价订单簿。请注意，客户构建整个订单簿并不是严格必要的，特别是如果交易策略不需要那么细粒度的信息。为了本书的目的，我们将在我们的交易框架中构建完整的订单簿，但我们只是想指出，在所有情况下这并不是严格必要的。这样一个简单的例子就是只关心了解最积极定价订单的价格和/或数量的策略——即最高出价价格和最低要价价格（称为**订单簿顶部**（**TOB**）或**最佳出价和要价**（**BBO**））。另一个例子是只依赖交易价格做出决策且不需要查看完整订单簿的策略。
- en: One thing to reiterate here is that the order book that the client builds is
    slightly different from the one that the exchange maintains because the client
    does not usually know which order belongs to which market participant. Additionally,
    depending on the exchange, a few more pieces of information might be hidden from
    the market participants, such as which orders are icebergs, which new orders are
    stop orders, self-match-prevention considerations, and so on. **Iceberg orders**
    are orders that have a larger hidden quantity than what is displayed in the public
    market data. **Stop orders** are orders that lie dormant and then become active
    when a specific price trades. **Self-match prevention** (**SMP**) is a constraint
    that prevents a client from trading against themselves, which some exchanges choose
    to enforce in the matching engine. For the purposes of this book, we will ignore
    and not implement such special functionality. Another thing to understand is that
    the book that the trading participants have is a slightly delayed version of the
    order book that the matching engine has. This is because there is some latency
    between the matching engine updating its order book to the trading client getting
    the market updates corresponding to the changes and updating their book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要重申的一点是，客户构建的订单簿与交易所维护的订单簿略有不同，因为客户通常不知道哪个订单属于哪个市场参与者。此外，根据交易所的不同，可能还有更多信息对市场参与者隐藏，例如哪些订单是冰山订单，哪些新订单是停止订单，自我匹配预防考虑等因素。**冰山订单**是指隐藏数量大于公开市场数据中显示数量的订单。**停止订单**是指处于休眠状态的订单，当达到特定价格时才会变为活跃状态。**自我匹配预防**（**SMP**）是一种约束，防止客户与自己交易，一些交易所选择在撮合引擎中实施此约束。在本书的范围内，我们将忽略并实现此类特殊功能。另一件需要理解的事情是，交易参与者拥有的订单簿是撮合引擎订单簿的一个略微延迟版本。这是因为撮合引擎更新其订单簿到交易客户端获取与变化相对应的市场更新之间存在一些延迟。
- en: Building a feature engine
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建功能引擎
- en: Sophisticated trading strategies need to build additional intelligence over
    just the order book. These trading strategies need to implement various trading
    signals and intelligence on top of the prices, liquidity, trade transactions,
    and order book published by the exchange. The idea here is to build intelligence,
    which can be a combination of technical analysis style indicators, statistical
    predictive signals and models, and market microstructure-related statistical edges.
    A detailed discussion of various kinds of trading signals and predictive analysis
    is outside the scope of this book, but there are plenty of texts dedicated to
    this topic. There are many different terms used in practice for such predictive
    edges – trading signals, indicators, features, and so on. The component inside
    the trading system that constructs and wires together a collection of such predictive
    signals is often referred to as a feature/signal/indicator engine. In this book,
    we will build a minimal feature engine for our trading strategies, but we reiterate
    here that feature engines can get quite sophisticated and complicated depending
    on the strategy’s complexity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Developing the execution logic
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After building the order book and deriving some trading signals from the current
    state of the market, if the trading strategies find an opportunity, they still
    need to execute their orders at the exchange. This is achieved by sending new
    orders, modifying existing orders to either move them to a more aggressive or
    less aggressive price, and/or canceling existing orders to avoid getting filled
    on them. The subcomponent in the trading infrastructure responsible for sending,
    modifying, and canceling orders – basically, managing a strategy’s orders at the
    exchange – is called the execution system. For the execution systems, the ability
    to react quickly to market data and order responses coming from the exchange and
    send out order requests as quickly as possible is extremely important. A large
    part of a high-frequency trading system’s profitability and sustainability depends
    on achieving the lowest possible latencies in the execution systems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the risk management systems
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The risk management system is an important piece of the trading strategy infrastructure.
    Technically speaking, in practice, there are multiple layers of risk management
    systems in a modern electronic trading ecosystem. In practice, there are risk
    management systems in the client’s trading strategy framework, order gateway clients
    in the market participant’s system, and backend systems at the clearing broker’s
    end. For this book’s purposes, we will only implement a minimal risk management
    system in the trading strategy framework. Risk management systems try to manage
    the different forms of risk, as depicted in the following diagram:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Different risk metrics in an automated risk management system](img/B19434_05_08.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Different risk metrics in an automated risk management system
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Let us discuss these risk measures in more detail next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Risk based on order quantities
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One measure that a lot of trading systems care about is the maximum possible
    quantity that the algorithm is allowed to send for a single order. This is mostly
    to prevent bugs and user errors in the system where the algorithm ends up accidentally
    sending an order much larger than expected. These types of errors in practice
    are referred to as **Fat Finger** errors, to refer to what would happen if a user
    accidentally pressed more keys than intended.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Risk based on firm positions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An obvious measure of risk is the position that a strategy has in a certain
    trading instrument. The size of the position directly dictates how much money
    is lost if the market prices change a certain amount. This is why the realized
    position that a strategy or a firm has in a certain trading instrument is an extremely
    important one and is closely monitored to make sure it falls within agreed-upon
    limits. Note that realized position is the position that the strategy currently
    holds, and this ignores additional orders that the strategy might have, which
    might increase or decrease the position on execution.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Risk based on worst-case position
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in the last section, we mentioned that realized position metrics ignore
    how many additional live orders exist in the market. The worst-case scenario position
    metric tracks what the position would be considering the live orders on the side
    that would increase the realized position along with the actual realized position.
    This means if the strategy or firm is long (position from buying an instrument),
    then it will also check how much additional unexecuted buy quantity the strategy
    has in the market to compute the absolute worst-case position. This is important
    because some strategies might never build up to large positions but might always
    have a lot of active orders in the market. The perfect example of such a strategy
    is a market-making strategy, which we will see later in this book, but the point
    here is that it is important to think about worst-case scenarios when it comes
    to risk management.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Risk to manage realized and unrealized loss
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is what most people think of when they think of risk in the context of
    electronic trading. This risk metric tracks and imposes limits on how much money
    a strategy or firm has lost. If that value crosses a certain threshold, then depending
    on how much the firm has in its brokerage account, how much collateral they have,
    and so on, there can be consequences for the firm. Not only is it important to
    track the realized losses for a strategy when the strategy opens and closes positions
    but it is also important to track the open positions against the market prices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, let us explain the following scenario: a strategy buys
    a certain quantity of an instrument and then sells the same amount of quantity
    back at a lower price where the strategy has a realized loss and no open position.
    Now, let us say the strategy buys some amount of the trading instrument, and then
    after the purchase where the strategy has a long position, the price of the instrument
    in the market moves lower. Here, this strategy not only has the realized loss
    it is carrying from the previous set of trades but now it also has an unrealized
    loss on this most recently opened long position. The risk management system needs
    to compute realized and unrealized losses in near real time to get an accurate
    view of the actual risk.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Risk based on traded volumes
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This measure is not necessarily a risk; a strategy that trades a lot of volume
    on a certain day or in general is not a problem in itself. This risk metric seeks
    mostly to prevent runaway algorithms from overtrading in the market in cases of
    software or configuration bugs or just unexpected market conditions. This can
    be implemented in many ways, but the simplest implementation would be to have
    a cap on how much volume a strategy is allowed to trade for a trading instrument
    before it automatically stops sending any new orders or trading further. Usually,
    at this point, an external human operator needs to make sure that the algorithm
    behavior is as expected and then resume the trading strategy or stop it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Risk to manage rate of orders, trades, and losses
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The risk metrics we will discuss in this subsection fall into the **rate-based**
    risk management category. What we mean by rate-based is that the risk is computed
    for sliding windows of time to make sure that the strategy does not send too many
    orders in each window, does not trade too much in each time window, does not lose
    too much money in each window, and so on. Again, these metrics are to prevent
    trading strategy behavior that is unexpected or resembles an out-of-control or
    runaway algorithm. These are implemented by either resetting the counters for
    the underlying metric (number of orders or number of trades or traded volume or
    loss) at the end of the time-period window or using a rolling counter of these
    metrics. These risk metrics also implicitly prevent the trading strategy from
    behaving unexpectedly during periods of super-heightened volatility or flash crash-style
    scenarios.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will design the last major component in our electronic trading ecosystem.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Designing our trading strategy framework
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us discuss a few design details for the trading strategy framework we will
    implement in our participant’s trading system. We present only the trading strategy
    framework from *Figure 5**.1* here so we can discuss the design in greater detail.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Design of our trading strategy framework](img/B19434_05_09.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Design of our trading strategy framework
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now we will discuss the design of the major subcomponents in the trading strategy
    framework we will build in this book. Note that we use the terms **trading strategy
    framework** and **trading engine** interchangeably and they mean the same thing
    in the context of this book – a collection of components to house and run automated
    trading algorithms.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Limit order book
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The limit order book in the trading strategy framework is similar to the one
    that the exchange matching engine builds. Obviously, the goal here is not to perform
    matching between orders but instead to build, maintain, and update the limit order
    book from the market data updates consumed by the market data consumer via the
    lock-free queue. The requirement to support efficient insertion, modification,
    and deletion of orders into this book still applies here. The other goal here
    is to also make this order book accessible for use cases that the feature engine
    and trading strategy components require. There can be various use cases; one example
    is being able to synthesize a BBO or TOB quickly and efficiently for components
    that only need the best prices and quantities. Another example would be the ability
    to track the strategy’s own orders in the limit order book to find where they
    are in the FIFO queue at a price level. Yet another example would be the ability
    to detect executions on a strategy’s orders from the public market data feed,
    which can be a big boost during times when the private order feed is lagging behind
    the public market data feed. Implementing these details in the trading strategies
    we build in this book is out of the scope of what we can cover. But in practice,
    these details are extremely important since the advantage one gains from detecting
    executions from both the order responses and market data can be tens, hundreds,
    or even thousands of microseconds in latency. Here, we will use the lock-free
    queue that we built in the *Transferring data using lock-free queues* section
    and the memory pool we built in the *Designing C++ memory pools to avoid dynamic
    memory allocations* section in the previous chapter, *Building the C++ Building
    Blocks for* *Low-Latency Applications*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Feature engine
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned before that we will be building a minimal feature engine in this
    book. Our feature engine will only support a single feature computed from the
    data available from our order book, and this single feature will be used to drive
    our trading strategies. This feature will be updated when there are substantial
    changes to the order book in terms of price or liquidity and as trades occur in
    the market. When the feature is updated, the trading strategy can use the new
    feature value to re-evaluate its position, live orders, and so on to make a trading
    decision.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Trading strategy
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trading strategy is the component that finally makes the trading decisions
    based on a multitude of factors. The trading decisions depend on the trading algorithm
    itself, the feature values from the feature engine, the state of the order book,
    the prices and FIFO position of the strategy’s orders in the order book, risk
    evaluations from the risk manager, the state of the live orders from the order
    manager, and so on. This is where most of the complexity of the trading strategy
    framework resides because it needs to handle a lot of different conditions and
    execute the orders safely and profitably. In this book, we will build two distinct
    kinds of basic trading algorithms – **market-making**, also known as **liquidity-providing
    strategies**, and **taking strategies**, also known as **liquidity-removing strategies**.
    Market-making strategies have passive orders in the book and rely on other market
    participants crossing the spread to trade against us. Liquidity-taking strategies
    are the strategies that cross the spread and send aggressive orders to take out
    passive liquidity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Order manager
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order manager component is an abstraction that hides the lower-level details
    of sending order requests, managing the states of active orders, handling **in-flight
    conditions** (we will explain this shortly) for these orders, handling responses
    from the exchange, handling scenarios around partial and full executions of orders,
    and managing positions. The order manager also builds and maintains a couple of
    different data structures to track the state of the strategy’s orders. In some
    sense, the order manager is like the limit order book, except it manages a tiny
    subset of the orders that belong to the strategy.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there is some additional complexity in the order management
    since there are some cases where order requests are in-flight from the market
    participant to the exchange and some events happen in the exchange matching engine
    at the same time. An example of an in-flight condition would be the scenario where
    the client tries to cancel an active order and sends a cancel request to the exchange.
    But while this cancel request is in-flight to the exchange, the matching engine
    at the exchange executes the order because an aggressor that would match this
    order shows up. Then, by the time the cancel request finally reaches the matching
    engine, the order is already executed and removed from the limit order book at
    the exchange, resulting in a cancel reject for this request. The order manager
    needs to be able to handle all different scenarios like this one accurately and
    efficiently.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will build an order manager that can be used to manage passive
    and aggressive orders and can handle all these different conditions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Risk manager
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The risk manager tracks the different risk metrics we described in the previous
    section, *Understanding the risk management systems*. Additionally, the risk manager
    needs to notify the trading strategy about events where risk limits are breached
    so that the trading strategy can reduce risk and/or shut down safely. In our trading
    infrastructure, we will implement a few basic risk metrics, such as position,
    total loss, and messaging rates for order requests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 风险经理跟踪我们在上一节“理解风险管理系统”中描述的不同风险指标。此外，风险经理还需要通知交易策略关于风险限制被突破的事件，以便交易策略可以降低风险或安全地关闭。在我们的交易基础设施中，我们将实施一些基本的风险指标，例如头寸、总损失和订单请求的消息速率。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes our discussion of the details and design of the major components
    in our electronic trading ecosystem. Let us summarize the concepts, components,
    and interactions we discussed, as well as the design of the components that build
    the electronic trading ecosystem we will build.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对电子交易生态系统主要组件的细节和设计的讨论。让我们总结一下我们讨论的概念、组件和交互，以及构建我们将要构建的电子交易生态系统的组件设计。
- en: We started off by presenting the topology of the electronic trading ecosystem.
    This consists of the electronic trading exchange and many market participants
    that want to trade on that exchange. The electronic trading exchange infrastructure
    itself consists of three major components at a high level – the matching engine,
    the market data publisher, and the order gateway server infrastructure. From a
    market participant’s perspective, the major components are the market data subscriber
    and consumer, the trading strategy framework with all its subcomponents, and the
    order gateway client infrastructure.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了电子交易生态系统的拓扑结构。这包括电子交易交易所和许多想要在该交易所进行交易的市场参与者。从高层次来看，电子交易交易所基础设施本身由三个主要组件组成——匹配引擎、市场数据发布者和订单网关服务器基础设施。从市场参与者的角度来看，主要组件包括市场数据订阅者和消费者、包含所有子组件的交易策略框架以及订单网关客户端基础设施。
- en: Next, we performed a deep dive into the exchange matching engine details. We
    explained the responsibilities of this component and how it builds, maintains,
    and updates the limit order book and matches participant orders that cross against
    each other. We concluded that section by designing our simplified matching engine
    component and its subcomponents, which we will implement in the next chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了交易所匹配引擎的细节。我们解释了该组件的职责以及它是如何构建、维护和更新限价订单簿并匹配相互交叉的参与者订单的。我们在那一节结束时设计了我们的简化匹配引擎组件及其子组件，这些将在下一章中实现。
- en: The next topics of discussion were the market data publisher and the order gateway
    server infrastructure at the exchange. We described in great detail the different
    messages that the market data feed is composed of, the market data feed protocol,
    as well as designing the components inside the market data publisher. We also
    discussed the order gateway server, which the exchange hosts as an endpoint for
    the market participants to connect to, forward order requests, and receive order
    responses and notifications for their orders getting executed by the matching
    engine. We presented the design of the order gateway server with all its subcomponents,
    which we will implement in later chapters of this book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的讨论主题是交易所的市场数据发布者和订单网关服务器基础设施。我们详细描述了市场数据馈送由哪些不同消息组成，市场数据馈送协议，以及设计市场数据发布者内部的组件。我们还讨论了订单网关服务器，这是交易所作为市场参与者连接到、转发订单请求并接收订单响应和通知的端点。我们展示了包含所有子组件的订单网关服务器的设计，这些将在本书的后续章节中实现。
- en: The section following that took a look at the market participants’ trading systems.
    First, we discussed the details for the market data consumer and the order gateway
    client infrastructure, which the participants use to consume the public market
    data feed from the exchange and connect to and communicate with the exchange.
    We also presented and discussed the design of the market data consumer we will
    build, as well as how it synchronizes and decodes the exchange market data feed.
    Finally, we designed the order gateway client infrastructure, which the trading
    system will use to connect to and communicate with the exchange’s order gateway
    server infrastructure.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后的部分，我们考察了市场参与者的交易系统。首先，我们讨论了市场数据消费者和订单网关客户端基础设施的细节，这些是参与者用来从交易所消费公共市场数据流并连接到以及与交易所通信的基础设施。我们还介绍了我们将要构建的市场数据消费者的设计，以及它是如何同步和解码交易所市场数据流的。最后，我们设计了订单网关客户端基础设施，这是交易系统将要用来连接到以及与交易所的订单网关服务器基础设施通信的。
- en: The final section of this chapter was dedicated to describing and designing
    the framework for trading strategies. We described the major components we will
    need to build this framework – the order book, the feature engine, the execution
    logic framework, and the risk management subcomponent. Finally, we laid out the
    design of the trading infrastructure we will build so that you can understand
    the higher-level design of this component before we dive into the lower-level
    details in subsequent chapters.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分致力于描述和设计交易策略框架。我们描述了我们将需要构建此框架的主要组件——订单簿、功能引擎、执行逻辑框架以及风险管理子组件。最后，我们概述了我们将要构建的交易基础设施的设计，以便您在我们深入到后续章节中的底层细节之前，可以理解此组件的高级设计。
- en: The next chapter jumps into the implementation details of the matching engine
    framework we designed in this chapter. Note that we will reuse a lot of the basic
    building blocks we built in the previous chapter moving forward as we implement
    our electronic trading ecosystem. The motivation for building the basic building
    blocks will become clearer as we implement the rest of the system, starting in
    the next chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将跳入我们本章设计的匹配引擎框架的实现细节。请注意，在实现我们的电子交易生态系统时，我们将重用我们在上一章中构建的大量基本构建块。随着我们开始实现系统的其余部分，构建基本构建块的动力将变得更加清晰。
