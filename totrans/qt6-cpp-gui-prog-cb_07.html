<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor158"/>7</h1>
<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Using Network and Managing Large Documents</h1>
<p>In this chapter, we will learn how to create a networking server program and a client program using Qt 6’s networking module. We will also learn how to create a program that uses <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>) to upload and download files from the server. Lastly, we will learn how to send HTTP requests to a specific web service using Qt 6 and C++ language.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Creating a TCP server</li>
<li>Creating a TCP client</li>
<li>Uploading and downloading files using FTP</li>
</ul>
<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/>Technical requirements</h1>
<p>The technical requirements for this chapter are Qt 6.6.1, Qt Creator 12.0.2, and FileZilla. All the code used in this chapter can be downloaded from the following GitHub repository: <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07</a>.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor161"/>Creating a TCP server</h1>
<p>In this recipe, we<a id="_idIndexMarker462"/> will learn how to create a <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) server in Qt 6. Before we’re able to <a id="_idIndexMarker463"/>create a server that lets us upload and download files, let’s scale it down a bit and learn how to create a networking server that receives and delivers texts.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor162"/>How to do it…</h2>
<p>Follow these steps to create a TCP server:</p>
<ol>
<li>First, let’s create a <strong class="bold">Qt Console Application</strong> project from <strong class="bold">File</strong> | <strong class="bold">New File or Project</strong>, as shown in the<a id="_idIndexMarker464"/> following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.1 – Creating a new Qt Console Application project" src="img/B20976_07_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Creating a new Qt Console Application project</p>
<ol>
<li value="2">After that, go to <strong class="bold">File</strong> | <strong class="bold">New File or Project</strong> again but this time, select <strong class="bold">C++ Class</strong> under the <strong class="bold">C/C++</strong> category, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.2 – Creating a new C++ class" src="img/B20976_07_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Creating a new C++ class</p>
<ol>
<li value="3">Then, name your class <code>server</code>. Set its base class to <code>server.h</code> and <code>server.cpp</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.3 – Defining the server class" src="img/B20976_07_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Defining the server class</p>
<ol>
<li value="4">After that, open up your project file (<code>.pro</code>) and add the <code>network</code> module, as shown in the<a id="_idIndexMarker466"/> following code. Then, run <code>qmake</code> again to reload the modules:<pre class="source-code">
QT += core <code>server.h</code> and add the following headers to it:<pre class="source-code">
#include &lt;QTcpServer&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QVector&gt;
#include &lt;QDebug&gt;</pre></li> <li>Right after that, declare the <code>startServer()</code> and <code>sendMessageToClients()</code> functions, as shown in the following code:<pre class="source-code">
public:
      server(QObject *parent = nullptr);
      <strong class="bold">void startServer();</strong>
<code>server</code> class:<pre class="source-code">
public slots:
     void newClientConnection();
     void socketDisconnected();
     void socketReadReady();
     void socketStateChanged(QAbstractSocket::SocketState state);</pre></li> <li>Finally, declare two private variables, as shown in the following code:<pre class="source-code">
private:
     QTcpServer* chatServer;
     QVector&lt;QTcpSocket*&gt;* allClients;</pre></li> <li>Once you’re done with the preceding step, open up <code>server.cpp</code> and define the <code>startServer()</code> function. Here, we create a <code>QVector</code> container to store all the clients that are connected to the server and use it to send out messages in later steps. This is shown in the following example:<pre class="source-code">
void server::startServer() {
     allClients = new QVector&lt;QTcpSocket*&gt;;
     chatServer = new QTcpServer();
     chatServer-&gt;setMaxPendingConnections(10);
     connect(chatServer, &amp;QTcpServer::newConnection,      this, &amp;server::newClientConnection);
if (chatServer-&gt;listen(QHostAddress::Any, 8001))
     qDebug() &lt;&lt; "Server has started. Listening to port     8001.";
else
     qDebug() &lt;&lt; "Server failed to start. Error: " +   chatServer-&gt;errorString();
}</pre></li> <li>Next, we implement<a id="_idIndexMarker468"/> the <code>sendMessageToClients()</code> function, where we iterate through the <code>allClients</code> container we just created in the previous step, and send the message to each client, as shown in the following example:<pre class="source-code">
void server::sendMessageToClients(QString message) {
if (allClients-&gt;size() &gt; 0) {
     for (int i = 0; i &lt; allClients-&gt;size(); i++) {
     if (allClients-&gt;at(i)-&gt;isOpen() &amp;&amp; allClients-   &gt;at(i)-&gt;isWritable()) {
     allClients-&gt;at(i)-&gt;write(message.toUtf8());
}
}}}</pre></li> <li>After that, we will start implementing the slot functions. Let’s start with the following code:<pre class="source-code">
void server::newClientConnection() {
     QTcpSocket* client = chatServer-&gt;nextPendingConnection();
     QString ipAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     connect(client, &amp;QTcpSocket::disconnected, this, &amp;server::socketDisconnected);
     connect(client, &amp;QTcpSocket::readyRead,this, &amp;server::socketReadReady);
     connect(client, &amp;QTcpSocket::stateChanged, this, &amp;server::socketStateChanged);
     allClients-&gt;push_back(client);
     qDebug() &lt;&lt; "Socket connected from " + ipAddress + ":" + QString::number(port);
}</pre></li> <li>Then, we’ll <a id="_idIndexMarker469"/>proceed with the <code>socketDisconnected()</code> function. This slot function will be called when a client has been disconnected from the server, as shown in the following example:<pre class="source-code">
void server::socketDisconnected() {
     QTcpSocket* client = qobject_cast&lt;QTcpSocket*&gt;(QObject::sender());
     QString socketIpAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     qDebug() &lt;&lt; "Socket disconnected from " + socketIpAddress + ":" + QString::number(port);
}</pre></li> <li>Next, we’ll define the <code>socketReadReady()</code> function, which will be triggered when a client sends a text message to the server, as shown in the following example:<pre class="source-code">
void server::socketReadReady() {
     QTcpSocket* client = qobject_cast&lt;QTcpSocket*&gt;(QObject::sender());
     QString socketIpAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     QString data = QString(client-&gt;readAll());
     qDebug() &lt;&lt; "Message: " + data + " (" + socketIpAddress + ":" + QString::number(port) + ")";
     sendMessageToClients(data);
}</pre></li> <li>After that, let’s<a id="_idIndexMarker470"/> implement the <code>socketStateChanged()</code> function, which will be called when the networking state of a client has changed, as shown in the following example:<pre class="source-code">
void server::socketStateChanged(QAbstractSocket::SocketState state) {
     QTcpSocket* client = qobject_cast&lt;QTcpSocket*&gt;(QObject::sender());
     QString socketIpAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     qDebug() &lt;&lt; "Socket state changed (" + socketIpAddress + ":" + QString::number(port) + "): " + desc;
}</pre></li> <li>We also need to add the following code into <code>socketStateChanged()</code> to print out the status of the client:<pre class="source-code">
     QString desc;
     if (state == QAbstractSocket::UnconnectedState)
           desc = "The socket is not connected.";
     else if (state == QAbstractSocket::HostLookupState)
           desc = "The socket is performing a host name lookup.";
     else if (state == QAbstractSocket::ConnectingState)
           desc = "The socket has started establishing a connection.";
     else if (state == QAbstractSocket::ConnectedState)
           desc = "A connection is established.";
     else if (state == QAbstractSocket::BoundState)
           desc = "The socket is bound to an address and port.";
     else if (state == QAbstractSocket::ClosingState)
           desc = "The socket is about to close (data may still be waiting to be written).";
     else if (state == QAbstractSocket::ListeningState)
           desc = "For internal use only.";</pre></li> <li>Lastly, let’s open up <code>main.cpp</code> and add the highlighted code in the following example in order to <a id="_idIndexMarker471"/>initiate the server:<pre class="source-code">
#include &lt;QCoreApplication&gt;
#include "server.h"
     int main(int argc, char *argv[]) {
     QCoreApplication a(argc, argv);
     <strong class="bold">server* myServer = new server();</strong>
     <strong class="bold">myServer-&gt;startServer();</strong>
     return a.exec();
}</pre></li> <li>You can try and run the server program now but you won’t be able to test it as we have not created the client program yet, as the following screenshot shows:</li>
</ol>
<div><div><img alt="Figure 7.4 – Server is now listening to port 8001" src="img/B20976_07_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Server is now listening to port 8001</p>
<ol>
<li value="18">Let’s proceed to the next example project and learn how to create the client program. We will <a id="_idIndexMarker472"/>come back to test this program again later on.</li>
</ol>
<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>How it works…</h2>
<p>There are mainly two types of network connections—the TCP connection and the <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) connection. TCP is <a id="_idIndexMarker473"/>a reliable networking connection, while UDP is unreliable.</p>
<p>These two connections are designed for very different purposes:</p>
<ul>
<li>TCP networking is usually for programs that require every single piece of data to be sent and received in order. It also makes sure that the client receives the data and that the server gets notified of that. Programs such as messaging software, web servers, and databases use TCP networking.</li>
<li>UDP networking, on the other hand, does not require constant handholding between the server and client. Since the connection is unreliable, there is also no feedback on whether the data has been successfully received. The dropping of packets is tolerated, and data may not even come in the same order as it was sent. UDP connections are usually used by applications that stream huge amounts of data to their clients without strict requirements on its packet delivery, such as video games, video conferencing software, and domain name systems.</li>
</ul>
<p>Creating networking software using Qt 6 is a lot easier through its signals and slots mechanism. All we need to do is connect the signals emitted by the <code>QTcpServer</code> class and <code>QTcpSocket</code> class to our slot functions. We will then implement these slot functions and define what to do within those functions.</p>
<p class="callout-heading">Note</p>
<p class="callout">We used a <code>QVector</code> container to store the pointers to all the clients that have connected to the server so that we can use it to deliver the messages later on.</p>
<p>To keep this example<a id="_idIndexMarker474"/> project simple, we simply send text messages to all the clients, sort of like a group chat. You are free to explore other possibilities and make your own changes to improve the program.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor164"/>Creating a TCP client</h1>
<p>Since we created a TCP server in the previous recipe, we now need a client program to complete the project. Therefore, in this <a id="_idIndexMarker475"/>recipe, we will learn how to create a TCP client program using Qt 6 and its network module.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor165"/>How to do it…</h2>
<p>To create a TCP client in Qt 6, let’s do the following:</p>
<ol>
<li>First off, let’s create a new <strong class="bold">Qt Widgets Application</strong> project from <strong class="bold">Files</strong> | <strong class="bold">New File </strong><strong class="bold">or Project</strong>.</li>
<li>Once the project has been created, let’s open up <code>mainwindow.ui</code> and set up the GUI as shown in the following diagram. Please note that the layout direction of the central widget has to be vertical:</li>
</ol>
<div><div><img alt="Figure 7.5 – The layout of our client program" src="img/B20976_07_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The layout of our client program</p>
<ol>
<li value="3">Then, right-click on the push button that says <code>clicked()</code> slot function <a id="_idIndexMarker476"/>from the menu. Then, repeat the same step on the <strong class="bold">Send</strong> button as well. As a result, two slot functions will be created for you in the source code, which may or may not look like what we see in the following code, depending on your widget’s name:<pre class="source-code">
void on_connectButton_clicked();
void on_sendButton_clicked();</pre></li> <li>Next, open up <code>mainwindow.h</code> and add the following headers:<pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QTcpSocket&gt;</pre></li> <li>Then, declare the <code>printMessage()</code> function and three slot functions: <code>socketConnected()</code>, <code>socketDisconnected()</code>, and <code>socketReadyRead()</code>, as shown in the following code:<pre class="source-code">
public:
     explicit MainWindow(QWidget *parent = 0);
     ~MainWindow();
     <strong class="bold">void printMessage(QString message);</strong>
private slots:
     void on_connectButton_clicked();
     void on_sendButton_clicked();
     <strong class="bold">void socketConnected();</strong>
     <strong class="bold">void socketDisconnected();</strong>
     <strong class="bold">void socketReadyRead();</strong></pre></li> <li>After that, declare the following<a id="_idIndexMarker477"/> variables as well:<pre class="source-code">
private:
     Ui::MainWindow *ui;
     <strong class="bold">bool connectedToHost;</strong>
     <code>mainwindow.cpp</code> and define the <code>printMessage()</code> function, as shown in the following example:<pre class="source-code">
void MainWindow::printMessage(QString message) {
     ui-&gt;chatDisplay-&gt;append(message);
}</pre></li> <li>Then, we’ll implement the <code>on_connectButton_clicked()</code> function, which will be triggered when the <strong class="bold">Connect</strong> button is clicked, as shown in the following code:<pre class="source-code">
void MainWindow::on_connectButton_clicked() {
     if (!connectedToHost) {
           socket = new QTcpSocket();
           connect(socket, &amp;QTcpSocket::connected, this, &amp;MainWindow::socketConnected);
           connect(socket, &amp;QTcpSocket::disconnected, this, &amp;MainWindow::socketDisconnected);
           connect(socket, &amp;QTcpSocket::readyRead, this, &amp;MainWindow::socketReadyRead);
           socket-&gt;connectToHost("127.0.0.1", 8001);
     }
     else {
           QString name = ui-&gt;nameInput-&gt;text();
           socket-&gt;write("&lt;font color=\"Orange\"&gt;" + name.toUtf8() + " has left the chat room.&lt;/font&gt;");
           socket-&gt;disconnectFromHost();
     }
}</pre></li> <li>We also define the <code>on_sendButton_clicked()</code> function, which will be called when the <strong class="bold">Send</strong> button is <a id="_idIndexMarker478"/>clicked, as shown in the following example:<pre class="source-code">
void MainWindow::on_sendButton_clicked() {
     QString name = ui-&gt;nameInput-&gt;text();
     QString message = ui-&gt;messageInput-&gt;text();
     socket-&gt;write("&lt;font color=\"Blue\"&gt;" + name.toUtf8() + "&lt;/font&gt;: " + message.toUtf8());
     ui-&gt;messageInput-&gt;clear();
}</pre></li> <li>Right after that, we implement the <code>socketConnected()</code> function, which will be called when the client program has been successfully connected to the server, as shown in the following code:<pre class="source-code">
void MainWindow::socketConnected() {
     qDebug() &lt;&lt; "Connected to server.";
     printMessage("&lt;font color=\"Green\"&gt;Connected to server.&lt;/font&gt;");
     QString name = ui-&gt;nameInput-&gt;text();
     socket-&gt;write("&lt;font color=\"Purple\"&gt;" + name.toUtf8() + " has joined the chat room.&lt;/font&gt;");
     ui-&gt;connectButton-&gt;setText("Disconnect");
     connectedToHost = true;
}</pre></li> <li>We are not yet done at this point. We also need to implement the <code>socketDisconnected()</code> function, which will be triggered whenever the client has been disconnected from<a id="_idIndexMarker479"/> the server, as shown in the following code:<pre class="source-code">
void MainWindow::socketDisconnected() {
     qDebug() &lt;&lt; "Disconnected from server.";
     printMessage("&lt;font color=\"Red\"&gt;Disconnected from server.&lt;/font&gt;");
     ui-&gt;connectButton-&gt;setText("Connect");
     connectedToHost = false;
}</pre></li> <li>Lastly, we also need to define the <code>socketReadyRead()</code> function, which prints out the message sent from the server, as shown in the following example:<pre class="source-code">
void MainWindow::socketReadyRead() {
     printMessage(socket-&gt;readAll());
}</pre></li> <li>Before we run the client program, we must first turn on the server program that we created in the previous recipe. Then, build and run the client program. Once the program has been opened, go and click the <strong class="bold">Connect</strong> button. After you have successfully connected to the server, type something in the line edit widget located at the bottom and press the <strong class="bold">Send</strong> button. You should see something similar to the <a id="_idIndexMarker480"/>following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.6 – Our chat program is now working" src="img/B20976_07_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Our chat program is now working</p>
<ol>
<li value="14">Let’s go to the server program, shown in the following screenshot, and see whether there is anything printed on the terminal window:</li>
</ol>
<div><div><img alt="Figure 7.7 – Client activities are also shown on the server output" src="img/B20976_07_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Client activities are also shown on the server output</p>
<ol>
<li value="15">Congratulations, you have successfully<a id="_idIndexMarker481"/> created a program that looks a bit<a id="_idIndexMarker482"/> like an <strong class="bold">Internet Relay Chat</strong> (<strong class="bold">IRC</strong>) chat room!</li>
</ol>
<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>How it works…</h2>
<p>In order for this to work, we need two programs: a server program that connects all the clients and delivers their messages, and a client program used by the users to send and receive messages from other users.</p>
<p>Since the server program just sits behind the scenes and works out everything in silence, it doesn’t need any user interface, and thus we only need it as a Qt Console application.</p>
<p>The client program, however, requires a visually pleasant yet easy-to-use GUI for the users to read and write their messages. Therefore, we created the client program as a Qt Widgets application instead.</p>
<p>The client program is relatively simple when compared to the server program. All it does is connect to the server, send out the message input by the user, and print out everything the server sends to it.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor167"/>Uploading and downloading files using FTP</h1>
<p>We have learned how to create simple<a id="_idIndexMarker483"/> chat software <a id="_idIndexMarker484"/>that distributes text messages among the users. Next, we will learn how to create a program that uploads and downloads files using FTP.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>How to do it…</h2>
<p>Let’s get started by observing the following steps:</p>
<ol>
<li>For this project, we need to<a id="_idIndexMarker485"/> install software called <strong class="bold">FileZilla Server</strong>, which we will use as the FTP server. FileZilla Server<a id="_idIndexMarker486"/> can be downloaded from <a href="https://filezilla-project.org">https://filezilla-project.org</a> by clicking on the <strong class="bold">Download FileZilla Server</strong> button, as shown in the following<a id="_idIndexMarker487"/> screenshot:</li>
</ol>
<div><div><img alt="Figure 7.8 – Downloading FileZilla Server from the official website" src="img/B20976_07_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Downloading FileZilla Server from the official website</p>
<ol>
<li value="2">Once you have downloaded the installer, run it and install <strong class="bold">FileZilla Server</strong> by agreeing to all the default options, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.9 – Default installation options will do" src="img/B20976_07_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Default installation options will do</p>
<ol>
<li value="3">When it has<a id="_idIndexMarker488"/> completed, open <a id="_idIndexMarker489"/>up <strong class="bold">FileZilla Server</strong> and press the <strong class="bold">Connect to Server…</strong> button, and the <strong class="bold">Connection</strong> window will pop up, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.10 – Setting the host, port, and password in the Connection window" src="img/B20976_07_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Setting the host, port, and password in the Connection window</p>
<ol>
<li value="4">After the server has been <a id="_idIndexMarker490"/>started, go to <strong class="bold">Server</strong> | <strong class="bold">Configure…</strong> from the top menu, as highlighted <a id="_idIndexMarker491"/>in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.11 – Opening up the Settings window from the top menu" src="img/B20976_07_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Opening up the Settings window from the top menu</p>
<ol>
<li value="5">Once the <strong class="bold">Settings</strong> window has been opened, click on the <strong class="bold">Add</strong> button located under the <strong class="bold">Available users</strong> list to add a new user. Then, add a shared folder under the <strong class="bold">Shared</strong> folders list, where your <a id="_idIndexMarker492"/>users will be uploading and downloading files to and from, as <a id="_idIndexMarker493"/>shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.12 – Clicking the Add button to add a new user" src="img/B20976_07_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Clicking the Add button to add a new user</p>
<ol>
<li value="6">We have now finished setting up FileZilla Server. Let’s move on to Qt Creator and create a new <code>mainwindow.ui</code> and set up the GUI, as shown in the following diagram:</li>
</ol>
<div><div><img alt="Figure 7.13 – Layout of our FPT program" src="img/B20976_07_013.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Layout of our FPT program</p>
<ol>
<li value="7">Next, right-click on<a id="_idIndexMarker494"/> the <code>clicked()</code> slot functions, as <a id="_idIndexMarker495"/>shown in the following code:<pre class="source-code">
private slots:
     <strong class="bold">void on_openButton_clicked();</strong>
     <strong class="bold">void on_uploadButton_clicked();</strong>
     <code>itemDoubleClicked(QListWidgetItem*)</code> option and click <strong class="bold">OK</strong>, as shown in the following <a id="_idIndexMarker496"/>screenshot:</li>
</ol>
<div><div><img alt="Figure 7.14 – Selecting the itemDoubleClicked option" src="img/B20976_07_014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Selecting the itemDoubleClicked option</p>
<ol>
<li value="9">Then, declare additional slot<a id="_idIndexMarker497"/> functions such as <code>serverConnected()</code>, <code>serverReply()</code>, and <code>dataReceived()</code>, which we will implement later in this chapter:<pre class="source-code">
private slots:
     void on_openButton_clicked();
     void on_uploadButton_clicked();
     void on_setFolderButton_clicked();
     void on_fileList_itemDoubleClicked(QListWidgetItem *item);
     <strong class="bold">void serverConnected(const QHostAddress &amp;address, int port);</strong>
     <strong class="bold">void serverReply(int code, const QString &amp;parameters);</strong>
     <code>FtpDataChannel</code>.</li>
<li>Then, open up <code>ftpdatachannel.h</code> and add the following code to it:<pre class="source-code">
#ifndef FTPDATACHANNEL_H
#define FTPDATACHANNEL_H
#include &lt;QtCore/qobject.h&gt;
#include &lt;QtNetwork/qtcpserver.h&gt;
#include &lt;QtNetwork/qtcpsocket.h&gt;
#include &lt;memory&gt;
class FtpDataChannel : public QObject{
    Q_OBJECT
public:
    explicit FtpDataChannel(QObject *parent = nullptr);
    void listen(const QHostAddress &amp;address = QHostAddress::Any);
    void sendData(const QByteArray &amp;data);
    void close();
    QString portspec() const;
    QTcpServer m_server;
    std::unique_ptr&lt;QTcpSocket&gt; m_socket;
signals:
    void dataReceived(const QByteArray &amp;data);
};
#endif</pre></li> <li>Right after that, open<a id="_idIndexMarker500"/> the <code>ftpdatachannel.cpp</code> source file<a id="_idIndexMarker501"/> and write the following code:<pre class="source-code">
#include "ftpdatachannel.h"
FtpDataChannel::FtpDataChannel(QObject *parent) : QObject(parent){
    connect(&amp;m_server, &amp;QTcpServer::newConnection, this, [this](){
        m_socket.reset(m_server.nextPendingConnection());
        connect(m_socket.get(), &amp;QTcpSocket::readyRead, this, [this](){
            emit dataReceived(m_socket-&gt;readAll());
        });
        connect(m_socket.get(), &amp;QTcpSocket::bytesWritten, this, [this](qint64 bytes){
            qDebug() &lt;&lt; bytes;
            close();
        });
    });
}</pre></li> <li>Then, we continue to<a id="_idIndexMarker502"/> implement functions for the <code>FtpDataChannel</code> class, such as <code>listen()</code>, <code>sendData()</code>, and <code>close()</code>:<pre class="source-code">
void FtpDataChannel::listen(const QHostAddress &amp;address){
    m_server.listen(address);
}
void FtpDataChannel::sendData(const QByteArray &amp;data){
    if (m_socket)
        m_socket-&gt;write(QByteArray(data).replace("\n", "\r\n"));
}
void FtpDataChannel::close(){
    if (m_socket)
        m_socket-&gt;disconnectFromHost();
}</pre></li> <li>Lastly, we implement the <code>postspec()</code> function, which composes the FTP server’s information<a id="_idIndexMarker503"/> in a special format that can be sent back to the FTP server for verification purposes:<pre class="source-code">
QString FtpDataChannel::portspec() const{
    QString portSpec;
    quint32 ipv4 = m_server.serverAddress().toIPv4Address();
    quint16 port = m_server.serverPort();
    portSpec += QString::number((ipv4 &amp; 0xff000000) &gt;&gt; 24);
    portSpec += ',' + QString::number((ipv4 &amp; 0x00ff0000) &gt;&gt; 16);
    portSpec += ',' + QString::number((ipv4 &amp; 0x0000ff00) &gt;&gt; 8);
    portSpec += ',' + QString::number(ipv4 &amp; 0x000000ff);
    portSpec += ',' + QString::number((port &amp; 0xff00) &gt;&gt; 8);
    portSpec += ',' + QString::number(port &amp;0x00ff);
    return portSpec;
}</pre></li> <li>Once we’re done with the <code>FtpDataChannel</code> class, go to <code>FtpControlChannel</code>.</li>
<li>Open up the newly <a id="_idIndexMarker505"/>created <code>ftpcontrolchannel.h</code> and add the following code to the header file:<pre class="source-code">
#ifndef FTPCONTROLCHANNEL_H
#define FTPCONTROLCHANNEL_H
#include &lt;QtNetwork/qhostaddress.h&gt;
#include &lt;QtNetwork/qtcpsocket.h&gt;
#include &lt;QtCore/qobject.h&gt;
class FtpControlChannel : public QObject{
    Q_OBJECT
public:
    explicit FtpControlChannel(QObject *parent = nullptr);
    void connectToServer(const QString &amp;server);
    void command(const QByteArray &amp;command, const QByteArray &amp;params);
public slots:
    void error(QAbstractSocket::SocketError);
signals:
    void opened(const QHostAddress &amp;localAddress, int localPort);
    void closed();
    void info(const QByteArray &amp;info);
    void reply(int code, const QByteArray &amp;parameters);
    void invalidReply(const QByteArray &amp;reply);
private:
    void onReadyRead();
    QTcpSocket m_socket;
    QByteArray m_buffer;
};
#endif // FTPCONTROLCHANNEL_H</pre></li> <li>Then, let’s <a id="_idIndexMarker506"/>open up <code>ftpcontrolchannel.cpp</code> and write the following <a id="_idIndexMarker507"/>code:<pre class="source-code">
#include "ftpcontrolchannel.h"
#include &lt;QtCore/qcoreapplication.h&gt;
FtpControlChannel::FtpControlChannel(QObject *parent) : QObject(parent){
    connect(&amp;m_socket, &amp;QIODevice::readyRead,
            this, &amp;FtpControlChannel::onReadyRead);
    connect(&amp;m_socket, &amp;QAbstractSocket::disconnected,
            this, &amp;FtpControlChannel::closed);
    connect(&amp;m_socket, &amp;QAbstractSocket::connected, this, [this]() {
        emit opened(m_socket.localAddress(), m_socket.localPort());
    });
    connect(&amp;m_socket, &amp;QAbstractSocket::errorOccurred,
            this, &amp;FtpControlChannel::error);
}</pre></li> <li>Then, we continue to<a id="_idIndexMarker508"/> implement other<a id="_idIndexMarker509"/> functions of the class, such as <code>connectToServer()</code> and <code>command()</code>:<pre class="source-code">
void FtpControlChannel::connectToServer(const QString &amp;server){
    m_socket.connectToHost(server, 21);
}
void FtpControlChannel::command(const QByteArray &amp;command, const QByteArray &amp;params){
    QByteArray sendData = command;
    if (!params.isEmpty())
        sendData += " " + params;
    m_socket.write(sendData + "\r\n");
}</pre></li> <li>Right after that, we continue<a id="_idIndexMarker510"/> to write the code for<a id="_idIndexMarker511"/> its slot functions—namely, <code>onReadyRead()</code> and <code>error()</code>:<pre class="source-code">
void FtpControlChannel::onReadyRead(){
    m_buffer.append(m_socket.readAll());
    int rn = -1;
    while ((rn = m_buffer.indexOf("\r\n")) != -1) {
        QByteArray received = m_buffer.mid(0, rn);
        m_buffer = m_buffer.mid(rn + 2);
        int space = received.indexOf(' ');
        if (space != -1) {
            int code = received.mid(0, space).toInt();
            if (code == 0) {
                qDebug() &lt;&lt; "Info received: " &lt;&lt; received.mid(space + 1);
                emit info(received.mid(space + 1));
            } else {
                qDebug() &lt;&lt; "Reply received: " &lt;&lt; received.mid(space + 1);
                emit reply(code, received.mid(space + 1));
            }
        } else {
            emit invalidReply(received);
        }
    }
}
void FtpControlChannel::error(QAbstractSocket::SocketError error){
    qWarning() &lt;&lt; "Socket error:" &lt;&lt; error;
    QCoreApplication::exit();
}</pre></li> <li>After that, open<a id="_idIndexMarker512"/> up <code>mainwindow.h</code> and add the<a id="_idIndexMarker513"/> following headers:<pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QFile&gt;
#include &lt;QFileInfo&gt;
#include &lt;QFileDialog&gt;
#include &lt;QListWidgetItem&gt;
#include &lt;QMessageBox&gt;
#include &lt;QThread&gt;
#include "ftpcontrolchannel.h"
#include "ftpdatachannel.h"</pre></li> <li>Then, declare the <code>getFileList()</code> function, as follows:<pre class="source-code">
public:
     explicit MainWindow(QWidget *parent = 0);
     ~MainWindow();
     void getFileList();</pre></li> <li>Right after that, declare the<a id="_idIndexMarker514"/> following variables:<pre class="source-code">
private:
     Ui::MainWindow *ui;
     FtpDataChannel* dataChannel;
     FtpControlChannel* controlChannel;
     QString ftpAddress;
     QString username;
     QString password;
     QStringList fileList;
     QString uploadFileName;
     QString downloadFileName;</pre></li> <li>Then, open up <code>mainwindow.cpp</code> and add <a id="_idIndexMarker515"/>the following code to the class constructor:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) {
     ui-&gt;setupUi(this);
     dataChannel = new FtpDataChannel(this);
     connect(dataChannel, &amp;FtpDataChannel::dataReceived, this, &amp;MainWindow::dataReceived);
     connect(controlChannel, &amp;FtpControlChannel::reply, this, &amp;MainWindow::serverReply);
     connect(controlChannel, &amp;FtpControlChannel::opened, this, &amp;MainWindow::serverConnected);
     controlChannel = new FtpControlChannel(this);
     ftpAddress = "127.0.0.1/";
     username = "myuser";
     password = "123456";
     controlChannel-&gt;connectToServer(ftpAddress);
}</pre></li> <li>After that, implement <a id="_idIndexMarker516"/>the <code>getFileList()</code> function, as shown in the following code:<pre class="source-code">
void MainWindow::getFileList() {
controlChannel-&gt;command("PORT", dataChannel-&gt;portspec().toUtf8());
    controlChannel-&gt;command("MLSD", "");}</pre></li> <li>Then, define the <code>on_openButton_clicked()</code> slot function, which gets triggered when the <strong class="bold">Open</strong> button is<a id="_idIndexMarker517"/> clicked, as shown in the following code:<pre class="source-code">
void MainWindow::on_openButton_clicked() {
     QString fileName = QFileDialog::getOpenFileName(this, "Select File", qApp-&gt;applicationDirPath());
     ui-&gt;uploadFileInput-&gt;setText(fileName);
}</pre></li> <li>Once you’re done with that, implement the slot function that gets called when the <strong class="bold">Upload</strong> button is clicked, as shown in the following example:<pre class="source-code">
void MainWindow::on_uploadButton_clicked() {
     QFile* file = new QFile(ui-&gt;uploadFileInput-&gt;text());
     QFileInfo fileInfo(*file);
     uploadFileName = fileInfo.fileName();
     controlChannel-&gt;command("PORT", dataChannel-&gt;portspec().toUtf8());
     controlChannel-&gt;command("STOR", uploadFileName.toUtf8());
}</pre></li> <li>The following code shows <a id="_idIndexMarker518"/>what the <code>on_setFolderButton_clicked()</code> slot function looks like:<pre class="source-code">
void MainWindow::on_setFolderButton_clicked() {
     QString folder = QFileDialog::getExistingDirectory(this, tr("Open Directory"), qApp-&gt;applicationDirPath(), QFileDialog::ShowDirsOnly);
     ui-&gt;downloadPath-&gt;setText(folder);
}</pre></li> <li>Next, define the slot function that <a id="_idIndexMarker519"/>will be triggered when one of the list widget’s items gets double-clicked, as shown in the following code:<pre class="source-code">
void MainWindow::on_fileList_itemDoubleClicked(QListWidgetItem *item) {
     downloadFileName = item-&gt;text();
     QString folder = ui-&gt;downloadPath-&gt;text();
     if (folder != "" &amp;&amp; QDir(folder).exists()) {
           controlChannel-&gt;command("PORT", dataChannel-&gt;portspec().toUtf8());
                       controlChannel-&gt;command("RETR", downloadFileName.toUtf8());
     }
     else {
           QMessageBox::warning(this, "Invalid Path", "Please set the download path before download.");
}}</pre></li> <li>We’re not quite done yet. Next, we will implement the <code>serverConnected()</code> function, which will be called automatically <a id="_idIndexMarker520"/>when the program has successfully connected to the FTP server, as shown<a id="_idIndexMarker521"/> in the following code:<pre class="source-code">
void MainWindow::serverConnected(const QHostAddress &amp;address, int port){
    qDebug() &lt;&lt; "Listening to:" &lt;&lt; address &lt;&lt; port;
    dataChannel-&gt;listen(address);
    controlChannel-&gt;command("USER", username.toUtf8());
    controlChannel-&gt;command("PASS", password.toUtf8());
    getFileList();
}</pre></li> <li>We also need to implement the function that will be called when the FTP server replies to our request, as shown in the following example:<pre class="source-code">
void MainWindow::serverReply(int code, const QString &amp;parameters){
    if (code == 150 &amp;&amp; uploadFileName != ""){
        QFile* file = new QFile(ui-&gt;uploadFileInput-&gt;text());
        QFileInfo fileInfo(*file);
        uploadFileName = fileInfo.fileName();
        if (file-&gt;open(QIODevice::ReadOnly)){
            QThread::msleep(1000);
            QByteArray data = file-&gt;readAll();
            dataChannel-&gt;sendData(data + "\n\r");
            qDebug() &lt;&lt; data;
        } else {
            QMessageBox::warning(this, "Invalid File", "Failed to open file for upload.");
        }
    }
    if (code == 226 &amp;&amp; uploadFileName != ""){
        uploadFileName = "";
        QMessageBox::warning(this, "Upload Success", "File successfully uploaded.");
    }
}</pre></li> <li>The <code>dataReceived()</code> function is<a id="_idIndexMarker522"/> used to obtain <a id="_idIndexMarker523"/>the data received from the FTP server, and it looks something like the following code:<pre class="source-code">
void MainWindow::dataReceived(const QByteArray &amp;data){
    if (data.startsWith("type=file")){
        ui-&gt;fileList-&gt;clear();
        QStringList fileList = QString(data).split("\r\n");
        if (fileList.length() &gt; 0){
            for (int i = 0; i &lt; fileList.length(); ++i){
                if (fileList.at(i) != ""){
                    QStringList fileInfo = fileList.at(i).split(";");
                    QString fileName = fileInfo.at(4).simplified();
                    ui-&gt;fileList-&gt;addItem(fileName);
                }
             }
        }
    } else {
        QString folder = ui-&gt;downloadPath-&gt;text();
        QFile file(folder + "/" + downloadFileName);
        file.open(QIODevice::WriteOnly);
        file.write((data));
        file.close();
        QMessageBox::information(this, "Success", "File successfully downloaded.");
    }
}</pre></li> <li>Lastly, build and run<a id="_idIndexMarker524"/> the program. Try and upload some files to the FTP server. If it works, the file list should be updated<a id="_idIndexMarker525"/> and displayed on the <strong class="bold">List</strong> widget. Then, try and double-click on the filename on the list widget and download the file to your computer, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.15 – Downloading a file from the FTP server by double-clicking on it" src="img/B20976_07_015.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Downloading a file from the FTP server by double-clicking on it</p>
<ol>
<li value="33">You can also try to upload <a id="_idIndexMarker526"/>a file by clicking on the <strong class="bold">Open</strong> button, selecting the<a id="_idIndexMarker527"/> desired file, and pressing the <strong class="bold">Upload</strong> button, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.16 – Uploading a file to the FTP server" src="img/B20976_07_016.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Uploading a file to the FTP server</p>
<ol>
<li value="34">Congratulations, you have <a id="_idIndexMarker528"/>now successfully created a <a id="_idIndexMarker529"/>working FTP program!</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Do note that this example program is only meant to show you the most basic implementation of an FTP program and is not a fully featured program. It’s not guaranteed to work if you try to upload/download files that are not in text format. It may also not upload correctly if a file already exists on the FTP server. You must implement these features by yourself if you wish to expand on top of this project.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>How it works…</h2>
<p>Although this project is much larger and with longer code, it is actually pretty similar to the TCP networking projects we have<a id="_idIndexMarker530"/> done in previous recipes. We have also made use of the signals and slots<a id="_idIndexMarker531"/> mechanism provided by Qt 6 to make our lives easier.</p>
<p>In the past, Qt used to support FTP in the <code>QNetworkAccessManager</code> class. However, FTP has since been deprecated in Qt 6 so we have to implement it on our own.</p>
<p>We must understand some of the most common FTP commands and utilize them in our program. For more information, check out <a href="https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command">https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command</a>.</p>
<p>The <code>FtpControlChannel</code> and <code>FtpDataChannel</code> classes were taken from Qt’s official Git repository with some tiny modifications: <a href="https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient">https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient</a>.</p>
</div>
</body></html>