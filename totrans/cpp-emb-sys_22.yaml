- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-Platform Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we explored practical examples of designing and implementing
    software components for embedded systems. Each example demonstrated good software
    design practices and guided you through the implementation using modern C++ techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The design practices we have followed throughout the book have helped us create
    portable, cross-platform code. Writing cross-platform code is important because
    it enables the reuse of software components across different hardware configurations.
    As we conclude this journey, let’s recap the key practices demonstrated in earlier
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of writing portable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on cross-platform development. The code shown here runs
    on multiple platforms, including common desktop architectures.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Compiler Explorer ([https://godbolt.org/](https://godbolt.org/))
    to run the examples. All source code is available on GitHub at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18).
  prefs: []
  type: TYPE_NORMAL
- en: Importance of writing portable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware projects mature, evolve, and adapt to market needs and supply chain
    conditions. Between 2020 and 2022, the global semiconductor industry faced a severe
    supply chain crisis, primarily triggered by the COVID-19 pandemic and worsened
    by several factors. Lockdowns disrupted production, while soaring demand for electronics
    (e.g., laptops, servers) collided with miscalculations in the automotive sector.
    Carmakers initially canceled chip orders, then scrambled to restock as demand
    rebounded.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, many components became scarce, overpriced, or unavailable altogether.
    Products had to adapt by replacing electronic components such as sensors, drivers,
    communication modules, or even microcontrollers. This, in turn, required firmware
    modifications to match the new hardware.
  prefs: []
  type: TYPE_NORMAL
- en: For well-written firmware, this adaptation was relatively straightforward and
    involved implementing only hardware-specific interfaces. For example, if a product
    used an accelerometer and needed to replace it, a well-designed firmware architecture
    would require just implementing the interface for the new component, leaving the
    business logic unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform code can also run in a simulated environment on a host. In [*Chapter
    17*](Chapter_17.xhtml), we ran Pigweed’s demo application on a host. This was
    possible, thanks to Pigweed’s well-structured interface design, which allowed
    host implementations of low-level hardware interfaces. The same business application
    code can run on multiple targets, including the host, where inputs and outputs
    are simulated.
  prefs: []
  type: TYPE_NORMAL
- en: Well-structured code is easier to read, change, and maintain. Good design principles
    keep projects flexible even as requirements evolve. Next, we will examine the
    five SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples throughout this book are aligned with **SOLID** design principles,
    originally described by Robert C. Martin in his 2000 paper *Design Principles
    and Design Patterns*. They serve as a recognized guide for writing code that remains
    adaptable and easy to work with over time. Although the SOLID principles were
    originally introduced in object-oriented programming, their focus on creating
    modular, maintainable, and extensible code can be applied in broader software
    design contexts. Each letter in the SOLID mnemonic acronym stands for one principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle (SRP)**: A class should have only one responsibility,
    giving it a single reason to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/Closed Principle (OCP)**: A class should be open for extension but closed
    for modification. A new functionality is added by extending the class through
    dynamic or static polymorphism, rather than modifying it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle (LSP)**: Derived classes should be usable in
    place of their parent classes without breaking the software’s behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle (ISP)**: Interface classes should remain
    small and concise so that derived classes implement only methods they need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle (DIP)**: High-level modules (e.g., an accelerometer)
    should not depend on low-level modules (e.g., I2C). Both should rely on abstractions
    (interfaces) rather than concrete implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we’ll go through an example of designing an accelerometer interface,
    explain how to use it, and show how it aligns with SOLID principles and why that
    alignment matters. First, we will design an accelerometer interface class. The
    code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface class accelerometer shown in the preceding code will be implemented
    by the `adxl_345` class, which will use the i2c interface to communicate with
    the actual accelerometer hardware (the ADXL345 integrated circuit is a small accelerometer
    with an I2C digital interface). Also, we will run the code on the STM32 platform,
    so we will create a (stubbed) implementation of the i2c interface – `i2c_stm32`.
    The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will design a simple `tap_detection_algo` class that uses an accelerometer
    interface to collect motion data and identify short, sudden movements, typically
    referred to as taps. The taps are quick spikes in acceleration that can be used
    as user input or trigger events in the application. A boilerplate for the tap-detection
    class is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will write code for the `main` function that instantiates an accelerometer
    and runs a tap detection algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is depicted in the following UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1 – Tap detection algorithm UML diagram](img/B22402_18-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1 – Tap detection algorithm UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18**.1* shows the architecture of the software components we designed.
    The code for the classes shown in the UML diagram is simplified, and it serves
    to demonstrate the following SOLID principles.'
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle (SRP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `accelerometer` class is an interface class with all virtual methods. Its
    single responsibility is to define an interface that will be used by higher-level
    components and implemented by concrete accelerometer implementations such as `adxl_345`.
  prefs: []
  type: TYPE_NORMAL
- en: The `adxl_345` class implements the accelerometer interface and it’s only responsible
    for implementing communication with the ADXL 345 accelerometer over a serial interface
    such as I2C or SPI. The only reason for this class to change is bug fixing related
    to the communication with the sensor itself on the higher protocol level, not
    the serial bus itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `i2c` class is an interface class with the responsibility of defining an
    interface for different implementations of the I2C peripheral, while `i2c_stm32`
    implements this interface. The only reason for the concrete implementation to
    change is bug fixing or optimization related to the serial hardware peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: The `tap_detection_algo` class takes accelerometer data and implements a tap
    detection algorithm using the collected data. The only reason to change this class
    is to fix or optimize the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Open/Closed Principle (OCP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interface-based design for the I2C and accelerometer components lets us extend
    the software without modifying any existing code. For example, if we want to run
    this code on a Texas Instruments microcontroller, all we need to do is implement
    the i2c interface for that platform. Likewise, if we change the accelerometer
    sensor (e.g., to an ST LSDO6), we only have to implement the accelerometer interface
    for the new sensor.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov Substitution Principle (LSP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LSP was introduced by Barbara Liskov in 1987\. The LSP focuses on designing
    robust contracts between base classes and their subclasses. Any client code that
    relies on a base class’s contract should work correctly when using any derived
    class, without unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a contract violation by `adxl_345` would occur if it silently
    fails when an unsupported sampling rate is requested, rather than handling it
    in a way that respects the base class contract (e.g., returning an error status).
  prefs: []
  type: TYPE_NORMAL
- en: The Interface Segregation Principle (ISP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ISP is about splitting large, monolithic interfaces into more focused ones
    so that each class only implements the methods it actually needs. An example of
    a violation of this principle would be having a broad **Inertial Measurement Unit**
    (**IMU**) interface that includes gyroscope and magnetometer functions, as `adxl_345`
    is only an accelerometer and would be forced to provide methods it cannot meaningfully
    support.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Inversion Principle (DIP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The example code we discussed clearly demonstrates the **Dependency Inversion
    Principle (DIP)**. By using an interface-based design, software components are
    cleanly decoupled:'
  prefs: []
  type: TYPE_NORMAL
- en: The `tap_detection_algo` class depends on the `accelerometer` interface, which
    is implemented by `adxl_345`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adxl_345` class depends on the `i2c` interface, which is implemented by
    `i2c_stm32`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles allow us to write highly decoupled software and create reusable,
    hardware-independent code. Decoupled code is more flexible, and it is easier to
    add new features.
  prefs: []
  type: TYPE_NORMAL
- en: '*As an exercise, add an accelerometer data logging capability without modifying
    the existing classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Good software design also improves software testability, which we will explore
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interface-based design leads to decoupled software, which improves testability.
    Let us analyze the former example and see how decoupled design helps with testing.
    We’ll focus on the tap detection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create a simple algorithm that detects a tap when the difference
    between the current sample and the previous sample on any axis exceeds a predefined
    threshold. This oversimplified implementation is shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements a simple tap detection algorithm. It accepts an
    accelerometer reference and, on each call to `run()`, retrieves the current sensor
    data. If it’s the first sample, it stores the value and returns false (no tap
    detected). On subsequent calls, it compares the current reading with the previous
    one on each axis. If the absolute difference on any axis exceeds a constant threshold,
    it signals a tap by returning true, then updates the previous sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'For unit testing, we’ll create a `fake_accel` class that simulates a sequence
    of accelerometer readings. This way, we can control the input data to check if
    `tap_detection_algo` works. The code for the `fake_accel` class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This class, `fake_accel`, is a test double for the accelerometer interface.
    It simulates accelerometer data by:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting a `vector` of predefined data samples through its constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `set_sampling_rate` to always return a successful result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning each sample in order via `get_data()`, and once all samples are used,
    it repeatedly returns the last sample.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This makes it useful for testing components that depend on accelerometer readings.
    Let us see how to use it to test the tap detection algorithm using the GoogleTest
    framework in the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This test verifies that the tap detection algorithm correctly identifies a
    sudden change in accelerometer data as a tap. The test sets up a fake accelerometer
    with three samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First sample: `{0.0f, 1.0f, 0.0f}` – used for initialization (no tap detection).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second sample: `{0.0f, 1.0f, 0.0f}` – no change compared to the first sample,
    so no tap is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third sample: `{0.0f, 2.0f, 0.0f}` – a significant change on the y axis (a
    difference of 1.0, which exceeds the threshold of 0.5) triggers tap detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test expects the first two calls to `run()` to return false and the third
    call to return true. Thanks to interface-based design, we can pass a `fake_accel`
    reference to the `tap_detection_algo` constructor since `fake_accel` implements
    the `accelerometer` interface. We supply the `fake_accel` constructor with a `vector`
    container of samples to feed into the algorithm. This allows us to easily test
    the algorithm with a test dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The full example can be found at GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18)).
    Make sure you add the GoogleTest library to Compiler Explorer when running it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned why writing portable, cross-platform code is important
    for embedded development. It allows you to easily reuse software components and
    adapt to hardware changes, and it improves testability.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about SOLID principles and how they apply to the design of
    software components in embedded systems using C++. Code readability and flexibility
    are some of the most important traits of well-designed software.
  prefs: []
  type: TYPE_NORMAL
- en: We humans read the code, and the human who reads your code may be the future
    you. So, having easy-to-read code should be a priority. Sacrifice readability
    and optimize for performance only when absolutely needed. Having flexible code
    allows you to adapt to changes or add new features easily.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, our journey comes to an end. We began by exploring common
    myths about C++ and debunking them. From there, we covered many important aspects
    of modern C++ and learned how to apply them in embedded application development.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how to use lambdas to write expressive code and took advantage of
    compile-time computation to generate lookup tables, conserving memory and processing
    power. We also leveraged C++ type safety to implement a type-safe HAL.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to apply design patterns such as Adapter, Observer, and
    State to solve typical problems in embedded systems. We explored the C++ Standard
    Library, ETL, Pigweed, and cib and learned how to use them in embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout all the examples in this book, we focused on writing readable, maintainable,
    and loosely coupled code to strengthen our software design and development skills.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this journey and wish you happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Packt_Logo_New1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[packtpub.com](https://packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packtpub.com](https://www.packtpub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9781803239545.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Embedded Systems Architecture, Second Edition**'
  prefs: []
  type: TYPE_NORMAL
- en: Daniele Lacamera
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-80323-954-5'
  prefs: []
  type: TYPE_NORMAL
- en: Participate in the design and definition phase of an embedded product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get to grips with writing code for ARM Cortex-M microcontrollers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an embedded development lab and optimize the workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure embedded systems with TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demystify the architecture behind the communication interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the design and development patterns for connected and distributed
    devices in the IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master multitasking parallel execution patterns and real-time operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Become familiar with Trusted Execution Environment (TEE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9781835460818.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Bare-Metal Embedded C Programming**'
  prefs: []
  type: TYPE_NORMAL
- en: Israel Gbati
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83546-081-8'
  prefs: []
  type: TYPE_NORMAL
- en: Decode microcontroller datasheets, enabling precise firmware development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master register manipulations for optimized Arm-based microcontroller firmware
    creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to navigate hardware intricacies confidently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to write optimized firmware without any assistance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on exercises to create bare-metal drivers for GPIO, timers, ADC, UART,
    SPI, I2C, DMA, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design energy-efficient embedded systems with power management techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](https://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *C++ in Embedded Systems*, we’d love to hear your thoughts!
    If you purchased the book from Amazon, please click here to go straight to the
    Amazon review page for this book and share your feedback or leave a review on
    the site that you purchased it from.
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  prefs: []
  type: TYPE_NORMAL
