- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Cross-Platform Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台开发
- en: In the previous chapters, we explored practical examples of designing and implementing
    software components for embedded systems. Each example demonstrated good software
    design practices and guided you through the implementation using modern C++ techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了为嵌入式系统设计和实现软件组件的实际示例。每个示例都展示了良好的软件设计实践，并指导您使用现代C++技术进行实现。
- en: The design practices we have followed throughout the book have helped us create
    portable, cross-platform code. Writing cross-platform code is important because
    it enables the reuse of software components across different hardware configurations.
    As we conclude this journey, let’s recap the key practices demonstrated in earlier
    chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中遵循的设计实践帮助我们创建了可移植的、跨平台的代码。编写跨平台代码很重要，因为它使得软件组件可以在不同的硬件配置中重用。随着我们结束这次旅程，让我们回顾一下前面章节中展示的关键实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Importance of writing portable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可移植代码的重要性
- en: SOLID design principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: Testability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: This chapter focuses on cross-platform development. The code shown here runs
    on multiple platforms, including common desktop architectures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍跨平台开发。这里展示的代码可以在多个平台上运行，包括常见的桌面架构。
- en: You can use Compiler Explorer ([https://godbolt.org/](https://godbolt.org/))
    to run the examples. All source code is available on GitHub at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Compiler Explorer ([https://godbolt.org/](https://godbolt.org/)) 来运行示例。所有源代码都可在GitHub上找到，网址为[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18)。
- en: Importance of writing portable code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可移植代码的重要性
- en: Hardware projects mature, evolve, and adapt to market needs and supply chain
    conditions. Between 2020 and 2022, the global semiconductor industry faced a severe
    supply chain crisis, primarily triggered by the COVID-19 pandemic and worsened
    by several factors. Lockdowns disrupted production, while soaring demand for electronics
    (e.g., laptops, servers) collided with miscalculations in the automotive sector.
    Carmakers initially canceled chip orders, then scrambled to restock as demand
    rebounded.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件项目成熟、发展并适应市场需求和供应链条件。在2020年至2022年期间，全球半导体行业面临严重的供应链危机，主要是由COVID-19大流行引发的，并因几个因素而加剧。封锁扰乱了生产，而对电子产品（例如笔记本电脑、服务器）的需求激增与汽车行业的误判相撞。汽车制造商最初取消了芯片订单，然后在需求反弹时急忙补货。
- en: As a result, many components became scarce, overpriced, or unavailable altogether.
    Products had to adapt by replacing electronic components such as sensors, drivers,
    communication modules, or even microcontrollers. This, in turn, required firmware
    modifications to match the new hardware.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多组件变得稀缺、价格过高或完全不可用。产品必须通过替换电子组件（如传感器、驱动程序、通信模块甚至微控制器）来适应。这反过来又需要修改固件以匹配新的硬件。
- en: For well-written firmware, this adaptation was relatively straightforward and
    involved implementing only hardware-specific interfaces. For example, if a product
    used an accelerometer and needed to replace it, a well-designed firmware architecture
    would require just implementing the interface for the new component, leaving the
    business logic unchanged.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编写良好的固件，这种适应相对简单，只需实现特定的硬件接口。例如，如果一个产品使用了加速度计并需要替换它，一个设计良好的固件架构只需实现新组件的接口，而无需更改业务逻辑。
- en: Cross-platform code can also run in a simulated environment on a host. In [*Chapter
    17*](Chapter_17.xhtml), we ran Pigweed’s demo application on a host. This was
    possible, thanks to Pigweed’s well-structured interface design, which allowed
    host implementations of low-level hardware interfaces. The same business application
    code can run on multiple targets, including the host, where inputs and outputs
    are simulated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台代码也可以在主机上的模拟环境中运行。在第[*17章*](Chapter_17.xhtml)中，我们在主机上运行了Pigweed的演示应用程序。这是可能的，多亏了Pigweed良好的接口设计，它允许主机实现低级硬件接口。相同的业务应用程序代码可以在多个目标上运行，包括主机，其中输入和输出是模拟的。
- en: Well-structured code is easier to read, change, and maintain. Good design principles
    keep projects flexible even as requirements evolve. Next, we will examine the
    five SOLID principles.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结构良好的代码更容易阅读、修改和维护。良好的设计原则即使在需求变化的情况下也能保持项目的灵活性。接下来，我们将探讨五个SOLID原则。
- en: SOLID design principles
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: 'The examples throughout this book are aligned with **SOLID** design principles,
    originally described by Robert C. Martin in his 2000 paper *Design Principles
    and Design Patterns*. They serve as a recognized guide for writing code that remains
    adaptable and easy to work with over time. Although the SOLID principles were
    originally introduced in object-oriented programming, their focus on creating
    modular, maintainable, and extensible code can be applied in broader software
    design contexts. Each letter in the SOLID mnemonic acronym stands for one principle:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例与**SOLID**设计原则相一致，这些原则最初由Robert C. Martin在他的2000年论文《设计原则与设计模式》中描述。它们作为编写代码的公认指南，这些代码随着时间的推移保持可适应性和易于工作。尽管SOLID原则最初是在面向对象编程中引入的，但它们关注于创建模块化、可维护和可扩展的代码，可以在更广泛的软件开发环境中应用。SOLID助记符中的每个字母代表一个原则：
- en: '**Single Responsibility Principle (SRP)**: A class should have only one responsibility,
    giving it a single reason to change.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则 (SRP)**: 一个类应该只有一个职责，使其只有一个改变的理由。'
- en: '**Open/Closed Principle (OCP)**: A class should be open for extension but closed
    for modification. A new functionality is added by extending the class through
    dynamic or static polymorphism, rather than modifying it.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则 (OCP)**: 一个类应该对扩展开放但对修改封闭。通过动态或静态多态扩展类来添加新功能，而不是修改它。'
- en: '**Liskov Substitution Principle (LSP)**: Derived classes should be usable in
    place of their parent classes without breaking the software’s behavior.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则 (LSP)**: 派生类应该可以在不破坏软件行为的情况下替换其父类。'
- en: '**Interface Segregation Principle (ISP)**: Interface classes should remain
    small and concise so that derived classes implement only methods they need.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则 (ISP)**: 接口类应该保持小巧和简洁，以便派生类只实现它们需要的那些方法。'
- en: '**Dependency Inversion Principle (DIP)**: High-level modules (e.g., an accelerometer)
    should not depend on low-level modules (e.g., I2C). Both should rely on abstractions
    (interfaces) rather than concrete implementations.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则 (DIP)**: 高级模块（例如，加速度计）不应依赖于低级模块（例如，I2C）。两者都应依赖于抽象（接口）而不是具体实现。'
- en: 'Next, we’ll go through an example of designing an accelerometer interface,
    explain how to use it, and show how it aligns with SOLID principles and why that
    alignment matters. First, we will design an accelerometer interface class. The
    code is shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个设计加速度计接口的示例，解释如何使用它，并展示它如何与SOLID原则相一致以及为什么这种一致性很重要。首先，我们将设计一个加速度计接口类。代码如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interface class accelerometer shown in the preceding code will be implemented
    by the `adxl_345` class, which will use the i2c interface to communicate with
    the actual accelerometer hardware (the ADXL345 integrated circuit is a small accelerometer
    with an I2C digital interface). Also, we will run the code on the STM32 platform,
    so we will create a (stubbed) implementation of the i2c interface – `i2c_stm32`.
    The code is shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中显示的接口类加速度计将由`adxl_345`类实现，该类将使用i2c接口与实际的加速度计硬件（ADXL345集成电路是一个具有I2C数字接口的小型加速度计）进行通信。此外，我们将在STM32平台上运行代码，因此我们将创建一个（模拟的）i2c接口实现
    – `i2c_stm32`。代码如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will design a simple `tap_detection_algo` class that uses an accelerometer
    interface to collect motion data and identify short, sudden movements, typically
    referred to as taps. The taps are quick spikes in acceleration that can be used
    as user input or trigger events in the application. A boilerplate for the tap-detection
    class is shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设计一个简单的`tap_detection_algo`类，该类使用加速度计接口来收集运动数据并识别短促的突然运动，通常称为轻敲。轻敲是加速度的快速峰值，可以用作用户输入或触发应用程序中的事件。以下代码展示了轻敲检测类的模板：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we will write code for the `main` function that instantiates an accelerometer
    and runs a tap detection algorithm:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为`main`函数编写代码，该代码实例化一个加速度计并运行轻敲检测算法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code is depicted in the following UML diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下UML图展示了前面的代码：
- en: '![Figure 18.1 – Tap detection algorithm UML diagram](img/B22402_18-01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图18.1 – 轻敲检测算法UML图](img/B22402_18-01.png)'
- en: Figure 18.1 – Tap detection algorithm UML diagram
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 – 轻敲检测算法UML图
- en: '*Figure 18**.1* shows the architecture of the software components we designed.
    The code for the classes shown in the UML diagram is simplified, and it serves
    to demonstrate the following SOLID principles.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18**.1* 展示了我们设计的软件组件的架构。UML 图中显示的类的代码被简化了，它用于演示以下 SOLID 原则。'
- en: Single Responsibility Principle (SRP)
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: The `accelerometer` class is an interface class with all virtual methods. Its
    single responsibility is to define an interface that will be used by higher-level
    components and implemented by concrete accelerometer implementations such as `adxl_345`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`accelerometer` 类是一个接口类，包含所有虚拟方法。它的单一职责是定义一个将被高级组件使用并由具体的加速度计实现（如 `adxl_345`）实现的接口。'
- en: The `adxl_345` class implements the accelerometer interface and it’s only responsible
    for implementing communication with the ADXL 345 accelerometer over a serial interface
    such as I2C or SPI. The only reason for this class to change is bug fixing related
    to the communication with the sensor itself on the higher protocol level, not
    the serial bus itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`adxl_345` 类实现了加速度计接口，它只负责在串行接口（如 I2C 或 SPI）上与 ADXL 345 加速度计进行通信。此类变更的唯一原因是与传感器本身在更高协议级别上的通信相关的错误修复，而不是串行总线本身。'
- en: The `i2c` class is an interface class with the responsibility of defining an
    interface for different implementations of the I2C peripheral, while `i2c_stm32`
    implements this interface. The only reason for the concrete implementation to
    change is bug fixing or optimization related to the serial hardware peripheral.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c` 类是一个接口类，负责为不同的 I2C 外设实现定义接口，而 `i2c_stm32` 实现了这个接口。具体实现变更的唯一原因是与串行硬件外设相关的错误修复或优化。'
- en: The `tap_detection_algo` class takes accelerometer data and implements a tap
    detection algorithm using the collected data. The only reason to change this class
    is to fix or optimize the algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`tap_detection_algo` 类接收加速度计数据，并使用收集到的数据实现敲击检测算法。更改此类的唯一原因是修复或优化算法。'
- en: Open/Closed Principle (OCP)
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放/封闭原则（OCP）
- en: An interface-based design for the I2C and accelerometer components lets us extend
    the software without modifying any existing code. For example, if we want to run
    this code on a Texas Instruments microcontroller, all we need to do is implement
    the i2c interface for that platform. Likewise, if we change the accelerometer
    sensor (e.g., to an ST LSDO6), we only have to implement the accelerometer interface
    for the new sensor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基于接口的 I2C 和加速度计组件设计使我们能够在不修改任何现有代码的情况下扩展软件。例如，如果我们想在德州仪器的微控制器上运行此代码，我们只需要为该平台实现
    i2c 接口。同样，如果我们更换加速度计传感器（例如，更换为 ST LSDO6），我们只需要为新传感器实现加速度计接口。
- en: The Liskov Substitution Principle (LSP)
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Liskov 替换原则（LSP）
- en: The LSP was introduced by Barbara Liskov in 1987\. The LSP focuses on designing
    robust contracts between base classes and their subclasses. Any client code that
    relies on a base class’s contract should work correctly when using any derived
    class, without unexpected behavior.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: LSP（里氏替换原则）是由 Barbara Liskov 在 1987 年提出的。LSP 专注于在基类及其子类之间设计健壮的合同。任何依赖于基类合同的客户端代码，在使用任何派生类时都应正常工作，而不应有意外行为。
- en: In this example, a contract violation by `adxl_345` would occur if it silently
    fails when an unsupported sampling rate is requested, rather than handling it
    in a way that respects the base class contract (e.g., returning an error status).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果 `adxl_345` 在请求不支持的采样率时静默失败，而不是以尊重基类合同的方式处理（例如，返回错误状态），则会发生合同违规。
- en: The Interface Segregation Principle (ISP)
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）
- en: The ISP is about splitting large, monolithic interfaces into more focused ones
    so that each class only implements the methods it actually needs. An example of
    a violation of this principle would be having a broad **Inertial Measurement Unit**
    (**IMU**) interface that includes gyroscope and magnetometer functions, as `adxl_345`
    is only an accelerometer and would be forced to provide methods it cannot meaningfully
    support.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ISP（接口隔离原则）是关于将大型、单一接口拆分为更专注的接口，以便每个类只实现它实际需要的方法。违反此原则的一个例子是拥有一个广泛的**惯性测量单元**（IMU）接口，该接口包括陀螺仪和磁力计功能，而
    `adxl_345` 只是一个加速度计，被迫提供它无法有意义支持的方法。
- en: The Dependency Inversion Principle (DIP)
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）
- en: 'The example code we discussed clearly demonstrates the **Dependency Inversion
    Principle (DIP)**. By using an interface-based design, software components are
    cleanly decoupled:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的示例代码清楚地展示了 **依赖倒置原则 (DIP)**。通过使用基于接口的设计，软件组件被干净地解耦：
- en: The `tap_detection_algo` class depends on the `accelerometer` interface, which
    is implemented by `adxl_345`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_detection_algo` 类依赖于 `accelerometer` 接口，该接口由 `adxl_345` 实现'
- en: The `adxl_345` class depends on the `i2c` interface, which is implemented by
    `i2c_stm32`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adxl_345` 类依赖于 `i2c` 接口，该接口由 `i2c_stm32` 实现'
- en: SOLID principles allow us to write highly decoupled software and create reusable,
    hardware-independent code. Decoupled code is more flexible, and it is easier to
    add new features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 原则使我们能够编写高度解耦的软件，并创建可重用、硬件无关的代码。解耦的代码更灵活，并且更容易添加新功能。
- en: '*As an exercise, add an accelerometer data logging capability without modifying
    the existing classes.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为练习，在不修改现有类的情况下添加加速度计数据记录功能。*'
- en: Good software design also improves software testability, which we will explore
    next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件设计也提高了软件的可测试性，我们将在下一部分探讨。
- en: Testability
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可测试性
- en: Interface-based design leads to decoupled software, which improves testability.
    Let us analyze the former example and see how decoupled design helps with testing.
    We’ll focus on the tap detection algorithm.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 基于接口的设计导致解耦的软件，这提高了可测试性。让我们分析前面的例子，看看解耦设计如何帮助测试。我们将重点关注敲击检测算法。
- en: 'In this example, we create a simple algorithm that detects a tap when the difference
    between the current sample and the previous sample on any axis exceeds a predefined
    threshold. This oversimplified implementation is shown in this code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个简单的算法，当任何轴上当前样本与上一个样本之间的差异超过预定义的阈值时，它会检测到敲击。这个过于简化的实现如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code implements a simple tap detection algorithm. It accepts an
    accelerometer reference and, on each call to `run()`, retrieves the current sensor
    data. If it’s the first sample, it stores the value and returns false (no tap
    detected). On subsequent calls, it compares the current reading with the previous
    one on each axis. If the absolute difference on any axis exceeds a constant threshold,
    it signals a tap by returning true, then updates the previous sample.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了一个简单的敲击检测算法。它接受一个加速度计参考，并在每次调用 `run()` 时检索当前传感器数据。如果是第一个样本，它存储该值并返回
    false（未检测到敲击）。在后续调用中，它比较每个轴上的当前读数与上一个读数。如果任何轴上的绝对差异超过一个常数阈值，它通过返回 true 信号敲击，然后更新上一个样本。
- en: 'For unit testing, we’ll create a `fake_accel` class that simulates a sequence
    of accelerometer readings. This way, we can control the input data to check if
    `tap_detection_algo` works. The code for the `fake_accel` class is shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们将创建一个 `fake_accel` 类来模拟一系列加速度计读数。这样，我们可以控制输入数据以检查 `tap_detection_algo`
    是否工作。`fake_accel` 类的代码如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This class, `fake_accel`, is a test double for the accelerometer interface.
    It simulates accelerometer data by:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类，`fake_accel`，是加速度计接口的测试替身。它通过以下方式模拟加速度计数据：
- en: Accepting a `vector` of predefined data samples through its constructor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其构造函数接受预定义数据样本的 `vector`。
- en: Implementing `set_sampling_rate` to always return a successful result.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `set_sampling_rate` 以始终返回成功的结果。
- en: Returning each sample in order via `get_data()`, and once all samples are used,
    it repeatedly returns the last sample.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `get_data()` 按顺序返回每个样本，并且一旦所有样本都使用完毕，它就重复返回最后一个样本。
- en: 'This makes it useful for testing components that depend on accelerometer readings.
    Let us see how to use it to test the tap detection algorithm using the GoogleTest
    framework in the code shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这使其适用于测试依赖于加速度计读数的组件。让我们看看如何使用它来测试以下代码中所示的 GoogleTest 框架中的敲击检测算法：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This test verifies that the tap detection algorithm correctly identifies a
    sudden change in accelerometer data as a tap. The test sets up a fake accelerometer
    with three samples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试验证敲击检测算法是否正确地将加速度计数据的突然变化识别为敲击。测试设置了一个包含三个样本的假加速度计：
- en: 'First sample: `{0.0f, 1.0f, 0.0f}` – used for initialization (no tap detection).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个样本：`{0.0f, 1.0f, 0.0f}` – 用于初始化（无敲击检测）。
- en: 'Second sample: `{0.0f, 1.0f, 0.0f}` – no change compared to the first sample,
    so no tap is detected.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个样本：`{0.0f, 1.0f, 0.0f}` – 与第一个样本相比没有变化，因此没有检测到敲击。
- en: 'Third sample: `{0.0f, 2.0f, 0.0f}` – a significant change on the y axis (a
    difference of 1.0, which exceeds the threshold of 0.5) triggers tap detection.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个样本：`{0.0f, 2.0f, 0.0f}` – y 轴上的显著变化（1.0 的差异，超过了 0.5 的阈值）触发了敲击检测。
- en: The test expects the first two calls to `run()` to return false and the third
    call to return true. Thanks to interface-based design, we can pass a `fake_accel`
    reference to the `tap_detection_algo` constructor since `fake_accel` implements
    the `accelerometer` interface. We supply the `fake_accel` constructor with a `vector`
    container of samples to feed into the algorithm. This allows us to easily test
    the algorithm with a test dataset.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试预期前两次对 `run()` 的调用返回 false，第三次调用返回 true。多亏了基于接口的设计，我们可以将 `fake_accel` 引用传递给
    `tap_detection_algo` 构造函数，因为 `fake_accel` 实现了 `accelerometer` 接口。我们向 `fake_accel`
    构造函数提供一个 `vector` 容器，其中包含要输入算法的样本。这使得我们能够轻松地使用测试数据集测试算法。
- en: The full example can be found at GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18)).
    Make sure you add the GoogleTest library to Compiler Explorer when running it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可以在 GitHub 上找到 ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18))。确保在运行时将
    GoogleTest 库添加到 Compiler Explorer。
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned why writing portable, cross-platform code is important
    for embedded development. It allows you to easily reuse software components and
    adapt to hardware changes, and it improves testability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了为什么编写可移植的、跨平台的代码对于嵌入式开发很重要。它允许您轻松重用软件组件并适应硬件变化，并提高可测试性。
- en: You also learned about SOLID principles and how they apply to the design of
    software components in embedded systems using C++. Code readability and flexibility
    are some of the most important traits of well-designed software.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了 SOLID 原则及其在嵌入式系统软件组件设计中的应用。代码可读性和灵活性是优秀软件设计的一些最重要的特性。
- en: We humans read the code, and the human who reads your code may be the future
    you. So, having easy-to-read code should be a priority. Sacrifice readability
    and optimize for performance only when absolutely needed. Having flexible code
    allows you to adapt to changes or add new features easily.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类阅读代码，阅读您代码的人可能是未来的您。因此，编写易于阅读的代码应该是优先事项。只有在绝对需要时才牺牲可读性并优化性能。具有灵活的代码允许您轻松适应变化或添加新功能。
- en: With this chapter, our journey comes to an end. We began by exploring common
    myths about C++ and debunking them. From there, we covered many important aspects
    of modern C++ and learned how to apply them in embedded application development.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们的旅程即将结束。我们开始探索关于 C++ 的常见神话，并对其进行驳斥。从那里，我们涵盖了现代 C++ 的许多重要方面，并学习了如何在嵌入式应用程序开发中应用它们。
- en: We explored how to use lambdas to write expressive code and took advantage of
    compile-time computation to generate lookup tables, conserving memory and processing
    power. We also leveraged C++ type safety to implement a type-safe HAL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用 lambda 表达式编写表达性代码，并利用编译时计算来生成查找表，节省内存和处理能力。我们还利用 C++ 类型安全性来实现类型安全的
    HAL。
- en: Next, we learned how to apply design patterns such as Adapter, Observer, and
    State to solve typical problems in embedded systems. We explored the C++ Standard
    Library, ETL, Pigweed, and cib and learned how to use them in embedded applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何应用设计模式，如适配器、观察者和状态，来解决嵌入式系统中的典型问题。我们探讨了 C++ 标准库、ETL、Pigweed 和 cib，并学习了如何在嵌入式应用程序中使用它们。
- en: Throughout all the examples in this book, we focused on writing readable, maintainable,
    and loosely coupled code to strengthen our software design and development skills.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有示例中，我们专注于编写可读的、可维护的、松耦合的代码，以加强我们的软件设计和开发技能。
- en: I hope you enjoyed this journey and wish you happy coding!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这次旅程，并祝您编码愉快！
- en: Join our community on Discord
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[嵌入式系统](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Discord 二维码](img/QR_code_Discord.png)'
- en: '![](img/Packt_Logo_New1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Packt 标志](img/Packt_Logo_New1.png)'
- en: '[packtpub.com](https://packtpub.com)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[packtpub.com](https://packtpub.com)'
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅我们的在线数字图书馆，以获得超过 7,000 本书和视频的完整访问权限，以及行业领先的工具，帮助您规划个人发展并推进您的职业生涯。更多信息，请访问我们的网站。
- en: Why subscribe?
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么订阅？
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自 4,000 多位行业专业人士的实用电子书和视频，节省学习时间，更多时间用于编码
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为您量身定制的技能计划提高学习效果
- en: Get a free eBook or video every month
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月免费获得一本电子书或视频
- en: Fully searchable for easy access to vital information
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全可搜索，便于轻松访问关键信息
- en: Copy and paste, print, and bookmark content
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制粘贴、打印和收藏内容
- en: At [www.packtpub.com](https://www.packtpub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [www.packtpub.com](https://www.packtpub.com)，您还可以阅读一系列免费的技术文章，订阅各种免费通讯，并享受
    Packt 书籍和电子书的独家折扣和优惠。
- en: Other Books You May Enjoy
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可能还会喜欢的其他书籍
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这本书，您可能还会对 Packt 的以下其他书籍感兴趣：
- en: '![](img/9781803239545.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9781803239545.jpg)'
- en: '**Embedded Systems Architecture, Second Edition**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式系统架构，第二版**'
- en: Daniele Lacamera
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Daniele Lacamera
- en: 'ISBN: 978-1-80323-954-5'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 978-1-80323-954-5'
- en: Participate in the design and definition phase of an embedded product
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与嵌入式产品的设计和定义阶段
- en: Get to grips with writing code for ARM Cortex-M microcontrollers
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握为 ARM Cortex-M 微控制器编写代码
- en: Build an embedded development lab and optimize the workflow
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立嵌入式开发实验室并优化工作流程
- en: Secure embedded systems with TLS
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TLS 保护嵌入式系统
- en: Demystify the architecture behind the communication interfaces
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示通信接口背后的架构之谜
- en: Understand the design and development patterns for connected and distributed
    devices in the IoT
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解物联网中连接和分布式设备的设计和开发模式
- en: Master multitasking parallel execution patterns and real-time operating systems
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握多任务并行执行模式和实时操作系统
- en: Become familiar with Trusted Execution Environment (TEE)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉可信执行环境 (TEE)
- en: '![](img/9781835460818.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9781835460818.jpg)'
- en: '**Bare-Metal Embedded C Programming**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**裸机嵌入式 C 编程**'
- en: Israel Gbati
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Israel Gbati
- en: 'ISBN: 978-1-83546-081-8'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 978-1-83546-081-8'
- en: Decode microcontroller datasheets, enabling precise firmware development
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码微控制器数据表，实现精确的固件开发
- en: Master register manipulations for optimized Arm-based microcontroller firmware
    creation
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握寄存器操作，以优化基于 Arm 的微控制器固件创建
- en: Discover how to navigate hardware intricacies confidently
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何自信地导航硬件复杂性
- en: Find out how to write optimized firmware without any assistance
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在不任何帮助的情况下编写优化的固件
- en: Work on exercises to create bare-metal drivers for GPIO, timers, ADC, UART,
    SPI, I2C, DMA, and more
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过练习创建 GPIO、定时器、ADC、UART、SPI、I2C、DMA 等裸机驱动程序
- en: Design energy-efficient embedded systems with power management techniques
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电源管理技术设计节能的嵌入式系统
- en: Packt is searching for authors like you
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Packt 正在寻找像您这样的作者
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](https://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣成为 Packt 的作者，请访问 [authors.packtpub.com](https://authors.packtpub.com)
    并今天申请。我们已与成千上万的开发人员和科技专业人士合作，就像您一样，帮助他们将见解分享给全球科技社区。您可以提交一般申请，申请我们正在招募作者的特定热门话题，或提交您自己的想法。
- en: Share your thoughts
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享您的想法
- en: Now you’ve finished *C++ in Embedded Systems*, we’d love to hear your thoughts!
    If you purchased the book from Amazon, please click here to go straight to the
    Amazon review page for this book and share your feedback or leave a review on
    the site that you purchased it from.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您已完成 *嵌入式系统中的 C++*，我们非常乐意听到您的想法！如果您从亚马逊购买了这本书，请点击此处直接转到该书的亚马逊评论页面并分享您的反馈或在该购买网站上留下评论。
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论对我们和科技社区都非常重要，它将帮助我们确保我们提供高质量的内容。
