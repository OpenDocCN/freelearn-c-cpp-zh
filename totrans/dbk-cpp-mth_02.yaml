- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every C++ Program Is Standard-Compliant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Except when they are not*'
  prefs: []
  type: TYPE_NORMAL
- en: In the world of C++ programming, the concept of standard compliance is often
    held in high regard, with the latest iteration of the C++ standard perceived as
    the definitive guide for writing correct and efficient code. The C++ standard,
    meticulously crafted and periodically updated by the C++ committee and the **International
    Organization for Standardization** ( **ISO** ), serves as the ultimate guide for
    developers, providing a comprehensive set of rules and best practices to ensure
    code quality and interoperability. However, the reality of software development
    is more nuanced and complex than this ideal suggests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the myriad challenges faced by developers
    who, due to various constraints, cannot always adhere to these standards and carefully
    balance on the sharp, thin edge between ideal standards and the practical demands
    of their work. These constraints can include limitations in their development
    environment, such as outdated compilers, legacy systems, or specific project requirements
    that mandate the use of non-standard features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex situations can arise when we are forced to use a framework that uses
    C++ as a base and provides a set of extensions to satisfy a certain use case.
    As we will present at a later stage, these frameworks build on existing standard
    C++ and bring in features that are highly specific for a certain scope, but have
    nothing in common with the C++ standard. So, we might ask ourselves: should we
    use these frameworks or not? The answer to this question, as we will see, is not
    as straightforward as one might assume.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following major topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adherence to standards in various compilers, frameworks, and environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why can’t everyone learn, use, or write standard C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler extensions drifting away from the standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to admit that reading this chapter will not be a straightforward process,
    but we will try to make it as easy as possible. Our minds will wander between
    platforms, compilers, and different dialects of the C++ language. However, at
    some point, we must draw the line and conclude that we should be able to transform
    all this theoretical transfer of information into the practicalities of life and
    produce some C++ code out of it. So, we kindly ask that at this stage of the book,
    you have access to the almighty internet, and the go-to place for experimental
    C++: Matt Godbolt’s site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://gcc.godbolt.org/](https://gcc.godbolt.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: That place should keep you covered since almost all the compilers we will discuss
    in this chapter are to be found there.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing else required for now. That’s because at this stage, we have
    not produced enough valuable code to be able to put anything meaningful into the
    GitHub repository of the book, and the code that we have produced should not go
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhere in Ghana, far, far away
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Richard Appiah Akoto posted a few images of himself drawing the user interface
    of Microsoft Word on a blackboard at his school in Ghana, he instantly became
    a social media phenomenon overnight [1](B22235_02.xhtml#footnote-007) . His school
    was poor and they had no working computers, just a standard blackboard from the
    turn of the century, but this did not stop him from performing his duties as a
    teacher. In a very creative manner, he did his best to convey life-altering knowledge
    to his pupils, hoping that one day, it would be useful for them in their quest
    for a better life. The rest is history, but the real question is: was this the
    standard way of teaching Microsoft Word?'
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B22235_02.xhtml#footnote-007-backlink) [https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/](https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not diverge too much from our initial objective. We want to find out about
    the standard compliance of C++ programs. For zealot C++ programmers, the latest
    iteration of the standard is perceived as holy scripture, the word, the collection
    of rules that they should obey, and any deviation from it should be punishable
    with an erasure and rewrite of the non-standard compliant code. Or one week in
    the detention center labeled *the maintainer of* *legacy code* .
  prefs: []
  type: TYPE_NORMAL
- en: Facing the harsh reality, things couldn’t be further from an idealistic environment.
    Some developers do not have the possibility to use the latest version of the C++
    standard. This could be because their livelihood is bound to real-life projects
    that require a specific compiler, or because the environment they program for
    does not allow the use of specific features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Or maybe they are paid to work on a platform that simply has not received updates
    for the last 20 years because the provider declared bankruptcy a decade ago, and
    there was no one to take up their business. However, since everything works and
    it still generates revenue, it is kept and maintained using tools that were available
    20 years ago.
  prefs: []
  type: TYPE_NORMAL
- en: This definitely does not include compilers with support for the latest C++ standard.
    So, does this mean the C++ code the developers working on these platforms write
    is not standard-compliant?
  prefs: []
  type: TYPE_NORMAL
- en: At the turn of the century, the author of this chapter found himself in a classroom
    at his university, attending a course called *Introduction to C++ Programming*
    . It was the only C++ course offered at that place, and there was one book the
    teacher used to pass on knowledge to more than 30 students.
  prefs: []
  type: TYPE_NORMAL
- en: The small copy shop owner at the end of the road was very happy when, one day,
    the teacher decided to loan the book to one of the students. The book was a translated
    and heavily reduced version of Kris Jamsa’s *C/C++ programmers’ Bible* , the “book
    with the spotted dog,” as we called it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local edition of the book contained only the C++ part, but it carried a
    very important inset: a Turbo C++ Lite IDE and accompanying compiler on a standard
    1.44 MB floppy disk. For those who are unfamiliar with the name, Turbo C++ Lite
    was a dumbed-down version of the popular (and very user-friendly) IDE and compiler
    Turbo C++ by Borland. The compiler was the same, however, a lot of features and
    tools were removed in order to fit the entire environment on a single 1.44 MB
    (megabytes, that is) floppy disk.'
  prefs: []
  type: TYPE_NORMAL
- en: This was our first introduction to the complex world of compilers, linkers,
    and syntax. Some of us found it so fascinating that even now, some 20 years later,
    we still use it in our daily work. So, as you can imagine, our first C++ program
    looked like the one in the screenshot that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The infamous blue screen of code, as seen in Life of a Programmer
    (1997)](img/B22235_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The infamous screen of code, as seen in Life of a Programmer (1997)
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, the horror on your face! I can clearly imagine it, dear C++ acolyte. The
    sheer sight of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iostream.h** : Well, hello, it’s 1999, and the C++98 standard came out last
    year. Why don’t you use it, you heretic? Its number is ISO/IEC 14882:1998, go
    fetch it for a mere 200 Swiss Francs. … Oh, that is your salary as a part-time
    dishwasher for three months while studying here?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void main(void)** : Oh dear, that was never even in any standard, whether
    C or C++. What sort of dark concoction did you just dig out? … Or is this the
    new thing they call… Java?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cout** : Without ever encountering a using directive, how is this even possible?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, you can easily afford to give up on trying to understand the reasons for
    this, sighing with relief, but please bear with me.
  prefs: []
  type: TYPE_NORMAL
- en: Very much akin to the conditions faced by Richard Appiah Akoto, at that stage
    of our education, we also had access to a classroom with a blackboard, accompanied
    by one dedicated teacher and the book, as well as several copies of it, as mentioned
    earlier. Even so, we learned C++. Maybe, from the point of view of the standard,
    these were ideal circumstances, because the C++ standard is very relaxed, considering
    the environment, it requires nothing that you can find in a modern computer –
    no keyboard, no screen, and not even an operating system. Indeed, the only very
    strict environmental requirement is that **char** must be at least 8 bits in size.
    This is to ensure that a **char** can hold any member of the basic execution character
    set (which includes standard ASCII characters). And the fact that **sizeof(char)
    == 1** is also guaranteed by the C++ standard, together with the signed and unsigned
    versions of it. Everything else builds on these foundations.
  prefs: []
  type: TYPE_NORMAL
- en: So, we might say that until we were granted access to the computer lab, we had
    ideal circumstances for learning standard C++. No annoying system dependencies,
    no computer crashes, and no hardware to kick in case of frustration when your
    code does not compile. Since we had no compiler running on the blackboard, our
    teacher soon realized that compiling more complex C++ code on a blackboard is
    not quite feasible, so we were allocated an early Friday morning time slot at
    the computer lab. All the troubles began afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation is quite simple: you see, the computer lab that was allocated
    for teaching C++ at our university back in the day consisted of a bunch of 80286
    IBM AT clones.'
  prefs: []
  type: TYPE_NORMAL
- en: You read that correctly. 30 students were allocated eight computers (each with
    a glorious 80286 processors, possibly high-tech at the time of their conception,
    albeit quite outdated more than one and a half decades later), hand-me-downs from
    some aid organization that likely did an upgrade, and decided to donate their
    old equipment to the university for the tax benefit of the company students. Four
    and a half people were sitting at one machine, with one book (and several copies)
    for the class, trying to learn C++.
  prefs: []
  type: TYPE_NORMAL
- en: Although the situation was not as bleak as in Richard Appiah Akoto’s school
    two decades later, there were simply no better conditions. Those machines could
    never run anything else than pure DOS, and there was no better compiler available
    for them than Turbo C++ Lite, which came out 10 years earlier. Does this mean
    we intentionally learned to write non-standard C++ code? No, obviously not. We
    wrote code that we had the possibility to.
  prefs: []
  type: TYPE_NORMAL
- en: However, let’s not jump that far back in time. As of 2024, the date of writing
    of this book, there are 46 questions on Stack Overflow ( [https://stackoverflow.com/](https://stackoverflow.com/)
    ), containing the dreaded **void main(void)** phrase. The latest one is surprisingly
    from 2023. A bit more with the **iostream.h** content but mostly with educational
    context, and we did not dare count the ones containing **cout** without encountering
    the using directive or a namespace qualifier because it would have been futile.
    Does this mean that even in 2024, there are programmers still writing code that
    relies on non-standard C++? Or are there students learning C++ in a non-standard
    way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Digging a bit further on Stack Overflow, another interesting piece of an old
    dialect of C++ pops up: **conio.h** . This header was shipped with Turbo C (and
    C++) several years before the official standardization of the language, but considering
    that there are young padawans still asking questions about it in 2024, we might
    say that the answer to the previous question is highly likely *yes* .'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on their circumstances and possibilities, whether they have to learn
    using a blackboard, drawing with chalk, or by sharing a keyboard, tapping each
    other’s hands gently in the process, there are still programmers out there today
    who involuntarily have the process of learning and writing non-standard C++ imposed
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft’s tiny, squishy C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s enough staring backward for now. Let’s look, for a moment, in a different
    direction and consider a compiler that once was the king of C++, but with time,
    its shine faded. OpenWatcom is an open source integrated development environment
    and suite of compilers for C and C++ (and Fortran too, but that language is not
    in focus in this book), originally developed by Watcom International Corporation
    and released as open source by Sybase in 2003.
  prefs: []
  type: TYPE_NORMAL
- en: It supports multiple operating systems, including DOS, Windows, OS/2, and also
    Linux, and is the de-facto compiler for programmers who have an interest in creating
    fun, free-time projects for retro platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Not necessarily for the money, but instead for that joyful feeling of sweet
    nostalgia shivering through one’s spine when they are in front of an 80x25 screen.
    Maybe that’s the reason most senior programmers today use a grid of VI editors
    running in a terminal tiled to 6x4 windows, on huge WQUXGA (or larger) screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s get back to the OpenWatcom compiler. While browsing the release notes
    of the project [2](B22235_02.xhtml#footnote-006) , we encountered the following,
    may I say so, quite intriguing phrase (in the *Major differences from version
    10.0* section, at item 29):'
  prefs: []
  type: TYPE_NORMAL
- en: '[2](B22235_02.xhtml#footnote-006-backlink) [https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html](https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We have duplicated a Microsoft Visual C++ extension that was required to parse
    the Windows 95 SDK header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: typedef struct S {
  prefs: []
  type: TYPE_NORMAL
- en: '} S, const *CSP;'
  prefs: []
  type: TYPE_NORMAL
- en: ^^^^^- not allowed in ISO C or ISO C++
  prefs: []
  type: TYPE_NORMAL
- en: Ehm … what? Did I just read correctly that there is an extension for Visual
    C++ that allows non-standard code to be compiled?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, we actually read that correctly. The following short sequence of demonstrative
    code should not compile with any major C++ compiler today, except for Visual C++
    (and OpenWatcom’s C++ compiler, as per their comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '...and due to some mystery, the author was not able to decipher, the code sequence
    is also accepted by several versions of ICC (Intel’s powerful, but sadly discontinued,
    C++ compiler). So, we can ask the following question again: since one major, and
    two relatively esoteric compilers accept this kind of code, does this mean that
    we should use it? Is it standard?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the second question is a definitive *no* . However, for the first
    one, it is a bit more nuanced. This is because before answering, we must take
    the background, requirements, and other relevant factors that might influence
    the decisions concerning the development into consideration again.
  prefs: []
  type: TYPE_NORMAL
- en: Do we want to stick to the standard C++ as much as we can? Is it possible to
    deliver the required solution without extending ourselves to using vendor-specific
    extensions? Are we bound to a compiler or an operating system, and are we not
    worried about ever needing to visit foreign lands?
  prefs: []
  type: TYPE_NORMAL
- en: Would it save us a lot of trouble to use the managed extensions for C++, offered
    by adopting the Microsoft platform, or would we rather stick to the good old syntax
    (and types) that we know and are familiar with?
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft is famous for providing platform-specific extensions for the C and
    C++ languages, to the extent that there is an entire section dedicated to Microsoft-specific
    C++ keywords [3](B22235_02.xhtml#footnote-005) . This tells us that there is a
    market for non-standard C++, and with just cause, because some of these extensions
    are very handy, at the expense of binding ourselves to a platform, compiler, and
    toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[3](B22235_02.xhtml#footnote-005-backlink) [https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170)'
  prefs: []
  type: TYPE_NORMAL
- en: One of the Microsoft extensions manifests itself within the **__declspec** keyword.
    The **__declspec** keyword in C and C++ is part of Microsoft’s extended C++ syntax,
    which allows developers to specify Microsoft-specific storage-class attributes
    for certain C++ constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This keyword provides additional control over behaviors such as DLL exporting
    and memory alignment, which are not covered by the standard ANSI keywords such
    as **static** and **extern** . By using **__declspec** , developers can easily
    and non-standard compliantly apply these features specific to Microsoft’s own
    compiler (behold: a surprise follows!) to their code, enhancing the capabilities
    and performance of their code, such as in the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using Microsoft’s **__declspec(property(...))** syntax, the preceding code sequence
    creates an **age** property that allows indirect interaction with **m_** **age**
    through the methods provided, properly encapsulating the age data while providing
    a simplified interface for accessing and modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of attributes that one can harness with the **__declspec** extension
    is quite long and pragmatic, and **__declspec** also seems to be catchy in the
    compiler development world. In fact, it’s so catchy that **Clang** provides an
    argument dedicated to understanding this Microsoft-specific extension. This flag,
    **-fdeclspec** , makes it possible to use the **__declspec** keyword in code compiled
    by Clang too. So, the question naturally arises: is this a Microsoft-specific
    extension anymore, or are we witnessing the emergence of a cross-platform feature?'
  prefs: []
  type: TYPE_NORMAL
- en: A truth that is still considered to be taboo in hardcore C++ programmer circles
    is that in real life, rare are the situations, when one needs to write true cross-platform
    code. Most programmers work for a specific company, developing or supporting a
    particular product. They’ll mostly use one operating system, with one compiler
    toolchain, complying with the restrictions imposed by their employer and happily
    compiling their code using all the extensions their compiler supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not mean they don’t explicitly want to write standard compliant C++
    code. No, on the contrary, I believe they write the highest quality code they
    can come up with. This just means that they merely use the possibilities provided
    by a specific compiler: the one they have to work with. At their next company,
    there is a high chance that they will be using a different compiler that runs
    on a different OS, thus forgetting all about the advantages provided by their
    ex-compiler at their ex-place. This is because compiler-specific syntax and extensions
    are not bound to one compiler exclusively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following code sample, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Other than hurting our eyes, this sequence is obviously as standard and non-conformant
    as possible. Who in their right mind would ever attempt to initialize an array
    of 6 chars like this? However, the Microsoft Visual C++ compiler happily digests
    it. Let’s start with a few normal characters, and when we get bored of typing
    in all the apostrophes and commas, we’ll just throw everything else in a constant
    string literal, because why not? And it is quite clever about it, detecting the
    size that was requested for the array and matching it to the accumulated length
    of the parts, signaling an error if there are any mismatches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft’s C++ compiler is a very innovative one when it comes to adding features
    not found in the standard, or allowing code that would break a language lawyer’s
    tongue. Let’s look at the following piece of code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sequence is anything but standard C++. Its sheer existence even allows
    us to write code that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example compiles and runs without any issues when compiled using
    Microsoft’s own C++ compiler. Please carefully observe the anonymous class, which
    contains the **name** member, is an object that has a constructor.. This is an
    object that has a constructor, a destructor, and lots of other interesting features.
    This is another (very handy, if I may say so) Microsoft deviation from the standard
    because anonymous unions are a well-known beast of C++. However, anonymous structs
    only dwell in the C language (starting from C11) and no other compiler accepts
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, if you’re not familiar with the notion of anonymous structs
    in the C language, they are a useful feature for simplifying nested structure
    declarations. They do not require the naming of inner structs when they are not
    needed elsewhere, and they make the code more concise and readable. While the
    members are enclosed in a structure, it is still possible to have direct access
    to them. By encapsulating related fields within anonymous structs, and introducing
    logical blocks within these members, the cluttering of the code with unnecessary
    type definitions becomes less overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: The realm of free compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the three major compilers today are developed and maintained in an open-source
    manner. This means that, in theory, anyone can contribute and provide useful new
    features to their compiler of choice. However, in practice, it means that there
    is a tiny core of professional programmers who have the necessary knowledge and
    dedication, and also the backing of a large corporation benefiting from the development
    of the aforementioned compiler working on it.
  prefs: []
  type: TYPE_NORMAL
- en: In no particular order, GCC and Clang (and MSVC, which we discussed in the previous
    section) are the most standard-compliant compilers as of 2024. This standard compliance,
    however, does not mean that these compilers don’t come with their own perks that
    a developer once thought would be a great idea to incorporate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take, for example, the **computed goto** feature of GCC (and Clang too,
    of course; those two tend to go hand in hand). We all have learned in school that
    **goto** is just plain evil, and should not be ever used. If you did not learn
    this in school, please do not learn it from this book. That’s because it is, again,
    not true. Instead, let’s focus on what we can think of the computed **goto** .
    If **goto** is evil, then is computed **goto** calculated evil? So is the following
    code sequence pure evil, or calculated evil? Let’s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing wrong with the first line. The problems start after that. This
    very handy feature can be used for implementing interpreters or state machines
    efficiently and in a non-standard manner by allowing jumps to labels based on
    the value of a pointer, initialized from the address of the label itself. Since
    we are dealing with pointers, it is entirely possible to use the dreaded pointer
    arithmetic and do some calculations on the addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this can be a dangerous feature if not used properly. Unlike in the case
    of the standard **goto** , the calculated one does not take into calculation the
    objects whose lifetime ends upon leaving a specific scope. So, no destructors
    are called. Consider yourself warned!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another pretty useful deviation from the standard C++ syntax comes from GCC
    (and again, it’s implemented by Clang too, what a surprise), which makes the following
    code sequence compilable with these two compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Neat, ain’t it? This feature is called *Statements and Declarations in Expressions*
    and has all the benefits that you can think of: nice encapsulation of the objects
    declared inside, and somewhat safer macros if used properly. It’s too bad it is
    not standard C++.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang, the new kid on the block (well, if we can call a 15-year-old compiler
    the “new” kid, although compared to GCC, with a birth date dating back to 1987,
    Clang is still a very young, albeit skilled, player in the field) takes the feature
    fight a bit further. The following piece of code only compiles with Clang, with
    the benefit of a very special library and a new command line switch to the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This feature is called **Blocks** in Clang. In order to get it right, you will
    need to install the **BlocksRuntime** [4](B22235_02.xhtml#footnote-004) library,
    then specify a special **-fblocks** flag to Clang, and, after all this blocking
    has been done, we can finally compile the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: '[4](B22235_02.xhtml#footnote-004-backlink) [https://github.com/mackyle/blocksruntime](https://github.com/mackyle/blocksruntime)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pretty much resembles the behavior of a standard C++11 lambda, but considering
    that this feature was created and introduced in Clang in 2008, we might call this
    the father of the standard C++ lambda. In case you’re curious, the standard C++
    lambda providing the same functionality is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s not black magic, unlike the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in case you are wondering what is happening there, here’s just a small
    refresher of your C++ freshman memories: under no circumstances is **int array[n]
    = {0};** standard C++. The **variable length array** is a feature present in C,
    but the C++ standard does not include it due to various safety considerations.
    Regardless, the preceding code is accepted by the GCC compiler, but Clang complains
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the error message, the fix is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, even Clang (and several other compilers, such as ICC) accept it, regardless
    of the state of standardness of the code… or rather, the lack of it.
  prefs: []
  type: TYPE_NORMAL
- en: A tribute to attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both GCC and Clang (and also Microsoft Visual C++) can, however, agree on the
    usefulness of one very specific extension to the C++ language: we need a way to
    attach metadata to some of the language constructs (such as types, functions,
    variables, etc.). This metadata can then be used by the compiler and other tools
    to generate optimized code, perform checks, or provide other features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before modern C++ (i.e., C++11) introduced the standardized way to specify
    attributes using the double square bracket syntax **[[attribute]]** , each compiler
    had their own way of specifying these so required attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: GCC and Clang used **__attribute__((attribute-name))**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Visual C++ used **__declspec(attribute-name)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the release of C++11, however, the standardization committee realized
    the usefulness of these, and lifted the most applicable attributes into the language
    (such as **[[noreturn]]** ) while later improvements to the standard added even
    more attributes (such as **[[fallthrough]]** , **[[nodiscard]]** , etc.). However,
    a lot of these attributes remained confined to the compilers that have introduced
    them. The following code snippet showcases some of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code sequence above contains a few attributes shared by GCC and Clang,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**__attribute__((deprecated))** marks **old_function** as deprecated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**__attribute__((noreturn))** is used to indicate that **fatal_error** does
    not return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**__attribute__((pure))** is used to indicate that **pure_function** has no
    side effects except for its return value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**__attribute__((aligned(16)))** is used to align the **x** variable to a 16-byte
    boundary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of attributes these compilers [5](B22235_02.xhtml#footnote-003) provide
    is huge [6](B22235_02.xhtml#footnote-002) , and we can highly recommend that if
    you are in a situation where you are working with one of these compilers on a
    very specific platform, and your main concern is not code portability, platform
    independence, and standard compliance, then you should go and check them out.
    That’s because a lot of power can be harnessed by properly using the tools your
    compiler provides you with.
  prefs: []
  type: TYPE_NORMAL
- en: '[5](B22235_02.xhtml#footnote-003-backlink) [https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html](https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6](B22235_02.xhtml#footnote-002-backlink) [https://clang.llvm.org/docs/AttributeReference.html](https://clang.llvm.org/docs/AttributeReference.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When the header is not even C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The long list of standard-non-compliant-but-still-working-and-useful features
    does not end with the preceding examples. However, if we had only focused our
    attention on those, we could still have filled several books with them. Sadly,
    for the moment, we have only dedicated one chapter to this topic, so let’s move
    our attention to somewhat more exotic features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt has been the de-facto cross-platform programming framework for GUI applications
    (but not only) for quite some time. Throughout its fateful history, while exchanging
    owners several times since its inception in 1994, the Qt framework has evolved
    significantly, with each release giving a new set of features to the C++ (but
    not only) programming community. However, one feature has remained more or less
    the same: the signal/slot implementation and the **Meta Object Compiler** ( **MOC**
    ). The pillar of the framework, the MOC makes it possible to connect events from
    components (i.e., signals) to receivers (i.e., slots) for proper handling.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this very handy feature comes at the expense of having to support several
    non-C++ constructs, which makes the connection between seemingly unrelated elements
    of the application possible. For example, the class declaration of objects that
    must respond to an event is extended by several non-standard “access modifiers”,
    such as **signals:** , **private slots:** , and so on. Also, there is a new **keyword**
    called **emit** , which makes it possible to, well, emit signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long story short, the following is an excerpt from a header file, making the
    compilation of the following code possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Should we adopt the luxury provided to us by Qt and use the very convenient
    signal/slot mechanism with the drawback that we have to write non-standard C++
    code? Or would we rather stick to tradition and create every little button and
    connection by writing pure C++ code, as we would do in GTK?
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter cannot answer this question because, in the end, it is up to every
    project’s specific requirements. Those include what is imposed by the environment,
    what the project stakeholders expect from it, and how the development team decides
    the path forward. However, despair not: even if this does not feel like standard
    C++, it solves a very real-life problem. Behind the scenes, there hides a cutting-edge
    implementation, which has been tested, approved, improved, and used in several
    small- and large-scale projects. It has stood the test of time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft’s own large-scale extension to the C++ language comes from a different
    approach. While not being a specific tool such as Qt’s MOC, C++/CLI extends C++
    with .NET-specific syntax. The Visual Studio compiler for C++/ **CLI** (as in,
    **Common Language Infrastructure** , not Command Line Interface) can parse this
    extended syntax and generate valid Common Intermediate Language (which is a low-level,
    platform-independent instruction set used by the .NET framework) and native code.
    The following code sequence is an example of this managed C++. It does nothing
    special; it just concatenates the elements of an array of strings and prints the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I totally agree; it is anything but standard C++. It does not look like standard
    C++, it does not feel like standard C++, and it doesn’t even quack like standard
    C++. So, it must not be that. The standard-compliant C++ code having the same
    functionality would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Isn’t it nicer, shorter, and more concise than the previous one? Not to mention
    the fact that it is also standard-conformant.
  prefs: []
  type: TYPE_NORMAL
- en: It will be interesting to observe the evolution of the managed extensions of
    C++ in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, it serves as a bridge between native and managed code, which is a
    very niche field for the moment. However, in the long term, its survival is heavily
    dependent on how the developer communities will embrace it (or not), whether the
    ecosystem it has created will be of enough use to keep it alive, or whether other
    technologies, such as P/Invoke or COM Interop, will take over the specific uses
    cases that C++/CLI handles right now.
  prefs: []
  type: TYPE_NORMAL
- en: There are interesting times ahead, indeed.
  prefs: []
  type: TYPE_NORMAL
- en: The curious case of C++ locked in a box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have observed cases where the standard compliance was at the
    developers’ own discretion. They had the option to choose their platform, use
    the extensions provided by their favorite compiler, or go for pure standard C++.
    However, out there in the wild wide world, there are certain circumstances wherein
    we cannot fully comply with the standard due to some restrictions imposed upon
    us by the environment that disallows the usage of certain features found in the
    C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: Not considering obscene scenarios, when we must maintain decades-old legacy
    code written in the golden age of C++ (i.e., before the standardization committee
    took over and ruined all the fun by demanding standard compliance, in order to
    avert the uncontrollable spread of C++ dialects as happened with **BASIC** ),
    there are situations outside of our control that make the usage of the full C++
    standard features impossible. For example, there might be certain requirements
    that disallow the usage of exceptions. Other environments may lack the proper
    support for memory allocation, while others still simply force us to write to
    direct hardware addresses in order for something to happen. However, this last
    one can happen in a standard-compliant way too.
  prefs: []
  type: TYPE_NORMAL
- en: Some embedded systems, for example, actively encourage the usage of their platform-specific
    assembly instructions. As we know, there is no such thing as a platform-independent
    assembly language because that is the lowest level one can go to in today’s C++.
    Below that is pure hexadecimal machine code, but long gone are the times when
    we had to use that in C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: There might also be scenarios wherein the requirements formulated for our code
    by the hardware require deterministic behavior. This, by definition, excludes
    exceptions (because who would like to be unable to follow the code flow at every
    nanosecond during its execution?) and memory allocations (because of allocation
    latency, memory fragmentation, and a myriad of other issues your code is again
    not behaving in a deterministic manner). Thus, a large chunk of the C++ standard
    falls out of our grace.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain solutions tackling the problem of memory allocation in embedded
    systems, such as the usage of memory pools, object pools, compile time memory
    allocation, and various other resources, which may be even platform-specific in
    turn. Then there are the exceptions. In his excellent paper [7](B22235_02.xhtml#footnote-001)
    , Bjarne Stroustrup discusses the challenges, costs, and risks involved in replacing
    C++ exceptions with alternatives such as deterministic exceptions. However, as
    the paper concludes, at this moment, there are no clear advantages to replacing
    the current exception-handling mechanisms with something else. That would include
    another fragmentation in the C++ developer community, as if there aren’t enough
    of those already. Instead, the paper argues for the importance of focusing on
    enhancing the current exception-handling system rather than complicating the language
    with additional mechanisms, emphasizing that exceptions, despite their imperfections,
    have effectively served a vast number of developers for decades.
  prefs: []
  type: TYPE_NORMAL
- en: '[7](B22235_02.xhtml#footnote-001-backlink) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Past days of future C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last scenario that we will explore concerning the standard compliance of
    the code you write relates to the most fundamental item in the C++ ecosystem:
    the compiler itself.'
  prefs: []
  type: TYPE_NORMAL
- en: You see, compilers are also programs, consisting of millions and millions of
    lines of code. There are several contributors spread out on the globe working
    on them, adding new features, fixing bugs, making them more standard compliant,
    releasing the latest versions, and generally making sure that your compiler just
    works.
  prefs: []
  type: TYPE_NORMAL
- en: These compilers also have a development timeline. The implementation of features
    does not happen overnight, and there simply might be situations wherein, at a
    certain point in time, some compiler does not support some feature of the standard
    because there was not enough manpower to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: There is a very handy document available at the source of all C++ knowledge
    [8](B22235_02.xhtml#footnote-000) , which details the support of various C++ standard
    features and which compilers have support for a specific feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[8](B22235_02.xhtml#footnote-000-backlink) [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)'
  prefs: []
  type: TYPE_NORMAL
- en: At the turn of standards (or when forced to use outdated compilers that have
    not implemented some of the features yet), there have been several tricks employed
    by the C++ developer community to compensate for the lack of features in upcoming
    versions of various compilers.
  prefs: []
  type: TYPE_NORMAL
- en: When the **mutable** keyword was introduced in C++98, its implementation in
    certain compilers took a bit longer than in others. For programmers using these
    compilers, it was challenging to modify member variables in **const** member functions
    (a feature introduced in the same standard).
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations like this, the following (quite ugly) hack had to be used to
    counteract the missing keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that your computer supports **const_cast** , there is nothing wrong
    with the preceding code. However, if **const_cast** is not in the list of supported
    keywords, then you are pretty much back to a standard C style cast, such as **((Counter*)(this))->viewCount++;**
    . This should fix all your problems.
  prefs: []
  type: TYPE_NORMAL
- en: The **mutable** keyword was not the first one whose lack of support in compilers
    caused trouble for developers. Before C++11 introduced **constexpr** (and a few
    years after that too, for Microsoft Visual C++ programmers), compile-time constant
    expressions had to be evaluated using various template tricks (or just macros,
    but as we all know, they are evil, so let’s avoid them for as long as we can).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following piece of code calculated the famous factorial of
    some number, before **constexpr** (but still at compile time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The current standard implementation using a compiler that supports **constexpr**
    of the same function is certainly shorter and much easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Certainly, a huge jump in the readability of the code, if I may say so.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this chapter has demonstrated, writing standard C++ ensures code portability,
    compatibility, and maintainability across different platforms and compilers. We
    learned that by adhering to the ISO/IEC C++ standard, we can create code that
    behaves predictably and is less prone to bugs and platform-specific issues. Standard-compliant
    C++ code also benefits from generic compiler optimizations and future language
    enhancements, while ensuring long-term relevance and performance, as we learned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using C++ compiler-specific extensions can provide performance
    optimizations specific to a platform and compiler, access to advanced features
    that are not yet standardized, and integration with vendor-specific tools. However,
    the extension may introduce portability issues, dependencies on specific compiler
    versions, as well as divergence from standard C++ practices, which can impact
    code maintenance and interoperability across different platforms and compilers.
    We also covered this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we learned that adoption should be carefully considered based on
    project needs, balancing the benefits of enhanced functionality with potential
    drawbacks related to compatibility and long-term support. At this stage, we trust
    that you can make the right decision that has the best impact on your project
    and code base while allowing you to deliver the required product. Even if it’s
    your pet project that you coded in your free time on a 30-year-old machine. Compiled
    with a 30-year-old compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Our next chapter, courtesy of Alex, will go on a deep exploration and try to
    uncover the basic truth of whether C++ is indeed just another object-oriented
    language, or whether there is something more lurking below the surface...
  prefs: []
  type: TYPE_NORMAL
