<html><head></head><body>
<div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.2.1">Communicating with Market Participants</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will build the order gateway component at the electronic trading exchange that is responsible for accepting client connections, handling requests, and publishing responses to clients about their orders when there are updates. </span><span class="koboSpan" id="kobo.3.2">Fairness, low latency, and low jitter (latency variance) are important requirements here to facilitate high-frequency trading participants. </span><span class="koboSpan" id="kobo.3.3">We will also build the component that publishes market data from the trading exchange. </span><span class="koboSpan" id="kobo.3.4">These market data updates are designed to allow clients to construct the order book of all client orders that the electronic trading exchange holds. </span><span class="koboSpan" id="kobo.3.5">These market updates need to be sent out as soon as possible when there are order updates and when matches occur, so the focus will be on super-low-latency performance. </span><span class="koboSpan" id="kobo.3.6">Additionally, the exchange needs to periodically provide snapshots of the order book for participants that drop packets or start after the market is </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">already open.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Defining the market data protocol and order </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">data protocol</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Building the order </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">gateway server</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Building the market </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">data publisher</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Building the main </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">exchange application</span></span></li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">All the code for this book can be found in the GitHub repository for this book at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">The source code for this chapter can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">Chapter7</span></strong><span class="koboSpan" id="kobo.20.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">It is important that you have read and understood the design of the electronic trading ecosystem presented in the </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.24.1"> chapter. </span><span class="koboSpan" id="kobo.24.2">The components we build in this chapter will interact with the matching engine we built in the </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.26.1"> chapter, so we assume you are familiar with that. </span><span class="koboSpan" id="kobo.26.2">As before, we will use the building blocks we built in the </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Building the C++ Building Blocks for Low-Latency </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.29.1"> chapter.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.30.1">Defining the market data protocol and order data protocol</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Before we</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.32.1"> build the components inside the trading exchange that publish market data updates and receive and respond to client requests, we need to finalize the protocol. </span><span class="koboSpan" id="kobo.32.2">The </span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.33.1">protocol needs to be publicly available so that market participants who want to connect to the exchange, process updates, and send order requests can build their software. </span><span class="koboSpan" id="kobo.33.2">The protocol is the </span><em class="italic"><span class="koboSpan" id="kobo.34.1">language</span></em><span class="koboSpan" id="kobo.35.1"> that the exchange and market participants will use to communicate. </span><span class="koboSpan" id="kobo.35.2">We will have two protocols – one for the format of the market data updates and one for the format to send order requests and receive order </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">responses in.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.37.1">Designing the market data protocol</span></h2>
<p><span class="koboSpan" id="kobo.38.1">For the </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.39.1">market data protocol, we will define an internal format that the matching engine uses, and a public format meant for the market participants. </span><span class="koboSpan" id="kobo.39.2">We saw the internal matching format, that is, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.41.1"> struct, in the </span><em class="italic"><span class="koboSpan" id="kobo.42.1">Building the Matching Engine</span></em><span class="koboSpan" id="kobo.43.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.44.1">Defining the operations and interactions in our matching engine</span></em><span class="koboSpan" id="kobo.45.1"> section. </span><span class="koboSpan" id="kobo.45.2">In this section, we will define the public market data format, which will be encapsulated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.47.1"> struct. </span><span class="koboSpan" id="kobo.47.2">Remember that we mentioned that market data formats can be of several types and different complexity, for example, the FAST protocol or the SBE protocol. </span><span class="koboSpan" id="kobo.47.3">For our market data format, we will use the </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Simple Binary Encoding</span></strong><span class="koboSpan" id="kobo.49.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.50.1">SBE</span></strong><span class="koboSpan" id="kobo.51.1">) format, which is</span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.52.1"> simply a binary data format. </span><span class="koboSpan" id="kobo.52.2">The code we discuss in this subsection can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">Chapter7/exchange/market_data/market_update.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.54.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Before we look at the market data protocol, a reminder that we first explained what a snapshot of market data is, why it is needed, and how it is synthesized using incremental market data updates in the </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.57.1"> chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.58.1">Understanding how an exchange publishes information to participants</span></em><span class="koboSpan" id="kobo.59.1"> section, in the </span><em class="italic"><span class="koboSpan" id="kobo.60.1">Designing the market data publisher</span></em><span class="koboSpan" id="kobo.61.1"> subsection. </span><span class="koboSpan" id="kobo.61.2">Additionally, we discussed additional details about the snapshot data stream in the same chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.62.1">Building a market participant’s interface to the exchange</span></em><span class="koboSpan" id="kobo.63.1"> section. </span><span class="koboSpan" id="kobo.63.2">So, it would be worthwhile to revisit those sections if a refresher of those concepts is required. </span><span class="koboSpan" id="kobo.63.3">But just to re-introduce snapshot messages, these are messages that contain full information about the state of the limit order book at any given time and can be used by market participants if they need to re-construct the full limit </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">order book.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Before we look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.67.1"> struct, let us first revisit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">MarketUpdateType</span></strong><span class="koboSpan" id="kobo.69.1"> enumeration we created in the previous chapter. </span><span class="koboSpan" id="kobo.69.2">In this chapter, we will add a few new enumeration types here – </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">CLEAR</span></strong><span class="koboSpan" id="kobo.71.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.73.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.75.1"> – which will be needed later. </span><span class="koboSpan" id="kobo.75.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">CLEAR</span></strong><span class="koboSpan" id="kobo.77.1"> message is used to notify clients that they should clear/empty the order book on their end, </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.79.1"> signifies that a snapshot message is starting, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.81.1"> signifies that all updates in the snapshot update have </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">been delivered.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">The updated</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.84.1"> enumeration list is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Exchange {
  enum class MarketUpdateType : uint8_t {
    INVALID = 0,
    CLEAR = 1,
    ADD = 2,
    MODIFY = 3,
    CANCEL = 4,
    TRADE = 5,
    SNAPSHOT_START = 6,
    SNAPSHOT_END = 7
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.87.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.89.1"> structure</span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.90.1"> contains an important addition over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.92.1"> structure, which is a sequence number field. </span><span class="koboSpan" id="kobo.92.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">size_t seq_num_</span></strong><span class="koboSpan" id="kobo.94.1"> field is an increasing sequence number value for every market update published by the exchange. </span><span class="koboSpan" id="kobo.94.2">For every new market update, the sequence number is exactly 1 greater than the previous market update. </span><span class="koboSpan" id="kobo.94.3">This sequence number field will be used by the market data consumers in the market participants’ trading systems to detect gaps in market updates. </span><span class="koboSpan" id="kobo.94.4">Remember that for our market data publisher, we will publish the market data in UDP format, which is an unreliable protocol. </span><span class="koboSpan" id="kobo.94.5">So, when there are drops in packets at the network level, or if a participant’s system drops a packet, they can use the sequence number field to detect that. </span><span class="koboSpan" id="kobo.94.6">We present the internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.96.1"> format again, and the new public </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.98.1"> format </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
#pragma pack(push, 1)
  struct MEMarketUpdate {
    MarketUpdateType type_ = MarketUpdateType::INVALID;
    OrderId order_id_ = OrderId_INVALID;
    TickerId ticker_id_ = TickerId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    Priority priority_ = Priority_INVALID;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "MEMarketUpdate"
         &lt;&lt; " ["
         &lt;&lt; " type:" &lt;&lt; marketUpdateTypeToString(type_)
         &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
         &lt;&lt; " oid:" &lt;&lt; orderIdToString(order_id_)
         &lt;&lt; " side:" &lt;&lt; sideToString(side_)
         &lt;&lt; " qty:" &lt;&lt; qtyToString(qty_)
         &lt;&lt; " price:" &lt;&lt; priceToString(price_)
         &lt;&lt; " priority:" &lt;&lt; priorityToString(priority_)
         &lt;&lt; "]";
      return ss.str();
    }
  };
  struct MDPMarketUpdate {
    size_t seq_num_ = 0;
    MEMarketUpdate me_market_update_;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "MDPMarketUpdate"
         &lt;&lt; " ["
         &lt;&lt; " seq:" &lt;&lt; seq_num_
         &lt;&lt; " " &lt;&lt; me_market_update_.toString()
         &lt;&lt; "]";
      return ss.str();
    }
  };
#pragma pack(pop)</span></pre>
<p><span class="koboSpan" id="kobo.101.1">Hence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.103.1"> is simply </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.105.1"> with a leading </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">seq_num_</span></strong><span class="koboSpan" id="kobo.107.1"> field. </span><span class="koboSpan" id="kobo.107.2">Before we finish this subsection, we will define two simple typedefs that we will need later in this chapter. </span><span class="koboSpan" id="kobo.107.3">We saw the first one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.109.1">, in the previous chapter; the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">MDPMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.111.1"> is similar and represents a lock-free</span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.112.1"> queue of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">MDPMarketUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1"> structures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
  typedef Common::LFQueue&lt;Exchange::MEMarketUpdate&gt;
    MEMarketUpdateLFQueue;
  typedef Common::LFQueue&lt;Exchange::MDPMarketUpdate&gt;
    MDPMarketUpdateLFQueue;</span></pre>
<p><span class="koboSpan" id="kobo.116.1">That concludes our design of the market data protocol. </span><span class="koboSpan" id="kobo.116.2">We will see the design of the order data </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">protocol next.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.118.1">Designing the order data protocol</span></h2>
<p><span class="koboSpan" id="kobo.119.1">In this subsection, we will design the </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.120.1">public order data protocol the clients will use to send order requests to the exchange and receive order responses from it, specifically the order </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">gateway server.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">First, we will see the format of messages sent from the market participant’s order gateway to the exchange’s order gateway server. </span><span class="koboSpan" id="kobo.122.2">We already discussed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">ClientRequestType</span></strong><span class="koboSpan" id="kobo.124.1"> enumeration, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.126.1"> struct, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.128.1"> typedef used by the matching engine in the </span><em class="italic"><span class="koboSpan" id="kobo.129.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.130.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.131.1">Defining the operations and interactions in our matching engine</span></em><span class="koboSpan" id="kobo.132.1"> section. </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.134.1"> is the internal format used by the matching engine, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.136.1"> is the format that the market participants need to use when sending order requests to the exchange order gateway server. </span><span class="koboSpan" id="kobo.136.2">Like the market data format, </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.138.1"> has a sequence number field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">seq_num_</span></strong><span class="koboSpan" id="kobo.140.1">, and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.142.1"> struct after that. </span><span class="koboSpan" id="kobo.142.2">The sequence number field here serves a similar purpose as before, to make sure that the exchange and client’s order gateway components are in sync with each other. </span><span class="koboSpan" id="kobo.142.3">The code for this structure is in </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.143.1">the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Chapter7/exchange/order_server/client_request.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
#include "common/lf_queue.h"
using namespace Common;
namespace Exchange {
#pragma pack(push, 1)
  struct OMClientRequest {
    size_t seq_num_ = 0;
    MEClientRequest me_client_request_;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "OMClientRequest"
         &lt;&lt; " ["
         &lt;&lt; "seq:" &lt;&lt; seq_num_
         &lt;&lt; " " &lt;&lt; me_client_request_.toString()
         &lt;&lt; "]";
      return ss.str();
    }
  };
#pragma pack(pop)
}</span></pre>
<p><span class="koboSpan" id="kobo.147.1">We have a </span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.148.1">symmetrical design of the responses sent from the exchange’s order gateway server to the client’s order gateway component. </span><span class="koboSpan" id="kobo.148.2">We saw the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.150.1"> structure in the previous chapter, which is used internally between the matching engine and the order gateway server component inside the trading exchange infrastructure. </span><span class="koboSpan" id="kobo.150.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.152.1"> structure is the public format that the market participants will use to receive and process order responses in. </span><span class="koboSpan" id="kobo.152.2">Like the other structures we saw before, there is a sequence number field for synchronization purposes and the remaining payload for this structure is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.154.1"> structure. </span><span class="koboSpan" id="kobo.154.2">This structure can be found in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Chapter7/exchange/order_server/client_response.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
#include "common/lf_queue.h"
using namespace Common;
namespace Exchange {
#pragma pack(push, 1)
  struct OMClientResponse {
    size_t seq_num_ = 0;
    MEClientResponse me_client_response_;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "OMClientResponse"
         &lt;&lt; " ["
         &lt;&lt; "seq:" &lt;&lt; seq_num_
         &lt;&lt; " " &lt;&lt; me_client_response_.toString()
         &lt;&lt; "]";
      return ss.str();
    }
  };
#pragma pack(pop)
}</span></pre>
<p><span class="koboSpan" id="kobo.158.1">This concludes the design of</span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.159.1"> the new structures we will need in this chapter. </span><span class="koboSpan" id="kobo.159.2">Next, we will start discussing the implementation of the order gateway server, starting with how it handles incoming client requests from </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">market participants.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.161.1">Building the order gateway server</span></h1>
<p><span class="koboSpan" id="kobo.162.1">In this section, we will start</span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.163.1"> building the order gateway server infrastructure, which is responsible for setting up a TCP server for clients to connect to. </span><span class="koboSpan" id="kobo.163.2">The order gateway server also needs to process incoming client requests from different clients in the order in which they arrive and forward those to the matching engine. </span><span class="koboSpan" id="kobo.163.3">Finally, it also needs to receive the order responses from the matching engine and forward them to the correct TCP connection for the corresponding market participant. </span><span class="koboSpan" id="kobo.163.4">We will revisit the design of the order gateway server and how it interacts with the matching engine and the market participants, </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">as follows.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.165.1"><img alt="Figure 7.1 – Order gateway server and its subcomponents" src="image/B19434_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.166.1">Figure 7.1 – Order gateway server and its subcomponents</span></p>
<p><span class="koboSpan" id="kobo.167.1">To refresh your memory, the order gateway server receives new TCP connections or client requests on established TCP connections. </span><span class="koboSpan" id="kobo.167.2">Then, those requests go through a FIFO sequencer stage to make sure that requests are processed in the exact order in which they arrived at the exchange’s infrastructure. </span><span class="koboSpan" id="kobo.167.3">There is a transformation between the internal matching engine format and the public order data format we described in the previous section. </span><span class="koboSpan" id="kobo.167.4">In the previous chapter on </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Building the Matching Engine</span></em><span class="koboSpan" id="kobo.169.1">, we already built the communication path to and from the matching engine, which is through lock-free queues. </span><span class="koboSpan" id="kobo.169.2">All the details behind the design of this component as well as what purpose it serves in our electronic trading ecosystem were discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.170.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.171.1"> chapter, specifically in the </span><em class="italic"><span class="koboSpan" id="kobo.172.1">Understanding the layout of the electronic trading ecosystem</span></em><span class="koboSpan" id="kobo.173.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.174.1">Understanding how an exchange publishes information to participants</span></em><span class="koboSpan" id="kobo.175.1"> sections. </span><span class="koboSpan" id="kobo.175.2">So, we would strongly recommend revisiting that chapter as you build the order gateway server at </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">the exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">First, we will build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">OrderServer</span></strong><span class="koboSpan" id="kobo.179.1"> class, which </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.180.1">represents the order gateway server component in the preceding diagram. </span><span class="koboSpan" id="kobo.180.2">The code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">OrderServer</span></strong><span class="koboSpan" id="kobo.182.1"> resides in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Chapter7/exchange/order_server/order_server.h</span></strong><span class="koboSpan" id="kobo.184.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Chapter7/exchange/order_server/order_server.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> files.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.187.1">Defining the data members in the order gateway server</span></h2>
<p><span class="koboSpan" id="kobo.188.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">OrderServer</span></strong><span class="koboSpan" id="kobo.190.1"> class has a</span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.191.1"> few important </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">data</span></span><span class="No-Break"><a id="_idIndexMarker1050"/></span><span class="No-Break"><span class="koboSpan" id="kobo.193.1"> members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.194.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">tcp_server_</span></strong><span class="koboSpan" id="kobo.196.1"> variable, which is an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Common::TCPServer</span></strong><span class="koboSpan" id="kobo.198.1"> class, which will be used to host a TCP server to poll for, accept incoming connections from market participants, and poll the established TCP connections to see whether there is data to be read from any of </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the connections.</span></span></li>
<li><span class="koboSpan" id="kobo.200.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">fifo_sequencer_</span></strong><span class="koboSpan" id="kobo.202.1"> variable, which is an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.204.1"> class and is responsible for making sure that client requests that come in on different TCP connections are processed in the correct order in which </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">they came.</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">A lock-free queue variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">outgoing_responses_</span></strong><span class="koboSpan" id="kobo.208.1">, of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.210.1"> type, using which it receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.212.1"> messages from the matching engine, which need to be sent out to the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">market participant.</span></span></li>
<li><span class="koboSpan" id="kobo.214.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">std::array</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.216.1">cid_tcp_socket_</span></strong><span class="koboSpan" id="kobo.217.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.219.1"> objects of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">ME_MAX_NUM_CLIENTS</span></strong><span class="koboSpan" id="kobo.221.1">, which will be used as a hash map from client-id to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.223.1"> connection for </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">that client.</span></span></li>
<li><span class="koboSpan" id="kobo.225.1">Two </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">std::array</span></strong><span class="koboSpan" id="kobo.227.1">s also of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">ME_MAX_NUM_CLIENTS</span></strong><span class="koboSpan" id="kobo.229.1"> to track the exchange-to-client and client-to-exchange sequence numbers on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.231.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.233.1"> messages. </span><span class="koboSpan" id="kobo.233.2">These are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">cid_next_outgoing_seq_num_</span></strong><span class="koboSpan" id="kobo.235.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">cid_next_exp_seq_num_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1"> variables.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">A Boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">run_</span></strong><span class="koboSpan" id="kobo.240.1"> variable, which will be used to start and stop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">OrderServer</span></strong><span class="koboSpan" id="kobo.242.1"> thread. </span><span class="koboSpan" id="kobo.242.2">Note that it is marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">volatile</span></strong><span class="koboSpan" id="kobo.244.1"> since it will be accessed from different threads, and we want to prevent compiler optimizations here for correct</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.245.1"> functionality in a </span><a id="_idIndexMarker1052"/><span class="No-Break"><span class="koboSpan" id="kobo.246.1">multi-threaded environment:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
#pragma once</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.248.1">
#include &lt;functional&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.249.1">
#include "common/thread_utils.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.250.1">
#include "common/macros.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
#include "common/tcp_server.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.252.1">
#include "order_server/client_request.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.253.1">
#include "order_server/client_response.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.254.1">
#include "order_server/fifo_sequencer.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
namespace Exchange {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.256.1">
  class OrderServer {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.257.1">
  private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.258.1">
    const std::string iface_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.259.1">
    const int port_ = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.260.1">
    ClientResponseLFQueue *outgoing_responses_ = nullptr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
    volatile bool run_ = false;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
    std::string time_str_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.263.1">
    Logger logger_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.264.1">
    std::array&lt;size_t, ME_MAX_NUM_CLIENTS&gt; cid_next_outgoing_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.265.1">
    seq_num_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.266.1">
    std::array&lt;size_t, ME_MAX_NUM_CLIENTS&gt; cid_next_exp_seq_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.267.1">
    num_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.268.1">
    std::array&lt;Common::TCPSocket *, ME_MAX_NUM_CLIENTS&gt; cid_tcp_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
    socket_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.270.1">
    Common::TCPServer tcp_server_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.271.1">
    FIFOSequencer fifo_sequencer_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.272.1">
  };</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.274.1">One more minor </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.275.1">declaration before we move on to </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.276.1">the next subsection is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">OrderServer</span></strong><span class="koboSpan" id="kobo.278.1"> class has the following method declarations, which we will define in the subsequent subsections. </span><span class="koboSpan" id="kobo.278.2">These are methods corresponding to the constructor, the destructor, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">start()</span></strong><span class="koboSpan" id="kobo.280.1"> method, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">stop()</span></strong><span class="koboSpan" id="kobo.282.1"> method, but for now, do not worry about the details of these; we will be defining them </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">very soon:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
    OrderServer(ClientRequestLFQueue *client_requests,
    ClientResponseLFQueue *client_responses, const std::string &amp;iface,
    int port);
    ~OrderServer();
    auto start() -&gt; void;
    auto stop() -&gt; void;</span></pre>
<p><span class="koboSpan" id="kobo.285.1">In the next subsection, we will initialize and de-initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">OrderServer</span></strong><span class="koboSpan" id="kobo.287.1"> class and its </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">member variables.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.289.1">Initializing the order gateway server</span></h2>
<p><span class="koboSpan" id="kobo.290.1">The constructor for</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.291.1"> this class is straightforward. </span><span class="koboSpan" id="kobo.291.2">We initialize the three arrays with some basic values: sequence numbers set to 1 and </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.293.1">s set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">nullptr</span></strong><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">We will also set the two callback members, </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.297.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">recv_finished_callback_</span></strong><span class="koboSpan" id="kobo.299.1">, to point to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.301.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">recvFinishedCallback()</span></strong><span class="koboSpan" id="kobo.303.1"> member functions. </span><span class="koboSpan" id="kobo.303.2">We will discuss these callback handling methods in the next few subsections. </span><span class="koboSpan" id="kobo.303.3">The constructor for </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">OrderServer</span></strong><span class="koboSpan" id="kobo.305.1"> accepts pointers to two lock-free queue objects: one to forward </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.307.1">s to the matching engine and one to receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.309.1">s from the matching engine. </span><span class="koboSpan" id="kobo.309.2">It also accepts a network interface and port to use that the order gateway server will listen to and accept client </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">connections on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
#include "order_server.h"
namespace Exchange {
  OrderServer::OrderServer(ClientRequestLFQueue *client_requests,
    ClientResponseLFQueue *client_responses, const std::string &amp;iface,
    int port)
      : iface_(iface), port_(port), outgoing_responses_(client_
    responses), logger_("exchange_order_server.log"),
        tcp_server_(logger_), fifo_sequencer_(client_requests, 
    &amp;logger_) {
    cid_next_outgoing_seq_num_.fill(1);
    cid_next_exp_seq_num_.fill(1);
    cid_tcp_socket_.fill(nullptr);
    tcp_server_.recv_callback_ = [this](auto socket, auto rx_time) { 
    recvCallback(socket, rx_time); };
    tcp_server_.recv_finished_callback_ = [this]() {
    recvFinishedCallback(); };
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.312.1">We will also</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.313.1"> define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">start()</span></strong><span class="koboSpan" id="kobo.315.1"> method, which will set the bool run_ to be true. </span><span class="koboSpan" id="kobo.315.2">This is the flag that controls how long the main thread will run. </span><span class="koboSpan" id="kobo.315.3">We also initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">TCPServer</span></strong><span class="koboSpan" id="kobo.317.1"> member object to start listening on the interface and port that </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">OrderServer</span></strong><span class="koboSpan" id="kobo.319.1"> was provided in the constructor. </span><span class="koboSpan" id="kobo.319.2">Finally, it creates and launches a thread that will execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">run()</span></strong><span class="koboSpan" id="kobo.321.1"> method, which we will also see in the next few subsections. </span><span class="koboSpan" id="kobo.321.2">For now, we will not set affinity on any threads we create in this application, but we will discuss optimization possibilities at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">this book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
  auto OrderServer::start() -&gt; void {
    run_ = true;
    tcp_server_.listen(iface_, port_);
    ASSERT(Common::createAndStartThread(-1, "Exchange/OrderServer",
    [this]() { run(); }) != nullptr, "Failed to start OrderServer
    thread.");
  }</span></pre>
<p><span class="koboSpan" id="kobo.324.1">We define a complementary </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">stop()</span></strong><span class="koboSpan" id="kobo.326.1"> method, which simply sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">run_</span></strong><span class="koboSpan" id="kobo.328.1"> flag to false, which will cause the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">run()</span></strong><span class="koboSpan" id="kobo.330.1"> method to finish execution (more on </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">this shortly):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
  auto OrderServer::stop() -&gt; void {
    run_ = false;
  }</span></pre>
<p><span class="koboSpan" id="kobo.333.1">The destructor for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">OrderServer</span></strong><span class="koboSpan" id="kobo.335.1"> class is also quite simple. </span><span class="koboSpan" id="kobo.335.2">It calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">stop()</span></strong><span class="koboSpan" id="kobo.337.1"> method to instruct the main thread to stop execution and then waits a brief period of time for the thread to finish any </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">pending tasks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
  OrderServer::~OrderServer() {
    stop();
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(1s);
  }</span></pre>
<p><span class="koboSpan" id="kobo.340.1">This concludes the </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.341.1">subsection on the initialization of this class. </span><span class="koboSpan" id="kobo.341.2">Next, we will investigate the functionality needed for </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">OrderServer</span></strong><span class="koboSpan" id="kobo.343.1"> to handle incoming client requests over </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">TCP connections.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.345.1">Handling incoming client requests</span></h2>
<p><span class="koboSpan" id="kobo.346.1">In this subsection, we </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.347.1">will discuss the code we need to handle incoming client requests. </span><span class="koboSpan" id="kobo.347.2">These client requests are received over TCP connections, and these are dispatched to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.349.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">recvFinishedCallback()</span></strong><span class="koboSpan" id="kobo.351.1"> methods through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">TCPServer</span></strong><span class="koboSpan" id="kobo.353.1"> like we set up in the constructor. </span><span class="koboSpan" id="kobo.353.2">We will break down the implementation of this method into different blocks so we can understand it </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">better here.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">The first code block in this method checks whether the size of the available data is at least as large as a complete </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.357.1"> struct. </span><span class="koboSpan" id="kobo.357.2">Then it breaks up the available data into blocks of size equal to the size of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.359.1"> object, and iterates through the available data. </span><span class="koboSpan" id="kobo.359.2">It reinterprets </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">rcv_buffer_</span></strong><span class="koboSpan" id="kobo.361.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.363.1"> as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.365.1"> struct and saves it in the request variable, which is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">OMClientRequest</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.367.1">pointer type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
    auto recvCallback(TCPSocket *socket, Nanos rx_time) noexcept {
      logger_.log("%:% %() % Received socket:% len:% rx:%\n", __FILE__,
    __LINE__, __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
                  socket-&gt;fd_, socket-&gt;next_rcv_valid_index_, rx_
    time);
      if (socket-&gt;next_rcv_valid_index_ &gt;= sizeof(OMClientRequest)) {
        size_t i = 0;
        for (; i + sizeof(OMClientRequest) &lt;= socket-&gt;next_rcv_valid_
        index_; i += sizeof(OMClientRequest)) {
        auto request = reinterpret_cast&lt;const OMClientRequest         *&gt;(socket-&gt;rcv_buffer_ + i);
          logger_.log("%:% %() % Received %\n", __FILE__, __LINE__,
          __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
          request-&gt;toString());</span></pre>
<p><span class="koboSpan" id="kobo.369.1">Once it has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.371.1"> it needs to process, it checks whether this is the first request from this client. </span><span class="koboSpan" id="kobo.371.2">If that is the case, then it tracks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.373.1"> instance for this client by</span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.374.1"> adding it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">cid_tcp_socket_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.376.1">std::array</span></strong><span class="koboSpan" id="kobo.377.1">, which we are using as a </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">hash map:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
          if (UNLIKELY(cid_tcp_socket_[request-&gt;me_client_request_.
</span><span class="koboSpan" id="kobo.379.2">          client_id_] == nullptr)) {
            cid_tcp_socket_[request-&gt;me_client_request_.client_id_] =
            socket;
          }</span></pre>
<p><span class="koboSpan" id="kobo.380.1">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.382.1"> entry for this client-id already existed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">cid_tcp_socket_</span></strong><span class="koboSpan" id="kobo.384.1"> container, then we would make sure that the previously tracked </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.386.1"> for this client-id matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.388.1"> for the current request. </span><span class="koboSpan" id="kobo.388.2">If they do not match, we log an error and skip processing </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">this request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
          if (cid_tcp_socket_[request-&gt;me_client_request_.client_id_]
          != socket) {
            logger_.log("%:% %() % Received ClientRequest from
            ClientId:% on different socket:% expected:%\n", __FILE__,
            __LINE__, __FUNCTION__,
                        Common::getCurrentTimeStr(&amp;time_str_),
                        request-&gt;me_client_request_.client_id_,
                        socket-&gt;fd_,
                        cid_tcp_socket_[request-&gt;me_client_request_.
</span><span class="koboSpan" id="kobo.390.2">                        client_id_]-&gt;fd_);
            continue;
          }</span></pre>
<p><span class="koboSpan" id="kobo.391.1">Next, we will perform a sequence number check to make sure that the sequence number on this </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.393.1"> is exactly what we expect it to be based on the last message we have seen. </span><span class="koboSpan" id="kobo.393.2">If there is a mismatch between the expected and received sequence numbers, then </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.394.1">we log an error and ignore </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">this request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
          auto &amp;next_exp_seq_num = cid_next_exp_seq_num_[request-&gt;me_
          client_request_.client_id_];
          if (request-&gt;seq_num_ != next_exp_seq_num) {
            logger_.log("%:% %() % Incorrect sequence number.
</span><span class="koboSpan" id="kobo.396.2">            ClientId:% SeqNum expected:% received:%\n", __FILE__,
            __LINE__, __FUNCTION__,
                        Common::getCurrentTimeStr(&amp;time_str_),
                        request-&gt;me_client_request_.client_id_, next_
                        exp_seq_num, request-&gt;seq_num_);
            continue;
          }</span></pre>
<p><span class="koboSpan" id="kobo.397.1">One note here is that in a realistic setup, the exchange will send a reject back to the client if it receives a request on an incorrect socket or if there is a sequence number mismatch, to notify them of the error. </span><span class="koboSpan" id="kobo.397.2">We have omitted that here for simplicity’s sake, but it is not difficult to add if needed. </span><span class="koboSpan" id="kobo.397.3">If we have made it this far in the execution of this loop, then we increment the next expected sequence number on the next </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">OMClientRequest</span></strong><span class="koboSpan" id="kobo.399.1"> for this client and forward this request to the FIFO sequencer data member. </span><span class="koboSpan" id="kobo.399.2">One important thing to note here is that we also forward </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">rx_time</span></strong><span class="koboSpan" id="kobo.401.1">, which is the software receive time of this TCP packet, to the FIFO sequencer since it will need that information to sequence the requests correctly. </span><span class="koboSpan" id="kobo.401.2">We will discuss the details of how the FIFO sequencer achieves this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">next subsection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
          ++next_exp_seq_num;
          fifo_sequencer_.addClientRequest(rx_time, request-&gt;me_
          client_request_);
        }
        memcpy(socket-&gt;rcv_buffer_, socket-&gt;rcv_buffer_ + i, socket-
        &gt;next_rcv_valid_index_ - i);
        socket-&gt;next_rcv_valid_index_ -= i;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.404.1">Remember that</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.405.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">recvFinishedCallback()</span></strong><span class="koboSpan" id="kobo.407.1"> method is called when all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.409.1"> methods have been dispatched from the current call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">TCPServer::sendAndRecv()</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">recvFinishedCallback()</span></strong><span class="koboSpan" id="kobo.413.1"> method instructs </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.415.1"> to correctly order the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">MEClientRequests</span></strong><span class="koboSpan" id="kobo.417.1"> that it has queued up and push them to the matching engine. </span><span class="koboSpan" id="kobo.417.2">This mechanism will become clear when we discuss the design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.419.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">next subsection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
    auto recvFinishedCallback() noexcept {
      fifo_sequencer_.sequenceAndPublish();
    }</span></pre>
<p><span class="koboSpan" id="kobo.422.1">Next, we will discuss the FIFO sequencer component, which is responsible for maintaining fairness from the perspective of processing client requests. </span><span class="koboSpan" id="kobo.422.2">It does this by making sure that requests received across different TCP connections are processed in the exact order in which they were received in the order </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">gateway server.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.424.1">Processing requests fairly using the FIFO sequencer</span></h2>
<p><span class="koboSpan" id="kobo.425.1">The</span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.426.1"> FIFO sequencer</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.427.1"> subcomponent in the order gateway server is responsible for making sure that client requests are processed in the order of their arrival time. </span><span class="koboSpan" id="kobo.427.2">This is necessary because the order gateway server reads and dispatches client requests from different TCP connections, which arrive at different times. </span><span class="koboSpan" id="kobo.427.3">Let us get started by first defining the data members inside this class. </span><span class="koboSpan" id="kobo.427.4">The code for the FIFO sequencer is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Chapter7/exchange/order_server/fifo_sequencer.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.429.1">source file.</span></span></p>
<h3><span class="koboSpan" id="kobo.430.1">Defining the data members in the FIFO sequencer</span></h3>
<p><span class="koboSpan" id="kobo.431.1">First, we define a</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.432.1"> constant, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">ME_MAX_PENDING_REQUESTS</span></strong><span class="koboSpan" id="kobo.434.1">, which</span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.435.1"> represents the maximum number of simultaneously pending requests available at the network socket across all TCP connections. </span><span class="koboSpan" id="kobo.435.2">If the order gateway server is busy with other tasks and has not polled the TCP connections for a very short period of time, it is possible client requests arrived during that time and are queued at the network </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">socket level.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">The FIFO sequencer uses this constant to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">std::array</span></strong><span class="koboSpan" id="kobo.439.1"> of that size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">RecvTimeClientRequest</span></strong><span class="koboSpan" id="kobo.441.1"> structures. </span><span class="koboSpan" id="kobo.441.2">This member variable is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">pending_client_requests_</span></strong><span class="koboSpan" id="kobo.443.1"> in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.445.1"> class. </span><span class="koboSpan" id="kobo.445.2">To count the number of actual pending request entries in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">pending_client_requests_</span></strong><span class="koboSpan" id="kobo.447.1"> array, we will maintain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">pending_size_</span></strong><span class="koboSpan" id="kobo.449.1"> variable of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">size_t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">RecvTimeClientRequest</span></strong><span class="koboSpan" id="kobo.454.1"> struct has two members – </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">recv_time_</span></strong><span class="koboSpan" id="kobo.456.1">, of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Nanos</span></strong><span class="koboSpan" id="kobo.458.1"> type, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">request_</span></strong><span class="koboSpan" id="kobo.460.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.462.1"> type. </span><span class="koboSpan" id="kobo.462.2">This structure captures the client request as well as the time of its arrival at the order gateway server. </span><span class="koboSpan" id="kobo.462.3">We will sort these by time and then process them in order of arrival. </span><span class="koboSpan" id="kobo.462.4">To make sorting easy, we will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">&lt;</span></strong><span class="koboSpan" id="kobo.464.1"> operator, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">true</span></strong><span class="koboSpan" id="kobo.466.1"> if the client request on the </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">left-hand side</span></strong><span class="koboSpan" id="kobo.468.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.469.1">LHS</span></strong><span class="koboSpan" id="kobo.470.1">) was received before the client request on the </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">right-hand side</span></strong><span class="koboSpan" id="kobo.472.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.473.1">RHS</span></strong><span class="koboSpan" id="kobo.474.1">) of </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">that operator.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Finally, the last</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.477.1"> important member of this class is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">incoming_requests_</span></strong><span class="koboSpan" id="kobo.479.1"> variable, which</span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.480.1"> is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.482.1"> type, which is the lock-free queue that the FIFO sequencer uses to send </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.484.1">s to the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">matching engine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
#pragma once
#include "common/thread_utils.h"
#include "common/macros.h"
#include "order_server/client_request.h"
namespace Exchange {
  constexpr size_t ME_MAX_PENDING_REQUESTS = 1024;
  class FIFOSequencer {
  private:
    ClientRequestLFQueue *incoming_requests_ = nullptr;
    std::string time_str_;
    Logger *logger_ = nullptr;
    struct RecvTimeClientRequest {
      Nanos recv_time_ = 0;
      MEClientRequest request_;
      auto operator&lt;(const RecvTimeClientRequest &amp;rhs) const {
        return (recv_time_ &lt; rhs.recv_time_);
      }
    };
    std::array&lt;RecvTimeClientRequest, ME_MAX_PENDING_REQUESTS&gt;
    pending_client_requests_;
    size_t pending_size_ = 0;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.487.1">Now, let us look at the source code to initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">FIFO sequencer.</span></span></p>
<h3><span class="koboSpan" id="kobo.489.1">Initializing the FIFO sequencer</span></h3>
<p><span class="koboSpan" id="kobo.490.1">The </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.491.1">constructor for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.493.1"> class is straightforward and self-explanatory. </span><span class="koboSpan" id="kobo.493.2">It is presented as follows and initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">incoming_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.495.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.496.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">logger_</span></strong><span class="koboSpan" id="kobo.498.1">, which are both passed to it in the constructor for </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">this class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
  class FIFOSequencer {
  public:
    FIFOSequencer(ClientRequestLFQueue *client_requests, Logger 
    *logger)
        : incoming_requests_(client_requests), logger_(logger) {
    }</span></pre>
<p><span class="koboSpan" id="kobo.501.1">Now, we will look at the most important functionality inside the FIFO sequencer – queueing up client requests and publishing them in order of their </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">receive time.</span></span></p>
<h3><span class="koboSpan" id="kobo.503.1">Publishing client requests in order</span></h3>
<p><span class="koboSpan" id="kobo.504.1">We</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.505.1"> used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">FIFOSequencer::addClientRequest()</span></strong><span class="koboSpan" id="kobo.507.1"> method in a previous subsection, </span><em class="italic"><span class="koboSpan" id="kobo.508.1">Handling incoming client requests</span></em><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">Here, we present the implementation, which is quite simple and involves simply adding it to the end of </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">pending_client_requests_</span></strong><span class="koboSpan" id="kobo.511.1"> and incrementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">pending_size_</span></strong><span class="koboSpan" id="kobo.513.1"> variable to signify that there is an additional entry that was added. </span><span class="koboSpan" id="kobo.513.2">Note here that we only ever expect a maximum of </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">ME_MAX_PENDING_REQUESTS</span></strong><span class="koboSpan" id="kobo.515.1"> at a time since we set it to a high value. </span><span class="koboSpan" id="kobo.515.2">If this limit is not enough, we have the option of increasing the array size and possibly switching to using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">MemPool</span></strong><span class="koboSpan" id="kobo.517.1"> of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">RecvTimeClientRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
    auto addClientRequest(Nanos rx_time, const MEClientRequest
    &amp;request) {
      if (pending_size_ &gt;= pending_client_requests_.size()) {
        FATAL("Too many pending requests");
      }
      pending_client_requests_.at(pending_size_++) =
      std::move(RecvTimeClientRequest{rx_time, request});
    }</span></pre>
<p><span class="koboSpan" id="kobo.521.1">We also </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.522.1">used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">FIFOSequencer::sequenceAndPublish()</span></strong><span class="koboSpan" id="kobo.524.1"> method in a previous subsection, </span><em class="italic"><span class="koboSpan" id="kobo.525.1">Handling incoming client requests</span></em><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">This is the most important method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.528.1"> class and performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.530.1">First, it sorts all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">RecvTimeClientRequest</span></strong><span class="koboSpan" id="kobo.532.1"> entries in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">pending_client_requests_</span></strong><span class="koboSpan" id="kobo.534.1"> container in ascending order of their arrival times. </span><span class="koboSpan" id="kobo.534.2">It achieves this by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">std::sort()</span></strong><span class="koboSpan" id="kobo.536.1"> algorithm, which in turn uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">&lt;</span></strong><span class="koboSpan" id="kobo.538.1"> operator we built for </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">RecvTimeClientRequest</span></strong><span class="koboSpan" id="kobo.540.1"> objects to sort the container. </span><span class="koboSpan" id="kobo.540.2">One word here: sorting can become time consuming if the number of elements is very large, but we rarely expect that to be the case here, since the number of simultaneously pending requests is expected to be quite low. </span><span class="koboSpan" id="kobo.540.3">This would be another optimization area, but we need to measure the load and performance of our system in practice before deciding how to </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">improve this.</span></span></li>
<li><span class="koboSpan" id="kobo.542.1">After the sorting step, it writes each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.544.1"> entries to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">incoming_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.546.1">LFQueue</span></strong><span class="koboSpan" id="kobo.547.1">, which goes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">matching engine.</span></span></li>
<li><span class="koboSpan" id="kobo.549.1">Finally, it</span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.550.1"> resets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">pending_size_</span></strong><span class="koboSpan" id="kobo.552.1"> variable to mark the end of processing and returns  from </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the method</span></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
    auto sequenceAndPublish() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
      if (UNLIKELY(!pending_size_))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
        return;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
      logger_-&gt;log("%:% %() % Processing % requests.\n", __</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.559.1">
      FILE__, __LINE__, __FUNCTION__, Common::getCurrentTimeStr</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
      (&amp;time_str_), pending_size_);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
      std::sort(pending_client_requests_.begin(), pending_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
      client_requests_.begin() + pending_size_);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
      for (size_t i = 0; i &lt; pending_size_; ++i) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.564.1">
        const auto &amp;client_request = pending_client_requests_.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.565.1">
        at(i);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.566.1">
        logger_-&gt;log("%:% %() % Writing RX:% Req:%</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.567.1">
        to FIFO.\n", __FILE__, __LINE__, __FUNCTION__,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.568.1">
        Common::getCurrentTimeStr(&amp;time_str_),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
                     client_request.recv_time_, client_request.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
                     request_.toString());</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.571.1">
        auto next_write = incoming_requests_-&gt;getNextToWriteTo();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.572.1">
        *next_write = std::move(client_request.request_);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.573.1">
        incoming_requests_-&gt;updateWriteIndex();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.574.1">
      }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.575.1">
      pending_size_ = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.576.1">
    }</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.577.1">This concludes the</span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.578.1"> design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.580.1"> subcomponent inside our order gateway server. </span><span class="koboSpan" id="kobo.580.2">Now, we can go back to our design of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">OrderServer</span></strong><span class="koboSpan" id="kobo.582.1"> class by adding functionality to send client responses back out to the clients </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">over TCP.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.584.1">Sending client responses</span></h2>
<p><span class="koboSpan" id="kobo.585.1">In this subsection, we will look</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.586.1"> at how </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">OrderServer</span></strong><span class="koboSpan" id="kobo.588.1"> performs two important tasks in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">run()</span></strong><span class="koboSpan" id="kobo.590.1"> method. </span><span class="koboSpan" id="kobo.590.2">Remember that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">run()</span></strong><span class="koboSpan" id="kobo.592.1"> method is the main loop for this class, which is run on the thread we created and launched in the </span><em class="italic"><span class="koboSpan" id="kobo.593.1">Initializing the order gateway server</span></em><span class="koboSpan" id="kobo.594.1"> subsection, specifically in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">start()</span></strong><span class="koboSpan" id="kobo.596.1"> method. </span><span class="koboSpan" id="kobo.596.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">run()</span></strong><span class="koboSpan" id="kobo.598.1"> method performs the following two </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">main tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.600.1">It calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">poll()</span></strong><span class="koboSpan" id="kobo.602.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">TCPServer</span></strong><span class="koboSpan" id="kobo.604.1"> object it holds. </span><span class="koboSpan" id="kobo.604.2">Remember that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">poll()</span></strong><span class="koboSpan" id="kobo.606.1"> method checks for and accepts new connections, removes dead connections, and checks whether there is data available on any of the established TCP connections, that is, </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">client requests.</span></span></li>
<li><span class="koboSpan" id="kobo.608.1">It also calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.610.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">TCPServer</span></strong><span class="koboSpan" id="kobo.612.1"> object it holds. </span><span class="koboSpan" id="kobo.612.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.614.1"> method reads the data from each of the TCP connections and dispatches the callbacks for them. </span><span class="koboSpan" id="kobo.614.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.616.1"> call also sends out any outgoing data on the TCP connections, that is, client responses. </span><span class="koboSpan" id="kobo.616.2">This code block is shown as follows and should be quite easy </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">to understand:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.618.1">
    auto run() noexcept {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
      logger_.log("%:% %() %\n", __FILE__, __LINE__, __</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.620.1">
      FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
      while (run_) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
        tcp_server_.poll();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
        tcp_server_.sendAndRecv();</span></pre></li>
<li><span class="koboSpan" id="kobo.624.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">run()</span></strong><span class="koboSpan" id="kobo.626.1"> loop also drains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">outgoing_responses_</span></strong><span class="koboSpan" id="kobo.628.1"> lock-free queue, which the matching engine uses to send out </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.630.1"> messages that need to be dispatched to the </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">correct clients.</span></span></li>
<li><span class="koboSpan" id="kobo.632.1">It iterates through the available data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">outgoing_responses_</span></strong><span class="koboSpan" id="kobo.634.1"> queue and then for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.636.1"> it reads, it first finds out what the correct outgoing sequence number is. </span><span class="koboSpan" id="kobo.636.2">This is the sequence number on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.638.1"> message to be sent to that </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">client ID.</span></span><span class="koboSpan" id="kobo.640.1"> It does this by looking up that answer in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">cid_next_outgoing_seq_num_</span></strong><span class="koboSpan" id="kobo.642.1"> array, which we are </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.643.1">really using as a hash map from the client ID to the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">sequence number:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.645.1">
        for (auto client_response = outgoing_responses_-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.646.1">
        &gt;getNextToRead(); outgoing_responses_-&gt;size() &amp;&amp;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
        client_response; client_response = outgoing_responses_-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.648.1">
        &gt;getNextToRead()) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.649.1">
          auto &amp;next_outgoing_seq_num = cid_next_outgoing_seq_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.650.1">
          num_[client_response-&gt;client_id_];</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.651.1">
          logger_.log("%:% %() % Processing cid:% seq:% %\n", __</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.652.1">
          FILE__, __LINE__, __FUNCTION__,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.653.1">
          Common::getCurrentTimeStr(&amp;time_str_),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.654.1">
          client_response-&gt;client_id_, next_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.655.1">
          outgoing_seq_num, client_response-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.656.1">
          &gt;toString());</span></pre></li>
<li><span class="koboSpan" id="kobo.657.1">It also checks that it has a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.659.1"> for the client ID that this response is meant for. </span><span class="koboSpan" id="kobo.659.2">It looks up that information in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">cid_tcp_socket_</span></strong><span class="koboSpan" id="kobo.661.1"> array, which is a hash map from the client ID to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">TCPSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.663.1"> objects.</span></span></li>
<li><span class="koboSpan" id="kobo.664.1">It then sends an </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.666.1"> message on </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.668.1"> for this client ID by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">TCPSocket::send()</span></strong><span class="koboSpan" id="kobo.670.1"> method. </span><span class="koboSpan" id="kobo.670.2">It achieves this by first sending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">next_outgoing_seq_num_</span></strong><span class="koboSpan" id="kobo.672.1"> value and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.674.1"> message that the matching engine generated. </span><span class="koboSpan" id="kobo.674.2">It might not be immediately clear, but this is actually sending an </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.676.1"> message because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.678.1"> message is actually just a sequence number field followed by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.680.1"> message, which is what we </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">just did.</span></span></li>
<li><span class="koboSpan" id="kobo.682.1">Finally, it </span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.683.1">updates the read index and the sequence number of the next outgoing message and continues with </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">the loop:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.685.1">
          ASSERT(cid_tcp_socket_[client_response-&gt;client_id_] !=</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.686.1">
          nullptr,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
                 "Dont have a TCPSocket for ClientId:" + </span></pre><pre class="source-code"><span class="koboSpan" id="kobo.688.1">
                 std::to_string(client_response-&gt;client_id_));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.689.1">
          cid_tcp_socket_[client_response-&gt;client_id_]-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.690.1">
          &gt;send(&amp;next_outgoing_seq_num, sizeof(next_outgoing_</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.691.1">
          seq_num));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.692.1">
          cid_tcp_socket_[client_response-&gt;client_id_]-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.693.1">
          &gt;send(client_response, sizeof(MEClientResponse));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.694.1">
          outgoing_responses_-&gt;updateReadIndex();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.695.1">
          ++next_outgoing_seq_num;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.696.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
      }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.698.1">
    }</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.699.1">This concludes the</span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.700.1"> full design and implementation of the order gateway server component in our electronic trading infrastructure. </span><span class="koboSpan" id="kobo.700.2">Next, we will look at the component that publishes the public market data to </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">the participants.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.702.1">Building the market data publisher</span></h1>
<p><span class="koboSpan" id="kobo.703.1">The last component in the</span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.704.1"> electronic trading exchange we need to build is the market data publisher, which is how the exchange publishes public market data updates to any market participants that need it. </span><span class="koboSpan" id="kobo.704.2">Revisiting the design of the market data publisher, we present a diagram of how this component communicates with the matching engine and publishes to the market data participants over UDP, </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">as follows.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.706.1"><img alt="Figure 7.2 – Market data publisher and its subcomponents" src="image/B19434_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.707.1">Figure 7.2 – Market data publisher and its subcomponents</span></p>
<p><span class="koboSpan" id="kobo.708.1">We would like to remind you that the purpose and design of the market data publisher were discussed in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.709.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.710.1"> chapter, specifically in the </span><em class="italic"><span class="koboSpan" id="kobo.711.1">Understanding the layout of the electronic trading ecosystem</span></em><span class="koboSpan" id="kobo.712.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.713.1">Understanding how an exchange publishes information to participants</span></em><span class="koboSpan" id="kobo.714.1"> sections. </span><span class="koboSpan" id="kobo.714.2">We would strongly encourage you to revisit those sections to follow along as we build our market data </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">publisher component.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">Let us get started by first understanding how updates are consumed from the matching engine and published by jumping into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.718.1"> class. </span><span class="koboSpan" id="kobo.718.2">All the source code </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.719.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.721.1"> class is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">Chapter7/exchange/market_data/market_data_publisher.h</span></strong><span class="koboSpan" id="kobo.723.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">Chapter7/exchange/market_data/market_data_publisher.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.725.1">source files.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.726.1">Defining the data members in the market data publisher</span></h2>
<p><span class="koboSpan" id="kobo.727.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.729.1"> class</span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.730.1"> has the following</span><a id="_idIndexMarker1080"/> <span class="No-Break"><span class="koboSpan" id="kobo.731.1">important members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.732.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">next_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.734.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">size_t</span></strong><span class="koboSpan" id="kobo.736.1"> type, which represents the sequence number to set on the next outgoing incremental market data message. </span><span class="koboSpan" id="kobo.736.2">We discussed the concepts of incremental and snapshot market data updates in the </span><em class="italic"><span class="koboSpan" id="kobo.737.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.738.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.739.1">Understanding how an exchange publishes information to participants</span></em><span class="koboSpan" id="kobo.740.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.741.1">Building a market participant’s interface to the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.742.1">exchange</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1"> sections.</span></span></li>
<li><span class="koboSpan" id="kobo.744.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">outgoing_md_updates_</span></strong><span class="koboSpan" id="kobo.746.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.748.1"> type, which is a lock-free queue of </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.750.1"> messages. </span><span class="koboSpan" id="kobo.750.2">We discussed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.752.1"> structure in the </span><em class="italic"><span class="koboSpan" id="kobo.753.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.754.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.755.1">Defining the operations and interactions in our matching engine</span></em><span class="koboSpan" id="kobo.756.1"> section. </span><span class="koboSpan" id="kobo.756.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">LFQueue</span></strong><span class="koboSpan" id="kobo.758.1"> is how the matching engine sends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.760.1"> messages that the market data publisher then publishes </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">over UDP.</span></span></li>
<li><span class="koboSpan" id="kobo.762.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">incremental_socket_</span></strong><span class="koboSpan" id="kobo.764.1"> member, which is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">McastSocket</span></strong><span class="koboSpan" id="kobo.766.1"> to be used to publish UDP messages on the incremental </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">multicast stream.</span></span></li>
<li><span class="koboSpan" id="kobo.768.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">snapshot_synthesizer_</span></strong><span class="koboSpan" id="kobo.770.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.772.1"> type, which we will discuss in the next subsection. </span><span class="koboSpan" id="kobo.772.2">This object will be responsible for generating a snapshot of the limit order book from the updates that the matching engine provides and periodically publishing a snapshot of the full order book on the snapshot multicast stream. </span><span class="koboSpan" id="kobo.772.3">This was discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.773.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.774.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.775.1">Understanding how an exchange publishes information to participants</span></em><span class="koboSpan" id="kobo.776.1"> section, specifically in the </span><em class="italic"><span class="koboSpan" id="kobo.777.1">Designing the market data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.778.1">publisher</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1"> subsection.</span></span></li>
<li><span class="koboSpan" id="kobo.780.1">A lock-free queue instance called </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">snapshot_md_updates_</span></strong><span class="koboSpan" id="kobo.782.1">, which will be of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">MDPMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.784.1"> type, which is a lock-free queue containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.786.1"> messages. </span><span class="koboSpan" id="kobo.786.2">This queue is used by the market data publisher thread to publish </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.788.1"> messages that it sends on the incremental stream to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.790.1"> component. </span><span class="koboSpan" id="kobo.790.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">LFQueue</span></strong><span class="koboSpan" id="kobo.792.1"> is necessary since </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.794.1"> runs on a different thread than </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.796.1">, which is primarily so that the snapshot synthesis and publishing process do not slow down the latency-sensitive </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">MarketDataPublisher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1"> component.</span></span></li>
<li><span class="koboSpan" id="kobo.799.1">The last </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.800.1">important member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.802.1"> class is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">run_</span></strong><span class="koboSpan" id="kobo.804.1"> Boolean variable, which is just used to control when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.806.1"> thread is started and</span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.807.1"> stopped. </span><span class="koboSpan" id="kobo.807.2">Since it is accessed from different threads, like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">run_</span></strong><span class="koboSpan" id="kobo.809.1"> variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">OrderServer</span></strong><span class="koboSpan" id="kobo.811.1"> class, it is also marked </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">volatile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.815.1">
#pragma once</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.816.1">
#include &lt;functional&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.817.1">
#include "market_data/snapshot_synthesizer.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.818.1">
namespace Exchange {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.819.1">
  class MarketDataPublisher {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.820.1">
  private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.821.1">
    size_t next_inc_seq_num_ = 1;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.822.1">
    MEMarketUpdateLFQueue *outgoing_md_updates_ = nullptr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.823.1">
    MDPMarketUpdateLFQueue snapshot_md_updates_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.824.1">
    volatile bool run_ = false;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.825.1">
    std::string time_str_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.826.1">
    Logger logger_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.827.1">
    Common::McastSocket incremental_socket_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
    SnapshotSynthesizer *snapshot_synthesizer_ = nullptr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.829.1">
  };</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.830.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.831.1">In the next section, we will see how these data members </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">are initialized.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.833.1">Initializing the market data publisher</span></h2>
<p><span class="koboSpan" id="kobo.834.1">In this subsection, we will </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.835.1">look at how to initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.837.1">, and how to start and stop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.839.1"> component. </span><span class="koboSpan" id="kobo.839.2">First, we will look at the constructor, which is presented as follows. </span><span class="koboSpan" id="kobo.839.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">market_updates</span></strong><span class="koboSpan" id="kobo.841.1"> argument passed to it is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.843.1"> object, which the matching engine will publish market updates on. </span><span class="koboSpan" id="kobo.843.2">The constructor also receives the network interface and two sets of IPs and ports – one for the incremental market data stream and one for the snapshot market data stream. </span><span class="koboSpan" id="kobo.843.3">In the constructor, it initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">outgoing_md_updates_</span></strong><span class="koboSpan" id="kobo.845.1"> member with the argument passed in the constructor and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">snapshot_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.847.1">LFQueue</span></strong><span class="koboSpan" id="kobo.848.1"> to be of the size </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">ME_MAX_MARKET_UPDATES</span></strong><span class="koboSpan" id="kobo.850.1">, which we first defined back in the </span><em class="italic"><span class="koboSpan" id="kobo.851.1">Designing the C++ matching engine</span></em><span class="koboSpan" id="kobo.852.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.853.1">Defining the operations and interactions in our matching engine</span></em> <em class="italic"><span class="koboSpan" id="kobo.854.1">section</span></em><span class="koboSpan" id="kobo.855.1">, and is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">common/types.h</span></strong><span class="koboSpan" id="kobo.857.1"> source file. </span><span class="koboSpan" id="kobo.857.2">It also initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">logger_</span></strong><span class="koboSpan" id="kobo.859.1"> object with a log file for this class and initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">incremental_socket_</span></strong><span class="koboSpan" id="kobo.861.1"> variable with the incremental IP and port provided in the constructor. </span><span class="koboSpan" id="kobo.861.2">Finally, it creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.863.1"> object and passes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">snapshot_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.865.1">LFQueue</span></strong><span class="koboSpan" id="kobo.866.1"> and the snapshot multicast </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">stream information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.868.1">
#include "market_data_publisher.h"
namespace Exchange {  MarketDataPublisher::MarketDataPublisher(MEMarketUpdateLFQueue
   *market_updates, const std::string &amp;iface,
                                           const std::string 
                                           &amp;snapshot_ip, int snapshot_
                                           port,
                                           const std::string
                                           &amp;incremental_ip, int 
                                           incremental_port)
      : outgoing_md_updates_(market_updates), snapshot_md_updates_(ME_
      MAX_MARKET_UPDATES),
        run_(false), logger_("exchange_market_data_publisher.log"),
        incremental_socket_(logger_) {
    ASSERT(incremental_socket_.init(incremental_ip, iface,
    incremental_port, /*is_listening*/ false) &gt;= 0,
           "Unable to create incremental mcast socket. </span><span class="koboSpan" id="kobo.868.2">error:" +
           std::string(std::strerror(errno)));
    snapshot_synthesizer_ = new SnapshotSynthesizer(&amp;snapshot_md_
    updates_, iface, snapshot_ip, snapshot_port);
  }</span></pre>
<p><span class="koboSpan" id="kobo.869.1">We also present a </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">start()</span></strong><span class="koboSpan" id="kobo.871.1"> method, shown </span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.872.1">as follows, which is similar in functionality to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">start()</span></strong><span class="koboSpan" id="kobo.874.1"> method we saw for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">OrderServer</span></strong><span class="koboSpan" id="kobo.876.1"> class. </span><span class="koboSpan" id="kobo.876.2">First, it sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">run_</span></strong><span class="koboSpan" id="kobo.878.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">true</span></strong><span class="koboSpan" id="kobo.880.1">, then creates and launches a new thread and assigns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">run()</span></strong><span class="koboSpan" id="kobo.882.1"> method to that thread, which will be our main </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">run</span></strong><span class="koboSpan" id="kobo.884.1"> loop for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.886.1"> component. </span><span class="koboSpan" id="kobo.886.2">It also calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">start()</span></strong><span class="koboSpan" id="kobo.888.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.890.1"> object so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.892.1"> thread can also </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">be launched:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
    auto start() {
      run_ = true;
      ASSERT(Common::createAndStartThread(-1, "Exchange/
      MarketDataPublisher", [this]() { run(); }) != nullptr, "Failed
      to start MarketData thread.");
      snapshot_synthesizer_-&gt;start();
    }</span></pre>
<p><span class="koboSpan" id="kobo.895.1">The destructor is quite self-explanatory; it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">stop()</span></strong><span class="koboSpan" id="kobo.897.1"> method to stop the running </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.899.1"> thread, then waits a short amount of time to let the thread finish any pending tasks and deletes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.901.1"> object. </span><span class="koboSpan" id="kobo.901.2">We will see the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">stop()</span></strong><span class="koboSpan" id="kobo.903.1"> method right after the destructor, but it should not be too difficult to </span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.904.1">guess what that method </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.906.1">
    ~MarketDataPublisher() {
      stop();
      using namespace std::literals::chrono_literals;
      std::this_thread::sleep_for(5s);
      delete snapshot_synthesizer_;
      snapshot_synthesizer_ = nullptr;
    }</span></pre>
<p><span class="koboSpan" id="kobo.907.1">Finally, as mentioned before, we present the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">stop()</span></strong><span class="koboSpan" id="kobo.909.1"> method. </span><span class="koboSpan" id="kobo.909.2">This method simply sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">run_</span></strong><span class="koboSpan" id="kobo.911.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">false</span></strong><span class="koboSpan" id="kobo.913.1"> and instructs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.915.1"> thread to stop </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
    auto stop() -&gt; void {
      run_ = false;
      snapshot_synthesizer_-&gt;stop();
    }</span></pre>
<p><span class="koboSpan" id="kobo.918.1">Now that we have seen how to initialize this class, we will look at how </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.920.1"> will publish order book updates, first the updates on the incremental updatesmarket data channel first and then the market updates on the snapshot updates secondmarket </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">data channel</span></span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.923.1">Publishing order book updates</span></h2>
<p><span class="koboSpan" id="kobo.924.1">The main </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">run()</span></strong><span class="koboSpan" id="kobo.926.1"> loop in </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.928.1"> does a couple of important things, which we will discuss </span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.929.1">here. </span><span class="koboSpan" id="kobo.929.2">First, it drains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">outgoing_md_updates_</span></strong><span class="koboSpan" id="kobo.931.1"> queue by reading any new </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">MEMarketDataUpdates</span></strong><span class="koboSpan" id="kobo.933.1"> published by the matching engine. </span><span class="koboSpan" id="kobo.933.2">This part of the code block is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.935.1">
  auto MarketDataPublisher::run() noexcept -&gt; void {
    logger_.log("%:% %() %\n", __FILE__, __LINE__, __FUNCTION__,
    Common::getCurrentTimeStr(&amp;time_str_));
    while (run_) {
      for (auto market_update = outgoing_md_updates_-&gt;getNextToRead();
           outgoing_md_updates_-&gt;size() &amp;&amp; market_update; market_
           update = outgoing_md_updates_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Sending seq:% %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_), next_inc_
        seq_num_,
                    market_update-&gt;toString().c_str());</span></pre>
<p><span class="koboSpan" id="kobo.936.1">Once it has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.938.1"> message from the matching engine, it will proceed to write it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">incremental_socket_</span></strong><span class="koboSpan" id="kobo.940.1"> UDP socket. </span><span class="koboSpan" id="kobo.940.2">But it needs to write out the message in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.942.1"> format, which is just a sequence number followed by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.944.1"> message. </span><span class="koboSpan" id="kobo.944.2">As we saw with </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">OrderServer</span></strong><span class="koboSpan" id="kobo.946.1">, it will achieve this here by first writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">next_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.948.1">, which is the next incremental sequence number to be sent out on the incremental stream, and then write </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.950.1">, which it received from the matching engine. </span><span class="koboSpan" id="kobo.950.2">This logic is shown in the following code block, along with the line to increment the read index in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">LFQueue</span></strong><span class="koboSpan" id="kobo.952.1"> that it just </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">read from:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.954.1">
        incremental_socket_.send(&amp;next_inc_seq_num_, sizeof(next_inc_
        seq_num_));
        incremental_socket_.send(market_update,
        sizeof(MEMarketUpdate));
        outgoing_md_updates_-&gt;updateReadIndex();</span></pre>
<p><span class="koboSpan" id="kobo.955.1">It needs to </span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.956.1">do one additional step here, which is to write the same incremental update it wrote to the socket to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">snapshot_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.958.1">LFQueue</span></strong><span class="koboSpan" id="kobo.959.1"> to inform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.961.1"> component about the new incremental update from the matching engine that was sent to the clients. </span><span class="koboSpan" id="kobo.961.2">That code block is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.963.1">
        auto next_write = snapshot_md_updates_.getNextToWriteTo();
        next_write-&gt;seq_num_ = next_inc_seq_num_;
        next_write-&gt;me_market_update_ = *market_update;
        snapshot_md_updates_.updateWriteIndex();</span></pre>
<p><span class="koboSpan" id="kobo.964.1">Finally, it increments the incremental stream sequence number tracker for the next message that will be sent out and calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.966.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">incremental_socket_</span></strong><span class="koboSpan" id="kobo.968.1"> so that the messages get put on </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">the wire:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.970.1">
        ++next_inc_seq_num_;
      }
      incremental_socket_.sendAndRecv();
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.971.1">That concludes all the tasks we need to perform to consume updates from the matching engine and generate the incremental market update multicast stream. </span><span class="koboSpan" id="kobo.971.2">In the next subsection, we will take care of the final key step in the market data publisher, which is synthesizing </span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.972.1">order book snapshots and publishing them periodically on the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">multicast stream.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.974.1">Synthesizing and publishing snapshots</span></h2>
<p><span class="koboSpan" id="kobo.975.1">This section </span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.976.1">will be dedicated to the design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.978.1"> class, which consumes incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">MDPMarketDataUpdates</span></strong><span class="koboSpan" id="kobo.980.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.982.1"> thread, synthesizes</span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.983.1"> a full snapshot of the order book, and periodically publishes the full book snapshot on the snapshot multicast stream. </span><span class="koboSpan" id="kobo.983.2">All the source code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.985.1"> can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">Chapter7/exchange/market_data/snapshot_synthesizer.h</span></strong><span class="koboSpan" id="kobo.987.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">Chapter7/exchange/market_data/snapshot_synthesizer.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.989.1">source files.</span></span></p>
<h3><span class="koboSpan" id="kobo.990.1">Defining the data members in the snapshot synthesizer</span></h3>
<p><span class="koboSpan" id="kobo.991.1">Let us first define the data </span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.992.1">members in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.994.1"> class. </span><span class="koboSpan" id="kobo.994.2">The </span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.995.1">important ones are described </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.997.1">First, </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">snapshot_md_updates_</span></strong><span class="koboSpan" id="kobo.999.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">MDPMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.1001.1"> type, which is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1003.1"> uses to publish incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">MDPMarketUpdates</span></strong><span class="koboSpan" id="kobo.1005.1"> to this component, which we saw in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">previous section.</span></span></li>
<li><span class="koboSpan" id="kobo.1007.1">It also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">snapshot_socket_</span></strong><span class="koboSpan" id="kobo.1009.1"> variable, which is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">McastSocket</span></strong><span class="koboSpan" id="kobo.1011.1"> to be used to publish snapshot market data updates to the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">multicast stream.</span></span></li>
<li><span class="koboSpan" id="kobo.1013.1">One of the most important data members is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">ticker_orders_</span></strong><span class="koboSpan" id="kobo.1015.1"> variable, which is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">std::array</span></strong><span class="koboSpan" id="kobo.1017.1"> of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.1019.1"> to represent the snapshot of the book for each trading instrument. </span><span class="koboSpan" id="kobo.1019.2">Each element of this array is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">std::array</span></strong><span class="koboSpan" id="kobo.1021.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1023.1"> pointers and a maximum size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">ME_MAX_ORDER_IDS</span></strong><span class="koboSpan" id="kobo.1025.1"> to represent a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">OrderId</span></strong><span class="koboSpan" id="kobo.1027.1"> to the order corresponding to that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">OrderId</span></strong><span class="koboSpan" id="kobo.1029.1">. </span><span class="koboSpan" id="kobo.1029.2">As we have done before, we use the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">std::array</span></strong><span class="koboSpan" id="kobo.1031.1"> as a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">TickerId</span></strong><span class="koboSpan" id="kobo.1033.1"> to the snapshot of the limit order book. </span><span class="koboSpan" id="kobo.1033.2">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">std::array</span></strong><span class="koboSpan" id="kobo.1035.1"> is also a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">OrderId</span></strong><span class="koboSpan" id="kobo.1037.1"> to the order information. </span><span class="koboSpan" id="kobo.1037.2">We will also have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">order_pool_</span></strong><span class="koboSpan" id="kobo.1039.1"> data member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">MemPool</span></strong><span class="koboSpan" id="kobo.1041.1"> type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1043.1"> objects. </span><span class="koboSpan" id="kobo.1043.2">This memory pool is what we will use to allocate and deallocate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1045.1"> objects from as we update the order book snapshot in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">ticker_orders_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1"> container.</span></span></li>
<li><span class="koboSpan" id="kobo.1048.1">We have two variables to track information about the last incremental market data update that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1050.1"> has processed. </span><span class="koboSpan" id="kobo.1050.2">The first one is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">last_inc_seq_num_</span></strong><span class="koboSpan" id="kobo.1052.1"> variable to track the sequence number on the last incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1054.1"> it has received. </span><span class="koboSpan" id="kobo.1054.2">The second one is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">last_snapshot_time_</span></strong><span class="koboSpan" id="kobo.1056.1"> variable used to track when the last snapshot was published over UDP since this component will only periodically publish the full snapshot of all </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">the books.</span></span></li>
<li><span class="koboSpan" id="kobo.1058.1">There is also a </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.1059.1">Boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">run_</span></strong><span class="koboSpan" id="kobo.1061.1"> variable, which </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.1062.1">serves a similar purpose as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">run_</span></strong><span class="koboSpan" id="kobo.1064.1"> variables in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1066.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1068.1"> components we built before. </span><span class="koboSpan" id="kobo.1068.2">This will be used to start and stop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1070.1"> thread and will be marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">volatile</span></strong><span class="koboSpan" id="kobo.1072.1"> since it will be accessed from </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">multiple threads:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
#pragma once</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1075.1">
#include "common/types.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
#include "common/thread_utils.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1077.1">
#include "common/lf_queue.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1078.1">
#include "common/macros.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1079.1">
#include "common/mcast_socket.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
#include "common/mem_pool.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1081.1">
#include "common/logging.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1082.1">
#include "market_data/market_update.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1083.1">
#include "matcher/me_order.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1084.1">
using namespace Common;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1085.1">
namespace Exchange {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1086.1">
  class SnapshotSynthesizer {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1087.1">
  private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1088.1">
    MDPMarketUpdateLFQueue *snapshot_md_updates_ = nullptr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1089.1">
    Logger logger_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1090.1">
    volatile bool run_ = false;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1091.1">
    std::string time_str_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1092.1">
    McastSocket snapshot_socket_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1093.1">
    std::array&lt;std::array&lt;MEMarketUpdate *, ME_MAX_ORDER_IDS&gt;,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1094.1">
    ME_MAX_TICKERS&gt; ticker_orders_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1095.1">
    size_t last_inc_seq_num_ = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1096.1">
    Nanos last_snapshot_time_ = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1097.1">
    MemPool&lt;MEMarketUpdate&gt; order_pool_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1098.1">
  };</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1099.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.1100.1">In the next subsection, we will see how these variables are initialized as we look at the initialization of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">SnapshotSynthesizer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1"> class.</span></span></p>
<h3><span class="koboSpan" id="kobo.1103.1">Initializing the snapshot synthesizer</span></h3>
<p><span class="koboSpan" id="kobo.1104.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1106.1"> constructor</span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.1107.1"> takes an argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">MDPMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.1109.1"> type passed to it from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1111.1"> component. </span><span class="koboSpan" id="kobo.1111.2">It also receives the network interface name and the snapshot IP and port to represent the multicast stream. </span><span class="koboSpan" id="kobo.1111.3">The constructor initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">snapshot_md_updates_</span></strong><span class="koboSpan" id="kobo.1113.1"> data member from the argument passed to it and initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">logger_</span></strong><span class="koboSpan" id="kobo.1115.1"> with a new filename. </span><span class="koboSpan" id="kobo.1115.2">It initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">MEMarketUpdate</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">MemPool</span></strong><span class="koboSpan" id="kobo.1118.1"> to be of the size </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">ME_MAX_ORDER_IDS</span></strong><span class="koboSpan" id="kobo.1120.1">. </span><span class="koboSpan" id="kobo.1120.2">It also initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">snapshot_socket_</span></strong><span class="koboSpan" id="kobo.1122.1"> and configures it to publish messages on the snapshot multicast IP and port on the provided </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">network interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1124.1">
#include "snapshot_synthesizer.h"
namespace Exchange {
  SnapshotSynthesizer::SnapshotSynthesizer(MDPMarketUpdateLFQueue
  *market_updates, const std::string &amp;iface,
                                           const std::string &amp;snapshot_
                                           ip, int snapshot_port)
      : snapshot_md_updates_(market_updates), logger_("exchange_
      snapshot_synthesizer.log"), snapshot_socket_(logger_), order_
      pool_(ME_MAX_ORDER_IDS) {
    ASSERT(snapshot_socket_.init(snapshot_ip, iface, snapshot_port,
    /*is_listening*/ false) &gt;= 0,
           "Unable to create snapshot mcast socket. </span><span class="koboSpan" id="kobo.1124.2">error:" +
           std::string(std::strerror(errno)));
  }</span></pre>
<p><span class="koboSpan" id="kobo.1125.1">We also </span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.1126.1">add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">start()</span></strong><span class="koboSpan" id="kobo.1128.1"> method here in the same way as we did with our other classes before. </span><span class="koboSpan" id="kobo.1128.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">start()</span></strong><span class="koboSpan" id="kobo.1130.1"> method sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">run_</span></strong><span class="koboSpan" id="kobo.1132.1"> flag to true, creates and launches a thread, and assigns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">run()</span></strong><span class="koboSpan" id="kobo.1134.1"> method to </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">the thread:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
  void SnapshotSynthesizer::start() {
    run_ = true;
    ASSERT(Common::createAndStartThread(-1, "Exchange/
    SnapshotSynthesizer", [this]() { run(); }) != nullptr,
           "Failed to start SnapshotSynthesizer thread.");
  }</span></pre>
<p><span class="koboSpan" id="kobo.1137.1">The destructor for this class is extremely simple; it just calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">stop()</span></strong><span class="koboSpan" id="kobo.1139.1"> method. </span><span class="koboSpan" id="kobo.1139.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">stop()</span></strong><span class="koboSpan" id="kobo.1141.1"> method is also extremely simple and just sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">run_</span></strong><span class="koboSpan" id="kobo.1143.1"> flag to false so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">run()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1145.1">method exits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
  SnapshotSynthesizer::~SnapshotSynthesizer() {
    stop();
  }
  void SnapshotSynthesizer::stop() {
    run_ = false;
  }</span></pre>
<p><span class="koboSpan" id="kobo.1147.1">Next, we will look at the important pieces of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1149.1">, which will synthesize the order book snapshots and publish the </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">snapshots periodically.</span></span></p>
<h3><span class="koboSpan" id="kobo.1151.1">Synthesizing the snapshot of the order book</span></h3>
<p><span class="koboSpan" id="kobo.1152.1">The process of </span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.1153.1">synthesizing the snapshot of the order books for the different trading instruments is like building </span><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">OrderBook</span></strong><span class="koboSpan" id="kobo.1155.1">. </span><span class="koboSpan" id="kobo.1155.2">However, the difference here is that the snapshot synthesis process only needs to maintain the last state of the live orders, so it is a simpler container. </span><span class="koboSpan" id="kobo.1155.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">addToSnapshot()</span></strong><span class="koboSpan" id="kobo.1157.1"> method we will build next receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1159.1"> message every time there is a new incremental market data update provided to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1161.1">. </span><span class="koboSpan" id="kobo.1161.2">We will break this method up into several code blocks so that it is easier </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">to follow.</span></span></p>
<p><span class="koboSpan" id="kobo.1163.1">In the first code block, we extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1165.1"> piece of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1167.1"> message and store it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">me_market_update</span></strong><span class="koboSpan" id="kobo.1169.1"> variable. </span><span class="koboSpan" id="kobo.1169.2">It also finds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">std::array</span></strong><span class="koboSpan" id="kobo.1171.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1173.1"> messages for the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">TickerId</span></strong><span class="koboSpan" id="kobo.1175.1"> for this instrument from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">ticker_orders_ std::array</span></strong><span class="koboSpan" id="kobo.1177.1"> hash map. </span><span class="koboSpan" id="kobo.1177.2">We then have a switch case on the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">MarketUpdateType</span></strong><span class="koboSpan" id="kobo.1179.1"> and then handle each of those cases individually. </span><span class="koboSpan" id="kobo.1179.2">Before we look at each of the cases under the switch case, let us present</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.1180.1"> the initial code block in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">addToSnapshot()</span></strong><span class="koboSpan" id="kobo.1182.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">we described:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1184.1">
  auto SnapshotSynthesizer::addToSnapshot(const MDPMarketUpdate
  *market_update) {
    const auto &amp;me_market_update = market_update-&gt;me_market_update_;
    auto *orders = &amp;ticker_orders_.at(me_market_update.ticker_id_);
    switch (me_market_update.type_) {</span></pre>
<p><span class="koboSpan" id="kobo.1185.1">Now, we will show the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1187.1"> case in the switch case. </span><span class="koboSpan" id="kobo.1187.2">To handle a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1189.1"> message, we simply insert it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">MEMarketUpdate</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">std::array</span></strong><span class="koboSpan" id="kobo.1192.1"> at the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">OrderId</span></strong><span class="koboSpan" id="kobo.1194.1"> location. </span><span class="koboSpan" id="kobo.1194.2">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1196.1"> message by allocating it from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">order_pool_</span></strong><span class="koboSpan" id="kobo.1198.1"> memory pool using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">allocate()</span></strong><span class="koboSpan" id="kobo.1200.1"> call and passing it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1202.1"> object to copy the </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">fields from:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1204.1">
      case MarketUpdateType::ADD: {
        auto order = orders-&gt;at(me_market_update.order_id_);
        ASSERT(order == nullptr, "Received:" + me_market_update.
</span><span class="koboSpan" id="kobo.1204.2">        toString() + " but order already exists:" + (order ? </span><span class="koboSpan" id="kobo.1204.3">order-
        &gt;toString() : ""));
        orders-&gt;at(me_market_update.order_id_) = order_pool_.
</span><span class="koboSpan" id="kobo.1204.4">        allocate(me_market_update);
      }
        break;</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">MarketUpdateType::MODIFY</span></strong><span class="koboSpan" id="kobo.1206.1"> is handled</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.1207.1"> similarly to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1209.1">. </span><span class="koboSpan" id="kobo.1209.2">The minor difference here is that we just update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">qty_</span></strong><span class="koboSpan" id="kobo.1211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">price_</span></strong><span class="koboSpan" id="kobo.1213.1"> fields and leave the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">type_</span></strong><span class="koboSpan" id="kobo.1215.1"> field on the entry </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">as is:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1217.1">
      case MarketUpdateType::MODIFY: {
        auto order = orders-&gt;at(me_market_update.order_id_);
        ASSERT(order != nullptr, "Received:" + me_market_update.
</span><span class="koboSpan" id="kobo.1217.2">        toString() + " but order does not exist.");
        ASSERT(order-&gt;order_id_ == me_market_update.order_id_,
        "Expecting existing order to match new one.");
        ASSERT(order-&gt;side_ == me_market_update.side_, "Expecting
        existing order to match new one.");
        order-&gt;qty_ = me_market_update.qty_;
        order-&gt;price_ = me_market_update.price_;
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1218.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">MarketUpdateType::CANCEL</span></strong><span class="koboSpan" id="kobo.1220.1"> type does the opposite of what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1222.1"> did. </span><span class="koboSpan" id="kobo.1222.2">Here, we find </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1224.1"> in the hash map and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">deallocate()</span></strong><span class="koboSpan" id="kobo.1226.1"> on it. </span><span class="koboSpan" id="kobo.1226.2">We also set the entry in the hash map style </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">std::array</span></strong><span class="koboSpan" id="kobo.1228.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">nullptr</span></strong><span class="koboSpan" id="kobo.1230.1"> to mark it as canceled or a </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">dead order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1232.1">
      case MarketUpdateType::CANCEL: {
        auto order = orders-&gt;at(me_market_update.order_id_);
        ASSERT(order != nullptr, "Received:" + me_market_update.
</span><span class="koboSpan" id="kobo.1232.2">        toString() + " but order does not exist.");
        ASSERT(order-&gt;order_id_ == me_market_update.order_id_,
        "Expecting existing order to match new one.");
        ASSERT(order-&gt;side_ == me_market_update.side_, "Expecting
        existing order to match new one.");
        order_pool_.deallocate(order);
        orders-&gt;at(me_market_update.order_id_) = nullptr;
      }
        break;</span></pre>
<p><span class="koboSpan" id="kobo.1233.1">We do not need to do</span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.1234.1"> anything with the other enumeration values, so we ignore them. </span><span class="koboSpan" id="kobo.1234.2">We just update the last sequence number we have seen on the incremental market data stream, which is stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">last_inc_seq_num_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1236.1">data members:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1237.1">
      case MarketUpdateType::SNAPSHOT_START:
      case MarketUpdateType::CLEAR:
      case MarketUpdateType::SNAPSHOT_END:
      case MarketUpdateType::TRADE:
      case MarketUpdateType::INVALID:
        break;
    }
    ASSERT(market_update-&gt;seq_num_ == last_inc_seq_num_ + 1, "Expected
    incremental seq_nums to increase.");
    last_inc_seq_num_ = market_update-&gt;seq_num_;
  }</span></pre>
<p><span class="koboSpan" id="kobo.1238.1">This concludes the </span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.1239.1">code to synthesize and update the order book snapshot from the incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1241.1"> messages. </span><span class="koboSpan" id="kobo.1241.2">Next, we will look at how the full snapshot stream is generated </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">and published.</span></span></p>
<h3><span class="koboSpan" id="kobo.1243.1">Publishing the snapshots</span></h3>
<p><span class="koboSpan" id="kobo.1244.1">The next method – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">publishSnapshot()</span></strong><span class="koboSpan" id="kobo.1246.1"> – is called whenever we want to publish a complete snapshot of the</span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.1247.1"> current state of the order book. </span><span class="koboSpan" id="kobo.1247.2">Before we look at the code to publish the snapshot messages, let us first try to understand the format and content of a snapshot message containing the full state of the book for multiple instruments. </span><span class="koboSpan" id="kobo.1247.3">The format of a full snapshot message looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1249.1">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1251.1"> message is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">MarketUpdateType::SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.1253.1"> type with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">seq_num_ = 0</span></strong><span class="koboSpan" id="kobo.1255.1"> to mark the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">snapshot messages.</span></span></li>
<li><span class="koboSpan" id="kobo.1257.1">Then, for each instrument, we publish </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">the following:</span></span><ol><li><span class="koboSpan" id="kobo.1259.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1261.1"> message of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">MarketUpdateType::CLEAR</span></strong><span class="koboSpan" id="kobo.1263.1"> type to instruct the client to clear their order book before applying the messages </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">that follow</span></span></li><li><span class="koboSpan" id="kobo.1265.1">For each order that exists in the snapshot for this instrument, we publish a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1267.1"> message with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1269.1"> till we have published the information for all </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">the orders</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1271.1">Finally, we publish a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1273.1"> message of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">MarketUpdateType::SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.1275.1"> type to mark the end of the snapshot messages. </span><span class="koboSpan" id="kobo.1275.2">One thing to note is that for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.1277.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.1279.1"> messages, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">OrderId</span></strong><span class="koboSpan" id="kobo.1281.1"> value to be the last incremental sequence number that was used to construct this snapshot. </span><span class="koboSpan" id="kobo.1281.2">The market participants will use this sequence number to synchronize the snapshot market data stream with the incremental market </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">data stream.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1283.1">This design is </span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.1284.1">represented in the following diagram, with a snapshot containing data for </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">three instruments.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.1286.1"><img alt="Figure 7.3 – Diagram describing the layout of our market data snapshot messages" src="image/B19434_07_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1287.1">Figure 7.3 – Diagram describing the layout of our market data snapshot messages</span></p>
<p><span class="koboSpan" id="kobo.1288.1">With that format in mind, let us look at the code to synthesize and publish the snapshot message format we described previously. </span><span class="koboSpan" id="kobo.1288.2">First, we publish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">MarketUpdateType::SNAPSHOT_START</span></strong><span class="koboSpan" id="kobo.1290.1"> message, </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1292.1">
  auto SnapshotSynthesizer::publishSnapshot() {
    size_t snapshot_size = 0;
    const MDPMarketUpdate start_market_update{snapshot_size++,
    {MarketUpdateType::SNAPSHOT_START, last_inc_seq_num_}};
    logger_.log("%:% %() % %\n", __FILE__, __LINE__, __FUNCTION__,
    getCurrentTimeStr(&amp;time_str_), start_market_update.toString());
    snapshot_socket_.send(&amp;start_market_update,
    sizeof(MDPMarketUpdate));</span></pre>
<p><span class="koboSpan" id="kobo.1293.1">Then, we iterate through all the</span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.1294.1"> instruments that we will publish the snapshots for. </span><span class="koboSpan" id="kobo.1294.2">The first thing we do is publish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1296.1"> message of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">MarketUpdateType::CLEAR</span></strong><span class="koboSpan" id="kobo.1298.1"> type for </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">that instrument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1300.1">
    for (size_t ticker_id = 0; ticker_id &lt; ticker_orders_.size();
    ++ticker_id) {
      const auto &amp;orders = ticker_orders_.at(ticker_id);
      MEMarketUpdate me_market_update;
      me_market_update.type_ = MarketUpdateType::CLEAR;
      me_market_update.ticker_id_ = ticker_id;
      const MDPMarketUpdate clear_market_update{snapshot_size++, me_
      market_update};
      logger_.log("%:% %() % %\n", __FILE__, __LINE__, __FUNCTION__,
      getCurrentTimeStr(&amp;time_str_), clear_market_update.toString());
      snapshot_socket_.send(&amp;clear_market_update,
      sizeof(MDPMarketUpdate));</span></pre>
<p><span class="koboSpan" id="kobo.1301.1">Then, we iterate through all the orders for this trading instrument and check for live orders – entries that do not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">nullptr</span></strong><span class="koboSpan" id="kobo.1303.1"> values. </span><span class="koboSpan" id="kobo.1303.2">For each valid order, we publish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1305.1"> message for that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">OrderId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1307.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">MarketUpdateType::ADD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1310.1">
      for (const auto order: orders) {
        if (order) {
          const MDPMarketUpdate market_update{snapshot_size++, *order};
          logger_.log("%:% %() % %\n", __FILE__, __LINE__, __
          FUNCTION__, getCurrentTimeStr(&amp;time_str_), market_update.
</span><span class="koboSpan" id="kobo.1310.2">          toString());
          snapshot_socket_.send(&amp;market_update, sizeof(MDPMarketUpdate));
          snapshot_socket_.sendAndRecv();
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.1311.1">Finally, we publish</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.1312.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1314.1"> message with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">MarketUpdateType::SNAPSHOT_END</span></strong><span class="koboSpan" id="kobo.1316.1"> type to signify the end of the snapshot messages </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">this round:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1318.1">
    const MDPMarketUpdate end_market_update{snapshot_size++, {MarketUpdateType::SNAPSHOT_END, last_inc_seq_num_}};
    logger_.log("%:% %() % %\n", __FILE__, __LINE__, __FUNCTION__,
    getCurrentTimeStr(&amp;time_str_), end_market_update.toString());
    snapshot_socket_.send(&amp;end_market_update,
    sizeof(MDPMarketUpdate));
    snapshot_socket_.sendAndRecv();
    logger_.log("%:% %() % Published snapshot of % orders.\n",
    __FILE__, __LINE__, __FUNCTION__, getCurrentTimeStr(&amp;time_str_),
    snapshot_size - 1);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1319.1">That concludes the design of the snapshot stream and the code to publish it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">publishSnapshot()</span></strong><span class="koboSpan" id="kobo.1321.1"> method. </span><span class="koboSpan" id="kobo.1321.2">In the next subsection, we will finish our discussion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1323.1"> component in the market data publisher infrastructure by implementing the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">run()</span></strong><span class="koboSpan" id="kobo.1325.1"> loop that ties </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">everything together.</span></span></p>
<h3><span class="koboSpan" id="kobo.1327.1">Running the main loop</span></h3>
<p><span class="koboSpan" id="kobo.1328.1">Remember </span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.1329.1">that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1331.1"> runs on its own thread separate from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1333.1"> thread to not cause latencies on the component that publishes the incremental market data stream. </span><span class="koboSpan" id="kobo.1333.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">run()</span></strong><span class="koboSpan" id="kobo.1335.1"> method is the method assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1337.1"> thread. </span><span class="koboSpan" id="kobo.1337.2">The only task it performs is checking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">snapshot_md_updates_</span></strong><span class="koboSpan" id="kobo.1339.1"> lock-free queue for new entries, which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1341.1"> sends incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1343.1"> messages on. </span><span class="koboSpan" id="kobo.1343.2">For each incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1345.1"> message it reads, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">addToSnapshot()</span></strong><span class="koboSpan" id="kobo.1347.1"> method we built earlier. </span><span class="koboSpan" id="kobo.1347.2">Additionally, it checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">last_snapshot_time_</span></strong><span class="koboSpan" id="kobo.1349.1"> variable against the current time obtained from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">getCurrentTime()</span></strong><span class="koboSpan" id="kobo.1351.1"> to see whether a minute has elapsed. </span><span class="koboSpan" id="kobo.1351.2">If at least a minute has elapsed since the last time a snapshot was published, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">publishSnapshot()</span></strong><span class="koboSpan" id="kobo.1353.1"> method to publish a new snapshot. </span><span class="koboSpan" id="kobo.1353.2">It also remembers the current time as the last time a full snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">was published:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1355.1">
  void SnapshotSynthesizer::run() {
    logger_.log("%:% %() %\n", __FILE__, __LINE__, __FUNCTION__,
    getCurrentTimeStr(&amp;time_str_));
    while (run_) {
      for (auto market_update = snapshot_md_updates_-&gt;getNextToRead();
      snapshot_md_updates_-&gt;size() &amp;&amp; market_update; market_update =
      snapshot_md_updates_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Processing %\n", __FILE__, __LINE__,
        __FUNCTION__, getCurrentTimeStr(&amp;time_str_),
                    market_update-&gt;toString().c_str());
        addToSnapshot(market_update);
        snapshot_md_updates_-&gt;updateReadIndex();
      }
      if (getCurrentNanos() - last_snapshot_time_ &gt; 60 * NANOS_TO_
      SECS) {
        last_snapshot_time_ = getCurrentNanos();
        publishSnapshot();
      }
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1356.1">This concludes the</span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.1357.1"> design and implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1359.1"> as well as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1361.1"> component and our complete electronic trading exchange infrastructure. </span><span class="koboSpan" id="kobo.1361.2">In the next section, we will build the main electronic exchange application, which will tie together all the components we have built so far on the side of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">electronic exchange.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.1363.1">Building the main exchange application</span></h1>
<p><span class="koboSpan" id="kobo.1364.1">In this final section of the chapter, as </span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.1365.1">well as the final section of the electronic trading exchange discussion, we will build the main exchange application. </span><span class="koboSpan" id="kobo.1365.2">This will be a standalone binary application that will run an order gateway server, the matching engine, and the market data publisher and perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1367.1">The order gateway server accepts client connections and </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">client requests.</span></span></li>
<li><span class="koboSpan" id="kobo.1369.1">The matching engine builds the limit </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">order book.</span></span></li>
<li><span class="koboSpan" id="kobo.1371.1">The matching engine also performs matching between </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">client orders.</span></span></li>
<li><span class="koboSpan" id="kobo.1373.1">The matching engine and the order gateway server publish </span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">client responses.</span></span></li>
<li><span class="koboSpan" id="kobo.1375.1">The matching engine and the market data publisher publish incremental market data updates in response to </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">client requests.</span></span></li>
<li><span class="koboSpan" id="kobo.1377.1">The market data publisher also synthesizes and periodically publishes a full snapshot of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">order book.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1379.1">The complete </span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.1380.1">design is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">following diagram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.1382.1"><img alt="Figure 7.4 – The final trading exchange application and all its components" src="image/B19434_07_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1383.1">Figure 7.4 – The final trading exchange application and all its components</span></p>
<p><span class="koboSpan" id="kobo.1384.1">The code for this exchange application is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">Chapter7/exchange/exchange_main.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1386.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.1387.1">We will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">Logger</span></strong><span class="koboSpan" id="kobo.1389.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1391.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1393.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1395.1"> instance in the global scope. </span><span class="koboSpan" id="kobo.1395.2">We will also create a signal handling function since this application will be killed when a UNIX signal is sent to it. </span><span class="koboSpan" id="kobo.1395.3">The signal handler cleans up the components </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">and exits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1397.1">
#include &lt;csignal&gt;
#include "matcher/matching_engine.h"
#include "market_data/market_data_publisher.h"
#include "order_server/order_server.h"
Common::Logger *logger = nullptr;
Exchange::MatchingEngine *matching_engine = nullptr;
Exchange::MarketDataPublisher *market_data_publisher = nullptr;
Exchange::OrderServer *order_server = nullptr;
void signal_handler(int) {
  using namespace std::literals::chrono_literals;
  std::this_thread::sleep_for(10s);
  delete logger;
  logger = nullptr;
  delete matching_engine;
  matching_engine = nullptr;
  delete market_data_publisher;
  market_data_publisher = nullptr;
  delete order_server;
  order_server = nullptr;
  std::this_thread::sleep_for(10s);
  exit(EXIT_SUCCESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.1398.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">main()</span></strong><span class="koboSpan" id="kobo.1400.1"> function</span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.1401.1"> initializes the logger object, installs the signal handler, and sets up three lock-free queues – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">client_requests</span></strong><span class="koboSpan" id="kobo.1403.1">, of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.1405.1"> type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">client_responses</span></strong><span class="koboSpan" id="kobo.1407.1">, of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.1409.1"> type, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">market_updates</span></strong><span class="koboSpan" id="kobo.1411.1">, of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.1413.1"> type – to facilitate communication between the three </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">major components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1415.1">
int main(int, char **) {
  logger = new Common::Logger("exchange_main.log");
  std::signal(SIGINT, signal_handler);
  const int sleep_time = 100 * 1000;
  Exchange::ClientRequestLFQueue client_requests(ME_MAX_CLIENT_
  UPDATES);
  Exchange::ClientResponseLFQueue client_responses(ME_MAX_CLIENT_
  UPDATES);
  Exchange::MEMarketUpdateLFQueue market_updates(ME_MAX_MARKET_
  UPDATES);</span></pre>
<p><span class="koboSpan" id="kobo.1416.1">Then, we create and</span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.1417.1"> start the instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1419.1"> component and pass the three </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">LFQueue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1422.1">
  std::string time_str;
  logger-&gt;log("%:% %() % Starting Matching Engine...\n", __FILE__, __
  LINE__, __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str));
  matching_engine = new Exchange::MatchingEngine(&amp;client_requests,
  &amp;client_responses, &amp;market_updates);
  matching_engine-&gt;start();</span></pre>
<p><span class="koboSpan" id="kobo.1423.1">We will also create and start the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1425.1"> and provide it with the snapshot and incremental stream information and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">market_updates</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">LFQueue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1428.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.1429.1">One note about the interfaces and the IPs and ports specified in this chapter as well as the subsequent ones is that we chose these arbitrarily; feel free to change them if needed. </span><span class="koboSpan" id="kobo.1429.2">The important thing here is that the market data stream IP:port information used by the electronic exchange and trading clients should match, and similarly, the order server IP:port </span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.1430.1">information used by the electronic exchange and trading </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">clients match:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1432.1">
  const std::string mkt_pub_iface = "lo";
  const std::string snap_pub_ip = "233.252.14.1", inc_pub_ip =
  "233.252.14.3";
  const int snap_pub_port = 20000, inc_pub_port = 20001;
  logger-&gt;log("%:% %() % Starting Market Data Publisher...\n", __
  FILE__, __LINE__, __FUNCTION__, Common::getCurrentTimeStr(&amp;time_
  str));
  market_data_publisher = new Exchange::MarketDataPublisher(&amp;market_
  updates, mkt_pub_iface, snap_pub_ip, snap_pub_port, inc_pub_ip, inc_
  pub_port);
  market_data_publisher-&gt;start();</span></pre>
<p><span class="koboSpan" id="kobo.1433.1">We perform similar tasks with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">order_server</span></strong><span class="koboSpan" id="kobo.1435.1"> object – create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1437.1"> and start it after providing it with the order gateway server </span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1">configuration information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1439.1">
  const std::string order_gw_iface = "lo";
  const int order_gw_port = 12345;
  logger-&gt;log("%:% %() % Starting Order Server...\n", __FILE__, __
  LINE__, __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str));
  order_server = new Exchange::OrderServer(&amp;client_requests, &amp;client_
  responses, order_gw_iface, order_gw_port);
  order_server-&gt;start();</span></pre>
<p><span class="koboSpan" id="kobo.1440.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">main()</span></strong><span class="koboSpan" id="kobo.1442.1"> thread just sleeps infinitely since the threads within the three components will run the exchange from this </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">point on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1444.1">
  while (true) {
    logger-&gt;log("%:% %() % Sleeping for a few milliseconds..\n", __
    FILE__, __LINE__, __FUNCTION__, Common::getCurrentTimeStr(&amp;time_
    str));
    usleep(sleep_time * 1000);
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1445.1">Running the application</span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.1446.1"> as follows will produce some minimal output to the screen, but most of the output goes to the log files we create from the three components and </span><span class="No-Break"><span class="koboSpan" id="kobo.1447.1">their subcomponents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1448.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter7$ ./cmake-build-release/exchange_main
Set core affinity for Common/Logger exchange_main.log 140329423955712 to -1
Set core affinity for Common/Logger exchange_matching_engine.log 140329253541632 to -1
Set core affinity for Exchange/MatchingEngine 140329245148928 to –1
...
</span><span class="koboSpan" id="kobo.1448.2">Sun Mar 26 13:58:04 2023 Flushing and closing Logger for exchange_order_server.log
Sun Mar 26 13:58:04 2023 Logger for exchange_order_server.log exiting.</span></pre>
<p><span class="koboSpan" id="kobo.1449.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1451.1"> application was killed by sending it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">SIGINT</span></strong><span class="koboSpan" id="kobo.1453.1"> signal using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">kill –2 PID</span></strong><span class="koboSpan" id="kobo.1455.1"> command. </span><span class="koboSpan" id="kobo.1455.2">We can inspect the log files to see what the different components did. </span><span class="koboSpan" id="kobo.1455.3">Note, however, that the output right now is not super interesting. </span><span class="koboSpan" id="kobo.1455.4">It simply logs that the components were created and started. </span><span class="koboSpan" id="kobo.1455.5">This output will have a lot more information once we add clients for this trading exchange that connect and send client requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1457.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter7$ tail -n 10 *.log</span></pre>
<p><span class="koboSpan" id="kobo.1458.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">exchange_main.log</span></strong><span class="koboSpan" id="kobo.1460.1"> file</span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.1461.1"> contains information about the creation of the different components, </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">as shown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1463.1">
==&gt; exchange_main.log &lt;==
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:43 main() Sun Mar 26 09:13:49 2023 Starting Matching Engine...
</span><span class="koboSpan" id="kobo.1463.2">/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:51 main() Sun Mar 26 09:13:51 2023 Starting Market Data Publisher...
</span><span class="koboSpan" id="kobo.1463.3">/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:58 main() Sun Mar 26 09:13:56 2023 Starting Order Server...
</span><span class="koboSpan" id="kobo.1463.4">/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:63 main() Sun Mar 26 09:13:58 2023 Sleeping for a few milliseconds..</span></pre>
<p><span class="koboSpan" id="kobo.1464.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">exchange_market_data_publisher.log</span></strong><span class="koboSpan" id="kobo.1466.1"> file creates the UDP sockets and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">run()</span></strong><span class="koboSpan" id="kobo.1468.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">as shown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1470.1">
==&gt; exchange_market_data_publisher.log &lt;==
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/common/socket_utils.cpp:68 createSocket() Sun Mar 26 09:13:52 2023 ip:233.252.14.3 iface:lo port:20001 is_udp:1 is_blocking:0 is_listening:0 ttl:32 SO_time:0
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/market_data_publisher.cpp:15 run() Sun Mar 26 09:13:54 2023</span></pre>
<p><span class="koboSpan" id="kobo.1471.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">exchange_matching_engine.log</span></strong><span class="koboSpan" id="kobo.1473.1"> file does not have much meaningful output yet since no matching was performed and no order book </span><span class="No-Break"><span class="koboSpan" id="kobo.1474.1">was built:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1475.1">
==&gt; exchange_matching_engine.log &lt;==
                          X
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/matcher/me_order_book.cpp:12 ~MEOrderBook() Sun Mar 26 09:15:00 2023 OrderBook
Ticker:7
                          X</span></pre>
<p><span class="koboSpan" id="kobo.1476.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">exchange_order_server.log</span></strong><span class="koboSpan" id="kobo.1478.1"> file also </span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.1479.1">contains some information about the creation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1481.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">run()</span></strong><span class="koboSpan" id="kobo.1483.1"> method for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">main thread:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1485.1">
==&gt; exchange_order_server.log &lt;==
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/common/socket_utils.cpp:68 createSocket() Sun Mar 26 09:13:57 2023 ip:127.0.0.1 iface:lo port:12345 is_udp:0 is_blocking:0 is_listening:1 ttl:0 SO_time:1
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/order_server/order_server.h:25 run() Sun Mar 26 09:13:57 2023</span></pre>
<p><span class="koboSpan" id="kobo.1486.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">exchange_snapshot_synthesizer.log</span></strong><span class="koboSpan" id="kobo.1488.1"> file outputs the messages in an empty snapshot for the different trading instruments, since there are no orders in the order </span><span class="No-Break"><span class="koboSpan" id="kobo.1489.1">book yet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1490.1">
==&gt; exchange_snapshot_synthesizer.log &lt;==
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:82 publishSnapshot() Sun Mar 26 09:14:55 2023 MDPMarketUpdate [ seq:2 MEMarketUpdate [ type:CLEAR ticker:1 oid:INVALID side:INVALID qty:INVALID price:INVALID priority:INVALID]]
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:82 publishSnapshot() Sun Mar 26 09:14:55 2023 MDPMarketUpdate [ seq:3 MEMarketUpdate [ type:CLEAR ticker:2 oid:INVALID side:INVALID qty:INVALID price:INVALID priority:INVALID]]
...
</span><span class="koboSpan" id="kobo.1490.2">/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:96 publishSnapshot() Sun Mar 26 09:14:55 2023 MDPMarketUpdate [ seq:9 MEMarketUpdate [ type:SNAPSHOT_END ticker:INVALID oid:0 side:INVALID qty:INVALID price:INVALID priority:INVALID]]
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:100 publishSnapshot() Sun Mar 26 09:14:55 2023 Published snapshot of 9 orders.</span></pre>
<p><span class="koboSpan" id="kobo.1491.1">This concludes our discussion, design, and implementation of the electronic trading exchange. </span><span class="koboSpan" id="kobo.1491.2">In the next chapter, we will build the trading system on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">client’s end.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.1493.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1494.1">This chapter was dedicated to building the order gateway server and the market data publisher components. </span><span class="koboSpan" id="kobo.1494.2">We also combined the matching engine component we built in the previous chapter with the order gateway server and market data publisher components we built in this chapter to build the final trading exchange </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">main application.</span></span></p>
<p><span class="koboSpan" id="kobo.1496.1">First, we defined the public market data protocol that will be used by the exchange to publish data on the wire and used by the clients to write market data consumer applications. </span><span class="koboSpan" id="kobo.1496.2">We performed a similar task with the order gateway protocol so that client applications can understand the format of the client requests that they send to the exchange’s order gateway server and receive </span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1">responses from.</span></span></p>
<p><span class="koboSpan" id="kobo.1498.1">We built the order gateway server, whose design we established in the </span><em class="italic"><span class="koboSpan" id="kobo.1499.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.1500.1"> chapter. </span><span class="koboSpan" id="kobo.1500.2">We built the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1502.1"> class, which builds and runs </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1504.1">, to accept and manage TCP client connections. </span><span class="koboSpan" id="kobo.1504.2">We added functionality to handle incoming client requests and send client responses. </span><span class="koboSpan" id="kobo.1504.3">We also built the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.1506.1"> component, which is responsible for sequencing/ordering the incoming TCP client requests in the order in which they were received to maintain fairness in </span><span class="No-Break"><span class="koboSpan" id="kobo.1507.1">the market.</span></span></p>
<p><span class="koboSpan" id="kobo.1508.1">The next component we built was designed in the same chapter, </span><em class="italic"><span class="koboSpan" id="kobo.1509.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.1510.1">, which is the market data publisher. </span><span class="koboSpan" id="kobo.1510.2">We built </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1512.1">, which consumes market data updates from the matching engine and generates a multicast stream of incremental market data updates. </span><span class="koboSpan" id="kobo.1512.2">We also added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1514.1"> component, which runs on a different thread and is responsible for consuming market data updates from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1516.1"> and synthesizing the snapshot of the full order book. </span><span class="koboSpan" id="kobo.1516.2">This full snapshot is periodically published by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1517.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1518.1"> on the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.1519.1">multicast stream.</span></span></p>
<p><span class="koboSpan" id="kobo.1520.1">Finally, we built the main electronic trading exchange application, which ties together all the exchange side components we have built so far. </span><span class="koboSpan" id="kobo.1520.2">This will serve as the central electronic trading exchange that supports multiple clients and different trading instruments for clients to connect and trade as well as receive market data </span><span class="No-Break"><span class="koboSpan" id="kobo.1521.1">updates for.</span></span></p>
<p><span class="koboSpan" id="kobo.1522.1">In the next chapter, we switch our focus from the exchange-side infrastructure to the market participants’ infrastructure. </span><span class="koboSpan" id="kobo.1522.2">The next chapter will focus on the functionality to connect to the order gateway server and communicate with it, as well as receiving and processing the market data updates published by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">electronic exchange.</span></span></p>
</div>


<div class="Content" id="_idContainer048">
<h1 id="_idParaDest-192"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.1.1">Part 3:Building Real-Time C++ Algorithmic Trading Systems</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will start building the trading client-side C++ algorithmic trading system. </span><span class="koboSpan" id="kobo.2.2">We will be building components that interface with the trading exchange to process market data and connect to and communicate with the exchange order gateway. </span><span class="koboSpan" id="kobo.2.3">We will also build the C++ framework on which we will build market-making and liquidity-taking trading algorithms. </span><span class="koboSpan" id="kobo.2.4">In the HFT space, this is where participants spend a lot of time and effort trying to reduce latencies and maximize performance (and profits). </span><span class="koboSpan" id="kobo.2.5">Finally, we will implement the market-making and liquidity-taking trading algorithms in this framework, run the entire trading ecosystem, and understand the interactions between all </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">the components.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19434_08.xhtml#_idTextAnchor206"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Processing Market Data and Sending Orders to the Exchange in C++</span></em></li>
<li><a href="B19434_09.xhtml#_idTextAnchor227"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Building the C++ Trading Algorithm Building Blocks</span></em></li>
<li><a href="B19434_10.xhtml#_idTextAnchor262"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Building the C++ Market-Making and Liquidity-Taking Algorithms</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer049">
</div>
</div>
<div>
<div id="_idContainer050">
</div>
</div>
</body></html>