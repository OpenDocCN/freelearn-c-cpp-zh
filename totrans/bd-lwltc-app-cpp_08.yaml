- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Processing Market Data and Sending Orders to the Exchange in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++ 处理市场数据并向交易所发送订单
- en: In this chapter, we will build the client’s C++ system that receives and processes
    market data updates from the trading exchange. We will also have to deal with
    creating and reading from UDP sockets, dealing with packet losses, etc. We will
    discuss the design of an order book on the client side to track the order book
    maintained at the trading exchange. We will also implement the C++ components
    needed to establish and maintain TCP connections to the trading exchange. We will
    also implement functionality to send orders to the exchange from the strategies
    and receive and process order responses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建客户端的 C++ 系统，该系统从交易交易所接收并处理市场数据更新。我们还将处理创建和读取 UDP 套接字、处理数据包丢失等问题。我们将讨论客户端上订单簿的设计，以跟踪交易所在维护的订单簿。我们还将实现建立和维护与交易交易所
    TCP 连接所需的 C++ 组件。我们还将实现从策略向交易所发送订单以及接收和处理订单响应的功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Subscribing to market data and decoding the market data protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅市场数据和解码市场数据协议
- en: Building order books from market data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从市场数据构建订单簿
- en: Connecting to the exchange, sending order requests, and receiving responses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到交易所、发送订单请求和接收响应
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in the GitHub repository for this book
    at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter 8` directory in the repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)。本章的源代码位于仓库中的
    `Chapter 8` 目录。
- en: You must read and understand the design of the electronic trading ecosystem
    presented in the chapter *Designing Our Trading Ecosystem*. The components we
    build in this chapter will interact with the electronic trading exchange application
    we built in the chapter *Communicating With Market Participants*, so we assume
    you are familiar with that. The limit order book we will build in the client application’s
    trade engine component is almost identical to the order book we built inside the
    matching engine in the chapter *Building the C++ Matching Engine* within the *Building
    the order book and matching orders* section. So, we assume the reader is very
    familiar with that chapter and the code we discussed there as we will make references
    to that in this chapter. As before, we will use the building blocks we built in
    the *Building the C++ Building Blocks for Low Latency* *Applications* chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须阅读并理解章节 *设计我们的交易生态系统* 中所介绍的电子交易生态系统的设计。我们本章构建的组件将与我们在章节 *与市场参与者通信* 中构建的电子交易交易所应用程序进行交互，因此我们假设您熟悉该内容。我们将在客户端应用程序的交易引擎组件中构建的限价订单簿几乎与我们在
    *构建订单簿和匹配订单* 部分中 *构建 C++ 匹配引擎* 章节内构建的订单簿相同。因此，我们假设读者非常熟悉该章节和我们在那里讨论的代码，因为我们将在此章节中引用它。与之前一样，我们将使用我们在
    *构建低延迟应用程序的 C++ 构建块* 章节中构建的构建块。
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown in the following bullet list. We present the details of
    this environment since all the C++ code presented in this book is not necessarily
    portable and might require some minor changes to work in your environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码开发环境的规格如下所示。我们提供此环境的详细信息，因为本书中展示的所有 C++ 代码可能并不一定可移植，可能需要在您的环境中进行一些小的修改才能工作：
- en: 'OS – `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OS – `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
- en: GCC – `g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC – `g++ (Ubuntu ` `11.3.0-1ubuntu1~22.04.1) 11.3.0`
- en: CMAKE – `cmake` `version 3.23.2`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMAKE – `cmake` `版本 3.23.2`
- en: NINJA – `1.10.2`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NINJA – `1.10.2`
- en: Subscribing to market data and decoding the market data protocol
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅市场数据和解码市场数据协议
- en: The first component we need to build inside the market participants’ trading
    system is the market data consumer. This component is responsible for subscribing
    to the multicast stream of public market data updates published by the trading
    exchange. It needs to decode the market data stream generated by the exchange
    from the public `MDPMarketUpdate` format we discussed earlier. Because of the
    choice of the **Simple Binary Encoding** (**SBE**) protocol, the decoding step
    is straightforward in our application and does not involve any complicated stream
    decoding logic. Another important responsibility of this component is detecting
    packet drops on the incremental market data stream and providing mechanisms to
    recover and synchronize with the market data stream again. This mechanism is also
    required for trading systems that subscribe to the market data stream after there
    is a non-empty order book, i.e. after the trading exchange is already open and
    accepting client orders. Also, this will be required if the trading application
    needs to be restarted in the middle of the day.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在市场参与者交易系统中，我们首先需要构建的是市场数据消费者组件。该组件负责订阅由交易交易所发布的公共市场数据更新多播流。它需要解码交易所生成并由我们之前讨论的公共`MDPMarketUpdate`格式生成的市场数据流。由于选择了**简单二进制编码**（**SBE**）协议，在我们的应用中解码步骤简单直接，不涉及任何复杂的流解码逻辑。该组件的另一个重要职责是检测增量市场数据流中的数据包丢失，并提供恢复并与市场数据流再次同步的机制。此机制对于在存在非空订单簿后订阅市场数据流（即交易所在接受客户订单后已经开放）的交易系统也是必需的。此外，如果交易应用程序需要在一天中重新启动，这也将是必需的。
- en: 'We present a detailed diagram of the market data consumer component we have
    seen before. As shown in *Figure 8**.1*, it consumes multicast data containing
    market data updates from the incremental and optionally the snapshot stream. After
    checking for sequence numbers on the market data updates and potentially needing
    to synchronize between the snapshot and the incremental streams, it decodes the
    market data updates. It then generates a stream of decoded and in-order market
    data updates for the trading engine to consume and publishes them over a lock-free
    queue:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了之前见过的市场数据消费者组件的详细图示。如图8.1所示，它消费包含市场数据更新的多播数据，这些更新来自增量流，也可以选择来自快照流。在检查市场数据更新的序列号并可能需要在快照流和增量流之间同步后，它解码市场数据更新。然后，它生成一系列解码并按顺序排列的市场数据更新流，供交易引擎消费，并通过无锁队列发布：
- en: '![Figure 8.1 – An overview of the market data consumer component and its sub-components](img/B19434_05_06.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 市场数据消费者组件及其子组件概述](img/B19434_05_06.jpg)'
- en: Figure 8.1 – An overview of the market data consumer component and its sub-components
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 市场数据消费者组件及其子组件概述
- en: Before we jump into the design and implementation of the market data consumer
    component, we would like to mention that the source code for this component can
    be found in the `Chapter8/trading/market_data/market_data_consumer.h` source file
    and the `Chapter8/trading/market_data/market_data_consumer.cpp` source file. Next,
    let us get started by first defining the internal data members that the market
    data consumer component will need.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入设计市场数据消费者组件的实现之前，我们想提到，该组件的源代码可以在`Chapter8/trading/market_data/market_data_consumer.h`源文件和`Chapter8/trading/market_data/market_data_consumer.cpp`源文件中找到。接下来，让我们首先定义市场数据消费者组件将需要的内部数据成员。
- en: Defining the data members in the market data consumer
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在市场数据消费者中定义数据成员
- en: 'The `MarketDataConsumer` class we are going to build will need a couple of
    important data members as shown in the following bullet list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的`MarketDataConsumer`类将需要以下列表中所示的一些重要数据成员：
- en: First, it needs a lock-free `incoming_md_updates_` queue instance of the `Exchange::MEMarketUpdateLFQueue`
    type, which we defined before. This is meant to be used by `MarketDataConsumer`
    to publish the `MEMarketUpdate` messages to the trading engine component.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它需要一个无锁的`incoming_md_updates_`队列实例，该实例为`Exchange::MEMarketUpdateLFQueue`类型，这是我们之前定义的。这是为了由`MarketDataConsumer`将`MEMarketUpdate`消息发布到交易引擎组件。
- en: We will maintain a `next_exp_inc_seq_num_` variable of the `size_t` type, which
    will be used to make sure that we process updates from the incremental market
    data stream in the correct order and detect packet drops on the incremental market
    data stream.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将维护一个`next_exp_inc_seq_num_`变量，该变量为`size_t`类型，它将用于确保我们按正确顺序处理增量市场数据流中的更新，并检测增量市场数据流中的数据包丢失。
- en: We will have two multicast subscriber sockets – `incremental_mcast_socket_`
    and `snapshot_mcast_socket_` of the `Common::McastSocket` types. These correspond
    to the sockets we will use to subscribe to and consume multicast data from the
    incremental and the snapshot multicast streams, respectively.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将有两个多播订阅套接字——`incremental_mcast_socket_` 和 `snapshot_mcast_socket_`，它们都是 `Common::McastSocket`
    类型。这些对应于我们将用于订阅和消费增量多播流和快照多播流的套接字。
- en: 'To perform the recovery/synchronization from the snapshot market data stream
    when needed, we will need to maintain a couple of extra data members, as shown
    in the following bullet list:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要从快照市场数据流执行恢复/同步操作时，我们需要维护一些额外的数据成员，如下面的项目符号列表所示：
- en: First, we will store an `in_recovery_` boolean flag to signify if `MarketDataConsumer`
    detected a packet drop and is currently trying to recover using the snapshot and
    incremental market data streams.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将存储一个 `in_recovery_` 布尔标志来表示 `MarketDataConsumer` 是否检测到数据包丢失，并且目前正在尝试使用快照和增量市场数据流进行恢复。
- en: Since we will join and leave the snapshot multicast stream as needed, we will
    have the multicast stream and network interface information in the `iface_` variable,
    the `snapshot_ip_ variable`, and the `snapshot_port_` variable. These represent
    the network interface to use, the IP address, and the port of the snapshot multicast
    stream.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将根据需要加入和离开快照多播流，我们将在 `iface_` 变量、`snapshot_ip_` 变量和 `snapshot_port_` 变量中拥有多播流和网络接口信息。这些代表要使用的网络接口、IP
    地址和快照多播流的端口。
- en: Finally, we define a type to queue up messages and order them by their corresponding
    sequence number. We will use the `std::map` type here and paramaterize it to use
    keys of the `size_t` type (to represent the sequence number of the update), hold
    objects of `Exchange::MEMarketUpdate`, and call this type `QueuedMarketUpdates`
    using `typedef`. We chose the `std::map` type here since it is easier to iterate
    over sorted keys compared to, say, `std::unordered _map`. Note that `std::map`
    is not efficient for a wide range of reasons – the internal data structure is
    `O(log(N))` and causes dynamic memory allocations, etc. However, we make an exception
    in this case because snapshot recovery is expected to be extremely rare, and when
    the `MarketDataConsumer` class is recovering from the snapshot stream, trading
    is generally paused inside the client’s trading application since it does not
    have an accurate view of the state of the order book. Additionally, the snapshot
    stream is delayed and throttled from the exchange’s side, so the snapshot synchronization
    process itself is not required to be low latency.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个类型来排队消息并按其相应的序列号进行排序。在这里我们将使用 `std::map` 类型，并对其进行参数化以使用 `size_t` 类型的键（表示更新的序列号），持有
    `Exchange::MEMarketUpdate` 对象，并使用 `typedef` 将此类型命名为 `QueuedMarketUpdates`。我们选择
    `std::map` 类型是因为与 `std::unordered_map` 相比，迭代排序键更容易。请注意，`std::map` 由于多种原因效率不高——其内部数据结构是
    `O(log(N))` 并导致动态内存分配等。然而，我们在此例中做出例外，因为快照恢复预计会非常罕见，并且当 `MarketDataConsumer` 类从快照流恢复时，客户端的交易应用程序中的交易通常会被暂停，因为它没有订单簿状态的准确视图。此外，快照流在交易所方面是延迟和节流的，因此快照同步过程本身不需要低延迟。
- en: We create two instances of this `QueuedMarketUpdates` type – `snapshot_queued_msgs_`
    and `incremental_queued_msgs_`, one to queue up `MEMarketUpdate` messages from
    the snapshot stream and one to queue up `MEMarketUpdate` messages from the incremental
    stream.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建两个 `QueuedMarketUpdates` 类型的实例——`snapshot_queued_msgs_` 和 `incremental_queued_msgs_`，一个用于排队快照流中的
    `MEMarketUpdate` 消息，另一个用于排队增量流中的 `MEMarketUpdate` 消息。
- en: 'The `MarketDataConsumer` class is also a different thread of execution, so
    similar to the classes we have seen before, it has a `run_` boolean flag to control
    the execution of the thread and it is marked `volatile` since it is accessed from
    different threads:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MarketDataConsumer` 类也是一个不同的执行线程，因此类似于我们之前看到的类，它有一个 `run_` 布尔标志来控制线程的执行，并且它被标记为
    `volatile`，因为它被不同的线程访问：'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will initialize the `MarketDataConsumer` class and these data members in
    the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中初始化 `MarketDataConsumer` 类及其数据成员。
- en: Initializing the market data consumer
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化市场数据消费者
- en: 'The constructor for the `MarketDataConsumer` class accepts the following arguments:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketDataConsumer` 类的构造函数接受以下参数：'
- en: A `client_id` argument of the `Common::ClientId` type, which in this case is
    used purely to create a unique log filename to be used to initialize the `Logger
    logger_` component in this class.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `client_id` 参数，其类型为 `Common::ClientId`，在此情况下仅用于创建一个唯一的日志文件名，用于初始化此类中 `Logger
    logger_` 组件。
- en: It also expects a pointer to a `MEMarketUpdateLFQueue` lock-free queue object
    called `market_updates`, where it will publish decoded and in-order market updates.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还期望一个指向名为 `market_updates` 的 `MEMarketUpdateLFQueue` 无锁队列对象的指针，其中它将发布解码并排序的市场更新。
- en: 'It expects the network interface name in the `iface` argument and the addresses
    of the snapshot and incremental market data streams. These will be passed in the
    `snapshot_ip` argument, the `snapshot_port` argument, the `incremental_ip` argument,
    and the `incremental_port` argument:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它期望在 `iface` 参数中提供网络接口名称以及快照和增量市场数据流的地址。这些将通过 `snapshot_ip` 参数、`snapshot_port`
    参数、`incremental_ip` 参数和 `incremental_port` 参数传递：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The constructor performs the following tasks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数执行以下任务：
- en: As we mentioned, the constructor creates a `Logger` instance for this class
    and uses that `logger_` object to initialize the `incremental_mcast_socket_` variable
    and the `snapshot_mcast_socket_` variable. It also initializes the `iface_`, `snapshot_ip_`,
    and `snapshot_port_` members from the arguments passed to it.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们提到的，构造函数为此类创建一个 `Logger` 实例，并使用该 `logger_` 对象初始化 `incremental_mcast_socket_`
    变量和 `snapshot_mcast_socket_` 变量。它还从传递给它的参数中初始化 `iface_`、`snapshot_ip_` 和 `snapshot_port_`
    成员。
- en: Using the `recv_callback()` lambda method, it initializes the `recv_callback_`
    variable in the `incremental_mcast_socket_` variable and the `snapshot_mcast_socket_`
    variable. The lambda just forwards the callbacks to the `recvCallback()` member
    method in the `MarketDataConsumer` class, which we will see later. The key point
    here is that we expect the `MarketDataConsumer::recvCallback()` method to be called
    when there is data available on the incremental or the snapshot multicast sockets.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `recv_callback()` lambda 方法，它在 `incremental_mcast_socket_` 变量和 `snapshot_mcast_socket_`
    变量中初始化 `recv_callback_` 变量。lambda 仅将回调转发到 `MarketDataConsumer` 类中的 `recvCallback()`
    成员方法，我们将在后面看到。关键点在于我们期望在增量或快照多播套接字上有数据可用时调用 `MarketDataConsumer::recvCallback()`
    方法。
- en: 'The last thing the constructor does is fully initialize `incremental_mcast_socket_`
    by calling the `McastSocket::init()` method, which creates the actual socket internally.
    It also calls the `McastSocket::join()` method to subscribe to the multicast stream
    for this socket. Note that we do not do the same for `snapshot_mcast_socket_`
    yet. That is done on demand as packet drops or sequence gaps are detected:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数最后一件要做的事情是通过调用 `McastSocket::init()` 方法完全初始化 `incremental_mcast_socket_`，该方法在内部创建实际的套接字。它还调用
    `McastSocket::join()` 方法来订阅此套接字的多播流。请注意，我们还没有对 `snapshot_mcast_socket_` 做同样的事情。这是在检测到数据包丢失或序列间隙时按需完成的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We add a `start()` method like what we have seen for our other components on
    the side of the trading exchange. This sets the `run_` variable to be `true` and
    creates and launches a thread to execute the `MarketDataConsumer::run()` method,
    which we will build later:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `start()` 方法，类似于我们在交易交易所的其他组件旁边看到的。它将 `run_` 变量设置为 `true` 并创建并启动一个线程来执行我们将在后面构建的
    `MarketDataConsumer::run()` 方法：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The destructor for this class is straightforward and calls the `stop()` method,
    which simply sets the `run_` flag to `false` to end the execution of the `run()`
    method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的析构函数简单直接，调用 `stop()` 方法，该方法仅将 `run_` 标志设置为 `false` 以结束 `run()` 方法的执行：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have initialized the `MarketDataConsumer` class, we will first look
    at the main `run()` loop, which executes a loop of consuming multicast traffic
    from the exchange.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了 `MarketDataConsumer` 类，我们将首先查看主要的 `run()` 循环，该循环执行从交易所消费多播流的一个循环。
- en: Running the market data consumer main loop
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行市场数据消费者主循环
- en: 'The `run()` method is simple for our market data consumer component. It simply
    calls the `sendAndRecv()` method on the `incremental_mcast_socket_` socket and
    the `snapshot_mcast_socket_` object, which in our case, consumes any additional
    data received on the incremental or snapshot channels and dispatches the callbacks:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的市场数据消费者组件，`run()` 方法很简单。它仅在 `incremental_mcast_socket_` 套接字和 `snapshot_mcast_socket_`
    对象上调用 `sendAndRecv()` 方法，在我们的情况下，它消费增量或快照通道上接收到的任何附加数据，并调度回调：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next section deals with the data available on the network sockets within
    the `recvCallback()` method that get dispatched from the previous logic.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节处理在`recvCallback()`方法中从先前逻辑分发的网络套接字上的可用数据。
- en: Processing market data updates and handling packet drops
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理市场数据更新和处理数据包丢失
- en: This section implements important functionality responsible for processing market
    data updates received on the incremental and the snapshot streams. Market updates
    on the incremental stream are received during the entire runtime of the `MarketDataConsumer`
    component. However, data is received and processed from the snapshot stream only
    when a sequence number gap is detected on the incremental stream, which causes
    `MarketDataConsumer` to initialize `snapshot_mcast_socket_` and subscribe to the
    snapshot multicast stream. Remember that in the constructor of `MarketDataConsumer`,
    we intentionally did not fully initialize `snapshot_mcast_socket_` as we did with
    the `incremental_mcast_socket_`. The important thing to understand here is that
    data on the snapshot socket is only received when we are in recovery mode and
    not otherwise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本节实现了处理在增量流和快照流上接收到的市场数据更新的重要功能。增量流上的市场更新在整个`MarketDataConsumer`组件运行期间接收。然而，只有在检测到增量流上的序列号间隙时，才会从快照流接收和处理数据，这导致`MarketDataConsumer`初始化`snapshot_mcast_socket_`并订阅快照多播流。记住，在`MarketDataConsumer`的构造函数中，我们故意没有像对`incremental_mcast_socket_`那样完全初始化`snapshot_mcast_socket_`。这里要理解的重要一点是，只有在恢复模式下，我们才会从快照套接字接收数据，否则不会。
- en: 'The first code block in the `recvCallback()` method determines if the data
    we are processing came from the incremental or snapshot stream by comparing the
    file descriptor of the socket on which it was received. In the extremely unlikely
    edge case that we received data on the snapshot socket but we are not in recovery,
    we simply log a warning, reset the socket receive buffer index, and return:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvCallback()`方法中的第一个代码块通过比较接收数据的套接字文件描述符，确定我们正在处理的数据来自增量流还是快照流。在极不可能的边缘情况下，如果我们从快照套接字接收数据但我们不在恢复中，我们简单地记录一个警告，重置套接字接收缓冲区索引，并返回：'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Otherwise, we proceed further and read `Exchange::MDPMarketUpdate` messages
    from the socket buffer using the same code that we have seen before. We go through
    the data contained in the `socket->rcv_buffer_` buffer and read it in chunks of
    size equal to the size of `Exchange::MDPMarketUpdate`. The goal here is to read
    as many full `MDPMarketUpdate` messages as possible until we have read them all
    from the buffer. We use `reinterpret_cast` to convert the data in the buffer to
    an object of the `Exchange::MDPMarketUpdate` type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们继续进行，并使用之前看到的相同代码从套接字缓冲区读取`Exchange::MDPMarketUpdate`消息。我们遍历`socket->rcv_buffer_`缓冲区中的数据，并以`Exchange::MDPMarketUpdate`大小为块的大小读取它。这里的目的是尽可能多地读取完整的`MDPMarketUpdate`消息，直到我们从缓冲区中读取完所有消息。我们使用`reinterpret_cast`将缓冲区中的数据转换为`Exchange::MDPMarketUpdate`类型的对象：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each `MDPMarketUpdate` message, we check the sequence number on the message
    we just read to see if there is a sequence number gap or not. We set the `in_recovery_`
    member flag to be `true` if we detect a sequence number gap or if we were already
    in recovery:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`MDPMarketUpdate`消息，我们检查我们刚刚读取的消息中的序列号，以查看是否存在序列号间隙。如果我们检测到序列号间隙或我们已经在恢复中，我们将`in_recovery_`成员标志设置为`true`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we will see the handling of the message if we are in recovery mode.
    In the next code block, we first check the `already_in_recovery_` flag to see
    if we were previously not in recovery and just started recovery due to this message
    or not. If we were previously not in recovery and started recovery because we
    saw a sequence number gap, we call the `startSnapshotSync()` method, which we
    will see shortly. Just to provide a brief introduction here, the `startSnapshotSync()`
    method will initialize the `snapshot_mcast_socket_` object and subscribe to the
    snapshot multicast stream, but more on that later. When in recovery, we call the
    `queueMessage()` method to store the `MDPMarketUpdate` message we just received.
    We stay in recovery mode and queue up market data updates on both the snapshot
    and incremental streams. We will do this until we have a complete snapshot of
    the book from the snapshot stream and all the incremental messages after the snapshot
    message to catch up with the incremental stream. We will cover more details on
    that shortly when we present the actual implementation of the `checkSnapshotSync()`
    method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到在恢复模式下处理消息的方式。在下一个代码块中，我们首先检查`already_in_recovery_`标志，以确定我们之前是否不在恢复模式，并且是否因为这条消息而刚刚开始恢复。如果我们之前不在恢复模式，并且因为看到了序列号差距而开始恢复，我们将调用`startSnapshotSync()`方法，我们很快就会看到这个方法。简而言之，`startSnapshotSync()`方法将初始化`snapshot_mcast_socket_`对象并订阅快照多播流，但关于这一点我们稍后再说。在恢复模式下，我们调用`queueMessage()`方法来存储我们刚刚收到的`MDPMarketUpdate`消息。我们保持在恢复模式，并在快照和增量流上排队市场数据更新。我们将这样做，直到我们从快照流中获得完整的簿记快照，以及快照消息之后的所有增量消息，以赶上增量流。我们将在稍后详细介绍这一点，当我们展示`checkSnapshotSync()`方法的实际实现时：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the branch where we are not in recovery and the message we received is
    from the incremental market data stream, we simply update `next_exp_inc_seq_num_`.
    This a reminder that the `next_exp_inc_seq_num_` variable tracks the next sequence
    number we expect on the next incremental market data update. We then write the
    `MEMarketUpdate` message to the `incoming_md_updates_` lock-free queue, which
    will be consumed by the trading engine component on the other end:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们不在恢复模式且接收到的消息来自增量市场数据流的情况，我们只需更新`next_exp_inc_seq_num_`。这是一个提醒，`next_exp_inc_seq_num_`变量跟踪我们期望在下一个增量市场数据更新中出现的下一个序列号。然后我们将`MEMarketUpdate`消息写入`incoming_md_updates_`无锁队列，该队列将由另一端的交易引擎组件消费：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we shift the remaining partial data left in the socket’s `rcv_buffer_`
    buffer and update the next valid receive index for the next read:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将socket中`rcv_buffer_`缓冲区中剩余的局部数据左移，并更新下一次有效接收索引以供下一次读取：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That concludes the implementation of the `recvCallback()` method and we will
    now look at the methods that handle snapshot subscription and synchronization
    logic. First, we investigate the `startSnapshotSync()` method, which, as we mentioned
    before, prepares the `MarketDataConsumer` class to start the snapshot synchronization
    mechanism on sequence number gaps. The first thing we do for this task is clear
    the two `std::map` containers – `snapshot_queued_msgs_` and `incremental_queued_msgs_`,
    which we use to queue upmarket update messages from the snapshot and incremental
    streams. Then we initialize the `snapshot_mcast_socket_` object using the `McastSocket::init()`
    method so that the socket gets created for the `snapshot_ip_` and `snapshot_port_`
    address. Then we call the `McastSocket::join()` method to start the multicast
    subscription for the snapshot market data stream. Remember that for multicast
    sockets, we need to make sure that not only do we have a socket that is reading
    market data, but we also have to issue the IGMP join membership network-level
    message so that messages can flow to the application, which is achieved by the
    call to `snapshot_mcast_socket_.join()`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`recvCallback()`方法的实现，我们现在将查看处理快照订阅和同步逻辑的方法。首先，我们研究`startSnapshotSync()`方法，正如我们之前提到的，它准备`MarketDataConsumer`类在序列号差距上启动快照同步机制。为此任务，我们首先清除两个`std::map`容器——`snapshot_queued_msgs_`和`incremental_queued_msgs_`，我们使用这些容器来排队快照和增量流中的市场更新消息。然后我们使用`McastSocket::init()`方法初始化`snapshot_mcast_socket_`对象，以便在`snapshot_ip_`和`snapshot_port_`地址上创建套接字。然后我们调用`McastSocket::join()`方法来开始快照市场数据流的组播订阅。记住，对于多播套接字，我们不仅要确保有一个正在读取市场数据的套接字，而且我们还需要发出IGMP加入成员网络级消息，以便消息可以流向应用程序，这是通过调用`snapshot_mcast_socket_.join()`实现的：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next section handles a very important responsibility of the `MarketDataConsumer`
    component, which is queueing up market data updates from the snapshot and incremental
    stream and synchronizing when needed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节处理`MarketDataConsumer`组件的一个重要职责，即从快照和增量流中排队市场数据更新，并在需要时进行同步。
- en: Synchronizing with the snapshot stream
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与快照流同步
- en: The first method we need to implement is the `MarketDataConsumer::queueMessage()`
    method, which we invoked earlier. This method receives an `MDPMarketUpdate` message
    and a flag that captures whether it was received from the snapshot stream or the
    incremental stream.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的第一种方法是`MarketDataConsumer::queueMessage()`方法，这是我们之前调用的。该方法接收一个`MDPMarketUpdate`消息和一个标志，该标志捕获它是否是从快照流或增量流接收到的。
- en: 'If the message came over the incremental market data stream, then it adds it
    to `incremental_queued_msgs_` `std::map`. If it is received over the snapshot
    stream, then first, it checks to see if a market update for that sequence number
    already exists in the `snapshot_queued_msgs_` container. If the entry for that
    sequence number already exists in the container, then that means that we are receiving
    a new snapshot messages cycle and we were not able to successfully recover from
    the previous snapshot messages cycle. In this case, it clears the `snapshot_queued_msgs_`
    container since we will have to restart the snapshot recovery process from the
    beginning. Finally, the `MEMarketUpdate` message is added to the `snapshot_queued_msgs_`
    container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息是通过增量市场数据流发送的，那么它将其添加到`incremental_queued_msgs_` `std::map`中。如果它是通过快照流接收的，那么首先，它会检查该序列号的市场更新是否已经存在于`snapshot_queued_msgs_`容器中。如果该序列号的条目已经存在于容器中，那么这意味着我们正在接收一个新的快照消息周期，并且我们没有能够从上一个快照消息周期中成功恢复。在这种情况下，它会清除`snapshot_queued_msgs_`容器，因为我们将不得不从头开始重新启动快照恢复过程。最后，将`MEMarketUpdate`消息添加到`snapshot_queued_msgs_`容器中：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the new message is queued in the correct container, we call the `checkSnapshotSync()`
    method to see if we can successfully recover from the snapshot and the incremental
    messages we have queued up so far:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新消息排队到正确的容器后，我们调用`checkSnapshotSync()`方法来查看我们是否可以从快照以及我们迄今为止排队的增量消息中成功恢复：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we will implement the last and most important method in the `MarketDataConsumer`
    class – `checkSnapshotSync()`, which inspects the queued `MEMarketUpdate` messages
    in the snapshot and incremental containers to see if we can successfully recover
    or synchronize with the snapshot and incremental streams and *catch up*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现`MarketDataConsumer`类中最后也是最重要的方法 – `checkSnapshotSync()`，该方法检查快照和增量容器中排队的`MEMarketUpdate`消息，以查看我们是否可以成功恢复或与快照和增量流同步并*赶上*：
- en: The logic is to queue up messages received on the snapshot and incremental market
    data streams.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑是排队快照和增量市场数据流上接收到的消息。
- en: Then, when we receive `MarketUpdateType::SNAPSHOT_END`, we make sure that no
    messages were dropped on the snapshot market data stream by checking that there
    is no gap in the sequence number field on the snapshot messages.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当我们收到`MarketUpdateType::SNAPSHOT_END`时，我们确保在快照市场数据流中没有丢失任何消息，通过检查快照消息的序列号字段上没有间隙来确认。
- en: Then, we inspect the queued market updates from the incremental data stream
    and check to see if we have messages following the last message that was used
    to synthesize this round of snapshot messages. We do this by checking if we have
    market updates in the incremental queue starting with a sequence number equal
    to the `OrderId + 1` value from the `SNAPSHOT_END` message in the snapshot queue.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查增量数据流中排队的市场更新，查看我们是否有消息跟在用于合成这一轮快照消息的最后一个消息之后。我们通过检查增量队列中是否有从`SNAPSHOT_END`消息中`OrderId
    + 1`值开始的序列号的市场更新来完成此操作。
- en: Finally, we check to make sure that from that point on in the incremental queued
    messages, we do not have another gap.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们确保从那个点开始，在增量排队消息中我们没有另一个间隙。
- en: 'To better understand how the snapshot recovery logic works, we present *Figure
    8**.2*, a concrete example of when recovery is possible:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解快照恢复逻辑是如何工作的，我们提供了一个具体的示例，即恢复是可能的，*图8**.2*：
- en: '![Figure 8.2 – Example state of snapshot and incremental queues when recovery
    is possible](img/B19434_08_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 当恢复可能时快照和增量队列的示例状态](img/B19434_08_02.jpg)'
- en: Figure 8.2 – Example state of snapshot and incremental queues when recovery
    is possible
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 当恢复可能时快照和增量队列的示例状态
- en: Applying the logic we just presented in *Figure 8**.2*, we first check the `snapshot_queued_msgs_`
    container to make sure we have a `SNAPSHOT_START` message and a `SNAPSHOT_END`
    message. We also make sure that we do not have any gaps in the snapshot messages
    by checking the sequence numbers, which start from zero and increment by one for
    each message. We find the last sequence number, which was used to synthesize this
    snapshot from the `SNAPSHOT_END` message and use the order ID field in that message,
    which in this case, is set to **776**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们在 *图8**.2* 中刚刚提出的逻辑，我们首先检查 `snapshot_queued_msgs_` 容器，以确保我们有一个 `SNAPSHOT_START`
    消息和一个 `SNAPSHOT_END` 消息。我们还通过检查序列号来确保快照消息中没有缺失，序列号从零开始，每条消息递增一。我们找到最后一个序列号，该序列号用于从
    `SNAPSHOT_END` 消息中合成这个快照，并使用该消息中的订单 ID 字段，在这种情况下，设置为 **776**。
- en: Once we determine that we have a complete sequence of snapshot messages, we
    check the queue of incremental market data updates. All queued-up incremental
    messages with a sequence number less than or equal to `checkSnapshotSync()` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定我们有一个完整的快照消息序列，我们将检查增量市场数据更新队列。所有队列中的增量消息，其序列号小于或等于 `checkSnapshotSync()`
    方法。
- en: 'First, we check if the `snapshot_queued_msgs_` container is empty. Obviously,
    we cannot recover since we need a full snapshot messages cycle and all the incremental
    messages from that point on to catch up with the incremental stream:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查 `snapshot_queued_msgs_` 容器是否为空。显然，我们无法恢复，因为我们需要一个完整的快照消息周期以及从那时起的所有增量消息来赶上增量流：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next thing we need to check is if we have `MEMarketUpdate` of the `MarketUpdateType::SNAPSHOT_START`
    type. Otherwise, we clear the queue and wait for the next round of snapshot messages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要检查的是是否存在 `MEMarketUpdate` 的 `MarketUpdateType::SNAPSHOT_START` 类型的更新。否则，我们将清空队列并等待下一轮快照消息：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will iterate through the queued snapshot messages and make sure that
    there is no gap in the snapshot messages we queued up by checking the sequence
    numbers. Remember that the key in the `snapshot_queued_msgs_` container is actually
    the `seq_num_` field from the `MDPMarketUpdate` messages. If we detect a gap in
    the snapshot messages, we set the `have_complete_snapshot` flag to `false` and
    exit out of the loop. We collect each message from the snapshot queue into the
    `final_events` container of type `std::vector` of `MEMarketUpdate` messages, which
    will be the container of all the events we will process if we successfully recover
    from this snapshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历队列中的快照消息，并确保我们队列中的快照消息没有缺失，通过检查序列号来实现。记住，`snapshot_queued_msgs_` 容器中的键实际上是来自
    `MDPMarketUpdate` 消息的 `seq_num_` 字段。如果我们检测到快照消息中的缺失，我们将 `have_complete_snapshot`
    标志设置为 `false` 并退出循环。我们将快照队列中的每条消息收集到 `final_events` 容器中，该容器是 `MEMarketUpdate`
    消息的 `std::vector` 类型，这将是我们从该快照成功恢复后要处理的全部事件的容器：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we finish the loop, we check the `have_complete_snapshot` flag to see
    if we found a gap in the snapshot messages or not. If the flag is set to `false`,
    meaning we found a gap, we clear the `snapshot_queued_msgs_` container and return,
    since we cannot recover and must wait for the next round of snapshot messages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成循环，我们将检查 `have_complete_snapshot` 标志，以查看我们是否在快照消息中找到了缺失。如果标志设置为 `false`，这意味着我们找到了缺失，我们将清空
    `snapshot_queued_msgs_` 容器并返回，因为我们无法恢复，必须等待下一轮快照消息：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Assuming we made it this far, we extract the last message in the queue of snapshot
    messages and make sure that it is of the `MarketUpdateType::SNAPSHOT_END` type
    since we will need to use the `order_id_` field in this message to process the
    incremental queue of messages:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经走到这一步，我们将从快照消息队列中提取最后一条消息，并确保它是 `MarketUpdateType::SNAPSHOT_END` 类型，因为我们需要使用该消息中的
    `order_id_` 字段来处理增量消息队列：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we move on to inspecting the queued incremental messages to see if we
    can synchronize successfully. We define a `have_complete_incremental` boolean
    flag, which will represent if we have all the messages from the incremental stream
    without any gaps. We also set the `next_exp_inc_seq_num_` member variable to be
    `last_snapshot_msg.order_id_ + 1` from the `SNAPSHOT_END` message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续检查队列中的增量消息，看看我们是否可以成功同步。我们定义一个 `have_complete_incremental` 布尔标志，它将表示我们是否拥有增量流中的所有消息，没有任何缺失。我们还设置
    `next_exp_inc_seq_num_` 成员变量为 `last_snapshot_msg.order_id_ + 1`，来自 `SNAPSHOT_END`
    消息：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we iterate through all the messages in our `incremental_queued_msgs_` container.
    We discard the messages that have sequence numbers less than the `next_exp_inc_seq_num_`
    variable we just assigned. Otherwise, we make sure that there are no gaps in the
    queue of incremental messages by making sure that the sequence number on the next
    message is equal to `next_exp_inc_seq_num_` and setting the `have_complete_incremental`
    flag to `false` if we detect a gap:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遍历`incremental_queued_msgs_`容器中的所有消息。我们丢弃序列号小于我们刚刚分配的`next_exp_inc_seq_num_`变量的消息。否则，我们确保增量消息队列中没有差距，通过确保下一个消息的序列号等于`next_exp_inc_seq_num_`，并在检测到差距时将`have_complete_incremental`标志设置为`false`：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we do not detect a gap in the market update message from the incremental
    queue, we add it to the `final_events` container as we did before. We also increment
    the `next_exp_inc_seq_num_` variable, since that is the next sequence number we
    expect if there are no gaps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在增量队列的市场更新消息中检测到差距，我们就像之前一样将其添加到`final_events`容器中。同时，我们也增加`next_exp_inc_seq_num_`变量，因为如果没有差距，这是我们期望的下一个序列号：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After exiting the loop, we check the `have_complete_incremental` flag to make
    sure there was no gap in the queue of incremental updates. If we did find a gap,
    we clear the `snapshot_queued_msgs_` container and return, since we cannot successfully
    synchronize:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出循环后，我们检查`have_complete_incremental`标志以确保增量更新队列中没有差距。如果我们确实发现了一个差距，我们就清除`snapshot_queued_msgs_`容器并返回，因为我们无法成功同步：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we have successfully recovered, so we iterate through all the
    `MEMarketUpdate` messages in the `final_events` container and write them to the
    `incoming_md_updates_` lock-free queue to be sent to the trading engine component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经成功恢复，因此我们遍历`final_events`容器中的所有`MEMarketUpdate`消息，并将它们写入`incoming_md_updates_`无锁队列，以便发送到交易引擎组件：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we clear the `snapshot_queued_msgs_` container and the `incremental_queued_msgs_`
    container and set the `in_recovery_` flag to `false` since we are no longer in
    recovery mode. Finally, we call the `McastSocket::leave()` method on `snapshot_mcast_socket_`,
    since we no longer need to be subscribed to the snapshot stream or receive or
    process the snapshot messages:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清除`snapshot_queued_msgs_`容器和`incremental_queued_msgs_`容器，并将`in_recovery_`标志设置为`false`，因为我们不再处于恢复模式。最后，我们在`snapshot_mcast_socket_`上调用`McastSocket::leave()`方法，因为我们不再需要订阅快照流或接收或处理快照消息：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this method, we have concluded the design and implementation of our `MarketDataConsumer`
    component. Next, we will move on to the topic of constructing the limit order
    book inside the trading engine from these market data update messages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们已经完成了我们的`MarketDataConsumer`组件的设计和实现。接下来，我们将从这些市场数据更新消息开始，讨论在交易引擎内部构建限价订单簿的话题。
- en: Building order books from market data
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从市场数据构建订单簿
- en: In the previous section, we built the market data consumer component, which
    subscribes to the market data stream, synchronizes between the snapshot and incremental
    streams, and decodes the market data updates and publishes them to the trading
    engine component. The trading engine component then needs to process these market
    data updates and build a limited order book like the one that the matching engine
    builds, except this is a much more limited version of the matching engine’s order
    book. As a reminder, we discussed this in the chapter *Designing Our Trading Ecosystem*
    in the *Designing a framework for low latency C++ trading algorithms* section.
    One last thing to note is that we will re-use the design and code of the order
    book in the matching engine to create the order book in the client’s system. We
    will re-use the source code we built in the chapter *Building the C++ Matching
    Engine* in the *Building the order book and matching orders* section. Now, let
    us get started with the implementation of the order book, which we will call `MarketOrderBook`,
    to easily differentiate it from the order book inside the matching engine, which
    was called `MEOrderBook`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了市场数据消费者组件，该组件订阅市场数据流，在快照流和增量流之间同步，并解码市场数据更新并将它们发布到交易引擎组件。交易引擎组件随后需要处理这些市场数据更新并构建一个类似于匹配引擎构建的限价订单簿，但这是一个比匹配引擎订单簿更为简化的版本。作为提醒，我们在“设计我们的交易生态系统”章节中讨论了这一点，该章节位于“设计低延迟C++交易算法框架”部分。最后要注意的一点是，我们将重用匹配引擎中订单簿的设计和代码来创建客户端系统中的订单簿。我们将重用我们在“构建C++匹配引擎”章节中构建的源代码，该章节位于“构建订单簿和匹配订单”部分。现在，让我们开始实现订单簿，我们将称之为`MarketOrderBook`，以便于与匹配引擎内部的订单簿区分开来，后者被称为`MEOrderBook`。
- en: Defining the structures for the market order book
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义市场订单簿的结构
- en: First, we will define the structures and types that make up the `MarketOrderBook`
    data structure. We use an identical design here as we did for the `MEOrderBook`
    class, and that design is presented in *Figure 8**.3*. We recommend revisiting
    the design of the order book and the motivation behind the different choices presented
    in the *Building the C++ Matching Engine* chapter in the *Designing the exchange
    order* *book* section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义构成`MarketOrderBook`数据结构的结构和类型。我们在这里使用的设计与`MEOrderBook`类中使用的相同设计，该设计在*图8.3*中展示。我们建议回顾订单簿的设计以及“构建C++匹配引擎”章节中在“设计交易所订单簿”部分提出的不同选择的动机。
- en: 'Each order is represented in a `MarketOrder` struct, which is a subset of the
    `MEOrder` struct we built for the matching engine. We will also have an `OrderHashMap`
    type, as we did in the matching engine, which will be a hash map from `OrderId`
    to these `MarketOrder` objects. Orders at the same price are held in a `MarketOrdersAtPrice`
    struct as we did in the matching engine, which will be a doubly linked list of
    `MarketOrder` objects. Remember that we need this structure to maintain all the
    orders with the same price and side attribute and arrange them in FIFO order.
    We will also build an `OrdersAtPriceHashMap` map, as we did in the matching engine
    to be a hash map from `Price` to these `MarketOrdersAtPrice` objects. The design
    is represented in *Figure 8**.3*, which is similar to the diagram we presented
    for the order book in the matching engine, except with different structures in
    this case:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个订单都由一个`MarketOrder`结构体表示，它是为我们为匹配引擎构建的`MEOrder`结构体的子集。我们还将有一个`OrderHashMap`类型，就像我们在匹配引擎中做的那样，它将是一个从`OrderId`到这些`MarketOrder`对象的哈希表。与匹配引擎中一样，相同价格的订单将保存在一个`MarketOrdersAtPrice`结构体中，这将是一个`MarketOrder`对象的双向链表。记住，我们需要这个结构来维护所有具有相同价格和买卖方向的订单，并按FIFO顺序排列。我们还将构建一个`OrdersAtPriceHashMap`映射，就像我们在匹配引擎中做的那样，它将是一个从`Price`到这些`MarketOrdersAtPrice`对象的哈希表。设计在*图8.3*中展示，与我们在匹配引擎中展示的订单簿图类似，但在这个情况下结构不同：
- en: '![Figure 8.3 – Architecture of the limit order book in the market participant’s
    trading engine](img/B19434_08_03.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 市场参与者交易引擎中限价订单簿的架构](img/B19434_08_03.jpg)'
- en: Figure 8.3 – Architecture of the limit order book in the market participant’s
    trading engine
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 市场参与者交易引擎中限价订单簿的架构
- en: All the source code for the structures and types we define in the next two sub-sections
    can be found in the `Chapter8/trading/strategy/market_order.h` source file and
    the `Chapter8/trading/strategy/market_order.cpp` source file. Let us get started
    with the `MarketOrderBook` implementation by first defining the data structures
    and types we will need.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下一两个子节中定义的结构体和类型的所有源代码都可以在 `Chapter8/trading/strategy/market_order.h` 源文件和
    `Chapter8/trading/strategy/market_order.cpp` 源文件中找到。让我们从定义我们将需要的结构体和类型开始，来开始 `MarketOrderBook`
    的实现。
- en: Defining the MarketOrder structure and OrderHashMap type
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 MarketOrder 结构体和 OrderHashMap 类型
- en: 'First, we will define the `MarketOrder` structure, which represents a single
    order in the market data stream. This structure contains the `OrderId`, `Side`,
    `Price`, `Qty`, and `Priority` attributes. It also contains a `prev_order_` and
    a `next_order_` member of type `MarketOrder` pointer since we will chain these
    objects in a doubly linked list:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义 `MarketOrder` 结构体，它代表市场数据流中的一个单个订单。这个结构体包含 `OrderId`、`Side`、`Price`、`Qty`
    和 `Priority` 属性。它还包含一个 `prev_order_` 和 `next_order_` 成员，类型为 `MarketOrder` 指针，因为我们将会将这些对象链成一个双链表：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The constructor is straightforward; it simply initializes the fields it is
    provided in the constructor:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数很简单；它只是初始化构造函数中提供的字段：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also define the `OrderHashMap` type, which is an `std::array` array of `MarketOrder`
    pointer objects and of size `ME_MAX_ORDER_IDS` `, in the` same way as we did in
    the matching engine order book:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了 `OrderHashMap` 类型，它是一个 `std::array` 数组，包含 `MarketOrder` 指针对象，大小为 `ME_MAX_ORDER_IDS`，与我们在匹配引擎订单簿中做的方式相同：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `toString()` method we will use for logging purposes is self-explanatory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于日志记录的 `toString()` 方法是显而易见的：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we will define the `MarketOrdersAtPrice` structure, which holds a linked
    list of `MarketOrder` objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `MarketOrdersAtPrice` 结构体，它包含一个指向 `MarketOrder` 对象链表的链接。
- en: Defining the MarketOrdersAtPrice structure and OrdersAtPriceHashMap type
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 MarketOrdersAtPrice 结构体和 OrdersAtPriceHashMap 类型
- en: 'The `MarketOrdersAtPrice` struct is identical to the `MEOrdersAtPrice` struct
    we built for the matching `MEOrderBook` engine. It contains `Side`, `Price`, and
    a `MarketOrder` `first_mkt_order_` pointer to represent the beginning of the `MarketOrder`-linked
    list at this price. It also contains two `MarketOrdersAtPrice` pointers, `prev_entry_`
    and `next_entry_`, since we will create a doubly linked list of `MarketOrdersAtPrice`
    objects to represent the price levels:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketOrdersAtPrice` 结构体与我们为匹配 `MEOrderBook` 引擎构建的 `MEOrdersAtPrice` 结构体相同。它包含
    `Side`、`Price` 以及一个指向 `MarketOrder` 的 `first_mkt_order_` 指针，以表示在此价格下 `MarketOrder`
    链表的开始。它还包含两个 `MarketOrdersAtPrice` 指针，`prev_entry_` 和 `next_entry_`，因为我们将会创建一个由
    `MarketOrdersAtPrice` 对象组成的双链表来表示价格层级：'
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The constructors for this class are self-explanatory. It simply initializes
    the data members with the arguments provided:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造函数是显而易见的。它只是用提供的参数初始化数据成员：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `toString()` method is identical to the one in the matching engine, so
    we will skip repeating it here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()` 方法与匹配引擎中的相同，所以我们在这里将跳过重复：'
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, `OrdersAtPriceHashMap` is identical to the one we built for the matching
    engine. It represents a hash map from `Price` to `MarketOrdersAtPrice` pointers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`OrdersAtPriceHashMap` 与我们为匹配引擎构建的相同。它表示一个从 `Price` 到 `MarketOrdersAtPrice`
    指针的哈希表：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we can finally implement the `MarketOrderBook` class in the next section,
    but before that, we need to define one more structure that will be used by various
    components to build a view of the **Best Bid** **Offer** (**BBO**).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在下一节中最终实现 `MarketOrderBook` 类，但在那之前，我们需要定义一个将用于各种组件以构建 **最佳买价** **卖价**（**BBO**）视图的结构体。
- en: Defining the BBO structure
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 BBO 结构体
- en: Finally, we need to define another structure that will represent the total quantity
    available at the best bid and ask prices. This will represent the best (most aggressive)
    buy and sell prices available in the market as well as the sum of the quantities
    of all the orders at those prices. This structure, called `bid_price_` and `ask_price_
    (`both `Price` types to represent the best prices), and `bid_qty_` and `ask_qty_`
    to represent the total quantity of all orders at these prices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义另一个结构体来表示在最佳买价和卖价下的总数量。这表示市场上可用的最佳（最激进的）买卖价格，以及那些价格下所有订单数量的总和。这个结构体称为
    `bid_price_` 和 `ask_price_`（都是 `Price` 类型，以表示最佳价格），以及 `bid_qty_` 和 `ask_qty_`
    以表示这些价格下所有订单的总数量。
- en: The BBO abstraction is used by many different components inside the trade engine.
    Typically, this is used by components that need a summary of the best market prices
    and liquidity, instead of the full depth of the book and all the details about
    each order in the book. For example, a component such as the `RiskManager` component,
    which only needs to compute the open `FeatureEngine`, `PositionKeeper`, `LiquidityTaker`,
    and `MarketMaker`, also use the BBO abstraction where the full order book is not
    needed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: BBO 抽象在交易引擎内部的不同组件中被广泛使用。通常，这被需要最佳市场价格和流动性的摘要而不是整个订单簿深度和每个订单详细信息的组件使用。例如，像 `RiskManager`
    这样的组件，它只需要计算开放的 `FeatureEngine`、`PositionKeeper`、`LiquidityTaker` 和 `MarketMaker`，也使用
    BBO 抽象，其中不需要完整的订单簿。
- en: 'To make it easy to log such objects, we will also add a `toString()` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于记录此类对象，我们还将添加一个 `toString()` 方法：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we can finally move on to our implementation of the `MarketOrderBook` class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以继续我们的 `MarketOrderBook` 类的实现。
- en: Defining the data members in the order book
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义订单簿中的数据成员
- en: To build the `MarketOrderBook` class, we first need to define the data members
    in this class. All the source code for this class can be found in the `Chapter8/trading/strategy/market_order_book.h`
    source file and the `Chapter8/trading/strategy/market_order_book.cpp` source file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `MarketOrderBook` 类，我们首先需要定义这个类中的数据成员。这个类的所有源代码都可以在 `Chapter8/trading/strategy/market_order_book.h`
    源文件和 `Chapter8/trading/strategy/market_order_book.cpp` 源文件中找到。
- en: 'The important data members in this class are the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的重要数据成员如下：
- en: A `trade_engine_` variable of the `TradeEngine` pointer type. We have not defined
    this class yet, but we will in this chapter. For now, it represents the class
    that is the trading engine framework. We will communicate changes to the order
    book using this variable.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `trade_engine_` 变量，其类型为 `TradeEngine` 指针类型。我们尚未定义这个类，但将在本章中定义它。目前，它代表的是交易引擎框架的类。我们将通过这个变量与订单簿进行通信。
- en: Two memory pools, `order_pool_` for `MarketOrder` objects and `orders_at_price_pool_`
    for `MarketOrdersAtPrice` objects, are to be used to allocate and deallocate these
    objects as needed. The first pool, `order_pool_`, is used to allocate and deallocate
    `MarketOrder` objects. The second pool, `orders_at_price_pool_`, is used to allocate
    and deallocate `MarketOrdersAtPrice` objects. Remember that a single `MemPool`
    instance is tied to a specific object type provided to it as a template parameter.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个内存池，`order_pool_` 用于 `MarketOrder` 对象，`orders_at_price_pool_` 用于 `MarketOrdersAtPrice`
    对象，将根据需要分配和释放这些对象。第一个池 `order_pool_` 用于分配和释放 `MarketOrder` 对象。第二个池 `orders_at_price_pool_`
    用于分配和释放 `MarketOrdersAtPrice` 对象。记住，一个 `MemPool` 实例与其提供的特定对象类型（作为模板参数提供）绑定在一起。
- en: A `bbo_` variable of the `BBO` type, which will be used to compute and maintain
    a `BBO`-view of the order book when there are updates and provided to any components
    that require it.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `bbo_` 变量，其类型为 `BBO`，将用于在更新时计算并维护订单簿的 `BBO` 视图，并将其提供给任何需要它的组件。
- en: An `oid_to_order_` variable of the `OrderHashMap` type will be used to track
    `MarketOrder` objects by `OrderId`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `oid_to_order_` 变量，其类型为 `OrderHashMap`，将用于通过 `OrderId` 跟踪 `MarketOrder` 对象。
- en: A `price_orders_at_price_` variable of the `OrdersAtPriceHashMap` type to track
    `OrdersAtPrice` objects by `Price`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `price_orders_at_price_` 变量，其类型为 `OrdersAtPriceHashMap`，用于通过 `Price` 跟踪 `OrdersAtPrice`
    对象。
- en: Two pointers to `MarketOrdersAtPrice` – `bids_by_price_` to represent the doubly
    linked list of bids sorted by price and `asks_by_price_` to represent the doubly
    linked list of asks sorted by price.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个指向 `MarketOrdersAtPrice` 的指针——`bids_by_price_` 用于表示按价格排序的双向链表中的出价，`asks_by_price_`
    用于表示按价格排序的双向链表中的要价。
- en: 'Finally, some variables that are not so important, such as `ticker_id_`, `time_str_`,
    and `logger_` for logging purposes:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一些不太重要的变量，例如用于记录的 `ticker_id_`、`time_str_` 和 `logger_`：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will also define a `MarketOrderBookHashMap` type, which is just a hash map
    from `TickerId` to `MarketOrderBook` objects of the `ME_MAX_TICKERS` size. This
    constant, as well as the others we will encounter in the next code snippet, were
    defined in the *Building the C++ Matching Engine* chapter in the *Defining the
    operations and interactions in our matching engine* section, within the *Defining
    some types and* *constants* sub-section:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个 `MarketOrderBookHashMap` 类型，它是一个从 `TickerId` 到 `MarketOrderBook` 对象的哈希表，大小为
    `ME_MAX_TICKERS`。这个常量，以及我们将在下一个代码片段中遇到的其它常量，都在 *构建 C++ 匹配引擎* 章节中的 *定义匹配引擎中的操作和交互*
    部分，以及 *定义一些类型和* *常量* 子部分中定义的：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we will see how to initialize the `MarketOrderBook` class and its member
    variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何初始化 `MarketOrderBook` 类及其成员变量。
- en: Initializing the order book
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化订单簿
- en: 'In this sub-section, we will implement the code to initialize the `MarketOrderBook`
    class as well as its internal data members. The constructor is straightforward
    and accepts the `TickerId` and `Logger` instances it will use to log. It initializes
    `orders_at_price_pool_` of `MarketOrdersAtPrice` objects to be of the `ME_MAX_PRICE_LEVELS`
    size and `order_pool_` of the `MarketOrder` objects to be of the `ME_MAX_ORDER_IDS`
    size:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现初始化 `MarketOrderBook` 类及其内部数据成员的代码。构造函数很简单，它接受将要用于记录的 `TickerId` 和
    `Logger` 实例。它初始化 `orders_at_price_pool_` 为 `MarketOrdersAtPrice` 对象的 `ME_MAX_PRICE_LEVELS`
    大小，并将 `order_pool_` 初始化为 `MarketOrder` 对象的 `ME_MAX_ORDER_IDS` 大小：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The destructor for this class just resets the internal data members:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的析构函数只是重置内部数据成员：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is an additional utility method called `setTradeEngine()`, which is a
    better method to set the `trade_engine_` variable with an instance of a `TradeEngine`
    object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `setTradeEngine()` 的附加实用方法，这是一个更好的方法来使用 `TradeEngine` 对象的实例设置 `trade_engine_`
    变量：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have seen how to initialize our `MarketOrderBook` class, we will
    discuss the most important functionality for this class, which is updating the
    order book from `MEMarketUpdate` messages that it will receive from the `TradeEngine`
    engine.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了如何初始化我们的 `MarketOrderBook` 类，我们将讨论这个类最重要的功能，即从 `TradeEngine` 引擎接收到的
    `MEMarketUpdate` 消息中更新订单簿。
- en: Processing market updates and updating the order book
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理市场更新和更新订单簿
- en: The `onMarketUpdate()` method is called along with the `MEMarketUpdate` message
    that needs to be processed. This method updates the order book from the market
    update, which is passed as an argument. We will understand the source code to
    handle these messages, but we will go code block by code block for each case of
    `MarketUpdateType`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMarketUpdate()` 方法会与需要处理的 `MEMarketUpdate` 消息一起被调用。此方法通过作为参数传递的市场更新来更新订单簿。我们将理解源代码以处理这些消息，但我们将逐个代码块地处理
    `MarketUpdateType` 的每个情况。'
- en: 'Before we get into the handling of the actual messages, we will first initialize
    a `bid_updated` boolean flag and an `ask_updated` boolean flag, which will represent
    if `BBO` will need to be updated because of this market update. We figure that
    out by checking if the market update we received corresponds to `side_ == Side::BUY`
    and `price_` of `market_update` is equal to or greater than `price_` of the current
    best bid, which we fetch from the `bids_by_price_->price_` variable. We do the
    same thing for the ask side by checking for `Side::SELL` on `market_update_->side_`
    and checking if `price_` of `market_update` is less than or equal to the price
    of the best ask (`asks_by_price_->price_`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理实际消息之前，我们首先初始化一个 `bid_updated` 布尔标志和一个 `ask_updated` 布尔标志，它们将表示由于这个市场更新，`BBO`
    是否需要更新。我们通过检查我们接收到的市场更新是否对应于 `side_ == Side::BUY` 和 `market_update` 的 `price_`
    等于或大于我们从 `bids_by_price_->price_` 变量获取的当前最佳出价来找出这一点。我们通过在 `market_update_->side_`
    上检查 `Side::SELL` 并检查 `market_update` 的 `price_` 是否小于或等于最佳要价（`asks_by_price_->price_`）来做同样的事情：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'First, we see the handling for `MarketUpdateType::ADD`. We will allocate a
    new `MarketOrder` object and call the `addOrder()` method on it. This `addOrder()`
    method is identical to the `addOrder()` method we built for the matching engine
    except it operates on `MarketOrder` and `MarketOrdersAtPrice` objects. We will
    discuss this `addOrder()` method briefly in the next sub-section, but we will
    not be fully re-implementing it since we have seen all the details in the *Building
    the C++ Matching* *Engine* chapter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到了对 `MarketUpdateType::ADD` 的处理。我们将分配一个新的 `MarketOrder` 对象，并在其上调用 `addOrder()`
    方法。这个 `addOrder()` 方法与我们为匹配引擎构建的 `addOrder()` 方法相同，但它操作 `MarketOrder` 和 `MarketOrdersAtPrice`
    对象。我们将在下一小节中简要讨论这个 `addOrder()` 方法，但我们将不会完全重新实现它，因为我们已经在 *Building the C++ Matching
    Engine* 章节中看到了所有细节：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The handling for the `MarketUpdateType::MODIFY` case finds the `MarketOrder`
    structure for which the modified message is targeted. It then updates the `qty_`
    attribute on that order:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `MarketUpdateType::MODIFY` 的情况的处理，找到目标修改消息的 `MarketOrder` 结构。然后，它更新该订单的 `qty_`
    属性：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The handling for `MarketUpdateType::CANCEL` is straightforward, and it finds
    `MarketOrder`, for which the cancel message is, and then calls the `removeOrder()`
    method on it. The `removeOrder()` method is also identical to the `removeOrder()`
    method we built for the matching engine order book in the *Building the C++ Matching
    Engine* chapter, except it operates on `MarketOrder` and `MarketOrdersAtPrice`
    objects. Again, we will not fully re-implement these methods since they are identical
    to what we have seen, and the details can be found in that chapter and the source
    files:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MarketUpdateType::CANCEL`的处理很简单，它会找到取消消息对应的`MarketOrder`，然后调用其上的`removeOrder()`方法。`removeOrder()`方法与我们在*构建C++撮合引擎*章节中构建的`removeOrder()`方法相同，除了它操作的是`MarketOrder`和`MarketOrdersAtPrice`对象。同样，我们不会完全重新实现这些方法，因为它们与我们之前看到的是相同的，详细信息可以在那一章和源文件中找到：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `MarketUpdateType::TRADE` messages do not change the order book, so here,
    we simply forward that trade message back to the `TradeEngine` engine using the
    `onTradeUpdate()` method. One thing to note here is that in the case of `MarketUpdateType::TRADE`,
    we simply return after calling the `TradeEngine::onTradeUpdate()` method. This
    is because the trade messages do not update the order book in our market data
    protocol, so the subsequent code after this `switch case` does not need to be
    executed:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketUpdateType::TRADE`消息不会改变订单簿，因此在这里，我们只需使用`onTradeUpdate()`方法将那条交易消息转发回`TradeEngine`引擎。这里需要注意的是，在`MarketUpdateType::TRADE`的情况下，我们在调用`TradeEngine::onTradeUpdate()`方法后直接返回。这是因为交易消息不会更新我们市场数据协议中的订单簿，所以在这个`switch
    case`之后的后续代码不需要执行：'
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `MarketOrderBook` class needs to handle the `MarketUpdateType::CLEAR` messages.
    It receives these messages when the book needs to be cleared because we dropped
    a packet and are recovering from the snapshot stream. All it does here is deallocate
    all the valid `MarketOrder` objects in the book and clear the `oid_to_order_`
    container by setting each entry to `nullptr`. It then iterates through the double-linked
    list starting with the `bids_by_price_` pointer and deallocates each `MarketOrdersAtPrice`
    object back to the `orders_at_price_pool_` memory pool. It does the same thing
    with the `asks_by_price_` linked list and, finally, sets both `bids_by_price_`
    and `asks_by_price_` to be `nullptr` to represent an empty book:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketOrderBook`类需要处理`MarketUpdateType::CLEAR`消息。当订单簿需要被清除，因为我们丢失了一个数据包并且正在从快照流中恢复时，它会接收到这些消息。在这里，它所做的只是释放订单簿中所有有效的`MarketOrder`对象，并通过将每个条目设置为`nullptr`来清除`oid_to_order_`容器。然后，它从`bids_by_price_`指针开始迭代双链表，并将每个`MarketOrdersAtPrice`对象释放回`orders_at_price_pool_`内存池。它对`asks_by_price_`链表做同样的处理，最后将`bids_by_price_`和`asks_by_price_`都设置为`nullptr`以表示一个空的订单簿：'
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `MarketOrderBook` class does not need to handle `INVALID`, `SNAPSHOT_START`,
    and `SNAPSHOT_END` `MarketUpdateType`s, so it does nothing with those messages:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketOrderBook`类不需要处理`INVALID`、`SNAPSHOT_START`和`SNAPSHOT_END`的`MarketUpdateType`s，因此对于这些消息它不做任何处理：'
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, we will call the `updateBBO()` method and pass it to the two
    boolean flags we computed: `bid_updated` and `ask_updated`. We will look at the
    implementation of this method shortly, but for now, you should understand that
    it will use the two boolean flags passed to it to decide if it needs to update
    the bid side or the ask side `BBO` values:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将调用`updateBBO()`方法，并将我们计算的两个布尔标志`bid_updated`和`ask_updated`传递给它。我们很快就会看到这个方法的实现，但你现在应该理解它将使用传递给它的两个布尔标志来决定是否需要更新出价或要价`BBO`值：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, it notifies the `TradeEngine` engine that the order book was updated
    using the `onOrderBookUpdate()` method, which we will discuss later in this chapter
    and enrich further in the next chapter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它通过`onOrderBookUpdate()`方法通知`TradeEngine`引擎订单簿已被更新，我们将在本章后面讨论该方法，并在下一章中进一步丰富它：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before we conclude this section, let us look at the implementation of the `updateBBO()`
    method we referred to before. The implementation itself is relatively straightforward,
    so let us look at the handling for the bid side first. Once we understand how
    we handle the bid side, understanding the ask side will be very simple since it
    is exactly the same. The first thing we do is check if the `update_bid` parameter
    passed to it is `true`. Only then do we have to update the bid side of the `BBO`
    object. Next, we check if the `bids_by_price_` member is not `nullptr`. If it
    is not valid, then we set the `bid_price_` variable and the `bid_qty_` variable
    to be invalid (`Price_INVALID` and `Qty_INVALID` respectively) since the side
    is empty. The more interesting handling is in the case where the `bids_by_price_`
    member is valid.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一节之前，让我们看看之前提到的`updateBBO()`方法的实现。实现本身相对简单，所以让我们先看看对买入方的处理。一旦我们了解了如何处理买入方，由于处理方式完全相同，理解卖出方将会非常简单。我们首先检查传递给它的`update_bid`参数是否为`true`。只有在这种情况下，我们才需要更新`BBO`对象的买入方。接下来，我们检查`bids_by_price_`成员是否不是`nullptr`。如果不是有效的，那么我们将`bid_price_`变量和`bid_qty_`变量设置为无效（分别为`Price_INVALID`和`Qty_INVALID`），因为这一侧是空的。更有趣的处理是在`bids_by_price_`成员有效的情况下。
- en: 'In that case, we set the bid_`price_` member variable in the `bbo_` object
    to be the price of the best bid: `bids_by_price_->price_`. To compute `bid_qty_`
    in the `bbo_` object, we first assign it `qty_` of the first order at that price
    level, which we access using the `bids_by_price_->first_mkt_order_->qty_` value.
    Then, we linearly iterate over all the orders at that price level by following
    the `next_order_` pointers until we wrap around, i.e. the `next_order_` points
    to the `first_mkt_order_` object. For each order we iterate over, we accumulate
    the `qty_` value of that order into the `bid_qty_` member in our `bbo_` object.
    At this point, we are done updating the bid side of the `BBO` object. Note here
    that the linear iteration is slightly inefficient and can be improved for example
    by tracking and updating these values during the processing of the `MEMarketUpdate`
    messages itself, but we leave that (simple) exercise up to the interested reader:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`bbo_`对象中的`bid_price_`成员变量设置为最佳买入价：`bids_by_price_->price_`。为了计算`bbo_`对象中的`bid_qty_`，我们首先将其分配为该价格水平上第一个订单的`qty_`值，我们通过`bids_by_price_->first_mkt_order_->qty_`值访问它。然后，我们通过跟随`next_order_`指针线性迭代该价格水平上的所有订单，直到我们绕回，即`next_order_`指向`first_mkt_order_`对象。对于我们迭代的每个订单，我们将该订单的`qty_`值累加到我们`bbo_`对象中的`bid_qty_`成员。到此，我们已经完成了对`BBO`对象买入方的更新。请注意，这里的线性迭代稍微低效，可以通过在处理`MEMarketUpdate`消息本身时跟踪和更新这些值来改进，但我们把这个（简单）练习留给感兴趣的读者：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The handling for the ask side of the `BBO` is identical to the handling for
    the bid side we just discussed. We will not repeat ourselves, but here is that
    handling:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BBO`的卖出方处理与之前讨论的买入方处理相同。我们不会重复，但这里是处理方法：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: That concludes most of the functionality we need in our `MarketOrderBook` class.
    In the next sub-section, we will quickly recap a couple of the utility methods
    we built for the order book in the matching engine, and we will replicate them
    for the trading engine’s order book.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们在`MarketOrderBook`类中需要的绝大部分功能。在下一小节中，我们将快速回顾一下我们在匹配引擎中为订单簿构建的一些实用方法，并将它们复制到交易引擎的订单簿中。
- en: Revisiting the generic utility methods for order book management
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视订单簿管理的通用实用方法
- en: In the *Building the C++ Matching Engine* chapter, we built `MEOrderBook` in
    the matching engine in the *Building the order book and matching* *orders* section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在*构建C++匹配引擎*章节中，我们在*构建订单簿和匹配* *订单*部分构建了`MEOrderBook`。
- en: 'We explained and implemented the `priceToIndex()` method and the `getOrdersAtPrice()`
    method in the *Building the internal data structures* sub-section. We have identical
    methods in our `MarketOrderBook` class, except they operate on `MarketOrdersAtPrice`
    instead of `MEOrdersAtPrice`. We will not discuss them again or re-implement them
    here, but we provide the signatures for those two methods:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*构建内部数据结构*子节中解释并实现了`priceToIndex()`方法和`getOrdersAtPrice()`方法。在我们的`MarketOrderBook`类中，我们有相同的方法，但它们操作的是`MarketOrdersAtPrice`而不是`MEOrdersAtPrice`。我们不会再次讨论或在这里重新实现它们，但提供了这两个方法的签名：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the *Handling new passive orders* sub-section in that chapter, we explained
    the logic and implemented the methods `addOrder()` and `addOrdersAtPrice()`. Again,
    for the `MarketOrderBook` class, the logic is identical except it operates on
    `MarketOrder` instead of the `MEOrder` structure and `MarketOrdersAtPrice` objects
    instead of `MEOrdersAtPrice` objects. The signatures for those two methods in
    the `MarketOrderBook` class are presented here, but we will skip repeating the
    explanation and source code here since it is identical:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在该章节的*处理新被动订单*子节中，我们解释了逻辑并实现了`addOrder()`和`addOrdersAtPrice()`方法。同样，对于`MarketOrderBook`类，逻辑是相同的，只是它操作的是`MarketOrder`结构而不是`MEOrder`结构，以及`MarketOrdersAtPrice`对象而不是`MEOrdersAtPrice`对象。这里展示了`MarketOrderBook`类中这两个方法的签名，但我们将跳过重复的解释和源代码，因为它们是相同的：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Similarly, in the *Handling order cancellation requests* sub-section, we covered
    the details behind the `removeOrder()` and `removeOrdersAtPrice()` methods. Again,
    for our `MarketOrderBook` class, these methods work exactly the same except they
    operate on the `MarketOrder` and `MarketOrdersAtPrice` structures:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在*处理订单取消请求*子节中，我们介绍了`removeOrder()`和`removeOrdersAtPrice()`方法背后的细节。同样，对于我们的`MarketOrderBook`类，这些方法的工作方式完全相同，只是它们操作的是`MarketOrder`和`MarketOrdersAtPrice`结构：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This concludes the design and implementation of the order book inside the trading
    engine framework. Next, we need to discuss the order gateway infrastructure component,
    which is what the `TradeEngine` component will use to communicate with the electronic
    trading exchange.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了交易引擎框架内订单簿的设计和实现。接下来，我们需要讨论订单网关基础设施组件，这是`TradeEngine`组件将用于与电子交易交易所通信的。
- en: Connecting to the exchange and sending and receiving order flow
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到交易所并发送和接收订单流
- en: The order gateway client component in the market participant’s trading infrastructure
    receives order requests from the trading engine through a lock-free queue and
    sends order responses back to the trading engine through another lock-free queue.
    It also establishes a TCP connection to the order gateway server in the exchange
    side infrastructure. It encodes order requests in the exchange’s order format
    and sends them over the TCP connection. It also consumes order responses sent
    by the exchange over that TCP connection and decodes them from the order data
    format. We present the order gateway client diagram again to refresh your memory
    on that component’s design.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者交易基础设施中的订单网关客户端组件通过无锁队列从交易引擎接收订单请求，并通过另一个无锁队列将订单响应发送回交易引擎。它还在交易所基础设施的订单网关服务器上建立了一个TCP连接。它将订单请求编码为交易所的订单格式，并通过TCP连接发送。它还消耗通过该TCP连接发送的订单响应，并将它们从订单数据格式解码。我们再次展示订单网关客户端图，以刷新您对该组件设计的记忆。
- en: '![Figure 8.4 – Diagram presenting the order gateway client component inside
    the client’s trading infrastructure](img/B19434_08_04.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 展示客户端交易基础设施中订单网关客户端组件的图](img/B19434_08_04.jpg)'
- en: Figure 8.4 – Diagram presenting the order gateway client component inside the
    client’s trading infrastructure
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 展示客户端交易基础设施中订单网关客户端组件的图
- en: We will start the implementation of this order gateway client component by defining
    the internal data members of that class first. All the source code for the order
    gateway client component is in the `Chapter8/trading/order_gw/order_gateway.h`
    source file and the `Chapter8/trading/order_gw/order_gateway.cpp` source files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义该类内部的数据成员来开始实现这个订单网关客户端组件。订单网关客户端组件的所有源代码都在`Chapter8/trading/order_gw/order_gateway.h`源文件和`Chapter8/trading/order_gw/order_gateway.cpp`源文件中。
- en: Defining the data members in the order gateway client
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义订单网关客户端的数据成员
- en: 'The important data members in the `OrderGateway` class are described here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderGateway`类中的重要数据成员在此描述：'
- en: Two lock-free queue pointers. The first one is named `outgoing_requests_` of
    the `ClientRequestLFQueue` type, which we defined before as an `LFQueue` instance
    of `MEClientRequest` structures. The other member is called `incoming_responses_`,
    which is of the `ClientResponseLFQueue` type, which we also defined earlier as
    an `LFQueue` instance of the `MEClientResponse` structures. These will be used
    by `OrderGateway` to receive order requests and send order responses to `TradeEngine`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个无锁队列指针。第一个是名为 `outgoing_requests_` 的 `ClientRequestLFQueue` 类型，这是我们之前定义的 `LFQueue`
    实例的 `MEClientRequest` 结构。另一个成员称为 `incoming_responses_`，它是 `ClientResponseLFQueue`
    类型，我们之前也定义了它作为 `MEClientResponse` 结构的 `LFQueue` 实例。这些将由 `OrderGateway` 用于接收订单请求并向
    `TradeEngine` 发送订单响应。
- en: It also contains a `tcp_socket_` member variable of the `TCPSocket` type, which
    is the TCP socket client to be used to connect to the exchange order gateway server
    and to send and receive messages.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还包含一个 `tcp_socket_` 成员变量，类型为 `TCPSocket`，这是用于连接到交易所订单网关服务器并发送和接收消息的 TCP 套接字客户端。
- en: Two `size_t` variables to represent sequence numbers. The first one, `next_outgoing_seq_num_`,
    tracks the sequence number that will be sent on the next outgoing `OMClientRequest`
    message sent to the exchange. The second one, `next_exp_seq_num_`, is used to
    check and validate that the `OMClientResponse` messages received from the exchange
    are in sequence.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `size_t` 变量用于表示序列号。第一个，`next_outgoing_seq_num_`，跟踪下一次发送到交易所的 `OMClientRequest`
    消息的序列号。第二个，`next_exp_seq_num_`，用于检查和验证从交易所接收到的 `OMClientResponse` 消息是否按顺序。
- en: A boolean `run_` flag, which serves a similar purpose as it did in all the other
    components we saw before. It will be used to start and stop the execution of the
    `OrderGateway` thread and is marked `volatile` since it is accessed from different
    threads.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔 `run_` 标志，它在我们之前看到的所有其他组件中起着类似的作用。它将用于启动和停止 `OrderGateway` 线程的执行，并且因为它被不同的线程访问，所以被标记为
    `volatile`。
- en: It also saves the network interface in the `iface_` variable and the IP and
    port of the exchange’s order gateway server in the `ip_` and `port_` member variables.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还保存网络接口在 `iface_` 变量中，以及交易所订单网关服务器的 IP 和端口在 `ip_` 和 `port_` 成员变量中。
- en: 'Finally, it stores the `client_id_` variable of the `ClientId` type to make
    sure that responses received on the TCP socket are meant for the correct client:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它存储 `ClientId` 类型的 `client_id_` 变量，以确保通过 TCP 套接字接收到的响应是针对正确客户端的：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the next section, we will initialize these data members as well as the `OrderGateway`
    class itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将初始化这些数据成员以及 `OrderGateway` 类本身。
- en: Initializing the order gateway client
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化订单网关客户端
- en: 'The constructor accepts the `client_id` ID of the trading client, a pointer
    to a `ClientRequestsLFQueue` object (`client_requests`), a pointer to a `ClientResponseLFQueue`
    object (`client_responses`), and the `ip`, `port`, and interface information (`iface`)
    for the TCP connection. It initializes its own internal variables with these arguments
    and initializes the `Logger` data member (`logger_`) with a filename for the order
    gateway logs for this client. It updates the `recv_callback_` member inside the
    `tcp_socket_` variable of the `TCPSocket` type so that callbacks dispatched on
    data reads will go to the `OrderGateway::recvCallback()` method. We will see the
    implementation of that method briefly:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受交易客户端的 `client_id` ID，一个指向 `ClientRequestsLFQueue` 对象的指针（`client_requests`），一个指向
    `ClientResponseLFQueue` 对象的指针（`client_responses`），以及 TCP 连接的 `ip`、`port` 和接口信息（`iface`）。它使用这些参数初始化自己的内部变量，并使用该客户端的订单网关日志文件名初始化
    `Logger` 数据成员（`logger_`）。它更新 `tcp_socket_` 变量中的 `TCPSocket` 类型的 `recv_callback_`
    成员，以便在数据读取上分发的回调将转到 `OrderGateway::recvCallback()` 方法。我们将简要地看到该方法的实现：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Like the design of our other components, we will add a `start()` method, which
    will enable the `run_` flag and create and launch a thread to execute the `run()`
    method. We will also initialize our `tcp_socket_` member variable and have it
    connect to the `ip_` and `port_` interface information of the order gateway server
    at the exchange:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们其他组件的设计一样，我们将添加一个 `start()` 方法，它将启用 `run_` 标志并创建和启动一个线程来执行 `run()` 方法。我们还将初始化我们的
    `tcp_socket_` 成员变量，并将其连接到交易所订单网关服务器的 `ip_` 和 `port_` 接口信息：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The destructor for the `OrderGateway` class calls the `stop()` method to stop
    the execution of the `run()` method and waits for a little bit before returning:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderGateway` 类的析构函数调用 `stop()` 方法来停止 `run()` 方法的执行，并在返回之前等待一小段时间：'
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `stop()` method simply sets the `run_` flag to be `false` to stop the execution
    of the `run()` loop:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop()`方法简单地将`run_`标志设置为`false`以停止`run()`循环的执行：'
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we can move on to the two remaining important tasks: sending order requests
    to the exchange and receiving order responses from the exchange.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续处理剩下的两个重要任务：向交易所发送订单请求和接收交易所的订单响应。
- en: Sending order requests to the exchange
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向交易所发送订单请求
- en: In this sub-section, we will implement the `run()` method, which is the main
    loop for the `OrderGateway` class. The goal of this method is to send out any
    client requests that are ready to be sent out on the TCP socket to read any data
    available on the socket and dispatch the `recv_callback_()` method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现`run()`方法，这是`OrderGateway`类的主要循环。该方法的目标是发送任何准备通过TCP套接字发送的客户端请求，读取套接字上可用的任何数据，并调度`recv_callback_()`方法。
- en: 'First, it calls the `TCPSocket::sendAndRecv()` method to send and receive data
    on the established TCP connection:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它调用`TCPSocket::sendAndRecv()`方法在建立的TCP连接上发送和接收数据：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It also reads any `MEClientRequest` messages available on the `outgoing_requests_`
    `LFQueue` sent by the `TradeEngine` engine and writes them to the `tcp_socket_`
    send buffer using the `TCPSocket::send()` method. Note that it needs to write
    out `OMClientRequest` messages, which it achieves by first writing the `next_outgoing_seq_num_`
    field and then the `MEClientRequest` object that the `TradeEngine` sent. This
    works because we designed the `OMClientRequest` object to be a struct that contains
    a `size_t seq_num_` field followed by a `MEClientRequest` object. We also increment
    the `next_outgoing_seq_num_` instance for the next outgoing socket message:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它还读取`outgoing_requests_` `LFQueue`上由`TradeEngine`引擎发送的任何`MEClientRequest`消息，并使用`TCPSocket::send()`方法将它们写入`tcp_socket_`发送缓冲区。请注意，它需要写入`OMClientRequest`消息，这是通过首先写入`next_outgoing_seq_num_`字段，然后写入`TradeEngine`发送的`MEClientRequest`对象来实现的。这是因为我们设计了`OMClientRequest`对象，使其成为一个包含`size_t
    seq_num_`字段和随后的`MEClientRequest`对象的struct。我们还为下一个出站套接字消息增加了`next_outgoing_seq_num_`实例：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will deal with the task of receiving and processing order responses that
    the exchange sends to the TCP connection `OrderGateway` establishes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理接收和处理交易所发送到`OrderGateway`建立的TCP连接的订单响应的任务。
- en: Processing order responses from the exchange
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理来自交易所的订单响应
- en: 'The `recvCallback()` method is called when there is data available on the `tcp_socket_`
    and the `TCPSocket::sendAndRecv()` method is called from the `run()` method in
    the previous section. We go through the `rcv_buffer_` buffer on `TCPSocket` and
    re-interpret the data as `OMClientResponse` messages:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当`tcp_socket_`上有数据可用时，`recvCallback()`方法会被调用，并且在前一节的`run()`方法中调用`TCPSocket::sendAndRecv()`方法。我们遍历`TCPSocket`上的`rcv_buffer_`缓冲区，并将数据重新解释为`OMClientResponse`消息：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For the `OMClientResponse` message we just read into the response variable,
    we check to make sure the client ID on the response matches the `OrderGateway`’s
    client ID and ignore the response if it does not match:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们刚刚读取到响应变量的`OMClientResponse`消息，我们检查以确保响应中的客户端ID与`OrderGateway`的客户端ID匹配，如果不匹配则忽略该响应：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We also check to make sure that the sequence number on `OMClientResponse` matches
    what we expect it to be. If there is a mismatch, we log an error and ignore the
    response. There is an opportunity to improve the error handling here, but for
    the sake of simplicity, we just log an error and continue:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查`OMClientResponse`上的序列号是否与我们期望的一致。如果存在不匹配，我们将记录错误并忽略响应。这里有机会改进错误处理，但为了简单起见，我们只是记录错误并继续：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, we increment the expected sequence number on the next `OMClientResponse`
    and write the response we just read to the `incoming_responses_` `LFQueue` for
    the `TradeEngine` to read. It also updates the `rcv_buffer_` buffer and the next
    receive index into the `TCPSocket` buffer we just consumed some messages from:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在下一个`OMClientResponse`上增加预期的序列号，并将我们刚刚读取的响应写入`incoming_responses_` `LFQueue`以供`TradeEngine`读取。它还更新了`rcv_buffer_`缓冲区和我们从其中消耗了一些消息的下一个接收索引到`TCPSocket`缓冲区：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this method implementation, we have finished the design and implementation
    of the `OrderGateway` component. That will be all the core infrastructure components
    we build in this chapter, and we will summarize everything we worked on in the
    next chapter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此方法实现，我们已经完成了`OrderGateway`组件的设计和实现。这将是本章中构建的所有核心基础设施组件，我们将在下一章总结我们所做的工作。
- en: One important note is that we will need to build all the components presented
    in this chapter as well as the *Building the C++ Trading Algorithm Building Blocks*
    and *Building the C++ Market Making and Liquidity Taking Algorithms* chapters
    before we can build and run a meaningful trading client. Since our ecosystem consists
    of a server (trading exchange) and client (trading client) infrastructure, we
    will need to wait until the *Building and running the main trading application*
    section in the *Building the C++ Market Making and Liquidity Taking Algorithms*
    chapter before we can run the full ecosystem.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，在我们能够构建和运行一个有意义的交易客户端之前，我们需要构建本章中展示的所有组件，以及《构建C++交易算法构建块》和《构建C++市场做市和流动性获取算法》章节中的所有组件。由于我们的生态系统由服务器（交易交易所）和客户端（交易客户端）基础设施组成，因此我们需要等待《构建C++市场做市和流动性获取算法》章节中的《构建和运行主要交易应用》部分，然后我们才能运行完整的生态系统。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to building the important core infrastructure components
    inside the market participant’s trading system. First, we build the market data
    consumer component, which is responsible for subscribing to the multicast market
    data stream generated by the exchange. It needs to detect gaps in market data
    updates on the incremental market data stream and initiate snapshot recovery and
    synchronization mechanisms to re-synchronize with the incremental market data
    stream. It decodes the market data updates from the format that the exchange publishes
    to a simpler internal market data format.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于构建市场参与者交易系统中的重要核心基础设施组件。首先，我们构建了市场数据消费者组件，该组件负责订阅由交易所生成的多播市场数据流。它需要检测增量市场数据流中市场数据更新的差距，并启动快照恢复和同步机制以重新与增量市场数据流同步。它将交易所发布的数据格式解码为更简单的内部市场数据格式。
- en: The order book sub-component inside the trading engine component processes the
    market data updates it receives from the market data consumer. It builds and updates
    an order book data structure from these updates for the trading engine to get
    an accurate view of the market.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 交易引擎组件内部的处理订单簿子组件处理它从市场数据消费者接收到的市场数据更新。它从这些更新中构建和更新订单簿数据结构，以便交易引擎能够获得对市场的准确视图。
- en: The order gateway component inside the trading system establishes and maintains
    a bi-directional TCP connection with the electronic trading exchange. It receives
    order action requests from the trading engine and sends them out to the exchange
    in the exchange’s order data format. It also receives order responses that the
    exchange sends to the trading client, decodes them, and forwards them to the trading
    engine.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 交易系统内部的订单网关组件与电子交易交易所建立并维护双向TCP连接。它从交易引擎接收订单操作请求，并以交易所的订单数据格式将它们发送到交易所。它还接收交易所发送给交易客户端的订单响应，解码它们，并将它们转发给交易引擎。
- en: Note that we do not have everything we need in the trading client’s trading
    system, that is, we are missing the components we need to build and run trading
    strategies and associated components. The next chapter will build the additional
    components we need in the trading strategy framework. The chapter after that will
    tie all the components together and finish the final trading application and the
    full trading ecosystem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并不在交易客户端的交易系统中拥有我们所需要的一切，也就是说，我们缺少构建和运行交易策略及其相关组件所需的组件。下一章将构建交易策略框架中所需的附加组件。随后的章节将把这些组件连接起来，完成最终的交易应用和完整的交易生态系统。
