["```cpp\nsf::SoundBuffer buffer;\nbuffer.loadFromFile(\"SomeSound.ogg\");\n\nsf::Sound sound(buffer);\nsound.setBuffer(buffer); // Alternative.\n```", "```cpp\nsound.play(); // Play the sound!\n```", "```cpp\nsound.pause(); // Pause the sound.\nsound.stop(); // Stop the sound.\n```", "```cpp\nsf::SoundSource::Status status = sound.getStatus();\n```", "```cpp\nsound.setVolume(100.f); // Takes in a float.\nsound.setPitch(1.f); // Takes in a float.\nsound.setLoop(true); // Takes in a Boolean.\nsound.setPlayingOffset(sf::seconds(5.f)); // Takes in sf::Time.\n```", "```cpp\nsf::Music music;\nmusic.openFromFile(\"SomeMusic.ogg\");\nmusic.play();\n...\nmusic.stop();\n```", "```cpp\nsf::Music music;\nsf::Music music2 = music; // ERROR!\n```", "```cpp\nsf::Listener::setPosition(5.f, 0.f, 5.f);\nsf::Listener::setDirection(1.f, 0.f, 0.f);\n```", "```cpp\nsf::Listener::setDirection(1.f, 0.f, 1.f);\nsf::Listener::setDirection(0.5f, 0.f, 0.5f);\n```", "```cpp\nsf::Sound sound;\nsound.setPosition(5.f, 0.f, 5.f);\n```", "```cpp\nsound.setMinDistance(6.f);\nsound.setAttenuation(2.f);\n```", "```cpp\nclass AudioManager : public ResourceManager<\n  AudioManager, sf::SoundBuffer>\n{\npublic:\n  AudioManager() : ResourceManager(\"audio.cfg\"){}\n\n  sf::SoundBuffer* Load(const std::string& l_path){\n    sf::SoundBuffer* sound = new sf::SoundBuffer();\n    if (!sound->loadFromFile(\n      Utils::GetWorkingDirectory() + l_path))\n    {\n      delete sound;\n      sound = nullptr;\n      std::cerr << \"! Failed to load sound: \"\n        << l_path << std::endl;\n    }\n    return sound;\n  }\n};\n```", "```cpp\nFootstep media/Audio/footstep.ogg\nTownTheme media/Audio/TownTheme.ogg\n```", "```cpp\nstruct SoundProps{\n    SoundProps(const std::string& l_name): m_audioName(l_name), m_volume(100), m_pitch(1.f), m_minDistance(10.f), m_attenuation(10.f){}\n    std::string m_audioName;\n    float m_volume;\n    float m_pitch;\n    float m_minDistance;\n    float m_attenuation;\n};\n```", "```cpp\nAudio Footstep\nVolume 25\nPitch 1.0\nDistance 150\nAttenuation 2\n```", "```cpp\nusing SoundID = int;\n```", "```cpp\nstruct SoundInfo{\n    SoundInfo(const std::string& l_name): m_name(l_name), m_manualPaused(false){}\n    std::string m_name;\n    bool m_manualPaused;\n};\n```", "```cpp\nusing SoundProperties = std::unordered_map<std::string,\n  SoundProps>;\nusing SoundContainer = std::unordered_map<SoundID,\n  std::pair<SoundInfo, sf::Sound*>>;\nusing Sounds = std::unordered_map<StateType, SoundContainer>;\nusing RecycledSounds = std::vector<std::pair<\n  std::pair<SoundID, std::string>, sf::Sound*>>;\nusing MusicContainer = std::unordered_map<StateType,\n  std::pair<SoundInfo, sf::Music*>>;\n```", "```cpp\nclass SoundManager{\npublic:\n  SoundManager(AudioManager* l_audioMgr);\n  ~SoundManager();\n\n  void ChangeState(const StateType& l_state);\n  void RemoveState(const StateType& l_state);\n\n  void Update(float l_dT);\n\n  SoundID Play(const std::string& l_sound, \n    const sf::Vector3f& l_position, \n    bool l_loop = false, \n    bool l_relative = false);\n  bool Play(const SoundID& l_id);\n  bool Stop(const SoundID& l_id);\n  bool Pause(const SoundID& l_id);\n\n  bool PlayMusic(const std::string& l_musicId,\n    float l_volume = 100.f, bool l_loop = false);\n  bool PlayMusic(const StateType& l_state);\n  bool StopMusic(const StateType& l_state);\n  bool PauseMusic(const StateType& l_state);\n\n  bool SetPosition(const SoundID& l_id, const sf::Vector3f& l_pos);\n  bool IsPlaying(const SoundID& l_id);\n  SoundProps* GetSoundProperties(const std::string& l_soundName);\n\n  static const int Max_Sounds = 150;\n  static const int Sound_Cache = 75;\nprivate:\n  bool LoadProperties(const std::string& l_file);\n  void PauseAll(const StateType& l_state);\n  void UnpauseAll(const StateType& l_state);\n\n  sf::Sound* CreateSound(SoundID& l_id,\n    const std::string& l_audioName);\n  void SetUpSound(sf::Sound* l_snd, const SoundProps* l_props, \n    bool l_loop = false, bool l_relative = false);\n  bool RecycleSound(const SoundID& l_id, sf::Sound* l_snd,\n    const std::string& l_name);\n\n  void Cleanup();\n\n  Sounds m_audio;\n  MusicContainer m_music;\n  RecycledSounds m_recycled;\n  SoundProperties m_properties;\n  StateType m_currentState;\n\n  SoundID m_lastID;\n  unsigned int m_numSounds;\n  float m_elapsed;\n\n  AudioManager* m_audioManager;\n};\n```", "```cpp\nSoundManager::SoundManager(AudioManager* l_audioMgr)\n    : m_lastID(0), m_audioManager(l_audioMgr), \n    m_elapsed(0.f), m_numSounds(0){}\n\nSoundManager::~SoundManager(){ Cleanup(); }\n```", "```cpp\nvoid SoundManager::ChangeState(const StateType& l_state){\n  PauseAll(m_currentState);\n  UnpauseAll(l_state);\n  m_currentState = l_state;\n\n  if (m_music.find(m_currentState) != m_music.end()){ return; }\n  SoundInfo info(\"\");\n  sf::Music* music = nullptr;\n  m_music.emplace(m_currentState, std::make_pair(info, music));\n}\n```", "```cpp\nvoid SoundManager::RemoveState(const StateType& l_state){\n  auto& StateSounds = m_audio.find(l_state)->second;\n  for (auto &itr : StateSounds){\n    RecycleSound(itr.first, itr.second.second,\n      itr.second.first.m_name);\n  }\n  m_audio.erase(l_state);\n  auto music = m_music.find(l_state);\n  if (music == m_music.end()){ return; }\n  if (music->second.second){\n    delete music->second.second;\n    --m_numSounds;\n  }\n  m_music.erase(l_state);\n}\n```", "```cpp\nvoid SoundManager::Cleanup(){\n  for (auto &state : m_audio){\n    for (auto &sound : state.second){\n      m_audioManager->ReleaseResource(sound.second.first.m_name);\n      delete sound.second.second;\n    }\n  }\n  m_audio.clear();\n  for (auto &recycled : m_recycled){\n    m_audioManager->ReleaseResource(recycled.first.second);\n    delete recycled.second;\n  }\n  m_recycled.clear();\n  for (auto &music : m_music){\n    if (music.second.second){ \n      delete music.second.second;\n    }\n  }\n  m_music.clear();\n\n  m_properties.clear();\n  m_numSounds = 0;\n  m_lastID = 0;\n}\n```", "```cpp\nvoid SoundManager::Update(float l_dT){\n  m_elapsed += l_dT;\n  if (m_elapsed < 0.33f){ return; }\n  // Run once every third of a second.\n  m_elapsed = 0;\n  auto& container = m_audio[m_currentState];\n  for (auto itr = container.begin(); itr != container.end();){\n    if (!itr->second.second->getStatus()){\n      RecycleSound(itr->first, itr->second.second,\n        itr->second.first.m_name);\n      itr = container.erase(itr); // Remove sound.\n      continue;\n    }\n    ++itr;\n  }\n  auto music = m_music.find(m_currentState);\n  if (music == m_music.end()){ return; }\n  if (!music->second.second){ return; }\n  if (music->second.second->getStatus()){ return; }\n  delete music->second.second;\n  music->second.second = nullptr;\n  --m_numSounds;\n}\n```", "```cpp\nSoundID SoundManager::Play(const std::string& l_sound,\n  const sf::Vector3f& l_position, bool l_loop, bool l_relative)\n{\n  SoundProps* props = GetSoundProperties(l_sound);\n  if (!props){ return -1; } // Failed to load sound properties.\n  SoundID id;\n  sf::Sound* sound = CreateSound(id, props->m_audioName);\n  if (!sound){ return -1; }\n  // Sound created successfully.\n  SetUpSound(sound, props, l_loop, l_relative);\n  sound->setPosition(l_position);\n  SoundInfo info(props->m_audioName);\n  m_audio[m_currentState].emplace(id,std::make_pair(info, sound));\n  sound->play();\n  return id;\n}\n```", "```cpp\nbool SoundManager::Play(const SoundID& l_id){\n  auto& container = m_audio[m_currentState];\n  auto sound = container.find(l_id);\n  if (sound == container.end()){ return false; }\n  sound->second.second->play();\n  sound->second.first.m_manualPaused = false;\n  return true;\n}\n```", "```cpp\nbool SoundManager::Stop(const SoundID& l_id){\n  auto& container = m_audio[m_currentState];\n  auto sound = container.find(l_id);\n  if (sound == container.end()){ return false; }\n  sound->second.second->stop();\n  sound->second.first.m_manualPaused = true;\n  return true;\n}\n```", "```cpp\nbool SoundManager::Pause(const SoundID& l_id){\n  auto& container = m_audio[m_currentState];\n  auto sound = container.find(l_id);\n  if (sound == container.end()){ return false; }\n  sound->second.second->pause();\n  sound->second.first.m_manualPaused = true;\n  return true;\n}\n```", "```cpp\nbool SoundManager::PlayMusic(const std::string& l_musicId,\n  float l_volume, bool l_loop)\n{\n  auto s = m_music.find(m_currentState);\n  if (s == m_music.end()){ return false; }\n  std::string path = m_audioManager->GetPath(l_musicId);\n  if (path == \"\"){ return false; }\n  if (!s->second.second){\n    s->second.second = new sf::Music();\n    ++m_numSounds;\n  }\n  sf::Music* music = s->second.second;\n  if (!music->openFromFile(Utils::GetWorkingDirectory() + path)){\n    delete music;\n    --m_numSounds;\n    s->second.second = nullptr;\n    std::cerr << \"[SoundManager] Failed to load music from file: \"\n      << l_musicId << std::endl;\n    return false;\n  }\n  music->setLoop(l_loop);\n  music->setVolume(l_volume);\n  music->setRelativeToListener(true); // Always relative.\n  music->play();\n  s->second.first.m_name = l_musicId;\n  return true;\n}\n```", "```cpp\nbool SoundManager::PlayMusic(const StateType& l_state){\n  auto music = m_music.find(m_currentState);\n  if (music == m_music.end()){ return false; }\n  if (!music->second.second){ return false; }\n  music->second.second->play();\n  music->second.first.m_manualPaused = false;\n  return true;\n}\nbool SoundManager::StopMusic(const StateType& l_state){\n  auto music = m_music.find(m_currentState);\n  if (music == m_music.end()){ return false; }\n  if (!music->second.second){ return false; }\n  music->second.second->stop();\n  delete music->second.second;\n  music->second.second = nullptr;\n  --m_numSounds;\n  return true;\n}\nbool SoundManager::PauseMusic(const StateType& l_state){\n  auto music = m_music.find(m_currentState);\n  if (music == m_music.end()){ return false; }\n  if (!music->second.second){ return false; }\n  music->second.second->pause();\n  music->second.first.m_manualPaused = true;\n  return true;\n}\n```", "```cpp\nbool SoundManager::SetPosition(const SoundID& l_id,\n  const sf::Vector3f& l_pos)\n{\n  auto& container = m_audio[m_currentState];\n  auto sound = container.find(l_id);\n  if (sound == container.end()){ return false; }\n  sound->second.second->setPosition(l_pos);\n  return true;\n}\n```", "```cpp\nbool SoundManager::IsPlaying(const SoundID& l_id){\n  auto& container = m_audio[m_currentState];\n  auto sound = container.find(l_id);\n  return (sound != container.end() ?\n    sound->second.second->getStatus() : false);\n}\n```", "```cpp\nSoundProps* SoundManager::GetSoundProperties(\n  const std::string& l_soundName)\n{\n  auto& properties = m_properties.find(l_soundName);\n  if (properties == m_properties.end()){\n    if (!LoadProperties(l_soundName)){ return nullptr; }\n    properties = m_properties.find(l_soundName);\n  }\n  return &properties->second;\n}\n```", "```cpp\nbool SoundManager::LoadProperties(const std::string& l_name){\n  std::ifstream file;\n  file.open(Utils::GetWorkingDirectory() +\n    \"media/Sounds/\" + l_name + \".sound\");\n  if (!file.is_open()){\n    std::cerr << \"Failed to load sound: \" << l_name << std::endl;\n    return false;\n  }\n  SoundProps props(\"\");\n  std::string line;\n  while (std::getline(file, line)){\n    if (line[0] == '|'){ continue; }\n    std::stringstream keystream(line);\n    std::string type;\n    keystream >> type;\n    if (type == \"Audio\"){\n      keystream >> props.m_audioName;\n    } else if (type == \"Volume\"){\n      keystream >> props.m_volume;\n    } else if (type == \"Pitch\"){\n      keystream >> props.m_pitch;\n    } else if (type == \"Distance\"){\n      keystream >> props.m_minDistance;\n    } else if (type == \"Attenuation\"){\n      keystream >> props.m_attenuation;\n    } else {\n      // ?\n    }\n  }\n  file.close();\n  if (props.m_audioName == \"\"){ return false; }\n  m_properties.emplace(l_name, props);\n  return true;\n}\n```", "```cpp\nvoid SoundManager::PauseAll(const StateType& l_state){\n  auto& container = m_audio[l_state];\n  for (auto itr = container.begin(); itr != container.end();){\n    if (!itr->second.second->getStatus()){\n      RecycleSound(itr->first, itr->second.second,\n        itr->second.first.m_name);\n      itr = container.erase(itr);\n      continue;\n    }\n    itr->second.second->pause();\n    ++itr;\n  }\n  auto music = m_music.find(l_state);\n  if (music == m_music.end()){ return; }\n  if (!music->second.second){ return; }\n  music->second.second->pause();\n}\n```", "```cpp\nvoid SoundManager::UnpauseAll(const StateType& l_state){\n  auto& container = m_audio[l_state];\n  for (auto &itr : container){\n    if (itr.second.first.m_manualPaused){ continue; }\n    itr.second.second->play();\n  }\n\n  auto music = m_music.find(l_state);\n  if (music == m_music.end()){ return; }\n  if (!music->second.second ||music->second.first.m_manualPaused){\n    return;\n  }\n  music->second.second->play();\n}\n```", "```cpp\nsf::Sound* SoundManager::CreateSound(SoundID& l_id,\n  const std::string& l_audioName)\n{\n  sf::Sound* sound = nullptr;\n  if (!m_recycled.empty() && (m_numSounds >= Max_Sounds ||\n    m_recycled.size() >= Sound_Cache))\n  {\n    auto itr = m_recycled.begin();\n    while (itr != m_recycled.end()){\n      if (itr->first.second == l_audioName){ break; }\n      ++itr;\n    }\n    if (itr == m_recycled.end()){\n      // If a sound with the same name hasn't been found!\n      auto element = m_recycled.begin();\n      l_id = element->first.first;\n      m_audioManager->ReleaseResource(element->first.second);\n      m_audioManager->RequireResource(l_audioName);\n      sound = element->second;\n      sound->setBuffer(*m_audioManager->GetResource(l_audioName));\n      m_recycled.erase(element);\n    } else {\n      l_id = itr->first.first;\n      sound = itr->second;\n      m_recycled.erase(itr);\n    }\n    return sound;\n  }\n  if (m_numSounds < Max_Sounds){\n    if (m_audioManager->RequireResource(l_audioName)){\n      sound = new sf::Sound();\n      l_id = m_lastID;\n      ++m_lastID;\n      ++m_numSounds;\n      sound->setBuffer(*m_audioManager->GetResource(l_audioName));\n      return sound;\n    }\n  }\n  std::cerr << \"[SoundManager] Failed to create sound.\"\n    << std::endl;\n  return nullptr;\n}\n```", "```cpp\nvoid SoundManager::SetUpSound(sf::Sound* l_snd, \n  const SoundProps* l_props, bool& l_loop, bool& l_relative)\n{\n    l_snd->setVolume(l_props->m_volume);\n    l_snd->setPitch(l_props->m_pitch);\n    l_snd->setMinDistance(l_props->m_minDistance);\n    l_snd->setAttenuation(l_props->m_attenuation);\n    l_snd->setLoop(l_loop);\n    l_snd->setRelativeToListener(l_relative);\n}\n```", "```cpp\nvoid SoundManager::RecycleSound(const SoundID& l_id, \n  sf::Sound* l_snd, const std::string& l_name)\n{\n  m_recycled.emplace_back(std::make_pair(l_id, l_name), l_snd);\n}\n```", "```cpp\nenum class EntityMessage{ \n  Move, Is_Moving, Frame_Change, State_Changed, Direction_Changed,\n  Switch_State, Attack_Action, Dead\n};\n```", "```cpp\nclass Anim_Base{\npublic:\n    ...\n    bool CheckMoved();\n    ...\nprotected:\n    ...\n    bool m_hasMoved;\n    ...\n};\n```", "```cpp\nAnim_Base::Anim_Base()...,m_hasMoved(false){ ... }\n\nbool Anim_Base::CheckMoved(){\n    bool result = m_hasMoved;\n    m_hasMoved = false;\n    return result;\n}\n```", "```cpp\nbool Anim_Base::SetFrame(const unsigned int& l_frame){\n    if((l_frame >= m_frameStart && l_frame <= m_frameEnd)||\n      (l_frame >= m_frameEnd && l_frame <= m_frameStart))\n    {\n        m_frameCurrent = l_frame;\n        m_hasMoved = true;\n        return true;\n    }\n    return false;\n}\n```", "```cpp\nvoid Anim_Directional::FrameStep(){\n  bool b = SetFrame(m_frameCurrent +\n    (m_frameStart <= m_frameEnd ? 1 : -1));\n  if (b){ return; }\n  if (m_loop){ SetFrame(m_frameStart); }\n  else { SetFrame(m_frameEnd); Pause(); }\n}\n```", "```cpp\nvoid S_SheetAnimation::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities){\n    ...\n    if (sheet->GetSpriteSheet()->GetCurrentAnim()->CheckMoved()){\n      int frame = sheet->GetSpriteSheet()->\n        GetCurrentAnim()->GetFrame();\n      Message msg((MessageType)EntityMessage::Frame_Change);\n      msg.m_receiver = entity;\n      msg.m_int = frame;\n      m_systemManager->GetMessageHandler()->Dispatch(msg);\n    }\n  }\n}\n```", "```cpp\nenum class EntitySound{ None = -1, Footstep, Attack, Hurt,Death };\n```", "```cpp\nstruct SoundParameters{\n  static const int Max_SoundFrames = 5;\n  SoundParameters(){\n    for (int i = 0; i < Max_SoundFrames; ++i){ m_frames[i] = -1; }\n  }\n  std::string m_sound;\n  std::array<int, Max_SoundFrames> m_frames;\n};\n```", "```cpp\nclass C_SoundEmitter : public C_Base{\npublic:\n    static const int Max_EntitySounds = 4;\n    ...\nprivate:\n    SoundID m_soundID;\n    std::array<SoundParameters, Max_EntitySounds> m_params;\n};\n```", "```cpp\nC_SoundEmitter(): C_Base(Component::SoundEmitter), m_soundID(-1){}\n```", "```cpp\nconst std::string& GetSound(const EntitySound& l_snd){\n  static std::string empty = \"\";\n  return((int)l_snd < Max_EntitySounds ?\n    m_params[(int)l_snd].m_sound : empty);\n}\n```", "```cpp\nbool IsSoundFrame(const EntitySound& l_snd, int l_frame){\n  if ((int)l_snd >= Max_EntitySounds){ return false; }\n  for (int i = 0; i < SoundParameters::Max_SoundFrames; ++i){\n    if (m_params[(int)l_snd].m_frames[i] == -1){ return false; }\n    if (m_params[(int)l_snd].m_frames[i] == l_frame){return true;}\n  }\n  return false;\n}\n```", "```cpp\nSoundID GetSoundID(){ return m_soundID; }\nvoid SetSoundID(const SoundID& l_id){ m_soundID = l_id; }\nSoundParameters* GetParameters(){ return &m_params[0]; }\n```", "```cpp\nName Player\n...\nComponent 6 footstep:1,4\n```", "```cpp\nvoid ReadIn(std::stringstream& l_stream){\n  std::string main_delimiter = \":\";\n  std::string frame_delimiter = \",\";\n  for (int i = 0; i < Max_EntitySounds; ++i){\n    std::string chunk;\n    l_stream >> chunk;\n    if (chunk == \"\"){ break; }\n\n    std::string sound = chunk.substr(0,\n      chunk.find(main_delimiter));\n    std::string frames = chunk.substr(\n      chunk.find(main_delimiter) + main_delimiter.length());\n    m_params[i].m_sound = sound;\n    size_t pos = 0;\n    unsigned int frameNum = 0;\n    while (frameNum < SoundParameters::Max_SoundFrames){\n      pos = frames.find(frame_delimiter);\n      int frame = -1;\n      if (pos != std::string::npos){\n        frame = stoi(frames.substr(0, pos));\n        frames.erase(0, pos + frame_delimiter.length());\n      } else {\n        frame = stoi(frames);\n        m_params[i].m_frames[frameNum] = frame;\n        break;\n      }\n      m_params[i].m_frames[frameNum] = frame;\n      ++frameNum;\n    }\n  }\n}\n```", "```cpp\nclass C_SoundListener : public C_Base{\npublic:\n    C_SoundListener() : C_Base(Component::SoundListener){}\n    void ReadIn(std::stringstream& l_stream){}\nprivate:\n\n};\n```", "```cpp\nclass S_Sound : public S_Base{\npublic:\n  S_Sound(SystemManager* l_systemMgr);\n  ~S_Sound();\n\n  void Update(float l_dT);\n  void HandleEvent(const EntityId& l_entity,\n    const EntityEvent& l_event);\n  void Notify(const Message& l_message);\n\n  void SetUp(AudioManager* l_audioManager,\n    SoundManager* l_soundManager);\nprivate:\n  sf::Vector3f MakeSoundPosition(const sf::Vector2f& l_entityPos,\n    unsigned int l_elevation);\n  void EmitSound(const EntityId& l_entity,\n    const EntitySound& l_sound, bool l_useId, bool l_relative,\n    int l_checkFrame = -1);\n  AudioManager* m_audioManager;\n  SoundManager* m_soundManager;\n};\n```", "```cpp\nS_Sound::S_Sound(SystemManager* l_systemMgr)\n  : S_Base(System::Sound, l_systemMgr), m_audioManager(nullptr),\n  m_soundManager(nullptr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::SoundEmitter);\n  m_requiredComponents.push_back(req);\n  req.ClearBit((unsigned int)Component::SoundEmitter);\n  req.TurnOnBit((unsigned int)Component::SoundListener);\n  m_requiredComponents.push_back(req);\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Direction_Changed, this);\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Frame_Change, this);\n}\n```", "```cpp\nvoid S_Sound::SetUp(AudioManager* l_audioManager, \n    SoundManager* l_soundManager)\n{ \n    m_audioManager = l_audioManager;\n    m_soundManager = l_soundManager;\n}\n```", "```cpp\nvoid S_Sound::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for (auto &entity : m_entities){\n    C_Position* c_pos = entities->\n      GetComponent<C_Position>(entity, Component::Position);\n    sf::Vector2f position = c_pos->GetPosition();\n    unsigned int elevation = c_pos->GetElevation();\n\n    bool IsListener = entities->\n      HasComponent(entity, Component::SoundListener);\n    if (IsListener){\n      sf::Listener::setPosition(\n        MakeSoundPosition(position, elevation));\n    }\n\n    if (!entities->HasComponent(\n      entity, Component::SoundEmitter))\n    {\n      continue;\n    }\n    C_SoundEmitter* c_snd = entities->GetComponent<C_SoundEmitter>\n      (entity,Component::SoundEmitter);\n    if (c_snd->GetSoundID() == -1){ continue; }\n    if (!IsListener){\n      if (!m_soundManager->SetPosition(c_snd->GetSoundID(),\n        MakeSoundPosition(position, elevation)))\n      {\n        c_snd->SetSoundID(-1);\n      }\n    } else {\n      if (!m_soundManager->IsPlaying(c_snd->GetSoundID())){\n        c_snd->SetSoundID(-1);\n      }\n    }\n  }\n}\n```", "```cpp\nvoid S_Sound::Notify(const Message& l_message){\n  if (!HasEntity(l_message.m_receiver)){ return; }\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  bool IsListener = entities->\n    HasComponent(l_message.m_receiver, Component::SoundListener);\n  EntityMessage m = (EntityMessage)l_message.m_type;\n  switch (m){\n  case EntityMessage::Direction_Changed:\n  {\n    if (!IsListener){ return; }\n    Direction dir = (Direction)l_message.m_int;\n    switch (dir){\n    case Direction::Up: sf::Listener::setDirection(0, 0, -1);\n      break;\n    case Direction::Down: sf::Listener::setDirection(0, 0, 1);\n      break;\n    case Direction::Left: sf::Listener::setDirection(-1, 0, 0);\n      break;\n    case Direction::Right: sf::Listener::setDirection(1, 0, 0);\n      break;\n    }\n  }\n    break;\n  case EntityMessage::Frame_Change:\n    if (!entities->HasComponent(l_message.m_receiver,\n      Component::SoundEmitter))\n    {\n      return;\n    }\n    EntityState state = entities->GetComponent<C_State>\n      (l_message.m_receiver, Component::State)->GetState();\n    EntitySound sound = EntitySound::None;\n    if (state==EntityState::Walking){sound=EntitySound::Footstep;}\n       else if(state == EntityState::Attacking){\n         sound = EntitySound::Attack;\n    } else if (state==EntityState::Hurt){sound=EntitySound::Hurt;}\n    else if (state==EntityState::Dying){sound=EntitySound::Death;}\n    if (sound == EntitySound::None){ return; }\n    EmitSound(l_message.m_receiver, sound, false,\n      IsListener, l_message.m_int);\n    break;\n  }\n}\n```", "```cpp\nsf::Vector3f S_Sound::MakeSoundPosition(\n  const sf::Vector2f& l_entityPos, unsigned int l_elevation)\n{\n  return sf::Vector3f(l_entityPos.x,\n    l_elevation * Sheet::Tile_Size, l_entityPos.y);\n}\n```", "```cpp\nvoid S_Sound::EmitSound(const EntityId& l_entity,\n  const EntitySound& l_sound, bool l_useId, bool l_relative,\n  int l_checkFrame)\n{\n  if (!HasEntity(l_entity)){ return; }\n  if (!m_systemManager->GetEntityManager()->\n    HasComponent(l_entity, Component::SoundEmitter))\n  {\n    return;\n  }\n  // Is a sound emitter.\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  C_SoundEmitter* c_snd = entities->GetComponent<C_SoundEmitter>\n    (l_entity, Component::SoundEmitter);\n  if (c_snd->GetSoundID() != -1 && l_useId){ return; }\n  // If sound is free or use of ID isn't required.\n  if (l_checkFrame != -1 &&\n    !c_snd->IsSoundFrame(l_sound, l_checkFrame))\n  {\n    return;\n  }\n  // Frame is irrelevant or correct.\n  C_Position* c_pos = entities->\n    GetComponent<C_Position>(l_entity, Component::Position);\n  sf::Vector3f pos = (l_relative ?\n    sf::Vector3f(0.f, 0.f, 0.f) :\n    MakeSoundPosition(c_pos->GetPosition(),\n    c_pos->GetElevation()));\n  if (l_useId){\n    c_snd->SetSoundID(m_soundManager->\n      Play(c_snd->GetSound(l_sound), pos));\n  } else {\n    m_soundManager->Play(c_snd->GetSound(l_sound),\n      pos, false, l_relative);\n  }\n}\n```", "```cpp\nvoid StateManager::SwitchTo(const StateType& l_type){\n  ...\n  m_shared->m_soundManager->ChangeState(l_type);\n  ...\n}\n```", "```cpp\nvoid StateManager::RemoveState(const StateType& l_type){\n  for (auto itr = m_states.begin();\n    itr != m_states.end(); ++itr)\n  {\n    if (itr->first == l_type){\n      ...\n      m_shared->m_soundManager->RemoveState(l_type);\n      return;\n    }\n  }\n}\n```", "```cpp\n...\n#include \"AudioManager.h\"\n#include \"SoundManager.h\"\n...\nstruct SharedContext{\n    SharedContext():\n        ...\n        m_audioManager(nullptr),\n        m_soundManager(nullptr),\n        ...\n        {}\n\n    ...\n    AudioManager* m_audioManager;\n    SoundManager* m_soundManager;\n    ...\n};\n```", "```cpp\nclass Game{\npublic:\n    ...\nprivate:\n    ...\n    AudioManager m_audioManager;\n    SoundManager m_soundManager;\n    ...\n};\n```", "```cpp\nGame::Game(): ..., m_soundManager(&m_audioManager)\n{\n  ...\n  m_context.m_audioManager = &m_audioManager;\n  m_context.m_soundManager = &m_soundManager;\n  ...\n  m_systemManager.GetSystem<S_Sound>(System::Sound)->\n    SetUp(&m_audioManager, &m_soundManager);\n  ...\n}\n```", "```cpp\nvoid Game::Update(){\n    ...\n    m_soundManager.Update(m_elapsed.asSeconds());\n    ...\n}\n```", "```cpp\nEntityManager::EntityManager(SystemManager* l_sysMgr, \n  TextureManager* l_textureMgr): ...\n{\n  ...\n  AddComponentType<C_SoundEmitter>(Component::SoundEmitter);\n  AddComponentType<C_SoundListener>(Component::SoundListener);\n}\n```", "```cpp\nSystemManager::SystemManager():...{\n  ...\n  m_systems[System::Sound] = new S_Sound(this);\n}\n```", "```cpp\nvoid State_Intro::OnCreate(){\n    ...\n    m_stateMgr->GetContext()->m_soundManager->\n        PlayMusic(\"Electrix\", 100.f, true);\n}\n```", "```cpp\nvoid State_Game::OnCreate(){\n    ...\n    m_stateMgr->GetContext()->m_soundManager->\n        PlayMusic(\"TownTheme\", 50.f, true);\n}\n```"]