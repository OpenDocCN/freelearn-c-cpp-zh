["```cpp\nint pipe(int arr[2]);\n```", "```cpp\nint mkfifo(const char *filename, mode_t permission);\n```", "```cpp\nwrite(int fp, const void *buf, size_t n);\n```", "```cpp\nread(int fp, void *buf, size_t n);\n```", "```cpp\nvoid perror ( const char * str );\n```", "```cpp\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#define max 50\n\nint main()\n{\n    char str[max];\n    int pp[2];\n\n    if (pipe(pp) < 0)\n        exit(1);\n    printf(\"Enter first message to write into pipe: \");\n    gets(str);\n    write(pp[1], str, max);\n    printf(\"Enter second message to write into pipe: \");\n    gets(str);\n    write(pp[1], str, max);\n    printf(\"Messages read from the pipe are as follows:\\n\");\n    read(pp[0], str, max);\n    printf(\"%s\\n\", str);\n    read(pp[0], str, max);\n    printf(\"%s\\n\", str);\n    return 0;\n}\n```", "```cpp\n$ gcc readwritepipe.c -o readwritepipe\n```", "```cpp\n$ ./readwritepipe\nEnter the first message to write into pipe: This is the first message for the pipe\nEnter the second message to write into pipe: Second message for the pipe\nMessages read from the pipe are as follows:\nThis is the first message for the pipe\nSecond message for the pipe\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define max  50\n\nint main()\n{\n    char wstr[max];\n    char rstr[max];\n    int pp[2];\n    pid_t p;\n    if(pipe(pp) < 0)\n    {\n        perror(\"pipe\");\n    } \n    p = fork();\n    if(p >= 0)\n    {\n        if(p == 0)\n        {\n            printf (\"Enter the string : \");\n            gets(wstr);\n            write (pp[1] , wstr , strlen(wstr));\n            exit(0);\n        }\n        else\n        {\n            read (pp[0] , rstr , sizeof(rstr));\n            printf(\"Entered message : %s\\n \" , rstr);\n            exit(0);\n        }\n    }\n    else\n    {\n        perror(\"fork\");\n        exit(2);\n    }        \n    return 0;\n}\n```", "```cpp\n$ gcc pipedemo.c -o pipedemo\n```", "```cpp\n$ ./pipedemo\nEnter the string : This is a message from the pipe\nEntered message : This is a message from the pipe\n```", "```cpp\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main()\n{\n    int fw;\n    char str[255];\n    mkfifo(\"FIFOPipe\", 0666);\n    fw = open(\"FIFOPipe\", O_WRONLY);\n    printf(\"Enter text: \");\n    gets(str);\n    write(fw,str, sizeof(str));\n    close(fw);\n    return 0;\n}\n```", "```cpp\n$ gcc writefifo.c -o writefifo\n```", "```cpp\n$ ./writefifo\nEnter text: This is a named pipe demo example called FIFO\n```", "```cpp\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#define BUFFSIZE 255\n\nint main()\n{\n    int fr;\n    char str[BUFFSIZE];\n    fr = open(\"FIFOPipe\", O_RDONLY);\n    read(fr, str, BUFFSIZE);\n    printf(\"Read from the FIFO Pipe: %s\\n\", str);\n    close(fr);\n    return 0;\n}\n```", "```cpp\n$ gcc readfifo.c -o readfifo\n```", "```cpp\n$ ./readfifo\nRead from the FIFO Pipe: This is a named pipe demo example called FIFO\n```", "```cpp\nstruct sockaddr_in {\n short int sin_family;\n unsigned short int sin_port;\n struct in_addr sin_addr;\n unsigned char sin_zero[8];\n};\n```", "```cpp\n\nstruct in_addr {\n     unsigned long s_addr; \n};\n```", "```cpp\nint socket(int domain, int type, int protocol);\n```", "```cpp\nvoid *memset(void *ptr, int v, size_t n);\n```", "```cpp\n   int bind(int fdsock, const struct sockaddr *structaddr, socklen_t lenaddr);\n```", "```cpp\nint listen(int sockfd, int lenque);\n```", "```cpp\nint accept(int socket, struct sockaddr *address, socklen_t *len);\n```", "```cpp\n       ssize_t send(int fdsock, const void *buf, size_t length, int flags);\n```", "```cpp\nint connect(int fdsock, const struct sockaddr *addr,  socklen_t len);\n```", "```cpp\nssize_t recv(int fdsock, void *buf, size_t len, int flags);\n```", "```cpp\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <arpa/inet.h>\n\nint main(){\n    int serverSocket, toSend;\n    char str[255];\n    struct sockaddr_in server_Address;\n    serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    server_Address.sin_family = AF_INET;\n    server_Address.sin_port = htons(2000);\n    server_Address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    memset(server_Address.sin_zero, '\\0', sizeof \n    server_Address.sin_zero); \n    bind(serverSocket, (struct sockaddr *) &server_Address, \n    sizeof(server_Address));\n    if(listen(serverSocket,5)==-1)\n    {\n        printf(\"Not able to listen\\n\");\n        return -1;\n    }\n    printf(\"Enter text to send to the client: \");\n    gets(str);\n    toSend = accept(serverSocket, (struct sockaddr *) NULL, NULL);\n    send(toSend,str, strlen(str),0);\n    return 0;\n}\n```", "```cpp\n$ gcc serverprog.c -o serverprog\n```", "```cpp\n$ ./serverprog\nEnter text to send to the client: thanks and good bye\n```", "```cpp\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <arpa/inet.h>\n\nint main(){\n    int clientSocket;\n    char str[255];\n    struct sockaddr_in client_Address;\n    socklen_t address_size;\n    clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n    client _Address.sin_family = AF_INET;\n    client _Address.sin_port = htons(2000);\n    client _Address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    memset(client _Address.sin_zero, '\\0', sizeof client_Address.sin_zero); \n    address_size = sizeof server_Address;\n    connect(clientSocket, (struct sockaddr *) &client_Address, address_size);\n    recv(clientSocket, str, 255, 0);\n    printf(\"Data received from server: %s\", str);  \n    return 0;\n}\n```", "```cpp\n$ gcc clientprog.c -o clientprog\n```", "```cpp\n$ ./clientprog\nData received from server: thanks and good bye\n```", "```cpp\nvoid bzero(void *r, size_t n);\n```", "```cpp\nssize_t sendto(int fdsock, const void *buff, size_t len, int flags, const struct sockaddr *recv_addr, socklen_t recv_len);\n```", "```cpp\nssize_t recvfrom(int fdsock, void *buffer, size_t length, int flags, struct sockaddr *address, socklen_t *address_len);\n```", "```cpp\n#include <stdio.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include<netinet/in.h>\n#include <stdlib.h> \n\nint main()\n{   \n    char msgReceived[255];\n    char msgforclient[255];\n    int UDPSocket, len;\n    struct sockaddr_in server_Address, client_Address;\n    bzero(&server_Address, sizeof(server_Address));\n    printf(\"Waiting for the message from the client\\n\");\n    if ( (UDPSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { \n        perror(\"Socket could not be created\"); \n        exit(1); \n    }      \n    server_Address.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_Address.sin_port = htons(2000);\n    server_Address.sin_family = AF_INET; \n    if ( bind(UDPSocket, (const struct sockaddr *)&server_Address, \n    sizeof(server_Address)) < 0 ) \n    { \n        perror(\"Binding could not be done\"); \n        exit(1); \n    } \n    len = sizeof(client_Address);\n    int n = recvfrom(UDPSocket, msgReceived, sizeof(msgReceived),  0, \n    (struct sockaddr*)&client_Address,&len);\n    msgReceived[n] = '\\0';\n    printf(\"Message received from the client: \");\n    puts(msgReceived);\n    printf(\"Enter the reply to be sent to the client: \");\n    gets(msgforclient);\n    sendto(UDPSocket, msgforclient, 255, 0, (struct \n    sockaddr*)&client_Address, sizeof(client_Address));\n    printf(\"Reply to the client sent \\n\");\n}\n```", "```cpp\n#include <stdio.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include<netinet/in.h>\n#include<unistd.h>\n#include<stdlib.h>\n\nint main()\n{   \n    char msgReceived[255];\n    char msgforserver[255];\n    int UDPSocket, n;\n    struct sockaddr_in client_Address;    \n    printf(\"Enter the message to send to the server: \");\n    gets(msgforserver);\n    bzero(&client_Address, sizeof(client_Address));\n    client_Address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    client_Address.sin_port = htons(2000);\n    client_Address.sin_family = AF_INET;     \n    if ( (UDPSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { \n        perror(\"Socket could not be created\"); \n        exit(1); \n    } \n    if(connect(UDPSocket, (struct sockaddr *)&client_Address, \n    sizeof(client_Address)) < 0)\n    {\n        printf(\"\\n Error : Connect Failed \\n\");\n        exit(0);\n    } \n    sendto(UDPSocket, msgforserver, 255, 0, (struct sockaddr*)NULL, \n    sizeof(client_Address));\n    printf(\"Message to the server sent. \\n\");\n    recvfrom(UDPSocket, msgReceived, sizeof(msgReceived), 0, (struct \n    sockaddr*)NULL, NULL);\n    printf(\"Received from the server: \");\n    puts(msgReceived);\n    close(UDPSocket);\n}\n```", "```cpp\n$ gcc udps.c -o udps\n```", "```cpp\n$ ./udps\nWaiting for the message from the client\n```", "```cpp\n$ gcc udpc.c -o udpc\n```", "```cpp\n$ ./udpc\nEnter the message to send to the server: Will it rain today?\nMessage to the server sent.\n```", "```cpp\nMessage received from the client: Will it rain today?\nEnter the reply to be sent to the client: It might\nReply to the client sent\n```", "```cpp\nReceived from the server: It might\n```", "```cpp\n$ ./bin/cygserver-config\nGenerating /etc/cygserver.conf file\nWarning: The following function requires administrator privileges!\nDo you want to install cygserver as service? yes\n\nThe service has been installed under LocalSystem account.\nTo start it, call `net start cygserver' or `cygrunsrv -S cygserver'.\n\nFurther configuration options are available by editing the configuration\nfile /etc/cygserver.conf. Please read the inline information in that\nfile carefully. The best option for the start is to just leave it alone.\n\nBasic Cygserver configuration finished. Have fun!\n```", "```cpp\n$ net start cygserver\nThe CYGWIN cygserver service is starting.\nThe CYGWIN cygserver service was started successfully.\n```", "```cpp\nkey_t ftok(const char *filename, int id);\n```", "```cpp\nint shmget(key_t key, size_t size, int shmflg);\n```", "```cpp\nvoid *shmat(int shidtfr, const void *addr, int flag);\n```", "```cpp\nint shmdt(const void *addr);\n```", "```cpp\nint shmctl(int shidtr, int cmd, struct shmid_ds *buf);\n```", "```cpp\n       int msgget(key_t key, int flag);\n```", "```cpp\nint msgrcv(int msqid, void *msgstruc, int msgsize, long typemsg, int flag);\n```", "```cpp\n int msgsnd ( int msqid, struct msgbuf *msgstruc, int msgsize, int flag );\n```", "```cpp\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MSGSIZE     255\n\nstruct msgstruc {\n    long mtype;\n    char mesg[MSGSIZE];\n};\n\nint main()\n{\n    int msqid, msglen;\n    key_t key;\n    struct msgstruc msgbuf;\n    system(\"touch messagefile\");\n    if ((key = ftok(\"messagefile\", 'a')) == -1) {\n        perror(\"ftok\");\n        exit(1);\n    } \n    if ((msqid = msgget(key, 0666 | IPC_CREAT)) == -1) {\n        perror(\"msgget\");\n        exit(1);\n    }\n    msgbuf.mtype = 1;\n    printf(\"Enter a message to add to message queue : \");\n    scanf(\"%s\",msgbuf.mesg);\n    msglen = strlen(msgbuf.mesg);\n    if (msgsnd(msqid, &msgbuf, msglen, IPC_NOWAIT) < 0)\n        perror(\"msgsnd\");\n    printf(\"The message sent is %s\\n\", msgbuf.mesg);\n    return 0;\n}\n```", "```cpp\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define MSGSIZE     255\n\nstruct msgstruc {\n    long mtype;\n    char mesg[MSGSIZE];\n};\n\nint main()\n{\n    int msqid;\n    key_t key;\n    struct msgstruc rcvbuffer;\n\n    if ((key = ftok(\"messagefile\", 'a')) == -1) {\n        perror(\"ftok\");\n        exit(1);\n    }\n    if ((msqid = msgget(key, 0666)) < 0)\n    {\n        perror(\"msgget\");\n        exit(1);\n    }\n    if (msgrcv(msqid, &rcvbuffer, MSGSIZE, 1, 0) < 0)\n    {\n        perror(\"msgrcv\");\n        exit(1);\n    }\n    printf(\"The message received is %s\\n\", rcvbuffer.mesg);\n    return 0;\n}\n```", "```cpp\n$ gcc messageqsend.c -o messageqsend\n```", "```cpp\n$ ./messageqsend\nEnter a message to add to message queue : GoodBye\nThe message sent is GoodBye\n```", "```cpp\n$ gcc messageqrecv.c -o messageqrecv\n```", "```cpp\n$ ./messageqrecv\nThe message received is GoodBye\n```", "```cpp\n#include <stdio.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    char *str;\n    int shmid;\n\n    key_t key = ftok(\"sharedmem\",'a');\n    if ((shmid = shmget(key, 1024,0666|IPC_CREAT)) < 0) {\n        perror(\"shmget\");\n        exit(1);\n    }\n    if ((str = shmat(shmid, NULL, 0)) == (char *) -1) {\n        perror(\"shmat\");\n        exit(1);\n    }\n    printf(\"Enter the string to be written in memory : \");\n    gets(str);\n    printf(\"String written in memory: %s\\n\",str);\n    shmdt(str);\n    return 0;\n}\n```", "```cpp\n#include <stdio.h> \n#include <sys/ipc.h> \n#include <sys/shm.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int shmid;\n    char * str;\n    key_t key = ftok(\"sharedmem\",'a');\n    if ((shmid = shmget(key, 1024,0666|IPC_CREAT)) < 0) {\n        perror(\"shmget\");\n        exit(1);\n    }\n    if ((str = shmat(shmid, NULL, 0)) == (char *) -1) {\n        perror(\"shmat\");\n        exit(1);\n    }\n    printf(\"Data read from memory: %s\\n\",str);\n    shmdt(str);                \n    shmctl(shmid,IPC_RMID,NULL);\n    return 0;\n}\n```", "```cpp\n$ gcc writememory.c -o writememory\n```", "```cpp\n$ ./writememory\nEnter the string to be written in memory : Today it might rain\nString written in memory: Today it might rain\n```", "```cpp\n$ gcc readmemory.c -o readmemory\n```", "```cpp\n$ ./readmemory\n Data read from memory: Today it might rain\n```"]