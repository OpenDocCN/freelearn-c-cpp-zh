<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Elements of WebAssembly - Wat, Wasm, and the JavaScript API</h1>
                </header>
            
            <article>
                
<p class="mce-root"><a href="15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml">Chapter 1</a>, <em>What is WebAssembly?</em>, described the history of WebAssembly and provided a high-level overview of the technology as well as the potential use cases and limitations. WebAssembly was described as being composed of multiple elements, not just the binary instruction format specified in the official definition.</p>
<p class="mce-root">In this chapter, we will dig into the elements that correspond to the official specifications created by the WebAssembly Working Group. We will examine the Wat and the binary format in greater detail to gain a better understanding of how they relate to modules. We will review the <em>JavaScript API</em> and <em>Web API</em> to ensure you're able to utilize the WebAssembly effectively in the browser.</p>
<p>Our goal for this chapter is to understand the following:</p>
<ul>
<li>How the text and binary formats are related</li>
<li>What Wat is and where it fits in to the development process</li>
<li>The binary format and module (Wasm) file</li>
<li>The components of the JavaScript and Web API and how they relate to the Wasm module</li>
<li>How to utilize WasmFiddle to evaluate the phases of WebAssembly (C/C++ &gt; Wat &gt; Wasm)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common structure and abstract syntax</h1>
                </header>
            
            <article>
                
<p>In <a href="15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml">Chapter 1</a>,<span> </span><em>What is WebAssembly?</em>, we talked about how the binary and text formats of WebAssembly both map to a common structure in the form of an abstract syntax. Before getting into the nuts and bolts of these formats, it's worth mentioning how these are related within the <em>Core Specification</em>. The following diagram is a visual representation of the table of contents (with some sections excluded for clarity):</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/24a8a8a0-7afd-4ffe-892c-bb162b09b784.png" style="width:42.83em;height:41.75em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><em>Core Specification</em> table of contents</div>
<p class="mce-root"/>
<p>As you can see, the <strong>Text Format</strong> and <strong>Binary Format</strong> sections contain subsections for <strong>Values</strong>, <strong>Types</strong>, <strong>Instructions</strong>, and <strong>Modules</strong> that correlate with the <strong>Structure</strong> section. Consequently, much of what we cover in the next section for the text format have direct corollaries with the binary format. With that in mind, let's dive into the text format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wat</h1>
                </header>
            
            <article>
                
<p>The <em>Text Format</em> section of the <em>Core Specification</em> provides technical descriptions for common language concepts such as values, types, and instructions. These are important concepts to know and understand if you're planning on building tooling for WebAssembly, but not necessary if you just plan on using it in your applications. That being said, the text format is an important part of WebAssembly, so there are concepts you should be aware of. In this section, we will dig into some of the details of the text format and highlight important points from the <em>Core Specification</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Definitions and S-expressions</h1>
                </header>
            
            <article>
                
<p>To understand Wat, let's start with the first sentence of the description taken directly from the WebAssembly <em>Core Specification</em>:</p>
<div class="packt_quote">"The textual format for WebAssembly modules is a rendering of their abstract syntax into S-expressions."</div>
<p>So what are <span><strong>symbolic expressions</strong> (</span><strong>S-expressions</strong>)? S-expressions are notations for nested list (tree-structured) data. Essentially, they provide a simple and elegant way to represent list-based data in textual form. To understand how textual representations of nested lists map to a tree structure, let's extrapolate the tree structure from an HTML page. The following example contains a simple HTML page and the corresponding tree structure diagram.</p>
<p>A simple HTML page:</p>
<pre>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;link rel="icon" href="favicon.ico"&gt;<br/>  &lt;title&gt;Page Title&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div&gt;<br/>    &lt;h1&gt;Header&lt;/h1&gt;<br/>    &lt;p&gt;This is a paragraph.&lt;/p&gt;<br/>  &lt;/div&gt;<br/>  &lt;div&gt;Some content&lt;/div&gt;<br/>  &lt;nav&gt;<br/>    &lt;ul&gt;<br/>      &lt;li&gt;Item 1&lt;/li&gt;<br/>      &lt;li&gt;Item 2&lt;/li&gt;<br/>      &lt;li&gt;Item 3&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/nav&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The corresponding tree structure is:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/fbdfac80-c6f7-45cb-beb9-5ebdc2ed8ffe.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A tree structure diagram for an HTML page</div>
<p class="mce-root"/>
<p>Even if you've never seen a tree structure before, it's still clear to see how the HTML maps to the tree in terms of structure and hierarchy. Mapping HTML elements is relatively simple because it's a markup language with well-defined tags and no actual logic.</p>
<p>Wat represents modules that can have multiple functions with varying parameters. To demonstrate the relationship between source code, Wat, and the corresponding tree structure, let's start with a simple C function that adds 2 to the number that is passed in as a parameter:</p>
<p>Here is a C function that adds <kbd>2</kbd> to the <kbd>num</kbd> argument passed in and returns the result:</p>
<pre style="padding-left: 60px">int addTwo(int num) {<br/>    return num + 2;<br/>}</pre>
<p>Converting the <kbd>addTwo</kbd> function to valid Wat produces this result:</p>
<pre style="padding-left: 60px">(module<br/>  (table 0 anyfunc)<br/>  (memory $0 1)<br/>  (export "memory" (memory $0))<br/>  (export "addTwo" (func $addTwo))<br/>  (func $addTwo (; 0 ;) (param $0 i32) (result i32)<br/>    (i32.add<br/>      (get_local $0)<br/>      (i32.const 2)<br/>    )<br/>  )<br/>)</pre>
<p>In <a href="15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml">Chapter 1</a>, <em>What is WebAssembly?</em>, we talked about language concepts associated with the <em>Core Specification</em> (<em>Functions</em>, <em>Linear Memory</em>, <em>Tables</em>, and so on). Within that specification, the <em>Structure</em> section defines each of these concepts in the context of an abstract syntax. The <em>Text Format</em> section of the specification corresponds with these concepts as well, and you can see them defined by their keywords in the preceding snippet (<kbd>func</kbd>, <kbd>memory</kbd>, <kbd>table</kbd>).</p>
<p>Tree Structure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/28fa4fdc-1b9e-4672-b752-8bb1a272e9e0.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A tree structure diagram for Wat</div>
<p>The entire tree would be too large to fit on a page, so this diagram is limited to the first five lines of the Wat source text. Each filled-in dot represents a list node (or the contents of a set of parentheses). As you can see, code written in s-expressions can be clearly and concisely expressed in a tree structure, which is why s-expressions were chosen for WebAssembly's text format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Values, types, and instructions</h1>
                </header>
            
            <article>
                
<p>Although detailed coverage of the <em>Text Format</em> section of the <em>Core Specification</em> is out of the scope of this text, it's worth demonstrating how some of the language concepts map to the corresponding Wat. The following diagram demonstrates these mappings in a sample Wat snippet. The C code that this was compiled from represents a function that takes a word as a parameter and returns the square root of the character count:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7c3b4124-7f45-49c6-a933-de3bf3861864.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Wat example with language concept details</div>
<p>If you intend on writing or editing Wat, note that it supports block and line comments. The instructions are split up into blocks and consist of setting and getting memory associated with variables with valid types. You are able to control the flow of logic using <kbd>if</kbd> statements and loops are supported using the <kbd>loop</kbd> keyword.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Role in the development process</h1>
                </header>
            
            <article>
                
<p>The text format allows for the representation of a binary Wasm module in textual form. This has some profound implications with regard to the ease of development and debugging. Having a textual representation of a WebAssembly module allows developers to view the source of a loaded module in a browser, which eliminates the black-box issues that inhibited the adoption of NaCl. It also allows for tooling to be built around troubleshooting modules. The official website describes the use cases that drove the design of the text format:</p>
<div class="mce-root packt_quote"><span>• View Source on a WebAssembly module, thus fitting into the Web (where every source can be viewed) in a natural way. <br/></span><span><br/>
• Presentation in browser development tools when source maps aren't present (which is necessarily the case with the Minimum Viable Product (MVP)).<br/>
<br/></span> <span>• Writing WebAssembly code directly for reasons including pedagogical, experimental, debugging, optimization, and testing of the spec itself.</span></div>
<p class="mce-root">The last item in the list reflects that the text format isn't intended to be written by hand in the course of normal development, but rather generated from a tool like Emscripten. You probably won't see or manipulate any <kbd>.wat</kbd> files when you're generating modules, but you may be viewing them in a debugging context.</p>
<p class="mce-root">Not only is the text format valuable with regards to debugging, but having this intermediate format reduces the amount of reliance on a single tool for compilation. Several different tools currently exist to consume and emit this s-expression syntax, some of which are used by Emscripten to compile your code down to a <kbd>.wasm</kbd> file.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binary format and the module file (Wasm)</h1>
                </header>
            
            <article>
                
<p>The <em>Binary Format</em> section of the <em>Core Specification</em> provides the same level of detail with regard to language concepts as the <em>Text format</em> section. In this section, we will briefly cover some high-level details about the binary format and discuss the various sections that make up a Wasm module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Definition and module overview</h1>
                </header>
            
            <article>
                
<p>The binary format is defined as a dense linear encoding of the abstract syntax. Without getting too technical, that essentially means it's an efficient form of binary that allows for fast decoding, small file size, and reduced memory usage. The file representation of the binary format is a <kbd>.wasm</kbd> file, which will be the compilation output from Emscripten that we'll use for our examples.</p>
<p>The <em>Values</em>, <em>Types</em>, and <em>Instructions</em> subsections of the <em>Core Specification</em> for the binary format correlate directly to the <em>Text Format</em> section. Each of these concepts is covered in the context of encoding. For example, according to the specification, the Integer types are encoded using the LEB128 variable-length integer encoding, in either unsigned or signed variant. These are important details to know if you wish to develop tooling for WebAssembly, but not necessary if you just plan on using it on your website.</p>
<p class="mce-root">The <em>Structure</em>, <em>Binary Format</em>, and <em>Text Format</em><span> </span><em>(wat)</em> sections of the <em>Core Specification</em> have a <em>Module</em> subsection. We didn't cover aspects of the module in the previous section because it's more prudent to describe them in the context of a binary. The official WebAssembly site offers the following description for a module:</p>
<div class="mce-root packt_quote">"The distributable, loadable, and executable unit of code in WebAssembly is called a <strong>module</strong>. At runtime, a module can be <strong>instantiated</strong> with a set of import values to produce an <strong>instance</strong>, which is an immutable tuple referencing all the state accessible to the running module."</div>
<p class="mce-root">We will discuss how to interact with the module using the JavaScript and Web APIs later in this chapter, so let's establish some context to understand how the module elements map to the API methods.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module sections</h1>
                </header>
            
            <article>
                
<p>A module is made up of several sections, some of which you'll be interacting with through the JavaScript API:</p>
<ul>
<li>Imports (<kbd>import</kbd>) are elements that can be accessed within the module and can be one of the following:
<ul>
<li>Function, which can be called inside the module using the <kbd>call</kbd> operator</li>
<li>Global, which can be accessed inside the module via the <kbd>global</kbd> operators</li>
<li>Linear Memory, which can be accessed inside the module via the <kbd>memory</kbd> operators</li>
<li>Table, which can be accessed inside the module using <kbd>call_indirect</kbd></li>
</ul>
</li>
<li>Exports (<kbd>export</kbd>) are elements that can be accessed by the consuming API (that is, called by a JavaScript function)</li>
<li>Module start function (<kbd>start</kbd>) is called after the module instance is initialized</li>
<li>Global (<kbd>global</kbd>) contains the internal definition of global variables</li>
<li>Linear memory (<kbd>memory</kbd>) contains the internal definition of linear memory with an initial memory size and optional maximum size</li>
<li>Data (<kbd>data</kbd>) contains an array of data segments which specify the initial contents of fixed ranges of a given memory</li>
<li>Table (<kbd>table</kbd>) is a linear memory whose elements are opaque values of a particular table element type:
<ul>
<li>In the MVP, its primary purpose is to implement indirect function calls in C/C++</li>
</ul>
</li>
<li>Elements (<kbd>elements</kbd>) is a section that allows a module to initialize the elements of any import or internally defined table with any other definition in the module</li>
<li>Function and code:
<ul>
<li>The function section declares the signatures of each internal function defined in the module</li>
<li>The code section contains the function body of each function declared by the function section</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p class="mce-root">Some of the keywords (<kbd>import</kbd>, <kbd>export</kbd>, and so on) should look familiar; they're present in the contents of the Wat file in the previous section. WebAssembly's components follow a logical mapping that directly correspond to the APIs  (for example, you pass a <kbd>memory</kbd> and <kbd>table</kbd> instance into JavaScript's <kbd>WebAssembly.instantiate()</kbd> function). Your primary interaction with a module in binary format will be through these APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JavaScript and Web APIs</h1>
                </header>
            
            <article>
                
<p>In addition to the <em>WebAssembly Core Specification</em>, there are two API specifications for interacting with WebAssembly modules: the <em>WebAssembly JavaScript Interface</em> (JavaScript API) and the <em>WebAssembly Web API</em>. In the previous sections, we covered pertinent aspects of the <em>Core Specification</em> to become familiar with the underlying technology. If you never read the <em>Core Specification</em> (or if you skipped the first few sections of this chapter), it wouldn't inhibit the use of WebAssembly in your application. That is not the case for the APIs, as they describe the methods and interface required to instantiate and interact with your compiled Wasm module. In this section, we will review the Web and JavaScript APIs and describe how to load and communicate with a Wasm module using JavaScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly store and object caches</h1>
                </header>
            
            <article>
                
<p>Before digging into interactions, let's discuss the relationship between JavaScript and WebAssembly in the context of execution. The <em>Core Specification</em> contains the following description in the <em>Execution</em> section:</p>
<div class="mce-root packt_quote">"WebAssembly code is executed when instantiating a module or invoking an exported function on the resulting module instance.<br/>
<br/>
Execution behavior is defined in terms of an abstract machine that models the program state. It includes a stack, which records operand values and control constructs, and an abstract store containing global state."</div>
<p class="mce-root">Under the hood, JavaScript uses something called <strong>agents</strong> to manage execution. The <em>store</em> being referred to in the definition is contained within an agent. The following diagram represents a JavaScript agent:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d01b7a99-69fe-4b97-b7f2-b4fed202aff1.png" style="width:30.25em;height:26.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">JavaScript agent elements</div>
<p class="mce-root">The store represents the state of the abstract machine. WebAssembly operations take a store and return an updated store. Each agent is associated with caches that map JavaScript objects to WebAssembly addresses. So why is this important? It represents the underlying method of interaction between WebAssembly modules and JavaScript. The JavaScript objects correspond to the WebAssembly namespace within the <em>JavaScript API</em>. With that in mind, let's dig into the interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading a module and the WebAssembly namespace methods</h1>
                </header>
            
            <article>
                
<p>The <em>JavaScript API</em> covers the various objects available on the global <kbd>WebAssembly</kbd> object in the browser. Before we discuss those, we'll start with the methods available on the <kbd>WebAssembly</kbd> object, with a brief overview of their intended purposes:</p>
<ul>
<li><kbd>instantiate()</kbd> is the primary API for compiling and instantiating WebAssembly code</li>
<li><kbd>instantiateStreaming()</kbd> performs the same functionality as <kbd>instantiate()</kbd>, but it uses streaming to compile and instantiate the module, which eliminates an intermediate step</li>
<li><kbd>compile()</kbd> only compiles a WebAssembly module, but doesn't instantiate it</li>
<li><kbd>compileStreaming()</kbd> also only compiles a WebAssembly module, but it uses streaming similar to <kbd>instantiateStreaming()</kbd></li>
<li><kbd>validate()</kbd> checks the WebAssembly binary code to ensure the bytes are valid and returns true if valid or false if not valid</li>
</ul>
<p>The <kbd>instantiateStreaming()</kbd> and <kbd>compileStreaming()</kbd> methods are currently only present in the <em>Web API</em>. In fact, these two methods comprise the entire specification. The methods available on the <kbd>WebAssembly</kbd> object are focused primarily on compiling and instantiating modules. With that in mind, let's discuss how to fetch and instantiate a Wasm module.</p>
<p>When you perform a fetch call to get a module, it returns a Promise that resolves with the raw bytes of that module, which need to be loaded into an <kbd>ArrayBuffer</kbd> and instantiated. Going forward, we will refer to this process as loading a module.</p>
<p>The following diagram demonstrates this process:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/368f1c3b-c24a-4265-967f-6347f5fa8b34.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fetching and loading a WebAssembly module</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This process is actually quite simple using Promises. The following code demonstrates how a module is loaded. The <kbd>importObj</kbd> argument passes any data or functions to the Wasm module. You can disregard it for now, as we'll be discussing it in greater detail in <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>:</p>
<pre>fetch('example.wasm')<br/>  .then(response =&gt; response.arrayBuffer())<br/>  .then(buffer =&gt; WebAssembly.instantiate(buffer, importObj))<br/>  .then(({ module, instance }) =&gt; {<br/>    // Do something with module or instance<br/>  });</pre>
<p>The preceding example dictates the method for loading the module using the <kbd>instantiate()</kbd> method. The <kbd>instantiateStreaming()</kbd> method is a little different and simplifies the process even more by fetching, compiling, and instantiating a module in a single step. The following code achieves the same goal (loading a module) using this method:</p>
<pre>WebAssembly.instantiateStreaming(fetch('example.wasm'), importObj)<br/>  .then(({ module, instance }) =&gt; {<br/>    // Do something with module or instance<br/>  });</pre>
<p>The instantiation methods return a Promise that resolves with an object containing a compiled <kbd>WebAssembly.Module</kbd> (<kbd>module</kbd>) and <kbd>WebAssembly.Instance</kbd> (<kbd>instance</kbd>), both of which will be covered later in this section. In most cases, you will use one of these methods to load a Wasm module on your site. The instance contains all of the exported WebAssembly functions that you can call from your JavaScript code.</p>
<p class="mce-root">The <kbd>compile()</kbd> and <kbd>compileStreaming()</kbd> methods return a Promise that only resolves with a compiled <kbd>WebAssembly.Module</kbd>. This is useful if you want to compile a module and instantiate it at a later time. <strong>Mozilla Developer Network</strong> (<strong>MDN</strong>), the web docs site managed by Mozilla, provides an example in which the compiled module is passed to a Web Worker.</p>
<p class="mce-root">As far as the <kbd>validate()</kbd> method is concerned, its only purpose is to test whether the typed array or <kbd>ArrayBuffer</kbd> passed in as a parameter is valid. This would be called after the raw bytes of the response are loaded into an <kbd>ArrayBuffer</kbd>. This method wasn't included in the code examples because attempting to instantiate or compile an invalid Wasm module will throw either a <kbd>TypeError</kbd> or one of the <kbd>Error</kbd> objects present on the <kbd>WebAssembly</kbd> object. We will cover these <kbd>Error</kbd> objects later in this section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly objects</h1>
                </header>
            
            <article>
                
<p class="mce-root">In addition to the methods covered in the <em>Loading a module and the WebAssembly namespace methods</em> section, the global <kbd>WebAssembly</kbd> object has child objects that are used to interact with and troubleshoot WebAssembly. These objects correlate directly to the concepts we discussed in the sections on the WebAssembly binary and text formats. The following list contains these objects as well as their definitions taken from MDN:</p>
<ul>
<li>The <kbd>WebAssembly.Module</kbd> object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with workers, cached in <kbd>IndexedDB</kbd>, and instantiated multiple times</li>
<li>The <kbd>WebAssembly.Instance</kbd> object is a stateful, executable instance of a <kbd>WebAssembly.Module</kbd> which contains all of the exported WebAssembly functions that allow calling into WebAssembly code from JavaScript</li>
<li><kbd>WebAssembly.Memory</kbd>, when called with the constructor, creates a new <kbd>Memory</kbd> object which is a resizable <kbd>ArrayBuffer</kbd> that holds the raw bytes of memory accessed by a WebAssembly <kbd>Instance</kbd></li>
<li><kbd>WebAssembly.Table</kbd>, when called with the constructor, creates a new <kbd>Table</kbd> object of the given size and element type that represents a WebAssembly <kbd>Table</kbd> (which stores function references)</li>
<li><kbd>WebAssembly.CompileError</kbd>, when called with the constructor, creates an error which indicates that an issue occurred during WebAssembly decoding, or validation</li>
<li><kbd>WebAssembly.LinkError</kbd>, when called with the constructor, creates an error which indicates that an issue occurred during module instantiation</li>
<li><kbd>WebAssembly.RuntimeError</kbd>, when called with the constructor, creates an error which indicates that WebAssembly specified a trap (for example, stack overflow occurred)</li>
</ul>
<p>Let's dig into each one individually, starting with the <kbd>WebAssembly.Module</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly.Module</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>WebAssembly.Module</kbd> object is the intermediate step between the <kbd>ArrayBuffer</kbd> and the instantiated module. The <kbd>compile()</kbd> and <kbd>instantiate()</kbd> methods (and their streaming counterparts) return a Promise that resolves with a module (module in lowercase represents the compiled <kbd>Module</kbd>). A module can also be created synchronously by passing a typed array or <kbd>ArrayBuffer</kbd> directly into the constructor, but this is discouraged for large modules.</p>
<p class="mce-root"/>
<p class="mce-root">The <kbd>Module</kbd> object also has three static methods: <kbd>exports()</kbd>, <kbd>imports()</kbd>, and <kbd>customSections()</kbd>. All three take a module as a parameter, but <kbd>customSections()</kbd> takes a string representing the section name as its second parameter. Custom sections are described in the <em>Binary Format</em> section of the <em>Core Specification</em> and are intended to be used for debugging information or third-party extensions. In most cases, you won't need to define these. The <kbd>exports()</kbd> function is useful if you're using a Wasm module that you didn't create, although you'll only be able to see the name and kind (for example, <kbd>function</kbd>) of each export.</p>
<p class="mce-root">For simple use cases, you won't be dealing directly with the <kbd>Module</kbd> object or compiled module. Most of the interaction will take place with an <kbd>Instance</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly.Instance</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>WebAssembly.Instance</kbd> object is the instantiated WebAssembly module, which means you can call exported WebAssembly functions from it. Calling <kbd>instantiate()</kbd> or <kbd>instantiateStreaming()</kbd> returns a Promise that resolves with an object containing an instance. You call WebAssembly functions by referencing the name of the function on the instance's <kbd>export</kbd> property. For example, if a module contained an exported function named <kbd>sayHello()</kbd>, you'd call the function using <kbd>instance.exports.sayHello()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly.Memory</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>WebAssembly.Memory</kbd> object holds the memory accessed by a WebAssembly <kbd>Instance</kbd>. This memory can be accessed and changed from both JavaScript and WebAssembly. To create a new instance of <kbd>Memory</kbd>, you need to pass an object with an <kbd>initial</kbd> and (optional) <kbd>maximum</kbd> value to the <kbd>WebAssembly.Memory()</kbd> constructor. These values are in units of WebAssembly pages, where one page is 64 KB. You increase the size of the memory instance by calling the <kbd>grow()</kbd> function with a single parameter that represents the number of WebAssembly pages to grow by. You can also access the current buffer contained in the memory instance through its <kbd>buffer</kbd> property.</p>
<p class="mce-root">MDN describes two ways to get to a <kbd>WebAssembly.Memory</kbd> object. The first way is to construct it from JavaScript (<kbd>var memory = new WebAssembly.Memory(...)</kbd>), while the second way is to have it exported by a WebAssembly module. The important takeaway is that memory can be passed easily between JavaScript and WebAssembly.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly.Table</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>WebAssembly.Table</kbd> object is an array-like structure that is used to store function references. Just as with <kbd>WebAssembly.Memory</kbd>, a <kbd>Table</kbd> can be accessed and changed from both JavaScript and WebAssembly. As of the time of writing, tables can only store function references, but it's likely that, as the technology evolves, additional entities will be able to be stored in tables as well.</p>
<p class="mce-root">To create a new <kbd>Table</kbd> instance, you need to pass an object with an <kbd>element</kbd>, <kbd>initial</kbd>, and (optional) <kbd>maximum</kbd> value. The <kbd>element</kbd> member is a string that represents the type of value stored in the table; currently the only valid value is <kbd>"anyfunc"</kbd> (for functions). The <kbd>initial</kbd> and <kbd>maximum</kbd> values represent the number of elements in the WebAssembly <kbd>Table</kbd>.</p>
<p class="mce-root">You can access the number of elements in the <kbd>Table</kbd> instance using the <kbd>length</kbd> property. The instance also includes methods to manipulate and query elements in the table. The <kbd>get()</kbd> method allows you to access the element at the given index, which is passed in as a parameter. The <kbd>set()</kbd> method allows you to set an element at the index specified as the first parameter to the value specified as the second parameter (per the preceding note, only functions are supported). Finally, <kbd>grow()</kbd> allows you to increase the size of the <kbd>Table</kbd> instance (number of elements) by the number passed in as a parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly errors (CompileError, LinkError, RuntimeError)</h1>
                </header>
            
            <article>
                
<p class="mce-root">The JavaScript API provides constructors to create instances of the <kbd>Error</kbd> objects specific to WebAssembly, but we won't spend too much time covering these objects. The object definition list at the beginning of this section describes the nature of each error, which may be raised if the specified condition is met. All three errors can be constructed with a message, filename, and line number parameter (all of which are optional), and has the same properties and methods as the standard JavaScript <kbd>Error</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting the dots with WasmFiddle</h1>
                </header>
            
            <article>
                
<p>We spent this chapter reviewing the various elements of WebAssembly and the corresponding JavaScript and Web APIs, but understanding how the pieces fit together can still be confusing. As we progress through the examples in this book and you're able to see how C/C++, WebAssembly, and JavaScript interact, these concepts will become clearer.</p>
<p class="mce-root"/>
<p>That being said, a demonstration of this interaction may help in clearing up some of the confusion. In this section, we're going to use an online tool called WasmFiddle to demonstrate the relationship between these elements so you can see WebAssembly in action and get a high-level overview of the development workflow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is WasmFiddle?</h1>
                </header>
            
            <article>
                
<p class="mce-root">WasmFiddle, located at <a href="https://wasdk.github.io/WasmFiddle/">https://wasdk.github.io/WasmFiddle/</a>, is an online code editing tool that allows you to write some C or C++ code and convert it to Wat, compile it to Wasm, or interact with it directly using JavaScript. The C/C++ and JavaScript editors are minimal and aren't intended to be used as your primary development environment, but it offers a valuable service in the Wasm compiler. In <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml">Chapter 3</a>, <em>Setting Up A Development Environment</em>, you'll discover that going from square one to generating Wasm files requires a little bit of work—being able to paste your C code into the browser and hitting a couple of buttons makes things much more convenient. The following diagram gives a quick overview of the interface:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a30bacbd-3e98-45bf-a2af-c4c7b35c24ea.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Components of the WasmFiddle user interface</div>
<p>As you can see, the interface is relatively simple. Let's try out some code!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C code to Wat</h1>
                </header>
            
            <article>
                
<p>The upper-left pane in the following screenshot contains a simple C function that adds 2 to the number specified as a parameter. The lower-left pane contains the corresponding Wat:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/14cdb18b-d295-4891-a9a6-a4ab72246a22.png" style="width:34.00em;height:30.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">C function and the corresponding Wat</div>
<p>If this looks familiar, it's because this same code was used for the explanation of Wat's s-expressions in the beginning of this chapter. Digging a little deeper, you can see how the C code corresponds to the Wat output. The <kbd>addTwo()</kbd> function is exported from the module as a string on line <kbd>5</kbd>. Line <kbd>5</kbd> also contains <kbd>(func $addTwo)</kbd>, which references the <kbd>$addTwo</kbd> function on line <kbd>6</kbd>. Line <kbd>6</kbd> specifies that a single parameter of type <kbd>i32</kbd> (an integer) can be passed in and the result returned is also an <kbd>i32</kbd>. Pressing the <span class="packt_screen">Build</span> button in the upper-right corner (or above the C/C++ editor) will compile the C code into a Wasm file. The Wasm will be available for download or interaction with JavaScript once the build is completed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wasm to JavaScript</h1>
                </header>
            
            <article>
                
<p>The upper-right pane in the following screenshot contains some JavaScript code to compile the Wasm that was generated in the previous step. The <kbd>wasmCode</kbd> was generated when the build finished, so it should be available automatically. Rather than use the <kbd>instantiate()</kbd> method, WasmFiddle creates a compiled <kbd>WebAssembly.Module</kbd> instance and passes that into the constructor of a new <kbd>WebAssembly.Instance</kbd>. The <kbd>wasmImports</kbd> object is currently empty, although we could pass in a <kbd>WebAssembly.Memory</kbd> and <kbd>WebAssembly.Table</kbd> instance if desired:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82dade82-c419-4ccb-85d2-89f58e525bcb.png" style="width:34.42em;height:26.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">JavaScript code calling the C function from the compiled Wasm module</div>
<p>The final line of JavaScript prints the result of <kbd>addTwo()</kbd> to the output in the lower-right pane when passed the number <kbd>2</kbd>. The <kbd>log()</kbd> method is a custom function that ensures the output is printed to the lower-right pane (the number <kbd>4</kbd>). Note how the JavaScript code interacts with <kbd>wasmInstance</kbd>. The <kbd>addTwo()</kbd> function is called from the instance's <kbd>exports</kbd> object. Although this was a contrived example, it demonstrates the steps C or C++ code goes through before it can be used by JavaScript as a Wasm module.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the elements of WebAssembly and their relationship. The structure of the <em>Core Specification</em> was used to describe the mapping of the text and binary formats to a common abstract syntax. We highlighted aspects of the text format (Wat) that can be useful in the context of debugging and development, as well as why s-expressions are an excellent fit for the textual representation of the abstract syntax. We also reviewed details pertaining to the binary format and the various elements that make up a module. The methods and objects within the JavaScript and Web APIs were defined with descriptions of their roles with regard to WebAssembly interaction. Finally, a simple example of the relationship between source code, Wat, and JavaScript was presented using the WasmFiddle tool. </p>
<p>In <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml">Chapter 3</a>, <em>Setting Up a Development Environment</em>, we'll install the development tooling we'll use to work effectively with WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What kind of data are s-expressions good at representing?</li>
<li>What are the four language concepts that are shared between the binary and text formats?</li>
<li>What is one of the use cases for the text format?</li>
<li>What is the only element type that can be stored in a WebAssembly <kbd>Table</kbd>?</li>
<li>What does the JavaScript engine use to manage execution?</li>
<li>Which method requires less code to instantiate a module, <kbd>instantiate()</kbd> or <kbd>instantiateStreaming()</kbd>?</li>
<li>What error objects are available on the <kbd>WebAssembly</kbd> JavaScript object and what event causes each one?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>WebAssembly on MDN: <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">https://developer.mozilla.org/en-US/docs/WebAssembly</a></li>
<li>WasmFiddle: <a href="https://wasdk.github.io/WasmFiddle">https://wasdk.github.io/WasmFiddle</a></li>
<li>S-expressions on Wikipedia: <a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a></li>
<li>Examples of Trees: <a href="http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html">http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>