- en: Changing Levels, Streaming, and Retaining Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变层级、流式传输和保留数据
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Switching levels in UE4 comes in two varieties. One is very simple: unload
    the old level, load in the new one, done (if that''s all you need, this chapter
    may be a very short one!). The second method of streaming levels in and out continuously
    has many more challenges, but can be a much more rewarding user experience too.
    And in both cases, the question remains: what game elements or player data stay
    with you as these levels load? Having that data persist can be a real challenge
    with a couple of solutions we''ll explore here too so that whichever methods are
    chosen, in the end, your player can have a continuous experience that hopefully
    is not too much of a strain on those working on level design!  Our goals here
    are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中切换层级有两种类型。一种是非常简单的：卸载旧层级，加载新层级，完成（如果这就是你需要的，这一章可能非常简短！）。第二种方法是在连续流式传输层级进出的过程中具有更多挑战，但也可以提供更丰富的用户体验。在这两种情况下，问题仍然是：在加载这些层级时，哪些游戏元素或玩家数据会与你一起保留？拥有这些数据持久化可能是一个真正的挑战，我们在这里也会探索一些解决方案，以便无论选择哪种方法，最终玩家都能有一个连续的游戏体验，希望这对那些从事关卡设计的人来说不会太有压力！我们的目标如下：
- en: Cover the basics of map-switching in UE4
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖UE4中地图切换的基础知识
- en: Adding a new level to transition to
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为过渡到新层级添加一个新层级
- en: Adapting the load/save system to persist state across map-transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加载/保存系统调整为在地图转换之间持久化状态
- en: Create a practical example of level streaming from a persistent level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建从持久层级进行层级流式传输的实用示例
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As usual, it is recommended to pick up from the end of Chapter 5, *Adding Enemies!*,
    for continuity, but it is by no means required. All lessons here should be able
    to be applied to any UE4 project at any stage of development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '如往常一样，建议从第5章的结尾“添加敌人！”开始，以保持连贯性，但这绝对不是必需的。这里的所有课程都应能够应用于任何UE4项目在任何开发阶段的任何项目。 '
- en: 'The GitHub project corresponding to it is found here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的GitHub项目可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6)'
- en: 'Engine version used: 4.19.2.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.2。
- en: Traditional level loading
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统层级加载
- en: Changing levels (maps) has been an inherent system of the Unreal Engine since
    its inception. So, naturally, there are several tools and options that have evolved
    with it over the years. That said, we already have all the tools needed for basic
    level changing, but it's still instructive to walk through them, and we'll update
    our loading and saving in this section to keep our progress and game state during
    those switches. First, a quick review of the foundations of level changing in
    UE4.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 改变层级（地图）一直是虚幻引擎自诞生以来的固有系统。因此，自然地，随着时间的发展，已经出现了许多与之相关的工具和选项。话虽如此，我们已经有所有进行基本层级转换所需的工具，但了解这些工具仍然是有益的，我们将在本节中更新我们的加载和保存，以保持在这些切换期间的游戏进度和状态。首先，快速回顾一下UE4中层级转换的基础。
- en: The basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'Blueprint and C++ both have a built-in way to change levels. In a quick blueprint
    example we''ll use here, it''s the Open Level node accessible from most places
    you could ever want to use it in blueprint. In C++, we already used it during
    load/save (though note that for a server-based game, you would normally pass the
    desired level as the first parameter; here, we simply use it to restart the existing
    level with the `"?Restart"` special string):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图和C++都内置了改变层级的方式。在我们这里快速使用的蓝图示例中，它是可以从蓝图中的大多数地方访问的Open Level节点。在C++中，我们已经在加载/保存时使用过它（尽管请注意，对于基于服务器的游戏，你通常会传递所需的层级作为第一个参数；这里，我们只是使用它来使用`"?Restart"`特殊字符串重新启动现有层级）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, triggering one of these in the game is about as simple as it can get. In
    our default FirstPersonExampleMap, I've added a few blocks to resemble a portal
    that is at the top of the moving platform we added some time ago.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在游戏中触发这些操作大约是最简单不过的了。在我们的默认FirstPersonExampleMap中，我添加了一些方块，以模拟一个位于我们之前添加的移动平台顶部的传送门。
- en: If you check GitHub, there is a Stash for this chapter on fixing the moving
    platforms because they can squish pawns (player or NPCs) out of the level when
    moving back down. It's not a perfect fix, but it simply disables collision as
    the platform moves back down and re-enables it once it reaches the bottom (and
    some other minor logic was fixed in the platforms). As this is not a specific
    goal of this chapter, however, it was stashed instead of checked directly into
    the GitHub project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In the middle of this, I added a simple trigger volume from the Volumes set
    on the left (no new blueprint class or instance is even needed):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a94ed8a-d097-4223-83b3-de14afd5fa43.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'With this selected, open the level blueprint by clicking Blueprints button
    at the top on the main menu bar, and selecting Open Level Blueprint. In there,
    while the volume is selected and you right-click, at the very top you have access
    to options specific to that specific object in the level. We''ll use its overlap
    event, check whether it''s the player, and if so, open MasteringTestLevel, as
    seen here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdb38767-10e3-4c4a-8dcf-122a81de24e9.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: That's it. Really. Just walk into the trigger and we'll be launched in the other
    level. If this is all your project needs, then it's best to stop here and keep
    life simple!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Using load/save to transition
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most games, especially those with a story-based single player mode or the like,
    though, will want the player''s status after leaving, as well as the state of
    the level itself, to be persistent across this transition. If we make a simple
    portal back to `FirstPersonExampleMap` just like we did in the preceding section,
    you''ll notice when switching back and forth that our player, the items, NPCs,
    and so on in those levels are as if we had opened them anew, rather than the state
    they were in when we left, and the player''s inventory is loaded anew as well.
    So now really we need two distinct things:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the player's data intact across any level load
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and saving the state of that level and its dynamic objects when switching
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, we have already implemented dynamic any-time loading and saving,
    so we'll just modify that and take advantage of it for the level state. But then
    we need something new for persisting data across map changes. There are several
    options to this (some definitely safer or more clean than others) but for our
    game, we'll make a new `UGameInstance` C++ class and use it like a singleton to
    hold data and information that will persist throughout the entire lifetime of
    the game being run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Any time static or global data is introduced, you must be extremely careful
    as it can have unforeseen effects on things such as play in editor, where even
    though you stop playing, so long as the editor is not closed and re-opened, any
    of that static data persists and so you cannot count on the same behavior starting
    and restarting PIE versus a standalone version of the game, say, on a device or
    other platform. We'll put in some safeguards here for our example, but use caution
    and minimize dangerous data storage whenever possible!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll name the new game instance `MasteringGameInstance` and give it some
    singleton-like functionality:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see above, this gives us a few pieces of persistent data that we'd
    like to survive loading and saving cycles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, some helper functions to get all of this working, and to make setting
    the player''s inventory and cleaning up our own state in the game instance simple:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, `BeginDestroy` and `FinishDestroy` probably won't need to both
    be here for us; but it's usually a good idea with static data holders such as
    this to have both. In `FinishDestroy`, if nothing else, you can put in safeguards
    to make sure no code after a session uses this same instance of the `GameInstance`
    without calling `Init` first, and clean up any remaining issues (you can even
    set `Instance` back to `nullptr` if you want to be extra safe). `BeginDestroy`
    for reference is the place to immediately clear out any data that any other classes
    might look to and make use of. We'll have a couple of those once we start this
    load/save task in earnest ( for example you definitely don't want to be in the
    middle of a load/save cycle, quit the game, and then upon restarting it have your
    variables set to what they were set to by that load/save starting). Be sure this
    point to go to Settings, Project Settings, and in Maps and Modes, set your game
    instance to `MasteringGameInstance`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to consolidate and abstract our game loading code a bit, we''ll make
    a new Blueprint Function Library C++ class (which almost by definition is a collection
    of static functions, which is just what we need here, even if it''s not necessarily
    ever called from blueprint):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And refactor the `MainMenuWidget` class to move huge swathes of code here where
    it''s more appropriate going forward, making that UI class much more focused and
    specific. Also, we now have some extra fix-up code that adjusts our player''s
    position and accounts for persisting the current inventory through a load cycle,
    like we want when returning to a level we previously visited:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Above you can see the method of loading, if we're going to the same world we're
    already on, we tell the world to restart essentially, otherwise, we open the new
    level.  We also save out the player's current position as "safe" as we can be
    confident it is a valid position for the player to occupy and we might need it
    if we're transitioning back to this level later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Saving is where the real work is done, and following the flow can be a bit tricky;
    but if you collapse the implementation of the actor loop above, the rest is pretty
    straight-forward, get the safe-location, clear out the safe-location (for clarity),
    then iterate those actors, serialize to our output, and save that as a file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fixing up the player is a special case that takes a lot of delicate work so
    is included here in its full form.  It's quite tricky to get all of the properties
    of the player put back to where we wanted them at the time of saving, but take
    the time to go through (and step through in your IDE with breakpoints!) the above
    code a couple of times.  Getting this right, and starting the precedent of it
    *being* right from the start of a load/save system like this is critical.  Take
    the time to understand it and when implementing it, to get it right, and test,
    test, test!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The changes needed to the menu widget class should be self-evident, but this
    can be seen in a checkpoint in the GitHub project if necessary. This allows us
    to take advantage of the loading and saving code from essentially anywhere C++
    (or even blueprint).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, really our only missing piece is a new trigger box type that has a
    little bit of special C++ code, adjusting our load/save process to ignore loading
    the inventory saved at save time, and restoring inventory at level-switch time.
    So, two quick steps: make a new trigger box subclass, and add the player inventory
    and volume''s safe position to the game instance. So, naming our new volume `LevelTransitionVolume`
    and giving it some functionality with added variables and functions to the game
    instance, we can now transition with our player''s inventory and the rest loaded
    from the save game of where we are going, and if we''re just switching levels,
    we keep the player''s current inventory (and if necessary, any other information).
    If we''re doing a full load, of course we need to restore what was saved.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this volume, in which we''ll replace the two volumes in the two
    levels used previously for testing, looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So now we're transitioning to the new level, and have saved where we were at
    the time we left the current one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll do the player here at this point, then finish off with finding any actors
    we found saved data for that haven''t already respawned (typically projectiles
    we made, for example):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After replacing the old trigger volumes and setting the right Transition Level
    names on the new boxes in the levels, of course we can remove the old logic in
    the level blueprints too. So, as seen previously, if we already have a save file
    matching the transition of to/from that we are about to do, load that save file.
    In any case, we will still preserve the player's inventory because of the lines
    setting this in the game instance near the top of this function, and save the
    state in our from/to form before leaving.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow our inventory to easily be transferred around, we can add a couple
    of utility functions. Note: it''s also possible to persist `UObject ` instances (other
    than the game instance) across level loading, but this often has unforeseen consequences
    with objects that reference other objects, which may be destroyed during a level
    load. So, in this case, we just make copying of inventory objects simple:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的库存容易转移，我们可以添加几个实用函数。注意：也可以在级别加载期间持久化`UObject`实例（除了游戏实例之外），但这通常会对在级别加载期间可能被销毁的引用其他对象的实例产生不可预见的影响。因此，在这种情况下，我们只是使库存对象的复制变得简单：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the last thing to do is to make an actual blueprint of the new trigger
    box and give it a proper safe-location where we can place the player. If we don''t
    do this, the player will be continually placed at the same spot they saved from
    (when they intersected the box), and you''ll get the player bouncing back and
    forth between the two levels infinitely. For those looking closely, you''ll see
    in the construction script that collision is initially disabled, and then the
    timer here re-enables it. This is because we need one tick of the game world to
    move the player to the updated position, and if we don''t briefly disable overlap
    events, we get the ping-pong behavior mentioned earlier when we do try to do the
    move:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后要做的就是制作一个新的触发盒的实际蓝图，并给它一个合适的安放位置，以便我们可以放置玩家。如果我们不这样做，玩家将不断被放置在保存的位置（当它们与盒子相交时），并且玩家将在两个级别之间无限弹跳。对于那些仔细观察的人，你会在构造脚本中看到碰撞最初是禁用的，然后这里的计时器重新启用它。这是因为我们需要游戏世界的一个tick来将玩家移动到更新后的位置，如果我们不暂时禁用重叠事件，当我们尝试移动时，就会得到前面提到的ping-pong行为：
- en: '![](img/7d6400fa-245f-43ea-80c4-4b4d51a87d55.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d6400fa-245f-43ea-80c4-4b4d51a87d55.png)'
- en: 'At this point, the player can transition back and forth between our two playable
    levels, have inventory persist at the current level, be placed at a safe position
    so they don''t immediately go back to the other level, and each level saves and
    restores the rest of its state like a normal load of a save. The only thing now
    missing as a general feature would be a spinning icon or fade-to-black and progress
    bar during the loading itself. UE4 certainly allows for these kinds of things,
    which update outside of the main game thread tick, but will not be specifically
    implemented here as we still have another major topic to delve into: streaming
    levels.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，玩家可以在我们的两个可玩级别之间来回切换，库存保持在当前级别，被放置在安全位置，这样他们就不会立即回到另一个级别，每个级别都像正常加载保存一样保存和恢复其状态。现在唯一缺少的一般功能可能是在加载过程中有一个旋转图标或淡入黑色和进度条。UE4当然允许这些类型的事情，它们在主游戏线程tick之外更新，但在这里不会具体实现，因为我们还有另一个主要主题要深入研究：流式传输级别。
- en: Perchance to stream?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有可能进行流式传输吗？
- en: 'So far we have now used triggering elements to load a specific level. Streaming,
    as it''s commonly known, is another method of loading levels on demand and allows
    for a much larger playing area without having to have all the encompassing actors
    loaded at any given time. Unreal allows this in two distinct ways, but they can
    complement each other: streaming volumes, and world composition. We''ll briefly
    explore these here, but they are great solutions for giving a huge playing area
    and keeping loaded memory at any given moment at a reasonable level. There are,
    of course, some drawbacks to this as well.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了触发元素来加载特定级别。流式传输，正如其通常所知，是另一种按需加载级别的的方法，它允许在不必须加载所有包围演员的情况下拥有更大的游戏区域。虚幻引擎以两种不同的方式允许这样做，但它们可以相互补充：流式体积和世界组成。我们在这里简要探讨这些内容，但它们是提供巨大游戏区域并保持任何给定时刻加载内存处于合理水平的好方法。当然，这种方法也有一些缺点。
- en: Streaming advantages and disadvantages
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式传输的优点和缺点
- en: 'The advantages of streaming are probably obvious. As already noted, there''s
    big spaces and manageable memory load. The disadvantages are probably a little
    less obvious, but are clearly illustrated with our first checkpoint here in the
    GitHub project: essentially duplicating (minus skybox and lighting) the `MasteringTestMap`
    into two other levels that are offset from it and streaming those in with streaming
    volumes. To do this, first go to the main editor Window menu and select Levels.
    Two new levels have been added with their offsets and each has a NavMesh volume
    around it to generate proper meshes. These meshes, when the levels are loaded,
    will combine.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'When a level is streamed out, however, all the actors in it will be destroyed,
    and when it is streamed back in, they will all be recreated as if loaded anew.
    So in this example, there are two new levels, MasteringTestMapW1 and W2\. MasteringTestMap
    will be our persistent level. This is the top-most level, which is *always* loaded.
    All streaming volumes also need to be placed in this level. So, as seen here,
    in a rough, demonstrative way, when starting MasteringTestMap and turning 90-degrees
    left and running, you see there is a short overlap of a few meters for the volume
    that streams in W1, and similarly there is a small overlap of W1''s map and the
    streaming volume for W2\. Normally you want these volumes to encompass any time
    the player can see that area, but in this case, we want to show streaming out:
    so if you run left, before hitting the edge of MasteringTestMap, W1 streams in.
    A similar thing will happen if you continue to W2\. If you go further into W2
    you''ll see that W1 then streams out when the player leaves W1''s volume, and
    similarly when heading back through W1 you can watch as W2 quickly streams out.
    Now come our problems. In W2 there is a volume to spawn more countess enemies.
    If you go slowly and carefully, they can chase you back into W1, but if you run
    quickly, W2 streams out and the countesses fall out of the world. Also, when streaming
    W1 back in, any weapon pickups that were previously collected now return.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic objects and streaming like this are the biggest issue to reconcile:
    how do you inform the newly loaded level that it should not respawn weapon pickups
    placed on the ground? How do the countesses handle their home level streaming
    out?  This utterly breaks their return-home behavior as they literally can''t
    do so (their pathfinding fails). Of course, it''s possible to save the state of
    objects spawned or destroyed in various levels when their streamed level streams
    out, either in the persistent level in a small way (such as simply storing the
    actor''s position and state) or possibly in the game instance as we with the player''s
    inventory across the level loads in the previous section. However, this is a lot
    of upkeep, so as with many features like this, if you intend to use streaming be
    sure to decide early and educate any other team-members on how to properly set
    these things up so your player feels like it is a seamless world. But first, let''s
    see a quick difference between these two streaming methods and observe the difficulties
    mentioned.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Example streaming and best practices
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To stream these levels, in the Levels window, you first have to click the Levels
    drop-down at the top and click on Add Existing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding W1 and W2 allows us to select them and then hook their loading state
    to the volumes shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/866065cb-a875-4596-8330-4096b918f137.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'With those added, and the volumes added like so to MasteringTestMap, it should
    look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce29f67a-44ee-4676-8ac1-695607c63615.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Back in the levels window, clicking the plus button on the volumes array allows
    us to then use the eye-dropper to drag into the world and select the right volume,
    or simply use the drop-down and pick the volume we want to associate with this
    level. Again, note the small overlaps. To avoid players noticing the streaming,
    it's usually best to make a much larger overlap area and also potentially bring
    in a fog-distance so the actual loading is not so obvious. For our instructive
    case, again, we want it to be obvious here. Now, with these pieces in place you
    can run West and see the levels come in and drop out as the player (actually the
    camera, to be exact) enters these areas and leaves them.  And again, with a couple
    of test runs, it should be obvious how the drawbacks mentioned are clearly visible
    if not accounted for as levels stream in and out. Should a countess never leave
    her home level? Should she disappear when her home level streams out? Should pickups
    somehow know they've previously been picked up and either not spawn or destroy
    themselves, like we do with pick-ups picked up when loading a save game? These
    are all questions each project must decide, weighing the complexity of maintaining
    such a system versus the player experience and not breaking their immersion.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Using volumes can be a great way to manually control exact levels of detail.
    For example, you can stream in basic physics and a bit of static mesh geometry
    with a very large volume to avoid any worries of the falling out of world problems
    such as the countess has, while then having an additional level with a smaller
    volume that only loads in when the player is closer, which loads a large number
    of cosmetic geometry that doesn''t impact gameplay. A limitation of volume-based
    streaming, though, is that levels can only extend from the origin of the persistent
    level out to `WORLD_MAX`, which is about 2 km (or from the start, 1 km East/West,
    1 km North/South). In most games, this is plenty. For an open world (and don''t
    forget you can still hard-transition to other persistent levels, such as indoor
    areas!) within this size limitation, we found a brick-like tiling was best for
    overlapping levels to be loaded. So, when you''re in the level in the center,
    the levels around it in this pattern would be loaded:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用体积可以是一种手动控制精确细节水平的好方法。例如，你可以使用一个非常大的体积来流式传输基本的物理和少量的静态网格几何形状，以避免任何世界掉落问题，比如伯爵遇到的问题，同时还有一个额外的级别，体积更小，只有当玩家靠近时才加载，这会加载大量不影响游戏玩法的外观几何形状。然而，基于体积的流式传输的一个限制是，级别只能从持久级别的起点扩展到`WORLD_MAX`，大约是2公里（或者从起点开始，东西方向1公里，南北方向1公里）。在大多数游戏中，这已经足够了。对于在这个尺寸限制内的开放世界（别忘了你仍然可以硬切换到其他持久级别，比如室内区域！），我们发现砖块状拼接最适合重叠级别加载。因此，当你处于中心级别时，按照这种模式围绕它的级别将会被加载：
- en: '![](img/227e7fa7-bedb-4bd9-be9c-cb9d62905b45.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/227e7fa7-bedb-4bd9-be9c-cb9d62905b45.png)'
- en: This way you can also work with level designers so that the sum memory of those
    seven levels is always less than a certain cap. So, for example, you could have
    some low-detail areas with a very high-detail area in the center, but of course
    as you move around and this pattern repeats, the sum of any seven loaded levels
    should be maintained under that agreed-upon cap. And the nice part is that server-based
    multiplayer games already respect this kind of streaming and have no problems
    tracking players across these boundaries from their clients. If your world needs
    a much larger or nearly boundless play space, world composition is worth exploring.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你还可以与级别设计师合作，确保这七个级别的总内存始终低于某个特定的上限。例如，你可以有一些低细节区域和中心的高细节区域，但当然，随着你的移动和这个模式的重复，任何七个加载级别的总和应该保持在商定的上限以下。而且，令人高兴的是，基于服务器的多人游戏已经尊重这种流式传输，并且没有问题跟踪客户端之间的玩家。如果你的世界需要一个更大或几乎无界的游戏空间，世界组成值得探索。
- en: World composition is a great way to create automated, grid-based tiling built
    into UE4\. This is particularly useful for very large worlds where the player
    can then travel almost endlessly in any given direction, but requires a large
    effort by artists or level designers typically to make these sections and make
    them match exactly at their borders. A perfect application for world composition
    is a single-player open-world game where exploration and a truly vast play area
    are the goal. As this is a bit niche, and Epic themselves have done a very nice
    job of documenting the feature, a link will be added to the *Further reading* section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 世界组成是创建自动化的、基于网格的拼接的好方法，它内置在UE4中。这对于非常大的世界非常有用，玩家可以在任何给定方向上几乎无限地旅行，但通常需要艺术家或级别设计师的大量工作来制作这些部分，并确保它们在边界处完全匹配。世界组成的完美应用是一个单人开放世界游戏，其中探索和真正广阔的游戏区域是目标。由于这是一个相当小众的领域，Epic
    本身已经对功能做了很好的文档记录，将在*进一步阅读*部分添加链接。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'From the start of this chapter to its completion, we have now demonstrated
    how to persist level state and player state independently across traditional level
    loads, as well as the basics of streaming levels as the player moves around. These
    are fundamental to almost all conceivable games in UE4 and should now form the
    basis of whatever strategy works best for a team and project going forward. Always
    remember: make these decisions early! It can be nearly impossible, for example,
    to retrofit levels built assuming a hard level-load into a streaming model, but
    if you adopt that streaming model and help your team stick to its limits from
    day one, this is one worry that won''t haunt you late in a project cycle.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章的开始到结束，我们现在已经展示了如何在传统的关卡加载中独立持久化关卡状态和玩家状态，以及玩家移动时流式传输关卡的基础知识。这些对于几乎所有的UE4可想象的游戏都是基本的，现在应该成为任何团队和项目向前发展的最佳策略的基础。始终记住：尽早做出这些决定！例如，将假设硬关卡加载的关卡改造为流式模型几乎是不可能的，但如果你从第一天就采用流式模型并帮助你的团队坚持其限制，那么这将是你在项目周期后期不会感到困扰的一个担忧。
- en: Questions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What existing classes or objects can be used in UE4 to implement level loading
    with no new changes?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4中可以使用哪些现有的类或对象来实现无需新更改的关卡加载？
- en: What are some limitations of using only these methods?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用这些方法有哪些局限性？
- en: What is the scope of the lifetime of the game instance object?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏实例对象的生命周期范围是什么？
- en: How is the game instance used to persist data when opening a new level or loading
    an existing one's state?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当打开新关卡或加载现有关卡的状态时，游戏实例是如何用来持久化数据的？
- en: What is the purpose of abstracting level load/save code to a blueprint function
    library?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将关卡加载/保存代码抽象到蓝图函数库的目的是什么？
- en: Why is the player's inventory copied rather than scoping a `UObject` to the
    game instance?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么玩家的库存被复制而不是将`UObject`范围限定在游戏实例中？
- en: What are the major drawbacks of volume-based streaming?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于体积的流式传输的主要缺点是什么？
- en: Which types of games should definitely use world composition?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的游戏肯定应该使用世界组成？
- en: Further reading
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'World composition in UE4:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: UE4中的世界组成：
- en: '[https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser](https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser](https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser)'
