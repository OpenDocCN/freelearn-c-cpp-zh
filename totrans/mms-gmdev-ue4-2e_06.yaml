- en: Changing Levels, Streaming, and Retaining Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switching levels in UE4 comes in two varieties. One is very simple: unload
    the old level, load in the new one, done (if that''s all you need, this chapter
    may be a very short one!). The second method of streaming levels in and out continuously
    has many more challenges, but can be a much more rewarding user experience too.
    And in both cases, the question remains: what game elements or player data stay
    with you as these levels load? Having that data persist can be a real challenge
    with a couple of solutions we''ll explore here too so that whichever methods are
    chosen, in the end, your player can have a continuous experience that hopefully
    is not too much of a strain on those working on level design!  Our goals here
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Cover the basics of map-switching in UE4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new level to transition to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting the load/save system to persist state across map-transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a practical example of level streaming from a persistent level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, it is recommended to pick up from the end of Chapter 5, *Adding Enemies!*,
    for continuity, but it is by no means required. All lessons here should be able
    to be applied to any UE4 project at any stage of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub project corresponding to it is found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Engine version used: 4.19.2.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional level loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Changing levels (maps) has been an inherent system of the Unreal Engine since
    its inception. So, naturally, there are several tools and options that have evolved
    with it over the years. That said, we already have all the tools needed for basic
    level changing, but it's still instructive to walk through them, and we'll update
    our loading and saving in this section to keep our progress and game state during
    those switches. First, a quick review of the foundations of level changing in
    UE4.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blueprint and C++ both have a built-in way to change levels. In a quick blueprint
    example we''ll use here, it''s the Open Level node accessible from most places
    you could ever want to use it in blueprint. In C++, we already used it during
    load/save (though note that for a server-based game, you would normally pass the
    desired level as the first parameter; here, we simply use it to restart the existing
    level with the `"?Restart"` special string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, triggering one of these in the game is about as simple as it can get. In
    our default FirstPersonExampleMap, I've added a few blocks to resemble a portal
    that is at the top of the moving platform we added some time ago.
  prefs: []
  type: TYPE_NORMAL
- en: If you check GitHub, there is a Stash for this chapter on fixing the moving
    platforms because they can squish pawns (player or NPCs) out of the level when
    moving back down. It's not a perfect fix, but it simply disables collision as
    the platform moves back down and re-enables it once it reaches the bottom (and
    some other minor logic was fixed in the platforms). As this is not a specific
    goal of this chapter, however, it was stashed instead of checked directly into
    the GitHub project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the middle of this, I added a simple trigger volume from the Volumes set
    on the left (no new blueprint class or instance is even needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a94ed8a-d097-4223-83b3-de14afd5fa43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this selected, open the level blueprint by clicking Blueprints button
    at the top on the main menu bar, and selecting Open Level Blueprint. In there,
    while the volume is selected and you right-click, at the very top you have access
    to options specific to that specific object in the level. We''ll use its overlap
    event, check whether it''s the player, and if so, open MasteringTestLevel, as
    seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdb38767-10e3-4c4a-8dcf-122a81de24e9.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it. Really. Just walk into the trigger and we'll be launched in the other
    level. If this is all your project needs, then it's best to stop here and keep
    life simple!
  prefs: []
  type: TYPE_NORMAL
- en: Using load/save to transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most games, especially those with a story-based single player mode or the like,
    though, will want the player''s status after leaving, as well as the state of
    the level itself, to be persistent across this transition. If we make a simple
    portal back to `FirstPersonExampleMap` just like we did in the preceding section,
    you''ll notice when switching back and forth that our player, the items, NPCs,
    and so on in those levels are as if we had opened them anew, rather than the state
    they were in when we left, and the player''s inventory is loaded anew as well.
    So now really we need two distinct things:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the player's data intact across any level load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and saving the state of that level and its dynamic objects when switching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, we have already implemented dynamic any-time loading and saving,
    so we'll just modify that and take advantage of it for the level state. But then
    we need something new for persisting data across map changes. There are several
    options to this (some definitely safer or more clean than others) but for our
    game, we'll make a new `UGameInstance` C++ class and use it like a singleton to
    hold data and information that will persist throughout the entire lifetime of
    the game being run.
  prefs: []
  type: TYPE_NORMAL
- en: Any time static or global data is introduced, you must be extremely careful
    as it can have unforeseen effects on things such as play in editor, where even
    though you stop playing, so long as the editor is not closed and re-opened, any
    of that static data persists and so you cannot count on the same behavior starting
    and restarting PIE versus a standalone version of the game, say, on a device or
    other platform. We'll put in some safeguards here for our example, but use caution
    and minimize dangerous data storage whenever possible!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll name the new game instance `MasteringGameInstance` and give it some
    singleton-like functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see above, this gives us a few pieces of persistent data that we'd
    like to survive loading and saving cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, some helper functions to get all of this working, and to make setting
    the player''s inventory and cleaning up our own state in the game instance simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this point, `BeginDestroy` and `FinishDestroy` probably won't need to both
    be here for us; but it's usually a good idea with static data holders such as
    this to have both. In `FinishDestroy`, if nothing else, you can put in safeguards
    to make sure no code after a session uses this same instance of the `GameInstance`
    without calling `Init` first, and clean up any remaining issues (you can even
    set `Instance` back to `nullptr` if you want to be extra safe). `BeginDestroy`
    for reference is the place to immediately clear out any data that any other classes
    might look to and make use of. We'll have a couple of those once we start this
    load/save task in earnest ( for example you definitely don't want to be in the
    middle of a load/save cycle, quit the game, and then upon restarting it have your
    variables set to what they were set to by that load/save starting). Be sure this
    point to go to Settings, Project Settings, and in Maps and Modes, set your game
    instance to `MasteringGameInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to consolidate and abstract our game loading code a bit, we''ll make
    a new Blueprint Function Library C++ class (which almost by definition is a collection
    of static functions, which is just what we need here, even if it''s not necessarily
    ever called from blueprint):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And refactor the `MainMenuWidget` class to move huge swathes of code here where
    it''s more appropriate going forward, making that UI class much more focused and
    specific. Also, we now have some extra fix-up code that adjusts our player''s
    position and accounts for persisting the current inventory through a load cycle,
    like we want when returning to a level we previously visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Above you can see the method of loading, if we're going to the same world we're
    already on, we tell the world to restart essentially, otherwise, we open the new
    level.  We also save out the player's current position as "safe" as we can be
    confident it is a valid position for the player to occupy and we might need it
    if we're transitioning back to this level later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Saving is where the real work is done, and following the flow can be a bit tricky;
    but if you collapse the implementation of the actor loop above, the rest is pretty
    straight-forward, get the safe-location, clear out the safe-location (for clarity),
    then iterate those actors, serialize to our output, and save that as a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Fixing up the player is a special case that takes a lot of delicate work so
    is included here in its full form.  It's quite tricky to get all of the properties
    of the player put back to where we wanted them at the time of saving, but take
    the time to go through (and step through in your IDE with breakpoints!) the above
    code a couple of times.  Getting this right, and starting the precedent of it
    *being* right from the start of a load/save system like this is critical.  Take
    the time to understand it and when implementing it, to get it right, and test,
    test, test!
  prefs: []
  type: TYPE_NORMAL
- en: The changes needed to the menu widget class should be self-evident, but this
    can be seen in a checkpoint in the GitHub project if necessary. This allows us
    to take advantage of the loading and saving code from essentially anywhere C++
    (or even blueprint).
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, really our only missing piece is a new trigger box type that has a
    little bit of special C++ code, adjusting our load/save process to ignore loading
    the inventory saved at save time, and restoring inventory at level-switch time.
    So, two quick steps: make a new trigger box subclass, and add the player inventory
    and volume''s safe position to the game instance. So, naming our new volume `LevelTransitionVolume`
    and giving it some functionality with added variables and functions to the game
    instance, we can now transition with our player''s inventory and the rest loaded
    from the save game of where we are going, and if we''re just switching levels,
    we keep the player''s current inventory (and if necessary, any other information).
    If we''re doing a full load, of course we need to restore what was saved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this volume, in which we''ll replace the two volumes in the two
    levels used previously for testing, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So now we're transitioning to the new level, and have saved where we were at
    the time we left the current one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll do the player here at this point, then finish off with finding any actors
    we found saved data for that haven''t already respawned (typically projectiles
    we made, for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After replacing the old trigger volumes and setting the right Transition Level
    names on the new boxes in the levels, of course we can remove the old logic in
    the level blueprints too. So, as seen previously, if we already have a save file
    matching the transition of to/from that we are about to do, load that save file.
    In any case, we will still preserve the player's inventory because of the lines
    setting this in the game instance near the top of this function, and save the
    state in our from/to form before leaving.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow our inventory to easily be transferred around, we can add a couple
    of utility functions. Note: it''s also possible to persist `UObject ` instances (other
    than the game instance) across level loading, but this often has unforeseen consequences
    with objects that reference other objects, which may be destroyed during a level
    load. So, in this case, we just make copying of inventory objects simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the last thing to do is to make an actual blueprint of the new trigger
    box and give it a proper safe-location where we can place the player. If we don''t
    do this, the player will be continually placed at the same spot they saved from
    (when they intersected the box), and you''ll get the player bouncing back and
    forth between the two levels infinitely. For those looking closely, you''ll see
    in the construction script that collision is initially disabled, and then the
    timer here re-enables it. This is because we need one tick of the game world to
    move the player to the updated position, and if we don''t briefly disable overlap
    events, we get the ping-pong behavior mentioned earlier when we do try to do the
    move:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d6400fa-245f-43ea-80c4-4b4d51a87d55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the player can transition back and forth between our two playable
    levels, have inventory persist at the current level, be placed at a safe position
    so they don''t immediately go back to the other level, and each level saves and
    restores the rest of its state like a normal load of a save. The only thing now
    missing as a general feature would be a spinning icon or fade-to-black and progress
    bar during the loading itself. UE4 certainly allows for these kinds of things,
    which update outside of the main game thread tick, but will not be specifically
    implemented here as we still have another major topic to delve into: streaming
    levels.'
  prefs: []
  type: TYPE_NORMAL
- en: Perchance to stream?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have now used triggering elements to load a specific level. Streaming,
    as it''s commonly known, is another method of loading levels on demand and allows
    for a much larger playing area without having to have all the encompassing actors
    loaded at any given time. Unreal allows this in two distinct ways, but they can
    complement each other: streaming volumes, and world composition. We''ll briefly
    explore these here, but they are great solutions for giving a huge playing area
    and keeping loaded memory at any given moment at a reasonable level. There are,
    of course, some drawbacks to this as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming advantages and disadvantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advantages of streaming are probably obvious. As already noted, there''s
    big spaces and manageable memory load. The disadvantages are probably a little
    less obvious, but are clearly illustrated with our first checkpoint here in the
    GitHub project: essentially duplicating (minus skybox and lighting) the `MasteringTestMap`
    into two other levels that are offset from it and streaming those in with streaming
    volumes. To do this, first go to the main editor Window menu and select Levels.
    Two new levels have been added with their offsets and each has a NavMesh volume
    around it to generate proper meshes. These meshes, when the levels are loaded,
    will combine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a level is streamed out, however, all the actors in it will be destroyed,
    and when it is streamed back in, they will all be recreated as if loaded anew.
    So in this example, there are two new levels, MasteringTestMapW1 and W2\. MasteringTestMap
    will be our persistent level. This is the top-most level, which is *always* loaded.
    All streaming volumes also need to be placed in this level. So, as seen here,
    in a rough, demonstrative way, when starting MasteringTestMap and turning 90-degrees
    left and running, you see there is a short overlap of a few meters for the volume
    that streams in W1, and similarly there is a small overlap of W1''s map and the
    streaming volume for W2\. Normally you want these volumes to encompass any time
    the player can see that area, but in this case, we want to show streaming out:
    so if you run left, before hitting the edge of MasteringTestMap, W1 streams in.
    A similar thing will happen if you continue to W2\. If you go further into W2
    you''ll see that W1 then streams out when the player leaves W1''s volume, and
    similarly when heading back through W1 you can watch as W2 quickly streams out.
    Now come our problems. In W2 there is a volume to spawn more countess enemies.
    If you go slowly and carefully, they can chase you back into W1, but if you run
    quickly, W2 streams out and the countesses fall out of the world. Also, when streaming
    W1 back in, any weapon pickups that were previously collected now return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic objects and streaming like this are the biggest issue to reconcile:
    how do you inform the newly loaded level that it should not respawn weapon pickups
    placed on the ground? How do the countesses handle their home level streaming
    out?  This utterly breaks their return-home behavior as they literally can''t
    do so (their pathfinding fails). Of course, it''s possible to save the state of
    objects spawned or destroyed in various levels when their streamed level streams
    out, either in the persistent level in a small way (such as simply storing the
    actor''s position and state) or possibly in the game instance as we with the player''s
    inventory across the level loads in the previous section. However, this is a lot
    of upkeep, so as with many features like this, if you intend to use streaming be
    sure to decide early and educate any other team-members on how to properly set
    these things up so your player feels like it is a seamless world. But first, let''s
    see a quick difference between these two streaming methods and observe the difficulties
    mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: Example streaming and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To stream these levels, in the Levels window, you first have to click the Levels
    drop-down at the top and click on Add Existing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding W1 and W2 allows us to select them and then hook their loading state
    to the volumes shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/866065cb-a875-4596-8330-4096b918f137.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With those added, and the volumes added like so to MasteringTestMap, it should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce29f67a-44ee-4676-8ac1-695607c63615.png)'
  prefs: []
  type: TYPE_IMG
- en: Back in the levels window, clicking the plus button on the volumes array allows
    us to then use the eye-dropper to drag into the world and select the right volume,
    or simply use the drop-down and pick the volume we want to associate with this
    level. Again, note the small overlaps. To avoid players noticing the streaming,
    it's usually best to make a much larger overlap area and also potentially bring
    in a fog-distance so the actual loading is not so obvious. For our instructive
    case, again, we want it to be obvious here. Now, with these pieces in place you
    can run West and see the levels come in and drop out as the player (actually the
    camera, to be exact) enters these areas and leaves them.  And again, with a couple
    of test runs, it should be obvious how the drawbacks mentioned are clearly visible
    if not accounted for as levels stream in and out. Should a countess never leave
    her home level? Should she disappear when her home level streams out? Should pickups
    somehow know they've previously been picked up and either not spawn or destroy
    themselves, like we do with pick-ups picked up when loading a save game? These
    are all questions each project must decide, weighing the complexity of maintaining
    such a system versus the player experience and not breaking their immersion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using volumes can be a great way to manually control exact levels of detail.
    For example, you can stream in basic physics and a bit of static mesh geometry
    with a very large volume to avoid any worries of the falling out of world problems
    such as the countess has, while then having an additional level with a smaller
    volume that only loads in when the player is closer, which loads a large number
    of cosmetic geometry that doesn''t impact gameplay. A limitation of volume-based
    streaming, though, is that levels can only extend from the origin of the persistent
    level out to `WORLD_MAX`, which is about 2 km (or from the start, 1 km East/West,
    1 km North/South). In most games, this is plenty. For an open world (and don''t
    forget you can still hard-transition to other persistent levels, such as indoor
    areas!) within this size limitation, we found a brick-like tiling was best for
    overlapping levels to be loaded. So, when you''re in the level in the center,
    the levels around it in this pattern would be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/227e7fa7-bedb-4bd9-be9c-cb9d62905b45.png)'
  prefs: []
  type: TYPE_IMG
- en: This way you can also work with level designers so that the sum memory of those
    seven levels is always less than a certain cap. So, for example, you could have
    some low-detail areas with a very high-detail area in the center, but of course
    as you move around and this pattern repeats, the sum of any seven loaded levels
    should be maintained under that agreed-upon cap. And the nice part is that server-based
    multiplayer games already respect this kind of streaming and have no problems
    tracking players across these boundaries from their clients. If your world needs
    a much larger or nearly boundless play space, world composition is worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: World composition is a great way to create automated, grid-based tiling built
    into UE4\. This is particularly useful for very large worlds where the player
    can then travel almost endlessly in any given direction, but requires a large
    effort by artists or level designers typically to make these sections and make
    them match exactly at their borders. A perfect application for world composition
    is a single-player open-world game where exploration and a truly vast play area
    are the goal. As this is a bit niche, and Epic themselves have done a very nice
    job of documenting the feature, a link will be added to the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the start of this chapter to its completion, we have now demonstrated
    how to persist level state and player state independently across traditional level
    loads, as well as the basics of streaming levels as the player moves around. These
    are fundamental to almost all conceivable games in UE4 and should now form the
    basis of whatever strategy works best for a team and project going forward. Always
    remember: make these decisions early! It can be nearly impossible, for example,
    to retrofit levels built assuming a hard level-load into a streaming model, but
    if you adopt that streaming model and help your team stick to its limits from
    day one, this is one worry that won''t haunt you late in a project cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What existing classes or objects can be used in UE4 to implement level loading
    with no new changes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some limitations of using only these methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the scope of the lifetime of the game instance object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the game instance used to persist data when opening a new level or loading
    an existing one's state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of abstracting level load/save code to a blueprint function
    library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the player's inventory copied rather than scoping a `UObject` to the
    game instance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the major drawbacks of volume-based streaming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which types of games should definitely use world composition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'World composition in UE4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser](https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser)'
  prefs: []
  type: TYPE_NORMAL
