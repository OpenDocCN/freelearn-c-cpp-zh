- en: Changing Levels, Streaming, and Retaining Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变层级、流式传输和保留数据
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Switching levels in UE4 comes in two varieties. One is very simple: unload
    the old level, load in the new one, done (if that''s all you need, this chapter
    may be a very short one!). The second method of streaming levels in and out continuously
    has many more challenges, but can be a much more rewarding user experience too.
    And in both cases, the question remains: what game elements or player data stay
    with you as these levels load? Having that data persist can be a real challenge
    with a couple of solutions we''ll explore here too so that whichever methods are
    chosen, in the end, your player can have a continuous experience that hopefully
    is not too much of a strain on those working on level design!  Our goals here
    are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中切换层级有两种类型。一种是非常简单的：卸载旧层级，加载新层级，完成（如果这就是你需要的，这一章可能非常简短！）。第二种方法是在连续流式传输层级进出的过程中具有更多挑战，但也可以提供更丰富的用户体验。在这两种情况下，问题仍然是：在加载这些层级时，哪些游戏元素或玩家数据会与你一起保留？拥有这些数据持久化可能是一个真正的挑战，我们在这里也会探索一些解决方案，以便无论选择哪种方法，最终玩家都能有一个连续的游戏体验，希望这对那些从事关卡设计的人来说不会太有压力！我们的目标如下：
- en: Cover the basics of map-switching in UE4
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖UE4中地图切换的基础知识
- en: Adding a new level to transition to
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为过渡到新层级添加一个新层级
- en: Adapting the load/save system to persist state across map-transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加载/保存系统调整为在地图转换之间持久化状态
- en: Create a practical example of level streaming from a persistent level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建从持久层级进行层级流式传输的实用示例
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As usual, it is recommended to pick up from the end of Chapter 5, *Adding Enemies!*,
    for continuity, but it is by no means required. All lessons here should be able
    to be applied to any UE4 project at any stage of development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '如往常一样，建议从第5章的结尾“添加敌人！”开始，以保持连贯性，但这绝对不是必需的。这里的所有课程都应能够应用于任何UE4项目在任何开发阶段的任何项目。 '
- en: 'The GitHub project corresponding to it is found here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的GitHub项目可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6)'
- en: 'Engine version used: 4.19.2.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.2。
- en: Traditional level loading
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统层级加载
- en: Changing levels (maps) has been an inherent system of the Unreal Engine since
    its inception. So, naturally, there are several tools and options that have evolved
    with it over the years. That said, we already have all the tools needed for basic
    level changing, but it's still instructive to walk through them, and we'll update
    our loading and saving in this section to keep our progress and game state during
    those switches. First, a quick review of the foundations of level changing in
    UE4.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 改变层级（地图）一直是虚幻引擎自诞生以来的固有系统。因此，自然地，随着时间的发展，已经出现了许多与之相关的工具和选项。话虽如此，我们已经有所有进行基本层级转换所需的工具，但了解这些工具仍然是有益的，我们将在本节中更新我们的加载和保存，以保持在这些切换期间的游戏进度和状态。首先，快速回顾一下UE4中层级转换的基础。
- en: The basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'Blueprint and C++ both have a built-in way to change levels. In a quick blueprint
    example we''ll use here, it''s the Open Level node accessible from most places
    you could ever want to use it in blueprint. In C++, we already used it during
    load/save (though note that for a server-based game, you would normally pass the
    desired level as the first parameter; here, we simply use it to restart the existing
    level with the `"?Restart"` special string):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图和C++都内置了改变层级的方式。在我们这里快速使用的蓝图示例中，它是可以从蓝图中的大多数地方访问的Open Level节点。在C++中，我们已经在加载/保存时使用过它（尽管请注意，对于基于服务器的游戏，你通常会传递所需的层级作为第一个参数；这里，我们只是使用它来使用`"?Restart"`特殊字符串重新启动现有层级）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, triggering one of these in the game is about as simple as it can get. In
    our default FirstPersonExampleMap, I've added a few blocks to resemble a portal
    that is at the top of the moving platform we added some time ago.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在游戏中触发这些操作大约是最简单不过的了。在我们的默认FirstPersonExampleMap中，我添加了一些方块，以模拟一个位于我们之前添加的移动平台顶部的传送门。
- en: If you check GitHub, there is a Stash for this chapter on fixing the moving
    platforms because they can squish pawns (player or NPCs) out of the level when
    moving back down. It's not a perfect fix, but it simply disables collision as
    the platform moves back down and re-enables it once it reaches the bottom (and
    some other minor logic was fixed in the platforms). As this is not a specific
    goal of this chapter, however, it was stashed instead of checked directly into
    the GitHub project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看GitHub，会发现有一个用于修复移动平台的Stash，因为它们可以在移动回下方的过程中将玩家（或NPC）挤压出关卡。这不是一个完美的解决方案，但它简单地禁用了平台移动回下方的碰撞，并在它到达底部时重新启用（还修复了一些平台上的其他小逻辑）。然而，由于这并不是本章的具体目标，所以它被存档而不是直接提交到GitHub项目。
- en: 'In the middle of this, I added a simple trigger volume from the Volumes set
    on the left (no new blueprint class or instance is even needed):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我添加了一个简单的触发器体积，来自左侧的体积集（甚至不需要新的蓝图类或实例）：
- en: '![](img/6a94ed8a-d097-4223-83b3-de14afd5fa43.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a94ed8a-d097-4223-83b3-de14afd5fa43.png)'
- en: 'With this selected, open the level blueprint by clicking Blueprints button
    at the top on the main menu bar, and selecting Open Level Blueprint. In there,
    while the volume is selected and you right-click, at the very top you have access
    to options specific to that specific object in the level. We''ll use its overlap
    event, check whether it''s the player, and if so, open MasteringTestLevel, as
    seen here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 选中它后，通过点击主菜单栏顶部的蓝图按钮，选择打开关卡蓝图。在里面，当体积被选中并且你右键点击时，在最顶部你可以访问该特定对象在关卡中的特定选项。我们将使用它的重叠事件，检查是否是玩家，如果是，就像这里所示打开MasteringTestLevel：
- en: '![](img/bdb38767-10e3-4c4a-8dcf-122a81de24e9.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bdb38767-10e3-4c4a-8dcf-122a81de24e9.png)'
- en: That's it. Really. Just walk into the trigger and we'll be launched in the other
    level. If this is all your project needs, then it's best to stop here and keep
    life simple!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。真的。只需走进触发器，我们就会被发射到另一个关卡。如果这就是你项目的需求，那么最好在这里停下来，保持生活简单！
- en: Using load/save to transition
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加载/保存进行过渡
- en: 'Most games, especially those with a story-based single player mode or the like,
    though, will want the player''s status after leaving, as well as the state of
    the level itself, to be persistent across this transition. If we make a simple
    portal back to `FirstPersonExampleMap` just like we did in the preceding section,
    you''ll notice when switching back and forth that our player, the items, NPCs,
    and so on in those levels are as if we had opened them anew, rather than the state
    they were in when we left, and the player''s inventory is loaded anew as well.
    So now really we need two distinct things:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数游戏，尤其是那些有基于故事的单人模式或类似模式的游戏，都希望玩家离开后的状态以及关卡本身的状态能够跨这个过渡过程持续存在。如果我们像上一节那样简单地创建一个返回到`FirstPersonExampleMap`的传送门，你会在切换回来和去的时候注意到，那些关卡中的玩家、物品、NPC等似乎是我们刚刚打开的，而不是我们离开时的状态，玩家的库存也被重新加载。所以现在我们实际上需要两个不同的东西：
- en: Keeping the player's data intact across any level load
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何关卡加载过程中保持玩家数据完整
- en: Loading and saving the state of that level and its dynamic objects when switching
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在切换时加载和保存该关卡及其动态对象的状态
- en: Fortunately, we have already implemented dynamic any-time loading and saving,
    so we'll just modify that and take advantage of it for the level state. But then
    we need something new for persisting data across map changes. There are several
    options to this (some definitely safer or more clean than others) but for our
    game, we'll make a new `UGameInstance` C++ class and use it like a singleton to
    hold data and information that will persist throughout the entire lifetime of
    the game being run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经在实现动态的任意时间加载和保存，所以我们将只修改这一点，并利用它来处理关卡状态。但是，我们需要一些新的方法来跨地图变化持久化数据。这里有几种选择（一些肯定比其他更安全或更干净），但针对我们的游戏，我们将创建一个新的`UGameInstance`
    C++类，并像单例一样使用它来保存将在游戏运行整个生命周期内持续的数据和信息。
- en: Any time static or global data is introduced, you must be extremely careful
    as it can have unforeseen effects on things such as play in editor, where even
    though you stop playing, so long as the editor is not closed and re-opened, any
    of that static data persists and so you cannot count on the same behavior starting
    and restarting PIE versus a standalone version of the game, say, on a device or
    other platform. We'll put in some safeguards here for our example, but use caution
    and minimize dangerous data storage whenever possible!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何引入静态或全局数据的时候，您都必须非常小心，因为它可能会对诸如在编辑器中的游戏等事物产生不可预见的影响，尽管您停止了游戏，只要编辑器没有关闭和重新打开，任何静态数据都会持续存在，因此您不能指望在启动和重新启动PIE与游戏的独立版本（例如，在设备或其他平台上）之间有相同的行为。我们将为我们的示例添加一些安全措施，但尽可能谨慎并最小化危险数据存储！
- en: 'We''ll name the new game instance `MasteringGameInstance` and give it some
    singleton-like functionality:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名新的游戏实例为`MasteringGameInstance`并给它一些单例功能：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see above, this gives us a few pieces of persistent data that we'd
    like to survive loading and saving cycles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这为我们提供了一些我们希望能够在加载和保存周期中持续存在的持久数据。
- en: 'Next, some helper functions to get all of this working, and to make setting
    the player''s inventory and cleaning up our own state in the game instance simple:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一些辅助函数来使所有这些工作正常，并使设置玩家的库存和清理游戏实例中的我们自己的状态变得简单：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, `BeginDestroy` and `FinishDestroy` probably won't need to both
    be here for us; but it's usually a good idea with static data holders such as
    this to have both. In `FinishDestroy`, if nothing else, you can put in safeguards
    to make sure no code after a session uses this same instance of the `GameInstance`
    without calling `Init` first, and clean up any remaining issues (you can even
    set `Instance` back to `nullptr` if you want to be extra safe). `BeginDestroy`
    for reference is the place to immediately clear out any data that any other classes
    might look to and make use of. We'll have a couple of those once we start this
    load/save task in earnest ( for example you definitely don't want to be in the
    middle of a load/save cycle, quit the game, and then upon restarting it have your
    variables set to what they were set to by that load/save starting). Be sure this
    point to go to Settings, Project Settings, and in Maps and Modes, set your game
    instance to `MasteringGameInstance`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`BeginDestroy`和`FinishDestroy`可能不需要都在这里；但通常对于像这样的静态数据持有者来说，同时拥有它们是个好主意。在`FinishDestroy`中，如果没有其他事情，您可以添加一些安全措施来确保在会话之后没有代码使用这个`GameInstance`的同一实例而不先调用`Init`，并清理任何剩余的问题（如果您想更加安全，甚至可以将`Instance`设置回`nullptr`）。作为参考，`BeginDestroy`是立即清除任何其他类可能会查找并使用的数据的地方。一旦我们开始认真进行加载/保存任务，我们将有几个这样的地方（例如，您绝对不希望在加载/保存周期中退出游戏，然后在重新启动时变量设置为加载/保存开始时的设置）。确保这一点指向设置，项目设置，然后在地图和模式中，将游戏实例设置为`MasteringGameInstance`。
- en: 'Next, to consolidate and abstract our game loading code a bit, we''ll make
    a new Blueprint Function Library C++ class (which almost by definition is a collection
    of static functions, which is just what we need here, even if it''s not necessarily
    ever called from blueprint):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了使我们的游戏加载代码更加精简和抽象，我们将创建一个新的蓝图函数库C++类（根据定义，这是一个静态函数的集合，这正是我们在这里需要的，即使它不一定从蓝图中调用）：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And refactor the `MainMenuWidget` class to move huge swathes of code here where
    it''s more appropriate going forward, making that UI class much more focused and
    specific. Also, we now have some extra fix-up code that adjusts our player''s
    position and accounts for persisting the current inventory through a load cycle,
    like we want when returning to a level we previously visited:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并且重构`MainMenuWidget`类，将大量代码移动到这里，使其在未来的使用中更加合适，使这个UI类更加专注和具体。此外，我们现在有一些额外的修复代码，它调整了玩家的位置，并考虑到在加载周期中持续当前库存，就像我们返回之前访问过的关卡时想要的那样：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Above you can see the method of loading, if we're going to the same world we're
    already on, we tell the world to restart essentially, otherwise, we open the new
    level.  We also save out the player's current position as "safe" as we can be
    confident it is a valid position for the player to occupy and we might need it
    if we're transitioning back to this level later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上方，您可以看到加载方法，如果我们打算进入我们已经在的世界，我们基本上告诉世界重新启动，否则，我们打开新关卡。我们还将玩家的当前位置保存为“安全”，因为我们有信心这是一个玩家可以占据的有效位置，如果我们稍后需要返回这个关卡，我们可能需要它。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Saving is where the real work is done, and following the flow can be a bit tricky;
    but if you collapse the implementation of the actor loop above, the rest is pretty
    straight-forward, get the safe-location, clear out the safe-location (for clarity),
    then iterate those actors, serialize to our output, and save that as a file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保存是真正的工作所在，遵循流程可能有点棘手；但如果您折叠上述演员循环的实现，其余部分就相当直接了，获取安全位置，清除安全位置（为了清晰），然后迭代这些演员，序列化到我们的输出，并将其保存为文件。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fixing up the player is a special case that takes a lot of delicate work so
    is included here in its full form.  It's quite tricky to get all of the properties
    of the player put back to where we wanted them at the time of saving, but take
    the time to go through (and step through in your IDE with breakpoints!) the above
    code a couple of times.  Getting this right, and starting the precedent of it
    *being* right from the start of a load/save system like this is critical.  Take
    the time to understand it and when implementing it, to get it right, and test,
    test, test!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 修复玩家是一个特殊情况，需要大量细致的工作，因此在此以完整形式包含。将玩家的所有属性放回到保存时想要的位置相当棘手，但请花时间通读（并在您的IDE中使用断点逐步执行）上述代码几次。正确地完成这项工作，并从这种加载/保存系统开始时就是正确的，这是至关重要的。花时间理解它，并在实现它时正确地实现它，测试，测试，再测试！
- en: The changes needed to the menu widget class should be self-evident, but this
    can be seen in a checkpoint in the GitHub project if necessary. This allows us
    to take advantage of the loading and saving code from essentially anywhere C++
    (or even blueprint).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修改菜单小部件类的更改应该是显而易见的，但如果需要，可以在GitHub项目的检查点中看到。这使我们能够利用从任何地方（基本上是C++或甚至蓝图）加载和保存的代码。
- en: 'So now, really our only missing piece is a new trigger box type that has a
    little bit of special C++ code, adjusting our load/save process to ignore loading
    the inventory saved at save time, and restoring inventory at level-switch time.
    So, two quick steps: make a new trigger box subclass, and add the player inventory
    and volume''s safe position to the game instance. So, naming our new volume `LevelTransitionVolume`
    and giving it some functionality with added variables and functions to the game
    instance, we can now transition with our player''s inventory and the rest loaded
    from the save game of where we are going, and if we''re just switching levels,
    we keep the player''s current inventory (and if necessary, any other information).
    If we''re doing a full load, of course we need to restore what was saved.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们真正缺少的只是一个具有少量特殊C++代码的新触发盒类型，调整我们的加载/保存过程以忽略在保存时保存的库存，并在层级切换时恢复库存。所以，两个快速步骤：创建一个新的触发盒子子类，并将玩家的库存和体积的安全位置添加到游戏实例中。因此，将我们的新体积命名为`LevelTransitionVolume`，并给它添加一些功能，通过向游戏实例添加变量和函数，我们现在可以过渡到带有玩家库存的，其余从我们要去的地方的保存游戏中加载，如果我们只是切换层级，我们保留玩家的当前库存（以及如果需要，任何其他信息）。如果我们正在进行完整加载，当然我们需要恢复保存的内容。
- en: 'The logic for this volume, in which we''ll replace the two volumes in the two
    levels used previously for testing, looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个体积的逻辑，我们将替换之前用于测试的两个层级中的两个体积，看起来是这样的：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So now we're transitioning to the new level, and have saved where we were at
    the time we left the current one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在正在过渡到新层级，并保存了我们离开当前层级时的位置。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll do the player here at this point, then finish off with finding any actors
    we found saved data for that haven''t already respawned (typically projectiles
    we made, for example):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这一点上处理玩家，然后完成找到的任何已保存数据的演员（通常是我们在其中创建的投射物等）：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After replacing the old trigger volumes and setting the right Transition Level
    names on the new boxes in the levels, of course we can remove the old logic in
    the level blueprints too. So, as seen previously, if we already have a save file
    matching the transition of to/from that we are about to do, load that save file.
    In any case, we will still preserve the player's inventory because of the lines
    setting this in the game instance near the top of this function, and save the
    state in our from/to form before leaving.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换了旧的触发体积并在层级中的新盒子上设置正确的过渡层级名称后，当然我们也可以在层级蓝图中去掉旧的逻辑。所以，如之前所见，如果我们已经有了与即将进行的过渡到/从的匹配的保存文件，就加载那个保存文件。无论如何，我们仍然会保留玩家的库存，因为游戏实例中靠近这个函数顶部的这些行设置了这一点，并在离开之前以我们的从/到形式保存状态。
- en: 'To allow our inventory to easily be transferred around, we can add a couple
    of utility functions. Note: it''s also possible to persist `UObject ` instances (other
    than the game instance) across level loading, but this often has unforeseen consequences
    with objects that reference other objects, which may be destroyed during a level
    load. So, in this case, we just make copying of inventory objects simple:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的库存容易转移，我们可以添加几个实用函数。注意：也可以在级别加载期间持久化`UObject`实例（除了游戏实例之外），但这通常会对在级别加载期间可能被销毁的引用其他对象的实例产生不可预见的影响。因此，在这种情况下，我们只是使库存对象的复制变得简单：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the last thing to do is to make an actual blueprint of the new trigger
    box and give it a proper safe-location where we can place the player. If we don''t
    do this, the player will be continually placed at the same spot they saved from
    (when they intersected the box), and you''ll get the player bouncing back and
    forth between the two levels infinitely. For those looking closely, you''ll see
    in the construction script that collision is initially disabled, and then the
    timer here re-enables it. This is because we need one tick of the game world to
    move the player to the updated position, and if we don''t briefly disable overlap
    events, we get the ping-pong behavior mentioned earlier when we do try to do the
    move:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后要做的就是制作一个新的触发盒的实际蓝图，并给它一个合适的安放位置，以便我们可以放置玩家。如果我们不这样做，玩家将不断被放置在保存的位置（当它们与盒子相交时），并且玩家将在两个级别之间无限弹跳。对于那些仔细观察的人，你会在构造脚本中看到碰撞最初是禁用的，然后这里的计时器重新启用它。这是因为我们需要游戏世界的一个tick来将玩家移动到更新后的位置，如果我们不暂时禁用重叠事件，当我们尝试移动时，就会得到前面提到的ping-pong行为：
- en: '![](img/7d6400fa-245f-43ea-80c4-4b4d51a87d55.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d6400fa-245f-43ea-80c4-4b4d51a87d55.png)'
- en: 'At this point, the player can transition back and forth between our two playable
    levels, have inventory persist at the current level, be placed at a safe position
    so they don''t immediately go back to the other level, and each level saves and
    restores the rest of its state like a normal load of a save. The only thing now
    missing as a general feature would be a spinning icon or fade-to-black and progress
    bar during the loading itself. UE4 certainly allows for these kinds of things,
    which update outside of the main game thread tick, but will not be specifically
    implemented here as we still have another major topic to delve into: streaming
    levels.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，玩家可以在我们的两个可玩级别之间来回切换，库存保持在当前级别，被放置在安全位置，这样他们就不会立即回到另一个级别，每个级别都像正常加载保存一样保存和恢复其状态。现在唯一缺少的一般功能可能是在加载过程中有一个旋转图标或淡入黑色和进度条。UE4当然允许这些类型的事情，它们在主游戏线程tick之外更新，但在这里不会具体实现，因为我们还有另一个主要主题要深入研究：流式传输级别。
- en: Perchance to stream?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有可能进行流式传输吗？
- en: 'So far we have now used triggering elements to load a specific level. Streaming,
    as it''s commonly known, is another method of loading levels on demand and allows
    for a much larger playing area without having to have all the encompassing actors
    loaded at any given time. Unreal allows this in two distinct ways, but they can
    complement each other: streaming volumes, and world composition. We''ll briefly
    explore these here, but they are great solutions for giving a huge playing area
    and keeping loaded memory at any given moment at a reasonable level. There are,
    of course, some drawbacks to this as well.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了触发元素来加载特定级别。流式传输，正如其通常所知，是另一种按需加载级别的的方法，它允许在不必须加载所有包围演员的情况下拥有更大的游戏区域。虚幻引擎以两种不同的方式允许这样做，但它们可以相互补充：流式体积和世界组成。我们在这里简要探讨这些内容，但它们是提供巨大游戏区域并保持任何给定时刻加载内存处于合理水平的好方法。当然，这种方法也有一些缺点。
- en: Streaming advantages and disadvantages
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式传输的优点和缺点
- en: 'The advantages of streaming are probably obvious. As already noted, there''s
    big spaces and manageable memory load. The disadvantages are probably a little
    less obvious, but are clearly illustrated with our first checkpoint here in the
    GitHub project: essentially duplicating (minus skybox and lighting) the `MasteringTestMap`
    into two other levels that are offset from it and streaming those in with streaming
    volumes. To do this, first go to the main editor Window menu and select Levels.
    Two new levels have been added with their offsets and each has a NavMesh volume
    around it to generate proper meshes. These meshes, when the levels are loaded,
    will combine.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输的优势可能很明显。正如之前提到的，有较大的空间和可管理的内存负载。其缺点可能不太明显，但通过我们在GitHub项目中的第一个检查点可以清楚地说明：基本上是将`MasteringTestMap`复制（除去天空盒和光照）到两个与之偏移的其他级别，并使用流式体积进行流式传输。为此，首先转到主编辑窗口菜单并选择级别。已经添加了两个新级别，并带有它们的偏移量，每个级别周围都有一个NavMesh体积来生成适当的网格。当级别加载时，这些网格将组合在一起。
- en: 'When a level is streamed out, however, all the actors in it will be destroyed,
    and when it is streamed back in, they will all be recreated as if loaded anew.
    So in this example, there are two new levels, MasteringTestMapW1 and W2\. MasteringTestMap
    will be our persistent level. This is the top-most level, which is *always* loaded.
    All streaming volumes also need to be placed in this level. So, as seen here,
    in a rough, demonstrative way, when starting MasteringTestMap and turning 90-degrees
    left and running, you see there is a short overlap of a few meters for the volume
    that streams in W1, and similarly there is a small overlap of W1''s map and the
    streaming volume for W2\. Normally you want these volumes to encompass any time
    the player can see that area, but in this case, we want to show streaming out:
    so if you run left, before hitting the edge of MasteringTestMap, W1 streams in.
    A similar thing will happen if you continue to W2\. If you go further into W2
    you''ll see that W1 then streams out when the player leaves W1''s volume, and
    similarly when heading back through W1 you can watch as W2 quickly streams out.
    Now come our problems. In W2 there is a volume to spawn more countess enemies.
    If you go slowly and carefully, they can chase you back into W1, but if you run
    quickly, W2 streams out and the countesses fall out of the world. Also, when streaming
    W1 back in, any weapon pickups that were previously collected now return.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当级别被流式传输出去时，其中的所有演员都将被销毁，当它被流式传输回来时，它们将全部重新创建，就像新加载一样。所以在这个例子中，有两个新级别，MasteringTestMapW1和W2。MasteringTestMap将是我们的持久级别。这是最顶层的级别，它总是被加载。所有流式传输体积也都需要放置在这个级别中。所以，正如这里所看到的，以粗略的演示方式，当开始MasteringTestMap并左转90度跑动时，你会看到流进W1的体积有短短几米的重叠，同样，W1的地图和流进W2的体积也有小范围的重叠。通常你希望这些体积包括玩家可以看到的任何区域，但在这个情况下，我们想展示流式传输出去：所以如果你跑向左边，在碰到MasteringTestMap的边缘之前，W1就会流进。如果你继续向W2前进，你会看到当玩家离开W1的体积时，W1就会流出去。同样，当你通过W1返回时，你可以看到W2迅速流出去。现在我们遇到了问题。在W2中有一个体积用于生成更多的敌人。如果你慢慢走，小心行事，他们可以把你赶回W1，但如果你跑得快，W2就会流出去，女伯爵们就会从世界中掉落。此外，当流式传输W1回来时，之前收集到的任何武器拾取现在都会返回。
- en: 'Dynamic objects and streaming like this are the biggest issue to reconcile:
    how do you inform the newly loaded level that it should not respawn weapon pickups
    placed on the ground? How do the countesses handle their home level streaming
    out?  This utterly breaks their return-home behavior as they literally can''t
    do so (their pathfinding fails). Of course, it''s possible to save the state of
    objects spawned or destroyed in various levels when their streamed level streams
    out, either in the persistent level in a small way (such as simply storing the
    actor''s position and state) or possibly in the game instance as we with the player''s
    inventory across the level loads in the previous section. However, this is a lot
    of upkeep, so as with many features like this, if you intend to use streaming be
    sure to decide early and educate any other team-members on how to properly set
    these things up so your player feels like it is a seamless world. But first, let''s
    see a quick difference between these two streaming methods and observe the difficulties
    mentioned.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 动态对象和此类流式传输是最大的协调问题：你如何通知新加载的关卡它不应该重新生成放置在地面上的武器拾取？女伯爵们如何处理她们的主关卡流式传输出去？这完全破坏了她们的回家行为，因为她们实际上无法这样做（它们的路径查找失败）。当然，当流式传输的关卡流式传输出去时，可以在持久关卡中以小的方式保存（例如，简单地存储角色的位置和状态）或在游戏实例中，就像我们在上一节中加载关卡时跨关卡加载玩家的库存一样。然而，这需要大量的维护，因此，像这样的许多功能一样，如果你打算使用流式传输，请务必尽早决定，并教育任何其他团队成员如何正确设置这些事情，以便你的玩家感觉这是一个无缝的世界。但是首先，让我们快速看一下这两种流式传输方法的区别，并观察提到的困难。
- en: Example streaming and best practices
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例流式传输和最佳实践
- en: To stream these levels, in the Levels window, you first have to click the Levels
    drop-down at the top and click on Add Existing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要流式传输这些关卡，在“关卡”窗口中，你首先必须点击顶部的“关卡”下拉菜单，然后点击“添加现有”。
- en: 'Adding W1 and W2 allows us to select them and then hook their loading state
    to the volumes shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加W1和W2使我们能够选择它们，然后将它们的加载状态连接到此处显示的体积：
- en: '![](img/866065cb-a875-4596-8330-4096b918f137.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/866065cb-a875-4596-8330-4096b918f137.png)'
- en: 'With those added, and the volumes added like so to MasteringTestMap, it should
    look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这些，并将体积添加到MasteringTestMap中，它应该看起来像这样：
- en: '![](img/ce29f67a-44ee-4676-8ac1-695607c63615.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce29f67a-44ee-4676-8ac1-695607c63615.png)'
- en: Back in the levels window, clicking the plus button on the volumes array allows
    us to then use the eye-dropper to drag into the world and select the right volume,
    or simply use the drop-down and pick the volume we want to associate with this
    level. Again, note the small overlaps. To avoid players noticing the streaming,
    it's usually best to make a much larger overlap area and also potentially bring
    in a fog-distance so the actual loading is not so obvious. For our instructive
    case, again, we want it to be obvious here. Now, with these pieces in place you
    can run West and see the levels come in and drop out as the player (actually the
    camera, to be exact) enters these areas and leaves them.  And again, with a couple
    of test runs, it should be obvious how the drawbacks mentioned are clearly visible
    if not accounted for as levels stream in and out. Should a countess never leave
    her home level? Should she disappear when her home level streams out? Should pickups
    somehow know they've previously been picked up and either not spawn or destroy
    themselves, like we do with pick-ups picked up when loading a save game? These
    are all questions each project must decide, weighing the complexity of maintaining
    such a system versus the player experience and not breaking their immersion.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在“关卡”窗口中，点击体积数组上的加号按钮，然后我们可以使用吸管工具将它们拖入世界并选择正确的体积，或者简单地使用下拉菜单选择我们想要与该关卡关联的体积。再次注意这些小的重叠。为了避免玩家注意到流式传输，通常最好制作一个更大的重叠区域，并可能引入雾距离，这样实际的加载就不会那么明显。在我们的教学案例中，我们再次希望它在这里是明显的。现在，有了这些组件，你可以运行West，看到关卡随着玩家（确切地说，是摄像机）进入这些区域并离开而进入和消失。再次，通过几次测试运行，应该很明显，如果没有考虑到这些提到的缺点，当关卡流式传输进和出时，它们会明显可见。女伯爵是否永远不应该离开她的主关卡？当她的主关卡流式传输出去时，她应该消失吗？拾取物是否应该以某种方式知道它们之前已经被拾取，并且要么不生成，要么像我们在加载存档游戏时拾取的拾取物那样销毁自己？这些都是每个项目必须决定的问题，权衡维护此类系统的复杂性以及玩家体验和避免破坏他们的沉浸感。
- en: 'Using volumes can be a great way to manually control exact levels of detail.
    For example, you can stream in basic physics and a bit of static mesh geometry
    with a very large volume to avoid any worries of the falling out of world problems
    such as the countess has, while then having an additional level with a smaller
    volume that only loads in when the player is closer, which loads a large number
    of cosmetic geometry that doesn''t impact gameplay. A limitation of volume-based
    streaming, though, is that levels can only extend from the origin of the persistent
    level out to `WORLD_MAX`, which is about 2 km (or from the start, 1 km East/West,
    1 km North/South). In most games, this is plenty. For an open world (and don''t
    forget you can still hard-transition to other persistent levels, such as indoor
    areas!) within this size limitation, we found a brick-like tiling was best for
    overlapping levels to be loaded. So, when you''re in the level in the center,
    the levels around it in this pattern would be loaded:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用体积可以是一种手动控制精确细节水平的好方法。例如，你可以使用一个非常大的体积来流式传输基本的物理和少量的静态网格几何形状，以避免任何世界掉落问题，比如伯爵遇到的问题，同时还有一个额外的级别，体积更小，只有当玩家靠近时才加载，这会加载大量不影响游戏玩法的外观几何形状。然而，基于体积的流式传输的一个限制是，级别只能从持久级别的起点扩展到`WORLD_MAX`，大约是2公里（或者从起点开始，东西方向1公里，南北方向1公里）。在大多数游戏中，这已经足够了。对于在这个尺寸限制内的开放世界（别忘了你仍然可以硬切换到其他持久级别，比如室内区域！），我们发现砖块状拼接最适合重叠级别加载。因此，当你处于中心级别时，按照这种模式围绕它的级别将会被加载：
- en: '![](img/227e7fa7-bedb-4bd9-be9c-cb9d62905b45.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/227e7fa7-bedb-4bd9-be9c-cb9d62905b45.png)'
- en: This way you can also work with level designers so that the sum memory of those
    seven levels is always less than a certain cap. So, for example, you could have
    some low-detail areas with a very high-detail area in the center, but of course
    as you move around and this pattern repeats, the sum of any seven loaded levels
    should be maintained under that agreed-upon cap. And the nice part is that server-based
    multiplayer games already respect this kind of streaming and have no problems
    tracking players across these boundaries from their clients. If your world needs
    a much larger or nearly boundless play space, world composition is worth exploring.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你还可以与级别设计师合作，确保这七个级别的总内存始终低于某个特定的上限。例如，你可以有一些低细节区域和中心的高细节区域，但当然，随着你的移动和这个模式的重复，任何七个加载级别的总和应该保持在商定的上限以下。而且，令人高兴的是，基于服务器的多人游戏已经尊重这种流式传输，并且没有问题跟踪客户端之间的玩家。如果你的世界需要一个更大或几乎无界的游戏空间，世界组成值得探索。
- en: World composition is a great way to create automated, grid-based tiling built
    into UE4\. This is particularly useful for very large worlds where the player
    can then travel almost endlessly in any given direction, but requires a large
    effort by artists or level designers typically to make these sections and make
    them match exactly at their borders. A perfect application for world composition
    is a single-player open-world game where exploration and a truly vast play area
    are the goal. As this is a bit niche, and Epic themselves have done a very nice
    job of documenting the feature, a link will be added to the *Further reading* section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 世界组成是创建自动化的、基于网格的拼接的好方法，它内置在UE4中。这对于非常大的世界非常有用，玩家可以在任何给定方向上几乎无限地旅行，但通常需要艺术家或级别设计师的大量工作来制作这些部分，并确保它们在边界处完全匹配。世界组成的完美应用是一个单人开放世界游戏，其中探索和真正广阔的游戏区域是目标。由于这是一个相当小众的领域，Epic
    本身已经对功能做了很好的文档记录，将在*进一步阅读*部分添加链接。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'From the start of this chapter to its completion, we have now demonstrated
    how to persist level state and player state independently across traditional level
    loads, as well as the basics of streaming levels as the player moves around. These
    are fundamental to almost all conceivable games in UE4 and should now form the
    basis of whatever strategy works best for a team and project going forward. Always
    remember: make these decisions early! It can be nearly impossible, for example,
    to retrofit levels built assuming a hard level-load into a streaming model, but
    if you adopt that streaming model and help your team stick to its limits from
    day one, this is one worry that won''t haunt you late in a project cycle.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章的开始到结束，我们现在已经展示了如何在传统的关卡加载中独立持久化关卡状态和玩家状态，以及玩家移动时流式传输关卡的基础知识。这些对于几乎所有的UE4可想象的游戏都是基本的，现在应该成为任何团队和项目向前发展的最佳策略的基础。始终记住：尽早做出这些决定！例如，将假设硬关卡加载的关卡改造为流式模型几乎是不可能的，但如果你从第一天就采用流式模型并帮助你的团队坚持其限制，那么这将是你在项目周期后期不会感到困扰的一个担忧。
- en: Questions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What existing classes or objects can be used in UE4 to implement level loading
    with no new changes?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4中可以使用哪些现有的类或对象来实现无需新更改的关卡加载？
- en: What are some limitations of using only these methods?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用这些方法有哪些局限性？
- en: What is the scope of the lifetime of the game instance object?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏实例对象的生命周期范围是什么？
- en: How is the game instance used to persist data when opening a new level or loading
    an existing one's state?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当打开新关卡或加载现有关卡的状态时，游戏实例是如何用来持久化数据的？
- en: What is the purpose of abstracting level load/save code to a blueprint function
    library?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将关卡加载/保存代码抽象到蓝图函数库的目的是什么？
- en: Why is the player's inventory copied rather than scoping a `UObject` to the
    game instance?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么玩家的库存被复制而不是将`UObject`范围限定在游戏实例中？
- en: What are the major drawbacks of volume-based streaming?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于体积的流式传输的主要缺点是什么？
- en: Which types of games should definitely use world composition?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的游戏肯定应该使用世界组成？
- en: Further reading
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'World composition in UE4:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: UE4中的世界组成：
- en: '[https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser](https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser](https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser)'
