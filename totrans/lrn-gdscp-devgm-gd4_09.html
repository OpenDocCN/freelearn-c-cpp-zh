<html><head></head><body>
		<div id="_idContainer184">
			<h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor590"/>9</h1>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor591"/>Cameras, Collisions, and Collectibles</h1>
			<p>While playing a game, the player doesn’t want to have to think about the camera and its placement. The camera should always follow the player’s character and anticipate what the player wants to achieve so it doesn’t obstruct the <span class="No-Break">player’s vision.</span></p>
			<p>In bigger games, full teams are tasked with producing the smoothest camera possible. In this chapter, we will attempt to do the same with some Godot <span class="No-Break">Engine nodes.</span></p>
			<p>After that, we’ll stop the player from walking through walls and have a look at sprinkling collectibles, such as health and money, around <span class="No-Break">our arena.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Making a camera that follows <span class="No-Break">the player</span></li>
				<li>Collisions with boulders <span class="No-Break">and walls</span></li>
				<li><span class="No-Break">Collision masks</span></li>
				<li>Creating <span class="No-Break">inherited scenes</span></li>
				<li>Connecting <span class="No-Break">to signals</span></li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor592"/>Technical requirements</h1>
			<p>As for every chapter, you can find the final code on the GitHub repository in the subfolder for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter9"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter9</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor593"/>Making a camera that follows the player</h1>
			<p>At the moment, our<a id="_idIndexMarker490"/> character can run around, but at some point, it will run off the screen and get lost forever. Our in-game camera should follow them around so the player knows where <span class="No-Break">they are.</span></p>
			<p>Luckily, the Godot Engine has a pretty nice camera system that we can use. It can be a bit basic, but it is all we need, and with some extra nodes, we’ll be able to achieve a very <span class="No-Break">smooth-moving camera.</span><a id="_idTextAnchor594"/></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor595"/>Setting up a basic camera</h2>
			<p>For 2D games, Godot<a id="_idIndexMarker491"/> provides the <span class="No-Break"><strong class="bold">Camera2D</strong></span><span class="No-Break"> node.</span></p>
			<p>Open up the <strong class="source-inline">player.tscn</strong> scene and add a <strong class="bold">Camera2D</strong> node to the <strong class="source-inline">Player</strong> node. This is all we need to make a basic camera that follows <span class="No-Break">the player:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer149">
					<img alt="Figure 9.1 – The player scene with an added Camera2D node" src="image/B19358_09_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The player scene with an added Camera2D node</p>
			<p>But this basic camera feels a bit stiff; it starts and stops moving at exactly the moment the character does. This doesn’t feel very natural. Let’s see how to <span class="No-Break">solve this.</span><a id="_idTextAnchor596"/></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor597"/>Adding drag margins</h2>
			<p>To make the<a id="_idIndexMarker492"/> camera movement appear natural, we will use <strong class="bold">drag margins</strong>. Find and enable <strong class="bold">Horizontal</strong> and <strong class="bold">Vertical</strong> drag in the <span class="No-Break">camera’s inspector:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer150">
					<img alt="Figure 9.2 – The drag margin settings for the Camera2D node in the inspector." src="image/B19358_09_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The drag margin settings for the Camera2D node in the inspector.</p>
			<p>Now, the camera only moves when the player exits a certain area in the middle of the screen. This is the <a id="_idIndexMarker493"/>margin within which nothing happens. If you enable <strong class="bold">Draw Drag Margin</strong> in the camera’s inspector, you can see the drag <span class="No-Break">margins visualized:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer151">
					<img alt="Figure 9.3 – Showing the drag margins in the editor by enabling them in the Camera2D inspector" src="image/B19358_09_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Showing the drag margins in the editor by enabling them in the Camera2D inspector</p>
			<p>With <strong class="bold">Draw Drag Margin</strong> enabled, you should be able to see the blue rectangles indicating when the camera will <span class="No-Break">start moving:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer152">
					<img alt="Figure 9.4 – The editor now shows the drag margins in light blue" src="image/B19358_09_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The editor now shows the drag margins in light blue</p>
			<p>You can play a bit with the left, top, right, and bottom margins in the inspector. I chose to set them all to <strong class="source-inline">0.1</strong>, as seen in <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">9</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break"> earlier.</span></p>
			<p>Great, the drag<a id="_idIndexMarker494"/> margins already feel great. But the camera still starts and stops moving very abruptly and seems to lag behind the player. Let’s fix <span class="No-Break">that nex<a id="_idTextAnchor598"/><a id="_idTextAnchor599"/>t.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor600"/>Making the camera look ahead</h2>
			<p>The movement <a id="_idIndexMarker495"/>of the camera feels pretty great now. But there is something wrong; we need something more fundamental than nice, smooth movement. When the player moves, the camera drags behind, showing where the player has been and not where the player <span class="No-Break">is going.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer153">
					<img alt="Figure 9.5 – The camera lags behind the player and does not show where the player is going" src="image/B19358_09_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The camera lags behind the player and does not show where the player is going</p>
			<p>This is not great; imagine running somewhere and only being able to look backward. What we actually<a id="_idIndexMarker496"/> want is for the camera to look ahead in the direction the player is moving. We can do this by, instead of tracking the player itself, tracking a point in front of the player. Basically, it is as if the player character is holding a selfie stick. So, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Add a new <strong class="bold">Node2D</strong> to <strong class="source-inline">Player</strong>  and call it <strong class="source-inline">CameraPosition</strong>. This will become the point we are going to track instead of the <span class="No-Break">player itself.</span></li>
				<li>Now drag the camera we already made onto this <strong class="source-inline">CameraPosition</strong> so that it is a child of the <span class="No-Break">new node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer154">
					<img alt="Figure 9.6 – Put the Camera2D node under a separate node called CameraPosition" src="image/B19358_09_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Put the Camera2D node under a separate node called CameraPosition</p>
			<ol>
				<li value="3">Make sure that the position of the <strong class="bold">Camera2D</strong> and <strong class="source-inline">CameraPosition</strong> is set to <strong class="source-inline">(0, 0)</strong> in <span class="No-Break">the inspector:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer155">
					<img alt="Figure 9.7 – Make sure the Camera2D and CameraPosition nodes are at position (0, 0)" src="image/B19358_09_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Make sure the Camera2D and CameraPosition nodes are at position (0, 0)</p>
			<ol>
				<li value="4">Add a script to the <strong class="source-inline">CameraPosition</strong> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">camera_position.gd</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>This script will keep the position in front of the camera. We can do this based on the <strong class="source-inline">velocity</strong> that the player <span class="No-Break">character has.</span></p>
			<p>The complete<a id="_idIndexMarker497"/> script looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
extends Node2D
@export var camera_distance: float = 200
@onready var _player: CharacterBody2D = get_parent()
func _process(_delta):
   var move_direction: Vector2 = _player.velocity.normalized()
   position = move_direction * camera_distance</pre>			<p>First, we define an export variable that we can play with called <strong class="source-inline">camera_distance</strong>.<a id="_idTextAnchor601"/><a id="_idTextAnchor602"/><a id="_idTextAnchor603"/> This will be the distance in front of the player at which we will keep the camera while the player <span class="No-Break">is moving.</span></p>
			<p>With <strong class="source-inline">_physics_process()</strong>, which gets executed for each physics frame of the game, we calculate the position of the camera point. Remember that this position is relative to the <strong class="source-inline">Player</strong> node, so a position of <strong class="source-inline">(0, 0)</strong> is right where the player is.The idea is to take the direction in which the player is moving and multiply that by the <strong class="source-inline">camera_distance</strong>. The direction the player is moving in can be derived from the <strong class="source-inline">velocity</strong> of the player. So first, we get the player node using the <strong class="source-inline">get_parent</strong> function and cache it in the <strong class="source-inline">_player</strong> variable. This function returns the parent of a node, in this case, the <strong class="source-inline">Player</strong> node because the <strong class="source-inline">CameraPosition</strong> is a direct child of <span class="No-Break">that node.</span></p>
			<p>Then, to get the direction the player is moving in, we normalize this <strong class="source-inline">velocity</strong> vector. Normalizing a vector, as we saw in <a href="B19358_07.xhtml#_idTextAnchor523"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, means that you take the whole vector and make it of length <strong class="source-inline">1</strong>. So, the whole vector is <strong class="source-inline">1</strong> pixel long. This will leave us with the direction of the <strong class="source-inline">velocity</strong> without its length. Now we can easily scale this direction to whatever length we want by multiplying it with the <strong class="source-inline">camera_distance</strong> to define the <strong class="source-inline">position</strong> of the <strong class="source-inline">CameraPosition</strong>. If you run the game now, you’ll see that <strong class="source-inline">CameraPosition</strong> does what you want it to and makes the camera look ahead in the direction the <a id="_idIndexMarker498"/>character is moving. But it is still a bit janky, so let’s smooth that out one <span class="No-Break">last time<a id="_idTextAnchor604"/>.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor605"/>Smoothing out the look ahead</h2>
			<p>The problem<a id="_idIndexMarker499"/> now is that the camera starts moving very suddenly and abruptly stops. This happens because the <strong class="source-inline">CameraPosition</strong> we created jumps around quite quickly. To fix this problem, we should make the movement of the <strong class="source-inline">CameraPosition</strong> <span class="No-Break">itself smooth.</span></p>
			<p>First, add a new exported variable, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
@export var position_interpolation_speed: float = 1.0</pre>			<p>Now, let’s change the <strong class="source-inline">_process()</strong> function of the <strong class="source-inline">camera_position.gd</strong> script <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func _physics_process(<strong class="bold">delta</strong>):
   var move_direction: Vector2 = _player.velocity.normalized()
   <strong class="bold">var target_position: Vector2 = move_direction * camera_distance</strong>
   position = <strong class="bold"> position.lerp(target_position, position_interpolation_speed * delta)</strong></pre>			<p>We do largely the same things as in the preceding section, but this time, we save the position we want the <strong class="source-inline">CameraPosition</strong> to have as a <strong class="source-inline">target_position</strong>. Then, in the next line, we calculate the <span class="No-Break">actual </span><span class="No-Break"><strong class="source-inline">position</strong></span><span class="No-Break">.</span></p>
			<p>To calculate the position, we use a new function, <strong class="source-inline">lerp()</strong>. This is short for <strong class="bold">linear interpolation</strong>. This<a id="_idIndexMarker500"/> function works very much the same as <strong class="source-inline">move_towards()</strong>, which we used in <a href="B19358_07.xhtml#_idTextAnchor523"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. However, while <strong class="source-inline">move_towards()</strong> moves the position a certain number of pixels toward the target position, <strong class="source-inline">lerp</strong> moves the position toward the <strong class="source-inline">target_position</strong> according to a percentage between the two, which is the last argument in the function. This percentage is expressed in a value from <strong class="source-inline">0.0</strong> to <strong class="source-inline">1.0</strong>, where <strong class="source-inline">0.0</strong> is <strong class="source-inline">0%</strong> and <strong class="source-inline">1.0</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">100%</strong></span><span class="No-Break">.</span></p>
			<p>So, let’s say we want to move <strong class="source-inline">50%</strong> between the position and its target, then the resulting position will be right in the middle between the <span class="No-Break">two points.</span></p>
			<p>This process is called <strong class="bold">linear interpolation</strong> because we interpolate between two values linearly. The way we use linear interpolation in our camera position script is to move toward the target position a little bit <span class="No-Break">every frame.</span></p>
			<p>The percentage of the linear interpolation that I chose was <strong class="source-inline">5.0 * delta</strong>. I put this value in an exported variable so we can easily tweak it from the editor. Because delta is the time between<a id="_idIndexMarker501"/> two frames, the result of this product is very small and should result in an interpolation of around <strong class="source-inline">10%</strong> per frame. We multiply by <strong class="source-inline">delta</strong> because, just like for the movement speed of the player, we want the speed of the camera not to change on faster or slower computers that run at a higher or lower framerate. We talked about frame rate independent calculations in <a href="B19358_07.xhtml#_idTextAnchor523"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> too when making the <span class="No-Break">character move.</span></p>
			<p>You can play around with the speed of the interpolation by changing the <strong class="source-inline">position_interpolation_speed</strong> to anything else through <span class="No-Break">the inspector.</span></p>
			<p>In this section, we learned a great deal about creating a smooth and useful camera that frames where the player is moving toward. As mentioned in the introduction of this chapter, big-budget games have whole teams that work on nothing else but the camera. But using some<a id="_idIndexMarker502"/> smart tricks, we achieved a fairly nice camera for our little game. Now, we’ll shift gears and make sure the player stops running through walls by adding <span class="No-Break">collision detection.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor606"/>Collisions</h1>
			<p>With our brand-new <a id="_idIndexMarker503"/>camera in place, let’s take a look at collisions. For now, we have the visuals of a nice arena, including walls and rocks, but they don’t really act like them. The player character is able to just run through them as if they were made out of air instead of <span class="No-Break">solid matter.</span></p>
			<p>Just like with the movement of the player, we can solve this using the built-in physics engine. Let’s start by taking a look at the different physics bodies at <span class="No-Break">our dis<a id="_idTextAnchor607"/>posal.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor608"/>The different physics bodies</h2>
			<p>For the player<a id="_idIndexMarker504"/> character, we used the <strong class="bold">CharacterBody2D</strong> physics body. But this is not the only kind that comes with the physics engine Godot. There are a few <span class="No-Break">other ones:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer156">
					<img alt="Figure 9.8 – The three different physics bodies as displayed in the scene tree" src="image/B19358_09_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The three different physics bodies as displayed in the scene tree</p>
			<p>For 2D games, there are three different kinds of physics bodies available. Each has its own uses within a game or physics simulation. Let’s take a look <span class="No-Break">at<a id="_idTextAnchor609"/> each.</span></p>
			<h3>RigidBody2D</h3>
			<p>A rigid body is a<a id="_idIndexMarker505"/> physics object that is fully simulated. Rigid<a id="_idIndexMarker506"/> bodies are completely dependent on outside physical forces and collisions. You are not supposed to control <span class="No-Break">them directly.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">These bodies are called rigid because the body itself does not deform. So, it gets used for simulating solid objects from cars to bones to walls. The <strong class="bold">StaticBody2D</strong> and <strong class="bold">CharacterBody2D</strong> can also not deform and are therefore also rigid bodies, but more in the mathematical sense of the word and not in how they are implemented within <span class="No-Break">the engine.</span></p>
			<p>We cannot directly control a rigid body; they are fully managed by the physics engine, which resolves how it moves and how the velocities and forces get applied. The only way to control a rigid body is by applying external forces to it. This is like hitting a golf ball with a stick. With enough practice and fine-tuning, you can get the ball in the general direction of the hole, but picking it up and dropping it in there, though easier, is not <span class="No-Break">an option.</span></p>
			<p>Simulating non-rigid, bodies, also known as soft bodies, is generally harder to do mathematically and performantly within a game. Soft bodies could be sponges, rubber objects that deform, jelly, and so on. There are ways to simulate these within a rigid body<a id="_idIndexMarker507"/> simulation, but it’s<a id="_idIndexMarker508"/> not advised to do this. In 3D, there is a <strong class="bold">Softbody3D</strong> node, but it is n<a id="_idTextAnchor610"/>ot <span class="No-Break">for 2D.</span></p>
			<h3>StaticBody2D</h3>
			<p>A static body is a <a id="_idIndexMarker509"/>physics body that stays static, meaning it<a id="_idIndexMarker510"/> does not move around and also cannot be pushed by external forces. This is the simplest of physics bodies to deal with and will be ideal for making our walls and r<a id="_idTextAnchor611"/>ocks <span class="No-Break">out of.</span></p>
			<h3>CharacterBody2D</h3>
			<p>A character <a id="_idIndexMarker511"/>body is a physics body that we are able <a id="_idIndexMarker512"/>to control through code. A <strong class="bold">RigidBody2D</strong>, as we saw earlier, is fully managed by the physics engine. This makes it hard to control to get it to do what you want <span class="No-Break">it to.</span></p>
			<p>A character body, on the other hand, gives us a good middle ground. Like in the <strong class="source-inline">player.gd</strong> script, we have to calculate the <strong class="source-inline">velocity</strong> ourselves and call <strong class="source-inline">move_and_slide()</strong>. But the physics engine still helps us out with collisions and calculating where the body is supposed to move based on <span class="No-Break">the velocity.</span></p>
			<p class="callout-heading">More information</p>
			<p class="callout">The Godot documentation also has a great write-up of the different physics bodies and how they can be <span class="No-Break">used: </span><a href="https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#collision-objects"><span class="No-Break">https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#collision-objects</span></a><span class="No-Break">.</span></p>
			<p>These were the three types of physics bodies available in Godot. But there is actually a fourth physics <a id="_idIndexMarker513"/>object, which is not a body. Let’s take a <a id="_idIndexMarker514"/>look at the <span class="No-Break"><strong class="bold">Area2D</strong></span><span class="No-Break"> node.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor612"/>The Area2D node</h2>
			<p>The three <a id="_idIndexMarker515"/>physics bodies we just saw all collide with each other and react <a id="_idIndexMarker516"/>to this collision or make other bodies react to it. In essence, their movements get processed by the <span class="No-Break">physics engine.</span></p>
			<p>The last physics object, <strong class="bold">Area2D</strong>, only detects and influences other physics objects. It is not subjected to physics calculation, like for movement. But it can detect if another physics object is overlapping it and throws a signal when these other physics objects enter <span class="No-Break">or leave.</span></p>
			<p>We will use this functionality near the end of this chapter to make the player pick up health potions when they come <span class="No-Break">near them.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer157">
					<img alt="Figure 9.9 – The four different physics objects as they are displayed in the scene tree" src="image/B19358_09_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The four different physics objects as they are displayed in the scene tree</p>
			<p>Now that you know about the three types of physics bodies currently available, we can start utilizing them to create <span class="No-Break">proper collisions.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor613"/>Adding a collision shape to the player node</h2>
			<p>Since we<a id="_idIndexMarker517"/> created the player node all the way back in <a href="B19358_06.xhtml#_idTextAnchor411"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, there<a id="_idIndexMarker518"/> has been this little orange triangle next to it. When we hover over it, the tool tip explains to us that this node is missing a shape. This makes sense, how can the physics engine detect collisions if it doesn’t know what shape a physics <span class="No-Break">body is?</span></p>
			<p>Let’s solve this <span class="No-Break">little warning:</span></p>
			<ol>
				<li>Find and add the <strong class="bold">CollisionShape2D</strong> node as a child of the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer158">
					<img alt="Figure 9.10 – Add a CollisionShape2D to the player scene" src="image/B19358_09_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Add a CollisionShape2D to the player scene</p>
			<ol>
				<li value="2">Select this newly created <strong class="bold">CollisionShape2D</strong> node and click on the empty <strong class="bold">Shape</strong> field to reveal a drop-down menu with <span class="No-Break">different shapes.</span></li>
				<li>Select the <span class="No-Break"><strong class="bold">CapsuleShape2D</strong></span><span class="No-Break"> option.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer159">
					<img alt="Figure 9.11 – Select a CapsuleShape2D as the CollisionShape2D’s shape" src="image/B19358_09_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Select a CapsuleShape2D as the CollisionShape2D’s shape</p>
			<ol>
				<li value="4">A capsule-like blue shape will appear on the screen. This is the shape of the physics body. Use the orange circles on the periphery of the shape to change its size and try to cover most of the <span class="No-Break">player sprite:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer160">
					<img alt="Figure 9.12 – Make sure the CapsuleShape2D covers the player sprite" src="image/B19358_09_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Make sure the CapsuleShape2D covers the player sprite</p>
			<p>The <strong class="bold">CollisionShape2D</strong> node in itself does not have a shape, but it will hold one for us. That is why<a id="_idIndexMarker519"/> we <a id="_idIndexMarker520"/>had to add one to the <span class="No-Break"><strong class="bold">Shape</strong></span><span class="No-Break"> property.</span></p>
			<p>Other shapes that are interesting as collision shapes are <strong class="bold">RectangleShape2D</strong> and <strong class="bold">CircleShape2D</strong>. The others are used in specialized situations, such as for very thin or disjointed objects, so don’t worry too much about them <span class="No-Break">just yet.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer161">
					<img alt="Figure 9.13 – The CircleShape2D and RectangleShape2D" src="image/B19358_09_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – The CircleShape2D and RectangleShape2D</p>
			<p>Running the game now will not result in the player colliding with the boulders or walls, simply because first, we’ll <a id="_idIndexMarker521"/>also need to add physics bodies<a id="_idIndexMarker522"/> and shapes to the s<a id="_idTextAnchor614"/>cenes of <span class="No-Break">these two.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor615"/>Creating static bodies for the boulders</h2>
			<p>In the <em class="italic">The different physics bodies</em> section, we<a id="_idIndexMarker523"/> learned <a id="_idIndexMarker524"/>that <strong class="bold">StaticBody2D</strong> nodes don’t move; that sounds ideal for a boulder. So, let’s make <span class="No-Break">them solid:</span></p>
			<ol>
				<li>Go into our <span class="No-Break"><strong class="source-inline">boulder.tscn</strong></span><span class="No-Break"> scene.</span></li>
				<li>Add a <strong class="bold">StaticBody2D</strong> node under the <span class="No-Break">root node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer162">
					<img alt="Figure 9.14 – Adding a StaticBody2D with a CollisionPolygon2D as a child of the boulder scene" src="image/B19358_09_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Adding a StaticBody2D with a CollisionPolygon2D as a child of the boulder scene</p>
			<ol>
				<li value="3">Add a <strong class="source-inline">CollisionPolygon2D</strong> node under this newly created <span class="No-Break">static body.</span></li>
				<li>Now add points to the collision polygon by clicking within the 2D editor. Try to cover the <span class="No-Break">boulder completely:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer163">
					<img alt="Figure 9.15 – Cover the boulder with the PolygonShape2D" src="image/B19358_09_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Cover the boulder with the PolygonShape2D</p>
			<p>Note that we use a different kind of collision shape. Now we use <strong class="source-inline">CollisionPolygon2D</strong>. This shape lets us define our own arbitrary shape. The advantage is that we can create any shape we like. The disadvantage is that arbitrary polygons are a bit slower for the physics engine to handle. But this should not be a big problem <a id="_idTextAnchor616"/>in our game because we will not have thousands of objects that require complex<a id="_idIndexMarker525"/> <span class="No-Break">physics </span><span class="No-Break"><a id="_idIndexMarker526"/></span><span class="No-Break">calculations.</span></p>
			<p>Now that we know how to create static bodies, we can do the same for other static objects in our game, such <span class="No-Break">as walls.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor617"/>Creating static bodies for the walls</h2>
			<p>Let’s do <a id="_idIndexMarker527"/>something similar by adding collision to the <a id="_idIndexMarker528"/>walls within <span class="No-Break">the game:</span></p>
			<ol>
				<li>Open <span class="No-Break">up </span><span class="No-Break"><strong class="source-inline">wall.tscn</strong></span><span class="No-Break">.</span></li>
				<li>Add a <span class="No-Break"><strong class="bold">StaticBody2D</strong></span><span class="No-Break"> node.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer164">
					<img alt="Figure 9.16 – The wall’s StaticBody2D has two CollisioniShape2D children" src="image/B19358_09_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – The wall’s StaticBody2D has two CollisioniShape2D children</p>
			<ol>
				<li value="3">Instead of using a <strong class="bold">CollisionPolygon2D</strong>, add two <span class="No-Break"><strong class="bold">CollisionShape2D</strong></span><span class="No-Break"> nodes.</span></li>
				<li>Give them each a <strong class="bold">RectangleShape2D</strong> in their <span class="No-Break"><strong class="bold">Shape</strong></span><span class="No-Break"> property.</span></li>
				<li>Now make sure that the combination of these two shapes covers <span class="No-Break">the wall:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer165">
					<img alt="Figure 9.17 – Covering the wall using the two RectangleShape2Ds" src="image/B19358_09_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Covering the wall using the two RectangleShape2Ds</p>
			<p>From this example, you can see that a single physics body can actually contain multiple collision shapes. This is very useful when constructing complex shapes without having to resort to a <strong class="bold">CollisionPolygon2D</strong>. Although we used two rectangle shapes, we could have used two different shapes if we wanted to, even combining regular shapes and polygons. We can add as many shapes under one physics body as <span class="No-Break">we desire.</span></p>
			<p>In this section, we learned how to use different physics bodies to do collision detection and make sure<a id="_idIndexMarker529"/> the player doesn’t walk through walls and <a id="_idIndexMarker530"/>boulders. In the next section, we’ll extend this knowledge to also use the physics engine to detect whether the player is within a<a id="_idTextAnchor618"/> certain region <span class="No-Break">or not.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor619"/>Creating collectibles</h1>
			<p>Now, let’s create <a id="_idIndexMarker531"/>some collectibles for our hero to pick up. We’ll create two <span class="No-Break">different collectibles:</span></p>
			<ul>
				<li>A health potion, which will replenish the health of <span class="No-Break">the character</span></li>
				<li>A coin, which will add one gold to the <span class="No-Break">player’s money</span></li>
			</ul>
			<p>We’ll start off by creating a base collectible, from which we can easily implement the two different behaviors we want the two collectibles <span class="No-Break">to have.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor620"/>Creating the base collectible scene</h2>
			<p>The base scene <a id="_idIndexMarker532"/>and class that we will build to inherit each specific collectible is very important; it should cover the use case of all other collectibles that we want to create. So <span class="No-Break">let’s start:</span></p>
			<ol>
				<li>Create a new scene called <strong class="source-inline">collectible.tscn</strong> in a new <span class="No-Break">folder, </span><span class="No-Break"><strong class="source-inline">parts/collectibles</strong></span><span class="No-Break">.</span></li>
				<li>Set up the scene as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.18</em></span><span class="No-Break">:</span><ol><li class="upper-roman">Make the root node a <strong class="bold">Node2D</strong> and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Collectible</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Add an <strong class="bold">Area2D</strong> node and a <strong class="bold">Sprite2D</strong> as <span class="No-Break">direct children.</span></li><li class="upper-roman"> Add a <strong class="bold">CollisionShape2D</strong> to <span class="No-Break">the area.</span></li></ol></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer166">
					<img alt="Figure 9.18 – The base scene structure for our collectibles" src="image/B19358_09_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – The base scene structure for our collectibles</p>
			<ol>
				<li value="3">Fill the <strong class="bold">Shape</strong> property of the <strong class="bold">CollisionShape2D</strong> with <span class="No-Break">a </span><span class="No-Break"><strong class="bold">CircleShape2D</strong></span><span class="No-Break">.</span></li>
				<li>Update the radius of the circle shape to be <span class="No-Break"><strong class="source-inline">25</strong></span><span class="No-Break"> pixels.</span></li>
			</ol>
			<p>We use a new node type, <strong class="bold">Area2D</strong>. An <strong class="bold">Area2D</strong> node can detect collisions when another physics body or area enters its shape. As we are using this physics object, the <strong class="bold">Area2D</strong> node will not act out any physics, nor will it influence the physics of the other physics body. <strong class="bold">Area2D</strong> nodes are used to detect whether other bodies or areas overlap their collision shape. We will use this functionality to detect if the player character overlaps the collectible because when this happens, we have to execute the code associated with <span class="No-Break">the collectible.</span></p>
			<p>With the base collectible scene ready, we can easily inherit from it in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor621"/>Inheriting from a base scene</h2>
			<p>If you were <a id="_idIndexMarker533"/>wondering why we didn’t add a texture to the collectible scene yet, that’s because we want to do that for specific collectibles, such as the health potion and coin, and not for <span class="No-Break">the base.</span></p>
			<p>So let’s create a <span class="No-Break">specific collectible:</span></p>
			<ol>
				<li>Right-click on the <strong class="source-inline">collectible.tscn</strong> scene in the file manager and select <strong class="bold">New </strong><span class="No-Break"><strong class="bold">Inherited Scene</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer167">
					<img alt="Figure 9.19 - Right-clicking the collectible.tscn file and choosing New Inherited Scene" src="image/B19358_09_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 - Right-clicking the collectible.tscn file and choosing New Inherited Scene</p>
			<ol>
				<li value="2">A new scene will open up. Rename the root node <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">HealthPotion</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer168">
					<img alt="Figure 9.20 – The inherited nodes are greyed out" src="image/B19358_09_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – The inherited nodes are greyed out</p>
			<ol>
				<li value="3">Save the inherited scene as <strong class="source-inline">health_potion.tscn</strong> in the same folder as the <strong class="source-inline">collectible.tscn</strong>, which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">parts/collectibles</strong></span><span class="No-Break">.</span></li>
				<li>Now add the <strong class="source-inline">HealthPotion.png</strong>, from <strong class="source-inline">assets/visual/collectibles</strong>, as a texture to the <span class="No-Break"><strong class="bold">Sprite2D</strong></span><span class="No-Break"> node.</span></li>
				<li>The sprite is a little small, so set the scale to <strong class="source-inline">(2, 2)</strong>, as we did for the player’s sprite in <a href="B19358_06.xhtml#_idTextAnchor411"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer169">
					<img alt="Figure 9.21 – This is how our health potion collectible should look in the editor" src="image/B19358_09_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – This is how our health potion collectible should look in the editor</p>
			<p>You can see that all <a id="_idIndexMarker534"/>the nodes, except for the root node, are greyed out, as in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>. That is because these nodes are managed by the scene we are inheriting from, the <strong class="source-inline">collectible.tscn</strong> scene in <span class="No-Break">this case.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer170">
					<img alt="Figure 9.22 – When inheriting a scene, the inherited nodes are greyed out" src="image/B19358_09_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – When inheriting a scene, the inherited nodes are greyed out</p>
			<p class="callout-heading">Try it yourself</p>
			<p class="callout">Just as an experiment, go back to the <strong class="source-inline">collectible.tscn</strong> scene, put the sprite node in a different location, and save. If you have a look in the <strong class="source-inline">health_potion.tscn</strong> scene, you’ll see that the sprite moved to the same <span class="No-Break">location too!</span></p>
			<p>With the technique of inheriting scenes, we can easily build out the functionality of collectibles without having to alter each collectible’s scene separately or copy-pasting. We can just define the base structure and <span class="No-Break">functionality once.</span></p>
			<p>With our base health potion scene done, we can now add its logic. First, we need to know when the<a id="_idIndexMarker535"/> player is actually close enough to pick up the collectible. We’ll learn how to do this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor622"/>Connecting to a signal</h2>
			<p>In the <em class="italic">Creating the base collectible scene</em> section, I told you that we were going to use an <strong class="bold">Area2D</strong> node<a id="_idIndexMarker536"/> to detect when the player’s physics shape enters and thus when we know the collectible should <span class="No-Break">be collected.</span></p>
			<p>To do this, we’ll learn about a new concept in Godot<a id="_idIndexMarker537"/> Engine: <strong class="bold">signals</strong>. All nodes can throw signals; a signal could be something such as <em class="italic">“a physics body entered my shape”</em>. We could listen, or connect, to this signal and run a piece of code whenever <span class="No-Break">it happens.</span></p>
			<p>We will now do this for the signal that the <strong class="bold">Area2D</strong> node throws when a physics body enters its <span class="No-Break">collision shape:</span></p>
			<ol>
				<li>Go to the <span class="No-Break"><strong class="source-inline">collectible.tscn</strong></span><span class="No-Break"> scene.</span></li>
				<li>Add an empty script to the root node. To connect to a signal, we first need a script. Make sure to delete all the code within the script except for the first one that says it extends the <strong class="bold">Node2D</strong>. Save the script <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">collectible.gb</strong></span><span class="No-Break">.</span></li>
				<li>Now select the <strong class="bold">Area2D</strong> node. In the right panel, where we normally see the Inspector for<a id="_idIndexMarker538"/> a node, there is also a tab called <strong class="bold">Node</strong>. <span class="No-Break">Click it.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer171">
					<img alt="Figure 9.23 – The list of signals an Area2D node can throw; body_entered is the one we need" src="image/B19358_09_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – The list of signals an Area2D node can throw; body_entered is the one we need</p>
			<ol>
				<li value="4">This tab shows us the different signals a node can throw. The one we want to connect to is called <strong class="source-inline">body_entered</strong> because it gets thrown from the moment a physics body enters the <strong class="bold">Area2D</strong> node. Select this signal and press the <strong class="bold">Connect</strong> button in the <span class="No-Break">bottom right.</span></li>
				<li>A modal pops up asking us to which node in the current scene we want to connect this signal. The root <strong class="source-inline">Collectible</strong> node should already be selected, so just press the <span class="No-Break"><strong class="bold">Connect</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer172">
					<img alt="Figure 9.24 – Selecting the node we want to connect the signal with, the Collectible node in our case" src="image/B19358_09_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Selecting the node we want to connect the signal with, the Collectible node in our case</p>
			<ol>
				<li value="6">We will now<a id="_idIndexMarker539"/> directly be taken to the <strong class="source-inline">collectible.gb</strong> script and you can see that a new function, <strong class="source-inline">_on_area_2d_body_entered</strong>, got added <span class="No-Break">for us:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer173">
					<img alt="Figure 9.25 – A new function will automatically be created for us after connecting the signal" src="image/B19358_09_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – A new function will automatically be created for us after connecting the signal</p>
			<p>The connection of the signal is done; now, every time the <strong class="source-inline">body_entered</strong> signal is thrown by the <strong class="bold">Area2D</strong> node, the <strong class="source-inline">_on_area_2d_body_entered</strong> function of that collectible will <span class="No-Break">be executed.</span></p>
			<p>Also notice that the generated function has a parameter called <strong class="source-inline">body</strong>. This is the body object that overlapped the <strong class="bold">Area2D</strong>; for example, the player. Signals can give some context when they <a id="_idIndexMarker540"/>are being throw in the form of these parameters. Different signals have different parameters, and most have no parameters <span class="No-Break">at all.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor623"/>Writing the code for collectibles</h2>
			<p>Now we’ll finally <a id="_idIndexMarker541"/>write some real code to give the player some new health points when picking up the health potion, though it will not be that much, to be honest. Let’s write the code necessary to make our health <span class="No-Break">potion functional:</span></p>
			<ol>
				<li>First, go back to the <strong class="source-inline">collectible.gd</strong> script. We’ll make this script a named class by adding a line defining the class name at <span class="No-Break">the top:</span><pre class="source-code">
class_name Collectible</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Creating a named class with <strong class="source-inline">class_name</strong> is not 100% necessary here, but it is good practice to name classes that you are going to <span class="No-Break">inherit from.</span></p>
			<ol>
				<li value="2">Now in the <strong class="source-inline">health_potion.tscn</strong> scene, right-click on the root node, and select <span class="No-Break"><strong class="bold">Extend Script</strong></span><span class="No-Break">.</span></li>
				<li>Save the new script as <strong class="source-inline">health_potion.gd</strong> in the same folder as <strong class="source-inline">health_potion.tscn</strong>. This will create a script that inherits from the <strong class="source-inline">Collectible</strong> class and assigns it to the <strong class="bold">HealthPotion</strong> node <span class="No-Break">for us.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer174">
					<img alt="Figure 9.26 – Right-clicking the HealthPotion node and selecting Extend Script" src="image/B19358_09_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Right-clicking the HealthPotion node and selecting Extend Script</p>
			<ol>
				<li value="4">Next, override<a id="_idIndexMarker542"/> the <strong class="source-inline">_on_area_2d_body_entered()</strong> function by defining a new one, <span class="No-Break">like so:</span><pre class="source-code">
func _on_area_2d_body_entered(body):
   body.health += 5
   queue_free()</pre></li>			</ol>
			<p>This function is used in the <strong class="source-inline">Collectible</strong> class to connect to the <strong class="source-inline">body_entered</strong> signal. By overriding it here, we effectively replace the function that will <span class="No-Break">be executed.</span></p>
			<p>You can see that we take the body that is provided as an argument and simply update its health value by <span class="No-Break">adding </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></p>
			<p>The last line introduces a new function that we can call on nodes: <strong class="source-inline">queue_free()</strong>. This function will queue the node for deletion so that the engine knows it can be removed from the scene tree. The engine will delete the node at the end of the <span class="No-Break">current frame.</span></p>
			<p>Let’s try this out! Go back to the main scene and add a health potion somewhere by dragging and dropping the scene anywhere in <span class="No-Break">the arena:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer175">
					<img alt="Figure 9.27 – Adding a HealthPotion in the main scene" src="image/B19358_09_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.27 – Adding a HealthPotion in the main scene</p>
			<p>If you put the health potion somewhere without boulders or walls, you will be able to walk over there <a id="_idIndexMarker543"/>with the player character and pick it up. But if you put the health potion too close to a boulder or wall, you’ll get an error! Oh no! Let’s learn how to solve <span class="No-Break">this next.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor624"/>Using collision layers and masks</h2>
			<p>There is one problem! The<a id="_idIndexMarker544"/> signal will now be thrown for every physics body that enters the <strong class="bold">Area2D</strong> of the collectible, so even for boulders and walls. But we only want to trigger the functionality when our player enters <span class="No-Break">the area.</span></p>
			<p>Luckily, we can only <a id="_idIndexMarker545"/>trigger the overlap detection for certain bodies using collision layers <span class="No-Break">and masks.</span></p>
			<h3>Introducing collision layers and masks</h3>
			<p>If you select<a id="_idIndexMarker546"/> the <strong class="bold">Area2D</strong> node within the <strong class="source-inline">collectible.tscn</strong> scene, you’ll see the <strong class="bold">Collision Layer</strong> and <strong class="bold">Collision Mask</strong> properties in the inspector. These two dictate what other physics bodies and areas can interact with <span class="No-Break">the area.</span></p>
			<ul>
				<li><strong class="bold">Collision Layers</strong> dictates what layer the physics object is in and can be detected by other <span class="No-Break">physics objects.</span></li>
				<li><strong class="bold">Collision Mask</strong> dictates what layers this physics object is looking at for <span class="No-Break">collision detection.</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer176">
					<img alt="Figure 9.28 – There are 32 separate collision layers and masks" src="image/B19358_09_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.28 – There are 32 separate collision layers and masks</p>
			<p>This means that the collision layers are used to tell other bodies and areas that you exist, while the collision mask is used to detect other bodies and areas. Note that these don’t need to be the same. The layers could be different from the mask, and that one body or area can be active in multiple layers and can look at <span class="No-Break">multiple masks.</span></p>
			<p>Each collision layer has a number associated with it, but we can actually give them a name that is easier to read for humans. We’ll do that in the <span class="No-Break">next section.</span></p>
			<h3>Naming collision layers</h3>
			<p>What we are going to<a id="_idIndexMarker547"/> do is use one layer, <strong class="source-inline">layer number 1</strong>, as the layer for wall collisions and another layer, <strong class="source-inline">layer number 2</strong>, for collectible detection. Because it is difficult and non-descriptive to talk about <strong class="source-inline">layer number 1</strong> and <strong class="source-inline">layer number 2</strong>, we can name layers within the Godot Editor. This will help us in the <span class="No-Break">long run:</span></p>
			<ol>
				<li>Open up the <span class="No-Break"><strong class="bold">Project Settings</strong></span><span class="No-Break">.</span></li>
				<li>Navigate to <strong class="bold">Layer Names</strong> | <span class="No-Break"><strong class="bold">2D Physics</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer177">
					<img alt="Figure 9.29 – Naming collision layers under the 2D Physics category" src="image/B19358_09_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.29 – Naming collision layers under the 2D Physics category</p>
			<p class="list-inset">Here, you can see the different collision layers and their names. None of them have a <span class="No-Break">name yet.</span></p>
			<ol>
				<li value="3">Give <strong class="bold">Layer 1</strong> the name <strong class="source-inline">Collision</strong> and <strong class="bold">Layer 2</strong> the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">Collectible</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer178">
					<img alt="Figure 9.30 – Naming two of the layers" src="image/B19358_09_30.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.30 – Naming two of the layers</p>
			<ol>
				<li value="4">If we now<a id="_idIndexMarker548"/> select the <strong class="bold">Area2D</strong> node from the collectible scene again and hover over the layer numbers, we’ll see the name <span class="No-Break">pop up:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer179">
					<img alt="Figure 9.31 – Hovering over a collision layer number shows us its name" src="image/B19358_09_31.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.31 – Hovering over a collision layer number shows us its name</p>
			<ol>
				<li value="5">We can also click on the ellipses next to the layers for easier layer selection to see our <span class="No-Break">names there.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer180">
					<img alt="Figure 9.32 – Pressing the ellipses makes it easy to select named collision layers" src="image/B19358_09_32.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.32 – Pressing the ellipses makes it easy to select named collision layers</p>
			<p>With these collision<a id="_idIndexMarker549"/> layers having a name, it will be easier to assign them in the future. So let’s do that in the <span class="No-Break">next section.</span></p>
			<h3>Assigning the right layers</h3>
			<p>Now that we<a id="_idIndexMarker550"/> understand collision layers and masks and know how to name them, let’s use them so that only the player can <span class="No-Break">trigger collectibles.</span></p>
			<p>We’ll have to adjust the collision layers and masks of all physics bodies in the game. Luckily, we made separate scenes for all of them, so this will go fast and, in the future, we can take these layers into account while making <span class="No-Break">the scenes.</span></p>
			<p>For the <strong class="source-inline">player.tscn</strong> root node, configure the layers and mask <span class="No-Break">as follows:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer181">
					<img alt="Figure 9.33 – The collision layer and mask configuration for the player" src="image/B19358_09_33.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.33 – The collision layer and mask configuration for the player</p>
			<p>For the <strong class="source-inline">boulder.tscn</strong> and <strong class="source-inline">wall.tscn</strong>, we want the <span class="No-Break">following configuration:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer182">
					<img alt="Figure 9.34 – The collision layer and mask configuration for boulders and walls" src="image/B19358_09_34.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.34 – The collision layer and mask configuration for boulders and walls</p>
			<p>Lastly, for the <strong class="source-inline">collectible.tscn</strong> scene, set the configuration <span class="No-Break">as follows:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer183">
					<img alt="Figure 9.35 – The collision layer and mask configuration for collectibles" src="image/B19358_09_35.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.35 – The collision layer and mask configuration for collectibles</p>
			<p>You can see that the player, boulders, and wall are in both the collision layer and collision mask. This is because they need to be able to interact with each other. On the other hand, the player is in the collectible layer and not the collectible mask, while the collectible scene<a id="_idIndexMarker551"/> does the opposite. We define the layer and mask for collectibles this way because the player doesn’t directly need to interact with collectibles and doesn’t need to detect them; the collectible scene does all t<a id="_idTextAnchor625"/><a id="_idTextAnchor626"/>he work <span class="No-Break">for us.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor627"/>Your turn!</h2>
			<p>Great, we created our health potion! Now you can implement the coin so the player can collect gold. Here are some of the steps you <span class="No-Break">could take:</span></p>
			<ol>
				<li>Make a new inherited scene from the <strong class="source-inline">collectible.tscn</strong> scene as we saw in the <em class="italic">Inheriting from a base </em><span class="No-Break"><em class="italic">scene</em></span><span class="No-Break"> section.</span></li>
				<li>Extend the collectible script, as we did in the <em class="italic">Writing the collectible </em><span class="No-Break"><em class="italic">code </em></span><span class="No-Break">section.</span></li>
				<li>Track the amount of gold the player owns using <span class="No-Break">a variable.</span></li>
				<li>Show how many coins the player owns on the screen using <span class="No-Break">a label.</span></li>
			</ol>
			<p>I’ll leave a possible implementation of all this in the repository of <span class="No-Break">the project.</span></p>
			<p>We learned a lot in this section. We discovered what <strong class="bold">Area2D</strong> nodes are, and collision layers and masks are no longer a mystery but a useful tool for defining what bodies and areas we want to interact with. Let’s do some last exercises before summarizing and ending <span class="No-Break">the chapter.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor628"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>Oh no! We added collisions to the boulders and inner walls of the arena, but not to the outer walls. Add a <strong class="bold">StaticBody2D</strong> that stops the player from escaping <span class="No-Break">the arena.</span></li>
				<li>Create a base scene for the boulders, inherit two boulders from that, and make their shapes different. Also, make sure you update the collision shape so that the player collides correctly <span class="No-Break">with them.</span></li>
			</ol>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor629"/>Summary</h1>
			<p>We started this chapter learning all about the <strong class="bold">Camera2D</strong> node and making it smooth and usable for the player so that they don’t have to think about it while navigating around the <span class="No-Break">playing field.</span></p>
			<p>After, we added colliders to the player and all solid objects within the game. We even used collision shapes to create little collectible items, such as a <span class="No-Break">health potion.</span></p>
			<p>Along the way, we saw what signals are and how we can connect them to functions in a <span class="No-Break">node’s script.</span></p>
			<p>In the next chapter, we’ll flesh out our game with enemies and menus so that<a id="_idTextAnchor630"/> we have a full <span class="No-Break">game loop.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor631"/>Quiz time</h1>
			<ul>
				<li>Why did we use a point in front of the player to position <span class="No-Break">the camera?</span></li>
				<li>What does the last parameter of a <strong class="source-inline">Vector2</strong>’s <strong class="source-inline">lerp</strong> function represent? Here is <span class="No-Break">an example:</span><pre class="source-code">
var position: Vector2 = Vector2(1, 1)
var target_position: Vector2 = Vector2(3, 5)
position.lerp(target_position, 0.5)</pre></li>				<li>Why did we use a <strong class="bold">CharacterBody2D</strong> for the player character and not <span class="No-Break">a </span><span class="No-Break"><strong class="bold">RigidBody2D</strong></span><span class="No-Break">?</span></li>
				<li>What are <strong class="bold">Area2D</strong> nodes <span class="No-Break">used for?</span></li>
				<li>We have two objects: an <strong class="bold">Area2D</strong> node and a <strong class="bold">CharacterBody2D</strong> node. We want to be able to detect the <strong class="bold">CharacterBody2D</strong> with the <strong class="bold">Area2D</strong> node. How do we need to configure their collision layers <span class="No-Break">and masks?</span></li>
				<li>The <strong class="bold">Area2D</strong> and <strong class="bold">CharacterBody2D</strong> nodes should be in the same <span class="No-Break">collision layer.</span></li>
				<li>The <strong class="bold">Area2D</strong> node should be in the same collision mask as the <strong class="bold">CharacterBody2D</strong> node’s <span class="No-Break">collision layer.</span></li>
				<li>The <strong class="bold">Area2D</strong> and the <strong class="bold">CharacterBody2D</strong> nodes should be in the same <span class="No-Break">collision mask.</span></li>
				<li>Signals notify us of certain actions that happen in a node. To what signal did we connect to detect if a player entered the <strong class="bold">Area2D</strong> node of <span class="No-Break">a collectible?</span></li>
			</ul>
		</div>
	</body></html>