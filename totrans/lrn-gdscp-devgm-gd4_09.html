<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor590"/>9</h1>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor591"/>Cameras, Collisions, and Collectibles</h1>
			<p>While playing a game, the player doesn’t want to have to think about the camera and its placement. The camera should always follow the player’s character and anticipate what the player wants to achieve so it doesn’t obstruct the player’s vision.</p>
			<p>In bigger games, full teams are tasked with producing the smoothest camera possible. In this chapter, we will attempt to do the same with some Godot Engine nodes.</p>
			<p>After that, we’ll stop the player from walking through walls and have a look at sprinkling collectibles, such as health and money, around our arena.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Making a camera that follows the player</li>
				<li>Collisions with boulders and walls</li>
				<li>Collision masks</li>
				<li>Creating inherited scenes</li>
				<li>Connecting to signals</li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor592"/>Technical requirements</h1>
			<p>As for every chapter, you can find the final code on the GitHub repository in the subfolder for this chapter at <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter9">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter9</a>.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor593"/>Making a camera that follows the player</h1>
			<p>At the moment, our<a id="_idIndexMarker490"/> character can run around, but at some point, it will run off the screen and get lost forever. Our in-game camera should follow them around so the player knows where they are.</p>
			<p>Luckily, the Godot Engine has a pretty nice camera system that we can use. It can be a bit basic, but it is all we need, and with some extra nodes, we’ll be able to achieve a very smooth-moving camera.<a id="_idTextAnchor594"/></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor595"/>Setting up a basic camera</h2>
			<p>For 2D games, Godot<a id="_idIndexMarker491"/> provides the <strong class="bold">Camera2D</strong> node.</p>
			<p>Open up the <code>player.tscn</code> scene and add a <code>Player</code> node. This is all we need to make a basic camera that follows the player:</p>
			<div><div><img alt="Figure 9.1 – The player scene with an added Camera2D node" src="img/B19358_09_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The player scene with an added Camera2D node</p>
			<p>But this basic camera feels a bit stiff; it starts and stops moving at exactly the moment the character does. This doesn’t feel very natural. Let’s see how to solve this.<a id="_idTextAnchor596"/></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor597"/>Adding drag margins</h2>
			<p>To make the<a id="_idIndexMarker492"/> camera movement appear natural, we will use <strong class="bold">drag margins</strong>. Find and enable <strong class="bold">Horizontal</strong> and <strong class="bold">Vertical</strong> drag in the camera’s inspector:</p>
			<div><div><img alt="Figure 9.2 – The drag margin settings for the Camera2D node in the inspector." src="img/B19358_09_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The drag margin settings for the Camera2D node in the inspector.</p>
			<p>Now, the camera only moves when the player exits a certain area in the middle of the screen. This is the <a id="_idIndexMarker493"/>margin within which nothing happens. If you enable <strong class="bold">Draw Drag Margin</strong> in the camera’s inspector, you can see the drag margins visualized:</p>
			<div><div><img alt="Figure 9.3 – Showing the drag margins in the editor by enabling them in the Camera2D inspector" src="img/B19358_09_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Showing the drag margins in the editor by enabling them in the Camera2D inspector</p>
			<p>With <strong class="bold">Draw Drag Margin</strong> enabled, you should be able to see the blue rectangles indicating when the camera will start moving:</p>
			<div><div><img alt="Figure 9.4 – The editor now shows the drag margins in light blue" src="img/B19358_09_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The editor now shows the drag margins in light blue</p>
			<p>You can play a bit with the left, top, right, and bottom margins in the inspector. I chose to set them all to <code>0.1</code>, as seen in <em class="italic">Figure </em><em class="italic">9</em><em class="italic">.2</em> earlier.</p>
			<p>Great, the drag<a id="_idIndexMarker494"/> margins already feel great. But the camera still starts and stops moving very abruptly and seems to lag behind the player. Let’s fix that nex<a id="_idTextAnchor598"/><a id="_idTextAnchor599"/>t.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor600"/>Making the camera look ahead</h2>
			<p>The movement <a id="_idIndexMarker495"/>of the camera feels pretty great now. But there is something wrong; we need something more fundamental than nice, smooth movement. When the player moves, the camera drags behind, showing where the player has been and not where the player is going.</p>
			<div><div><img alt="Figure 9.5 – The camera lags behind the player and does not show where the player is going" src="img/B19358_09_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The camera lags behind the player and does not show where the player is going</p>
			<p>This is not great; imagine running somewhere and only being able to look backward. What we actually<a id="_idIndexMarker496"/> want is for the camera to look ahead in the direction the player is moving. We can do this by, instead of tracking the player itself, tracking a point in front of the player. Basically, it is as if the player character is holding a selfie stick. So, follow these steps:</p>
			<ol>
				<li>Add a new <code>Player</code>  and call it <code>CameraPosition</code>. This will become the point we are going to track instead of the player itself.</li>
				<li>Now drag the camera we already made onto this <code>CameraPosition</code> so that it is a child of the new node:</li>
			</ol>
			<div><div><img alt="Figure 9.6 – Put the Camera2D node under a separate node called CameraPosition" src="img/B19358_09_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Put the Camera2D node under a separate node called CameraPosition</p>
			<ol>
				<li value="3">Make sure that the position of the <code>CameraPosition</code> is set to <code>(0, 0)</code> in the inspector:</li>
			</ol>
			<div><div><img alt="Figure 9.7 – Make sure the Camera2D and CameraPosition nodes are at position (0, 0)" src="img/B19358_09_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Make sure the Camera2D and CameraPosition nodes are at position (0, 0)</p>
			<ol>
				<li value="4">Add a script to the <code>CameraPosition</code> called <code>camera_position.gd</code>.</li>
			</ol>
			<p>This script will keep the position in front of the camera. We can do this based on the <code>velocity</code> that the player character has.</p>
			<p>The complete<a id="_idIndexMarker497"/> script looks like this:</p>
			<pre class="source-code">
extends Node2D
@export var camera_distance: float = 200
@onready var _player: CharacterBody2D = get_parent()
func _process(_delta):
   var move_direction: Vector2 = _player.velocity.normalized()
   position = move_direction * camera_distance</pre>			<p>First, we define an export variable that we can play with called <code>camera_distance</code>.<a id="_idTextAnchor601"/><a id="_idTextAnchor602"/><a id="_idTextAnchor603"/> This will be the distance in front of the player at which we will keep the camera while the player is moving.</p>
			<p>With <code>_physics_process()</code>, which gets executed for each physics frame of the game, we calculate the position of the camera point. Remember that this position is relative to the <code>Player</code> node, so a position of <code>(0, 0)</code> is right where the player is.The idea is to take the direction in which the player is moving and multiply that by the <code>camera_distance</code>. The direction the player is moving in can be derived from the <code>velocity</code> of the player. So first, we get the player node using the <code>get_parent</code> function and cache it in the <code>_player</code> variable. This function returns the parent of a node, in this case, the <code>Player</code> node because the <code>CameraPosition</code> is a direct child of that node.</p>
			<p>Then, to get the direction the player is moving in, we normalize this <code>velocity</code> vector. Normalizing a vector, as we saw in <a href="B19358_07.xhtml#_idTextAnchor523"><em class="italic">Chapter 7</em></a>, means that you take the whole vector and make it of length <code>1</code>. So, the whole vector is <code>1</code> pixel long. This will leave us with the direction of the <code>velocity</code> without its length. Now we can easily scale this direction to whatever length we want by multiplying it with the <code>camera_distance</code> to define the <code>position</code> of the <code>CameraPosition</code>. If you run the game now, you’ll see that <code>CameraPosition</code> does what you want it to and makes the camera look ahead in the direction the <a id="_idIndexMarker498"/>character is moving. But it is still a bit janky, so let’s smooth that out one last time<a id="_idTextAnchor604"/>.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor605"/>Smoothing out the look ahead</h2>
			<p>The problem<a id="_idIndexMarker499"/> now is that the camera starts moving very suddenly and abruptly stops. This happens because the <code>CameraPosition</code> we created jumps around quite quickly. To fix this problem, we should make the movement of the <code>CameraPosition</code> itself smooth.</p>
			<p>First, add a new exported variable, like so:</p>
			<pre class="source-code">
@export var position_interpolation_speed: float = 1.0</pre>			<p>Now, let’s change the <code>_process()</code> function of the <code>camera_position.gd</code> script as follows:</p>
			<pre class="source-code">
func _physics_process(<strong class="bold">delta</strong>):
   var move_direction: Vector2 = _player.velocity.normalized()
   <strong class="bold">var target_position: Vector2 = move_direction * camera_distance</strong>
   position = <code>CameraPosition</code> to have as a <code>target_position</code>. Then, in the next line, we calculate the actual <code>position</code>.</p>
			<p>To calculate the position, we use a new function, <code>lerp()</code>. This is short for <code>move_towards()</code>, which we used in <a href="B19358_07.xhtml#_idTextAnchor523"><em class="italic">Chapter 7</em></a>. However, while <code>move_towards()</code> moves the position a certain number of pixels toward the target position, <code>lerp</code> moves the position toward the <code>target_position</code> according to a percentage between the two, which is the last argument in the function. This percentage is expressed in a value from <code>0.0</code> to <code>1.0</code>, where <code>0.0</code> is <code>0%</code> and <code>1.0</code> is <code>100%</code>.</p>
			<p>So, let’s say we want to move <code>50%</code> between the position and its target, then the resulting position will be right in the middle between the two points.</p>
			<p>This process is called <strong class="bold">linear interpolation</strong> because we interpolate between two values linearly. The way we use linear interpolation in our camera position script is to move toward the target position a little bit every frame.</p>
			<p>The percentage of the linear interpolation that I chose was <code>5.0 * delta</code>. I put this value in an exported variable so we can easily tweak it from the editor. Because delta is the time between<a id="_idIndexMarker501"/> two frames, the result of this product is very small and should result in an interpolation of around <code>10%</code> per frame. We multiply by <code>delta</code> because, just like for the movement speed of the player, we want the speed of the camera not to change on faster or slower computers that run at a higher or lower framerate. We talked about frame rate independent calculations in <a href="B19358_07.xhtml#_idTextAnchor523"><em class="italic">Chapter 7</em></a> too when making the character move.</p>
			<p>You can play around with the speed of the interpolation by changing the <code>position_interpolation_speed</code> to anything else through the inspector.</p>
			<p>In this section, we learned a great deal about creating a smooth and useful camera that frames where the player is moving toward. As mentioned in the introduction of this chapter, big-budget games have whole teams that work on nothing else but the camera. But using some<a id="_idIndexMarker502"/> smart tricks, we achieved a fairly nice camera for our little game. Now, we’ll shift gears and make sure the player stops running through walls by adding collision detection.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor606"/>Collisions</h1>
			<p>With our brand-new <a id="_idIndexMarker503"/>camera in place, let’s take a look at collisions. For now, we have the visuals of a nice arena, including walls and rocks, but they don’t really act like them. The player character is able to just run through them as if they were made out of air instead of solid matter.</p>
			<p>Just like with the movement of the player, we can solve this using the built-in physics engine. Let’s start by taking a look at the different physics bodies at our dis<a id="_idTextAnchor607"/>posal.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor608"/>The different physics bodies</h2>
			<p>For the player<a id="_idIndexMarker504"/> character, we used the <strong class="bold">CharacterBody2D</strong> physics body. But this is not the only kind that comes with the physics engine Godot. There are a few other ones:</p>
			<div><div><img alt="Figure 9.8 – The three different physics bodies as displayed in the scene tree" src="img/B19358_09_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The three different physics bodies as displayed in the scene tree</p>
			<p>For 2D games, there are three different kinds of physics bodies available. Each has its own uses within a game or physics simulation. Let’s take a look at<a id="_idTextAnchor609"/> each.</p>
			<h3>RigidBody2D</h3>
			<p>A rigid body is a<a id="_idIndexMarker505"/> physics object that is fully simulated. Rigid<a id="_idIndexMarker506"/> bodies are completely dependent on outside physical forces and collisions. You are not supposed to control them directly.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">These bodies are called rigid because the body itself does not deform. So, it gets used for simulating solid objects from cars to bones to walls. The <strong class="bold">StaticBody2D</strong> and <strong class="bold">CharacterBody2D</strong> can also not deform and are therefore also rigid bodies, but more in the mathematical sense of the word and not in how they are implemented within the engine.</p>
			<p>We cannot directly control a rigid body; they are fully managed by the physics engine, which resolves how it moves and how the velocities and forces get applied. The only way to control a rigid body is by applying external forces to it. This is like hitting a golf ball with a stick. With enough practice and fine-tuning, you can get the ball in the general direction of the hole, but picking it up and dropping it in there, though easier, is not an option.</p>
			<p>Simulating non-rigid, bodies, also known as soft bodies, is generally harder to do mathematically and performantly within a game. Soft bodies could be sponges, rubber objects that deform, jelly, and so on. There are ways to simulate these within a rigid body<a id="_idIndexMarker507"/> simulation, but it’s<a id="_idIndexMarker508"/> not advised to do this. In 3D, there is a <strong class="bold">Softbody3D</strong> node, but it is n<a id="_idTextAnchor610"/>ot for 2D.</p>
			<h3>StaticBody2D</h3>
			<p>A static body is a <a id="_idIndexMarker509"/>physics body that stays static, meaning it<a id="_idIndexMarker510"/> does not move around and also cannot be pushed by external forces. This is the simplest of physics bodies to deal with and will be ideal for making our walls and r<a id="_idTextAnchor611"/>ocks out of.</p>
			<h3>CharacterBody2D</h3>
			<p>A character <a id="_idIndexMarker511"/>body is a physics body that we are able <a id="_idIndexMarker512"/>to control through code. A <strong class="bold">RigidBody2D</strong>, as we saw earlier, is fully managed by the physics engine. This makes it hard to control to get it to do what you want it to.</p>
			<p>A character body, on the other hand, gives us a good middle ground. Like in the <code>player.gd</code> script, we have to calculate the <code>velocity</code> ourselves and call <code>move_and_slide()</code>. But the physics engine still helps us out with collisions and calculating where the body is supposed to move based on the velocity.</p>
			<p class="callout-heading">More information</p>
			<p class="callout">The Godot documentation also has a great write-up of the different physics bodies and how they can be used: <a href="https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#collision-objects">https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#collision-objects</a>.</p>
			<p>These were the three types of physics bodies available in Godot. But there is actually a fourth physics <a id="_idIndexMarker513"/>object, which is not a body. Let’s take a <a id="_idIndexMarker514"/>look at the <strong class="bold">Area2D</strong> node.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor612"/>The Area2D node</h2>
			<p>The three <a id="_idIndexMarker515"/>physics bodies we just saw all collide with each other and react <a id="_idIndexMarker516"/>to this collision or make other bodies react to it. In essence, their movements get processed by the physics engine.</p>
			<p>The last physics object, <strong class="bold">Area2D</strong>, only detects and influences other physics objects. It is not subjected to physics calculation, like for movement. But it can detect if another physics object is overlapping it and throws a signal when these other physics objects enter or leave.</p>
			<p>We will use this functionality near the end of this chapter to make the player pick up health potions when they come near them.</p>
			<div><div><img alt="Figure 9.9 – The four different physics objects as they are displayed in the scene tree" src="img/B19358_09_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The four different physics objects as they are displayed in the scene tree</p>
			<p>Now that you know about the three types of physics bodies currently available, we can start utilizing them to create proper collisions.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor613"/>Adding a collision shape to the player node</h2>
			<p>Since we<a id="_idIndexMarker517"/> created the player node all the way back in <a href="B19358_06.xhtml#_idTextAnchor411"><em class="italic">Chapter 6</em></a>, there<a id="_idIndexMarker518"/> has been this little orange triangle next to it. When we hover over it, the tool tip explains to us that this node is missing a shape. This makes sense, how can the physics engine detect collisions if it doesn’t know what shape a physics body is?</p>
			<p>Let’s solve this little warning:</p>
			<ol>
				<li>Find and add the <code>Player</code> node:</li>
			</ol>
			<div><div><img alt="Figure 9.10 – Add a CollisionShape2D to the player scene" src="img/B19358_09_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Add a CollisionShape2D to the player scene</p>
			<ol>
				<li value="2">Select this newly created <strong class="bold">CollisionShape2D</strong> node and click on the empty <strong class="bold">Shape</strong> field to reveal a drop-down menu with different shapes.</li>
				<li>Select the <strong class="bold">CapsuleShape2D</strong> option.</li>
			</ol>
			<div><div><img alt="Figure 9.11 – Select a CapsuleShape2D as the CollisionShape2D’s shape" src="img/B19358_09_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Select a CapsuleShape2D as the CollisionShape2D’s shape</p>
			<ol>
				<li value="4">A capsule-like blue shape will appear on the screen. This is the shape of the physics body. Use the orange circles on the periphery of the shape to change its size and try to cover most of the player sprite:</li>
			</ol>
			<div><div><img alt="Figure 9.12 – Make sure the CapsuleShape2D covers the player sprite" src="img/B19358_09_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Make sure the CapsuleShape2D covers the player sprite</p>
			<p>The <strong class="bold">CollisionShape2D</strong> node in itself does not have a shape, but it will hold one for us. That is why<a id="_idIndexMarker519"/> we <a id="_idIndexMarker520"/>had to add one to the <strong class="bold">Shape</strong> property.</p>
			<p>Other shapes that are interesting as collision shapes are <strong class="bold">RectangleShape2D</strong> and <strong class="bold">CircleShape2D</strong>. The others are used in specialized situations, such as for very thin or disjointed objects, so don’t worry too much about them just yet.</p>
			<div><div><img alt="Figure 9.13 – The CircleShape2D and RectangleShape2D" src="img/B19358_09_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – The CircleShape2D and RectangleShape2D</p>
			<p>Running the game now will not result in the player colliding with the boulders or walls, simply because first, we’ll <a id="_idIndexMarker521"/>also need to add physics bodies<a id="_idIndexMarker522"/> and shapes to the s<a id="_idTextAnchor614"/>cenes of these two.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor615"/>Creating static bodies for the boulders</h2>
			<p>In the <em class="italic">The different physics bodies</em> section, we<a id="_idIndexMarker523"/> learned <a id="_idIndexMarker524"/>that <strong class="bold">StaticBody2D</strong> nodes don’t move; that sounds ideal for a boulder. So, let’s make them solid:</p>
			<ol>
				<li>Go into our <code>boulder.tscn</code> scene.</li>
				<li>Add a <strong class="bold">StaticBody2D</strong> node under the root node:</li>
			</ol>
			<div><div><img alt="Figure 9.14 – Adding a StaticBody2D with a CollisionPolygon2D as a child of the boulder scene" src="img/B19358_09_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Adding a StaticBody2D with a CollisionPolygon2D as a child of the boulder scene</p>
			<ol>
				<li value="3">Add a <code>CollisionPolygon2D</code> node under this newly created static body.</li>
				<li>Now add points to the collision polygon by clicking within the 2D editor. Try to cover the boulder completely:</li>
			</ol>
			<div><div><img alt="Figure 9.15 – Cover the boulder with the PolygonShape2D" src="img/B19358_09_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Cover the boulder with the PolygonShape2D</p>
			<p>Note that we use a different kind of collision shape. Now we use <code>CollisionPolygon2D</code>. This shape lets us define our own arbitrary shape. The advantage is that we can create any shape we like. The disadvantage is that arbitrary polygons are a bit slower for the physics engine to handle. But this should not be a big problem <a id="_idTextAnchor616"/>in our game because we will not have thousands of objects that require complex<a id="_idIndexMarker525"/> physics <a id="_idIndexMarker526"/>calculations.</p>
			<p>Now that we know how to create static bodies, we can do the same for other static objects in our game, such as walls.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor617"/>Creating static bodies for the walls</h2>
			<p>Let’s do <a id="_idIndexMarker527"/>something similar by adding collision to the <a id="_idIndexMarker528"/>walls within the game:</p>
			<ol>
				<li>Open up <code>wall.tscn</code>.</li>
				<li>Add a <strong class="bold">StaticBody2D</strong> node.</li>
			</ol>
			<div><div><img alt="Figure 9.16 – The wall’s StaticBody2D has two CollisioniShape2D children" src="img/B19358_09_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – The wall’s StaticBody2D has two CollisioniShape2D children</p>
			<ol>
				<li value="3">Instead of using a <strong class="bold">CollisionPolygon2D</strong>, add two <strong class="bold">CollisionShape2D</strong> nodes.</li>
				<li>Give them each a <strong class="bold">RectangleShape2D</strong> in their <strong class="bold">Shape</strong> property.</li>
				<li>Now make sure that the combination of these two shapes covers the wall:</li>
			</ol>
			<div><div><img alt="Figure 9.17 – Covering the wall using the two RectangleShape2Ds" src="img/B19358_09_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Covering the wall using the two RectangleShape2Ds</p>
			<p>From this example, you can see that a single physics body can actually contain multiple collision shapes. This is very useful when constructing complex shapes without having to resort to a <strong class="bold">CollisionPolygon2D</strong>. Although we used two rectangle shapes, we could have used two different shapes if we wanted to, even combining regular shapes and polygons. We can add as many shapes under one physics body as we desire.</p>
			<p>In this section, we learned how to use different physics bodies to do collision detection and make sure<a id="_idIndexMarker529"/> the player doesn’t walk through walls and <a id="_idIndexMarker530"/>boulders. In the next section, we’ll extend this knowledge to also use the physics engine to detect whether the player is within a<a id="_idTextAnchor618"/> certain region or not.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor619"/>Creating collectibles</h1>
			<p>Now, let’s create <a id="_idIndexMarker531"/>some collectibles for our hero to pick up. We’ll create two different collectibles:</p>
			<ul>
				<li>A health potion, which will replenish the health of the character</li>
				<li>A coin, which will add one gold to the player’s money</li>
			</ul>
			<p>We’ll start off by creating a base collectible, from which we can easily implement the two different behaviors we want the two collectibles to have.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor620"/>Creating the base collectible scene</h2>
			<p>The base scene <a id="_idIndexMarker532"/>and class that we will build to inherit each specific collectible is very important; it should cover the use case of all other collectibles that we want to create. So let’s start:</p>
			<ol>
				<li>Create a new scene called <code>collectible.tscn</code> in a new folder, <code>parts/collectibles</code>.</li>
				<li>Set up the scene as shown in <em class="italic">Figure 9</em><em class="italic">.18</em>:<ol><li class="upper-roman">Make the root node a <code>Collectible</code>.</li><li class="upper-roman">Add an <strong class="bold">Area2D</strong> node and a <strong class="bold">Sprite2D</strong> as direct children.</li><li class="upper-roman"> Add a <strong class="bold">CollisionShape2D</strong> to the area.</li></ol></li>
			</ol>
			<div><div><img alt="Figure 9.18 – The base scene structure for our collectibles" src="img/B19358_09_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – The base scene structure for our collectibles</p>
			<ol>
				<li value="3">Fill the <strong class="bold">Shape</strong> property of the <strong class="bold">CollisionShape2D</strong> with a <strong class="bold">CircleShape2D</strong>.</li>
				<li>Update the radius of the circle shape to be <code>25</code> pixels.</li>
			</ol>
			<p>We use a new node type, <strong class="bold">Area2D</strong>. An <strong class="bold">Area2D</strong> node can detect collisions when another physics body or area enters its shape. As we are using this physics object, the <strong class="bold">Area2D</strong> node will not act out any physics, nor will it influence the physics of the other physics body. <strong class="bold">Area2D</strong> nodes are used to detect whether other bodies or areas overlap their collision shape. We will use this functionality to detect if the player character overlaps the collectible because when this happens, we have to execute the code associated with the collectible.</p>
			<p>With the base collectible scene ready, we can easily inherit from it in the next section.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor621"/>Inheriting from a base scene</h2>
			<p>If you were <a id="_idIndexMarker533"/>wondering why we didn’t add a texture to the collectible scene yet, that’s because we want to do that for specific collectibles, such as the health potion and coin, and not for the base.</p>
			<p>So let’s create a specific collectible:</p>
			<ol>
				<li>Right-click on the <code>collectible.tscn</code> scene in the file manager and select <strong class="bold">New </strong><strong class="bold">Inherited Scene</strong>.</li>
			</ol>
			<div><div><img alt="Figure 9.19 - Right-clicking the collectible.tscn file and choosing New Inherited Scene" src="img/B19358_09_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 - Right-clicking the collectible.tscn file and choosing New Inherited Scene</p>
			<ol>
				<li value="2">A new scene will open up. Rename the root node to <code>HealthPotion</code>:</li>
			</ol>
			<div><div><img alt="Figure 9.20 – The inherited nodes are greyed out" src="img/B19358_09_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – The inherited nodes are greyed out</p>
			<ol>
				<li value="3">Save the inherited scene as <code>health_potion.tscn</code> in the same folder as the <code>collectible.tscn</code>, which is <code>parts/collectibles</code>.</li>
				<li>Now add the <code>HealthPotion.png</code>, from <code>assets/visual/collectibles</code>, as a texture to the <strong class="bold">Sprite2D</strong> node.</li>
				<li>The sprite is a little small, so set the scale to <code>(2, 2)</code>, as we did for the player’s sprite in <a href="B19358_06.xhtml#_idTextAnchor411"><em class="italic">Chapter 6</em></a>:</li>
			</ol>
			<div><div><img alt="Figure 9.21 – This is how our health potion collectible should look in the editor" src="img/B19358_09_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – This is how our health potion collectible should look in the editor</p>
			<p>You can see that all <a id="_idIndexMarker534"/>the nodes, except for the root node, are greyed out, as in <em class="italic">Figure 9</em><em class="italic">.22</em>. That is because these nodes are managed by the scene we are inheriting from, the <code>collectible.tscn</code> scene in this case.</p>
			<div><div><img alt="Figure 9.22 – When inheriting a scene, the inherited nodes are greyed out" src="img/B19358_09_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – When inheriting a scene, the inherited nodes are greyed out</p>
			<p class="callout-heading">Try it yourself</p>
			<p class="callout">Just as an experiment, go back to the <code>collectible.tscn</code> scene, put the sprite node in a different location, and save. If you have a look in the <code>health_potion.tscn</code> scene, you’ll see that the sprite moved to the same location too!</p>
			<p>With the technique of inheriting scenes, we can easily build out the functionality of collectibles without having to alter each collectible’s scene separately or copy-pasting. We can just define the base structure and functionality once.</p>
			<p>With our base health potion scene done, we can now add its logic. First, we need to know when the<a id="_idIndexMarker535"/> player is actually close enough to pick up the collectible. We’ll learn how to do this in the next section.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor622"/>Connecting to a signal</h2>
			<p>In the <em class="italic">Creating the base collectible scene</em> section, I told you that we were going to use an <strong class="bold">Area2D</strong> node<a id="_idIndexMarker536"/> to detect when the player’s physics shape enters and thus when we know the collectible should be collected.</p>
			<p>To do this, we’ll learn about a new concept in Godot<a id="_idIndexMarker537"/> Engine: <strong class="bold">signals</strong>. All nodes can throw signals; a signal could be something such as <em class="italic">“a physics body entered my shape”</em>. We could listen, or connect, to this signal and run a piece of code whenever it happens.</p>
			<p>We will now do this for the signal that the <strong class="bold">Area2D</strong> node throws when a physics body enters its collision shape:</p>
			<ol>
				<li>Go to the <code>collectible.tscn</code> scene.</li>
				<li>Add an empty script to the root node. To connect to a signal, we first need a script. Make sure to delete all the code within the script except for the first one that says it extends the <code>collectible.gb</code>.</li>
				<li>Now select the <strong class="bold">Area2D</strong> node. In the right panel, where we normally see the Inspector for<a id="_idIndexMarker538"/> a node, there is also a tab called <strong class="bold">Node</strong>. Click it.</li>
			</ol>
			<div><div><img alt="Figure 9.23 – The list of signals an Area2D node can throw; body_entered is the one we need" src="img/B19358_09_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – The list of signals an Area2D node can throw; body_entered is the one we need</p>
			<ol>
				<li value="4">This tab shows us the different signals a node can throw. The one we want to connect to is called <code>body_entered</code> because it gets thrown from the moment a physics body enters the <strong class="bold">Area2D</strong> node. Select this signal and press the <strong class="bold">Connect</strong> button in the bottom right.</li>
				<li>A modal pops up asking us to which node in the current scene we want to connect this signal. The root <code>Collectible</code> node should already be selected, so just press the <strong class="bold">Connect</strong> button.</li>
			</ol>
			<div><div><img alt="Figure 9.24 – Selecting the node we want to connect the signal with, the Collectible node in our case" src="img/B19358_09_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Selecting the node we want to connect the signal with, the Collectible node in our case</p>
			<ol>
				<li value="6">We will now<a id="_idIndexMarker539"/> directly be taken to the <code>collectible.gb</code> script and you can see that a new function, <code>_on_area_2d_body_entered</code>, got added for us:</li>
			</ol>
			<div><div><img alt="Figure 9.25 – A new function will automatically be created for us after connecting the signal" src="img/B19358_09_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – A new function will automatically be created for us after connecting the signal</p>
			<p>The connection of the signal is done; now, every time the <code>body_entered</code> signal is thrown by the <code>_on_area_2d_body_entered</code> function of that collectible will be executed.</p>
			<p>Also notice that the generated function has a parameter called <code>body</code>. This is the body object that overlapped the <strong class="bold">Area2D</strong>; for example, the player. Signals can give some context when they <a id="_idIndexMarker540"/>are being throw in the form of these parameters. Different signals have different parameters, and most have no parameters at all.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor623"/>Writing the code for collectibles</h2>
			<p>Now we’ll finally <a id="_idIndexMarker541"/>write some real code to give the player some new health points when picking up the health potion, though it will not be that much, to be honest. Let’s write the code necessary to make our health potion functional:</p>
			<ol>
				<li>First, go back to the <code>collectible.gd</code> script. We’ll make this script a named class by adding a line defining the class name at the top:<pre class="source-code">
class_name Collectible</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Creating a named class with <code>class_name</code> is not 100% necessary here, but it is good practice to name classes that you are going to inherit from.</p>
			<ol>
				<li value="2">Now in the <code>health_potion.tscn</code> scene, right-click on the root node, and select <strong class="bold">Extend Script</strong>.</li>
				<li>Save the new script as <code>health_potion.gd</code> in the same folder as <code>health_potion.tscn</code>. This will create a script that inherits from the <code>Collectible</code> class and assigns it to the <strong class="bold">HealthPotion</strong> node for us.</li>
			</ol>
			<div><div><img alt="Figure 9.26 – Right-clicking the HealthPotion node and selecting Extend Script" src="img/B19358_09_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Right-clicking the HealthPotion node and selecting Extend Script</p>
			<ol>
				<li value="4">Next, override<a id="_idIndexMarker542"/> the <code>_on_area_2d_body_entered()</code> function by defining a new one, like so:<pre class="source-code">
func _on_area_2d_body_entered(body):
   body.health += 5
   queue_free()</pre></li>			</ol>
			<p>This function is used in the <code>Collectible</code> class to connect to the <code>body_entered</code> signal. By overriding it here, we effectively replace the function that will be executed.</p>
			<p>You can see that we take the body that is provided as an argument and simply update its health value by adding <code>5</code>.</p>
			<p>The last line introduces a new function that we can call on nodes: <code>queue_free()</code>. This function will queue the node for deletion so that the engine knows it can be removed from the scene tree. The engine will delete the node at the end of the current frame.</p>
			<p>Let’s try this out! Go back to the main scene and add a health potion somewhere by dragging and dropping the scene anywhere in the arena:</p>
			<div><div><img alt="Figure 9.27 – Adding a HealthPotion in the main scene" src="img/B19358_09_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.27 – Adding a HealthPotion in the main scene</p>
			<p>If you put the health potion somewhere without boulders or walls, you will be able to walk over there <a id="_idIndexMarker543"/>with the player character and pick it up. But if you put the health potion too close to a boulder or wall, you’ll get an error! Oh no! Let’s learn how to solve this next.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor624"/>Using collision layers and masks</h2>
			<p>There is one problem! The<a id="_idIndexMarker544"/> signal will now be thrown for every physics body that enters the <strong class="bold">Area2D</strong> of the collectible, so even for boulders and walls. But we only want to trigger the functionality when our player enters the area.</p>
			<p>Luckily, we can only <a id="_idIndexMarker545"/>trigger the overlap detection for certain bodies using collision layers and masks.</p>
			<h3>Introducing collision layers and masks</h3>
			<p>If you select<a id="_idIndexMarker546"/> the <code>collectible.tscn</code> scene, you’ll see the <strong class="bold">Collision Layer</strong> and <strong class="bold">Collision Mask</strong> properties in the inspector. These two dictate what other physics bodies and areas can interact with the area.</p>
			<ul>
				<li><strong class="bold">Collision Layers</strong> dictates what layer the physics object is in and can be detected by other physics objects.</li>
				<li><strong class="bold">Collision Mask</strong> dictates what layers this physics object is looking at for collision detection.</li>
			</ul>
			<div><div><img alt="Figure 9.28 – There are 32 separate collision layers and masks" src="img/B19358_09_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.28 – There are 32 separate collision layers and masks</p>
			<p>This means that the collision layers are used to tell other bodies and areas that you exist, while the collision mask is used to detect other bodies and areas. Note that these don’t need to be the same. The layers could be different from the mask, and that one body or area can be active in multiple layers and can look at multiple masks.</p>
			<p>Each collision layer has a number associated with it, but we can actually give them a name that is easier to read for humans. We’ll do that in the next section.</p>
			<h3>Naming collision layers</h3>
			<p>What we are going to<a id="_idIndexMarker547"/> do is use one layer, <code>layer number 1</code>, as the layer for wall collisions and another layer, <code>layer number 2</code>, for collectible detection. Because it is difficult and non-descriptive to talk about <code>layer number 1</code> and <code>layer number 2</code>, we can name layers within the Godot Editor. This will help us in the long run:</p>
			<ol>
				<li>Open up the <strong class="bold">Project Settings</strong>.</li>
				<li>Navigate to <strong class="bold">Layer Names</strong> | <strong class="bold">2D Physics</strong>:</li>
			</ol>
			<div><div><img alt="Figure 9.29 – Naming collision layers under the 2D Physics category" src="img/B19358_09_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.29 – Naming collision layers under the 2D Physics category</p>
			<p class="list-inset">Here, you can see the different collision layers and their names. None of them have a name yet.</p>
			<ol>
				<li value="3">Give <code>Collision</code> and <code>Collectible</code>:</li>
			</ol>
			<div><div><img alt="Figure 9.30 – Naming two of the layers" src="img/B19358_09_30.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.30 – Naming two of the layers</p>
			<ol>
				<li value="4">If we now<a id="_idIndexMarker548"/> select the <strong class="bold">Area2D</strong> node from the collectible scene again and hover over the layer numbers, we’ll see the name pop up:</li>
			</ol>
			<div><div><img alt="Figure 9.31 – Hovering over a collision layer number shows us its name" src="img/B19358_09_31.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.31 – Hovering over a collision layer number shows us its name</p>
			<ol>
				<li value="5">We can also click on the ellipses next to the layers for easier layer selection to see our names there.</li>
			</ol>
			<div><div><img alt="Figure 9.32 – Pressing the ellipses makes it easy to select named collision layers" src="img/B19358_09_32.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.32 – Pressing the ellipses makes it easy to select named collision layers</p>
			<p>With these collision<a id="_idIndexMarker549"/> layers having a name, it will be easier to assign them in the future. So let’s do that in the next section.</p>
			<h3>Assigning the right layers</h3>
			<p>Now that we<a id="_idIndexMarker550"/> understand collision layers and masks and know how to name them, let’s use them so that only the player can trigger collectibles.</p>
			<p>We’ll have to adjust the collision layers and masks of all physics bodies in the game. Luckily, we made separate scenes for all of them, so this will go fast and, in the future, we can take these layers into account while making the scenes.</p>
			<p>For the <code>player.tscn</code> root node, configure the layers and mask as follows:</p>
			<div><div><img alt="Figure 9.33 – The collision layer and mask configuration for the player" src="img/B19358_09_33.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.33 – The collision layer and mask configuration for the player</p>
			<p>For the <code>boulder.tscn</code> and <code>wall.tscn</code>, we want the following configuration:</p>
			<div><div><img alt="Figure 9.34 – The collision layer and mask configuration for boulders and walls" src="img/B19358_09_34.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.34 – The collision layer and mask configuration for boulders and walls</p>
			<p>Lastly, for the <code>collectible.tscn</code> scene, set the configuration as follows:</p>
			<div><div><img alt="Figure 9.35 – The collision layer and mask configuration for collectibles" src="img/B19358_09_35.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.35 – The collision layer and mask configuration for collectibles</p>
			<p>You can see that the player, boulders, and wall are in both the collision layer and collision mask. This is because they need to be able to interact with each other. On the other hand, the player is in the collectible layer and not the collectible mask, while the collectible scene<a id="_idIndexMarker551"/> does the opposite. We define the layer and mask for collectibles this way because the player doesn’t directly need to interact with collectibles and doesn’t need to detect them; the collectible scene does all t<a id="_idTextAnchor625"/><a id="_idTextAnchor626"/>he work for us.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor627"/>Your turn!</h2>
			<p>Great, we created our health potion! Now you can implement the coin so the player can collect gold. Here are some of the steps you could take:</p>
			<ol>
				<li>Make a new inherited scene from the <code>collectible.tscn</code> scene as we saw in the <em class="italic">Inheriting from a base </em><em class="italic">scene</em> section.</li>
				<li>Extend the collectible script, as we did in the <em class="italic">Writing the collectible </em><em class="italic">code </em>section.</li>
				<li>Track the amount of gold the player owns using a variable.</li>
				<li>Show how many coins the player owns on the screen using a label.</li>
			</ol>
			<p>I’ll leave a possible implementation of all this in the repository of the project.</p>
			<p>We learned a lot in this section. We discovered what <strong class="bold">Area2D</strong> nodes are, and collision layers and masks are no longer a mystery but a useful tool for defining what bodies and areas we want to interact with. Let’s do some last exercises before summarizing and ending the chapter.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor628"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>Oh no! We added collisions to the boulders and inner walls of the arena, but not to the outer walls. Add a <strong class="bold">StaticBody2D</strong> that stops the player from escaping the arena.</li>
				<li>Create a base scene for the boulders, inherit two boulders from that, and make their shapes different. Also, make sure you update the collision shape so that the player collides correctly with them.</li>
			</ol>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor629"/>Summary</h1>
			<p>We started this chapter learning all about the <strong class="bold">Camera2D</strong> node and making it smooth and usable for the player so that they don’t have to think about it while navigating around the playing field.</p>
			<p>After, we added colliders to the player and all solid objects within the game. We even used collision shapes to create little collectible items, such as a health potion.</p>
			<p>Along the way, we saw what signals are and how we can connect them to functions in a node’s script.</p>
			<p>In the next chapter, we’ll flesh out our game with enemies and menus so that<a id="_idTextAnchor630"/> we have a full game loop.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor631"/>Quiz time</h1>
			<ul>
				<li>Why did we use a point in front of the player to position the camera?</li>
				<li>What does the last parameter of a <code>Vector2</code>’s <code>lerp</code> function represent? Here is an example:<pre class="source-code">
var position: Vector2 = Vector2(1, 1)
var target_position: Vector2 = Vector2(3, 5)
position.lerp(target_position, 0.5)</pre></li>				<li>Why did we use a <strong class="bold">CharacterBody2D</strong> for the player character and not a <strong class="bold">RigidBody2D</strong>?</li>
				<li>What are <strong class="bold">Area2D</strong> nodes used for?</li>
				<li>We have two objects: an <strong class="bold">Area2D</strong> node and a <strong class="bold">CharacterBody2D</strong> node. We want to be able to detect the <strong class="bold">CharacterBody2D</strong> with the <strong class="bold">Area2D</strong> node. How do we need to configure their collision layers and masks?</li>
				<li>The <strong class="bold">Area2D</strong> and <strong class="bold">CharacterBody2D</strong> nodes should be in the same collision layer.</li>
				<li>The <strong class="bold">Area2D</strong> node should be in the same collision mask as the <strong class="bold">CharacterBody2D</strong> node’s collision layer.</li>
				<li>The <strong class="bold">Area2D</strong> and the <strong class="bold">CharacterBody2D</strong> nodes should be in the same collision mask.</li>
				<li>Signals notify us of certain actions that happen in a node. To what signal did we connect to detect if a player entered the <strong class="bold">Area2D</strong> node of a collectible?</li>
			</ul>
		</div>
	</body></html>