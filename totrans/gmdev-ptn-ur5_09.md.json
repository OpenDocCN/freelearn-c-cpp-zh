["```cpp\npublic class AActor\n{\npublic:\nvoid ProcessGame() {\nBeginPlay();\nwhile(gameRunning)\n    Tick();\n    EndPlay();\n    }\nprotected:\n    abstract void BeginPlay();\n    abstract void Tick();\n    abstract void EndPlay();\n}\n```", "```cpp\nUCLASS(Abstract)\nclass RTS_AI_API ATemplateWeapon_Base : public AWeapon_Base\n{\n    GENERATED_BODY()\npublic:\n    virtual void Fire() override;\n    UFUNCTION(BlueprintCallable, BlueprintNativeEvent)\n    void Reload();\nprotected:\n    UFUNCTION(BlueprintNativeEvent)\n    bool CheckAmmo();\n    UFUNCTION(BlueprintImplementableEvent)\n    void ProcessFiring();\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayEffects();\n    UFUNCTION(BlueprintNativeEvent)\n    void UpdateAmmo();\n};\n```", "```cpp\nvoid ATemplateWeapon_Base::Fire()\n{\n    if(!_CanFire) return;\n    if(CheckAmmo())\n    {\n        PlayEffects();\n        ProcessFiring();\n        UpdateAmmo();\n        Super::Fire();\n        return;\n    }\n    Reload();\n}\n```", "```cpp\nvoid ATemplateWeapon_Base::Reload_Implementation()\n{\n    _CurrentAmmo = _MaxAmmo;\n    Handle_FireDelay();\n}\nbool ATemplateWeapon_Base::CheckAmmo_Implementation()\n{\n    return _AmmoPerFire <= _CurrentAmmo;\n}\nvoid ATemplateWeapon_Base::UpdateAmmo_Implementation()\n{\n    _CurrentAmmo -= _AmmoPerFire;\n}\n```", "```cpp\npublic class Sandbox_Parent\n{\npublic:\n    abstract void DoAThing();\nprotected:\n    void PlaySound() { //Plays sound correctly }\n    void FireParticle() { //Fires particle correctly }\n    void AddForce() { //Adds force correctly }\n    void DealDamage() { //Deals damage correctly }\n}\n```", "```cpp\nUCLASS(Abstract)\nclass RTS_AI_API ASandboxWeapon_Base : public AWeapon_Base\n{\n    GENERATED_BODY()\npublic:\n    virtual void Fire() override;\n    UFUNCTION(BlueprintImplementableEvent)\n    void SandboxFire();\n    UFUNCTION(BlueprintCallable)\n    void Reload();\nprotected:\n    UFUNCTION(BlueprintCallable)\n    bool CheckAmmo();\n    UFUNCTION(BlueprintCallable)\n    void LinetraceOneShot(FVector direction);\n    UFUNCTION(BlueprintCallable)\n    void PlaySound(USoundBase* sound);\n    UFUNCTION(BlueprintCallable)\n    void UpdateAmmo();\n};\n```", "```cpp\nvoid ASandboxWeapon_Base::Fire()\n{\n    SandboxFire();\n}\nvoid ASandboxWeapon_Base::Reload()\n{\n    _CurrentAmmo = _MaxAmmo; Handle_FireDelay();\n}\nbool ASandboxWeapon_Base::CheckAmmo()\n{\n    return _AmmoPerFire <= _CurrentAmmo;\n}\nvoid ASandboxWeapon_Base::PlaySound(USoundBase* sound)\n{\n    UGameplayStatics::PlaySoundAtLocation(this, sound,\n        GetActorLocation());\n}\nvoid ASandboxWeapon_Base::UpdateAmmo()\n{\n    _CurrentAmmo -= _AmmoPerFire;\n}\n```", "```cpp\nvoid ASandboxWeapon_Base::LinetraceOneShot(FVector direction)\n{\n    FHitResult hit(ForceInit);\n    FVector start = _FirePoint->GetComponentLocation();\n    FVector end = start + (direction * _Range);\n    if(!UKismetSystemLibrary::LineTraceSingle(GetWorld(),\n        start, end,\n        UEngineTypes::ConvertToTraceType(ECC_Visibility),\n        false,\n        {this, GetOwner()},\n        EDrawDebugTrace::ForDuration,\n        hit,\n        true,\n        FLinearColor::Red, FLinearColor::Green, 5))\n            return;\n    UGameplayStatics::ApplyDamage(hit.GetActor(),\n        _DamagePerHit, GetInstigatorController(),\n            GetOwner(), UDamageType::StaticClass());\n}\n```", "```cpp\nUCLASS(BlueprintType)\nclass RTS_AI_API UEnemyType : public UDataAsset\n{\n    GENERATED_BODY()\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    float _Health;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TObjectPtr<UMaterialInstance> _Material1;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TObjectPtr<UMaterialInstance> _Material2;\n};\n```"]