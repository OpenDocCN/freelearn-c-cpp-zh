<html><head></head><body>
<div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.2.1">Objects, Pointers, and References</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Before we start discussing memory management in C++, let’s make sure we understand each other and agree on a common vocabulary. </span><span class="koboSpan" id="kobo.3.2">If you’re a long-time C++ programmer, you probably have your own ideas about what pointers, objects, and references are. </span><span class="koboSpan" id="kobo.3.3">Your ideas will stem from a wealth of experience. </span><span class="koboSpan" id="kobo.3.4">If you are coming to this book from another language, you might also have your own ideas as to what these terms mean in C++ and how they relate to memory and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">memory management.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we are going to make sure we have a common understanding of some basic (but profound) ideas so that we can build on this shared understanding for the rest of our adventure together. </span><span class="koboSpan" id="kobo.5.2">Specifically, we will explore questions such as </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">How is memory represented in C++? </span><span class="koboSpan" id="kobo.7.2">What exactly is that thing we call memory, at least in the context of the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">C++ language?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">What are objects, pointers, and references? </span><span class="koboSpan" id="kobo.9.2">What do we mean by those terms in C++? </span><span class="koboSpan" id="kobo.9.3">What are the lifetime rules of objects? </span><span class="koboSpan" id="kobo.9.4">How do they relate </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">to memory?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">What are arrays in C++? </span><span class="koboSpan" id="kobo.11.2">In this language, arrays are a low-level but highly efficient construct represented in a way that directly impacts </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">memory management.</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">This book assumes that readers have some basic knowledge of C++ or of syntactically similar languages such as C, Java, C#, or JavaScript. </span><span class="koboSpan" id="kobo.14.2">For this reason, we will not explain the basics of variable declarations, loops, </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">if</span></strong><span class="koboSpan" id="kobo.16.1"> statements, </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">or functions.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">We will, however, use some aspects of the C++ language in this chapter that some readers might be less comfortable with. </span><span class="koboSpan" id="kobo.18.2">Please refer to </span><a href="B21071_16.xhtml#_idTextAnchor221"><em class="italic"><span class="koboSpan" id="kobo.19.1">Annexure</span></em></a><em class="italic"><span class="koboSpan" id="kobo.20.1">:</span></em> <em class="italic"><span class="koboSpan" id="kobo.21.1">Things You Should Know</span></em><span class="koboSpan" id="kobo.22.1">, before reading </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Some of the examples use C++20 or C++23, so make sure that your compiler supports this version of the standard to get the most out </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">The code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.30.1">Representation of memory in C++</span></h1>
<p><span class="koboSpan" id="kobo.31.1">This is a book on memory management. </span><span class="koboSpan" id="kobo.31.2">You, readers, are trying to figure out what it means, and I, as the author, am trying to convey what </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">it means.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">The way in which the standard describes memory can be seen in [</span><a href="http://wg21.link/basic.memobj"><span class="koboSpan" id="kobo.34.1">wg21.link/basic.memobj</span></a><span class="koboSpan" id="kobo.35.1">]. </span><span class="koboSpan" id="kobo.35.2">Essentially, memory in C++ is expressed as one or more sequences of contiguous bytes. </span><span class="koboSpan" id="kobo.35.3">This opens up the possibility of memory expressed as a set of discontinuous blocks of contiguous memory because, historically, C++ has supported memories made of various distinct segments. </span><span class="koboSpan" id="kobo.35.4">Every byte in a C++ program has a </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">unique address.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Memory in a C++ program is </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.38.1">populated with various entities such as objects, functions, references, and so on. </span><span class="koboSpan" id="kobo.38.2">Managing memory efficiently requires grasping what these entities mean and how programs can make use </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">The meaning of the word byte is important in C++. </span><span class="koboSpan" id="kobo.40.2">As detailed in [</span><a href="http://wg21.link/intro.memory"><span class="koboSpan" id="kobo.41.1">wg21.link/intro.memory</span></a><span class="koboSpan" id="kobo.42.1">], bytes are the fundamental storage unit in C++. </span><span class="koboSpan" id="kobo.42.2">The number of bits in a byte is implementation-defined in C++. </span><span class="koboSpan" id="kobo.42.3">The standard does state, however, that a byte has to be wide enough to contain both the ordinary literal encoding of any element of the basic literal character set and the eight-bit code units of the UTF-8 encoding form. </span><span class="koboSpan" id="kobo.42.4">It also states that a byte is made of a contiguous sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">of bits.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">What often surprises people is that in C++, a byte is not necessarily an octet: a byte consists of at least eight bits but could be made of more (something that’s useful on some exotic hardware). </span><span class="koboSpan" id="kobo.44.2">This might change in the future, as the standard committee might constrain that definition someday, but this is the situation at the time of the publication of this book. </span><span class="koboSpan" id="kobo.44.3">The key idea here is that a byte is the smallest addressable unit of memory in </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">a program.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.46.1">Objects, pointers, and references</span></h2>
<p><span class="koboSpan" id="kobo.47.1">We tend to use words such as object, pointer, and reference informally, without thinking too much about what they mean. </span><span class="koboSpan" id="kobo.47.2">In a language such as C++, these words have precise meanings that define and delimit what we can do </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Before we get our hands dirty, so to speak, let’s examine the formal meaning of these terms </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">in C++.</span></span></p>
<h3><span class="koboSpan" id="kobo.51.1">Objects</span></h3>
<p><span class="koboSpan" id="kobo.52.1">If we polled programmers working with different languages and asked them how they would define the term object, we could probably expect such answers as “something that groups together </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.53.1">variables and related functions” or “an instance of a class,” which correspond to traditional takes on that term from the realm of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">object-oriented programming.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">C++ as a language tries to provide homogeneous support for user-defined types such as structs or classes. </span><span class="koboSpan" id="kobo.55.2">It also provides support for fundamental types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">int</span></strong><span class="koboSpan" id="kobo.57.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">float</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">Thus, it probably should not </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.60.1">be surprising that, for C++, the definition of an object is expressed in terms of its properties, not in terms of what the word means, and that this definition includes the most fundamental types. </span><span class="koboSpan" id="kobo.60.2">The definition of an object in C++ is described in [</span><a href="http://wg21.link/intro.object"><span class="koboSpan" id="kobo.61.1">wg21.link/intro.object</span></a><span class="koboSpan" id="kobo.62.1">] and takes the following factors </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">into account:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.64.1">How the object is created explicitly, such as when defining the object or constructing it through one of the many variations of </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">operator new</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">The object may also be created implicitly such as when creating a temporary object as the result of some expression or when changing the active member of </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">union</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">The fact that an object is somewhere (it has an address) and occupies a region of storage of non-zero size, from the start of its construction to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">its destruction.</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">Other properties of an object, including its name (if it has one), its type, and its storage duration (</span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">automatic</span></strong><span class="koboSpan" id="kobo.74.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">static</span></strong><span class="koboSpan" id="kobo.76.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">thread_local</span></strong><span class="koboSpan" id="kobo.78.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">so on.).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.80.1">The C++ standard explicitly calls out functions as not being objects, even if a function has an address and </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">occupies storage.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">From this, we can infer that even a humble </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">int</span></strong><span class="koboSpan" id="kobo.84.1"> is an object, but a function is not. </span><span class="koboSpan" id="kobo.84.2">You can see already, dear reader, that the book you’re reading will touch on fundamental topics, since lifetime and the storage occupied by objects are part of the fundamental properties of these entities we use in our programs every day. </span><span class="koboSpan" id="kobo.84.3">Such things as lifetime and storage are </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.85.1">clearly part of what memory management is about. </span><span class="koboSpan" id="kobo.85.2">You can convince yourself of that fact with this</span><a id="_idIndexMarker004"/> <span class="No-Break"><span class="koboSpan" id="kobo.86.1">simple program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
#include &lt;type_traits&gt;
int main() {
   static_assert(std::is_object_v&lt;int&gt;);
   static_assert(!std::is_object_v&lt;decltype(main)&gt;);
}</span></pre> <p><span class="koboSpan" id="kobo.88.1">What is an object? </span><span class="koboSpan" id="kobo.88.2">It’s something that has a lifetime and occupies storage. </span><span class="koboSpan" id="kobo.88.3">Controlling these characteristics is part of the reasons why this </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">book exists.</span></span></p>
<h3><span class="koboSpan" id="kobo.90.1">Pointers</span></h3>
<p><span class="koboSpan" id="kobo.91.1">There are numerous (around 2,000) mentions of the word “pointer” in the text of the C++ standard, but if </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.92.1">you open an electronic copy of that document and search through it, you’ll find that a formal </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.93.1">definition is surprisingly hard to come by. </span><span class="koboSpan" id="kobo.93.2">This can be surprising given the fact that people tend to associate that idea with C and (by </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">extension) C++.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Let us try to offer a useful yet informal definition, then: a pointer is a typed address. </span><span class="koboSpan" id="kobo.95.2">It associates a type with what is found at some location in memory. </span><span class="koboSpan" id="kobo.95.3">For that reason, in code like the following, one reads that </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">n</span></strong><span class="koboSpan" id="kobo.97.1"> is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">int</span></strong><span class="koboSpan" id="kobo.99.1"> object and that </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">p</span></strong><span class="koboSpan" id="kobo.101.1"> points to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">int</span></strong><span class="koboSpan" id="kobo.103.1"> object that happens to be the address of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">n</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
int n = 3; // n is an int object
char c;
// int *p = &amp;c; // no, illegal
int *p = &amp;n;</span></pre> <p><span class="koboSpan" id="kobo.107.1">It’s important to understand here that </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">p</span></strong><span class="koboSpan" id="kobo.109.1"> indeed points to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">int</span></strong><span class="koboSpan" id="kobo.111.1">, unless </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">p</span></strong><span class="koboSpan" id="kobo.113.1"> is left uninitialized, </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">p</span></strong><span class="koboSpan" id="kobo.115.1"> points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">nullptr</span></strong><span class="koboSpan" id="kobo.117.1">, or programmers have played tricks with the type system and made </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">p</span></strong><span class="koboSpan" id="kobo.119.1"> point to something else deliberately. </span><span class="koboSpan" id="kobo.119.2">Of course, pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">p</span></strong><span class="koboSpan" id="kobo.121.1"> is an object, as it respects all the rules to </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">that effect.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">Much of the (syntactic) confusion about pointers probably comes from the contextual meaning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">*</span></strong><span class="koboSpan" id="kobo.125.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">&amp;</span></strong><span class="koboSpan" id="kobo.127.1"> symbols. </span><span class="koboSpan" id="kobo.127.2">The</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.128.1"> trick is to remember that they have different roles when they appear in the introduction of a name and when they</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.129.1"> are used on an </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">existing object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
int m = 4, n = 3;
int *p; // p declares (and defines) a pointer to an int
        // (currently uninitialized), introducing a name
p = 0; // p is a null pointer (it does not necessarily
       // point to address zero; 0 as used here is
       // just a convention)
p = nullptr; // likewise, but clearer. </span><span class="koboSpan" id="kobo.131.2">Prefer nullptr to
             // literal 0 whenever possible to describe
             // a null pointer
p = &amp;m; // p points to m (p contains the address of m)
assert(*p == 4); // p already exists; with *p we are
                 // accessing what p points to
p = &amp;n; // p now points to n (p contains the address of n)
int *q = &amp;n; // q declares (and defines) a pointer to an
             // int and &amp;n represents the address of n, the
             // address of an int: q is a pointer to an int
assert(*q == 3); // n holds 3 at this stage, and q points
                 // to n, so what q points to has value 3
assert(*p == 3); // the same holds for p
assert(p == q); // p and q point to the same int object
*q = 4; // q already exists, so *q means "whatever q
        // points to"
assert(n == 4); // indeed, n now holds value 4 since we
                // modified it indirectly through q
auto qq = &amp;q;   // qq is the address of q, and its type is
                // "pointer to a pointer to an int", thus
                // int **... </span><span class="koboSpan" id="kobo.131.3">But we will rarely – if ever –
                // need this
int &amp;r = n; // declaration of r as a reference to integer n
            // (see below). </span><span class="koboSpan" id="kobo.131.4">Note that &amp; is used in a
            // declaration in this case</span></pre> <p><span class="koboSpan" id="kobo.132.1">As you can see, when introducing an object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">*</span></strong><span class="koboSpan" id="kobo.134.1"> means “pointer to.” </span><span class="koboSpan" id="kobo.134.2">On an existing object, it means “what that pointer </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.135.1">points to” (the pointee). </span><span class="koboSpan" id="kobo.135.2">Similarly, when introducing a name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">&amp;</span></strong><span class="koboSpan" id="kobo.137.1"> means “reference to” (something we will discuss imminently). </span><span class="koboSpan" id="kobo.137.2">On an existing object, it means “address of” and yields </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">a pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Pointers allow us to </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.140.1">do arithmetic, but that’s (legitimately) seen as a dangerous operation, as it can take us to arbitrary locations in a program and can therefore lead to serious damage. </span><span class="koboSpan" id="kobo.140.2">Arithmetic on a pointer depends on </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">its type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
int *f();
char *g();
int danger() {
   auto p = f(); // p points to whatever f() returned
   int *q = p + 3; // q points to where p points to plus
                   // three times the size of an int. </span><span class="koboSpan" id="kobo.142.2">No
                   // clue where this is, but it's a bad,
                   // bad idea...
</span><span class="koboSpan" id="kobo.142.3">   auto pc = g(); // pc points to whatever g() returned
   char * qc = pc + 3; // qc points to where pc points
                       // to plus three times the size
                       // of a char. </span><span class="koboSpan" id="kobo.142.4">Please don't make
                       // your pointers go to places you
                       // don't know about like this
}</span></pre> <p><span class="koboSpan" id="kobo.143.1">Of course, accessing the contents of arbitrary addresses is just asking for trouble. </span><span class="koboSpan" id="kobo.143.2">This is because it would mean invoking undefined behavior (described in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.144.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.145.1">), and if you do that, you’re on your </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.146.1">own. </span><span class="koboSpan" id="kobo.146.2">Please do not do such things in real code, as you could hurt programs – or worse, people. </span><span class="koboSpan" id="kobo.146.3">C++ is powerful and flexible, but if </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.147.1">you program in C++, you’re expected to behave responsibly </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">and professionally.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">C++ has four special types for </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">pointer manipulation:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">void*</span></strong><span class="koboSpan" id="kobo.152.1"> means “address </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.153.1">with no specific (type-related) semantics.” </span><span class="koboSpan" id="kobo.153.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">void*</span></strong><span class="koboSpan" id="kobo.155.1"> is an address with no associated type. </span><span class="koboSpan" id="kobo.155.2">All pointers (if we discount the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">const</span></strong><span class="koboSpan" id="kobo.157.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">volatile</span></strong><span class="koboSpan" id="kobo.159.1"> qualifiers) are implicitly convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">void*</span></strong><span class="koboSpan" id="kobo.161.1">; an informal way to read this is as “all pointers, regardless of type, really are addresses.” </span><span class="koboSpan" id="kobo.161.2">The converse does not hold. </span><span class="koboSpan" id="kobo.161.3">For example, it’s not true that all addresses are implicitly convertible to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> pointers.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">char*</span></strong><span class="koboSpan" id="kobo.165.1"> means “pointer to a byte.” </span><span class="koboSpan" id="kobo.165.2">Due to the C language roots of C++, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">char*</span></strong><span class="koboSpan" id="kobo.167.1"> can alias any address in memory (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">char</span></strong><span class="koboSpan" id="kobo.169.1"> type, regardless of its name, which evocates “character”, really means “byte” in C and, by extension, in C++). </span><span class="koboSpan" id="kobo.169.2">There is an ongoing effort in C++ to give </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">char</span></strong><span class="koboSpan" id="kobo.171.1"> the meaning of “character,” but as of this writing, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">char*</span></strong><span class="koboSpan" id="kobo.173.1"> can alias pretty much anything in a program. </span><span class="koboSpan" id="kobo.173.2">This hampers some compiler optimization opportunities (it is hard to constrain or reason about something that can lead to literally anything </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">in memory).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">std::byte*</span></strong><span class="koboSpan" id="kobo.176.1"> is the new “pointer to a byte,” at least since C++17. </span><span class="koboSpan" id="kobo.176.2">The (long-term) intent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">byte*</span></strong><span class="koboSpan" id="kobo.178.1"> is to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">char*</span></strong><span class="koboSpan" id="kobo.180.1"> in those functions that do byte-per-byte manipulation or addressing, but since there’s so much code that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">char*</span></strong><span class="koboSpan" id="kobo.182.1"> to that effect, this will </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">take time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.184.1">For an example of</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.185.1"> conversion from and to </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">void*</span></strong><span class="koboSpan" id="kobo.187.1">, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
int n = 3;
int *p = &amp;n; // fine so far
void *pv = p; // Ok, a pointer is an address
// p = pv; // no, a void* does not necessarily point to
           // an int (Ok in C, not in C++)
p = static_cast&lt;int *&gt;(pv); // fine, you asked for it, but
                            // if you're wrong you're on
                            // your own</span></pre> <p><span class="koboSpan" id="kobo.190.1">The following example, which is</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.191.1"> somewhat more elaborate, uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">const char*</span></strong><span class="koboSpan" id="kobo.193.1"> (but could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">const byte*</span></strong><span class="koboSpan" id="kobo.195.1"> instead). </span><span class="koboSpan" id="kobo.195.2">It shows that one can compare the byte-per-byte representation of two objects, at least in some circumstances, to see whether they </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">are equivalent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
using namespace std;
bool same_bytes(const char *p0, const char *p1,
                std::size_t n) {
    for(std::size_t i = 0; i != n; ++i)
        if(*(p0 + i) != *(p1 + i))
            return false;
    return true;
}
template &lt;class T, class U&gt;
   bool same_bytes(const T &amp;a, const U &amp;b) {
      using namespace std;
       static_assert(sizeof a == sizeof b);
       static_assert(has_unique_object_representations_v&lt;
          T
       &gt;);
       static_assert(has_unique_object_representations_v&lt;
          U
       &gt;);
       return same_bytes(reinterpret_cast&lt;const char*&gt;(&amp;a),
                         reinterpret_cast&lt;const char*&gt;(&amp;b),
                         sizeof a);
   }
struct X {
   int x {2}, y{3};
};
struct Y {
   int x {2}, y{3};
};
#include &lt;cassert&gt;
int main() {
    constexpr X x;
    constexpr Y y;
    assert(same_bytes(x, y));
}</span></pre> <p><span class="koboSpan" id="kobo.198.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">has_unique_object_representations</span></strong><span class="koboSpan" id="kobo.200.1"> trait is true for types uniquely defined by their values, that is, types exempt of padding bits.. </span><span class="koboSpan" id="kobo.200.2">That’s sometimes important as C++ does not say what happens to padding bits in an object, and performing a bit-per-bit comparison of two objects might yield surprising results. </span><span class="koboSpan" id="kobo.200.3">Note that objects of floating</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.201.1"> point types are not considered uniquely defined by their values as there are many distinct values that qualify as NaN, or “not </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">a number”.</span></span></p>
<h3><span class="koboSpan" id="kobo.203.1">References</span></h3>
<p><span class="koboSpan" id="kobo.204.1">The C++ language supports two related families of indirections: pointers and references. </span><span class="koboSpan" id="kobo.204.2">Like their cousins, the pointers, references</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.205.1"> are often mentioned by the C++ standard (more than 1,800 times) but it’s hard to find a formal definition </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">for them.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">We will try once again to provide an informal </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.208.1">but operational definition: a reference can be seen as an alias for an existing entity. </span><span class="koboSpan" id="kobo.208.2">We deliberately did not use object, since one could refer to a function and we already know that a function is not </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">an object.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Pointers are objects. </span><span class="koboSpan" id="kobo.210.2">As such, they occupy storage. </span><span class="koboSpan" id="kobo.210.3">References, on the other hand, are not objects and use no storage of their own, even though an implementation could simulate their existence with pointers. </span><span class="koboSpan" id="kobo.210.4">Compare </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">std::is_object_v&lt;int*&gt;</span></strong><span class="koboSpan" id="kobo.212.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">std::is_object_v&lt;int&amp;&gt;</span></strong><span class="koboSpan" id="kobo.214.1">: the former is </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">true</span></strong><span class="koboSpan" id="kobo.216.1">, and the latter </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">sizeof</span></strong><span class="koboSpan" id="kobo.222.1"> operator, applied to a</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.223.1"> reference, will yield the size of what it refers to. </span><span class="koboSpan" id="kobo.223.2">Consequently, taking the address of a reference yields the address of what it </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">refers to.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">In C++, a reference is always bound to an object and remains bound to that object until the end of the reference’s lifetime. </span><span class="koboSpan" id="kobo.225.2">A pointer, on the other hand, can point to numerous distinct objects during its lifetime, as we have </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">seen before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
// int &amp;nope; // would not compile (what would nope
              // refer to?)
int n = 3;
int &amp;r = n; // r refers to n
++r; // n becomes 4
assert(&amp;r == &amp;n); // taking the address of r means taking
                  // the address of n</span></pre> <p><span class="koboSpan" id="kobo.228.1">Another difference between pointers and references is that, contrary to the situation that prevails with pointers, there is no such thing as reference arithmetic. </span><span class="koboSpan" id="kobo.228.2">This makes references somewhat safer than pointers. </span><span class="koboSpan" id="kobo.228.3">There is room for both kinds of indirections in a program (and we will use</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.229.1"> them both in this book!), but for everyday programming, a good rule of thumb is to use references if possible and to use pointers </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">if necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Now that we have</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.232.1"> examined the representation of memory and taken a look at how C++ defines some fundamental ideas such as a byte, an object, a pointer, or a reference, we can delve a little deeper into some important defining properties </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">of objects.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.234.1">Understanding the fundamental properties of objects</span></h1>
<p><span class="koboSpan" id="kobo.235.1">We saw earlier that in C++, an object has a type and an address. </span><span class="koboSpan" id="kobo.235.2">It also occupies a region of storage from the beginning of its construction to the end of its destruction. </span><span class="koboSpan" id="kobo.235.3">We will now examine these fundamental properties in more detail in order to understand how these properties affect the ways in which we </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">write programs.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.237.1">Object lifetime</span></h2>
<p><span class="koboSpan" id="kobo.238.1">One of C++’s strengths, but also one reason for its relative complexity, arises from the control one has over the lifetime of objects. </span><span class="koboSpan" id="kobo.238.2">In C++, generally speaking, automatic objects are destructed at the end of their scope in a well-defined order. </span><span class="koboSpan" id="kobo.238.3">Static (global) objects are destructed on program</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.239.1"> termination in a somewhat well-defined order (in a given file, the order of destruction is clear, but it’s more complicated for static objects in different files). </span><span class="koboSpan" id="kobo.239.2">Dynamically allocated objects are destructed “when your program says so” (there are many nuances </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">to this).</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">Let’s examine some aspects of object lifetime with the following (very) </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">simple program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;format&gt;
struct X {
   std::string s;
   X(std::string_view s) : s{ s } {
      std::cout &lt;&lt; std::format("X::X({})\n", s);
   }
   ~X(){
      std::cout &lt;&lt; std::format("~X::X() for {}\n", s);
   }
};
X glob { "glob" };
void g() {
   X xg{ «g()» };
}
int main() {
   X *p0 = new X{ "p0" };
   [[maybe_unused]] X *p1 = new X{ "p1" }; // will leak
   X xmain{ "main()" };
   g();
   delete p0;
   // oops, forgot delete p1
}</span></pre> <p><span class="koboSpan" id="kobo.244.1">When executed, that </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.245.1">program will print </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
X::X(glob)
X::X(p0)
X::X(p1)
X::X(main())
X::X(g())
~X::X() for g()
~X::X() for p0
~X::X() for main()
~X::X() for glob</span></pre> <p><span class="koboSpan" id="kobo.248.1">The fact that the number of constructors and destructors do not match is a sign that we did something wrong. </span><span class="koboSpan" id="kobo.248.2">More specifically, in this example, we manually created an object (pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">p1</span></strong><span class="koboSpan" id="kobo.250.1">) with </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">operator new</span></strong><span class="koboSpan" id="kobo.252.1"> but never manually destructed that </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">object afterward.</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">One common source of</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.255.1"> confusion for programmers unfamiliar with C++ is the distinction between pointer and pointee. </span><span class="koboSpan" id="kobo.255.2">In this program, </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">p0</span></strong><span class="koboSpan" id="kobo.257.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">p1</span></strong><span class="koboSpan" id="kobo.259.1"> are both destructed when reaching the end of their scope (by the closing brace of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">main()</span></strong><span class="koboSpan" id="kobo.261.1"> function), just as </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">xmain</span></strong><span class="koboSpan" id="kobo.263.1"> will be. </span><span class="koboSpan" id="kobo.263.2">However, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">p0</span></strong><span class="koboSpan" id="kobo.265.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">p1</span></strong><span class="koboSpan" id="kobo.267.1"> point to dynamically allocated objects, the pointees have to be explicitly destructed, something we did for </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">p0</span></strong><span class="koboSpan" id="kobo.269.1"> but (deliberately, for the sake of the example) neglected to do </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">p1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">What happens to </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">p1</span></strong><span class="koboSpan" id="kobo.275.1">’s pointee then? </span><span class="koboSpan" id="kobo.275.2">Well, it has been manually constructed and has not been manually destructed. </span><span class="koboSpan" id="kobo.275.3">As such, it floats in memory where no one can access it anymore. </span><span class="koboSpan" id="kobo.275.4">This is what people often call a memory leak: a chunk of memory your program allocated but </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">never deallocated.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Worse than leaking the storage for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">X</span></strong><span class="koboSpan" id="kobo.279.1"> object pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">p1</span></strong><span class="koboSpan" id="kobo.281.1">, however, is the fact that the pointee’s destructor will never be called, which can cause all sorts of resource leaks (files not closed, database connections not closed, system handles not released, and so on). </span><span class="koboSpan" id="kobo.281.2">In </span><a href="B21071_04.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.282.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.283.1">, </span><em class="italic"><span class="koboSpan" id="kobo.284.1">Using Destructors</span></em><span class="koboSpan" id="kobo.285.1">, we will examine how it is possible to avoid such situations and write clean, simple code at the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">same time.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.287.1">Object size, alignment, and padding</span></h2>
<p><span class="koboSpan" id="kobo.288.1">Since each object occupies</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.289.1"> storage, the space associated with an object is an</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.290.1"> important (if low-level) property of C++ types. </span><span class="koboSpan" id="kobo.290.2">For example, look at </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.291.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
class B; // forward declaration: there will be a class B
         // at some point in the future
void f(B*); // fine, we know what B is, even if we don't
            // know the details yet, and all object
            // addresses are of the same size
// class D : B {}; // oops! </span><span class="koboSpan" id="kobo.293.2">To know what a D is, we have
                   // to know how big a B is and what a
                   // B object contains since a D is a B</span></pre> <p><span class="koboSpan" id="kobo.294.1">In that example, trying to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">D</span></strong><span class="koboSpan" id="kobo.296.1"> class would not compile. </span><span class="koboSpan" id="kobo.296.2">This is because in order to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">D</span></strong><span class="koboSpan" id="kobo.298.1"> object, the compiler needs to reserve enough space for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">D</span></strong><span class="koboSpan" id="kobo.300.1"> object, but a </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">D</span></strong><span class="koboSpan" id="kobo.302.1"> object is also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">B</span></strong><span class="koboSpan" id="kobo.304.1"> object, and as such we cannot know the size of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">D</span></strong><span class="koboSpan" id="kobo.306.1"> object without knowing the size of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">The size of an object or, equivalently, of a type can be obtained through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">sizeof</span></strong><span class="koboSpan" id="kobo.311.1"> operator. </span><span class="koboSpan" id="kobo.311.2">This operator yields a compile-time, non-zero unsigned integral value corresponding to the number of bytes required to store </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">an object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
char c;
// a char occupies precisely one byte of storage, per
// standard wording
static_assert(sizeof c == 1); // for objects parentheses
                              // are not required
static_assert(sizeof(c) == 1); // ... </span><span class="koboSpan" id="kobo.313.2">but you can use them
static_assert(sizeof(char) == 1); // for types, parentheses
                                  // are required
struct Tiny {};
// all C++ types occupy non-zero bytes of storage by
// definition, even if they are "empty" like type Tiny
static_assert(sizeof(Tiny) &gt; 0);</span></pre> <p><span class="koboSpan" id="kobo.314.1">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">Tiny</span></strong><span class="koboSpan" id="kobo.316.1"> class is empty because it has no data member. </span><span class="koboSpan" id="kobo.316.2">A class could have member </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.317.1">functions and still be empty. </span><span class="koboSpan" id="kobo.317.2">Empty classes that expose member functions are very commonly used </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">in C++.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">A C++ object always occupies at least</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.320.1"> one byte of storage, even in the case of empty classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Tiny</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">That’s because if an object’s size was zero, that object could be at the same memory location as its immediate neighbor, which would be somewhat hard to </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">reason about.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">C++ differs from many other languages in that it does not standardize the size of all fundamental types. </span><span class="koboSpan" id="kobo.324.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">sizeof(int)</span></strong><span class="koboSpan" id="kobo.326.1"> can yield different values depending on the compiler and </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.327.1">platform. </span><span class="koboSpan" id="kobo.327.2">Still, there are rules concerning the size </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">of objects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.329.1">The size reported by operator </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">sizeof</span></strong><span class="koboSpan" id="kobo.331.1"> for objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">signed char</span></strong><span class="koboSpan" id="kobo.333.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">unsigned char</span></strong><span class="koboSpan" id="kobo.335.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">char</span></strong><span class="koboSpan" id="kobo.337.1"> is 1, and the same goes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">sizeof(std::byte)</span></strong><span class="koboSpan" id="kobo.339.1"> as each of these types can be used to represent a </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">single byte.</span></span></li>
<li><span class="koboSpan" id="kobo.341.1">Expressions </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">sizeof(short)&gt;=sizeof(char)</span></strong><span class="koboSpan" id="kobo.343.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">sizeof(int)&gt;=sizeof(short)</span></strong><span class="koboSpan" id="kobo.345.1"> will hold on all platforms, which means that there might be cases where </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">sizeof(char)</span></strong><span class="koboSpan" id="kobo.347.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">sizeof(int)</span></strong><span class="koboSpan" id="kobo.349.1"> are both 1. </span><span class="koboSpan" id="kobo.349.2">In terms of width (i.e., bits used in the value representation) of fundamental types, the C++ standard limits itself to stating the minimum width for each type. </span><span class="koboSpan" id="kobo.349.3">The list can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">at [</span></span><a href="http://wg21.link/tab:basic.fundamental.width"><span class="No-Break"><span class="koboSpan" id="kobo.351.1">wg21.link/tab:basic.fundamental.width</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.352.1">].</span></span></li>
<li><span class="koboSpan" id="kobo.353.1">As we have already said, expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">sizeof(T)&gt;0</span></strong><span class="koboSpan" id="kobo.355.1"> holds for any type </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">T</span></strong><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">In C++, there are no zero-sized objects, not even objects of </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">empty classes.</span></span></li>
<li><span class="koboSpan" id="kobo.359.1">The size occupied by an object of any </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">struct</span></strong><span class="koboSpan" id="kobo.361.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">class</span></strong><span class="koboSpan" id="kobo.363.1"> cannot be less than the sum of the size of its data members (but there </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">are caveats).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.365.1">This last rule deserves an explanation. </span><span class="koboSpan" id="kobo.365.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">following situation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
class X {};
class Y {
   X x;
};
int main() {
   static_assert(sizeof(X) &gt; 0);
   static_assert(sizeof(Y) == sizeof(X)); // &lt;-- here
}</span></pre> <p><span class="koboSpan" id="kobo.368.1">The line marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">&lt;-- here</span></strong><span class="koboSpan" id="kobo.370.1"> might be intriguing. </span><span class="koboSpan" id="kobo.370.2">Why would </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">sizeof(Y)</span></strong><span class="koboSpan" id="kobo.372.1"> be equal to</span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1"> sizeof(X)</span></strong><span class="koboSpan" id="kobo.374.1"> if every </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Y</span></strong><span class="koboSpan" id="kobo.376.1"> object contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">X</span></strong><span class="koboSpan" id="kobo.378.1"> object? </span><span class="koboSpan" id="kobo.378.2">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.380.1">  is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">0</span></strong><span class="koboSpan" id="kobo.382.1"> even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">X</span></strong><span class="koboSpan" id="kobo.384.1"> is an empty class because</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.385.1"> every C++ object has to occupy at least one byte of </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.386.1">storage. </span><span class="koboSpan" id="kobo.386.2">However, in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Y</span></strong><span class="koboSpan" id="kobo.388.1">, which is not an empty class, each </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Y</span></strong><span class="koboSpan" id="kobo.390.1"> object already occupies </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.391.1">storage due to its </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">x</span></strong><span class="koboSpan" id="kobo.393.1"> data member. </span><span class="koboSpan" id="kobo.393.2">There’s no reason to somewhat artificially add storage space to objects of </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">that type.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Now, </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">consider this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
class X {
   char c;
};
class Y {
   X x;
};
int main() {
   static_assert(sizeof(X) == sizeof(char)); // &lt;-- here
   static_assert(sizeof(Y) == sizeof(X)); // &lt;-- here too
}</span></pre> <p><span class="koboSpan" id="kobo.398.1">The same reasoning applies again: an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">X</span></strong><span class="koboSpan" id="kobo.400.1"> occupies the same amount of storage space as its only data member (of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">char</span></strong><span class="koboSpan" id="kobo.402.1">), and an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Y</span></strong><span class="koboSpan" id="kobo.404.1"> occupies the same amount of storage</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.405.1"> space as its only data member (of </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">X</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Continuing this exploration, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">this :</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
class X { };
class Y {
   X x;
   char c;
};
int main() {
   static_assert(sizeof(Y) &gt;= sizeof(char) + sizeof(X));
}</span></pre> <p><span class="koboSpan" id="kobo.412.1">This is the rule we </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.413.1">mentioned earlier but expressed formally for a specific type. </span><span class="koboSpan" id="kobo.413.2">In this situation, supposing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.415.1">being equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">1</span></strong><span class="koboSpan" id="kobo.417.1"> is highly probable, one </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.418.1">could even reasonably expect that </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">sizeof(Y)</span></strong><span class="koboSpan" id="kobo.420.1">would be equal to the sum of</span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">sizeof(char)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">sizeof(X)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Finally, </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">consider this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
class X { };
class Y : X { // &lt;--  private inheritance
   char c;
};
int main() {
   static_assert(sizeof(Y) == sizeof(char)); // &lt;-- here
}</span></pre> <p><span class="koboSpan" id="kobo.428.1">We moved from having an object of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">X</span></strong><span class="koboSpan" id="kobo.430.1"> being a data member of </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Y</span></strong><span class="koboSpan" id="kobo.432.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">X</span></strong><span class="koboSpan" id="kobo.434.1"> being a base class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Y</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">This has an interesting consequence: since the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">X</span></strong><span class="koboSpan" id="kobo.438.1"> is empty, and since we know from definition that objects of the derived class </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Y</span></strong><span class="koboSpan" id="kobo.440.1"> will occupy at least one byte of storage, the base class can be flattened into the derived class for </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Y</span></strong><span class="koboSpan" id="kobo.442.1"> objects. </span><span class="koboSpan" id="kobo.442.2">This is a useful optimization called the </span><strong class="bold"><span class="koboSpan" id="kobo.443.1">empty base optimization</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">You can reasonably expect compilers to perform</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.445.1"> this optimization in practice, at least in the case of single </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">inheritance relationships.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Note that since the presence of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">X</span></strong><span class="koboSpan" id="kobo.449.1"> in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Y</span></strong><span class="koboSpan" id="kobo.451.1"> is an implementation detail, not something that participates in the interface of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Y</span></strong><span class="koboSpan" id="kobo.453.1">, we used private inheritance in this example. </span><span class="koboSpan" id="kobo.453.2">The empty base optimization would apply with public or protected inheritance too, but in this case, private inheritance</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.454.1"> preserves the fact that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">X</span></strong><span class="koboSpan" id="kobo.456.1"> part of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Y</span></strong><span class="koboSpan" id="kobo.458.1"> is something that only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Y</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.460.1">knows about.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Since C++20, if you think </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.462.1">composition would be more appropriate than inheritance to describe the relation between two classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">X</span></strong><span class="koboSpan" id="kobo.464.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Y</span></strong><span class="koboSpan" id="kobo.466.1">, you can mark a data member as </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">[[no_unique_address]]</span></strong><span class="koboSpan" id="kobo.468.1"> to inform the compiler that this member, if it is an object of an empty class, does not have to occupy storage within the enclosing object. </span><span class="koboSpan" id="kobo.468.2">Compilers are not </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.469.1">forced to comply, since attributes can be ignored, so make sure to verify that your chosen compilers implement this before writing code that relies </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">on this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
class X { };
class Y {
   char c;
   [[no_unique_address]] X x;
};
int main() {
   static_assert(sizeof(X) &gt; 0);
   static_assert(sizeof(Y) == sizeof(char)); // &lt;-- here
}</span></pre> <p><span class="koboSpan" id="kobo.472.1">All of the examples so far have been very simple, using classes with zero, one, or two very small data members. </span><span class="koboSpan" id="kobo.472.2">Code is rarely so simple. </span><span class="koboSpan" id="kobo.472.3">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">following program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
class X {
   char c; // sizeof(char) == 1 by definition
   short s;
   int n;
};
int main() {
   static_assert(sizeof(short) == 2); // we suppose this...
</span><span class="koboSpan" id="kobo.474.2">   static_assert(sizeof(int) == 4);   // ... </span><span class="koboSpan" id="kobo.474.3">and this
   static_assert(
      sizeof(X) &gt;= sizeof(char)+sizeof(short)+sizeof(int)
   );
}</span></pre> <p><span class="koboSpan" id="kobo.475.1">Supposing that the first two static assertions hold, which is probable but not guaranteed, we know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.477.1"> will be at least </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">7</span></strong><span class="koboSpan" id="kobo.479.1"> (the sum of the sizes of its data members). </span><span class="koboSpan" id="kobo.479.2">In practice, however, you will </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.480.1">probably see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.482.1"> is equal to 8. </span><span class="koboSpan" id="kobo.482.2">Now, this might seem</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.483.1"> surprising at </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.484.1">first, but it’s a logical consequence of something </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.486.1">alignment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">The alignment of an object (or of its type) tells us where that object can be placed in memory. </span><span class="koboSpan" id="kobo.488.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">char</span></strong><span class="koboSpan" id="kobo.490.1"> type has an alignment of </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">1</span></strong><span class="koboSpan" id="kobo.492.1">, and as such one can place a </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">char</span></strong><span class="koboSpan" id="kobo.494.1"> object literally anywhere (as long as one can access that memory). </span><span class="koboSpan" id="kobo.494.2">For an alignment of </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">2 </span></strong><span class="koboSpan" id="kobo.496.1">(which is likely for type </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">short</span></strong><span class="koboSpan" id="kobo.498.1">), objects can only be placed at addresses that are a multiple of 2. </span><span class="koboSpan" id="kobo.498.2">More generally, if a type has an alignment of </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">n</span></strong><span class="koboSpan" id="kobo.500.1">, then objects of that type must be placed at an</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.501.1"> address that is a multiple of </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">n</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">Note that alignment has to be a strictly positive power of 2; not respecting this rule incurs undefined behavior. </span><span class="koboSpan" id="kobo.503.3">Of course, your compiler will not put you in that position, but you might put yourself in such trouble if you’re not careful, given some of the tricks we will be using in this book. </span><span class="koboSpan" id="kobo.503.4">With great control comes </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">great responsibility.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">The C++ language offers two operators related </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">to alignment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.507.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">alignof</span></strong><span class="koboSpan" id="kobo.509.1"> operator, which yields the natural alignment of a type </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">T</span></strong><span class="koboSpan" id="kobo.511.1"> or of an object of </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">that type.</span></span></li>
<li><span class="koboSpan" id="kobo.513.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">alignas</span></strong><span class="koboSpan" id="kobo.515.1"> operator, which lets programmers impose the alignment of an object. </span><span class="koboSpan" id="kobo.515.2">This is often useful when playing tricks with memory (as we will) or when interfacing with exotic </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.516.1">hardware (the term “exotic” here can be taken in a very broad sense). </span><span class="koboSpan" id="kobo.516.2">Of </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.517.1">course, </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">alignas</span></strong><span class="koboSpan" id="kobo.519.1"> can only reasonably increase the natural alignment of a type, not </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">reduce it.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.521.1">For some fundamental type </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">T</span></strong><span class="koboSpan" id="kobo.523.1">, one can expect the assertion that </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">sizeof(T)</span></strong><span class="koboSpan" id="kobo.525.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">alignof(T)</span></strong><span class="koboSpan" id="kobo.527.1"> to hold, but that assertion does not generalize to composite types. </span><span class="koboSpan" id="kobo.527.2">For example, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
class X {
   char c;
   short s;
   int n;
};
int main() {
   static_assert(sizeof(short) == alignof(short));
   static_assert(sizeof(int) == alignof(int));
   static_assert(sizeof(X) == 8); // highly probable
   static_assert(alignof(X) == alignof(int)); // likewise
}</span></pre> <p><span class="koboSpan" id="kobo.530.1">Generally speaking, for a composite type, the alignment will correspond to the worst alignment of its data </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.531.1">members. </span><span class="koboSpan" id="kobo.531.2">Here, “worst” means “biggest.” </span><span class="koboSpan" id="kobo.531.3">For class </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">X</span></strong><span class="koboSpan" id="kobo.533.1">, the worst-aligned data member is </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">n</span></strong><span class="koboSpan" id="kobo.535.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">int</span></strong><span class="koboSpan" id="kobo.537.1"> and as such, </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">X</span></strong><span class="koboSpan" id="kobo.539.1"> objects will be aligned on boundaries of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">alignof(int)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1"> bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">You might wonder now why we can expect the assertion that </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.544.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">8</span></strong><span class="koboSpan" id="kobo.546.1"> to hold if </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">sizeof(short)==2</span></strong><span class="koboSpan" id="kobo.548.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">Let’s look at the probable layout for objects of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">X</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1"> type:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.553.1"><img alt="Figure 1.1 – Compact layout of an object of type X in memory" src="image/B21071_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.554.1">Figure 1.1 – Compact layout of an object of type X in memory</span></p>
<p><span class="koboSpan" id="kobo.555.1">Each box in this figure is a byte in memory. </span><span class="koboSpan" id="kobo.555.2">As we can see, there’s a </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">?</span></strong><span class="koboSpan" id="kobo.557.1"> between </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">c</span></strong><span class="koboSpan" id="kobo.559.1"> and the first byte of </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">s</span></strong><span class="koboSpan" id="kobo.561.1">. </span><span class="koboSpan" id="kobo.561.2">That comes from alignment. </span><span class="koboSpan" id="kobo.561.3">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">alignof(short)==2</span></strong><span class="koboSpan" id="kobo.563.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">alignof(int)==4</span></strong><span class="koboSpan" id="kobo.565.1">, then the only correct layout for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">X</span></strong><span class="koboSpan" id="kobo.567.1"> object places its </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">n</span></strong><span class="koboSpan" id="kobo.569.1"> member at a boundary of </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">4</span></strong><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">This means that there will be a padding byte (a byte that does not participate in the value</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.572.1"> representation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">X</span></strong><span class="koboSpan" id="kobo.574.1">) between </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">c</span></strong><span class="koboSpan" id="kobo.576.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">s</span></strong><span class="koboSpan" id="kobo.578.1"> to align </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">s</span></strong><span class="koboSpan" id="kobo.580.1"> on a two-byte boundary and to align </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">n</span></strong><span class="koboSpan" id="kobo.582.1"> on a </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">four-byte boundary.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">What might seem more </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.585.1">surprising is that the order in which data members</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.586.1"> are laid out in a class impacts the size of the objects of that class. </span><span class="koboSpan" id="kobo.586.2">For example, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
class X {
   short s;
   int n;
   char c;
};
int main() {
   static_assert(sizeof(short) == alignof(short));
   static_assert(sizeof(int) == alignof(int));
   static_assert(alignof(X) == alignof(int));
   static_assert(sizeof(X) == 12); // highly probable
}</span></pre> <p><span class="koboSpan" id="kobo.589.1">That often surprises people, but it’s true, and something to think about. </span><span class="koboSpan" id="kobo.589.2">With this example, the probable layout for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">X</span></strong><span class="koboSpan" id="kobo.591.1"> object would be </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.593.1"><img alt="Figure 1.2 – Less compact layout for an object of type X in memory" src="image/B21071_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.594.1">Figure 1.2 – Less compact layout for an object of type X in memory</span></p>
<p><span class="koboSpan" id="kobo.595.1">By now, the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">?</span></strong><span class="koboSpan" id="kobo.597.1"> “squares” between </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">s</span></strong><span class="koboSpan" id="kobo.599.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">n</span></strong><span class="koboSpan" id="kobo.601.1"> are probably clear, but the three trailing </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">?</span></strong><span class="koboSpan" id="kobo.603.1"> “squares” might seem surprising. </span><span class="koboSpan" id="kobo.603.2">After all, why add padding at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">an object?</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">The answer is </span><em class="italic"><span class="koboSpan" id="kobo.606.1">because of arrays</span></em><span class="koboSpan" id="kobo.607.1">. </span><span class="koboSpan" id="kobo.607.2">As we will soon discuss, elements of an array are contiguous in memory, and for that reason, it is important that each element of an array is properly aligned. </span><span class="koboSpan" id="kobo.607.3">In a case such as</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.608.1"> this, the trailing padding bytes in an object of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">X</span></strong><span class="koboSpan" id="kobo.610.1"> ensure that if an element in</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.611.1"> an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">X</span></strong><span class="koboSpan" id="kobo.613.1"> objects is properly aligned, then the next element will be properly </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">aligned too.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">Now that you know about alignment, consider that just changing the order of elements from one version of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">X</span></strong><span class="koboSpan" id="kobo.617.1"> to another resulted in a memory consumption increase of 50% for each object of that type. </span><span class="koboSpan" id="kobo.617.2">That hurts your program’s memory space consumption and its speed all at once. </span><span class="koboSpan" id="kobo.617.3">C++ compilers cannot reorder your data members for you, as your code sees the addresses of objects. </span><span class="koboSpan" id="kobo.617.4">Changing the relative position of data members could break users’ code, so it’s up to programmers to be careful with their chosen layouts. </span><span class="koboSpan" id="kobo.617.5">Note that</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.618.1"> keeping objects small is not the only factor that can influence the choice of layout in an object, especially in multithreaded code (where sometimes keeping two objects at a distance from one another can lead to better cache usage), so one should remember that layout is important, but not something to take </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">on naïvely.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.620.1">Copy and movement</span></h2>
<p><span class="koboSpan" id="kobo.621.1">At this point, we need to say a few words about copy and movement, two fundamental considerations in a language such as C++ where there are </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">actual objects.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">The C++ language considers six member</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.624.1"> functions as special. </span><span class="koboSpan" id="kobo.624.2">These functions will be automatically generated for your types unless you take steps to prevent it. </span><span class="koboSpan" id="kobo.624.3">These are </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.626.1">The default constructor</span></strong><span class="koboSpan" id="kobo.627.1">: It’s probably the</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.628.1"> least special of all six, as it’s only implicitly generated if you write no constructor of </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">your own.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">The destructor</span></strong><span class="koboSpan" id="kobo.631.1">: This is called at the end of </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.632.1">an </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">object’s lifetime.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.634.1">The copy constructor</span></strong><span class="koboSpan" id="kobo.635.1">: It is called when </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.636.1">constructing an object with a single object of the same type </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">as argument.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.638.1">The copy assignment</span></strong><span class="koboSpan" id="kobo.639.1">: It is called</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.640.1"> when replacing the contents of an existing object with a copy of the contents of </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">another object.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.642.1">The move constructor</span></strong><span class="koboSpan" id="kobo.643.1">: It is called when constructing an object from a reference to an object one can </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.644.1">move from. </span><span class="koboSpan" id="kobo.644.2">Examples of movable-from objects include objects one could not refer to anymore, such as the (anonymous) result of evaluating an expression or one being returned by a function. </span><span class="koboSpan" id="kobo.644.3">The program can also explicitly make an object movable-from </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">std::move()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.648.1">The move assignment</span></strong><span class="koboSpan" id="kobo.649.1">: It behaves like  copy assignment but is applied when the argument passed to the </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.650.1">assignment operator is something one can </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">move from.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.652.1">When a type does not explicitly manage any resources on its own, one can usually write none of these special functions, as the ones generated by the compiler will be exactly what one wants. </span><span class="koboSpan" id="kobo.652.2">For example, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.654.1">
struct Point2D {
   float x{}, y{};
};</span></pre> <p><span class="koboSpan" id="kobo.655.1">Here, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">Point2D</span></strong><span class="koboSpan" id="kobo.657.1"> represents a 2D coordinate that has no invariants (all values are fine for its </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">x</span></strong><span class="koboSpan" id="kobo.659.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">y</span></strong><span class="koboSpan" id="kobo.661.1"> data members). </span><span class="koboSpan" id="kobo.661.2">Since we used default initializers for </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">x</span></strong><span class="koboSpan" id="kobo.663.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">y</span></strong><span class="koboSpan" id="kobo.665.1"> that set these data members to 0, a default </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Point2D</span></strong><span class="koboSpan" id="kobo.667.1"> object will represent coordinate </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">(0,0)</span></strong><span class="koboSpan" id="kobo.669.1"> and the six special member functions will behave as expected. </span><span class="koboSpan" id="kobo.669.2">The copy constructor will call the data members’ copy constructors, the copy assignment will call their copy assignment operators, the destructor will be trivial, and move operations will behave like copy operations since the data members are of </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">fundamental types.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">Should we decide to add a</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.672.1"> parametric constructor to explicitly let user code initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">x</span></strong><span class="koboSpan" id="kobo.674.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">y</span></strong><span class="koboSpan" id="kobo.676.1"> data members to other values than our chosen defaults, we can do so. </span><span class="koboSpan" id="kobo.676.2">However, this will cost us our implicit </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">default constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
struct Point2D {
   float x{}, y{};
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
};
void oops() {
</span><strong class="bold"><span class="koboSpan" id="kobo.679.1">   Point2D pt; // does not compile, pt has no default ctor</span></strong><span class="koboSpan" id="kobo.680.1">
}</span></pre> <p><span class="koboSpan" id="kobo.681.1">We can of course fix this. </span><span class="koboSpan" id="kobo.681.2">One way to</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.682.1"> do so is by writing the details of a default </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">constructor explicitly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
struct Point2D {
   float x, y; // no need for default initializations
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.685.1">   Point2D() : x{ }, y{ } { // &lt;-- here</span></strong><span class="koboSpan" id="kobo.686.1">
   }
};
void oops() {
   Point2D pt; // Ok
}</span></pre> <p><span class="koboSpan" id="kobo.687.1">Another approach is to delegate work from the default constructor to the </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">parametric constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
struct Point2D {
   float x, y; </span><strong class="bold"><span class="koboSpan" id="kobo.690.1">// no need for default initializations</span></strong><span class="koboSpan" id="kobo.691.1">
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.692.1">   Point2D() : Point2D{ 0, 0 } { // &lt;-- here</span></strong><span class="koboSpan" id="kobo.693.1">
   }
};
void oops() {
   Point2D pt; // Ok
}</span></pre> <p><span class="koboSpan" id="kobo.694.1">Another even better approach is to inform the compiler that we want to retain the default behavior even though we </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.695.1">did something (writing another constructor) that would otherwise </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">prevent it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.697.1">
struct Point2D {
   float x{}, y{};
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.698.1">   Point2D() = default; // &lt;-- here</span></strong><span class="koboSpan" id="kobo.699.1">
};
void oops() {
   Point2D pt; // Ok
}</span></pre> <p><span class="koboSpan" id="kobo.700.1">The latter option will usually lead to the best generated code, as compilers are really good at getting maximal results from minimal effort when they understand the programmer’s intent. </span><span class="koboSpan" id="kobo.700.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">=default</span></strong><span class="koboSpan" id="kobo.702.1"> makes the intent very explicit: </span><em class="italic"><span class="koboSpan" id="kobo.703.1">please do what you would have done normally if my code had </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.704.1">not interfered</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.706.1">A note about these constructors</span></p>
<p class="callout"><span class="koboSpan" id="kobo.707.1">We added parametric constructors to </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">Point2D</span></strong><span class="koboSpan" id="kobo.709.1"> for the sake of this example, but it’s not necessary in this case as </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">Point2D</span></strong><span class="koboSpan" id="kobo.711.1"> is an </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.712.1">aggregate. </span><span class="koboSpan" id="kobo.712.2">These types have special initialization support, but that’s beside the point for our illustration. </span><span class="koboSpan" id="kobo.712.3">Aggregate types are types that comply with several restrictions (no user-declared or inherited constructors, no private non-static data members, no virtual bases classes, and so on) and that usually have no invariants to maintain, but can be initialized very efficiently by </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">your compiler.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">When a class explicitly manages resources, the default-generated special functions rarely do what we would </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.715.1">want. </span><span class="koboSpan" id="kobo.715.2">Indeed, how could the compiler know about our intents in such a situation? </span><span class="koboSpan" id="kobo.715.3">Suppose we make a naïve </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">string</span></strong><span class="koboSpan" id="kobo.717.1">-like class of our own, starting with the following (</span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">incomplete) excerpt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
#include &lt;cstring&gt; // std::strlen()
#include &lt;algorithm&gt; // std::copy()
class naive_string { // too simple to be useful
   char *p {}; // pointer to the elements (nullptr)
   std::size_t nelems {}; // number of elements (zero)
public:
   std::size_t size() const {
      return nelems;
   }
   bool empty() const {
      return size() == 0;
   }
   naive_string() = default; // empty string
   naive_string(const char *s)
      : nelems{ std::strlen(s) } {
      p = new char[size() + 1]; // leaving room for a
                                // (convenient) trailing 0
      std::copy(s, s + size(), p);
      p[size()] = '\0';
   }
   // index-wise access to characters, const and non-const
   // versions: the const version is useful for const
   // naive_string objects, whereas the non-const version
   // lets user code modify elements
   // precondition: n &lt; size()
   char operator[](std::size_t n) const { return p[n]; }
   char&amp; operator[](std::size_t n) { return p[n]; }
   // ... </span><span class="koboSpan" id="kobo.719.2">additional code (below) goes here
};</span></pre> <p><span class="koboSpan" id="kobo.720.1">Naïve as it is, this class clearly does explicit resource allocation by allocating a chunk of </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">size()+1</span></strong><span class="koboSpan" id="kobo.722.1"> bytes to hold a copy of the sequence of characters starting at </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">p</span></strong><span class="koboSpan" id="kobo.724.1">. </span><span class="koboSpan" id="kobo.724.2">For that reason, the compiler-provided special</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.725.1"> member functions will not do the right thing for our class. </span><span class="koboSpan" id="kobo.725.2">For example, the default-generated copy constructor will copy pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">p</span></strong><span class="koboSpan" id="kobo.727.1">, but that means we will have two pointers (the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">p</span></strong><span class="koboSpan" id="kobo.729.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">p</span></strong><span class="koboSpan" id="kobo.731.1"> in the copy) sharing a common pointee, which is probably not what we want. </span><span class="koboSpan" id="kobo.731.2">The default-generated destructor will destroy the pointer, but we also want to deallocate the pointee and avoid a memory leak, and </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">In a case such as this, we want to implement the so-called rule of three and code the destructor as well as the two copy operations (the copy constructor and the copy assignment). </span><span class="koboSpan" id="kobo.733.2">Before the arrival of move semantics in C++11, that was sufficient to properly implement resource management for our types. </span><span class="koboSpan" id="kobo.733.3">It technically still is today but considering move semantics too will help us get a more efficient type in many ways. </span><span class="koboSpan" id="kobo.733.4">In contemporary code, when discussing code that implements the two move operations in addition to the rule of three, we typically speak of the rule </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">of five.</span></span></p>
<h3><span class="koboSpan" id="kobo.735.1">Destruction</span></h3>
<p><span class="koboSpan" id="kobo.736.1">As our </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">naive_string</span></strong><span class="koboSpan" id="kobo.738.1"> type does resource management with the dynamically allocated array pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">p</span></strong><span class="koboSpan" id="kobo.740.1">, the</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.741.1"> destructor for that class will be simple, as its role will be limited to deallocating the chunk of memory pointed to </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">p</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
// ...
</span><span class="koboSpan" id="kobo.745.2">   ~naive_string() {
      delete [] p;
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.746.1">Note that there is no need to check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">p</span></strong><span class="koboSpan" id="kobo.748.1"> is non-null (</span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">delete nullptr;</span></strong><span class="koboSpan" id="kobo.750.1"> does nothing in C++ and is inherently non-dangerous). </span><span class="koboSpan" id="kobo.750.2">Also note that we are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">delete[]</span></strong><span class="koboSpan" id="kobo.752.1">, not </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">delete</span></strong><span class="koboSpan" id="kobo.754.1">, as we allocated the chunk of memory with </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">new[]</span></strong><span class="koboSpan" id="kobo.756.1">, not </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">new</span></strong><span class="koboSpan" id="kobo.758.1">. </span><span class="koboSpan" id="kobo.758.2">The nuances between these </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.759.1">operations will be explained in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.760.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.761.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.762.1">Copy operations</span></h3>
<p><span class="koboSpan" id="kobo.763.1">The copy constructor is the </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.764.1">function called when constructing an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">naive_string</span></strong><span class="koboSpan" id="kobo.766.1"> class with an argument that is another object of that class. </span><span class="koboSpan" id="kobo.766.2">For </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.767.1">example, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.769.1">
// ...
</span><span class="koboSpan" id="kobo.769.2">void f(naive_string); // pass-by-value
void copy_construction_examples() {
   naive_string s0{ "What a fine day" };
   naive_string s1 = s0; // constructs s1 so this is
                         // copy construction
   naive_string s2(s0); // ...this too
   naive_string s3{ s0 }; // ...and so is this
   f(s0); // likewise because of pass-by-value
   s1 = s0; // this is not a copy construction as s1
            // already exists: this is a copy assignment
}</span></pre> <p><span class="koboSpan" id="kobo.770.1">For our </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">naive_string</span></strong><span class="koboSpan" id="kobo.772.1"> class, a </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.773.1">correct copy constructor could be written </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
// ...
</span><span class="koboSpan" id="kobo.775.2">   naive_string(const naive_string &amp;other)
      : p{ new char[other.size() + 1] },
        nelems{ other.size() } {
      std::copy(other.p, other.p + other.size(), p);
      p[size()] = '\0';
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.776.1">Copy assignments could be written in numerous ways, but many of them are complicated or just plain </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.777.1">dangerous. </span><span class="koboSpan" id="kobo.777.2">For example, consider the following example…but do not write your assignment operator </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">like this!:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.779.1">
// ...
</span><span class="koboSpan" id="kobo.779.2">   // bad copy assignment operator
   naive_string&amp; operator=(const naive_string &amp;other) {
      // first, release the memory held by *this
      delete [] p;
      // then, allocate a new chunk of memory
      p = new char[other.size() + 1]; // &lt;-- note this line
      // copy the contents themselves
      std::copy(other.p, other.p + other.size(), p);
      // adjust the size and add the trailing zero
      nelems = other.size();
      p[size()] = '\0';
      return *this;
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.780.1">Now, this might seem reasonable (if a bit long-winded), but if we look at the line where memory allocation is performed, one has to wonder: what will happen if this fails? </span><span class="koboSpan" id="kobo.780.2">Indeed it could. </span><span class="koboSpan" id="kobo.780.3">For example, it might fail if the </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.781.1">process is running low on available memory and </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">other.size()</span></strong><span class="koboSpan" id="kobo.783.1"> is too much for whatever resources are left. </span><span class="koboSpan" id="kobo.783.2">In C++, by default, allocation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">operator new</span></strong><span class="koboSpan" id="kobo.785.1"> throws an exception on failure. </span><span class="koboSpan" id="kobo.785.2">This would complete the execution of our copy assignment function, leaving </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">*this</span></strong><span class="koboSpan" id="kobo.787.1"> in an incorrect (and dangerous!) state whereby </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">p</span></strong><span class="koboSpan" id="kobo.789.1"> is non-null and </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">nelems</span></strong><span class="koboSpan" id="kobo.791.1"> is non-zero but </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">p</span></strong><span class="koboSpan" id="kobo.793.1"> points to what most would call </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.794.1">garbage: memory we do not own and whose contents would lead to undefined behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">if used.</span></span></p>
<p><span class="koboSpan" id="kobo.796.1">We could claim that we can do better and write even more code trying to fix this bug. </span><span class="koboSpan" id="kobo.796.2">The recommendation to avoid writing your copy assignment operators like this holds also in </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">this case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
// ...
</span><span class="koboSpan" id="kobo.798.2">   // another bad copy assignment operator
   naive_string&amp; operator=(const naive_string &amp;other) {
      // first, allocate a new chunk of memory
      char *q = new char[other.size() + 1];
      // then release the memory held by *this and make
      // p point to the new chunk
      delete [] p; // &lt;-- pay attention to this line
      p = q;
      // copy the contents themselves
      std::copy(other.p, other.p + other.size(), p);
      // adjust the size and add the trailing zero
      nelems = other.size();
      p[size()] = '\0';
      return *this;
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.799.1">This looks safer on the surface, as we do not try to clean up the existing state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">*this</span></strong><span class="koboSpan" id="kobo.801.1"> until we are sure that the </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.802.1">allocation has worked. </span><span class="koboSpan" id="kobo.802.2">It might even pass most of your tests – until someone crafts the </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">following test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
void test_self_assignment() {
   naive_string s0 { "This is not going to end well..." </span><span class="koboSpan" id="kobo.804.2">};
   s0 = s0; // oops!
</span><span class="koboSpan" id="kobo.804.3">}</span></pre> <p><span class="koboSpan" id="kobo.805.1">With this use case, our copy assignment will behave very badly. </span><span class="koboSpan" id="kobo.805.2">After allocating a properly sized chunk </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.806.1">of memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">q</span></strong><span class="koboSpan" id="kobo.808.1">, it will delete what </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">p</span></strong><span class="koboSpan" id="kobo.810.1"> points to. </span><span class="koboSpan" id="kobo.810.2">Unfortunately, this also happens to be what </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">other.p</span></strong><span class="koboSpan" id="kobo.812.1"> points to, destroying the actual source data we are aiming to copy from. </span><span class="koboSpan" id="kobo.812.2">What follows that step reads from memory we do not own anymore, and the program stops </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">making sense.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">We can still try to patch this, and even make it work, </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">but beware:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
// ...
</span><span class="koboSpan" id="kobo.816.2">   // this works, but it's getting complicated and
   // is a sign we're doing something wrong
   naive_string&amp; operator=(const naive_string &amp;other) {
      // prevent self-assignment
      if(this == &amp;other) return *this;
      // then, do that sequence of steps
      char *q = new char[other.size() + 1];
      delete [] p; // &lt;-- pay attention to this line
      p = q;
      std::copy(other.p, other.p + other.size(), p);
      nelems = other.size();
      p[size()] = '\0';
      return *this;
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.817.1">This fix is a pessimization, since we will be making every copy assignment call pay for that </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">if</span></strong><span class="koboSpan" id="kobo.819.1"> branch that, in</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.820.1"> practice, should almost never be used. </span><span class="koboSpan" id="kobo.820.2">Brute-force problem-solving led us to complicated </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.821.1">code that works (though it’s not necessarily self-evident) and that will need to be reconsidered with every resource-managing class </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">we write.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.823.1">About the word pessimization</span></p>
<p class="callout"><span class="koboSpan" id="kobo.824.1">The word </span><em class="italic"><span class="koboSpan" id="kobo.825.1">pessimization</span></em><span class="koboSpan" id="kobo.826.1"> is generally used as the opposite of </span><em class="italic"><span class="koboSpan" id="kobo.827.1">optimization</span></em><span class="koboSpan" id="kobo.828.1">, referring to a programming maneuver or technique</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.829.1"> that makes program behavior less efficient than it </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.830.1">should be. </span><span class="koboSpan" id="kobo.830.2">The preceding case is a well-known example of such a maneuver: everyone will pay for the potential branch introduced by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">if</span></strong><span class="koboSpan" id="kobo.832.1"> statement even though it’s only required for rare and degenerate cases – things that should </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">not happen.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.834.1">When faced with a “pessimization” opportunity, it’s often worth it to take a step back and reconsider. </span><span class="koboSpan" id="kobo.834.2">Maybe we’ve been taking the wrong angle when approaching </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the problem.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">Luckily, there is a well-known idiom in C++ called the </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">safe assignment idiom</span></strong><span class="koboSpan" id="kobo.838.1">, colloquially known as copy-and-swap. </span><span class="koboSpan" id="kobo.838.2">The trick is to recognize that the assignment is made of two parts: a destructive part that </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.839.1">cleans up the existing state owned by the destination object (the left side of the assignment) and a constructive part that copies the state from a source object (right side of the assignment) to the destination object. </span><span class="koboSpan" id="kobo.839.2">The destructive part is generally equivalent to the code found in the type’s destructor, and the constructive part is generally equivalent to the code found in the type’s </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">copy constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.841.1">The informal copy-and-swap name for that technique comes from the fact that it is usually implemented through a </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.842.1">combination of the type’s copy constructor, its destructor, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">swap()</span></strong><span class="koboSpan" id="kobo.844.1"> member function that swaps member variables one </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">by one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.846.1">
// ...
</span><span class="koboSpan" id="kobo.846.2">   void swap(naive_string &amp;other) noexcept {
      using std::swap; // make the standard swap function
                       // available
      swap(p, other.p); // swap data members
      swap(nelems, other.nelems);
   }
   // idiomatic copy assignment
   naive_string&amp; operator=(const naive_string &amp;other) {
      naive_string { other }.swap(*this); // &lt;-- here
      return *this; // yes, that's it!
</span><span class="koboSpan" id="kobo.846.3">   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.847.1">That idiom is extremely useful to know and use as it’s exception-safe, simple, and works for almost all types. </span><span class="koboSpan" id="kobo.847.2">The line that does all the work performs </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">three steps:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.849.1">First, it constructs an anonymous copy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">other</span></strong><span class="koboSpan" id="kobo.851.1"> using that type’s copy constructor. </span><span class="koboSpan" id="kobo.851.2">Now, that might fail if an exception is thrown, but if it does, </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">*this</span></strong><span class="koboSpan" id="kobo.853.1"> has not been modified and thus </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">remains uncorrupted.</span></span></li>
<li><span class="koboSpan" id="kobo.855.1">Second, it swaps that anonymous temporary’s contents (holding what we want to put in </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">*this</span></strong><span class="koboSpan" id="kobo.857.1">) with the destination object’s contents (putting the now-unneeded state in that</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.858.1"> anonymous </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">temporary object).</span></span></li>
<li><span class="koboSpan" id="kobo.860.1">Finally, the anonymous temporary object is destroyed at the end of the expression (being anonymous), leaving </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">*this</span></strong><span class="koboSpan" id="kobo.862.1"> holding a copy of the state </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">other</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.866.1">This idiom even works safely for self-assignment. </span><span class="koboSpan" id="kobo.866.2">It incurs an unneeded copy, but it trades an </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">if</span></strong><span class="koboSpan" id="kobo.868.1"> branch that every call would have paid but almost none would have benefitted from for a copy that will rarely </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">be useless.</span></span></p>
<p><span class="koboSpan" id="kobo.870.1">You might notice </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">noexcept</span></strong><span class="koboSpan" id="kobo.872.1"> preceding the opening brace of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">swap()</span></strong><span class="koboSpan" id="kobo.874.1"> member function. </span><span class="koboSpan" id="kobo.874.2">We will return to this</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.875.1"> later, but for now, the important point is that we can claim that this function (swapping objects of fundamental types as it does) will never throw an exception. </span><span class="koboSpan" id="kobo.875.2">This information will help us achieve some precious optimizations later in </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">this book.</span></span></p>
<h3><span class="koboSpan" id="kobo.877.1">Move operations</span></h3>
<p><span class="koboSpan" id="kobo.878.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">naive_string</span></strong><span class="koboSpan" id="kobo.880.1">, which is augmented by its destructor, copy constructor, and copy assignment member functions, now </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.881.1">manages resources appropriately. </span><span class="koboSpan" id="kobo.881.2">It </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.882.1">could, however, be made faster, and sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">even safer.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">Consider the following non-member string concatenation operator that someone could want to add to complement </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">our class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.886.1">
// returns the concatenation of s0 and s1
naive_string operator+(naive_string s0, naive_string s1);</span></pre> <p><span class="koboSpan" id="kobo.887.1">An operation like this could be used in user code such as </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.889.1">
naive_string make_message(naive_string name) {
   naive_string s0{ "Hello "},
                s1{ "!" </span><span class="koboSpan" id="kobo.889.2">};
   return s0 + name + s1; // &lt;-- note this line
}</span></pre> <p><span class="koboSpan" id="kobo.890.1">The expression that follows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">return</span></strong><span class="koboSpan" id="kobo.892.1"> statement first performs a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">operator+()</span></strong><span class="koboSpan" id="kobo.894.1"> and creates an unnamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">naive_string</span></strong><span class="koboSpan" id="kobo.896.1"> object from the concatenation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">s0</span></strong><span class="koboSpan" id="kobo.898.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">name</span></strong><span class="koboSpan" id="kobo.900.1">. </span><span class="koboSpan" id="kobo.900.2">Then, that unnamed object is passed as the first argument to another call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">operator+()</span></strong><span class="koboSpan" id="kobo.902.1"> that yields another unnamed object created from the concatenation of the first unnamed object and </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">s1</span></strong><span class="koboSpan" id="kobo.904.1">. </span><span class="koboSpan" id="kobo.904.2">With our current implementation, each unnamed object incurs an allocation, a copy of the data held in its buffer, a destruction, and more. </span><span class="koboSpan" id="kobo.904.3">It’s more costly than it looks at first glance and is made even worse by the fact that each allocation could throw </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.906.1">Still, </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">it works.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">Since C++11, we can make such code significantly more efficient through move semantics. </span><span class="koboSpan" id="kobo.908.2">In addition to </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.909.1">the traditional rule of three functions we just discussed, one can augment a class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">naive_string</span></strong><span class="koboSpan" id="kobo.911.1"> with a move constructor and a move assignment operator. </span><span class="koboSpan" id="kobo.911.2">These will kick in implicitly when the compiler operates on objects it knows will not be used anymore. </span><span class="koboSpan" id="kobo.911.3">Consider </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
// ...
</span><span class="koboSpan" id="kobo.913.2">   return s0 + name + s1;
// ...</span></pre> <p><span class="koboSpan" id="kobo.914.1">This translates to </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.916.1">
// ...
</span><span class="koboSpan" id="kobo.916.2">   return (s0 + name) + s1;
//         ^^^^^^^^^^^ &lt;-- anonymous object (we cannot
/                          refer to it afterward)
// ...</span></pre> <p><span class="koboSpan" id="kobo.917.1">It then translates to </span><a id="_idIndexMarker088"/><span class="No-Break"><span class="koboSpan" id="kobo.918.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.919.1">
// ...
</span><span class="koboSpan" id="kobo.919.2">   ((s0 + name) + s1);
// ^^^^^^^^^^^^^^^^^^^ &lt;-- anonymous object (idem)
// ...</span></pre> <p><span class="koboSpan" id="kobo.920.1">When one thinks about it, the reason for copy operations is to keep the source object intact in case we need it later. </span><span class="koboSpan" id="kobo.920.2">Temporary objects that have no name do not need to be preserved from further modifications as they cannot be referred to later. </span><span class="koboSpan" id="kobo.920.3">For that reason, we can be more aggressive with these and essentially move their contents instead of copying them. </span><span class="koboSpan" id="kobo.920.4">The rule we are asked to follow by the standard is to leave the moved-from object in a valid-yet-indeterminate state. </span><span class="koboSpan" id="kobo.920.5">Essentially, the moved-from object has to be in such a</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.921.1"> state that it can be safely destroyed or assigned to, and its invariants should still hold. </span><span class="koboSpan" id="kobo.921.2">In practice, that often amounts to leaving the moved-from object in something equivalent to its </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">default state.</span></span></p>
<p><span class="koboSpan" id="kobo.923.1">For our </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">naive_string</span></strong><span class="koboSpan" id="kobo.925.1"> type, a move constructor could look </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.927.1">
// ...
</span><span class="koboSpan" id="kobo.927.2">   naive_string(naive_string &amp;&amp;other) noexcept
      : p{ std::move(other.p) },
        nelems{ std::move(other.nelems) } {
      other.p = nullptr;
      other.nelems = 0;
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.928.1">The calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">std::move()</span></strong><span class="koboSpan" id="kobo.930.1"> in this specific case could be avoided (moving objects of fundamental types is equivalent to copying them), but it’s probably more hygienic to make sure that the intent to move those objects is inscribed explicitly in the source code. </span><span class="koboSpan" id="kobo.930.2">We’ll look cursorily at </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">std::move()</span></strong><span class="koboSpan" id="kobo.932.1"> later in this section, but the important thing to remember is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">std::move()</span></strong><span class="koboSpan" id="kobo.934.1"> does not move anything. </span><span class="koboSpan" id="kobo.934.2">It marks an object as movable in the eyes of the compiler. </span><span class="koboSpan" id="kobo.934.3">In other words, </span><em class="italic"><span class="koboSpan" id="kobo.935.1">it’s </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.936.1">a cast</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">The important things to note with our move constructor are </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.940.1">The argument is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">naive_string&amp;&amp;</span></strong><span class="koboSpan" id="kobo.942.1">. </span><span class="koboSpan" id="kobo.942.2">This means it is a reference to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">rvalue</span></strong><span class="koboSpan" id="kobo.944.1">, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">rvalue</span></strong><span class="koboSpan" id="kobo.946.1"> itself informally meaning “something one could find on the right side of an </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">assignment operator.”</span></span></li>
<li><span class="koboSpan" id="kobo.948.1">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">swap()</span></strong><span class="koboSpan" id="kobo.950.1">, it is marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">noexcept</span></strong><span class="koboSpan" id="kobo.952.1"> to express the fact that no exception will be thrown during </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">its execution.</span></span></li>
<li><span class="koboSpan" id="kobo.954.1">It’s effectively transferring state from the source object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">other</span></strong><span class="koboSpan" id="kobo.956.1">, to the object under construction, </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">*this</span></strong><span class="koboSpan" id="kobo.958.1">. </span><span class="koboSpan" id="kobo.958.2">After the completion of this transfer, we leave </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">other</span></strong><span class="koboSpan" id="kobo.960.1"> in a valid state (equivalent to what we would have with a default </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">naive_string</span></strong><span class="koboSpan" id="kobo.962.1"> object), respecting the </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">standard’s recommendation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.964.1">One could write this function in </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.965.1">a slightly terser manner with a small but quite useful function found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">&lt;utility&gt;</span></strong><span class="koboSpan" id="kobo.967.1"> header and named </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">std::exchange()</span></strong><span class="koboSpan" id="kobo.969.1">. </span><span class="koboSpan" id="kobo.969.2">Indeed, consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">following expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.971.1">
a = std::exchange(b, c);</span></pre> <p><span class="koboSpan" id="kobo.972.1">This expression means “assign to </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">a</span></strong><span class="koboSpan" id="kobo.974.1"> the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">b</span></strong><span class="koboSpan" id="kobo.976.1"> but replace the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">b</span></strong><span class="koboSpan" id="kobo.978.1"> with the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">c</span></strong><span class="koboSpan" id="kobo.980.1">.” </span><span class="koboSpan" id="kobo.980.2">This is a</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.981.1"> very common sequence of operations in real code. </span><span class="koboSpan" id="kobo.981.2">With this function, our move constructor becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
// ...
</span><span class="koboSpan" id="kobo.983.2">   naive_string(naive_string &amp;&amp;other) noexcept
      : p{ std::exchange(other.p, nullptr) },
        nelems{ std::exchange(other.nelems, 0) } {
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.984.1">That form is idiomatic C++ and can lead to some interesting optimizations in </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">some circumstances.</span></span></p>
<p><span class="koboSpan" id="kobo.986.1">What about the move assignment? </span><span class="koboSpan" id="kobo.986.2">Well, we can take note of the idiomatic copy assignment we discussed at some length earlier and express it </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.988.1">
   // idiomatic copy assignment
   naive_string&amp; operator=(naive_string &amp;&amp;other) noexcept {
      naive_string { std::move(other) }.swap(*this);
      return *this;
   }</span></pre> <p><span class="koboSpan" id="kobo.989.1">Following the path set by </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.990.1">our copy assignment operator, we expressed the move assignment operator as a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">swap()</span></strong><span class="koboSpan" id="kobo.992.1">, a destructor, and a move constructor. </span><span class="koboSpan" id="kobo.992.2">The general logic behind both idioms is </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">the same.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.994.1">Arrays</span></h1>
<p><span class="koboSpan" id="kobo.995.1">We have used arrays in our preceding examples, but we have not really provided a formal definition for that </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.996.1">useful-yet-low-level construct. </span><span class="koboSpan" id="kobo.996.2">Note that in this section, the term “array” refers to raw, built-in arrays, not to other very useful but higher-level constructs such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">std::vector&lt;T&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.998.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">std::array&lt;T,N&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">Quite simply, in C++, an array is a contiguous sequence of elements of the same type. </span><span class="koboSpan" id="kobo.1001.2">Thus, in the following excerpt, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">a0</span></strong><span class="koboSpan" id="kobo.1003.1"> object occupies </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">10*sizeof(int)</span></strong><span class="koboSpan" id="kobo.1005.1"> bytes in memory, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">a1</span></strong><span class="koboSpan" id="kobo.1007.1"> object occupies </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">20*sizeof(std::string)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1"> bytes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1010.1">
int a0[10];
std::string a1[20];</span></pre> <p><span class="koboSpan" id="kobo.1011.1">The number of bytes between elements at indices </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">i</span></strong><span class="koboSpan" id="kobo.1013.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">i+1</span></strong><span class="koboSpan" id="kobo.1015.1"> in an array of some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">T</span></strong><span class="koboSpan" id="kobo.1017.1"> is precisely equal </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">sizeof(T)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1021.1">Consider the following expression, which would be used in C++, as in C, for some </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">array </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">arr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1025.1">
arr[i]</span></pre> <p><span class="koboSpan" id="kobo.1026.1">It evaluates to the same address as </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
*(arr + i)</span></pre> <p><span class="koboSpan" id="kobo.1029.1">Since pointer arithmetic is typed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">+ i</span></strong><span class="koboSpan" id="kobo.1031.1"> part in this expression means “plus </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">i</span></strong><span class="koboSpan" id="kobo.1033.1"> elements” or “plus </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">i</span></strong><span class="koboSpan" id="kobo.1035.1"> times the size of an element </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">in bytes.”</span></span></p>
<p><span class="koboSpan" id="kobo.1037.1">Array sizes are positive but cannot be 0 unless the array is </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">dynamically allocated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1039.1">
int a0[5]; // Ok
static_assert(sizeof a0 == 5 * sizeof(int));
enum { N = sizeof a0 / sizeof a0[0] }; // N == 5
// int a1[0]; // not allowed: the array would be at the
              // same address as the next object in memory!
</span><span class="koboSpan" id="kobo.1039.2">int *p0 = new int[5]; // Ok, but you have to manage the
                      // pointee now
int *p1 = new int[0]; // Ok, dynamically allocated; you
                      // still have to manage the pointee
// ...
</span><span class="koboSpan" id="kobo.1039.3">delete [] p1; // good
delete [] p0; // good; be responsible</span></pre> <p><span class="koboSpan" id="kobo.1040.1">Each call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">operator new[]</span></strong><span class="koboSpan" id="kobo.1042.1"> has to yield a different address, even if the array’s size is 0. </span><span class="koboSpan" id="kobo.1042.2">Each call </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.1043.1">technically returns the address of a </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">different object.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.1045.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1046.1">In this chapter, we took a look at fundamental ideas of the C++ language such as: what is an object? </span><span class="koboSpan" id="kobo.1046.2">What are pointers and references? </span><span class="koboSpan" id="kobo.1046.3">What do we mean when we talk about the size and alignment of an object or of a type? </span><span class="koboSpan" id="kobo.1046.4">Why are there no zero-size objects in C++? </span><span class="koboSpan" id="kobo.1046.5">What are the special members of a class and when do we need to write them explicitly? </span><span class="koboSpan" id="kobo.1046.6">This non-exhaustive list of topics gave us a common vocabulary from which to build what you, dear reader, will find in the chapters </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">to come.</span></span></p>
<p><span class="koboSpan" id="kobo.1048.1">With this, we are ready to get our hands dirty, so to speak. </span><span class="koboSpan" id="kobo.1048.2">We have given ourselves a set of low-level tools and ideas from which to build higher-level abstractions, but we have to give ourselves some measure </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">of discipline.</span></span></p>
<p><span class="koboSpan" id="kobo.1050.1">The next chapter will discuss some things we need to avoid. </span><span class="koboSpan" id="kobo.1050.2">Those include undefined behavior, implementation-defined behavior (to a lesser extent), ill-formed no-diagnostic-required code, buffer overflows, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">unrecommendable behaviors.</span></span></p>
<p><span class="koboSpan" id="kobo.1052.1">Then, we will follow with a chapter describing C++ casts, and how they can help us express clear ideas even when we feel the need to eschew some of the rules set out for us by the language’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">type system.</span></span></p>
<p><span class="koboSpan" id="kobo.1054.1">After that, we will start to build beautiful and powerful abstractions that will help us with our stated goal of safely and efficiently managing resources in general and managing memory </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">in particular.</span></span></p>
</div>
</body></html>