<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Objects, Pointers, and References</h1>
<p>Before we start discussing memory management in C++, let’s make sure we understand each other and agree on a common vocabulary. If you’re a long-time C++ programmer, you probably have your own ideas about what pointers, objects, and references are. Your ideas will stem from a wealth of experience. If you are coming to this book from another language, you might also have your own ideas as to what these terms mean in C++ and how they relate to memory and memory management.</p>
<p>In this chapter, we are going to make sure we have a common understanding of some basic (but profound) ideas so that we can build on this shared understanding for the rest of our adventure together. Specifically, we will explore questions such as the following:</p>
<ul>
<li>How is memory represented in C++? What exactly is that thing we call memory, at least in the context of the C++ language?</li>
<li>What are objects, pointers, and references? What do we mean by those terms in C++? What are the lifetime rules of objects? How do they relate to memory?</li>
<li>What are arrays in C++? In this language, arrays are a low-level but highly efficient construct represented in a way that directly impacts memory management.</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>This book assumes that readers have some basic knowledge of C++ or of syntactically similar languages such as C, Java, C#, or JavaScript. For this reason, we will not explain the basics of variable declarations, loops, <code>if</code> statements, or functions.</p>
<p>We will, however, use some aspects of the C++ language in this chapter that some readers might be less comfortable with. Please refer to <a href="B21071_16.xhtml#_idTextAnchor221"><em class="italic">Annexure</em></a><em class="italic">:</em> <em class="italic">Things You Should Know</em>, before reading this book.</p>
<p>Some of the examples use C++20 or C++23, so make sure that your compiler supports this version of the standard to get the most out of them.</p>
<p>The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1</a>.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Representation of memory in C++</h1>
<p>This is a book on memory management. You, readers, are trying to figure out what it means, and I, as the author, am trying to convey what it means.</p>
<p>The way in which the standard describes memory can be seen in [<a href="http://wg21.link/basic.memobj">wg21.link/basic.memobj</a>]. Essentially, memory in C++ is expressed as one or more sequences of contiguous bytes. This opens up the possibility of memory expressed as a set of discontinuous blocks of contiguous memory because, historically, C++ has supported memories made of various distinct segments. Every byte in a C++ program has a unique address.</p>
<p>Memory in a C++ program is <a id="_idIndexMarker000"/>populated with various entities such as objects, functions, references, and so on. Managing memory efficiently requires grasping what these entities mean and how programs can make use of them.</p>
<p>The meaning of the word byte is important in C++. As detailed in [<a href="http://wg21.link/intro.memory">wg21.link/intro.memory</a>], bytes are the fundamental storage unit in C++. The number of bits in a byte is implementation-defined in C++. The standard does state, however, that a byte has to be wide enough to contain both the ordinary literal encoding of any element of the basic literal character set and the eight-bit code units of the UTF-8 encoding form. It also states that a byte is made of a contiguous sequence of bits.</p>
<p>What often surprises people is that in C++, a byte is not necessarily an octet: a byte consists of at least eight bits but could be made of more (something that’s useful on some exotic hardware). This might change in the future, as the standard committee might constrain that definition someday, but this is the situation at the time of the publication of this book. The key idea here is that a byte is the smallest addressable unit of memory in a program.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Objects, pointers, and references</h2>
<p>We tend to use words such as object, pointer, and reference informally, without thinking too much about what they mean. In a language such as C++, these words have precise meanings that define and delimit what we can do in practice.</p>
<p>Before we get our hands dirty, so to speak, let’s examine the formal meaning of these terms in C++.</p>
<h3>Objects</h3>
<p>If we polled programmers working with different languages and asked them how they would define the term object, we could probably expect such answers as “something that groups together <a id="_idIndexMarker001"/>variables and related functions” or “an instance of a class,” which correspond to traditional takes on that term from the realm of object-oriented programming.</p>
<p>C++ as a language tries to provide homogeneous support for user-defined types such as structs or classes. It also provides support for fundamental types such as <code>int</code> or <code>float</code>. Thus, it probably should not <a id="_idIndexMarker002"/>be surprising that, for C++, the definition of an object is expressed in terms of its properties, not in terms of what the word means, and that this definition includes the most fundamental types. The definition of an object in C++ is described in [<a href="http://wg21.link/intro.object">wg21.link/intro.object</a>] and takes the following factors into account:</p>
<ul>
<li>How the object is created explicitly, such as when defining the object or constructing it through one of the many variations of <code>operator new</code>. The object may also be created implicitly such as when creating a temporary object as the result of some expression or when changing the active member of a <code>union</code>.</li>
<li>The fact that an object is somewhere (it has an address) and occupies a region of storage of non-zero size, from the start of its construction to the end of its destruction.</li>
<li>Other properties of an object, including its name (if it has one), its type, and its storage duration (<code>automatic</code>, <code>static</code>, <code>thread_local</code>, and so on.).</li>
</ul>
<p>The C++ standard explicitly calls out functions as not being objects, even if a function has an address and occupies storage.</p>
<p>From this, we can infer that even a humble <code>int</code> is an object, but a function is not. You can see already, dear reader, that the book you’re reading will touch on fundamental topics, since lifetime and the storage occupied by objects are part of the fundamental properties of these entities we use in our programs every day. Such things as lifetime and storage are <a id="_idIndexMarker003"/>clearly part of what memory management is about. You can convince yourself of that fact with this<a id="_idIndexMarker004"/> simple program:</p>
<pre class="source-code">
#include &lt;type_traits&gt;
int main() {
   static_assert(std::is_object_v&lt;int&gt;);
   static_assert(!std::is_object_v&lt;decltype(main)&gt;);
}</pre> <p>What is an object? It’s something that has a lifetime and occupies storage. Controlling these characteristics is part of the reasons why this book exists.</p>
<h3>Pointers</h3>
<p>There are numerous (around 2,000) mentions of the word “pointer” in the text of the C++ standard, but if <a id="_idIndexMarker005"/>you open an electronic copy of that document and search through it, you’ll find that a formal <a id="_idIndexMarker006"/>definition is surprisingly hard to come by. This can be surprising given the fact that people tend to associate that idea with C and (by extension) C++.</p>
<p>Let us try to offer a useful yet informal definition, then: a pointer is a typed address. It associates a type with what is found at some location in memory. For that reason, in code like the following, one reads that <code>n</code> is an <code>int</code> object and that <code>p</code> points to an <code>int</code> object that happens to be the address of the <code>n</code> object:</p>
<pre class="source-code">
int n = 3; // n is an int object
char c;
// int *p = &amp;c; // no, illegal
int *p = &amp;n;</pre> <p>It’s important to understand here that <code>p</code> indeed points to an <code>int</code>, unless <code>p</code> is left uninitialized, <code>p</code> points to <code>nullptr</code>, or programmers have played tricks with the type system and made <code>p</code> point to something else deliberately. Of course, pointer <code>p</code> is an object, as it respects all the rules to that effect.</p>
<p>Much of the (syntactic) confusion about pointers probably comes from the contextual meaning of the <code>*</code> and <code>&amp;</code> symbols. The<a id="_idIndexMarker007"/> trick is to remember that they have different roles when they appear in the introduction of a name and when they<a id="_idIndexMarker008"/> are used on an existing object:</p>
<pre class="source-code">
int m = 4, n = 3;
int *p; // p declares (and defines) a pointer to an int
        // (currently uninitialized), introducing a name
p = 0; // p is a null pointer (it does not necessarily
       // point to address zero; 0 as used here is
       // just a convention)
p = nullptr; // likewise, but clearer. Prefer nullptr to
             // literal 0 whenever possible to describe
             // a null pointer
p = &amp;m; // p points to m (p contains the address of m)
assert(*p == 4); // p already exists; with *p we are
                 // accessing what p points to
p = &amp;n; // p now points to n (p contains the address of n)
int *q = &amp;n; // q declares (and defines) a pointer to an
             // int and &amp;n represents the address of n, the
             // address of an int: q is a pointer to an int
assert(*q == 3); // n holds 3 at this stage, and q points
                 // to n, so what q points to has value 3
assert(*p == 3); // the same holds for p
assert(p == q); // p and q point to the same int object
*q = 4; // q already exists, so *q means "whatever q
        // points to"
assert(n == 4); // indeed, n now holds value 4 since we
                // modified it indirectly through q
auto qq = &amp;q;   // qq is the address of q, and its type is
                // "pointer to a pointer to an int", thus
                // int **... But we will rarely – if ever –
                // need this
int &amp;r = n; // declaration of r as a reference to integer n
            // (see below). Note that &amp; is used in a
            // declaration in this case</pre> <p>As you can see, when introducing an object, <code>*</code> means “pointer to.” On an existing object, it means “what that pointer <a id="_idIndexMarker009"/>points to” (the pointee). Similarly, when introducing a name, <code>&amp;</code> means “reference to” (something we will discuss imminently). On an existing object, it means “address of” and yields a pointer.</p>
<p>Pointers allow us to <a id="_idIndexMarker010"/>do arithmetic, but that’s (legitimately) seen as a dangerous operation, as it can take us to arbitrary locations in a program and can therefore lead to serious damage. Arithmetic on a pointer depends on its type:</p>
<pre class="source-code">
int *f();
char *g();
int danger() {
   auto p = f(); // p points to whatever f() returned
   int *q = p + 3; // q points to where p points to plus
                   // three times the size of an int. No
                   // clue where this is, but it's a bad,
                   // bad idea...
   auto pc = g(); // pc points to whatever g() returned
   char * qc = pc + 3; // qc points to where pc points
                       // to plus three times the size
                       // of a char. Please don't make
                       // your pointers go to places you
                       // don't know about like this
}</pre> <p>Of course, accessing the contents of arbitrary addresses is just asking for trouble. This is because it would mean invoking undefined behavior (described in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a>), and if you do that, you’re on your <a id="_idIndexMarker011"/>own. Please do not do such things in real code, as you could hurt programs – or worse, people. C++ is powerful and flexible, but if <a id="_idIndexMarker012"/>you program in C++, you’re expected to behave responsibly and professionally.</p>
<p>C++ has four special types for pointer manipulation:</p>
<ul>
<li><code>void*</code> means “address <a id="_idIndexMarker013"/>with no specific (type-related) semantics.” A <code>void*</code> is an address with no associated type. All pointers (if we discount the <code>const</code> and <code>volatile</code> qualifiers) are implicitly convertible to <code>void*</code>; an informal way to read this is as “all pointers, regardless of type, really are addresses.” The converse does not hold. For example, it’s not true that all addresses are implicitly convertible to <code>int</code> pointers.</li>
<li><code>char*</code> means “pointer to a byte.” Due to the C language roots of C++, a <code>char*</code> can alias any address in memory (the <code>char</code> type, regardless of its name, which evocates “character”, really means “byte” in C and, by extension, in C++). There is an ongoing effort in C++ to give <code>char</code> the meaning of “character,” but as of this writing, a <code>char*</code> can alias pretty much anything in a program. This hampers some compiler optimization opportunities (it is hard to constrain or reason about something that can lead to literally anything in memory).</li>
<li><code>std::byte*</code> is the new “pointer to a byte,” at least since C++17. The (long-term) intent of <code>byte*</code> is to replace <code>char*</code> in those functions that do byte-per-byte manipulation or addressing, but since there’s so much code that uses <code>char*</code> to that effect, this will take time.</li>
</ul>
<p>For an example of<a id="_idIndexMarker014"/> conversion from and to <code>void*</code>, consider the following:</p>
<pre class="source-code">
int n = 3;
int *p = &amp;n; // fine so far
void *pv = p; // Ok, a pointer is an address
// p = pv; // no, a void* does not necessarily point to
           // an int (Ok in C, not in C++)
p = static_cast&lt;int *&gt;(pv); // fine, you asked for it, but
                            // if you're wrong you're on
                            // your own</pre> <p>The following example, which is<a id="_idIndexMarker015"/> somewhat more elaborate, uses <code>const char*</code> (but could use <code>const byte*</code> instead). It shows that one can compare the byte-per-byte representation of two objects, at least in some circumstances, to see whether they are equivalent:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
using namespace std;
bool same_bytes(const char *p0, const char *p1,
                std::size_t n) {
    for(std::size_t i = 0; i != n; ++i)
        if(*(p0 + i) != *(p1 + i))
            return false;
    return true;
}
template &lt;class T, class U&gt;
   bool same_bytes(const T &amp;a, const U &amp;b) {
      using namespace std;
       static_assert(sizeof a == sizeof b);
       static_assert(has_unique_object_representations_v&lt;
          T
       &gt;);
       static_assert(has_unique_object_representations_v&lt;
          U
       &gt;);
       return same_bytes(reinterpret_cast&lt;const char*&gt;(&amp;a),
                         reinterpret_cast&lt;const char*&gt;(&amp;b),
                         sizeof a);
   }
struct X {
   int x {2}, y{3};
};
struct Y {
   int x {2}, y{3};
};
#include &lt;cassert&gt;
int main() {
    constexpr X x;
    constexpr Y y;
    assert(same_bytes(x, y));
}</pre> <p>The <code>has_unique_object_representations</code> trait is true for types uniquely defined by their values, that is, types exempt of padding bits.. That’s sometimes important as C++ does not say what happens to padding bits in an object, and performing a bit-per-bit comparison of two objects might yield surprising results. Note that objects of floating<a id="_idIndexMarker016"/> point types are not considered uniquely defined by their values as there are many distinct values that qualify as NaN, or “not a number”.</p>
<h3>References</h3>
<p>The C++ language supports two related families of indirections: pointers and references. Like their cousins, the pointers, references<a id="_idIndexMarker017"/> are often mentioned by the C++ standard (more than 1,800 times) but it’s hard to find a formal definition for them.</p>
<p>We will try once again to provide an informal <a id="_idIndexMarker018"/>but operational definition: a reference can be seen as an alias for an existing entity. We deliberately did not use object, since one could refer to a function and we already know that a function is not an object.</p>
<p>Pointers are objects. As such, they occupy storage. References, on the other hand, are not objects and use no storage of their own, even though an implementation could simulate their existence with pointers. Compare <code>std::is_object_v&lt;int*&gt;</code> with <code>std::is_object_v&lt;int&amp;&gt;</code>: the former is <code>true</code>, and the latter is <code>false</code>.</p>
<p>The <code>sizeof</code> operator, applied to a<a id="_idIndexMarker019"/> reference, will yield the size of what it refers to. Consequently, taking the address of a reference yields the address of what it refers to.</p>
<p>In C++, a reference is always bound to an object and remains bound to that object until the end of the reference’s lifetime. A pointer, on the other hand, can point to numerous distinct objects during its lifetime, as we have seen before:</p>
<pre class="source-code">
// int &amp;nope; // would not compile (what would nope
              // refer to?)
int n = 3;
int &amp;r = n; // r refers to n
++r; // n becomes 4
assert(&amp;r == &amp;n); // taking the address of r means taking
                  // the address of n</pre> <p>Another difference between pointers and references is that, contrary to the situation that prevails with pointers, there is no such thing as reference arithmetic. This makes references somewhat safer than pointers. There is room for both kinds of indirections in a program (and we will use<a id="_idIndexMarker020"/> them both in this book!), but for everyday programming, a good rule of thumb is to use references if possible and to use pointers if necessary.</p>
<p>Now that we have<a id="_idIndexMarker021"/> examined the representation of memory and taken a look at how C++ defines some fundamental ideas such as a byte, an object, a pointer, or a reference, we can delve a little deeper into some important defining properties of objects.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/>Understanding the fundamental properties of objects</h1>
<p>We saw earlier that in C++, an object has a type and an address. It also occupies a region of storage from the beginning of its construction to the end of its destruction. We will now examine these fundamental properties in more detail in order to understand how these properties affect the ways in which we write programs.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Object lifetime</h2>
<p>One of C++’s strengths, but also one reason for its relative complexity, arises from the control one has over the lifetime of objects. In C++, generally speaking, automatic objects are destructed at the end of their scope in a well-defined order. Static (global) objects are destructed on program<a id="_idIndexMarker022"/> termination in a somewhat well-defined order (in a given file, the order of destruction is clear, but it’s more complicated for static objects in different files). Dynamically allocated objects are destructed “when your program says so” (there are many nuances to this).</p>
<p>Let’s examine some aspects of object lifetime with the following (very) simple program:</p>
<pre class="source-code">
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;format&gt;
struct X {
   std::string s;
   X(std::string_view s) : s{ s } {
      std::cout &lt;&lt; std::format("X::X({})\n", s);
   }
   ~X(){
      std::cout &lt;&lt; std::format("~X::X() for {}\n", s);
   }
};
X glob { "glob" };
void g() {
   X xg{ «g()» };
}
int main() {
   X *p0 = new X{ "p0" };
   [[maybe_unused]] X *p1 = new X{ "p1" }; // will leak
   X xmain{ "main()" };
   g();
   delete p0;
   // oops, forgot delete p1
}</pre> <p>When executed, that <a id="_idIndexMarker023"/>program will print the following:</p>
<pre class="source-code">
X::X(glob)
X::X(p0)
X::X(p1)
X::X(main())
X::X(g())
~X::X() for g()
~X::X() for p0
~X::X() for main()
~X::X() for glob</pre> <p>The fact that the number of constructors and destructors do not match is a sign that we did something wrong. More specifically, in this example, we manually created an object (pointed to by <code>p1</code>) with <code>operator new</code> but never manually destructed that object afterward.</p>
<p>One common source of<a id="_idIndexMarker024"/> confusion for programmers unfamiliar with C++ is the distinction between pointer and pointee. In this program, <code>p0</code> and <code>p1</code> are both destructed when reaching the end of their scope (by the closing brace of the <code>main()</code> function), just as <code>xmain</code> will be. However, since <code>p0</code> and <code>p1</code> point to dynamically allocated objects, the pointees have to be explicitly destructed, something we did for <code>p0</code> but (deliberately, for the sake of the example) neglected to do for <code>p1</code>.</p>
<p>What happens to <code>p1</code>’s pointee then? Well, it has been manually constructed and has not been manually destructed. As such, it floats in memory where no one can access it anymore. This is what people often call a memory leak: a chunk of memory your program allocated but never deallocated.</p>
<p>Worse than leaking the storage for the <code>X</code> object pointed to by <code>p1</code>, however, is the fact that the pointee’s destructor will never be called, which can cause all sorts of resource leaks (files not closed, database connections not closed, system handles not released, and so on). In <a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Destructors</em>, we will examine how it is possible to avoid such situations and write clean, simple code at the same time.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Object size, alignment, and padding</h2>
<p>Since each object occupies<a id="_idIndexMarker025"/> storage, the space associated with an object is an<a id="_idIndexMarker026"/> important (if low-level) property of C++ types. For example, look at <a id="_idIndexMarker027"/>the following code:</p>
<pre class="source-code">
class B; // forward declaration: there will be a class B
         // at some point in the future
void f(B*); // fine, we know what B is, even if we don't
            // know the details yet, and all object
            // addresses are of the same size
// class D : B {}; // oops! To know what a D is, we have
                   // to know how big a B is and what a
                   // B object contains since a D is a B</pre> <p>In that example, trying to define the <code>D</code> class would not compile. This is because in order to create a <code>D</code> object, the compiler needs to reserve enough space for a <code>D</code> object, but a <code>D</code> object is also a <code>B</code> object, and as such we cannot know the size of a <code>D</code> object without knowing the size of a <code>B</code> object.</p>
<p>The size of an object or, equivalently, of a type can be obtained through the <code>sizeof</code> operator. This operator yields a compile-time, non-zero unsigned integral value corresponding to the number of bytes required to store an object:</p>
<pre class="source-code">
char c;
// a char occupies precisely one byte of storage, per
// standard wording
static_assert(sizeof c == 1); // for objects parentheses
                              // are not required
static_assert(sizeof(c) == 1); // ... but you can use them
static_assert(sizeof(char) == 1); // for types, parentheses
                                  // are required
struct Tiny {};
// all C++ types occupy non-zero bytes of storage by
// definition, even if they are "empty" like type Tiny
static_assert(sizeof(Tiny) &gt; 0);</pre> <p>In the preceding example, the <code>Tiny</code> class is empty because it has no data member. A class could have member <a id="_idIndexMarker028"/>functions and still be empty. Empty classes that expose member functions are very commonly used in C++.</p>
<p>A C++ object always occupies at least<a id="_idIndexMarker029"/> one byte of storage, even in the case of empty classes such as <code>Tiny</code>. That’s because if an object’s size was zero, that object could be at the same memory location as its immediate neighbor, which would be somewhat hard to reason about.</p>
<p>C++ differs from many other languages in that it does not standardize the size of all fundamental types. For example, <code>sizeof(int)</code> can yield different values depending on the compiler and <a id="_idIndexMarker030"/>platform. Still, there are rules concerning the size of objects:</p>
<ul>
<li>The size reported by operator <code>sizeof</code> for objects of type <code>signed char</code>, <code>unsigned char</code> and <code>char</code> is 1, and the same goes for <code>sizeof(std::byte)</code> as each of these types can be used to represent a single byte.</li>
<li>Expressions <code>sizeof(short)&gt;=sizeof(char)</code> and <code>sizeof(int)&gt;=sizeof(short)</code> will hold on all platforms, which means that there might be cases where <code>sizeof(char)</code> and <code>sizeof(int)</code> are both 1. In terms of width (i.e., bits used in the value representation) of fundamental types, the C++ standard limits itself to stating the minimum width for each type. The list can be found at [<a href="http://wg21.link/tab:basic.fundamental.width">wg21.link/tab:basic.fundamental.width</a>].</li>
<li>As we have already said, expression <code>sizeof(T)&gt;0</code> holds for any type <code>T</code>. In C++, there are no zero-sized objects, not even objects of empty classes.</li>
<li>The size occupied by an object of any <code>struct</code> or <code>class</code> cannot be less than the sum of the size of its data members (but there are caveats).</li>
</ul>
<p>This last rule deserves an explanation. Consider the following situation:</p>
<pre class="source-code">
class X {};
class Y {
   X x;
};
int main() {
   static_assert(sizeof(X) &gt; 0);
   static_assert(sizeof(Y) == sizeof(X)); // &lt;-- here
}</pre> <p>The line marked <code>&lt;-- here</code> might be intriguing. Why would <code>sizeof(Y)</code> be equal to<code> sizeof(X)</code> if every <code>Y</code> object contains an <code>X</code> object? Remember that <code>sizeof(X)</code>  is greater than <code>0</code> even though <code>X</code> is an empty class because<a id="_idIndexMarker031"/> every C++ object has to occupy at least one byte of <a id="_idIndexMarker032"/>storage. However, in the case of <code>Y</code>, which is not an empty class, each <code>Y</code> object already occupies <a id="_idIndexMarker033"/>storage due to its <code>x</code> data member. There’s no reason to somewhat artificially add storage space to objects of that type.</p>
<p>Now, consider this:</p>
<pre class="source-code">
class X {
   char c;
};
class Y {
   X x;
};
int main() {
   static_assert(sizeof(X) == sizeof(char)); // &lt;-- here
   static_assert(sizeof(Y) == sizeof(X)); // &lt;-- here too
}</pre> <p>The same reasoning applies again: an object of type <code>X</code> occupies the same amount of storage space as its only data member (of type <code>char</code>), and an object of type <code>Y</code> occupies the same amount of storage<a id="_idIndexMarker034"/> space as its only data member (of type <code>X</code>).</p>
<p>Continuing this exploration, consider this :</p>
<pre class="source-code">
class X { };
class Y {
   X x;
   char c;
};
int main() {
   static_assert(sizeof(Y) &gt;= sizeof(char) + sizeof(X));
}</pre> <p>This is the rule we <a id="_idIndexMarker035"/>mentioned earlier but expressed formally for a specific type. In this situation, supposing that <code>sizeof(X)</code>being equal to <code>1</code> is highly probable, one <a id="_idIndexMarker036"/>could even reasonably expect that <code>sizeof(Y)</code>would be equal to the sum of<code> </code><code>sizeof(char)</code>and <code>sizeof(X)</code>.</p>
<p>Finally, consider this:</p>
<pre class="source-code">
class X { };
class Y : X { // &lt;--  private inheritance
   char c;
};
int main() {
   static_assert(sizeof(Y) == sizeof(char)); // &lt;-- here
}</pre> <p>We moved from having an object of class <code>X</code> being a data member of <code>Y</code> to <code>X</code> being a base class of <code>Y</code>. This has an interesting consequence: since the base class <code>X</code> is empty, and since we know from definition that objects of the derived class <code>Y</code> will occupy at least one byte of storage, the base class can be flattened into the derived class for <code>Y</code> objects. This is a useful optimization called the <strong class="bold">empty base optimization</strong>. You can reasonably expect compilers to perform<a id="_idIndexMarker037"/> this optimization in practice, at least in the case of single inheritance relationships.</p>
<p>Note that since the presence of an <code>X</code> in a <code>Y</code> is an implementation detail, not something that participates in the interface of class <code>Y</code>, we used private inheritance in this example. The empty base optimization would apply with public or protected inheritance too, but in this case, private inheritance<a id="_idIndexMarker038"/> preserves the fact that the <code>X</code> part of a <code>Y</code> is something that only the <code>Y</code> knows about.</p>
<p>Since C++20, if you think <a id="_idIndexMarker039"/>composition would be more appropriate than inheritance to describe the relation between two classes such as <code>X</code> and <code>Y</code>, you can mark a data member as <code>[[no_unique_address]]</code> to inform the compiler that this member, if it is an object of an empty class, does not have to occupy storage within the enclosing object. Compilers are not <a id="_idIndexMarker040"/>forced to comply, since attributes can be ignored, so make sure to verify that your chosen compilers implement this before writing code that relies on this:</p>
<pre class="source-code">
class X { };
class Y {
   char c;
   [[no_unique_address]] X x;
};
int main() {
   static_assert(sizeof(X) &gt; 0);
   static_assert(sizeof(Y) == sizeof(char)); // &lt;-- here
}</pre> <p>All of the examples so far have been very simple, using classes with zero, one, or two very small data members. Code is rarely so simple. Consider the following program:</p>
<pre class="source-code">
class X {
   char c; // sizeof(char) == 1 by definition
   short s;
   int n;
};
int main() {
   static_assert(sizeof(short) == 2); // we suppose this...
   static_assert(sizeof(int) == 4);   // ... and this
   static_assert(
      sizeof(X) &gt;= sizeof(char)+sizeof(short)+sizeof(int)
   );
}</pre> <p>Supposing that the first two static assertions hold, which is probable but not guaranteed, we know that <code>sizeof(X)</code> will be at least <code>7</code> (the sum of the sizes of its data members). In practice, however, you will <a id="_idIndexMarker041"/>probably see that <code>sizeof(X)</code> is equal to 8. Now, this might seem<a id="_idIndexMarker042"/> surprising at <a id="_idIndexMarker043"/>first, but it’s a logical consequence of something called <strong class="bold">alignment</strong>.</p>
<p>The alignment of an object (or of its type) tells us where that object can be placed in memory. The <code>char</code> type has an alignment of <code>1</code>, and as such one can place a <code>char</code> object literally anywhere (as long as one can access that memory). For an alignment of <code>2 </code>(which is likely for type <code>short</code>), objects can only be placed at addresses that are a multiple of 2. More generally, if a type has an alignment of <code>n</code>, then objects of that type must be placed at an<a id="_idIndexMarker044"/> address that is a multiple of <code>n</code>. Note that alignment has to be a strictly positive power of 2; not respecting this rule incurs undefined behavior. Of course, your compiler will not put you in that position, but you might put yourself in such trouble if you’re not careful, given some of the tricks we will be using in this book. With great control comes great responsibility.</p>
<p>The C++ language offers two operators related to alignment:</p>
<ul>
<li>The <code>alignof</code> operator, which yields the natural alignment of a type <code>T</code> or of an object of that type.</li>
<li>The <code>alignas</code> operator, which lets programmers impose the alignment of an object. This is often useful when playing tricks with memory (as we will) or when interfacing with exotic <a id="_idIndexMarker045"/>hardware (the term “exotic” here can be taken in a very broad sense). Of <a id="_idIndexMarker046"/>course, <code>alignas</code> can only reasonably increase the natural alignment of a type, not reduce it.</li>
</ul>
<p>For some fundamental type <code>T</code>, one can expect the assertion that <code>sizeof(T)</code> is equal to <code>alignof(T)</code> to hold, but that assertion does not generalize to composite types. For example, consider the following:</p>
<pre class="source-code">
class X {
   char c;
   short s;
   int n;
};
int main() {
   static_assert(sizeof(short) == alignof(short));
   static_assert(sizeof(int) == alignof(int));
   static_assert(sizeof(X) == 8); // highly probable
   static_assert(alignof(X) == alignof(int)); // likewise
}</pre> <p>Generally speaking, for a composite type, the alignment will correspond to the worst alignment of its data <a id="_idIndexMarker047"/>members. Here, “worst” means “biggest.” For class <code>X</code>, the worst-aligned data member is <code>n</code> of type <code>int</code> and as such, <code>X</code> objects will be aligned on boundaries of <code>alignof(int)</code> bytes.</p>
<p>You might wonder now why we can expect the assertion that <code>sizeof(X)</code> is equal to <code>8</code> to hold if <code>sizeof(short)==2</code> and <code>sizeof(int)==4</code>. Let’s look at the probable layout for objects of the <code>X</code> type:</p>
<div><div><img alt="Figure 1.1 – Compact layout of an object of type X in memory" src="img/B21071_01_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Compact layout of an object of type X in memory</p>
<p>Each box in this figure is a byte in memory. As we can see, there’s a <code>?</code> between <code>c</code> and the first byte of <code>s</code>. That comes from alignment. If <code>alignof(short)==2</code> and <code>alignof(int)==4</code>, then the only correct layout for an <code>X</code> object places its <code>n</code> member at a boundary of <code>4</code>. This means that there will be a padding byte (a byte that does not participate in the value<a id="_idIndexMarker048"/> representation of <code>X</code>) between <code>c</code> and <code>s</code> to align <code>s</code> on a two-byte boundary and to align <code>n</code> on a four-byte boundary.</p>
<p>What might seem more <a id="_idIndexMarker049"/>surprising is that the order in which data members<a id="_idIndexMarker050"/> are laid out in a class impacts the size of the objects of that class. For example, consider the following:</p>
<pre class="source-code">
class X {
   short s;
   int n;
   char c;
};
int main() {
   static_assert(sizeof(short) == alignof(short));
   static_assert(sizeof(int) == alignof(int));
   static_assert(alignof(X) == alignof(int));
   static_assert(sizeof(X) == 12); // highly probable
}</pre> <p>That often surprises people, but it’s true, and something to think about. With this example, the probable layout for an <code>X</code> object would be as follows:</p>
<div><div><img alt="Figure 1.2 – Less compact layout for an object of type X in memory" src="img/B21071_01_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Less compact layout for an object of type X in memory</p>
<p>By now, the two <code>?</code> “squares” between <code>s</code> and <code>n</code> are probably clear, but the three trailing <code>?</code> “squares” might seem surprising. After all, why add padding at the end of an object?</p>
<p>The answer is <em class="italic">because of arrays</em>. As we will soon discuss, elements of an array are contiguous in memory, and for that reason, it is important that each element of an array is properly aligned. In a case such as<a id="_idIndexMarker051"/> this, the trailing padding bytes in an object of class <code>X</code> ensure that if an element in<a id="_idIndexMarker052"/> an array of <code>X</code> objects is properly aligned, then the next element will be properly aligned too.</p>
<p>Now that you know about alignment, consider that just changing the order of elements from one version of class <code>X</code> to another resulted in a memory consumption increase of 50% for each object of that type. That hurts your program’s memory space consumption and its speed all at once. C++ compilers cannot reorder your data members for you, as your code sees the addresses of objects. Changing the relative position of data members could break users’ code, so it’s up to programmers to be careful with their chosen layouts. Note that<a id="_idIndexMarker053"/> keeping objects small is not the only factor that can influence the choice of layout in an object, especially in multithreaded code (where sometimes keeping two objects at a distance from one another can lead to better cache usage), so one should remember that layout is important, but not something to take on naïvely.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Copy and movement</h2>
<p>At this point, we need to say a few words about copy and movement, two fundamental considerations in a language such as C++ where there are actual objects.</p>
<p>The C++ language considers six member<a id="_idIndexMarker054"/> functions as special. These functions will be automatically generated for your types unless you take steps to prevent it. These are as follows:</p>
<ul>
<li><strong class="bold">The default constructor</strong>: It’s probably the<a id="_idIndexMarker055"/> least special of all six, as it’s only implicitly generated if you write no constructor of your own.</li>
<li><strong class="bold">The destructor</strong>: This is called at the end of <a id="_idIndexMarker056"/>an object’s lifetime.</li>
<li><strong class="bold">The copy constructor</strong>: It is called when <a id="_idIndexMarker057"/>constructing an object with a single object of the same type as argument.</li>
<li><strong class="bold">The copy assignment</strong>: It is called<a id="_idIndexMarker058"/> when replacing the contents of an existing object with a copy of the contents of another object.</li>
<li><code>std::move()</code>.</li>
<li><strong class="bold">The move assignment</strong>: It behaves like  copy assignment but is applied when the argument passed to the <a id="_idIndexMarker060"/>assignment operator is something one can move from.</li>
</ul>
<p>When a type does not explicitly manage any resources on its own, one can usually write none of these special functions, as the ones generated by the compiler will be exactly what one wants. For example, consider the following:</p>
<pre class="source-code">
struct Point2D {
   float x{}, y{};
};</pre> <p>Here, type <code>Point2D</code> represents a 2D coordinate that has no invariants (all values are fine for its <code>x</code> and <code>y</code> data members). Since we used default initializers for <code>x</code> and <code>y</code> that set these data members to 0, a default <code>Point2D</code> object will represent coordinate <code>(0,0)</code> and the six special member functions will behave as expected. The copy constructor will call the data members’ copy constructors, the copy assignment will call their copy assignment operators, the destructor will be trivial, and move operations will behave like copy operations since the data members are of fundamental types.</p>
<p>Should we decide to add a<a id="_idIndexMarker061"/> parametric constructor to explicitly let user code initialize the <code>x</code> and <code>y</code> data members to other values than our chosen defaults, we can do so. However, this will cost us our implicit default constructor:</p>
<pre class="source-code">
struct Point2D {
   float x{}, y{};
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
};
void oops() {
<strong class="bold">   Point2D pt; // does not compile, pt has no default ctor</strong>
}</pre> <p>We can of course fix this. One way to<a id="_idIndexMarker062"/> do so is by writing the details of a default constructor explicitly:</p>
<pre class="source-code">
struct Point2D {
   float x, y; // no need for default initializations
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
<strong class="bold">   Point2D() : x{ }, y{ } { // &lt;-- here</strong>
   }
};
void oops() {
   Point2D pt; // Ok
}</pre> <p>Another approach is to delegate work from the default constructor to the parametric constructor:</p>
<pre class="source-code">
struct Point2D {
   float x, y; <strong class="bold">// no need for default initializations</strong>
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
<strong class="bold">   Point2D() : Point2D{ 0, 0 } { // &lt;-- here</strong>
   }
};
void oops() {
   Point2D pt; // Ok
}</pre> <p>Another even better approach is to inform the compiler that we want to retain the default behavior even though we <a id="_idIndexMarker063"/>did something (writing another constructor) that would otherwise prevent it:</p>
<pre class="source-code">
struct Point2D {
   float x{}, y{};
   Point2D(float x, float y) : x{ x }, y{ y } {
   }
<strong class="bold">   Point2D() = default; // &lt;-- here</strong>
};
void oops() {
   Point2D pt; // Ok
}</pre> <p>The latter option will usually lead to the best generated code, as compilers are really good at getting maximal results from minimal effort when they understand the programmer’s intent. In this case, <code>=default</code> makes the intent very explicit: <em class="italic">please do what you would have done normally if my code had </em><em class="italic">not interfered</em>.</p>
<p class="callout-heading">A note about these constructors</p>
<p class="callout">We added parametric constructors to <code>Point2D</code> for the sake of this example, but it’s not necessary in this case as <code>Point2D</code> is an <a id="_idIndexMarker064"/>aggregate. These types have special initialization support, but that’s beside the point for our illustration. Aggregate types are types that comply with several restrictions (no user-declared or inherited constructors, no private non-static data members, no virtual bases classes, and so on) and that usually have no invariants to maintain, but can be initialized very efficiently by your compiler.</p>
<p>When a class explicitly manages resources, the default-generated special functions rarely do what we would <a id="_idIndexMarker065"/>want. Indeed, how could the compiler know about our intents in such a situation? Suppose we make a naïve <code>string</code>-like class of our own, starting with the following (incomplete) excerpt:</p>
<pre class="source-code">
#include &lt;cstring&gt; // std::strlen()
#include &lt;algorithm&gt; // std::copy()
class naive_string { // too simple to be useful
   char *p {}; // pointer to the elements (nullptr)
   std::size_t nelems {}; // number of elements (zero)
public:
   std::size_t size() const {
      return nelems;
   }
   bool empty() const {
      return size() == 0;
   }
   naive_string() = default; // empty string
   naive_string(const char *s)
      : nelems{ std::strlen(s) } {
      p = new char[size() + 1]; // leaving room for a
                                // (convenient) trailing 0
      std::copy(s, s + size(), p);
      p[size()] = '\0';
   }
   // index-wise access to characters, const and non-const
   // versions: the const version is useful for const
   // naive_string objects, whereas the non-const version
   // lets user code modify elements
   // precondition: n &lt; size()
   char operator[](std::size_t n) const { return p[n]; }
   char&amp; operator[](std::size_t n) { return p[n]; }
   // ... additional code (below) goes here
};</pre> <p>Naïve as it is, this class clearly does explicit resource allocation by allocating a chunk of <code>size()+1</code> bytes to hold a copy of the sequence of characters starting at <code>p</code>. For that reason, the compiler-provided special<a id="_idIndexMarker066"/> member functions will not do the right thing for our class. For example, the default-generated copy constructor will copy pointer <code>p</code>, but that means we will have two pointers (the original <code>p</code> and <code>p</code> in the copy) sharing a common pointee, which is probably not what we want. The default-generated destructor will destroy the pointer, but we also want to deallocate the pointee and avoid a memory leak, and so on.</p>
<p>In a case such as this, we want to implement the so-called rule of three and code the destructor as well as the two copy operations (the copy constructor and the copy assignment). Before the arrival of move semantics in C++11, that was sufficient to properly implement resource management for our types. It technically still is today but considering move semantics too will help us get a more efficient type in many ways. In contemporary code, when discussing code that implements the two move operations in addition to the rule of three, we typically speak of the rule of five.</p>
<h3>Destruction</h3>
<p>As our <code>naive_string</code> type does resource management with the dynamically allocated array pointed to by <code>p</code>, the<a id="_idIndexMarker067"/> destructor for that class will be simple, as its role will be limited to deallocating the chunk of memory pointed to by <code>p</code>:</p>
<pre class="source-code">
// ...
   ~naive_string() {
      delete [] p;
   }
// ...</pre> <p>Note that there is no need to check that <code>p</code> is non-null (<code>delete nullptr;</code> does nothing in C++ and is inherently non-dangerous). Also note that we are using <code>delete[]</code>, not <code>delete</code>, as we allocated the chunk of memory with <code>new[]</code>, not <code>new</code>. The nuances between these <a id="_idIndexMarker068"/>operations will be explained in <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>.</p>
<h3>Copy operations</h3>
<p>The copy constructor is the <a id="_idIndexMarker069"/>function called when constructing an object of the <code>naive_string</code> class with an argument that is another object of that class. For <a id="_idIndexMarker070"/>example, consider the following:</p>
<pre class="source-code">
// ...
void f(naive_string); // pass-by-value
void copy_construction_examples() {
   naive_string s0{ "What a fine day" };
   naive_string s1 = s0; // constructs s1 so this is
                         // copy construction
   naive_string s2(s0); // ...this too
   naive_string s3{ s0 }; // ...and so is this
   f(s0); // likewise because of pass-by-value
   s1 = s0; // this is not a copy construction as s1
            // already exists: this is a copy assignment
}</pre> <p>For our <code>naive_string</code> class, a <a id="_idIndexMarker071"/>correct copy constructor could be written as follows:</p>
<pre class="source-code">
// ...
   naive_string(const naive_string &amp;other)
      : p{ new char[other.size() + 1] },
        nelems{ other.size() } {
      std::copy(other.p, other.p + other.size(), p);
      p[size()] = '\0';
   }
// ...</pre> <p>Copy assignments could be written in numerous ways, but many of them are complicated or just plain <a id="_idIndexMarker072"/>dangerous. For example, consider the following example…but do not write your assignment operator like this!:</p>
<pre class="source-code">
// ...
   // bad copy assignment operator
   naive_string&amp; operator=(const naive_string &amp;other) {
      // first, release the memory held by *this
      delete [] p;
      // then, allocate a new chunk of memory
      p = new char[other.size() + 1]; // &lt;-- note this line
      // copy the contents themselves
      std::copy(other.p, other.p + other.size(), p);
      // adjust the size and add the trailing zero
      nelems = other.size();
      p[size()] = '\0';
      return *this;
   }
// ...</pre> <p>Now, this might seem reasonable (if a bit long-winded), but if we look at the line where memory allocation is performed, one has to wonder: what will happen if this fails? Indeed it could. For example, it might fail if the <a id="_idIndexMarker073"/>process is running low on available memory and <code>other.size()</code> is too much for whatever resources are left. In C++, by default, allocation with <code>operator new</code> throws an exception on failure. This would complete the execution of our copy assignment function, leaving <code>*this</code> in an incorrect (and dangerous!) state whereby <code>p</code> is non-null and <code>nelems</code> is non-zero but <code>p</code> points to what most would call <a id="_idIndexMarker074"/>garbage: memory we do not own and whose contents would lead to undefined behavior if used.</p>
<p>We could claim that we can do better and write even more code trying to fix this bug. The recommendation to avoid writing your copy assignment operators like this holds also in this case:</p>
<pre class="source-code">
// ...
   // another bad copy assignment operator
   naive_string&amp; operator=(const naive_string &amp;other) {
      // first, allocate a new chunk of memory
      char *q = new char[other.size() + 1];
      // then release the memory held by *this and make
      // p point to the new chunk
      delete [] p; // &lt;-- pay attention to this line
      p = q;
      // copy the contents themselves
      std::copy(other.p, other.p + other.size(), p);
      // adjust the size and add the trailing zero
      nelems = other.size();
      p[size()] = '\0';
      return *this;
   }
// ...</pre> <p>This looks safer on the surface, as we do not try to clean up the existing state of <code>*this</code> until we are sure that the <a id="_idIndexMarker075"/>allocation has worked. It might even pass most of your tests – until someone crafts the following test:</p>
<pre class="source-code">
void test_self_assignment() {
   naive_string s0 { "This is not going to end well..." };
   s0 = s0; // oops!
}</pre> <p>With this use case, our copy assignment will behave very badly. After allocating a properly sized chunk <a id="_idIndexMarker076"/>of memory pointed to by <code>q</code>, it will delete what <code>p</code> points to. Unfortunately, this also happens to be what <code>other.p</code> points to, destroying the actual source data we are aiming to copy from. What follows that step reads from memory we do not own anymore, and the program stops making sense.</p>
<p>We can still try to patch this, and even make it work, but beware:</p>
<pre class="source-code">
// ...
   // this works, but it's getting complicated and
   // is a sign we're doing something wrong
   naive_string&amp; operator=(const naive_string &amp;other) {
      // prevent self-assignment
      if(this == &amp;other) return *this;
      // then, do that sequence of steps
      char *q = new char[other.size() + 1];
      delete [] p; // &lt;-- pay attention to this line
      p = q;
      std::copy(other.p, other.p + other.size(), p);
      nelems = other.size();
      p[size()] = '\0';
      return *this;
   }
// ...</pre> <p>This fix is a pessimization, since we will be making every copy assignment call pay for that <code>if</code> branch that, in<a id="_idIndexMarker077"/> practice, should almost never be used. Brute-force problem-solving led us to complicated <a id="_idIndexMarker078"/>code that works (though it’s not necessarily self-evident) and that will need to be reconsidered with every resource-managing class we write.</p>
<p class="callout-heading">About the word pessimization</p>
<p class="callout">The word <em class="italic">pessimization</em> is generally used as the opposite of <em class="italic">optimization</em>, referring to a programming maneuver or technique<a id="_idIndexMarker079"/> that makes program behavior less efficient than it <a id="_idIndexMarker080"/>should be. The preceding case is a well-known example of such a maneuver: everyone will pay for the potential branch introduced by the <code>if</code> statement even though it’s only required for rare and degenerate cases – things that should not happen.</p>
<p class="callout">When faced with a “pessimization” opportunity, it’s often worth it to take a step back and reconsider. Maybe we’ve been taking the wrong angle when approaching the problem.</p>
<p>Luckily, there is a well-known idiom in C++ called the <strong class="bold">safe assignment idiom</strong>, colloquially known as copy-and-swap. The trick is to recognize that the assignment is made of two parts: a destructive part that <a id="_idIndexMarker081"/>cleans up the existing state owned by the destination object (the left side of the assignment) and a constructive part that copies the state from a source object (right side of the assignment) to the destination object. The destructive part is generally equivalent to the code found in the type’s destructor, and the constructive part is generally equivalent to the code found in the type’s copy constructor.</p>
<p>The informal copy-and-swap name for that technique comes from the fact that it is usually implemented through a <a id="_idIndexMarker082"/>combination of the type’s copy constructor, its destructor, and a <code>swap()</code> member function that swaps member variables one by one:</p>
<pre class="source-code">
// ...
   void swap(naive_string &amp;other) noexcept {
      using std::swap; // make the standard swap function
                       // available
      swap(p, other.p); // swap data members
      swap(nelems, other.nelems);
   }
   // idiomatic copy assignment
   naive_string&amp; operator=(const naive_string &amp;other) {
      naive_string { other }.swap(*this); // &lt;-- here
      return *this; // yes, that's it!
   }
// ...</pre> <p>That idiom is extremely useful to know and use as it’s exception-safe, simple, and works for almost all types. The line that does all the work performs three steps:</p>
<ul>
<li>First, it constructs an anonymous copy of <code>other</code> using that type’s copy constructor. Now, that might fail if an exception is thrown, but if it does, <code>*this</code> has not been modified and thus remains uncorrupted.</li>
<li>Second, it swaps that anonymous temporary’s contents (holding what we want to put in <code>*this</code>) with the destination object’s contents (putting the now-unneeded state in that<a id="_idIndexMarker083"/> anonymous temporary object).</li>
<li>Finally, the anonymous temporary object is destroyed at the end of the expression (being anonymous), leaving <code>*this</code> holding a copy of the state of <code>other</code>.</li>
</ul>
<p>This idiom even works safely for self-assignment. It incurs an unneeded copy, but it trades an <code>if</code> branch that every call would have paid but almost none would have benefitted from for a copy that will rarely be useless.</p>
<p>You might notice <code>noexcept</code> preceding the opening brace of the <code>swap()</code> member function. We will return to this<a id="_idIndexMarker084"/> later, but for now, the important point is that we can claim that this function (swapping objects of fundamental types as it does) will never throw an exception. This information will help us achieve some precious optimizations later in this book.</p>
<h3>Move operations</h3>
<p>Our <code>naive_string</code>, which is augmented by its destructor, copy constructor, and copy assignment member functions, now <a id="_idIndexMarker085"/>manages resources appropriately. It <a id="_idIndexMarker086"/>could, however, be made faster, and sometimes even safer.</p>
<p>Consider the following non-member string concatenation operator that someone could want to add to complement our class:</p>
<pre class="source-code">
// returns the concatenation of s0 and s1
naive_string operator+(naive_string s0, naive_string s1);</pre> <p>An operation like this could be used in user code such as the following:</p>
<pre class="source-code">
naive_string make_message(naive_string name) {
   naive_string s0{ "Hello "},
                s1{ "!" };
   return s0 + name + s1; // &lt;-- note this line
}</pre> <p>The expression that follows the <code>return</code> statement first performs a call to <code>operator+()</code> and creates an unnamed <code>naive_string</code> object from the concatenation of <code>s0</code> and <code>name</code>. Then, that unnamed object is passed as the first argument to another call to <code>operator+()</code> that yields another unnamed object created from the concatenation of the first unnamed object and <code>s1</code>. With our current implementation, each unnamed object incurs an allocation, a copy of the data held in its buffer, a destruction, and more. It’s more costly than it looks at first glance and is made even worse by the fact that each allocation could throw an exception.</p>
<p>Still, it works.</p>
<p>Since C++11, we can make such code significantly more efficient through move semantics. In addition to <a id="_idIndexMarker087"/>the traditional rule of three functions we just discussed, one can augment a class such as <code>naive_string</code> with a move constructor and a move assignment operator. These will kick in implicitly when the compiler operates on objects it knows will not be used anymore. Consider the following:</p>
<pre class="source-code">
// ...
   return s0 + name + s1;
// ...</pre> <p>This translates to the following:</p>
<pre class="source-code">
// ...
   return (s0 + name) + s1;
//         ^^^^^^^^^^^ &lt;-- anonymous object (we cannot
/                          refer to it afterward)
// ...</pre> <p>It then translates to <a id="_idIndexMarker088"/>the following:</p>
<pre class="source-code">
// ...
   ((s0 + name) + s1);
// ^^^^^^^^^^^^^^^^^^^ &lt;-- anonymous object (idem)
// ...</pre> <p>When one thinks about it, the reason for copy operations is to keep the source object intact in case we need it later. Temporary objects that have no name do not need to be preserved from further modifications as they cannot be referred to later. For that reason, we can be more aggressive with these and essentially move their contents instead of copying them. The rule we are asked to follow by the standard is to leave the moved-from object in a valid-yet-indeterminate state. Essentially, the moved-from object has to be in such a<a id="_idIndexMarker089"/> state that it can be safely destroyed or assigned to, and its invariants should still hold. In practice, that often amounts to leaving the moved-from object in something equivalent to its default state.</p>
<p>For our <code>naive_string</code> type, a move constructor could look like this:</p>
<pre class="source-code">
// ...
   naive_string(naive_string &amp;&amp;other) noexcept
      : p{ std::move(other.p) },
        nelems{ std::move(other.nelems) } {
      other.p = nullptr;
      other.nelems = 0;
   }
// ...</pre> <p>The calls to <code>std::move()</code> in this specific case could be avoided (moving objects of fundamental types is equivalent to copying them), but it’s probably more hygienic to make sure that the intent to move those objects is inscribed explicitly in the source code. We’ll look cursorily at <code>std::move()</code> later in this section, but the important thing to remember is that <code>std::move()</code> does not move anything. It marks an object as movable in the eyes of the compiler. In other words, <em class="italic">it’s </em><em class="italic">a cast</em>.</p>
<p>The important things to note with our move constructor are as follows:</p>
<ul>
<li>The argument is of type <code>naive_string&amp;&amp;</code>. This means it is a reference to an <code>rvalue</code>, with <code>rvalue</code> itself informally meaning “something one could find on the right side of an assignment operator.”</li>
<li>Like <code>swap()</code>, it is marked <code>noexcept</code> to express the fact that no exception will be thrown during its execution.</li>
<li>It’s effectively transferring state from the source object, <code>other</code>, to the object under construction, <code>*this</code>. After the completion of this transfer, we leave <code>other</code> in a valid state (equivalent to what we would have with a default <code>naive_string</code> object), respecting the standard’s recommendation.</li>
</ul>
<p>One could write this function in <a id="_idIndexMarker090"/>a slightly terser manner with a small but quite useful function found in the <code>&lt;utility&gt;</code> header and named <code>std::exchange()</code>. Indeed, consider the following expression:</p>
<pre class="source-code">
a = std::exchange(b, c);</pre> <p>This expression means “assign to <code>a</code> the value of <code>b</code> but replace the value of <code>b</code> with the value of <code>c</code>.” This is a<a id="_idIndexMarker091"/> very common sequence of operations in real code. With this function, our move constructor becomes the following:</p>
<pre class="source-code">
// ...
   naive_string(naive_string &amp;&amp;other) noexcept
      : p{ std::exchange(other.p, nullptr) },
        nelems{ std::exchange(other.nelems, 0) } {
   }
// ...</pre> <p>That form is idiomatic C++ and can lead to some interesting optimizations in some circumstances.</p>
<p>What about the move assignment? Well, we can take note of the idiomatic copy assignment we discussed at some length earlier and express it as follows:</p>
<pre class="source-code">
   // idiomatic copy assignment
   naive_string&amp; operator=(naive_string &amp;&amp;other) noexcept {
      naive_string { std::move(other) }.swap(*this);
      return *this;
   }</pre> <p>Following the path set by <a id="_idIndexMarker092"/>our copy assignment operator, we expressed the move assignment operator as a combination of <code>swap()</code>, a destructor, and a move constructor. The general logic behind both idioms is the same.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/>Arrays</h1>
<p>We have used arrays in our preceding examples, but we have not really provided a formal definition for that <a id="_idIndexMarker093"/>useful-yet-low-level construct. Note that in this section, the term “array” refers to raw, built-in arrays, not to other very useful but higher-level constructs such as <code>std::vector&lt;T&gt;</code> or <code>std::array&lt;T,N&gt;</code>.</p>
<p>Quite simply, in C++, an array is a contiguous sequence of elements of the same type. Thus, in the following excerpt, the <code>a0</code> object occupies <code>10*sizeof(int)</code> bytes in memory, whereas the <code>a1</code> object occupies <code>20*sizeof(std::string)</code> bytes:</p>
<pre class="source-code">
int a0[10];
std::string a1[20];</pre> <p>The number of bytes between elements at indices <code>i</code> and <code>i+1</code> in an array of some type <code>T</code> is precisely equal to <code>sizeof(T)</code>.</p>
<p>Consider the following expression, which would be used in C++, as in C, for some array <code>arr</code>:</p>
<pre class="source-code">
arr[i]</pre> <p>It evaluates to the same address as the following:</p>
<pre class="source-code">
*(arr + i)</pre> <p>Since pointer arithmetic is typed, the <code>+ i</code> part in this expression means “plus <code>i</code> elements” or “plus <code>i</code> times the size of an element in bytes.”</p>
<p>Array sizes are positive but cannot be 0 unless the array is dynamically allocated:</p>
<pre class="source-code">
int a0[5]; // Ok
static_assert(sizeof a0 == 5 * sizeof(int));
enum { N = sizeof a0 / sizeof a0[0] }; // N == 5
// int a1[0]; // not allowed: the array would be at the
              // same address as the next object in memory!
int *p0 = new int[5]; // Ok, but you have to manage the
                      // pointee now
int *p1 = new int[0]; // Ok, dynamically allocated; you
                      // still have to manage the pointee
// ...
delete [] p1; // good
delete [] p0; // good; be responsible</pre> <p>Each call to <code>operator new[]</code> has to yield a different address, even if the array’s size is 0. Each call <a id="_idIndexMarker094"/>technically returns the address of a different object.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>Summary</h1>
<p>In this chapter, we took a look at fundamental ideas of the C++ language such as: what is an object? What are pointers and references? What do we mean when we talk about the size and alignment of an object or of a type? Why are there no zero-size objects in C++? What are the special members of a class and when do we need to write them explicitly? This non-exhaustive list of topics gave us a common vocabulary from which to build what you, dear reader, will find in the chapters to come.</p>
<p>With this, we are ready to get our hands dirty, so to speak. We have given ourselves a set of low-level tools and ideas from which to build higher-level abstractions, but we have to give ourselves some measure of discipline.</p>
<p>The next chapter will discuss some things we need to avoid. Those include undefined behavior, implementation-defined behavior (to a lesser extent), ill-formed no-diagnostic-required code, buffer overflows, and other unrecommendable behaviors.</p>
<p>Then, we will follow with a chapter describing C++ casts, and how they can help us express clear ideas even when we feel the need to eschew some of the rules set out for us by the language’s type system.</p>
<p>After that, we will start to build beautiful and powerful abstractions that will help us with our stated goal of safely and efficiently managing resources in general and managing memory in particular.</p>
</div>
</body></html>