["```cpp\n    auto rayGenShader = context_->createShaderModule(\n      (resourcesFolder / \"raytrace_raygen.rgen\")\n        .string(),\n      VK_SHADER_STAGE_RAYGEN_BIT_KHR,\n      \"RayTracer RayGen Shader\");\n    auto rayMissShader = context_->createShaderModule(\n      (resourcesFolder / \"raytrace_miss.rmiss\")\n        .string(),\n      VK_SHADER_STAGE_MISS_BIT_KHR,\n      \"RayTracer Miss Shader\");\n    auto rayMissShadowShader =\n      context_->createShaderModule(\n        (resourcesFolder / \"raytrace_shadow.rmiss\")\n          .string(),\n        VK_SHADER_STAGE_MISS_BIT_KHR,\n        \"RayTracer Miss Shadow Shader\");\n    auto rayClosestHitShader =\n      context_->createShaderModule(\n        (resourcesFolder /\n         \"raytrace_closesthit.rchit\")\n          .string(),\n        VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,\n        \"RayTracer Closest hit Shader\");\n    ```", "```cpp\n    struct RayTracingPipelineDescriptor {\n      std::vector<SetDescriptor> sets_;\n      std::weak_ptr<ShaderModule> rayGenShader_;\n      std::vector<std::weak_ptr<ShaderModule>>\n        rayMissShaders_;\n      std::vector<std::weak_ptr<ShaderModule>>\n        rayClosestHitShaders_;\n      std::vector<VkPushConstantRange> pushConstants_;\n    };\n    ```", "```cpp\n    typedef struct VkRayTracingShaderGroupCreateInfoKHR {\n      VkStructureType sType;\n      const void *pNext;\n      VkRayTracingShaderGroupTypeKHR type;\n      uint32_t generalShader;\n      uint32_t closestHitShader;\n      uint32_t anyHitShader;\n      uint32_t intersectionShader;\n      const void *pShaderGroupCaptureReplayHandle;\n    } VkRayTracingShaderGroupCreateInfoKHR;\n    ```", "```cpp\n    std::vector<VkPipelineShaderStageCreateInfo>\n      shaderStages;\n    std::vector<VkRayTracingShaderGroupCreateInfoKHR>\n      shaderGroups;\n    const VkPipelineShaderStageCreateInfo\n      rayGenShaderInfo{\n        .sType =\n          VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n        .stage = rayGenShader->vkShaderStageFlags(),\n        .module = rayGenShader->vkShaderModule(),\n        .pName = rayGenShader->entryPoint().c_str(),\n      };\n    shaderStages.push_back(rayGenShaderInfo);\n    const VkRayTracingShaderGroupCreateInfoKHR\n      shaderGroup{\n        .sType =\n          VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,\n        .type =\n          VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,\n        .generalShader =\n          static_cast<uint32_t>(shaderStages.size()) -\n          1,\n        .closestHitShader = VK_SHADER_UNUSED_KHR,\n        .anyHitShader = VK_SHADER_UNUSED_KHR,\n        .intersectionShader = VK_SHADER_UNUSED_KHR,\n      };\n    shaderGroups.push_back(shaderGroup);\n    ```", "```cpp\n    VkRayTracingPipelineCreateInfoKHR rayTracingPipelineInfo{\n          .sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,\n          .stageCount = static_cast<uint32_t>(shaderStages.size()),\n          .pStages = shaderStages.data(),\n          .groupCount = static_cast<uint32_t>(shaderGroups.size()),\n          .pGroups = shaderGroups.data(),\n          .maxPipelineRayRecursionDepth = 10,\n          .layout = vkPipelineLayout_,\n      };\n      VK_CHECK(vkCreateRayTracingPipelinesKHR(context_->device(), VK_NULL_HANDLE,\n                                              VK_NULL_HANDLE, 1, &rayTracingPipelineInfo,\n                                              nullptr, &vkPipeline_));\n    ```", "```cpp\n    struct SBT {\n      std::shared_ptr<VulkanCore::Buffer> buffer;\n      VkStridedDeviceAddressRegionKHR sbtAddress;\n    };\n    ```", "```cpp\n    void EngineCore::RayTracer::\n      createShaderBindingTable() {\n      const uint32_t handleSize =\n        context_->physicalDevice()\n          .rayTracingProperties()\n          .shaderGroupHandleSize;\n      const uint32_t handleSizeAligned =\n        alignedSize(context_->physicalDevice()\n                      .rayTracingProperties()\n                      .shaderGroupHandleSize,\n                    context_->physicalDevice()\n                      .rayTracingProperties()\n                      .shaderGroupHandleAlignment);\n    ```", "```cpp\n    const uint32_t numRayGenShaders = 1;\n    const uint32_t numRayMissShaders =\n      2; // 1 for miss and 1 for shadow\n    const uint32_t numRayClosestHitShaders = 1;\n    const uint32_t numShaderGroups =\n      numRayGenShaders + numRayMissShaders +\n      numRayClosestHitShaders;\n    const uint32_t groupCount =\n      static_cast<uint32_t>(numShaderGroups);\n    const uint32_t sbtSize =\n      groupCount * handleSizeAligned;\n    ```", "```cpp\n    std::vector<uint8_t> shaderHandleStorage(sbtSize);\n    VK_CHECK(vkGetRayTracingShaderGroupHandlesKHR(\n      context_->device(), pipeline_->vkPipeline(), 0,\n      groupCount, sbtSize,\n      shaderHandleStorage.data()));\n    ```", "```cpp\n    raygenSBT_.buffer = context_->createBuffer(\n      context_->physicalDevice()\n          .rayTracingProperties()\n          .shaderGroupHandleSize *\n        numRayGenShaders,\n      VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR |\n        VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,\n      VMA_MEMORY_USAGE_CPU_ONLY, \"RayGen SBT Buffer\");\n    raygenSBT_.sbtAddress.deviceAddress =\n      raygenSBT_.buffer->vkDeviceAddress();\n    raygenSBT_.sbtAddress.size =\n      handleSizeAligned * numRayGenShaders;\n    raygenSBT_.sbtAddress.stride = handleSizeAligned;\n    raygenSBT_.buffer->copyDataToBuffer(\n      shaderHandleStorage.data(),\n      handleSize *numRayGenShaders);\n    ```", "```cpp\n    VkAccelerationStructureGeometryKHR\n      accelerationStructureGeometry{\n        .sType =\n          VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,\n        .geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR,\n        .geometry = {\n            .triangles = {\n                .sType =\n                  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,\n                .vertexFormat =\n                  VK_FORMAT_R32G32B32_SFLOAT,\n                .vertexData = vertexBufferDeviceAddress,\n                .vertexStride =\n                  sizeof(EngineCore::Vertex),\n                .maxVertex = numVertices,\n                .indexType = VK_INDEX_TYPE_UINT32,\n                .indexData = indexBufferDeviceAddress,\n              },\n          },\n      };\n    ```", "```cpp\n    VkAccelerationStructureBuildSizesInfoKHR\n      accelerationStructureBuildSizesInfo{\n        .sType =\n          VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,\n      };\n    vkGetAccelerationStructureBuildSizesKHR(\n      context_->device(),\n      VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,\n      &accelerationStructureBuildGeometryInfo,\n      &numTriangles,\n      &accelerationStructureBuildSizesInfo);\n    ```", "```cpp\n    // Creating buffer to hold the acceleration structure\n    bLAS_[meshIdx].buffer = context_->createBuffer(...);\n    // Creating acceleration structure\n    VkAccelerationStructureCreateInfoKHR accelerationStructureCreateInfo{\n        .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,\n        .buffer = bLAS_[meshIdx].buffer->vkBuffer(),\n        .size = accelerationStructureBuildSizesInfo.accelerationStructureSize,\n        .type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR};\n    VK_CHECK(vkCreateAccelerationStructureKHR(context_->device(),\n                                              &accelerationStructureCreateInfo, nullptr,\n                                              &bLAS_[meshIdx].handle));\n    // Creating temporary buffer\n    auto tempBuffer = context_->createBuffer(...);\n    // Setting up geometry and build range info for acceleration structure\n    VkAccelerationStructureBuildGeometryInfoKHR accelerationBuildGeometryInfo{\n        .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,\n        .dstAccelerationStructure = bLAS_[meshIdx].handle,\n        .scratchData = {.deviceAddress = tempBuffer->vkDeviceAddress()}};\n    VkAccelerationStructureBuildRangeInfoKHR accelerationStructureBuildRangeInfo{\n        .primitiveCount = numTriangles};\n    // Building acceleration structure\n    const auto commandBuffer = commandQueueMgr.getCmdBufferToBegin();\n    vkCmdBuildAccelerationStructuresKHR(\n        commandBuffer, 1, &accelerationBuildGeometryInfo,\n        &accelerationStructureBuildRangeInfo);\n    ```", "```cpp\n    for (int meshIdx = 0; meshIdx < model->meshes.size();\n         ++meshIdx) {\n      VkAccelerationStructureInstanceKHR instance{};\n      ...\n      instance.accelerationStructureReference =\n        bLAS_[meshIdx].buffer->vkDeviceAddress();\n      accelarationInstances_.push_back(instance);\n    }\n    ```", "```cpp\n    VkAccelerationStructureGeometryKHR\n      accelerationStructureGeometry{\n      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,\n      .geometryType = VK_GEOMETRY_TYPE_INSTANCES_KHR,\n      .geometry = {\n        .instances = {\n          .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,\n          .data = instanceDataDeviceAddress,\n        },\n      },\n      .flags = VK_GEOMETRY_OPAQUE_BIT_KHR,\n    };\n    ```", "```cpp\n    VkAccelerationStructureBuildSizesInfoKHR\n      accelerationStructureBuildSizesInfo{\n        .sType =\n          VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,\n      };\n    vkGetAccelerationStructureBuildSizesKHR(\n      context_->device(),\n      VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,\n      &accelerationStructureBuildGeometryInfo,\n      &primitiveCount,\n      &accelerationStructureBuildSizesInfo);\n    ```", "```cpp\n    VkAccelerationStructureCreateInfoKHR\n      accelerationStructureCreateInfo{\n        .sType =\n          VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,\n        .buffer = tLAS_.buffer->vkBuffer(),\n        .size = accelerationStructureBuildSizesInfo\n                  .accelerationStructureSize,\n        .type =\n          VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,\n      };\n    VK_CHECK(vkCreateAccelerationStructureKHR(\n      context_->device(),\n      &accelerationStructureCreateInfo, nullptr,\n      &tLAS_.handle));\n    vkCmdBuildAccelerationStructuresKHR(\n      commandBuffer, 1, &accelerationBuildGeometryInfo,\n      accelerationBuildStructureRangeInfos.data());\n    ```", "```cpp\n    void main() {\n      // Ray Generation\n      // tea refers to Tiny Encryption Algorithm, used to generate a unique and reproducible seed for each task and frame.\n      uint seed =\n        tea(gl_LaunchIDEXT.y * gl_LaunchIDEXT.x +\n              gl_LaunchIDEXT.x,\n            camProps.frameId);\n      vec3 finalOutColor = vec3(0);\n      vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) +\n                         vec2(0.5) +\n                         vec2(rand(seed), rand(seed));\n      vec4 target =\n        camProps.projInverse *\n        vec4(pixelCenter / vec2(gl_LaunchSizeEXT.xy) *\n                 2.0 -\n               1.0,\n             1, 1);\n      vec4 direction =\n        camProps.viewInverse *\n        vec4(normalize(target.xyz / target.w), 0);\n      // Initial Payload Setup\n      rayPayload.currentBounceIndex = 0;\n      rayPayload.exit = false;\n      rayPayload.origin =\n        (camProps.viewInverse * vec4(0, 0, 0, 1)).xyz;\n      rayPayload.direction = direction.xyz;\n      // Ray Tracing Loop\n      for (int j = 0; j < MAX_BOUNCES; ++j) {\n        rayPayload.currentBounceIndex = j;\n      // Traces a ray using a culling mask of 0xff to include all potential intersections.\n        traceRayEXT(topLevelAccelStruct,\n                    gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0,\n                    rayPayload.origin.xyz, 0.001,\n                    rayPayload.direction.xyz, 10000.0, 0);\n        if (rayPayload.exit)\n          break;\n      }\n      // Final Color Calculation and Image Store\n      finalOutColor += rayPayload.radiance / MAX_SAMPLES;\n      imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy),\n                 vec4(linear2sRGB(finalOutColor), 0.0));\n    }\n    ```", "```cpp\n    void main() {\n      rayPayload.radiance =\n        envMapColor(gl_WorldRayDirectionEXT);\n      rayPayload.exit = true;\n    }\n    ```", "```cpp\n    vec3 envLightColor = vec3(0);\n    vec4 dirPdf =\n      envSample(envLightColor, rayPayload.seed);\n    vec3 lightDir = dirPdf.xyz;\n    float lightPdf = dirPdf.w\n    ```", "```cpp\n    inshadow = true;\n    const int layoutLocation = 1;\n    // Trace the shadow ray\n    traceRayEXT(topLevelAccelStruct, rayFlags, cullMask,\n                0, 0, 1, worldPosition, rayMinDist,\n                lightDir, rayMaxDist, layoutLocation);\n    ```", "```cpp\nif (!inshadow) {\n  float pdf;\n  // returns diffuse & specular both\n  vec3 F =\n    PbrEval(eta, metallic, roughness, baseColor.rgb,\n            specularColor, -rayPayload.direction, N,\n            lightDir, pdf);\n  float cosTheta = abs(dot(lightDir, N));\n  float misWeight =\n    max(0.0, powerHeuristic(lightPdf, pdf));\n  if (misWeight > 0.0) {\n    directLightColor += misWeight * F * cosTheta *\n                        envLightColor /\n                        (lightPdf + EPS);\n  }\n}\nrayPayload.radiance +=\n  directLightColor * rayPayload.throughput;\n```", "```cpp\nVec3 F = PbrSample(baseColor.rgb, specularColor, eta,\n                   materialIOR, metallic, roughness,\n                   T, B, -rayPayload.direction,\n                   ffnormal, bsdfDirNextRay,\n                   bsdfpdfNextRay, rayPayload.seed);\nfloat cosTheta = abs(dot(N, bsdfDirNextRay));\nrayPayload.throughput *=\n  F * cosTheta / (bsdfpdfNextRay);\n// Russian roulette\nfloat rrPcont =\n  min(max3(rayPayload.throughput) * eta * eta + 0.001,\n      0.95);\nrayPayload.throughput /= rrPcont;\n// update new ray direction & position\nrayPayload.direction = bsdfDirNextRay;\nrayPayload.origin = offsetRay(\n  worldPosition, dot(bsdfDirNextRay, worldNormal) > 0\n                   ? worldNormal\n                   : -worldNormal);\n```", "```cpp\n raytrace_raygen_shadow_hybrid.rgen, raytrace_miss_shadow_hybrid.rmiss, raytrace_closesthit_shadow_hybrid.rchit\n```", "```cpp\n hybridRenderer_lighting_composite.frag.\n```", "```cpp\n    layout(location = 0) rayPayloadEXT\n      float visibilityRayPayload;\n    layout(set = 0, binding = 0) uniform\n      accelerationStructureEXT topLevelAccelStruct;\n    layout(set = 0, binding = 1,\n           rgba8) uniform image2D outputImage;\n    layout(set = 1,\n           binding = 0) uniform sampler2D gbufferNormal;\n    layout(set = 1,\n           binding = 1) uniform sampler2D gbufferPosition;\n    ```", "```cpp\n    const vec2 pixelCenter =\n      vec2(gl_LaunchIDEXT.xy) + vec2(0.5);\n    const vec2 inUV =\n      pixelCenter / vec2(gl_LaunchSizeEXT.xy);\n    vec3 normal =\n      normalize(texture(gbufferNormal, inUV).xyz);\n    vec3 worldPosition =\n      texture(gbufferPosition, inUV).xyz;\n    vec3 rayOrigin = worldPosition + normal * 0.1f;\n    ```", "```cpp\n    for (int i = 0; i < numSamples; i++) {\n      vec3 randomPointOnLight =\n        lightData.lightPos.xyz +\n        (rand3(seed) - 0.5) * lightSize;\n      vec3 directionToLight =\n        normalize(randomPointOnLight - worldPosition);\n      // Start the raytrace\n      traceRayEXT(topLevelAccelStruct, rayFlags, 0xFF, 0,\n                  0, 0, rayOrigin.xyz, tMin,\n                  directionToLight.xyz, tMax, 0);\n      visible += visibilityRayPayload;\n    }\n    visible /= float(numSamples);\n    ```"]