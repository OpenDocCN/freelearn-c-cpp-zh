- en: '*Chapter 2*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*'
- en: Thesis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 论文
- en: Objects Are Independent Programs
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象是独立的程序
- en: The thread running through a lot of different presentations is that objects
    are isolated computer programs that communicate by sending and receiving messages.
    Often, there is an *and*, but the second clause differs greatly. Let’s ignore
    it and focus on that first clause.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同演示中贯穿的线索是对象是相互独立的计算机程序，它们通过发送和接收消息进行通信。通常，有一个“和”，但第二个子句差异很大。让我们忽略它，专注于第一个子句。
- en: For example, in Smalltalk-80 and (most of) its descendants, objects could be
    described as isolated computer programs that communicate by sending and receiving
    messages *and* are instances of classes that are organized in a tree structure.
    The second part here, the part about classes, weakens the first part by reducing
    the scope of isolation. Why is it required that both the sender and recipient
    of a message are instances of a class, and that both classes are members of the
    same tree structure? It is not, so let’s strengthen the idea of isolated programs
    by removing the constraint on inheritance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Smalltalk-80 及其大多数后继者中，对象可以被描述为相互独立的计算机程序，它们通过发送和接收消息进行通信，并且是组织在树结构中的类的实例。这里第二部分，关于类的内容，通过减少隔离的范围削弱了第一部分。为什么要求消息的发送者和接收者都是类的实例，并且这两个类都是同一树结构的成员？这并不是必须的，所以让我们通过移除继承的约束来加强独立程序的概念。
- en: An existing example of an OOP environment with this form of isolation is COM
    (yes, the Microsoft **Component Object Model**, that **COM**). When you receive
    an object, you know nothing about it but that it responds to the messages defined
    in the **IUnknown**—[https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown](https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown)
    interface, which let you keep a reference to the object, relinquish that reference,
    or find out what other interfaces it supports. It tells you nothing about where
    that object came from, whether it inherited from another object, or whether it
    has fresh, hand-crafted, artisanal implementations of each of its methods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有这种隔离形式的面向对象编程环境的现有例子是 COM（是的，就是微软的**组件对象模型**，也就是**COM**）。当你收到一个对象时，你对其一无所知，只知道它响应在
    **IUnknown**—[https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown](https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown)
    接口中定义的消息，该接口允许你保持对对象的引用，放弃该引用，或找出它支持的其他接口。它没有告诉你该对象来自何处，是否从另一个对象继承，或者它是否对其每个方法都有新鲜、手工制作的、工匠般的实现。
- en: An inference you can make about both `COM` objects and `Smalltalk` objects is
    that they exist in the same process, that is, the same blob of memory and execution
    context, as the thing sending them the message. Maybe they internally forward
    their messages over some `Smalltalk` object hogs the CPU, other objects do not
    get to run.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对 COM 对象和 Smalltalk 对象做出的一个推论是，它们存在于同一个进程中，也就是说，与发送消息的同一块内存和执行上下文。也许它们在内部通过某些
    Smalltalk 对象将消息转发，其他对象则无法运行。
- en: So, while `Smalltalk` objects *approximate* the **isolated computer programs**
    concept, the approximation is inexact. Meanwhile, on Mach, the only thing a sender
    knows about an object is a “port,” a number that the kernel can use to work out
    what object is being messaged. An object could be on a different thread, on the
    same thread, in a different process, or (at least in theory) on a different computer,
    and sending it a message works in the same way. The receiver and the sender could
    share all of their code, inherit from a common ancestor, or be written in different
    programming languages and running on CPUs that store numbers in a different way,
    but they can still send each other a message.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然 Smalltalk 对象*近似*了独立计算机程序的概念，但这种近似并不精确。同时，在 Mach 上，发送者对对象唯一知道的是“端口”，这是一个内核可以使用它来确定正在被消息的对象的数字。对象可能位于不同的线程上，位于同一线程上，位于不同的进程中，或者（至少在理论上）位于不同的计算机上，向其发送消息的方式是相同的。接收者和发送者可能共享他们所有的代码，从共同的祖先继承，或者用不同的编程语言编写，在以不同方式存储数字的
    CPU 上运行，但他们仍然可以向对方发送消息。
- en: Between the extreme of `Smalltalk` (all objects are the same sort of objects
    and are related to each other) and Mach there is the concept of the `MetaObject`—[http://wiki.c2.com/?MetaObjectProtocol](http://wiki.c2.com/?MetaObjectProtocol).
    As the objects in a software system define how the system models some problem,
    the metaobjects define how the software system expresses the behavior of its objects.
    The `MetaObject` protocol exposes messages that change the meaning of the *object
    model* inside the system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Smalltalk`（所有对象都是同一种对象，并且相互关联）和Mach之间，存在`MetaObject`的概念——[http://wiki.c2.com/?MetaObjectProtocol](http://wiki.c2.com/?MetaObjectProtocol)。由于软件系统中的对象定义了系统如何建模某些问题，元对象定义了软件系统如何表达其对象的行为。`MetaObject`协议暴露了改变系统内部*对象模型*含义的消息。
- en: 'A `MetaObject` protocol, in other words, lets a programmer choose different
    rules for their programming environment for different sections of their program.
    Consider method lookup, for example: in Part One, we saw how any of prototypical
    inheritance, single inheritance and multiple inheritance, have benefits and drawbacks,
    and each impose different constraints on the design of an object system. Why not
    have all of these inheritance tools – and indeed any others, and other forms of
    delegation – to hand at the same time? With a `MetaObject` protocol, that’s possible.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个`MetaObject`协议让程序员能够为程序的不同部分选择不同的编程环境规则。以方法查找为例：在第一部分，我们看到了原型继承、单继承和多继承各自的优点和缺点，以及它们对对象系统设计的不同约束。为什么不同时拥有所有这些继承工具——以及任何其他工具，以及其他形式的委托——呢？有了`MetaObject`协议，这是可能的。
- en: The Open-Closed Nature of Independent Objects
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立对象的开放封闭特性
- en: In his book *Object-Oriented Software Construction*, *Bertrand Meyer* introduced
    the Open-Closed Principle. This principle may be one of the most confusingly stated
    ideas in all of computing and has led to a whole sub-industry of articles and
    podcasts explaining how a `ShapeRenderer` can draw `Squares` and `Circles` (of
    course, I have also partaken of such, and will continue here).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书籍《面向对象软件构造》中，**伯特兰·迈耶**介绍了开放封闭原则。这个原则可能是所有计算中最容易混淆的观点之一，并导致了一个完整的子行业，包括文章和播客解释如何一个`ShapeRenderer`可以绘制`正方形`和`圆形`（当然，我也有参与其中，并将继续在这里讨论）。
- en: The Open-Closed Principle says that a module (an object, in our case) should
    be open to extension – it should be possible to extend its behavior for new purposes
    – and yet closed to modification – you should not need to change it. This design
    principle comes with a cost, as you need to design your objects to support extensibility
    along lines that are not yet known (or at least, to make it clear which lines
    are or are not going to be fruitful) in return for the benefit that maintainers
    and users of the objects know that they are going to be stable and will not introduce
    breakages into a system through unexpected changes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开放封闭原则指出，一个模块（在我们的情况下是一个对象）应该对扩展开放——应该能够扩展其行为以适应新的目的——同时对其修改封闭——你不应该需要改变它。这个设计原则是有代价的，因为你需要设计你的对象以支持沿着尚未知的线路进行扩展（或者至少，要清楚地说明哪些线路是有益的，哪些不是），以换取维护者和对象使用者知道它们将是稳定的，并且不会通过意外的变化将破坏引入系统的好处。
- en: The nature of objects explored above, their treatment as completely independent
    programs, supports the Open-Closed Principle by keeping each object at arm’s length
    from the others. Their only point of contact is their messaging interface, even
    to their parent classes (remembering, of course, that they may not have any).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上文探讨的对象特性，将它们视为完全独立的程序，通过保持每个对象与其他对象保持距离来支持开放封闭原则。它们唯一的接触点是它们的消息接口，甚至是对它们的父类（当然，记住它们可能没有任何父类）。
- en: 'Therefore, to be open and closed, an object also needs to be ignorant: it should
    know as little as possible about its context. It knows what to do when it receives
    messages, and it knows when to send messages, but should otherwise remain uninformed
    as to what is happening around it. An ignorant object can be used in multiple
    contexts – open to extensions of its use – due to the fact that it cannot distinguish
    these contexts. It requires no contextual changes, and thus is closed to modification.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了保持开放和封闭，一个对象也需要无知：它应该尽可能少地了解其上下文。它知道在接收到消息时应该做什么，也知道何时发送消息，但应该在其他方面对周围发生的事情保持不知情。由于无法区分这些上下文，无知对象可以在多个上下文中使用——对其使用的扩展是开放的——这是因为它无法区分这些上下文。它不需要进行上下文更改，因此对修改是封闭的。
- en: The Correctness of Independent Objects
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立对象的正确性
- en: 'When each object is its own separate program, then we turn the problem of “does
    this big system work” into two separate problems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个对象都是其自己的独立程序时，我们将“这个大系统是否工作”的问题转化为两个独立的问题：
- en: Do these independent objects work?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些独立的对象是否工作？
- en: Are these independent objects communicating correctly?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些独立的对象是否正确地进行了通信？
- en: Each of these problems has been solved repeatedly in software engineering, and
    particularly in OOP. An object’s message interface makes a natural boundary between
    “this unit” and “everything else”, for the purposes of defining unit tests. Kent
    Beck’s Test-Driven Development approach sees developers designing objects from
    the message boundary inwards, by asking themselves what messages they would like
    to send to the object and what outcomes they would expect. This answers the question
    “do these independent objects work?” by considering each of the objects as a separate
    system under test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在软件工程中，尤其是在面向对象编程（OOP）中，已经被反复解决。一个对象的消息接口在定义单元测试时，自然地构成了“这个单元”和“其他一切”之间的边界。Kent
    Beck的测试驱动开发（TDD）方法通过询问自己希望向对象发送什么消息以及期望什么结果，从消息边界向内设计对象。这种方法通过将每个对象视为一个单独的系统来测试，回答了“这些独立的对象是否工作？”的问题。
- en: The London School of TDD, exemplified by the book *Growing Object-Oriented Software,
    Guided by Tests*, takes an extreme interpretation of the message-boundary-as-system-boundary
    rule, by using **mock objects**—[http://xunitpatterns.com/Mock%20Object.html](http://xunitpatterns.com/Mock%20Object.html)
    as stand-ins for all collaborators of the object under test. *This* object (the
    one being tested) needs to send a message to *that* object (some collaborator),
    but there’s no reason to know anything about that object other than that it will
    respond to the message. In this way, the London School promotes the ignorance
    described above as supporting the **Open-Closed Principle**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以《通过测试引导的面向对象软件增长》一书为例的伦敦TDD学校，对消息边界作为系统边界的规则进行了极端解释，通过使用**模拟对象**——[http://xunitpatterns.com/Mock%20Object.html](http://xunitpatterns.com/Mock%20Object.html)作为被测试对象的全部协作者的替代品。*这个*对象（被测试的对象）需要向*那个*对象（某个协作者）发送消息，但没有理由了解关于那个对象的其他信息，除了它将响应这个消息。通过这种方式，伦敦学校推崇的上述无知被用来支持**开放-封闭原则**。
- en: With the Eiffel programming language, Bertrand Meyer also addressed the question
    of whether each object works by allowing developers to associate a *contract*
    with each class. The contract is based on work Edsger Dijkstra and others had
    done on using mathematical induction to prove statements about programs, using
    the object’s message interface as the natural outer edge of the program. The contract
    explains what an object requires to be true before handling a given message (the
    preconditions), what an object will arrange to be true after executing its method
    (the postconditions), and the things that will always be true when the object
    is not executing a method (the invariants). These contracts are then run as checks
    whenever the objects are used, unlike unit tests which are only executed with
    the inputs and outputs that the test author originally thought of.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eiffel编程语言中，Bertrand Meyer通过允许开发者将一个*契约*与每个类关联起来，也解决了每个对象是否工作的问题。这个契约基于Edsger
    Dijkstra和其他人使用数学归纳法来证明关于程序陈述的工作，使用对象的消息接口作为程序的自然外部边界。契约解释了在处理给定消息之前对象需要什么条件为真（前置条件），对象在其方法执行后将安排什么条件为真（后置条件），以及当对象不执行方法时始终为真的条件（不变性）。然后，当对象被使用时，这些契约作为检查运行，与仅使用测试作者最初考虑的输入和输出的单元测试不同。
- en: Contracts have turned up in a limited way in the traditional software development
    approach in the form of **property-based testing**—[http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html](http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html),
    embodied in Haskell’s **QuickCheck**, Scala’s **ScalaCheck**, and other tools.
    In Eiffel, the contract is part of the system being constructed and describes
    how an object is to be used when combined with other objects. Property-based tests
    encapsulate the contract as an external verifier of the object under test by using
    the contract as a test oracle from which any number of automated tests can be
    constructed. A contract might say “if you supply a list of e-mail messages, each
    of which has a unique identifier, this method will return a list containing the
    same messages, sorted by sent date and then by identifier if the dates are equal”.
    A property-based test might say “for all lists of e-mail messages with unique
    identifiers, the result of calling this method is...”. A developer may generate
    a hundred or a thousand tests of that form, checking for no counter-examples as
    part of their release pipeline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 契约在传统的软件开发方法中以有限的方式出现，形式为基于属性的测试——[http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html](http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html)，体现在
    Haskell 的 **QuickCheck**、Scala 的 **ScalaCheck** 和其他工具中。在 Eiffel 中，契约是正在构建的系统的一部分，并描述了对象与其他对象结合时应该如何使用。基于属性的测试通过将契约作为测试占卜师，从而作为测试对象的外部验证器，使用契约来构建任何数量的自动化测试。一个契约可能说“如果你提供一个包含具有唯一标识符的电子邮件消息的列表，这个方法将返回一个包含相同消息的列表，按发送日期排序，如果日期相同，则按标识符排序”。一个基于属性的测试可能说“对于所有具有唯一标识符的电子邮件消息列表，调用此方法的输出结果...”。开发者可能生成一百或一千个这样的测试，作为他们发布流程的一部分，检查是否存在反例。
- en: The second part of the problem – are these independent objects communicating
    correctly? – can also be approached in multiple ways. It is addressed in a contract
    world such as Eiffel by ensuring that at each point where an object sends a message
    to a collaborator, the preconditions for that collaborator are satisfied. For
    everybody else, there are integration tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的第二部分——这些独立对象是否正确地进行了通信？——也可以用多种方式来处理。在像 Eiffel 这样的契约世界中，这是通过确保在每个对象向协作者发送消息的点，满足该协作者的先决条件来解决的。对于其他人，则有集成测试。
- en: 'If a unit test reports the behavior of a single object, then an integration
    test is trivially any test of an assembly containing more than one object. Borrowing
    Brad Cox’s Software ICs metaphor, a unit test tells you that a chip works, an
    integration test tells you that a circuit works. A special case of the integration
    test is the system test, which integrates all of the objects needed to solve some
    particular problem: it tells you that the whole board does what it ought to.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试报告了一个单一对象的行为，那么集成测试就是任何包含多个对象的组件的测试。借用布拉德·科克斯的软件集成电路隐喻，单元测试告诉你芯片是否工作，集成测试告诉你电路是否工作。集成测试的一个特殊情况是系统测试，它集成了解决某些特定问题所需的所有对象：它告诉你整个板是否按预期工作。
- en: The Design of Independent Objects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立对象的 设计
- en: 'It is appropriate to digress into a discussion of design here, because the
    activities of testing and design are closely related. Eric Evans’s book **Domain-Driven
    Design** discusses a form of what was previously called object-oriented analysis:
    finding the objects needed to solve a problem by interpreting a description of
    the problem. The process is straightforward. Take a description of the problem,
    and the *things* that do things are objects, the things they *do* are methods,
    and the things they *tell* or *ask* other things are messages. Evans proposes
    having a single “ubiquitous” language across the whole development team, so that
    the words used by the person who has the problem – the **Goal Donor**—[http://wiki.c2.com/?GoalDonor](http://wiki.c2.com/?GoalDonor)
    are the same words as those used by the people building the solution. Borrowing
    an idea from Christopher Alexander, it is the ubiquitous language of the problem
    and solution domain in which one would expect to find a pattern language, as common
    aspects of problems become addressed in similar ways.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里讨论设计是合适的，因为测试和设计活动是紧密相关的。Eric Evans的书籍**领域驱动设计**讨论了一种之前被称为面向对象分析的形式：通过解释问题的描述来找到解决问题所需的对象。这个过程很简单。取一个问题的描述，执行动作的“事物”是对象，它们执行的“动作”是方法，它们告诉或询问其他事物的“事物”是消息。Evans建议在整个开发团队中有一个单一的“普遍”语言，这样拥有问题的**目标提供者**[http://wiki.c2.com/?GoalDonor](http://wiki.c2.com/?GoalDonor)所使用的词汇与构建解决方案的人所使用的词汇相同。借鉴Christopher
    Alexander的想法，这是问题域和解决方案域的普遍语言，在其中可以期望找到一种模式语言，因为问题的常见方面以类似的方式得到解决。
- en: '**Behavior-Driven Development** marries the technical process of **Test-Driven
    Development** with the design concept of the ubiquitous language by encouraging
    developers to collaborate with the rest of their team on defining statements of
    desired behavior in the ubiquitous language and using those to drive the design
    and implementation of the objects in the solution domain. In that way, the statement
    of what the Goal Donor needs is also the statement of sufficiency and correctness
    – that is, the description of the problem that needs solving is also the description
    of a working solution. This ends up looking tautological enough not to be surprising.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**将**测试驱动开发**的技术流程与普遍语言的构思设计相结合，通过鼓励开发者与其他团队成员协作，用普遍语言定义期望的行为陈述，并使用这些陈述来驱动解决方案领域中对象的开发和实现。这样，目标提供者所需的目标陈述也是充分性和正确性的陈述——也就是说，需要解决的问题的描述也是有效解决方案的描述。这种方式最终看起来足够自洽，以至于不会令人感到惊讶。'
- en: Constructing Independent Objects
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建独立对象
- en: The theme running through this is that sufficiency is sufficient. When an object
    has been identified as part of the solution to a problem and contributes to that
    solution to the extent needed (even if for now that extent is “demonstrate that
    a solution is viable”), then it is ready to use. There is no *need* to situate
    the object in a taxonomy of inherited classes, but if that helps to solve the
    problem, then by all means do it. There is no *need* to show that various objects
    demonstrate a strict subtype relationship and can be used interchangeably, unless
    solving your problem requires that they be used interchangeably. There is no *need*
    for an object to make its data available to the rest of the program, unless the
    problem can be better solved (or cheaper solved, or some other desirable property)
    by doing so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章贯穿的主题是充分性足够。当一个对象被识别为解决问题的一部分，并且对解决方案的贡献达到所需程度（即使现在这个程度是“证明解决方案是可行的”），那么它就准备好使用了。没有必要将对象定位在继承类别的分类中，但如果这样做有助于解决问题，那么就尽一切可能去做。没有必要证明各种对象表现出严格的子类型关系并且可以互换使用，除非解决问题需要它们可以互换使用。没有必要让对象将其数据提供给程序的其他部分，除非这样做可以更好地解决问题（或者更便宜地解决问题，或者其他可取的性质）。
- en: I made quite a big deal earlier of the **Open-Closed Principle**, and its suggestion
    that the objects we build be “open to modification.” Doesn’t that mean that anticipating
    the ways in which a system will change and making it possible for the objects
    to flex in those ways?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前对**开放封闭原则**做了很多讨论，它建议我们构建的对象应该是“开放于修改”。这难道不是意味着预测系统将如何变化，并使对象能够以这种方式灵活变化吗？
- en: To some extent, yes, and indeed that consideration can be valuable. If your
    problem is working out how much to bill snooker players for their time on the
    tables in your local snooker hall, then it is indeed possible that your solution
    will be used in the same hall on the pool tables, or in a different snooker hall.
    But which of those will happen first? Will either happen soon? Those are questions
    to work with the Goal Donor and the **Gold Owner**—[http://wiki.c2.com/?GoldOwner](http://wiki.c2.com/?GoldOwner),
    the person paying for the solution) on answering. Is it worth paying to solve
    this related problem *now*, or not?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，是的，而且确实这种考虑是有价值的。如果你的问题是确定在你的当地台球馆中台球手在台上的时间应该如何收费，那么你的解决方案确实可能在同一个馆的台球桌上或在不同的台球馆中使用。但哪个会先发生？会很快发生吗？这些问题需要与目标捐赠者和**黄金所有者**（[http://wiki.c2.com/?GoldOwner](http://wiki.c2.com/?GoldOwner)，为解决方案付费的人）一起回答。现在解决这个相关问题值得付费吗？
- en: Regardless of the answer, the fact is that the objects are still ready to go
    to work as soon as they address *the problem you have now*. And there are other
    ways to address related problems anyway, which don’t require “future-proofing”
    the object designs to anticipate the uses to which they may be put. Perhaps your
    `SnookerTable` isn’t open to the extension of representing a pool table too, but
    the rest of the objects in your solution can send messages to a `PoolPlayer` in
    its stead. As the variant on the Open-Closed Principle showed, these other objects
    could be ignorant of the game played on the table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无论答案如何，事实是，一旦它们解决了“你现在遇到的问题”，这些对象就可以随时开始工作。而且，无论如何，还有其他方法来解决相关的问题，这些方法不需要“未来证明”对象设计以预测它们可能被用于哪些用途。也许你的`SnookerTable`并不适用于扩展表示台球桌，但你的解决方案中的其他对象可以代替向`PoolPlayer`发送消息。正如开放-封闭原则的变体所显示的，这些其他对象可能对在桌面上进行的游戏一无所知。
- en: 'Some amount of planning is always helpful, whether or not the plan turns out
    to be. The goal at every turn should be to understand how we get to *what we now
    want* from *what we have now*, not to *already have* that which *we will probably
    want sometime*. Maybe the easiest thing to do is to start afresh: so, do that.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论计划是否最终实现，一定的规划总是有帮助的。在每个转折点，我们的目标应该是理解我们如何从“我们现在拥有的”达到“我们现在想要的”，而不是“已经拥有”我们可能将来想要的东西。也许最容易的事情就是从头开始：所以，就这样做。
- en: Working with Independent Objects
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与独立对象协同工作
- en: The traditional way of writing and changing software has led to Continuous Deployment,
    a principle of automating the pipeline between writing source code and deploying
    the production artifact in a live environment, with a goal of reducing the time
    taken for changes to flow through the pipeline while maintaining a high level
    of quality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的编写和更改软件的方式导致了持续部署，这是一种自动化从编写源代码到在实时环境中部署生产实体的管道的原则，目标是减少更改通过管道所需的时间，同时保持高质量。
- en: Environments such as **Pharo**—[https://pharo.org/](https://pharo.org/), **SqueakJS**
    ([https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip]](https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip]),
    or even in their limited ways **Swift Playgrounds**—[https://www.apple.com/swift/playgrounds/](https://www.apple.com/swift/playgrounds/)
    and **Project Jupyter**—[https://jupyter.org/](https://jupyter.org/) show that
    this pipeline *can* be zero length, and that software can be written directly
    in the environment it is intended for. The result of a test failure does not need
    to be a log file served by Jenkins that must be pored over so a fix can be hypothesized
    in “local dev”, it can be an opportunity to correct the program running in the
    live environment and continue (or, at worst, restart) the operation that failed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pharo**（[https://pharo.org/](https://pharo.org/)）、**SqueakJS**（[https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip](https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip)）或甚至以它们有限的方式**Swift
    Playgrounds**（[https://www.apple.com/swift/playgrounds/](https://www.apple.com/swift/playgrounds/)）和**Project
    Jupyter**（[https://jupyter.org/](https://jupyter.org/)）都表明，这个管道可以是零长度的，并且软件可以直接在预期的环境中编写。测试失败的结果不需要是Jenkins提供的日志文件，必须仔细阅读以在“本地开发”中假设一个修复方案，它可以是纠正运行在实时环境中的程序的机会，并继续（或，在最坏的情况下，重新启动）失败的操作。'
- en: This liveness property is not restricted to Smalltalk-like environments or REPLs.
    Consider the Mach microkernel operating system; any server that is registered
    to the name server (or, in the case of the HURD, as a translator on the filesystem)
    is a “live object” that can receive messages from the rest of the system and participate
    in its behavior. They are also tasks that can be inspected, debugged, changed,
    restarted, or replaced.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种活跃性属性不仅限于类似Smalltalk的环境或REPLs。考虑Mach微内核操作系统；任何注册到名称服务器（或者在HURD的情况下，作为文件系统上的翻译器）的服务器都是一个“活对象”，它可以接收来自系统其余部分的消息并参与其行为。它们也是可以检查、调试、更改、重新启动或替换的任务。
- en: 'A server application composed of microservices presents similar properties.
    The “objects” (the running instances of the services) find each other by URL:
    whatever service is configured to receive HTTP requests at a given route “responds”
    to the “messages”. Each of these services can be independently inspected, debugged,
    edited, or replaced.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由微服务组成的服务器应用程序具有类似属性。“对象”（服务的运行实例）通过URL找到彼此：任何配置为在给定路由接收HTTP请求的服务“响应”消息。这些服务中的每一个都可以独立检查、调试、编辑或替换。
- en: Conclusion to Part Two
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分结论
- en: When the additional complexity, and the attempts to appeal to traditional software
    delivery techniques, are removed, Object-Oriented Programming is an attempt to
    represent complicated problems through a network of small, independent programs
    that each model one (simpler) aspect of the problem. These programs can be independently
    written, verified, deployed, changed, and used. They should ideally be ignorant
    of each other as much as possible, relying only on the knowledge that they should
    respond to certain messages and can send other messages to other objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当移除了额外的复杂性和试图采用传统的软件开发技术时，面向对象编程（Object-Oriented Programming）试图通过一组小型、独立的程序来表示复杂问题，每个程序都模拟问题的一个（更简单）方面。这些程序可以独立编写、验证、部署、更改和使用。理想情况下，它们应尽可能地对彼此一无所知，仅依赖于它们应该响应某些消息并且可以向其他对象发送其他消息的知识。
