- en: '*Chapter 2*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thesis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects Are Independent Programs
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thread running through a lot of different presentations is that objects
    are isolated computer programs that communicate by sending and receiving messages.
    Often, there is an *and*, but the second clause differs greatly. Let’s ignore
    it and focus on that first clause.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Smalltalk-80 and (most of) its descendants, objects could be
    described as isolated computer programs that communicate by sending and receiving
    messages *and* are instances of classes that are organized in a tree structure.
    The second part here, the part about classes, weakens the first part by reducing
    the scope of isolation. Why is it required that both the sender and recipient
    of a message are instances of a class, and that both classes are members of the
    same tree structure? It is not, so let’s strengthen the idea of isolated programs
    by removing the constraint on inheritance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: An existing example of an OOP environment with this form of isolation is COM
    (yes, the Microsoft **Component Object Model**, that **COM**). When you receive
    an object, you know nothing about it but that it responds to the messages defined
    in the **IUnknown**—[https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown](https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown)
    interface, which let you keep a reference to the object, relinquish that reference,
    or find out what other interfaces it supports. It tells you nothing about where
    that object came from, whether it inherited from another object, or whether it
    has fresh, hand-crafted, artisanal implementations of each of its methods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: An inference you can make about both `COM` objects and `Smalltalk` objects is
    that they exist in the same process, that is, the same blob of memory and execution
    context, as the thing sending them the message. Maybe they internally forward
    their messages over some `Smalltalk` object hogs the CPU, other objects do not
    get to run.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: So, while `Smalltalk` objects *approximate* the **isolated computer programs**
    concept, the approximation is inexact. Meanwhile, on Mach, the only thing a sender
    knows about an object is a “port,” a number that the kernel can use to work out
    what object is being messaged. An object could be on a different thread, on the
    same thread, in a different process, or (at least in theory) on a different computer,
    and sending it a message works in the same way. The receiver and the sender could
    share all of their code, inherit from a common ancestor, or be written in different
    programming languages and running on CPUs that store numbers in a different way,
    but they can still send each other a message.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Between the extreme of `Smalltalk` (all objects are the same sort of objects
    and are related to each other) and Mach there is the concept of the `MetaObject`—[http://wiki.c2.com/?MetaObjectProtocol](http://wiki.c2.com/?MetaObjectProtocol).
    As the objects in a software system define how the system models some problem,
    the metaobjects define how the software system expresses the behavior of its objects.
    The `MetaObject` protocol exposes messages that change the meaning of the *object
    model* inside the system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'A `MetaObject` protocol, in other words, lets a programmer choose different
    rules for their programming environment for different sections of their program.
    Consider method lookup, for example: in Part One, we saw how any of prototypical
    inheritance, single inheritance and multiple inheritance, have benefits and drawbacks,
    and each impose different constraints on the design of an object system. Why not
    have all of these inheritance tools – and indeed any others, and other forms of
    delegation – to hand at the same time? With a `MetaObject` protocol, that’s possible.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The Open-Closed Nature of Independent Objects
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In his book *Object-Oriented Software Construction*, *Bertrand Meyer* introduced
    the Open-Closed Principle. This principle may be one of the most confusingly stated
    ideas in all of computing and has led to a whole sub-industry of articles and
    podcasts explaining how a `ShapeRenderer` can draw `Squares` and `Circles` (of
    course, I have also partaken of such, and will continue here).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Open-Closed Principle says that a module (an object, in our case) should
    be open to extension – it should be possible to extend its behavior for new purposes
    – and yet closed to modification – you should not need to change it. This design
    principle comes with a cost, as you need to design your objects to support extensibility
    along lines that are not yet known (or at least, to make it clear which lines
    are or are not going to be fruitful) in return for the benefit that maintainers
    and users of the objects know that they are going to be stable and will not introduce
    breakages into a system through unexpected changes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The nature of objects explored above, their treatment as completely independent
    programs, supports the Open-Closed Principle by keeping each object at arm’s length
    from the others. Their only point of contact is their messaging interface, even
    to their parent classes (remembering, of course, that they may not have any).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to be open and closed, an object also needs to be ignorant: it should
    know as little as possible about its context. It knows what to do when it receives
    messages, and it knows when to send messages, but should otherwise remain uninformed
    as to what is happening around it. An ignorant object can be used in multiple
    contexts – open to extensions of its use – due to the fact that it cannot distinguish
    these contexts. It requires no contextual changes, and thus is closed to modification.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The Correctness of Independent Objects
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When each object is its own separate program, then we turn the problem of “does
    this big system work” into two separate problems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Do these independent objects work?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are these independent objects communicating correctly?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these problems has been solved repeatedly in software engineering, and
    particularly in OOP. An object’s message interface makes a natural boundary between
    “this unit” and “everything else”, for the purposes of defining unit tests. Kent
    Beck’s Test-Driven Development approach sees developers designing objects from
    the message boundary inwards, by asking themselves what messages they would like
    to send to the object and what outcomes they would expect. This answers the question
    “do these independent objects work?” by considering each of the objects as a separate
    system under test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The London School of TDD, exemplified by the book *Growing Object-Oriented Software,
    Guided by Tests*, takes an extreme interpretation of the message-boundary-as-system-boundary
    rule, by using **mock objects**—[http://xunitpatterns.com/Mock%20Object.html](http://xunitpatterns.com/Mock%20Object.html)
    as stand-ins for all collaborators of the object under test. *This* object (the
    one being tested) needs to send a message to *that* object (some collaborator),
    but there’s no reason to know anything about that object other than that it will
    respond to the message. In this way, the London School promotes the ignorance
    described above as supporting the **Open-Closed Principle**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: With the Eiffel programming language, Bertrand Meyer also addressed the question
    of whether each object works by allowing developers to associate a *contract*
    with each class. The contract is based on work Edsger Dijkstra and others had
    done on using mathematical induction to prove statements about programs, using
    the object’s message interface as the natural outer edge of the program. The contract
    explains what an object requires to be true before handling a given message (the
    preconditions), what an object will arrange to be true after executing its method
    (the postconditions), and the things that will always be true when the object
    is not executing a method (the invariants). These contracts are then run as checks
    whenever the objects are used, unlike unit tests which are only executed with
    the inputs and outputs that the test author originally thought of.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Contracts have turned up in a limited way in the traditional software development
    approach in the form of **property-based testing**—[http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html](http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html),
    embodied in Haskell’s **QuickCheck**, Scala’s **ScalaCheck**, and other tools.
    In Eiffel, the contract is part of the system being constructed and describes
    how an object is to be used when combined with other objects. Property-based tests
    encapsulate the contract as an external verifier of the object under test by using
    the contract as a test oracle from which any number of automated tests can be
    constructed. A contract might say “if you supply a list of e-mail messages, each
    of which has a unique identifier, this method will return a list containing the
    same messages, sorted by sent date and then by identifier if the dates are equal”.
    A property-based test might say “for all lists of e-mail messages with unique
    identifiers, the result of calling this method is...”. A developer may generate
    a hundred or a thousand tests of that form, checking for no counter-examples as
    part of their release pipeline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the problem – are these independent objects communicating
    correctly? – can also be approached in multiple ways. It is addressed in a contract
    world such as Eiffel by ensuring that at each point where an object sends a message
    to a collaborator, the preconditions for that collaborator are satisfied. For
    everybody else, there are integration tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'If a unit test reports the behavior of a single object, then an integration
    test is trivially any test of an assembly containing more than one object. Borrowing
    Brad Cox’s Software ICs metaphor, a unit test tells you that a chip works, an
    integration test tells you that a circuit works. A special case of the integration
    test is the system test, which integrates all of the objects needed to solve some
    particular problem: it tells you that the whole board does what it ought to.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The Design of Independent Objects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is appropriate to digress into a discussion of design here, because the
    activities of testing and design are closely related. Eric Evans’s book **Domain-Driven
    Design** discusses a form of what was previously called object-oriented analysis:
    finding the objects needed to solve a problem by interpreting a description of
    the problem. The process is straightforward. Take a description of the problem,
    and the *things* that do things are objects, the things they *do* are methods,
    and the things they *tell* or *ask* other things are messages. Evans proposes
    having a single “ubiquitous” language across the whole development team, so that
    the words used by the person who has the problem – the **Goal Donor**—[http://wiki.c2.com/?GoalDonor](http://wiki.c2.com/?GoalDonor)
    are the same words as those used by the people building the solution. Borrowing
    an idea from Christopher Alexander, it is the ubiquitous language of the problem
    and solution domain in which one would expect to find a pattern language, as common
    aspects of problems become addressed in similar ways.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior-Driven Development** marries the technical process of **Test-Driven
    Development** with the design concept of the ubiquitous language by encouraging
    developers to collaborate with the rest of their team on defining statements of
    desired behavior in the ubiquitous language and using those to drive the design
    and implementation of the objects in the solution domain. In that way, the statement
    of what the Goal Donor needs is also the statement of sufficiency and correctness
    – that is, the description of the problem that needs solving is also the description
    of a working solution. This ends up looking tautological enough not to be surprising.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Independent Objects
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The theme running through this is that sufficiency is sufficient. When an object
    has been identified as part of the solution to a problem and contributes to that
    solution to the extent needed (even if for now that extent is “demonstrate that
    a solution is viable”), then it is ready to use. There is no *need* to situate
    the object in a taxonomy of inherited classes, but if that helps to solve the
    problem, then by all means do it. There is no *need* to show that various objects
    demonstrate a strict subtype relationship and can be used interchangeably, unless
    solving your problem requires that they be used interchangeably. There is no *need*
    for an object to make its data available to the rest of the program, unless the
    problem can be better solved (or cheaper solved, or some other desirable property)
    by doing so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: I made quite a big deal earlier of the **Open-Closed Principle**, and its suggestion
    that the objects we build be “open to modification.” Doesn’t that mean that anticipating
    the ways in which a system will change and making it possible for the objects
    to flex in those ways?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: To some extent, yes, and indeed that consideration can be valuable. If your
    problem is working out how much to bill snooker players for their time on the
    tables in your local snooker hall, then it is indeed possible that your solution
    will be used in the same hall on the pool tables, or in a different snooker hall.
    But which of those will happen first? Will either happen soon? Those are questions
    to work with the Goal Donor and the **Gold Owner**—[http://wiki.c2.com/?GoldOwner](http://wiki.c2.com/?GoldOwner),
    the person paying for the solution) on answering. Is it worth paying to solve
    this related problem *now*, or not?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the answer, the fact is that the objects are still ready to go
    to work as soon as they address *the problem you have now*. And there are other
    ways to address related problems anyway, which don’t require “future-proofing”
    the object designs to anticipate the uses to which they may be put. Perhaps your
    `SnookerTable` isn’t open to the extension of representing a pool table too, but
    the rest of the objects in your solution can send messages to a `PoolPlayer` in
    its stead. As the variant on the Open-Closed Principle showed, these other objects
    could be ignorant of the game played on the table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Some amount of planning is always helpful, whether or not the plan turns out
    to be. The goal at every turn should be to understand how we get to *what we now
    want* from *what we have now*, not to *already have* that which *we will probably
    want sometime*. Maybe the easiest thing to do is to start afresh: so, do that.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Working with Independent Objects
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional way of writing and changing software has led to Continuous Deployment,
    a principle of automating the pipeline between writing source code and deploying
    the production artifact in a live environment, with a goal of reducing the time
    taken for changes to flow through the pipeline while maintaining a high level
    of quality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Environments such as **Pharo**—[https://pharo.org/](https://pharo.org/), **SqueakJS**
    ([https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip]](https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip]),
    or even in their limited ways **Swift Playgrounds**—[https://www.apple.com/swift/playgrounds/](https://www.apple.com/swift/playgrounds/)
    and **Project Jupyter**—[https://jupyter.org/](https://jupyter.org/) show that
    this pipeline *can* be zero length, and that software can be written directly
    in the environment it is intended for. The result of a test failure does not need
    to be a log file served by Jenkins that must be pored over so a fix can be hypothesized
    in “local dev”, it can be an opportunity to correct the program running in the
    live environment and continue (or, at worst, restart) the operation that failed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: This liveness property is not restricted to Smalltalk-like environments or REPLs.
    Consider the Mach microkernel operating system; any server that is registered
    to the name server (or, in the case of the HURD, as a translator on the filesystem)
    is a “live object” that can receive messages from the rest of the system and participate
    in its behavior. They are also tasks that can be inspected, debugged, changed,
    restarted, or replaced.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种活跃性属性不仅限于类似Smalltalk的环境或REPLs。考虑Mach微内核操作系统；任何注册到名称服务器（或者在HURD的情况下，作为文件系统上的翻译器）的服务器都是一个“活对象”，它可以接收来自系统其余部分的消息并参与其行为。它们也是可以检查、调试、更改、重新启动或替换的任务。
- en: 'A server application composed of microservices presents similar properties.
    The “objects” (the running instances of the services) find each other by URL:
    whatever service is configured to receive HTTP requests at a given route “responds”
    to the “messages”. Each of these services can be independently inspected, debugged,
    edited, or replaced.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由微服务组成的服务器应用程序具有类似属性。“对象”（服务的运行实例）通过URL找到彼此：任何配置为在给定路由接收HTTP请求的服务“响应”消息。这些服务中的每一个都可以独立检查、调试、编辑或替换。
- en: Conclusion to Part Two
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分结论
- en: When the additional complexity, and the attempts to appeal to traditional software
    delivery techniques, are removed, Object-Oriented Programming is an attempt to
    represent complicated problems through a network of small, independent programs
    that each model one (simpler) aspect of the problem. These programs can be independently
    written, verified, deployed, changed, and used. They should ideally be ignorant
    of each other as much as possible, relying only on the knowledge that they should
    respond to certain messages and can send other messages to other objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当移除了额外的复杂性和试图采用传统的软件开发技术时，面向对象编程（Object-Oriented Programming）试图通过一组小型、独立的程序来表示复杂问题，每个程序都模拟问题的一个（更简单）方面。这些程序可以独立编写、验证、部署、更改和使用。理想情况下，它们应尽可能地对彼此一无所知，仅依赖于它们应该响应某些消息并且可以向其他对象发送其他消息的知识。
