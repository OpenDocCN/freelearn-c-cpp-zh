- en: Chapter 2.  Its Game Time! - Designing the Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 游戏时间！ - 设计项目
- en: In the previous chapter, we covered the essential parts of our pre-established
    code base that is going to be used while creating a game. The time has come to
    take what we have learned and build upon it, by focusing on project-specific code
    that will be unique to the game we are making.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了将要用于创建游戏时预建立的代码库的基本部分。现在是时候将我们所学的内容应用于实践，通过关注项目特定的代码来构建我们正在制作的游戏的独特性。
- en: 'In this chapter, we are going to be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Implementing key entity components and systems for minimal gameplay
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现关键实体组件和系统以实现最小化游戏玩法
- en: Creating a couple of states for navigating the game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建几个状态以导航游戏
- en: Arranging all of our code into a cohesive, working project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有代码整理成一个连贯、可工作的项目
- en: We have a whole game to design, so let us get to it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个完整游戏要设计，让我们开始吧！
- en: Use of copyrighted resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的使用
- en: 'In this chapter, and for the entire length of this book, we are going to be
    using these resources:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及整本书的篇幅中，我们将使用以下资源：
- en: '*Mage City Arcanos* by *Hyptosis* under the **CC0** license (public domain): [http://opengameart.org/content/mage-city-arcanos](http://opengameart.org/content/mage-city-arcanos)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Hyptosis*创作的*法师城市Arcanos*，遵循**CC0**许可（公有领域）：[http://opengameart.org/content/mage-city-arcanos](http://opengameart.org/content/mage-city-arcanos)
- en: '*[LPC] Leaf Recolor* by *William. Thompsonj* under the **CC-BY-SA 3.0** and
    **GPL 3.0** licenses: [http://opengameart.org/content/lpc-leaf-recolor](http://opengameart.org/content/lpc-leaf-recolor)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*William. Thompsonj*创作的*[LPC] 叶子重着色*，遵循**CC-BY-SA 3.0**和**GPL 3.0**许可：[http://opengameart.org/content/lpc-leaf-recolor](http://opengameart.org/content/lpc-leaf-recolor)
- en: '*[LPC] Medieval fantasy character sprites* by *Wulax* under **CC-BY-SA 3.0**
    and **GPL 3.0** licenses: [http://opengameart.org/content/lpc-medieval-fantasy-character-sprites](http://opengameart.org/content/lpc-medieval-fantasy-character-sprites)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Wulax*创作的*[LPC] 中世纪幻想角色精灵*，遵循**CC-BY-SA 3.0**和**GPL 3.0**许可：[http://opengameart.org/content/lpc-medieval-fantasy-character-sprites](http://opengameart.org/content/lpc-medieval-fantasy-character-sprites)
- en: '*Fantasy UI Elements* by *Ravenmore* at [http://dycha.net/](http://dycha.net/)
    under the **CC-BY 3.0** license: [http://opengameart.org/content/fantasy-ui-elements-by-ravenmore](http://opengameart.org/content/fantasy-ui-elements-by-ravenmore)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Ravenmore*创作的*幻想UI元素*，可在[http://dycha.net/](http://dycha.net/)找到，遵循**CC-BY
    3.0**许可：[http://opengameart.org/content/fantasy-ui-elements-by-ravenmore](http://opengameart.org/content/fantasy-ui-elements-by-ravenmore)
- en: '*Vegur font* by *Arro* under the **CC0** license (public domain): [http://www.fontspace.com/arro/vegur](http://www.fontspace.com/arro/vegur)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Arro*创作的*Vegur字体*，遵循**CC0**许可（公有领域）：[http://www.fontspace.com/arro/vegur](http://www.fontspace.com/arro/vegur)
- en: '*Fantozzi''s Footsteps (Grass/Sand & Stone)* by *Fantozzi* under the **CC0**
    license (public domain): [http://opengameart.org/content/fantozzis-footsteps-grasssand-stone](http://opengameart.org/content/fantozzis-footsteps-grasssand-stone)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Fantozzi*创作的*Fantozzi的足迹（草地/沙地与石头）*，遵循**CC0**许可（公有领域）：[http://opengameart.org/content/fantozzis-footsteps-grasssand-stone](http://opengameart.org/content/fantozzis-footsteps-grasssand-stone)
- en: '*Electrix* (NES Version) by *Snabisch* under the **CC-BY 3.0** license: [http://opengameart.org/content/electrix-nes-version](http://opengameart.org/content/electrix-nes-version)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Snabisch*创作的*Electrix*（NES版本），遵循**CC-BY 3.0**许可：[http://opengameart.org/content/electrix-nes-version](http://opengameart.org/content/electrix-nes-version)
- en: '*Town Theme RPG* by *cynicmusic* under the **CC-BY 3.0** license: [http://opengameart.org/content/town-theme-rpg](http://opengameart.org/content/town-theme-rpg)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*cynicmusic*创作的*城镇主题RPG*，遵循**CC-BY 3.0**许可：[http://opengameart.org/content/town-theme-rpg](http://opengameart.org/content/town-theme-rpg)
- en: 'Information about all of the licenses that apply to these resources can be
    found here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些资源所适用的所有许可证的信息，可以在此找到：
- en: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
- en: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
- en: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
- en: '[http://www.gnu.org/licenses/gpl-3.0.html](http://www.gnu.org/licenses/gpl-3.0.html)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.gnu.org/licenses/gpl-3.0.html](http://www.gnu.org/licenses/gpl-3.0.html)'
- en: Entity placement and rendering
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体放置和渲染
- en: 'Let us start with the basics. Most (if not all) entities in any game we build
    are going to be positioned within the world. Let us ignore the corner cases of
    special types of entities for now. In order to represent the entity position,
    we are going to be creating a position component like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始。在我们构建的任何游戏中，大多数（如果不是所有）实体都将位于世界中。现在让我们忽略特殊类型实体的边缘情况。为了表示实体位置，我们将创建一个位置组件，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Only two things are worthy of noting here. First, the component type has to
    be set up through the `C_Base` constructor. That can be changed in the future
    if we are going to be re-designing this system, but for now this is the way to
    do it. We must also implement the `ReadIn` method, in order to be able to de-serialize
    component data properly. This means that every time an entity file is being loaded
    and the position data is encountered, it is going to read in the *x* coordinate,
    the *y* coordinate, and the elevation in this exact order.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有两件事值得注意。首先，组件类型必须通过`C_Base`构造函数来设置。如果我们将来要重新设计这个系统，这可以改变，但就目前而言，这是处理方式。我们还必须实现`ReadIn`方法，以便能够正确地反序列化组件数据。这意味着每次加载实体文件并遇到位置数据时，它将按照这个顺序读取*x*坐标、*y*坐标和海拔：
- en: 'The component itself only holds the data that is relevant to its cause. Two
    different data members for entity position are being stored here: the current
    position `m_position`, and the position of the entity one game tick ago, `m_positionOld`.
    That can be useful, should any system need to rely on position changes between
    updates.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 组件本身只持有与其原因相关的数据。这里存储了两个实体位置的数据成员：当前位置`m_position`和上一个游戏周期的实体位置`m_positionOld`。如果任何系统需要依赖更新之间的位置变化，这可能是有用的。
- en: The drawable side of things
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事物的可绘制方面
- en: 'The visual side of things is not that different to represent within the ECS
    paradigm. Because we may be dealing with more than one type of renderable objects,
    it helps out to have an interface that they all have to honor and implement:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECS范式下表示事物的视觉方面并没有太大的不同。因为我们可能要处理多种可渲染对象，所以有一个它们都必须遵守和实现的接口是有帮助的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Depending on the type and implementation of drawable components, they may rely
    on different ways of representing their position, size, and the particular method
    of being drawn. All three of these aspects need to be defined when a new drawable
    type is created, much like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据可绘制组件的类型和实现方式，它们可能依赖于不同的方式来表示其位置、大小以及特定的绘制方法。当创建一个新的可绘制类型时，这三个方面都需要被定义，就像这样：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A sprite-sheet component utilizes one of the classes we have covered back in
    [Chapter 1](ch01.html "Chapter 1. Under the Hood - Setting up the Backend") ,
    *Under the Hood - Setting up the Backend*. De-serialization for this component
    is quite simple. All it requires is the name of the sheet file, which contains
    all size, padding, space, and animation information. Because this class relies
    on the texture manager for loading its assets, a special `Create()` method is
    used in order to set up this relationship post-loading.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精灵图组件利用我们在[第1章](ch01.html "第1章。内部机制 - 设置后端")中介绍过的其中一个类，*内部机制 - 设置后端*。这个组件的反序列化相当简单。它只需要包含所有大小、填充、空间和动画信息的图文件名。因为这个类依赖于纹理管理器来加载其资源，所以使用了一个特殊的`Create()`方法来在加载后设置这种关系。
- en: Rendering system
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染系统
- en: 'With the data aspect all taken care of and out of the way, we can now focus
    on actually drawing entities on screen. This is where the very first type of system
    comes in:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理方面已经全部处理完毕并移除之后，我们现在可以专注于在屏幕上实际绘制实体。这正是第一个系统类型发挥作用的地方：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The renderer system operates on two different types of component for now: position
    and sprite sheet. Given a wider variety of drawable component types, it would,
    of course, need to include them as well. This is precisely why a bitmask data
    member with the name `m_drawableTypes` is kept around. It keeps track of all possible
    drawable component types, and will be used later to fetch actual component data.
    All of those types should be registered here.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，渲染系统操作两种不同类型的组件：位置和精灵图。如果提供了更多种类的可绘制组件类型，它当然也需要包括它们。这正是为什么保留了一个名为`m_drawableTypes`的位掩码数据成员。它跟踪所有可能的可绘制组件类型，并将被用于稍后检索实际组件数据。所有这些类型都应该在这里注册。
- en: This system also needs to be notified when an entity changes its direction,
    in order to enforce those changes on a given sprite sheet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统还需要在实体改变方向时得到通知，以便在给定的精灵图集中强制执行这些变化。
- en: 'All of the components a system uses usually need to be updated like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用的所有组件通常都需要像这样更新：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's pretty straightforward. Any and all drawable components need to have their
    positions updated in order for the simulation to be accurate. We use a private
    method to obtain a pointer to whatever drawable type the current entity has, check
    if it's not `nullptr`, and then update its position.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。为了使模拟准确，所有可绘制组件的位置都需要更新。我们使用一个私有方法来获取当前实体具有的可绘制类型的指针，检查它是否不是 `nullptr`，然后更新其位置。
- en: 'Event handling is also utilized in this system in order to achieve a *depth*
    effect by sorting entities:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理也用于这个系统，通过排序实体来实现 *深度* 效果：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we have to do here is invoke another private method that's going to sort
    all entities this system has along the *y* axis. This only needs to happen if
    an entity is moving, changing elevations, or has just spawned.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做的就是调用另一个私有方法，该方法将根据 *y* 轴对所有系统中的实体进行排序。这只有在实体正在移动、改变高度或刚刚生成时才需要发生。
- en: 'As far as entity messages go, we''re only interested in one single type, as
    should be evident from the constructor of `S_Renderer`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就实体消息而言，我们只对一种类型感兴趣，正如 `S_Renderer` 构造函数所明显显示的那样：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another private method comes to the rescue. It will be covered shortly, but
    the basic gist of it is that sprite sheets need to be informed of any direction
    changes, in order to reflect them visually.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个私有方法也派上了用场。它将在稍后进行介绍，但基本思路是精灵图集需要被告知任何方向变化，以便在视觉上反映出来。
- en: 'Since the whole point of this system is rendering our entities on screen, let''s
    do just that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个系统的整个目的是在屏幕上渲染我们的实体，让我们就这样做：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, it's fairly simple. The actual rendering is layer-based, so an argument
    is taken in for the specific layer we're currently drawing. The position component
    is obtained first in order to check if the entity's elevation matches the current
    layer being rendered. Because the game entities are always kept sorted, we know
    it's okay to break out of the loop if any given entity's elevation goes beyond
    the layer we're working with.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这相当简单。实际的渲染是按层进行的，因此传入一个参数表示我们当前正在绘制的特定层。首先获取位置组件，以检查实体的高度是否与当前正在渲染的层匹配。由于游戏实体总是保持排序，我们知道如果任何给定实体的高度超过我们正在处理的层，就可以跳出循环。
- en: Finally, the drawable component of the entity is obtained, as well as checked
    for being outside the screen area, in order to minimize unnecessary drawing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取实体的可绘制组件，并检查它是否在屏幕区域外，以最小化不必要的绘制。
- en: 'All we have left now are the private helper methods, starting with `SetSheetDirection`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下私有辅助方法了，从 `SetSheetDirection` 开始：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's nothing we haven't seen before. The entity is checked for having a sprite-sheet
    component, which then gets obtained and informed of direction changes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前都见过。检查实体是否有精灵图集组件，然后获取该组件并告知方向变化。
- en: 'This system heavily relies on entities being sorted, based on their *y* coordinate
    and elevation. For that, we use this bit of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统严重依赖于实体根据它们的 *y* 坐标和高度进行排序。为此，我们使用以下代码：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because entity identifiers are stored inside an STL container, `std::sort` comes
    to the rescue. The actual sorting gives priority to elevation; however, if two
    entities share that in common, they're sorted according to the *y* coordinate,
    going from smallest to largest.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实体标识符存储在 STL 容器中，`std::sort` 就派上用场了。实际的排序优先考虑高度；然而，如果两个实体在这一方面有共同点，它们将根据 *y*
    坐标进行排序，从小到大。
- en: 'To wrap this up, here''s a method that''s going to save us some typing, should
    additional drawable component types be added in the future:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结一下，这里有一个方法可以节省我们一些打字时间，如果将来添加了额外的可绘制组件类型：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All it does is simply iterate through all component types, looking for one that
    matches drawable types registered in the constructor of this system. Once one
    is found, the entity is checked for having that component. If it does, a pointer
    to it gets returned.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的只是简单地遍历所有组件类型，寻找与系统构造函数中注册的可绘制类型匹配的类型。一旦找到，就检查实体是否具有该组件。如果它有，就返回它的指针。
- en: Entity kinematics
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体运动学
- en: 'The code we have written so far would only produce a static, unmoving scene.
    Since that isn''t very exciting, let''s work on adding potential for entity movement.
    Since it calls for more data being stored, we need another component type to work
    with:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的代码只会产生一个静态、不动的场景。由于这并不非常令人兴奋，让我们努力添加实体运动的可能性。由于需要存储更多数据，我们需要另一种组件类型来工作：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our movement is going to be modeled by the relationships between velocity, speed,
    and acceleration. For purposes of controlling entities, a maximum velocity value
    is going to be imposed as well, in order to prevent endless acceleration. We also
    store direction with this component in order to reduce certain complexities and
    inter-component relationships; however, it could be its own separate component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过速度、速度和加速度之间的关系来模拟运动。为了控制实体，还将强制实施一个最大速度值，以防止无限加速。我们还使用此组件存储方向，以减少某些复杂性和组件间的关系；然而，它也可以是一个独立的组件。
- en: Movement system
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运动系统
- en: 'To kick this into gear, let us first take a look at what the movement system
    needs in order to work:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动这个系统，让我们首先看看运动系统需要什么才能工作：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The entity's kinematic state is going to directly control its position, so we
    need both position and movable components here. An entity message type of `Is_Moving`
    is also subscribed to. The way it is named should be a clue that this message
    is going to be used as a request for information, and its sender will be expecting
    an answer. Since this system is responsible for everything related to motion,
    it will be handling requests like this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的运动状态将直接控制其位置，因此在这里我们需要同时处理位置和可移动组件。还订阅了实体消息类型`Is_Moving`。其命名方式应该是一个线索，表明这条消息将被用作信息请求，并且发送者期望得到答复。由于该系统负责与运动相关的所有事情，它将处理此类请求。
- en: 'Next, let us update the component data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新组件数据：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After both components are obtained, they are passed into a private method that
    handles a movement step. We will be covering this later, but it's important to
    note that it takes the position component pointer in as a `const` value, which
    implies that it will be read only. This is why the position of the entity is modified
    separately one line down, by invoking its `MoveBy()` method. It simply advances
    the position by a vector, provided as the sole argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这两个组件后，它们将被传递到一个处理移动步骤的私有方法中。我们稍后会介绍这一点，但重要的是要注意，它以`const`值的形式接受位置组件指针，这意味着它只读。这就是为什么实体位置在下一行被单独修改，通过调用其`MoveBy()`方法。它只是通过提供的唯一参数（向量）推进位置。
- en: 'With a more complex system task, we obviously have more events to deal with:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的系统任务，显然有更多的事件需要处理：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will want to stop our entity on a given axis, if it is actually colliding
    with a solid. The collision event emission will be discussed when we are covering
    the collision system, so all we have to remember now is that if an entity is colliding
    on a specific axis, it needs to have its velocity reduced to `0` on that axis.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体实际上与一个固体发生碰撞，我们将希望在其给定轴上停止实体。当讨论碰撞系统时，我们将讨论碰撞事件发射，所以现在我们只需要记住的是，如果一个实体在特定轴上发生碰撞，它需要在该轴上将其速度减少到`0`。
- en: Since we are also in charge of the entity's direction, movement events are handled
    and used to update it. Direction priority is given to horizontal movement, while
    up and down directions are only set if the velocity on the *x* axis is zero.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还要负责实体的方向，因此处理运动事件并使用它们来更新它。方向优先级给予水平运动，而上下方向仅在*x*轴上的速度为零时设置。
- en: 'Back in the constructor of this system, we have subscribed to a message that
    requests movement information. Let us take a look at how that can be handled:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此系统的构造函数中，我们订阅了一个请求运动信息的消息。让我们看看如何处理它：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the entity information was requested about isn't even part of this system,
    the message gets ignored. Otherwise, the movable component is obtained and its
    velocity gets checked for not being an absolute zero. If it is, an entity event
    `Became_Idle` is sent out. This will be useful later, when we're dealing with
    entity animations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的实体信息甚至不属于该系统的一部分，则消息将被忽略。否则，将获取可移动组件并检查其速度是否不为绝对零。如果是，则发送实体事件`Became_Idle`。这将在我们处理实体动画时很有用。
- en: 'Once again, all the hard lifting exists inside our helper methods. Let''s start
    with a simple one, used to obtain tile friction for a specific coordinate in space:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有繁重的工作都在我们的辅助方法中完成。让我们从一个简单的开始，用于获取空间中特定坐标的瓷砖摩擦力：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A `null` pointer to a tile is established first. A `while` loop is then used
    to attempt to obtain an actual tile, starting with the original elevation and
    moving down until it reaches *0*. We finally return either the friction of the
    tile that was found, or the default friction of the map if it wasn''t. It comes
    into play when we''re trying to process the movement step of an entity here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先建立一个指向瓷砖的 `null` 指针。然后使用 `while` 循环尝试获取实际的瓷砖，从原始高度开始，向下移动直到达到 *0*。我们最终返回找到的瓷砖的摩擦力，或者如果没有找到，则返回地图的默认摩擦力。它在尝试处理实体的移动步骤时发挥作用：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After the friction coefficient is obtained from the current tile an entity is
    standing on, speed loss due to friction is calculated, velocity due to acceleration
    is added, acceleration itself is zeroed out, and friction is applied. In order
    to account for diagonal movement, a velocity magnitude is calculated and checked
    for exceeding the maximum allowed value. If it does, the entity's velocity is
    re-calculated based on the ratios between its current velocity and the total magnitude,
    and adjusted to fit within the provided boundaries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在从实体所站立的当前瓷砖中获取摩擦系数后，由于摩擦力而损失的速度被计算，由于加速度产生的速度被添加，加速度本身被置零，并应用摩擦力。为了考虑对角线移动，计算速度大小并检查是否超过最大允许值。如果超过了，根据其实际速度和总大小之间的比率重新计算实体的速度，并调整以适应提供的边界。
- en: 'Stopping an entity simply comes down to zeroing its velocity out on a provided
    axis, like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 停止一个实体简单来说就是将其在提供的轴上的速度置零，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Updating the entity''s direction is equally as simple, but it can''t go unnoticed
    by other systems:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更新实体的方向同样简单，但其他系统不能忽视这一点：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After the direction is updated, a new message is constructed and dispatched,
    letting the relevant systems know about the direction changes of an entity. This
    will also prove to be incredibly useful when handling entity animations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新方向后，构建并派发一个新的消息，让相关系统知道实体的方向变化。这也会在处理实体动画时证明非常有用。
- en: Handling collisions
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: 'In order to make the game we''re making feel like more than just entities moving
    across a static background with no consequences, collisions have to be checked
    for and handled. Within the ECS paradigm, this can be achieved by implementing
    a collidable component. For more flexibility, let''s define multiple points that
    the collision box can be attached to:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们所制作的游戏感觉不仅仅是在没有后果的静态背景上移动的实体，我们需要检查和处理碰撞。在ECS范式内，这可以通过实现一个可碰撞组件来实现。为了增加灵活性，让我们定义多个碰撞框可以附加的点：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **TOP_LEFT** origin simply places the collision rectangle''s top-left corner
    to the position provided. **ABS_CENTRE** moves that rectangle''s centre to the
    position, and the **MIDDLE_BOTTOM** origin places it halfway through the *x* axis
    and all the way down the *y* axis. Consider the following illustration:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOP_LEFT** 原点简单地将碰撞矩形的左上角放置在提供的位置。**ABS_CENTRE** 将该矩形的中心移动到该位置，而**MIDDLE_BOTTOM**
    原点则将其放置在*x*轴的中点和*y*轴的底部。考虑以下插图：'
- en: '![Handling collisions](img/image_02_001.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![处理碰撞](img/image_02_001.jpg)'
- en: 'With this information, let us work on implementing the collidable component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，让我们着手实现可碰撞组件：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, let us look at the data we are keeping. `sf::FloatRect` represents the
    basic **AABB** bounding box around the entity that will be used as our collider.
    We also want to be able to offset it by some value, which is going to be loaded
    from the entity file. Obviously, the origin point is stored as well, along with
    two flags that indicate whether a collision is happening on each axis.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们正在保存的数据。`sf::FloatRect` 代表围绕将要用作碰撞器的实体的基本 **AABB** 边界框。我们还想能够通过一些值来偏移它，这些值将从实体文件中加载。显然，原点点也被存储，以及两个标志，指示每个轴上是否发生碰撞。
- en: The `SetPosition()` method incorporates the use of an origin point and adjusts
    the rectangle to be positioned properly, since the native `sf::FloatRect` doesn't
    support origins by itself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetPosition()` 方法结合了原点的使用，并调整矩形以正确定位，因为原生的 `sf::FloatRect` 本身不支持原点。'
- en: Collision system
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞系统
- en: 'In order to work with and handle collisions, we only need two components:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理碰撞，我们只需要两个组件：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the `m_gameMap` data member. We're going to need to provide the collision
    system with a pointer to the game map at some point, in order to be able to handle
    map collisions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`m_gameMap`数据成员。在某个时候，我们需要向碰撞系统提供一个指向游戏地图的指针，以便能够处理地图碰撞。
- en: 'Next, let''s handle updating our component data:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理更新我们的组件数据：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, the entity's position is checked to see whether it's outside the map's
    boundaries. After it potentially has been adjusted, the `collidable` component
    is updated with the new position information, and its collision flags are reset.
    Both components are then passed into a private method that handles map collisions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查实体的位置，看它是否在地图边界之外。在可能调整后，使用新的位置信息更新`collidable`组件，并重置其碰撞标志。然后，这两个组件被传递给一个处理地图碰撞的私有方法。
- en: 'After all of the entities are checked against the map, we must check them for
    collisions against each other:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查所有实体与地图的碰撞之后，我们必须检查它们之间的碰撞：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So far, we don't really need to handle entity-on-entity collisions in any way,
    but this is an entry point for later features.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上并不需要以任何方式处理实体间的碰撞，但这将是以后功能的入口点。
- en: 'The out-of-bounds check is fairly simple:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 边界检查相当简单：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It simply checks the position for being either in negative coordinates, or outside
    the map's boundaries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地检查位置是否在负坐标或地图边界之外。
- en: 'Processing actual map collisions is further broken down into more readable
    bits:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实际处理地图碰撞被进一步分解为更易读的部分：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After a `Collisions` data type is set up, it, along with the position and collidable
    components, is passed to two private methods, which actually perform collision
    checks, and later handle them. The `Collisions` data type is just a container
    for collision information:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好`Collisions`数据类型后，它连同位置和可碰撞组件一起传递给两个私有方法，这些方法实际上执行碰撞检查，并随后处理它们。`Collisions`数据类型只是一个用于存储碰撞信息的容器：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let us focus on actually filling this structure out with useful collision information
    next:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来关注实际上填充这个结构以包含有用的碰撞信息：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method uses the entity collision box and the map tile size to establish
    a range of tiles that are intersecting with it. We then use that range to obtain
    tiles one by one, check if they exist and are solid, construct their bounding
    boxes, measure the areas of intersection, and add all of that information to the
    collision container. So far, so good!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用实体碰撞框和地图瓦片大小来确定与之相交的瓦片范围。然后我们使用这个范围逐个获取瓦片，检查它们是否存在且是实心的，构建它们的边界框，测量相交区域的面积，并将所有这些信息添加到碰撞容器中。到目前为止，一切顺利！
- en: 'The grand finale of this system is, of course, handling all of the collision
    information that got collected:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的最终大戏当然是处理收集到的所有碰撞信息：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The collision container is first checked for being empty. If it isn't, we sort
    the collision information to flow in a descending order, and use the size of the
    intersecting area for the comparison. This ensures that the collision(s) with
    the largest area of intersection come first, and thus gets handled first.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查碰撞容器是否为空。如果不为空，我们将碰撞信息排序，以便按降序流动，并使用相交区域的尺寸进行比较。这确保了具有最大相交面积的碰撞（或碰撞）首先被处理。
- en: During the processing of this information, we must first check if the entity's
    bounding box is still colliding with the tile. In case of multiple collisions,
    the first collision that got processed may have moved an entity in such a way
    that it no longer collides with anything at all.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这些信息的过程中，我们首先需要检查实体的边界框是否仍然与瓦片发生碰撞。在发生多次碰撞的情况下，首先处理的那次碰撞可能会将实体移动到不再与任何物体发生碰撞的位置。
- en: The `xDiff` and `yDiff` variables are used to hold the penetration information
    of each axis, and the `resolve` variable will be used to store exact distance
    by which the entity is going to be pushed to resolve the collision. The first
    two variables are then compared, in order to decide which axis to resolve the
    collision on. Our `resolve` variable is used to calculate the exact distance of
    the push based on whether it's a left-to-right or right-to-left collision.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`xDiff`和`yDiff`变量用于存储每个轴的穿透信息，而`resolve`变量将用于存储实体将要被推开的精确距离，以解决碰撞。然后比较这两个变量，以决定在哪个轴上解决碰撞。我们的`resolve`变量用于根据是左到右还是右到左的碰撞来计算推开的精确距离。'
- en: Finally, the position is adjusted by the resolve distance on the relevant axis,
    the collidable component's position is updated to match the changes, a colliding
    event is sent out, and the collidable component's `CollideOnX` or `CollideOnY`
    method is invoked to update the collision flags. These events then get handled
    by other systems, such as `S_Movement`, which we have already covered.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调整相关轴上的解析距离，更新可碰撞组件的位置以匹配这些变化，发送出碰撞事件，并调用可碰撞组件的`CollideOnX`或`CollideOnY`方法来更新碰撞标志。然后这些事件被其他系统处理，例如我们之前提到的`S_Movement`。
- en: Controlling entities
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制实体
- en: 'Since we have already laid down the code foundation, it''s now possible to
    focus on controlling the entities on the screen. Whether they''re being controlled
    as player avatars by means of a keyboard, or through some sort of **artificial
    intelligence** (**AI**), they still need to have this basic component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经奠定了代码基础，现在可以专注于控制屏幕上的实体。无论是通过键盘控制作为玩家角色，还是通过某种形式的**人工智能**（**AI**），它们仍然需要这个基本组件：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can tell, we have absolutely no data that gets stored here so far. For
    now, it can simply be considered just a specific signature that lets the ECS know
    it can be controlled.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，到目前为止，我们在这里绝对没有任何数据被存储。现在，它可以简单地被认为是一个特定的签名，让ECS知道它可以被控制。
- en: Control system
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制系统
- en: 'In order for entities to be controlled, they must have three basic component
    types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制实体，它们必须具有三种基本组件类型：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Actual control happens through the event system:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的控制是通过事件系统来实现的：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The movement itself is just a modification of the movable component, as shown
    here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运动本身只是对可移动组件的修改，如下所示：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `C_Movable` component type takes care of actually modifying its data. All
    we need to do is pass in a valid direction.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`C_Movable`组件类型负责实际修改其数据。我们只需要传递一个有效的方向。'
- en: Entity states
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体状态
- en: 'Having entities that are able to move around now implies they can either be
    standing still or moving. This quickly brings about the issue of entity states.
    Luckily, we have an elegant way of dealing with that, by introducing another component
    type and a system. Let''s start by enumerating all possible entity states, and
    using the enumeration to establish a component type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实体能够移动意味着它们要么是静止的，要么是在移动。这迅速引发了实体状态的问题。幸运的是，我们有一个优雅的方式来处理这个问题，通过引入另一个组件类型和一个系统。让我们首先列举所有可能的实体状态，并使用枚举来建立组件类型：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That's all we have to keep track of inside the component class. Time to move
    on to the system!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在组件类中跟踪的所有内容就是这些。现在是时候继续到系统部分了！
- en: State system
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态系统
- en: 'Because state is not directly tethered to any other data, we can only require
    one component type to be present in order to work with states:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为状态并没有直接绑定到其他任何数据上，所以我们只能要求存在一种组件类型来处理状态：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This system also needs to subscribe to two different message types: `Move`
    and `Switch_State`. The action of movement is obviously state-dependent, since,
    for example, an entity shouldn''t be able to move if it is dead.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统还需要订阅两种不同的消息类型：`Move`和`Switch_State`。显然，动作是依赖于状态的，例如，如果一个实体已经死亡，它就不应该能够移动。
- en: 'Updating entities with a state is fairly basic, since we''re about to utilize
    the movement system indirectly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态更新实体相当基础，因为我们即将间接利用运动系统：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All we care about so far is if the state of the current entity is `Walking`,
    but the entity has gone idle. For that, we can send out the `Is_Moving` message,
    which the `S_Movement` is going to respond to with an event, given that the entity
    has stopped. That event is then handled here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们关心的是当前实体的状态是否为`Walking`，但实体已经处于空闲状态。为此，我们可以发送出`Is_Moving`消息，如果实体已经停止，`S_Movement`将响应这个事件。然后这个事件在这里被处理：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A private method for changing an entity's state is invoked, setting it to `Idle`.
    Kids' stuff!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个私有方法来改变实体的状态，将其设置为`Idle`。小菜一碟！
- en: 'Next, let us handle the message types this system is subscribed to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理这个系统订阅的消息类型：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since actual entity movement depends on its state, this is the system that decides
    whether there is movement or not. The entity's state is first checked, to make
    sure it can't move if it's dying. An `EntityEvent` structure is then constructed
    and set to match the direction of the `Move` message. After the event is dispatched,
    the entity's state is changed to `Walking`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际实体移动取决于其状态，因此这是决定是否有移动的系统。首先检查实体的状态，以确保它不能移动如果它正在死亡。然后构建一个`EntityEvent`结构并将其设置为与`Move`消息的方向匹配。事件派发后，实体的状态将更改为`Walking`。
- en: 'Other systems within the ECS may care about the state of an entity changing.
    For that, we need to handle these changes accordingly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ECS中的其他系统可能关心实体状态的改变。为此，我们需要相应地处理这些更改：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note the last argument of this method. It indicates whether the state change
    should be forced or not. This is done to ensure that certain state changes can
    be defined as non-critical, and should be ignored if an entity is dying.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个方法最后一个参数。它指示状态更改是否应该被强制执行。这样做是为了确保某些状态更改可以定义为非关键性，如果实体正在死亡，则应该忽略。
- en: If the state ends up getting changed, the component data is updated, and a new
    `State_Changed` message is dispatched to inform other systems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态最终被更改，组件数据将被更新，并且将派发一个新的`State_Changed`消息来通知其他系统。
- en: Sheet animation system
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纸张动画系统
- en: 'One of the objects sensitive to state changes is the sprite sheet animation
    system. Knowing an entity''s state is of paramount importance, if we desire to
    apply animations that describe its current action:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对状态更改敏感的对象之一是精灵图集动画系统。如果我们希望应用描述其实际动作的动画，了解实体的状态至关重要：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, all we need are two component types and a subscription to a
    message type of `State_Changed`. So far, so good!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要的只是两种组件类型和一个订阅`State_Changed`消息类型。到目前为止，一切顺利！
- en: 'Updating the sprite sheets can get a little involved, so let us delve right
    into it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更新精灵图集可能有点复杂，所以让我们直接深入探讨：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After the sprite sheet and state components are obtained, the sheet gets updated.
    The name of its current animation is then obtained. Keep in mind that certain
    entity states are dependent on the current animation, and as soon as that animation
    is over, we want to switch back to an idle state. For example, the attack animation
    is first checked for no longer playing. If that's the case, a message is sent
    to the state system, letting it know that this entity's state needs to be switched
    to idle. Additionally, the animation's action range is checked, which is used
    to determine whether, for example, the current frames of the attack animation
    are of the character swinging the sword just right, where we can inflict damage.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 获取精灵图集和状态组件后，图集将被更新。然后获取其当前动画的名称。请注意，某些实体状态取决于当前动画，并且一旦该动画结束，我们希望切换回空闲状态。例如，首先检查攻击动画是否不再播放。如果是这样，则向状态系统发送消息，让它知道这个实体的状态需要切换到空闲。此外，检查动画的动作范围，这用于确定例如，攻击动画的当前帧是否是角色挥舞剑的正确时机，我们可以造成伤害。
- en: The exact same principle applies to the death animation, except the message
    that gets sent out once that is finished is different.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与死亡动画的原理完全相同，只是在完成时发送的消息不同。
- en: Finally, every single animation has to be checked for frame progression, in
    which case a message gets sent out, notifying systems interested in that type
    that the animation frame has changed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须检查每个动画的帧进度，在这种情况下，将发送消息，通知对该类型感兴趣的系统动画帧已更改。
- en: 'As mentioned before, sprite sheets need to know if the entity''s state has
    changed. This is where we handle that:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，精灵图集需要知道实体的状态是否已更改。这就是我们处理的地方：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This essentially just maps the name of a specific animation to a state. The
    private method used to set that up is quite simple:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只是将特定动画的名称映射到状态。用于设置此状态的私有方法相当简单：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It takes in the entity identifier, the name of the animation, a flag for whether
    the animation should be played automatically, and another flag for whether it
    should loop. The sprite sheet that sits inside the component is then requested
    to play the animation provided.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受实体标识符、动画名称、一个标志表示动画是否应该自动播放，以及另一个标志表示是否应该循环。然后请求组件内的精灵图集播放提供的动画。
- en: Entity sounds
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体声音
- en: 'Just like states, an entity can emit multiple different types of sound. Each
    different type must also have certain parameters associated with it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像状态一样，一个实体可以发出多种不同类型的声音。每种不同类型也必须与某些参数相关联：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`struct SoundParameters` simply stores the name of the sound, as well as an
    array of integers for the maximum number of sound frames. A sound frame is the
    glue between sounds and sprite sheets, as it defines during which animation frames
    the sound is emitted.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct SoundParameters`仅仅存储声音的名称，以及一个整数数组，表示声音帧的最大数量。声音帧是声音和精灵图集之间的粘合剂，因为它定义了在哪些动画帧期间发出声音。'
- en: 'Having defined the previous data structure allows us to successfully create
    a sound emitter component type:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了前面的数据结构后，我们可以成功创建一个声音发射器组件类型：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The only data we are storing here is an array of `SoundParameter` objects for
    each type of `EntitySound` enum, and a `SoundID` data member, which is going to
    be used in the sound system, in order to make sure only one entity sound is playing
    at the same time. The large method for de-serialization simply deals with correctly
    loading in the sound frames.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里存储的唯一数据是每个`EntitySound`枚举类型的`SoundParameter`对象数组，以及一个`SoundID`数据成员，它将在声音系统中使用，以确保同一时间只有一个实体声音正在播放。用于反序列化的长方法只是正确加载声音帧。
- en: 'Another, much more basic component type we need before we can proceed is a
    sound listener:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以继续之前，还需要另一个更基本的组件类型，即声音监听器：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This, much like `C_Controller`, is basically just a flag that lets the sound
    system know that the entity that has it should be treated as the listener. We
    need to be careful with this, since there should only ever be one sound listener
    present at a time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这，就像`C_Controller`一样，基本上只是一个标志，让声音系统知道拥有它的实体应该被视为监听器。我们需要小心处理这一点，因为任何时候都应该只有一个声音监听器存在。
- en: Sound system
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音系统
- en: 'The system in charge of managing entity sounds uses the component signature
    bitmask in a way that allows multiple different compositions to be recognized:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 负责管理实体声音的系统使用组件签名掩码的方式，允许识别多种不同的组合：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We want entities with a position component, as well as an emitter and/or listener
    component. The message of type `Direction_Changed` is also subscribed to, as well
    as `Frame_Change`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实体具有位置组件，以及发射器或监听器组件。同时订阅了类型为`Direction_Changed`的消息以及`Frame_Change`。
- en: 'Updating these components looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 更新这些组件看起来是这样的：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The entity is checked for being a sound listener. If it is, the SFML's sound
    listener position is set to the position of the entity, with elevation included.
    We utilize a private helper method here, to construct a 3D vector, which will
    be covered shortly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实体被检查是否是一个有效的监听器。如果是，SFML的监听器位置被设置为实体的位置，包括高度。在这里我们使用一个私有辅助方法来构建一个3D向量，这将在稍后进行介绍。
- en: If the entity has a sound emitter component, and its sound identifier isn't
    equal to `-1`, which would indicate that no sounds are playing, the sound's position
    is attempted to be updated, provided the entity isn't a sound listener. If either
    the position update fails, or the sound is no longer playing, its identifier is
    set back to `-1`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体有一个声音发射器组件，并且其声音标识符不等于`-1`，这表示没有声音正在播放，那么如果实体不是监听器，将尝试更新声音的位置。如果位置更新失败，或者声音不再播放，其标识符将被设置回`-1`。
- en: 'Next up is message handling:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是消息处理：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We should only care about the direction change message if our entity is a sound
    listener, in which case the global sound listener direction is simply updated
    to reflect the changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只关心方向改变消息，如果我们的实体是一个监听器，在这种情况下，全局监听器方向简单地更新以反映这些变化。
- en: 'If a frame is changed, we make sure the entity is a sound emitter first. If
    it is, its current state is matched to a sound type that would play. The private
    `EmitSound` method is then invoked:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果帧发生变化，我们首先确保实体是一个声音发射器。如果是，它的当前状态将与一个将要播放的声音类型相匹配。然后调用私有的`EmitSound`方法：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After all the component and entity checks have passed, the sound emitter is
    checked for not emitting another sound already in case we want to use the existing
    ID. The sound frame is then checked, and the position for the sound is calculated
    based on whether the entity is a listener or not. Finally, based on whether we're
    using the sound ID or not, the sound manager's `Play` method is invoked, and its
    return sound ID is possibly stored.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有组件和实体检查通过之后，检查声音发射器是否已经发出另一个声音，以防我们想使用现有的 ID。然后检查声音帧，并根据实体是否是监听器来计算声音的位置。最后，根据我们是否使用声音
    ID，调用声音管理器的 `Play` 方法，并可能存储其返回的声音 ID。
- en: 'To conclude the sound topic within ECS, as well as the entire ECS portion of
    this chapter, let''s look at how we construct a 3D sound position based on the
    entity''s *x* and *y* positions, as well as its elevation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 ECS 中结束声音主题，以及本章整个 ECS 部分，让我们看看我们是如何根据实体的 *x* 和 *y* 位置以及其海拔来构建 3D 声音位置的：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `z` member of `sf::Vector3f` is used to store the *height*, which is simply
    the elevation multiplied by the tile size.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Vector3f` 的 `z` 成员用于存储 *高度*，这仅仅是海拔乘以瓦片大小。'
- en: Implementing the menu state
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现菜单状态
- en: 'With most of the backend already covered, we''re ready to move towards the
    front, and start working on more interactive aspects of the project, such as interfaces.
    Let''s start by creating a main menu:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端的大部分内容已经介绍完毕后，我们准备转向前端，开始处理项目的更多交互式方面，例如界面。让我们先创建一个主菜单：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All of these classes have already been covered in [Chapter 1](http://Chapter
    1) , *Under the Hood - Setting up the Backend*, but let us have a quick rundown
    of what this does once more. After we obtain the shared context, a main menu interface
    is loaded and positioned on screen. The `m_eventManager` is then used to bind
    the main menu button clicks to methods of this class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类已经在 [第 1 章](http://Chapter 1) 中介绍过，*内部结构 - 设置后端*，但让我们再次快速概述一下它做了什么。在获得共享上下文后，加载主菜单界面并将其放置在屏幕上。然后使用
    `m_eventManager` 将主菜单按钮点击绑定到这个类的函数上。
- en: 'These resources/bindings obviously have to be removed when the state is destroyed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源/绑定显然在状态销毁时必须移除：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Upon activation of the main menu state, we are going to want to check if a
    game state has already been added:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活主菜单状态时，我们将想要检查是否已经添加了游戏状态：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This ensures that the first button in the menu accurately reflects the existence/lack
    of a game state.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了菜单中的第一个按钮准确地反映了游戏状态的存在/不存在。
- en: 'Finally, here are the callbacks of the main menu buttons:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是主菜单按钮的回调函数：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In case of the play button being clicked, we switch to a game state, whether
    or not it exists yet. The quit button, on the other hand, would reach the window
    class and close it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击播放按钮，我们将切换到游戏状态，无论它是否存在。另一方面，退出按钮会到达窗口类并关闭它。
- en: Implementing the game state
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏状态
- en: 'Now it''s getting more interesting. The game state is where all of the fun
    happens, so we need to make sure it''s set up properly. Let us start, as per usual,
    with the creation of the state:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在越来越有趣了。游戏状态是所有乐趣发生的地方，因此我们需要确保它被正确设置。让我们像往常一样，从创建状态开始：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: First, all of the relevant events we're interested in are bound to methods of
    this class. This includes the escape key, which simply switches back to the menu
    state, and four player movement keys. The view of this state is then set up to
    be zoomed in slightly more, just to be able to see the character better.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将所有我们感兴趣的相关事件绑定到这个类的函数上。这包括退格键，它只是简单地切换回菜单状态，以及四个玩家移动键。然后设置这个状态的观点，以便稍微放大，以便更好地看到角色。
- en: The last couple of lines obtain the loading state, and add the game map and
    the tile set to it as loaders right after the map and tile set files to be loaded
    are added.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行获取加载状态，并将游戏地图和瓦片集作为加载器添加到其中，紧随地图和瓦片集文件之后。
- en: 'Naturally, these callbacks are going to need to be unbound upon the destruction
    of the state:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这些回调在状态销毁时将需要解除绑定：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that both the game map and the tile set are both purged here as well.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，游戏地图和瓦片集也在这里被清除。
- en: 'Updating the game state only comes down to updating its own camera, alongside
    the game map and the ECS system manager:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更新游戏状态仅涉及更新其自己的相机，以及游戏地图和 ECS 系统管理器：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The camera (or the view) of the state is updated like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的相机（或视图）更新如下：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This can look like a lot, but the basic gist of it is first obtaining the position
    of our player, and then using those coordinates to either centre the view on,
    or position it in such a way that the very edge of the map is at the edge of the
    view. The idea is not moving the state view beyond the borders of the map.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很多，但基本思路是首先获取我们玩家的位置，然后使用这些坐标来使视图居中，或者以这种方式定位，使得地图的边缘正好在视图的边缘。想法是不将状态视图移动到地图之外。
- en: 'Drawing is also fairly straightforward:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制也是相当直接的：
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A loop is started for each layer/elevation the game map supports. The map data
    of that layer is drawn first, and is followed by the system manager drawing entities
    on that layer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏地图支持的每个层/海拔，都会启动一个循环。首先绘制该层的地图数据，然后系统管理器在该层上绘制实体。
- en: 'Let us take a look at the callback method for our player movement:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的玩家移动的回调方法：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Whenever this is invoked, a new `Move` message is constructed. The direction
    it carries is set, based on the actual event name. After the receiving entity
    (the player) is stored, the message is dispatched.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此方法时，都会构建一个新的`Move`消息。它携带的方向基于实际的事件名称设置。在存储接收实体（玩家）后，消息被分发。
- en: 'Lastly, we have one callback and the state''s activation method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个回调和状态激活方法：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the *Esc* key is pressed, we simply switch to the main menu state. If the
    state is then switched back to `Game`, the `Activate` method of it is invoked.
    We use that functionality to re-obtain the player ID, in case it changed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下*Esc*键，我们简单地切换到主菜单状态。如果状态随后切换回`Game`，则调用它的`Activate`方法。我们使用这个功能来重新获取玩家ID，以防它已更改。
- en: The main game class
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主游戏类
- en: 'All we have left to do now is to put everything together. We''re going to be
    using a `Game` class for that, so let''s take a look at it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的就是将所有东西组合在一起。我们将使用一个`Game`类来完成这个任务，所以让我们来看看它：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This class holds all of the classes that we covered, so let us begin setting
    them up in the constructor:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含了我们讨论过的所有类，所以让我们从构造函数开始设置它们：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The initializer list is used to set up whatever dependencies our classes have
    that need to be satisfied inside their constructors. The rest of the constructor
    body is used to invoke three private *setup* methods, as well as to require the
    main font that is to be used throughout the game, and switch to the `Intro` state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化列表用于设置我们类中需要在其构造函数内满足的任何依赖项。构造函数体的其余部分用于调用三个私有*setup*方法，以及要求使用整个游戏的主字体，并切换到`Intro`状态。
- en: 'We''re going to need a couple of basic setters and getters from this class
    as well:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从这个类中获取一些基本的设置器和获取器：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With that out of the way, let us actually update all of our code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们实际更新所有代码：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: After the relevant managers are updated, the GUI events are polled and passed
    to the event manager to be handled.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关管理器更新后，轮询GUI事件并将它们传递给事件管理器进行处理。
- en: 'Next, let us take a look at what needs to happen during the `Render` call:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在`Render`调用期间需要发生什么：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is fairly basic as well. Since we're going to always want to draw states,
    the state manager's `Draw` call is placed here. On top of that (quite literally),
    we're going to always draw the GUIs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很基础。由于我们总是想绘制状态，所以将状态管理器的`Draw`调用放在这里。实际上，我们还将始终绘制GUI。
- en: 'A nice little feature to have is a late update that can be used to process
    anything that can''t go into regular updates:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的小功能是后期更新，可以用来处理无法进入常规更新的任何内容：
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The state manager's removal requests are processed here, in addition to the
    game clock being restarted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里处理状态管理器的移除请求，以及重新启动游戏时钟。
- en: 'One of the three private methods invoked in the constructor that helps us set
    up all the classes can be implemented like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中调用的三个私有方法之一，帮助我们设置所有类，可以像这样实现：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: After the random number generator is seeded, we need to make sure to bind every
    single class to the shared context, in order to be able to access them anywhere
    a service locator pattern is relied upon.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机数生成器初始化后，我们需要确保将每个类绑定到共享上下文，以便能够在任何依赖服务定位器模式的地方访问它们。
- en: 'Another set up function we invoked deals with setting up the entity component
    system:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们调用的设置函数处理的是设置实体组件系统：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, all of the component types and systems are added and set up for use. The
    collision and movement systems need to have access to the game map, while the
    sound system relies on the audio and sound managers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有组件类型和系统都被添加并设置好以供使用。碰撞和运动系统需要访问游戏地图，而声音系统则依赖于音频和声音管理器。
- en: 'The last bit of setup is related to states and their dependents:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的设置与状态及其依赖项有关：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The event, GUI, and sound managers all rely on being kept up to date on all
    state changes, so they must be registered as dependents. Also, our three main
    state types that we will be using are registered as well, so that they can be
    created using the factory method inside the state manager.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 事件、GUI和声音管理器都需要保持对所有状态变化的最新了解，因此它们必须被注册为依赖项。此外，我们将使用的三个主要状态类型也已注册，这样它们就可以在状态管理器内部使用工厂方法创建。
- en: The final bit of code
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的最后部分
- en: 'Lastly, the main entry point of our application is defined inside the main
    function, like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应用程序的主要入口点定义在`main`函数内部，如下所示：
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: After an instance of `Game` is set up, we begin a `while` loop that keeps running
    until the `Window` instance is closed. Inside the loop, we update the game, render
    it, and call the late update method as well, for all of those post-rendering tasks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好`Game`实例后，我们开始一个`while`循环，该循环会一直运行，直到`Window`实例被关闭。在循环内部，我们更新游戏，渲染它，并调用后期更新方法，以处理所有那些渲染后的任务。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, it's a good time to wrap up. If you have followed through to the
    end, congratulations! You have just built a basic, fully functioning game out
    of nothing but a couple of states, some components, and systems. This chapter,
    much like the one before, is quite condensed, so feel free to look through the
    code and feel comfortable with its structure.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是收尾的好时机。如果你一直跟到最后，恭喜你！你只用几个状态、一些组件和系统就构建了一个基本且完全功能的游戏。本章，就像之前的一章一样，相当紧凑，所以请随意查看代码，并对其结构感到舒适。
- en: In the next chapter, we're going to be focusing solely on implementing and using
    particle systems in order to really add some life to the bare-bones game we have
    made. See you there!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将专注于实现和使用粒子系统，以真正为我们的基础游戏增添活力。那里见！
