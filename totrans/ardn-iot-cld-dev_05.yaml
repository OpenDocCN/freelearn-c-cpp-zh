- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project #2 – Creating a Portable Thing Tracker Using MKR GSM 1400'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to **smart transportation** and **smart remote monitoring**.
    It shows how cellular communication-enabled devices can be integrated with the
    **Arduino IoT Cloud** platform, and it also offers an example of using a **global
    IoT SIM card** for communication.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will practically explore **Long-Term Evolution** (**LTE**) technologies,
    which are very useful in remote monitoring and control, whether they involve asset
    tracking or remote operation monitoring. This project uses the **Arduino MKR GSM
    1400** development board, which is equipped with the latest communication bands
    and was specially designed for **Industrial Internet of Things** (**IIoT**) and
    **Internet of Things** (**IoT**) use cases. This project practically explains
    how you can develop a tracking solution based on cellular communications for different
    use cases. This chapter will help you to understand cellular communication technology,
    global IoT SIM cards, and the integration of Arduino IoT Cloud using cellular
    technology. By the end of this chapter, you will be able to develop solutions
    for remote areas using cellular technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing operations with IoT asset tracking and remote control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the advantages of GSM/LTE/NB-IoT communication technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless global connectivity with IoT SIM cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks – sensors and development boards for IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the project architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating SIM cards for IoT deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Thing, network credentials, cloud variables, and code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating comprehensive web and mobile dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the hardware components required to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: MKR GSM 1400/MKR NB 1500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hologram global IoT SIM card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A NEO-6M GPS module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For coding, we will use the **Arduino Web Editor**, which includes a large collection
    of development boards and sensor libraries, as well as Arduino IoT Cloud for Thing
    and dashboard setup. To develop hardware and sensor designs, we need the **Fritzing**
    desktop software, and we need **Arduino IDE** for GPS module testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the **Arduino IoT SIM card** for communication
    instead of local SIM providers. Arduino provides a wide variety of data plans
    for global IoT sim cards that can be chosen according to requirements. The code
    for this chapter is available at the book’s official GitHub repository at this
    link: https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing operations with IoT asset tracking and remote control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IoT** technology can be very useful for asset tracking and remote controlling
    and monitoring operations. By installing sensors on assets and connecting them
    to a central network, you can track the location and status of your assets in
    real time. Here are some ways in which IoT can be used for asset tracking and
    remote controlling and monitoring operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asset tracking**: By installing GPS trackers or RFID tags on your assets,
    you can track their location and movements in real time. This can be very useful
    for logistics and supply chain management, as well as fleet management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition monitoring**: By installing sensors on your assets, you can monitor
    their condition and performance in real time. This can help you identify potential
    problems before they become serious and take corrective action to prevent downtime
    and reduce maintenance costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictive maintenance**: By analyzing data from your sensors, you can use
    machine learning algorithms to predict when maintenance is needed on your assets.
    This can help you schedule maintenance at the most convenient time and avoid unplanned
    downtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote control**: By connecting your assets to a central network, you can
    control them remotely from a central location. This can be very useful for operations
    that are located in remote areas or difficult to access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote monitoring**: By installing cameras and other sensors on your assets,
    you can monitor their operations remotely in real time. This can help you identify
    potential problems and take corrective action quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, IoT technology can be very useful for asset tracking and remote controlling
    and monitoring operations. By leveraging the power of sensors, data analytics,
    and machine learning, you can improve the efficiency and reliability of your operations
    while reducing costs and downtime. In this section, we have discussed IoT for
    asset tracking and remote monitoring using cellular technology. Next, we will
    cover different communication technologies that are available now and coming to
    market in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the advantages of GSM/LTE/NB-IoT communication technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Global System for Mobile communication** (**GSM**), LTE, and **NarrowBand-Internet
    of Things** (**NB-IoT**) are all wireless communication technologies that are
    widely used for mobile communications and IoT devices. Each technology has its
    own pros and cons, and the choice of which technology to use depends on the specific
    requirements and solution design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the reasons why GSM, LTE, or NB-IoT are often chosen over
    other communication technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wide coverage**: GSM and LTE networks have extensive coverage and are available
    in most parts of the world, making them ideal for global connectivity. NB-IoT,
    on the other hand, has been designed specifically for IoT devices and offers greater
    coverage in hard-to-reach areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High data rates**: LTE offers high data rates, making it suitable for applications
    that require fast and reliable data transfer. NB-IoT, although slower, still offers
    better data rates than other **Low-Power Wide-Area Network** (**LPWAN**) technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: GSM and LTE networks offer high levels of security, with features
    such as encryption and authentication to protect against eavesdropping and other
    forms of cyberattacks. NB-IoT also provides end-to-end encryption for data security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility**: GSM and LTE networks are backward compatible with previous
    generations of technology, allowing for seamless integration with existing infrastructure.
    NB-IoT is also designed to be compatible with LTE networks, making it easy to
    add IoT capabilities to existing LTE networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battery life**: NB-IoT and other LPWAN technologies are designed to consume
    minimal power, resulting in longer battery life for connected devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, GSM, LTE, and NB-IoT are widely used communication technologies that
    offer reliable connectivity, high data rates, security, and compatibility with
    existing infrastructure. Here, we have discussed the benefits of GSM/LTE/NB-IoT
    communication technologies over other wireless communication technologies. In
    the next section, we are going to cover global IoT SIM cards, which is the main
    pillar of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless global connectivity with IoT SIM cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global IoT SIM cards are specifically designed for IoT devices that require
    cellular connectivity to communicate with the internet or other connected devices.
    These SIM cards provide access to multiple networks, allowing devices to roam
    across different countries and regions without the need to switch between SIM
    cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Global IoT SIM cards typically offer features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-network coverage**: These SIM cards can connect to multiple cellular
    networks, including GSM, LTE, and other emerging technologies, such as NB-IoT
    and **Cat-M**, to provide reliable coverage in different locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Over-the-air** (**OTA**) **updates**: Many global IoT SIM card providers
    offer OTA updates, enabling devices to receive firmware and software updates without
    the need for physical intervention, improving efficiency and reducing maintenance
    costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data plans**: Global IoT SIM card providers offer flexible data plans that
    can be customized to suit the specific needs of a device or application. This
    includes data allowances, data speed, and the ability to add more data as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Global IoT SIM cards typically come with security features such
    as encryption and authentication to protect data and prevent unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management tools**: Many global IoT SIM card providers offer web-based portals
    or mobile apps that allow users to monitor and manage their SIM cards, including
    data usage, network performance, and billing information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global IoT SIM cards provide a cost-effective and flexible solution for companies,
    allowing them to deploy IoT devices worldwide. They allow seamless connectivity,
    ensuring that devices are always connected to the best available network, regardless
    of location.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many IoT global SIM service providers. Here is a list of some of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: Hologram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soracom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino SIM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twilio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emnify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aeris
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KORE Wireless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sierra Wireless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleena
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thales Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UROS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1oT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Before buying an IoT global SIM card from any service provider, please verify
    whether it works in your region or not and, if so, what type of services it offers,
    such as GSM, **3G**/**4G**, or NB-IoT, as there are many regions where, for example,
    NB-IoT services are still not available.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is not a complete list, and there are many other IoT SIM
    providers available in the market. It’s important to research and compare different
    providers based on your specific requirements and needs before making a decision.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have discussed global IoT SIM cards in detail and listed all the top
    global IoT SIM card service providers. Next, we are going to cover what types
    of hardware and sensors are required to complete the chapter’s project.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks – sensors and development boards for IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino series has a wide collection of development boards that vary in
    size, pins, and communication technologies. In this chapter, I will use an Arduino
    MKR GSM 1400 development board, as it’s compact, battery-enabled, and provides
    the support of GSM/3G/4G. *Figure 5**.1* shows the pinout diagram for the MKR
    GSM 1400.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Arduino MKR GSM 1400](img/B19752_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Arduino MKR GSM 1400
  prefs: []
  type: TYPE_NORMAL
- en: Arduino MKR GSM 1400 provides 7 analog pins and 14 digital input/output pins,
    with built-in battery charging and a LiPo battery connector for standby power,
    which helps developers build prototypes and solutions for remote monitoring/operations
    without worrying about power backups. For further details, please visit the official
    website at [https://store-usa.arduino.cc/products/arduino-mkr-gsm-1400](https://store-usa.arduino.cc/products/arduino-mkr-gsm-1400).
  prefs: []
  type: TYPE_NORMAL
- en: Arduino’s latest development board, MKR NB 1500, only supports NB-IoT, **LTE-M**,
    and **Enhanced GPRS** (**EGPRS**) for SMS. NB-IoT and LTE-M are specially designed
    for IoT devices, and their popularity is spreading very rapidly across different
    regions. For complete details and specifications, visit [https://store-usa.arduino.cc/products/arduino-mkr-nb-1500](https://store-usa.arduino.cc/products/arduino-mkr-nb-1500).
    For a list of updated regions where NB-IoT and LTE-M are deployed, visit [https://www.gsma.com/iot/deployment-map/](https://www.gsma.com/iot/deployment-map/).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will track the assets based on GPS location. To get the
    GPS coordinates, we will use the **GY-GPS6MV2 GPS module**, which is based on
    the **NEO-6M u-blox** chip. The GPS module communicates on both software serial
    and hardware serial ports, but MKR GSM 1400 provides a built-in hardware serial,
    so we will use *Pins 13* and *14* to communicate with the GPS module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GPS module provides latitude, longitude, satellite count, altitude feet,
    and speed per mile data. We will display these properties on the dashboard for
    proper asset tracking. This module was developed in China and is available on
    the market at affordable prices, but there are many other organizations that develop
    GPS modules based on the NEO-6M u-blox chip, such as **SparkFun**, **Seeed Studio**,
    and **Adafruit**. *Figure 5**.2* shows the NEO-6M u-blox GPS module and its pinout
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The NEO-6M u-blox GY-GPS6MV2 GPS module and a pinout diagram](img/B19752_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The NEO-6M u-blox GY-GPS6MV2 GPS module and a pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure illustrates the pinout layout of the GPS module. *Pin
    #1* is a **ground** (**GND**) pin that connects with the onboard GND, while *Pin
    #2* and *Pin #3* are **transmit** (**TX**) and **receive** (**RX**) pins, respectively,
    and connect to *Pin #13* and *Pin #14* of MKR GSM 1400, respectively. *Pin #4*
    – the **voltage common collector** (**VCC**) – works with both onboard VCC and
    5V pins. You can solder the male headers with the GPS module or directly solder
    the cables without any header pins.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The GPS module works optimally in an outdoor environment. Make sure there is
    no rooftop during testing and deployment to receive a proper signal from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the module in a lab, then there will be a chance that the GPS
    module will not work properly. Remember that there is a built-in light in the
    GPS module that blinks when you start receiving signals from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the MKR GSM 1400 development board, which is a
    SIM-enabled board, and the NEO-6M u-blox GPS module, which will provide the GPS
    coordinates to the development board. We also discussed their pin layouts. Next,
    we will discuss how to connect the GPS module with the MKR GSM 1400 development
    board.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, we discussed the module and development board in
    detail. Now, it’s time to cook the recipe. In hardware development, before starting
    to work with sensors and development boards, we need to develop the design concepts
    to get a better understanding of how things will connect. There is a lot of software
    that is available to design and develop design concepts for an electronics project,
    but in this case, we will use Fritzing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, we will talk about schematics and designing
    a project, while explaining how to connect pins with a development board and soldering.
    Then, we will do some tests to fetch GPS coordinates, which is very important
    before sending data to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Schematic design and assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of your schematic design is to get a clear understanding of how
    sensors will connect with a development board. Schematic diagram helps you to
    develop a prototype on a breadboard or a **Veroboard,** which is shown in *Figure
    5**.3*. Another major benefit of designing is that Fritzing builds hardware schematics
    and PCB design in the background according to your design, which can be adjusted
    according to system requirements. *Figure 5**.3* shows the schematic diagram of
    how to connect MKR GSM 1400 with the NEO-6M u-blox GPS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – MKR GSM 1400 and the GPS module schematic](img/B19752_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – MKR GSM 1400 and the GPS module schematic
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.3* is schematic diagram of project, but for ease I also created
    *Table 5.1,* which demonstrates MKR GSM 1400 to GPS Module pin numbers and names.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **MKR GSM** **1400 Board** | **GPS Module** |'
  prefs: []
  type: TYPE_TB
- en: '| 5V | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 14 TX | RX |'
  prefs: []
  type: TYPE_TB
- en: '| 13 RX | TX |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – MKR GSM 1400 and the GPS module pin connections list
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding design provides a full overview of how you can connect a module
    to a development board. According to our design, we have 5V and GND from the development
    board to the GPS module. The GPS module TX is connected to the RX (*Pin #13*)
    and the GPS module RX pin is connected to the TX (*Pin #14*) of the development
    board. *Table 5.1* shows the pin information. Finally, we have built our prototype
    by using a breadboard, which is shown in *Figure 5**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The final prototype](img/B19752_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The final prototype
  prefs: []
  type: TYPE_NORMAL
- en: After soldering the male headers to the GPS module, connect the pins according
    to the schematic diagram. There is only one sensor, so there is no requirement
    for the Veroboard. Next, we are going to test the GPS module using a serial monitor
    to verify that our GPS module is working properly and getting the values from
    GPS.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GPS module data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For module testing, we need a `tinygps` into the search bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The TinyGPSPlus library](img/B19752_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The TinyGPSPlus library
  prefs: []
  type: TYPE_NORMAL
- en: After searching, **Library Manager** shows a lot of libraries. Select the **TinyGPSPlus**
    library and install its latest version. The library comes with a lot of examples,
    but all are based on software serial. However, **Arduino SAMD** boards provide
    hardware serial, so I modified the code that uses hardware serial to communicate
    with the GPS module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the code from the book’s official GitHub repository in the chapter
    folder, open the `MKR-1400-NEO-6M-GPS-Module` code, and upload it to the development
    board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the setup, we have initialized `Serial` and `Serial1`. `Serial` is used to
    display the content on the serial monitor, while `Serial1` is the hardware serial
    that is used to communicate with the GPS module. The preceding code belongs to
    the `loop()` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, the GPS module will read the data from satellites using the `Serial1.read()`
    method and encode the data via the `gps.encode()` method. `Serial1` only reads
    one character at a time, so it will take a little bit of time to update the values.
    Next, we will verify whether there is any update in location by using the `gps.location.isUpdated()`
    method. If there is a change, then data will be printed on the serial monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your GPS module is placed in an open environment where you have
    a clear sky without any obstructions, such as a roof or anything similar, to properly
    receive signals from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: The GPS module has an onboard built-in LED that starts blinking when it receives
    data from GPS.
  prefs: []
  type: TYPE_NORMAL
- en: The same code will work with MKR NB 1500 without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.6* shows the serial monitor with values from the GPS, which includes
    latitude and longitude, along with other parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – GPS module data on the serial monitor](img/B19752_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – GPS module data on the serial monitor
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the data that is received by the GPS module from
    GPS satellites and printed on the serial monitor. The data includes the satellite
    count, the latitude and longitude that represent the location coordinates, the
    speed in **miles per hour** (**MPH**) based on current and previous GPS coordinates,
    and the altitude in feet.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we tested the NEO-6M u-blox GPS module in the Arduino IDE.
    First, we installed the TinyGPSPlus library for the module and then we used the
    preceding code for the development board, which shows the readings on the serial
    monitor. In the next section, we are going to start with the global IoT SIM card
    activation.
  prefs: []
  type: TYPE_NORMAL
- en: Activating SIM cards for IoT deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After assembling the GPS module with MKR GSM 1400 and testing it, it’s time
    to activate the Hologram global IoT SIM card, which will act as a bridge between
    the device and the Arduino IoT Cloud. You can purchase the IoT SIM card from [https://store.hologram.io/store/](https://store.hologram.io/store/).
    It provides different types of SIM cards for industries, such as the **Hyper EUICC
    IoT SIM card**, which is an industrial-grade and simple SIM card for learning
    projects, and these are available in different sizes according to the SIM slots
    in the development boards. You can order its **pilot SIM card** for free, but
    you need to pay for its shipment.
  prefs: []
  type: TYPE_NORMAL
- en: After receiving the SIM card, create an account at [hologram.io](http://hologram.io),
    where you will be able to activate and manage all your SIM cards. The Hologram
    dashboard provides full details regarding the data utilization of devices, packages,
    billing, and routes. By setting up routes, you can forward your device data to
    a different IoT cloud if you directly send it to the Hologram cloud. However,
    in our case, we will just use the Hologram SIM card as a carrier to transfer data
    from a device directly to the Arduino IoT Cloud, so there will be no requirements
    to set up a route. Just activate the SIM card and insert it into the MKR GSM 1400
    development board.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how we can proceed with Hologram global IoT SIM
    card activation as well as the different types of SIM cards available at [hologram.io](http://hologram.io)
    for researchers as well as industry. In the next section, we are going to set
    up the Thing in the Arduino IoT Cloud, which will include cloud variables creation,
    device association, network configuration, and code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Thing, network credentials, cloud variables, and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After setting up the hardware, it’s time to set up the Thing in the Arduino
    IoT Cloud. For this project, we need four cloud variables to fetch different properties
    from the device. The network settings will be different as we are using a GSM
    series board instead of Wi-Fi. *Figure 5**.7* shows the complete overview of the
    Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – A portable Thing tracker using the MKR GSM 1400 Thing setup](img/B19752_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – A portable Thing tracker using the MKR GSM 1400 Thing setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new Thing with the name `A portable thing tracker using MKR GSM1400`.
    Then, follow these steps to create cloud variables, an associate device, a network
    configuration, and finally, the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up four cloud variables for location, altitude feet,
    satellite count, and speed. The complete details regarding these cloud variables
    are available in the following section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to associate the device with the Thing. In the current project,
    we will use the MKR GSM 1400, so the wizard will be the same one used for the
    Arduino boards. The complete details are available in the *Associating a* *device*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to set up a network configuration for the device, but this
    time, we need to provide different settings for the GSM board, which will be covered
    in the *Network* subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have discussed what steps will be involved in the Thing creation. In
    the following subsections, we will create cloud variables, associate a device
    to the Thing, and network settings in separate subsections step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table explains all the properties that we need to use during cloud
    variable creation. For `Location`, we need two different variables to store latitude
    and longitude, but thanks to the Arduino IoT Cloud extended group of variables,
    we have a `Location` type variable. Next, make sure each variable matches the
    declaration in the table; otherwise, you need to modify the example code according
    to your naming.
  prefs: []
  type: TYPE_NORMAL
- en: In *Table 5.2*, during the cloud variables creation, I made the permission *read-only*.
    Although we have the read/write option, in this project, we only want to receive
    data from the device instead of modifying it on the dashboard. That’s why read-only
    mode is used – to prevent issues with data consistency. **Update Policy** is set
    to **On change**, as the device will send the data when the GPS module receives
    new data from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: '| **#** | **Variable name** | **Variable type** | **Declaration** | **Permission**
    | **Update policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `AltitudeFeet` | `Float` | `altitudeFeet` | Read-only | **On change**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `Location` | `CloudLocation` | `location` | Read-only | **On change**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `SatelliteCount` | `Int` | `satelliteCount` | Read-only | **On change**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `Speed` | `Float` | `speed` | Read-only | **On change** |'
  prefs: []
  type: TYPE_TB
- en: Table 5.2 – Cloud variables list for the Thing
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed what type of cloud variables are required
    for this project. Here, we have listed four cloud variables of different types
    but in read-only mode, as we only want to take the values from the device. In
    the next subsection, we are going to associate the MKR GSM 1400 with the Thing.
  prefs: []
  type: TYPE_NORMAL
- en: Associating a device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the variables, it’s time to add the device and associate it
    with the Thing. Before adding the device, connect the development board to the
    computer and open the **Arduino Create Agent** application. *Figure 5**.8* shows
    a popup in which we have options to either select the existing device for association
    or set up a new device that is not available in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Associate device](img/B19752_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Associate device
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we already have different devices in the portal, but we want to
    add a new MKR GSM 1400 device, so just click on **SET UP NEW DEVICE** to configure
    the new device in the account.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will see two options in the popup (*Figure 5**.9*). The first option
    is to set up an Arduino board, and the second option is to set up a third party
    device. Here, you will see a note under both options, **Compatible devices** (![](img/Icon.png)),
    which means you can only use certain types of Arduino devices as well as third-party
    devices in the Arduino IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Choosing a development device](img/B19752_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Choosing a development device
  prefs: []
  type: TYPE_NORMAL
- en: We can select any one option from the popup, according to the available device.
    However, in this case, click on the option to set up an Arduino device, as, in
    this chapter, we will use the MKR GSM 1400 board. Before adding the device, make
    sure that Arduino Create Agent runs on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we have associated the MKR GSM 1400 development board with
    the Thing. Next, we will configure the network settings in the **Thing** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After associating the device with the Thing, it is time to configure the network
    settings for device communication. These network settings are different from the
    Wi-Fi network settings. Both the MKR GSM 1400 and MKR NB 1500 development boards
    use SIM technology for communication. For that reason, their network configurations
    are different and will vary according to the IoT SIM card service provider. The
    following figure (*Figure 5**.10*) shows the **Configure network** popup for the
    MKR GSM 1400, which is totally different to the Wi-Fi configuration due to cellular
    communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The network configuration for the MKR GSM 1400](img/B19752_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The network configuration for the MKR GSM 1400
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we are using the Hologram global IoT SIM card, and only need to mention
    `hologram` under `prepay.pelion`, `0000`, and `arduino`. Before using any other
    global IoT SIM card, first, take its APN information to set up the network properly.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have discussed the network configuration for the Arduino MKR GSM 1400,
    which includes the APN, PIN, username, and password. In the next section, we will
    cover the code for the development board.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chapter’s code is available at the book’s official GitHub repository. Download
    `A_portable_thing_tracker_using_MKR_GSM1400_apr07a.zip` and import it into the
    Arduino Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code and put it into your Thing by navigating to the `setup()`
    method; remember to never try to use the `delay` method, as it will block the
    `ArduinoCloud.update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare the `gps` instance and two variables,
    which will be used to wait for 30,000 milliseconds (30 seconds) before taking
    the next readings without blocking the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will move toward the `loop` method. Here, we call the `FetchGPS()`
    method after every 30 minutes, which is carried out by comparing `currentMillis`
    and `previousMillis` without the use of delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following snippet, I have just picked a small part of the code from
    the `FetchGPS()` method. Here, I assign the latest values from the GPS module
    to the Arduino cloud variables, which will be used to send data to the cloud as
    well as print it on the serial monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Upload the code to the device and open up the Arduino Web Editor serial monitor
    to verify the values. After successfully uploading the data to the cloud, it’s
    time to set up a beautiful dashboard for web and mobile for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used different names in the variable declaration, then update the code
    according to your naming scheme. However, it’s better to first follow all the
    steps according to the book and later change the cloud variable names, modifying
    your code respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Never try to use the `delay` method, which will create a block for the `ArduinoCloud.update()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud only updates a value on the dashboard whenever a variable
    value is changed. For example, if the GPS location of the device is the same after
    an interval of time, then it means the device is not moving. Then, the Arduino
    IoT Cloud will not record the value, so don’t get confused if values are not changing
    on the map. Another benefit of this feature is that you will not get duplicate
    data when you export the content.
  prefs: []
  type: TYPE_NORMAL
- en: The same code will work with MKR NB 1500 without any modification. However,
    here, you need to associate the MKR NB 1500 device with the Thing instead of the
    MKR GSM 1400.
  prefs: []
  type: TYPE_NORMAL
- en: Creating comprehensive web and mobile dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After uploading the code to the device, it’s time to set up a dashboard for
    web and mobile to visualize the data with different widgets. The following figure
    demonstrates the visualization of readings with different widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The Thing dashboard](img/B19752_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The Thing dashboard
  prefs: []
  type: TYPE_NORMAL
- en: We have four readings from the GPS module to visualize; here, I have used three
    widgets, `location` variable. Currently, the Map widget is only capable of displaying
    the location of the asset device based on coordinates; if you have multiple assets
    to track, then you need to set up multiple Map widgets according to the number
    of tracking devices.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this was the last section of our chapter. Here, we have created a stunning
    dashboard for GPS tracking that shows the location using the Map widget on the
    dashboard, the speed per mile, and some other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have a lot of options available to explore, but now it’s your time
    to use different sensors and development boards to do some more experiments and
    learn from them. In the current chapter, we only used one GPS module, which gave
    us only four parameters but, on the market, there are a lot of GPS modules that
    provide a wide variety of functionalities; they work under the roof as well as
    under clear sky, and have several accuracy features.
  prefs: []
  type: TYPE_NORMAL
- en: While monitoring an asset’s location, there are some other parameters that are
    very important to monitor in different industries, such as temperature and humidity,
    which are very important in food and medical products. CO2 and LPG gases are very
    important to monitor during fuel transportation. Try different sensors with a
    GPS module to set up different tracking prototypes for different industries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to develop a GPS-based tracking system using
    a global IoT SIM card and GPS module. We set up the Thing, which included cloud
    variable creation, device association, GSM network configuration, and coding a
    development board. Later, we created a dashboard to visualize the Thing readings
    with different types of widgets to display current readings, with the most important
    widget of the chapter being the Map widget. It is a very interesting and important
    widget to display the location of IoT devices using GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: GPS tracking is a very important aspect that we covered in this chapter, and
    it helps us to develop a device for our asset tracking, which will help us in
    asset tracking and monitoring. This chapter demonstrated how we can display the
    location of a device on the dashboard, which gives you the confidence to build
    more solutions regarding asset tracking. In the next chapter, we will explore
    another long-range communication technology, called **LoRaWAN**. We will use this
    technology to build a solution for remote monitoring distant areas as well as
    compare this technology with GSM/4G/LTE and NB-IoT technology for proper guidance.
  prefs: []
  type: TYPE_NORMAL
