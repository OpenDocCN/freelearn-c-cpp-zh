<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-57"><a id="_idTextAnchor057"/>4</h1>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Premade Patterns in UE5 – Component, Update Method, and Behavior Tree</h1>
<p>This chapter will focus on the three main patterns widely used in game development that Unreal Engine 5 offers robust support and tools for, including pre-built implementations and editors – namely the <strong class="bold">component</strong>, <strong class="bold">update method</strong>, and <strong class="bold">behavior tree</strong> patterns. We will discuss the theory of why they exist and explore how you can implement them with guided exercises in our custom framework.</p>
<p>Understanding the tools at your disposal will improve your development speed, saving you from reinventing the proverbial wheel. Even if these are tools you are familiar with in Blueprint, some insight into the C++ workings will hopefully improve your effectiveness wherever you use them.</p>
<p>In this chapter, we’ll be covering the following topics:</p>
<ul>
<li>Understanding and creating components</li>
<li>Applying the update method for prototyping gameplay</li>
<li>Working with behavior trees</li>
</ul>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Technical requirements</h1>
<p>For this chapter, you will need to download the starter RTS framework from the <a href="B18297_04.xhtml#_idTextAnchor057"><em class="italic">Chapter 4</em></a> branch of the GitHub repository, which can be downloaded from <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04</a></p>
<p>We will be building elements for this framework in the following chapters, building up a series of gameplay features using patterns as we explore them.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Understanding and creating components</h1>
<p>One of the first things you learn when programming is to try to never repeat yourself. In fact, every technique you learn, from loops to functions to class encapsulation, is focused on reusing code with less typing. Building up the analogy, a loop reuses lines of code in one area so that you don’t need to repeat them next to each other. A function reuses blocks of code so that you don’t need to repeat them across your class. Then a class lets you reuse sets of functions and data in instances, so you don’t need to repeat logic across your program.</p>
<p>How does this help? Well, in games, any object that can be seen probably has some rendering element allowing it to be drawn to the screen. The code for rendering your object in your chosen graphics pipeline follows a standardized structure and is likely to be the same across every object that needs to be rendered. Even thinking about this possible repetition should be ringing alarm bells. Initially, it is a waste of your time to write out the same lines multiple times in different places. Then, if you need to make a structural change later down the line, you suddenly have a scavenger hunt trying to find all the places it needs to be changed.</p>
<p>There is a better way.</p>
<p>Enter, the <a id="_idIndexMarker133"/>component pattern. Essentially, we utilize the reusable aspect of classes as described previously to encapsulate all logic around a repeatable behavior. This forms a sort of building block template that we can instance and reference in many places. When the time comes to update the logic, it exists in only one place and will affect all areas that reference it.</p>
<p>Practically, this also makes our code around this functionality cleaner. Components are generally designed <a id="_idIndexMarker134"/>to be completely self-contained, which means that our collision code will deal with context for us and the rendering component will deal with linking model and texture assets together with materials. This leads to fewer checks needed before calling functions on these components and reduces unintended behavior.</p>
<p>For instance, when dealing with collision checks between two objects, you don’t need to find out what shape collider objects A and B have before checking if they can collide; the code for deciphering that is contained in the collider component itself. You also only get collision signals from the collider component; it doesn’t make your model flash when it collides with something. Using components effectively can lead to a modular code architecture that will be key to getting the most out of a large engine such as Unreal with a team of developers.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Notice how this links back to the single responsibility principle from our SOLID principles of code back in <a href="B18297_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>. Good patterns almost always reflect these principles. In this case, our components do one thing each that makes our code modular, and therefore, more useful.</p>
<p>Unreal Engine 5 is based on what is called <a id="_idIndexMarker135"/>an <code>BP_TopDownCharacter3</code> has the following components:</p>
<ul>
<li><strong class="bold">Capsule</strong> – set as the <a id="_idIndexMarker136"/>root; it describes the shape of the object for the physics engine</li>
<li><strong class="bold">Mesh</strong> – holds <a id="_idIndexMarker137"/>all the data for how to render the object to the screen</li>
<li><strong class="bold">Spring arm</strong> – dynamic <a id="_idIndexMarker138"/>component for holding objects at a distance</li>
<li><strong class="bold">Camera</strong> – attached to<a id="_idIndexMarker139"/> the spring arm, this describes the position and settings of the camera to render the screen</li>
</ul>
<p>Components vary in<a id="_idIndexMarker140"/> importance and size. The preceding list shows how a spring arm component, which is relatively small and unimportant, can be used with a larger, more important component such as the camera within the same actor. Size doesn’t dictate importance though, so let’s have a look at the first component you may create to make your development a touch easier – a <code>health</code> component. Our aim is to make a simple-to-use tool for designers to drop onto any actor, giving them the ability to track a health value, which is attached to the built-in damage system. The component should also provide hooks for notifying when damage has been taken and when the health value hits zero.</p>
<p>With the <a id="_idIndexMarker141"/>example framework open, click on <strong class="bold">Tools</strong> | <strong class="bold">New </strong><strong class="bold">C++ Class…</strong>.</p>
<p>You will be presented with the following window, showing all the parent classes you can extend:</p>
<div><div><img alt="Figure 4.1 – Window for choosing a class to inherit from" src="img/Figure_04.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Window for choosing a class to inherit from</p>
<p>We are interested in <strong class="bold">Actor, Component</strong> so select that and click on <strong class="bold">Next</strong>.</p>
<p>In the following window, we will name the component something sensible such as <code>HealthComponent</code>:</p>
<div><div><img alt="Figure 4.2 – Window for naming and scoping a new C++ class" src="img/Figure_04.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Window for naming and scoping a new C++ class</p>
<p>The rest of the settings don’t matter for this example, but they do impact the scope of our component. This is only something you need to be concerned with if you are building large projects with multiple sub-systems that may need to cross-reference classes. For now, let the settings be as is and click on <strong class="bold">Create Class</strong>. This will launch the IDE Unreal is linked to, which by default is Microsoft Visual Studio.</p>
<p class="callout-heading">Important note</p>
<p class="callout">While tools such as Visual Studio are great IDEs, at the time of writing, there is none better than JetBrains Rider for Unreal development. As of the 2022 version, Unreal-specific structures are built into their code auto-completer and error checker. However, this software is not free, so if you are using Visual Studio, then note that some of your code may display errors, but it will build and run fine.</p>
<p>With the <a id="_idIndexMarker142"/>class open, you should have a header (<code>.h</code>) and a body (<code>.cpp</code>) file. We will start by discussing requirements drawn from our task aim and building our header. Our component needs to do the following:</p>
<ul>
<li>Contain a value for health</li>
<li>Be able to receive a damage signal</li>
<li>Notify when taking damage and when dead</li>
</ul>
<p>Tackling our <a id="_idIndexMarker143"/>value for health is easy: we only need to define a float variable to track the current value and another to allow setting of the maximum value from the editor. With that in mind, setting the property specifiers in the <code>UPROPERTY</code> block is the most important part. Taking damage is also quite simple as Unreal Engine 5 has a damage interface system that proliferates every <code>AActor</code>. To hook into this, all you need is a function that shares a signature with the <code>OnTakeAnyDamage</code> event, as shown in the following <code>HealthComponent.h</code> code snippet. Lastly, to notify the owning <code>AActor</code> that the component has taken damage or is out of health, we will use some dynamic multicast delegates. These will be covered more in <a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a> when we look into clean communication, but for now, think of them as smoke signals coming from the component that the owning <code>AActor</code> can watch for.</p>
<p>So, let's write the code in the header file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">HealthComponent.h</p>
<pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "HealthComponent.generated.h"
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
    FComponentDeadSignature, AController*, causer);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(
    FComponentDamagedSignature, AController*, causer,
    float, damage, float, newHealth);
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class RTS_AI_API UHealthComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    UHealthComponent();
    UPROPERTY(BlueprintAssignable)
    FComponentDeadSignature onComponentDead;
    UPROPERTY(BlueprintAssignable)
    FComponentDamagedSignature onComponentDamaged;
protected:
    UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
    float _currentHealth;
    UPROPERTY(BlueprintReadWrite, EditAnywhere)
    float _maxHealth;
    virtual void BeginPlay() override;
    UFUNCTION()
    void DamageTaken(AActor* damagedActor, float damage,
        const UDamageType* damageType, AController*
        instigator, AActor* causer);
};</pre> <p>Next, we need to fill out the<a id="_idIndexMarker144"/> function definitions for the constructor, <code>BeginPlay</code> and <code>DamageTaken</code>. The constructor is simple enough as it just sets advised values for designers. Here, we only set the max health. <code>BeginPlay</code> is a little more interesting. Shown in the following code block, <code>BeginPlay</code> is where we link our damage function to the event in the owning <code>AActor</code>. <code>DamageTaken</code> does all the work in this component, but it is equally simple, with two lines being taken for ‘‘Broadcast’’-ing the delegates.</p>
<p class="callout-heading">Important note</p>
<p class="callout">We will be looking in more depth at what events do and what some of the terminology means later, in <a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a>. For now, the important aspect is that this component does function the way we need it to.</p>
<p>Let's add those to the body file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">HealthComponent.cpp</p>
<pre class="source-code">
UHealthComponent::UHealthComponent()
{
    _maxHealth = 100.f;
}
void UHealthComponent::BeginPlay()
{
Super::BeginPlay();
    GetOwner()-&gt;OnTakeAnyDamage.AddDynamic(this,
        &amp;UHealthComponent::DamageTaken);
    _currentHealth = _maxHealth;
}
void UHealthComponent::DamageTaken(AActor* damagedActor,
    float damage, const UDamageType* damageType,
    AController* instigator, AActor* causer)
{
    _currentHealth=FMath::Max(_currentHealth–damage, 0.f);
    onComponentDamaged.Broadcast(instigator,damage, _currentHealth);
    if(_currentHealth &lt;= 0.f)
    {
        onComponentDead.Broadcast(instigator);
    }
}</pre> <p>To use this<a id="_idIndexMarker145"/> component, head into a Blueprint class and click the <code>Component</code> should find it. Then, after adding it, you can link logic into it by clicking the green plus buttons next to the events we made in C++:</p>
<div><div><img alt="Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window" src="img/Figure_04.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window</p>
<p>As a final note on this pattern, you may also have heard the term ECS bandied around with games such as <em class="italic">Doom Eternal</em> and <em class="italic">Overwatch</em>, but this is slightly different from Unreal’s implementation. The ECS being spoken about there is what we call <em class="italic">data-oriented</em> ECS. This means that components store only data. The systems are the functions and are stored separately. Then the systems run on archetypes of components we call entities. Entities are stored contiguously in memory, which makes processing systems across large arrays of entities much faster and even possible to easily multi-thread.</p>
<p>The trade-off with this is that, while in principle it sounds simple, in practice it is a paradigm shift in how to approach programming as large as the jump from the linear <em class="italic">hello world</em> style programs with everything in one file to object-oriented projects with many classes and complex internal structures. This, combined with the infancy of the approach, means it is not practical to develop a large game and expect the entire programming team to hit the ground running with this system. If you would like to learn more about full data-oriented ECS, then there are plenty of resources on the topic. The keywords for proper research into the topic would be data-oriented, archetypes, and ECS, in some order, but due to the low adoption rate of the technique, resources are generally either terse or surface-level. The concept is best learned practically by pulling the ENTT C++ library apart to see how it implements the pattern. This is best for practical learners as it is a raw implementation with no other distractions.</p>
<p>Components are<a id="_idIndexMarker146"/> everywhere in modern game design, and now you should have some understanding of how to structure your code with them. Another ubiquitous tool in your developer belt is the update method.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Applying the update method for prototyping gameplay</h1>
<p>The <a id="_idIndexMarker147"/>update method is all about abstraction. Let’s learn through an example. Imagine building a <em class="italic">Pong</em> clone with only rudimentary knowledge of C++. It might look something like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Naïve Pong code</p>
<pre class="source-code">
Entity aiPaddle;
Entity ball;
Vector2D direction;
// Main game loop
while (looping)
{
    Vector2D ballPos = ball.GetPosition();
    ballPos += direction;
    ball.SetPosition(ballPos);
    if (ballPos.y &gt; aiPaddle.GetPosition().y)
    {
        aiPaddle.MoveUp();
    }
    else
    {
        aiPaddle.MoveDown();
    }
    // Input, collisions, and rendering...
}</pre> <p>This <a id="_idIndexMarker148"/>code may work for <em class="italic">Pong</em> but the problem is pretty clear. As you add more and more types of objects to your game, the ways you have to deal with every frame balloons your code. This is not sustainable.</p>
<p>The solution can be found in the minds of every person with an overbearing micro-managing boss: “<em class="italic">Just let me do my job.</em>” In this situation, the main loop is the manager, and the entities are sitting on the sidelines. They exist but are largely having logic run at them rather than on them. Why not trust these experts and make each entity responsible for the logic under its namesake? We keep a list of references in the main loop, but we forget who each of them are and resort to referencing them as numbers, or indexes in an array.</p>
<p>This new impersonal approach frees up the main loop to go through all entities and call a shared <code>Update()</code> method on them all. Each entity can now deal with its own world within its own override of the <code>Update</code> function. The following code snippet is an example of how you might manage this new approach:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Better Pong code</p>
<pre class="source-code">
Entity entities[];
//Main game loop
while(looping)
{
    for(Entity e : entities)
    {
        e.Update();
    }
//Collision and rendering…
}</pre> <p>Unreal Engine’s implementation <a id="_idIndexMarker149"/>of <code>Update</code> is called “<code>Tick</code>.” It fires once every rendered frame and allows developers to provide each actor they make with a different behavior. There is, however, a big issue with the update method pattern, which is why we will be exploring it in more depth in <a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>.</p>
<p>Now that we’ve covered the update method pattern, we are going to move on to the implementation of the behavior tree pattern in Unreal Engine 5 by exploring the behavior tree system inside the Unreal Engine editor.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Working with behavior trees</h1>
<p>The last pattern for this chapter is a little specific but no less useful than the others. Behavior trees<a id="_idIndexMarker150"/> define decision trees for AI brains to run. These trees define how information stored about the situation the AI thinks it is in will affect the actions it takes. Instead of compartmentalizing code into discrete blocks like other AI brain solutions, the behavior tree favors fragmentation with the aim of reuse. This flows back to the idea from the beginning of the chapter about the reuse of code for efficiency. A tree may look complex with many branches and leaves (yes, that is what we call the composites and tasks that make up a behavior tree), but on closer inspection, you will see that there are only a few building blocks and their arrangement is what creates the illusion of complex decision making.</p>
<p>The flow through a simple tree starts at the root and evaluates each node in the layer below in ascending order from 0 (order matters here) until it gets a success response. At this point, the tree knows it has found the correct task for its situation and can reset. As mentioned before, there are two types of simple nodes: composite and task. Composite nodes direct the flow of logic with their own sets of rules, whilst tasks are the actions and can succeed or fail depending on the logic contained within them (either in Blueprint or C++ code), and can never have a layer below them. The behavior tree executes each node in order until they reach the end of the list, or a node fails. They succeed when all their children succeed.</p>
<p>We will be using selector and sequence nodes, both of which are types of composite nodes. A selector node executes all of its children from left to right; it stops executing when one of its children succeeds. A sequence node also executes all of its children from left to right; however, unlike the selector node, it stops executing when one of its children fails. There are other more specialized nodes, but these two composite nodes are the foundations for any system you could wish to design.</p>
<p>The other composite <a id="_idIndexMarker151"/>node type, which we won’t be using, is the <strong class="bold">simple parallel</strong> node type. The simple parallel node<a id="_idIndexMarker152"/> allows you to run two child nodes at the same time: one must be a task, and the other can contain a complete sub-tree or branch of the behavior tree.</p>
<div><div><img alt="Figure 4.4 – The three types of composite nodes: Selector, Sequence, and Simple Parallel" src="img/Figure_04.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The three types of composite nodes: Selector, Sequence, and Simple Parallel</p>
<p>A notable use of behavior trees in games is <em class="italic">Halo 2</em>. As mentioned above, the order of the nodes in the tree matters and can radically change how AI behaves as it will tend to favor branches higher in the order. To differentiate the varied enemy types, Microsoft designed different behavior trees for each one. <em class="italic">Grunts</em> have a higher-order branch for fleeing so they tend to seem more scared, whereas <em class="italic">Elites</em> can re-order their own trees based on what the player is doing to make them seem adaptable. Notably, if you get in a vehicle enemy, <em class="italic">Elites</em> will raise the priority of them getting in a vehicle as vehicle-to-vehicle combat is more fun than the alternative and vice versa. There are many more tricks going on in that game, but this is not the place to continue, so back to UE5.</p>
<p>Let’s look at building a <a id="_idIndexMarker153"/>behavior tree for a simple <strong class="bold">real-time strategy</strong> (<strong class="bold">RTS</strong>) AI in the RTS framework. We will introduce the various building blocks of behavior trees, including selectors, sequences, decorators, services, and tasks.</p>
<p>For this implementation, we are going to use Blueprint to create the service (a collection of functions called by a behavior tree node) and tasks as opposed to using C++, as the main focus is on the implementation of the behavior tree pattern in Unreal Engine 5.</p>
<p>The framework contains a<a id="_idIndexMarker154"/> series of assets that have already been set up for you. Any Blueprint logic that we’ve created has been commented, if you would like to explore them further. Inside the <code>Content/RTS/Blueprints</code> folder, you will find a series of unreal assets used to create the basic elements of our RTS example game:</p>
<ul>
<li><strong class="bold">GM_RTS</strong>: This is the game mode. It contains references to the various classes for the framework to work.</li>
<li><strong class="bold">PC_RTS</strong>: This is the player controller. It contains the functionality to left-click selectable units and right-click on the world in order to tell the unit where to go.</li>
<li><strong class="bold">BP_CameraPawn</strong>: This is our pawn. It is a simple pawn blueprint with a camera that is set up to be placed directly in the center of the map.</li>
<li><strong class="bold">BPI_Units:</strong> This is our Blueprint interface. It contains three functions: <strong class="bold">SetMoveLocation</strong>, <strong class="bold">Stop</strong>, and <strong class="bold">AttackTarget</strong>:<ul><li><strong class="bold">SetMoveLocation</strong> has a vector input, <strong class="bold">Target Location</strong></li><li><strong class="bold">AttackTarget</strong> has an object input, <strong class="bold">TargetToAttack</strong></li><li><strong class="bold">Stop</strong> is just a function name and does not have any inputs or outputs</li></ul></li>
<li><code>BPI_Units</code> Blueprint interface.</p><p class="list-inset">The skeletal mesh component has been set up to use a green-tinted material instance placed on the default mesh, which is inherited from the base character class. We are making use of the standard mannequin character mesh here.</p><p class="list-inset">This Blueprint currently contains no functionality.</p></li>
<li><strong class="bold">BP_EnemyUnit</strong>: This is a second character blueprint. This is a simple character blueprint with no functionality.<p class="list-inset">The skeletal mesh component has been set up with a red-tinted material instance so that it is clearly identifiable.</p></li>
</ul>
<p>So, we are <a id="_idIndexMarker155"/>going to build an AI unit that the player will be able to control. The player will only be able to tell the unit where to move. They will do this by first selecting the unit using a left-click and then selecting a desired location for the unit to move to by right-clicking on the floor.</p>
<p>The unit will then move to the location. When not moving, the unit will search to see if any enemy units are within a radius of its current location. If it finds an enemy, the unit will then turn to face the enemy and shoot at it (using a simple line trace for now).</p>
<p>To achieve this, we need to create a series of assets. We are going to create an AI controller asset, for which we will create a Blackboard asset that contains the variables used inside the behavior tree.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Creating the AI controller</h2>
<p>The first thing<a id="_idIndexMarker156"/> we need to create is an AI controller Blueprint asset. This asset <a id="_idIndexMarker157"/>allows us to replace the human controller for a pawn with an AI solution using a behavior tree. For this, we need to do the following:</p>
<ol>
<li>Inside the Unreal Engine Editor, open the <code>Content/RTS/Blueprints</code> folder.</li>
<li>Right-click within the folder in the <strong class="bold">Content Browser</strong> and create a new <strong class="bold">Blueprint Class</strong>.</li>
<li>Expand the <code>AIController</code>.</li>
<li>Select the <strong class="bold">AIController</strong> entry from the list and click <strong class="bold">Select</strong>.</li>
</ol>
<div><div><img alt="Figure 4.5 – The Pick Parent Class dialog with the AIController parent class selected as the chosen parent class for the new Blueprint" src="img/Figure_04.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The Pick Parent Class dialog with the AIController parent class selected as the chosen parent class for the new Blueprint</p>
<ol>
<li value="5">Name <a id="_idIndexMarker158"/>the new<a id="_idIndexMarker159"/> Blueprint <code>AIC_EliteUnit</code>.</li>
</ol>
<p>Now we have our new AI controller, we now need to set it as the default AI controller for the <em class="italic">Elite</em> unit. This will ensure that whenever an Elite unit is spawned or placed within the game, it will have a controller. To assign the default AI controller, we need to do the following:</p>
<ol>
<li>From the <code>Blueprints</code> folder, open the <strong class="bold">BP_EliteUnit</strong> Blueprint asset.</li>
<li>Click the <strong class="bold">Class Defaults</strong> button in the top menu.</li>
<li>In <a id="_idIndexMarker160"/>the <code>AIC_EliteUnit</code>.</li>
</ol>
<p>Now we have an AI controller, we can start building our AI system. Before we can create the behavior tree, we first need to set up a <strong class="bold">Blackboard</strong> asset.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Creating the Blackboard asset</h2>
<p>Blackboards<a id="_idIndexMarker162"/> are used to define variables (known as keys) and<a id="_idIndexMarker163"/> store their values, which will allow our behavior tree to make decisions.</p>
<p>To create the Blackboard asset, we need to do the following:</p>
<ol>
<li>In the <strong class="bold">Content Browser</strong> window, right-click and select <strong class="bold">Artificial Intelligence</strong> | <strong class="bold">Blackboard</strong>.<div><img alt="Figure 4.6 – The Artificial Intelligence options when creating a new asset" src="img/Figure_04.06_B18297.jpg"/></div></li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The Artificial Intelligence options when creating a new asset</p>
<ol>
<li value="2">Name the new <code>BB_EliteUnit</code>.</li>
<li>Open the <code>BB_EliteUnit </code>Blackboard asset.</li>
<li>Add two new keys and set the <code>MoveToLocation</code>: <code>Vector</code></li><li><code>TargetEntity</code>: <code>Object</code></li></ul></li>
</ol>
<div><div><img alt="Figure 4.7 – The Blackboard asset with two keys" src="img/Figure_04.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The Blackboard asset with two keys</p>
<p>Now that we <a id="_idIndexMarker164"/>have our Blackboard setup with our <a id="_idIndexMarker165"/>variables (keys), we can go ahead and create the behavior tree asset and get building our AI system.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Building the behavior tree</h2>
<p>Now we have our<a id="_idIndexMarker166"/> Blackboard, we can create our behavior tree asset and link the main assets together:</p>
<ol>
<li>In the <strong class="bold">Content Browser</strong> window, right-click and select <strong class="bold">Artificial Intelligence</strong> | <strong class="bold">Behavior Tree</strong>.</li>
<li>Name the new <code>BT_EliteUnit</code>.</li>
<li>Open the <code>BT_EliteUnit</code> asset.</li>
<li>Set the <strong class="bold">Blackboard Asset</strong> setting in the <strong class="bold">Details</strong> panel to <strong class="bold">BB_EliteUnit</strong>.</li>
</ol>
<div><div><img alt="Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior Tree" src="img/Figure_04.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior Tree</p>
<ol>
<li value="5">Open the <code>AIC_EliteUnit</code> Blueprint asset (the AI controller) and activate the behavior<a id="_idIndexMarker167"/> tree when the unit is possessed using <strong class="bold">Event </strong><strong class="bold">On Possess</strong>:</li>
</ol>
<div><div><img alt="Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed" src="img/Figure_04.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed</p>
<p>With that done, we now have created the behavior tree asset; we can start building the AI system.</p>
<h3>Basic movement branch</h3>
<p>To start building the brains<a id="_idIndexMarker168"/> of our system, we are going to set up the following:</p>
<ul>
<li>A selector node, which is used to branch out into other sections of the tree</li>
<li>A sequence node, which allows us to move through multiple tasks, in order, from left to right</li>
<li>Our first task, which will use the existing <strong class="bold">Move </strong><strong class="bold">To</strong> task</li>
</ul>
<p>This will enable our character to be moved around the world. This part of the system requires no additional logic, just setting up within the behavior tree itself.</p>
<p>So, let’s start<a id="_idIndexMarker169"/> building:</p>
<ol>
<li>Open the <code>BT_EliteUnit</code> behavior tree.</li>
<li>Drag from the dark gray section at the bottom of the root node and create a <code>RootSelector</code>.</li>
</ol>
<div><div><img alt="Figure 4.10 – Options available when dragging from the root node in the behavior tree" src="img/Figure_04.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Options available when dragging from the root node in the behavior tree</p>
<ol>
<li value="3">From the bottom of the new <code>MoveToTargetLocation</code>.</li>
<li>For one final time, drag from the bottom of the new <strong class="bold">Sequence</strong> node and add <strong class="bold">Move To</strong> from the <strong class="bold">Tasks</strong> section of the selection popup:</li>
</ol>
<div><div><img alt="Figure 4.11 – Behavior tree creation popup with Move To highlighted" src="img/Figure_04.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Behavior tree creation popup with Move To highlighted</p>
<ol>
<li value="5">Set the <a id="_idIndexMarker170"/>Blackboard key to <code>MoveToLocation</code> – this is the vector key in the Blackboard asset.</li>
</ol>
<p>At the moment, this behavior tree will run; however, the task (<em class="italic">Move To</em>) will try to move the character to <code>0</code>,<code>0</code>,<code>0</code> because we have yet to set a value for the <strong class="bold">MoveToLocation</strong> key on the Blackboard.</p>
<p>The Blackboard keys can be set from multiple places if you can provide a reference to the owner of the Blackboard.</p>
<p>We’ve already provided the connection between the player controller Blueprint and the <code>BP_EliteUnit</code> character. Now we can set up the character to do something with those values:</p>
<ol>
<li>Open the <code>BP_EliteUnit</code> character Blueprint.</li>
<li>Create a new <code>Event Possessed</code> logic chain that casts <code>AIC_EliteUnit</code> and then stores the reference as a variable called <code>AIController</code>. Do this by creating the Blueprint nodes as shown (to create the <code>AIController</code>):</li>
</ol>
<div><div><img alt="Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint" src="img/Figure_04.12_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint</p>
<ol>
<li value="3">From the <strong class="bold">Interfaces</strong> section of the <strong class="bold">My Blueprint</strong> tab, double-click the <strong class="bold">Set Move Location</strong> label. This will create an <strong class="bold">Event Set Move </strong><strong class="bold">Location</strong> node.</li>
<li>From the <code>MoveToLocation</code>.</li>
<li>Drag the<code>Get Blackboard</code> node, and from that, add a <code>Set Value as </code><code>Vector</code> node.</li>
<li>From <a id="_idIndexMarker171"/>the <code>Make Literal Name</code> node. Set <code>MoveToLocation</code> – this is the key name on the Blackboard.</li>
<li>Use the <strong class="bold">MoveToLocation</strong> vector variable as the <strong class="bold">Vector </strong><strong class="bold">Value</strong> input.</li>
</ol>
<div><div><img alt="Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character Blueprint" src="img/Figure_04.13_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character Blueprint</p>
<p class="list-inset">This logic will, when the event is called, pass <code>MoveToLocation</code> key value.</p>
<ol>
<li value="8">Repeat this <a id="_idIndexMarker172"/>process for the <strong class="bold">Stop</strong> interface function from the <strong class="bold">Interfaces</strong> section of the <strong class="bold">My Blueprint</strong> tab, except instead of using a pin on the event to set the <strong class="bold">MoveToLocation</strong> vector, use a <strong class="bold">Get Actor </strong><strong class="bold">Location</strong> node.</li>
</ol>
<div><div><img alt="Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint" src="img/Figure_04.14_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint</p>
<p>The last thing left to do is tell the <code>MoveToLocation</code> key on the Blackboard:</p>
<ol>
<li>Select the <strong class="bold">Move To</strong> node on the behavior tree.</li>
<li>In the <strong class="bold">Details</strong> panel, check<a id="_idIndexMarker173"/> the <strong class="bold">Observe Blackboard </strong><strong class="bold">Value</strong> box.</li>
</ol>
<div><div><img alt="Figure 4.15 – Observe Blackboard Value checked on Move To task node" src="img/Figure_04.15_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Observe Blackboard Value checked on Move To task node</p>
<p>Now that the basic movement is set up, the character can be instructed to move around the world. Next, we are going to add a branch to our tree that will focus on the shooting part of our system.</p>
<h3>Shooting branch and task</h3>
<p>The next element of<a id="_idIndexMarker174"/> the system we are going to build is a means to enable the character to shoot enemies. For this, we are going to need to create a new task to build into the tree:</p>
<ol>
<li>To start with, click the <strong class="bold">New Task</strong> button at the top of the <strong class="bold">Behavior Tree</strong> editor and select <strong class="bold">BTTask_BlueprintBase</strong> from the list.</li>
</ol>
<div><div><img alt="Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected" src="img/Figure_04.16_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected</p>
<ol>
<li value="2">From the <code>Blueprints</code> folder is selected and set the name as <code>BTT_ShootTarget</code>.</li>
</ol>
<div><div><img alt="Figure 4.17 – Save Asset As window for behavior tree tasks" src="img/Figure_04.17_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Save Asset As window for behavior tree tasks</p>
<p class="list-inset">This has now created a behavior tree task asset, which should open automatically. If it doesn’t, you will find it as a Blueprint asset in the <strong class="bold">Content Browser</strong>.</p>
<p class="list-inset">With the task created, we now need to add some logic for what the task will do.</p>
<p class="list-inset">A <a id="_idIndexMarker175"/>task works by utilizing the <code>AttackTarget</code>, which we will set up to just print a <code>Shoot</code> message for now.</p>
<p class="list-inset">Behavior tree tasks need any logic chains to end with a <code>Success</code>. If the logic has completed the task, then this should be set to <strong class="bold">True</strong>, if it hasn’t, it should be set to <strong class="bold">False</strong>. For this example, we will only have a <strong class="bold">True</strong> result as all we are doing is calling an event on the character Blueprint.</p>
<ol>
<li value="3">In the <code>BTT_ShootTarget</code> Blueprint, add an <strong class="bold">Event Receive Execute AI</strong> node either by right-clicking in the viewport and searching for it or by clicking the <strong class="bold">Override</strong> dropdown that appears on the <strong class="bold">Functions</strong> rollout title when you hover over it.</li>
<li>Drag from the <code>AttackTarget</code> interface event.</li>
<li>From the <code>Get Blackboard Value as Object </code>node. This will allow us to get the value of an object key.</li>
<li>Right-click the <code>TargetEntity</code> – it is vital that this matches the name of the key on the Blackboard.</li>
<li>Set the <code>TargetEntity</code> variable to be <strong class="bold">Instance Editable</strong> by clicking the eye to the right of the variable type in the <strong class="bold">Variables</strong> list.</li>
</ol>
<div><div><img alt="Figure 4.18 – Instance Editable set to True on the TargetEntity variable" src="img/Figure_04.18_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Instance Editable set to True on the TargetEntity variable</p>
<ol>
<li value="8">Add a <code>Finish Execute</code> node after <strong class="bold">Attack Target</strong> and set <strong class="bold">Success</strong> to <strong class="bold">True</strong>.</li>
</ol>
<div><div><img alt="Figure 4.19 – Complete BTT_ShootTarget Blueprint logic" src="img/Figure_04.19_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Complete BTT_ShootTarget Blueprint logic</p>
<p>The task is<a id="_idIndexMarker176"/> now created. Before we add it to the tree, we need to add a response to the interface call on the character. For now, we will just add a <code>Shoot</code>:</p>
<ol>
<li>Open the <code>BP_EliteUnit</code> character Blueprint.</li>
<li>Double-click <strong class="bold">AttackTarget</strong> from the <strong class="bold">Interfaces</strong> rollout in <strong class="bold">My Blueprint</strong>.</li>
<li>Add a <code>Print String</code> node to the new <code>Hello</code> with <code>Shoot</code>.</li>
</ol>
<div><div><img alt="Figure 4.20 – Temporary attack target logic" src="img/Figure_04.20_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – Temporary attack target logic</p>
<p>We will replace this with a proper solution later. For now, this will serve the purpose of confirming that the event is being called by the task in the behavior tree.</p>
<p>Now that we have our task <a id="_idIndexMarker177"/>and interface event set up, we can add the task to the behavior tree:</p>
<ol>
<li>Open the <code>BT_EliteUnit</code> behavior tree.</li>
<li>Drag from the bottom of the <code>ShootNearbyTargets</code>.</li>
<li>Place this new node to the left of the <strong class="bold">MoveToTargetLocation</strong> node. This ensures that this node is considered first (i.e., it has a higher priority).</li>
<li>Drag from the bottom of the <code>Rotate to face BB</code> entry task – this will cause the character to face its target.</li>
<li>Set the <code>TargetEntity</code>.</li>
<li>Drag from the bottom of the <code>BTT_ShootTarget</code> task.</li>
<li>Set the <code>TargetEntity</code> if not set automatically.</li>
</ol>
<div><div><img alt="Figure 4.21 – The behavior tree so far with a new sequence and tasks added" src="img/Figure_04.21_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – The behavior tree so far with a new sequence and tasks added</p>
<p>The main structure <a id="_idIndexMarker178"/>of the branches is now complete; what we don’t have, however, is any way of identifying and setting the target identity. We are going to use a service to find our nearest target and a decorator to identify when the <code>TargetEntity</code> key has changed in order to choose when to complete the tasks in the <code>ShootNearbyTargets</code> sequence.</p>
<h3>Identifying enemy targets with a service</h3>
<p>To identify the <a id="_idIndexMarker179"/>enemies around the character, we are going to place a sphere trace within a service on the <strong class="bold">RootSelector</strong> selector node. This will provide the required information to the decision-making processes below as to what part of the tree will run, reducing the need to do tasks that don’t return successes.</p>
<p>So, let’s start by creating a service:</p>
<ol>
<li>Click the <strong class="bold">New Service</strong> button at the top of the <strong class="bold">Behavior </strong><strong class="bold">Tree</strong> editor.</li>
<li>Ensure the asset is being saved in the <code>Blueprint</code> folder and set <code>BTS_Find</code><strong class="source-inline">
</strong><code>NearestTarget</code>.</li>
<li>Open the new asset (if it doesn’t open automatically).</li>
<li>Create a new float variable called <code>SearchRadius</code>, set its default as <code>500</code>, and make it<strong class="bold"> </strong><strong class="bold">Instance Editable</strong>.</li>
<li>Create a new Blackboard key selector variable called <code>TargetEntity</code> and make it <strong class="bold">Instance Editable</strong>. Just like when creating the <em class="italic">Shoot Target</em> task, it is vital this is spelled correctly, matching the Blackboard key name.</li>
<li>Override the <strong class="bold">Receive Tick AI</strong> function by either right-clicking on the graph and searching for the node or using the override dropdown.</li>
<li>Add <a id="_idIndexMarker180"/>a <code>Sphere Trace For Objects</code> node and set it up as shown:</li>
</ol>
<div><div><img alt="Figure 4.22 – Sphere trace for pawns other than the unit doing the search" src="img/Figure_04.22_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Sphere trace for pawns other than the unit doing the search</p>
<ol>
<li value="8">Check the <code>Break Hit Result</code> node, as shown:</li>
</ol>
<div><div><img alt="Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor" src="img/Figure_04.23_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor</p>
<ol>
<li value="9">If the <code>TargetEntity</code> key using a <strong class="bold">Clear Blackboard Value</strong> node. This can be created by dragging from the <strong class="bold">TargetEntity</strong> variable <a id="_idIndexMarker181"/>node.</li>
</ol>
<p>The service Blueprint is now complete and looks as shown in the following screenshot. If you would like to visualize the sphere trace in order to determine whether the <strong class="bold">Search Radius</strong> variable is suitable, set the <strong class="bold">Draw Debug Type</strong> dropdown in the <strong class="bold">Sphere Trace For Objects</strong> node to <strong class="bold">For </strong><strong class="bold">One Frame</strong>.</p>
<div><div><img alt="Figure 4.24 – Completed service logic" src="img/Figure_04.24_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Completed service logic</p>
<p>With the service created, we can now add it to the <code>Root</code> selector:</p>
<ol>
<li>In the <code>BT_EliteUnit</code> behavior tree, right-click the <strong class="bold">RootSelector</strong> node, navigate to <strong class="bold">Add Service…</strong> and select <strong class="bold">BTS Find </strong><strong class="bold">Nearest Target</strong>.</li>
<li>Make sure the <code>TargetEntity</code> and that the search radius is showing as <code>500</code>. The search variable can be changed depending on the needs<a id="_idIndexMarker182"/> of the behavior tree it is being added to.</li>
</ol>
<div><div><img alt="Figure 4.25 – RootSelector with service added" src="img/Figure_04.25_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – RootSelector with service added</p>
<p>With the service added, the <strong class="bold">RootSelector</strong> should now look as shown in the preceding screenshot. You may need to rearrange your nodes to accommodate its increased size.</p>
<p>Now that we have the selector set up to find the nearest target, we can use the result of that service to define whether the shooting part of our behavior tree can be executed.</p>
<h3>Adding a decorator to activate the shooting sequence</h3>
<p>In order to<a id="_idIndexMarker183"/> ensure that the character only tries to rotate and shoot at a target that exists, we need to make sure we only run those tasks when <code>TargetEntity</code> has a valid value (this is why we clear the value when the sphere trace returns no hit results). We are going to add a decorator to <code>ShootNearbyTargets</code>. A decorator (known as a conditional in other behavior tree systems) defines whether a branch or node can be executed. We will use the decorator to monitor the <code>TargetEntity</code> Blackboard key value to see if we have anything to shoot; when we do, the <code>ShootNearbyTargets</code> sequence can be executed:</p>
<ol>
<li>Right-click the <strong class="bold">ShootNearbyTargets</strong> sequence node, navigate to <strong class="bold">Add Decorator…</strong>, and choose <strong class="bold">Blackboard</strong>.</li>
<li>Select the decorator (the blue box that has now appeared) and rename the node <code>TargetFound</code>.</li>
<li>Ensure<a id="_idIndexMarker184"/> that <strong class="bold">Blackboard Key</strong> = <strong class="bold">TargetEntity</strong> and <strong class="bold">Key Query</strong> = <strong class="bold">Is Set</strong>.</li>
</ol>
<div><div><img alt="Figure 4.26 – The final behavior tree" src="img/Figure_04.26_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26 – The final behavior tree</p>
<p>If you now test the system by playing in the viewport, you should be able to select and move the green character near either of the red characters. When the green character stops, it will find the nearest target, turn, and should create a print string of <code>Shoot</code>. It will continue to do so until the target is no longer valid, which, at this point, will be an eternity as we are not dealing any damage to the unit. You also won’t be able to move the character once it finds a target because there is currently no way of getting the AI to move away from the <code>BTT_ShootTarget</code> task.</p>
<p>To damage the enemy unit, making use of the <code>Health</code> component we created earlier, we need to replace the <code>BP_EliteUnit</code> <strong class="bold">Attack Target</strong> event with <a id="_idIndexMarker185"/>some logic to confirm the line of sight and then apply damage:</p>
<ol>
<li>Open the <code>BP_EliteUnit</code> character Blueprint.</li>
<li>Delete the <strong class="bold">Print String</strong> node from the <strong class="bold">Event Attack Target</strong> logic chain.</li>
<li>Cast the <strong class="bold">TargetToAttack</strong> object to <strong class="bold">Actor</strong> in order to get the actor’s location and use that as part of a <strong class="bold">Line Trace By Channel</strong>, as shown in the following screenshot. The line trace has been set up to draw onscreen for 5 seconds so we can confirm the trace is happening correctly.</li>
</ol>
<div><div><img alt="Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor" src="img/Figure_04.27_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor</p>
<ol>
<li value="4">Create a <code>Break Hit Result</code> node from the <code>Apply Damage</code> node with <code>100</code> <code>Print String</code> node for <code>No Line </code><code>of Sight</code>.</li>
</ol>
<div><div><img alt="Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes at the bottom left are routed from the As Actor pin of the Cast to Actor node" src="img/Figure_04.28_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes at the bottom left are routed from the As Actor pin of the Cast to Actor node</p>
<ol>
<li value="5">Lastly, to <a id="_idIndexMarker186"/>enable the enemy unit to be destroyed, we need to utilize the <strong class="bold">OnComponentDead</strong> event from the <strong class="bold">Health</strong> component by linking it to a <strong class="bold">Destroy </strong><strong class="bold">Actor</strong> node:</li>
</ol>
<div><div><img alt="Figure 4.29 – Health component death event linked to a Destroy Actor node" src="img/Figure_04.29_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.29 – Health component death event linked to a Destroy Actor node</p>
<p>Next, we will look at the final thoughts.</p>
<h3>Testing and final thoughts</h3>
<p>Testing the game now should remove the enemy instead of continually printing <code>Shoot</code>. This will result in the target entity being cleared, which in turn will allow you to move the character again.</p>
<p>While we now have a successful AI-controlled unit that moves and shoots, there is one other thing that is worth exploring, which is the <code>TargetFound</code> decorator. We originally left this set as <code>None</code>, which means the unit will complete its <code>shoot</code> as soon as it detects an enemy with a simple change of this value:</p>
<ol>
<li>Select the <code>TargetFound</code> decorator.</li>
<li>In the <strong class="bold">Details</strong> panel, set the <strong class="bold">Notify Observer</strong> to <strong class="bold">On </strong><strong class="bold">Result Change</strong>.</li>
<li>Change the <strong class="bold">Observer aborts</strong> to <strong class="bold">Lower Priority</strong>.</li>
</ol>
<p>Test the game again. You should now see that if you tell the unit to move past one of the enemies, it will stop en route to engage with the target. This is because the decorator has identified a change in the value of <code>TargetEntity</code> from the <code>BTS_FindNearestTarget</code> service and can now interrupt any lower-priority branch of the behavior tree, so any node which is to the right of it in the selector, which in this case includes the <code>MoveToTargetLocation</code> sequence, which holds the <strong class="bold">Move </strong><strong class="bold">To</strong> task.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Summary</h1>
<p>In this chapter, we have discussed the game development patterns that are present as premade tools and systems inside Unreal Engine. Namely, the component, update, and behavior tree patterns.</p>
<p>We made a <code>Health</code> component that will hopefully prove useful in your future projects, along with a simple behavior tree showing each major piece of the system. Armed with this knowledge, you should be able to make a functional AI system for any of your future Unreal projects.</p>
<p>The next chapter will take what we have learned about the update method and explain how we can do better. What is the impact of using <code>Tick</code> within the engine and how can you measure that impact?</p>
</div>


<div><h1 id="_idParaDest-67" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor067"/>Part 2: Anonymous Modular Design</h1>
</div>
<div><p>In this part, we will begin creating more efficient code to build modular solutions that communicate with each other efficiently and cleanly, without the use of direct references and casts.</p>
<p>We will start by reducing the need for gated polling in our code by replacing it with cleaner communication methods, and we will explore interfaces and event delegates to allow our code to be decoupled. This will culminate in a coding design paradigm we call Anonymous Modular Design, which should make our object-oriented code the most maintainable and expandable it can be.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, <em class="italic">Forgetting Tick</em></li>
<li><a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a>, <em class="italic">Clean Communication – Interface and Event Observer Patterns</em></li>
<li><a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic">Chapter 7</em></a>, <em class="italic">A Perfectly Decoupled System</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>