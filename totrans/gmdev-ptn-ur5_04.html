<html><head></head><body>
<div id="_idContainer098">
<h1 class="chapter-number" id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.2.1">Premade Patterns in UE5 – Component, Update Method, and Behavior Tree</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter will focus on the three main patterns widely used in game development that Unreal Engine 5 offers robust support and tools for, including pre-built implementations and editors – namely the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">component</span></strong><span class="koboSpan" id="kobo.5.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">update method</span></strong><span class="koboSpan" id="kobo.7.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">behavior tree</span></strong><span class="koboSpan" id="kobo.9.1"> patterns. </span><span class="koboSpan" id="kobo.9.2">We will discuss the theory of why they exist and explore how you can implement them with guided exercises in our </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">custom framework.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Understanding the tools at your disposal will improve your development speed, saving you from reinventing the proverbial wheel. </span><span class="koboSpan" id="kobo.11.2">Even if these are tools you are familiar with in Blueprint, some insight into the C++ workings will hopefully improve your effectiveness wherever you </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">use them.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we’ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Understanding and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">creating components</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Applying the update method for </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">prototyping gameplay</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">behavior trees</span></span></li>
</ul>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">For this chapter, you will need to download the starter RTS framework from the </span><a href="B18297_04.xhtml#_idTextAnchor057"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.24.1"> branch of the GitHub repository, which can be downloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">from </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04</span></span></a></p>
<p><span class="koboSpan" id="kobo.27.1">We will be building elements for this framework in the following chapters, building up a series of gameplay features using patterns as we </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">explore them.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.29.1">Understanding and creating components</span></h1>
<p><span class="koboSpan" id="kobo.30.1">One of the first things you learn when programming is to try to never repeat yourself. </span><span class="koboSpan" id="kobo.30.2">In fact, every technique you learn, from loops to functions to class encapsulation, is focused on reusing code with less typing. </span><span class="koboSpan" id="kobo.30.3">Building up the analogy, a loop reuses lines of code in one area so that you don’t need to repeat them next to each other. </span><span class="koboSpan" id="kobo.30.4">A function reuses blocks of code so that you don’t need to repeat them across your class. </span><span class="koboSpan" id="kobo.30.5">Then a class lets you reuse sets of functions and data in instances, so you don’t need to repeat logic across </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">your program.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">How does this help? </span><span class="koboSpan" id="kobo.32.2">Well, in games, any object that can be seen probably has some rendering element allowing it to be drawn to the screen. </span><span class="koboSpan" id="kobo.32.3">The code for rendering your object in your chosen graphics pipeline follows a standardized structure and is likely to be the same across every object that needs to be rendered. </span><span class="koboSpan" id="kobo.32.4">Even thinking about this possible repetition should be ringing alarm bells. </span><span class="koboSpan" id="kobo.32.5">Initially, it is a waste of your time to write out the same lines multiple times in different places. </span><span class="koboSpan" id="kobo.32.6">Then, if you need to make a structural change later down the line, you suddenly have a scavenger hunt trying to find all the places it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">be changed.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">There is a </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">better way.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Enter, the </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.37.1">component pattern. </span><span class="koboSpan" id="kobo.37.2">Essentially, we utilize the reusable aspect of classes as described previously to encapsulate all logic around a repeatable behavior. </span><span class="koboSpan" id="kobo.37.3">This forms a sort of building block template that we can instance and reference in many places. </span><span class="koboSpan" id="kobo.37.4">When the time comes to update the logic, it exists in only one place and will affect all areas that </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">reference it.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Practically, this also makes our code around this functionality cleaner. </span><span class="koboSpan" id="kobo.39.2">Components are generally designed </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.40.1">to be completely self-contained, which means that our collision code will deal with context for us and the rendering component will deal with linking model and texture assets together with materials. </span><span class="koboSpan" id="kobo.40.2">This leads to fewer checks needed before calling functions on these components and reduces </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">unintended behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">For instance, when dealing with collision checks between two objects, you don’t need to find out what shape collider objects A and B have before checking if they can collide; the code for deciphering that is contained in the collider component itself. </span><span class="koboSpan" id="kobo.42.2">You also only get collision signals from the collider component; it doesn’t make your model flash when it collides with something. </span><span class="koboSpan" id="kobo.42.3">Using components effectively can lead to a modular code architecture that will be key to getting the most out of a large engine such as Unreal with a team </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">of developers.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.44.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.45.1">Notice how this links back to the single responsibility principle from our SOLID principles of code back in </span><a href="B18297_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">Good patterns almost always reflect these principles. </span><span class="koboSpan" id="kobo.47.3">In this case, our components do one thing each that makes our code modular, and therefore, </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">more useful.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Unreal Engine 5 is based on what is called </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.50.1">an </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">entity component system</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.53.1">ECS</span></strong><span class="koboSpan" id="kobo.54.1">). </span><span class="koboSpan" id="kobo.54.2">This essentially means that all objects in the game world are considered entities. </span><span class="koboSpan" id="kobo.54.3">Each entity comprises components that, as we have established, encapsulate some behavior. </span><span class="koboSpan" id="kobo.54.4">When you open an actor’s </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">Blueprint Editor</span></strong><span class="koboSpan" id="kobo.56.1"> and look at its hierarchy, you are looking at the components that make up that entity (or in this case, actor). </span><span class="koboSpan" id="kobo.56.2">Take, for example, the default character in the framework adjacent to this book. </span><span class="koboSpan" id="kobo.56.3">We have left the hierarchy, which is all we will be focusing on for now, as mostly the same as the example character that Epic provides in their sample projects. </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">BP_TopDownCharacter3</span></strong><span class="koboSpan" id="kobo.58.1"> has the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Capsule</span></strong><span class="koboSpan" id="kobo.61.1"> – set as the </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.62.1">root; it describes the shape of the object for the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">physics engine</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Mesh</span></strong><span class="koboSpan" id="kobo.65.1"> – holds </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.66.1">all the data for how to render the object to </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the screen</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Spring arm</span></strong><span class="koboSpan" id="kobo.69.1"> – dynamic </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.70.1">component for holding objects at </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">a distance</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Camera</span></strong><span class="koboSpan" id="kobo.73.1"> – attached to</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.74.1"> the spring arm, this describes the position and settings of the camera to render </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">the screen</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.76.1">Components vary in</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.77.1"> importance and size. </span><span class="koboSpan" id="kobo.77.2">The preceding list shows how a spring arm component, which is relatively small and unimportant, can be used with a larger, more important component such as the camera within the same actor. </span><span class="koboSpan" id="kobo.77.3">Size doesn’t dictate importance though, so let’s have a look at the first component you may create to make your development a touch easier – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">health</span></strong><span class="koboSpan" id="kobo.79.1"> component. </span><span class="koboSpan" id="kobo.79.2">Our aim is to make a simple-to-use tool for designers to drop onto any actor, giving them the ability to track a health value, which is attached to the built-in damage system. </span><span class="koboSpan" id="kobo.79.3">The component should also provide hooks for notifying when damage has been taken and when the health value </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">hits zero.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">With the </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.82.1">example framework open, click on </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Tools</span></strong><span class="koboSpan" id="kobo.84.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">New </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.86.1">C++ Class…</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">You will be presented with the following window, showing all the parent classes you </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">can extend:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.90.1"><img alt="Figure 4.1 – Window for choosing a class to inherit from" src="image/Figure_04.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.91.1">Figure 4.1 – Window for choosing a class to inherit from</span></p>
<p><span class="koboSpan" id="kobo.92.1">We are interested in </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Actor, Component</span></strong><span class="koboSpan" id="kobo.94.1"> so select that and click </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">on </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.96.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">In the following window, we will name the component something sensible such </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">HealthComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.102.1"><img alt="Figure 4.2 – Window for naming and scoping a new C++ class" src="image/Figure_04.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.103.1">Figure 4.2 – Window for naming and scoping a new C++ class</span></p>
<p><span class="koboSpan" id="kobo.104.1">The rest of the settings don’t matter for this example, but they do impact the scope of our component. </span><span class="koboSpan" id="kobo.104.2">This is only something you need to be concerned with if you are building large projects with multiple sub-systems that may need to cross-reference classes. </span><span class="koboSpan" id="kobo.104.3">For now, let the settings be as is and click on </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Create Class</span></strong><span class="koboSpan" id="kobo.106.1">. </span><span class="koboSpan" id="kobo.106.2">This will launch the IDE Unreal is linked to, which by default is Microsoft </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">Visual Studio.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.108.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.109.1">While tools such as Visual Studio are great IDEs, at the time of writing, there is none better than JetBrains Rider for Unreal development. </span><span class="koboSpan" id="kobo.109.2">As of the 2022 version, Unreal-specific structures are built into their code auto-completer and error checker. </span><span class="koboSpan" id="kobo.109.3">However, this software is not free, so if you are using Visual Studio, then note that some of your code may display errors, but it will build and </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">run fine.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">With the </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.112.1">class open, you should have a header (</span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">.h</span></strong><span class="koboSpan" id="kobo.114.1">) and a body (</span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">.cpp</span></strong><span class="koboSpan" id="kobo.116.1">) file. </span><span class="koboSpan" id="kobo.116.2">We will start by discussing requirements drawn from our task aim and building our header. </span><span class="koboSpan" id="kobo.116.3">Our component needs to do </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.118.1">Contain a value </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">for health</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">Be able to receive a </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">damage signal</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">Notify when taking damage and </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">when dead</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.124.1">Tackling our </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.125.1">value for health is easy: we only need to define a float variable to track the current value and another to allow setting of the maximum value from the editor. </span><span class="koboSpan" id="kobo.125.2">With that in mind, setting the property specifiers in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">UPROPERTY</span></strong><span class="koboSpan" id="kobo.127.1"> block is the most important part. </span><span class="koboSpan" id="kobo.127.2">Taking damage is also quite simple as Unreal Engine 5 has a damage interface system that proliferates every </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">AActor</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">To hook into this, all you need is a function that shares a signature with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">OnTakeAnyDamage</span></strong><span class="koboSpan" id="kobo.131.1"> event, as shown in the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">HealthComponent.h</span></strong><span class="koboSpan" id="kobo.133.1"> code snippet. </span><span class="koboSpan" id="kobo.133.2">Lastly, to notify the owning </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">AActor</span></strong><span class="koboSpan" id="kobo.135.1"> that the component has taken damage or is out of health, we will use some dynamic multicast delegates. </span><span class="koboSpan" id="kobo.135.2">These will be covered more in </span><a href="B18297_06.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.137.1"> when we look into clean communication, but for now, think of them as smoke signals coming from the component that the owning </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">AActor</span></strong><span class="koboSpan" id="kobo.139.1"> can </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">watch for.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">So, let's write the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">header file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">HealthComponent.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
#pragma once
#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "HealthComponent.generated.h"
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
    FComponentDeadSignature, AController*, causer);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(
    FComponentDamagedSignature, AController*, causer,
    float, damage, float, newHealth);
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class RTS_AI_API UHealthComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    UHealthComponent();
    UPROPERTY(BlueprintAssignable)
    FComponentDeadSignature onComponentDead;
    UPROPERTY(BlueprintAssignable)
    FComponentDamagedSignature onComponentDamaged;
protected:
    UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
    float _currentHealth;
    UPROPERTY(BlueprintReadWrite, EditAnywhere)
    float _maxHealth;
    virtual void BeginPlay() override;
    UFUNCTION()
    void DamageTaken(AActor* damagedActor, float damage,
        const UDamageType* damageType, AController*
        instigator, AActor* causer);
};</span></pre> <p><span class="koboSpan" id="kobo.145.1">Next, we need to fill out the</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.146.1"> function definitions for the constructor, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.148.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">DamageTaken</span></strong><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">The constructor is simple enough as it just sets advised values for designers. </span><span class="koboSpan" id="kobo.150.3">Here, we only set the max health. </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.152.1"> is a little more interesting. </span><span class="koboSpan" id="kobo.152.2">Shown in the following code block, </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.154.1"> is where we link our damage function to the event in the owning </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">AActor</span></strong><span class="koboSpan" id="kobo.156.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">DamageTaken</span></strong><span class="koboSpan" id="kobo.158.1"> does all the work in this component, but it is equally simple, with two lines being taken for ‘‘Broadcast’’-ing </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the delegates.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.160.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.161.1">We will be looking in more depth at what events do and what some of the terminology means later, in </span><a href="B18297_06.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.163.1">. </span><span class="koboSpan" id="kobo.163.2">For now, the important aspect is that this component does function the way we need </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">it to.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Let's add those to the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">body file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">HealthComponent.cpp</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
UHealthComponent::UHealthComponent()
{
    _maxHealth = 100.f;
}
void UHealthComponent::BeginPlay()
{
Super::BeginPlay();
    GetOwner()-&gt;OnTakeAnyDamage.AddDynamic(this,
        &amp;UHealthComponent::DamageTaken);
    _currentHealth = _maxHealth;
}
void UHealthComponent::DamageTaken(AActor* damagedActor,
    float damage, const UDamageType* damageType,
    AController* instigator, AActor* causer)
{
    _currentHealth=FMath::Max(_currentHealth–damage, 0.f);
    onComponentDamaged.Broadcast(instigator,damage, _currentHealth);
    if(_currentHealth &lt;= 0.f)
    {
        onComponentDead.Broadcast(instigator);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.169.1">To use this</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.170.1"> component, head into a Blueprint class and click the </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">Add Component</span></strong><span class="koboSpan" id="kobo.172.1"> button in the Blueprint Editor window under </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">Components</span></strong><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">Searching here for the name of your component without the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Component</span></strong><span class="koboSpan" id="kobo.176.1"> should find it. </span><span class="koboSpan" id="kobo.176.2">Then, after adding it, you can link logic into it by clicking the green plus buttons next to the events we made </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">in C++:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.178.1"><img alt="Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window" src="image/Figure_04.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.179.1">Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window</span></p>
<p><span class="koboSpan" id="kobo.180.1">As a final note on this pattern, you may also have heard the term ECS bandied around with games such as </span><em class="italic"><span class="koboSpan" id="kobo.181.1">Doom Eternal</span></em><span class="koboSpan" id="kobo.182.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.183.1">Overwatch</span></em><span class="koboSpan" id="kobo.184.1">, but this is slightly different from Unreal’s implementation. </span><span class="koboSpan" id="kobo.184.2">The ECS being spoken about there is what we call </span><em class="italic"><span class="koboSpan" id="kobo.185.1">data-oriented</span></em><span class="koboSpan" id="kobo.186.1"> ECS. </span><span class="koboSpan" id="kobo.186.2">This means that components store only data. </span><span class="koboSpan" id="kobo.186.3">The systems are the functions and are stored separately. </span><span class="koboSpan" id="kobo.186.4">Then the systems run on archetypes of components we call entities. </span><span class="koboSpan" id="kobo.186.5">Entities are stored contiguously in memory, which makes processing systems across large arrays of entities much faster and even possible to </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">easily multi-thread.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">The trade-off with this is that, while in principle it sounds simple, in practice it is a paradigm shift in how to approach programming as large as the jump from the linear </span><em class="italic"><span class="koboSpan" id="kobo.189.1">hello world</span></em><span class="koboSpan" id="kobo.190.1"> style programs with everything in one file to object-oriented projects with many classes and complex internal structures. </span><span class="koboSpan" id="kobo.190.2">This, combined with the infancy of the approach, means it is not practical to develop a large game and expect the entire programming team to hit the ground running with this system. </span><span class="koboSpan" id="kobo.190.3">If you would like to learn more about full data-oriented ECS, then there are plenty of resources on the topic. </span><span class="koboSpan" id="kobo.190.4">The keywords for proper research into the topic would be data-oriented, archetypes, and ECS, in some order, but due to the low adoption rate of the technique, resources are generally either terse or surface-level. </span><span class="koboSpan" id="kobo.190.5">The concept is best learned practically by pulling the ENTT C++ library apart to see how it implements the pattern. </span><span class="koboSpan" id="kobo.190.6">This is best for practical learners as it is a raw implementation with no </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">other distractions.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Components are</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.193.1"> everywhere in modern game design, and now you should have some understanding of how to structure your code with them. </span><span class="koboSpan" id="kobo.193.2">Another ubiquitous tool in your developer belt is the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">update method.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.195.1">Applying the update method for prototyping gameplay</span></h1>
<p><span class="koboSpan" id="kobo.196.1">The </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.197.1">update method is all about abstraction. </span><span class="koboSpan" id="kobo.197.2">Let’s learn through an example. </span><span class="koboSpan" id="kobo.197.3">Imagine building a </span><em class="italic"><span class="koboSpan" id="kobo.198.1">Pong</span></em><span class="koboSpan" id="kobo.199.1"> clone with only rudimentary knowledge of C++. </span><span class="koboSpan" id="kobo.199.2">It might look something </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.201.1">Naïve Pong code</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
Entity aiPaddle;
Entity ball;
Vector2D direction;
// Main game loop
while (looping)
{
    Vector2D ballPos = ball.GetPosition();
    ballPos += direction;
    ball.SetPosition(ballPos);
    if (ballPos.y &gt; aiPaddle.GetPosition().y)
    {
        aiPaddle.MoveUp();
    }
    else
    {
        aiPaddle.MoveDown();
    }
    // Input, collisions, and rendering...
</span><span class="koboSpan" id="kobo.202.2">}</span></pre> <p><span class="koboSpan" id="kobo.203.1">This </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.204.1">code may work for </span><em class="italic"><span class="koboSpan" id="kobo.205.1">Pong</span></em><span class="koboSpan" id="kobo.206.1"> but the problem is pretty clear. </span><span class="koboSpan" id="kobo.206.2">As you add more and more types of objects to your game, the ways you have to deal with every frame balloons your code. </span><span class="koboSpan" id="kobo.206.3">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">not sustainable.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">The solution can be found in the minds of every person with an overbearing micro-managing boss: “</span><em class="italic"><span class="koboSpan" id="kobo.209.1">Just let me do my job.</span></em><span class="koboSpan" id="kobo.210.1">” In this situation, the main loop is the manager, and the entities are sitting on the sidelines. </span><span class="koboSpan" id="kobo.210.2">They exist but are largely having logic run at them rather than on them. </span><span class="koboSpan" id="kobo.210.3">Why not trust these experts and make each entity responsible for the logic under its namesake? </span><span class="koboSpan" id="kobo.210.4">We keep a list of references in the main loop, but we forget who each of them are and resort to referencing them as numbers, or indexes in </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">an array.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">This new impersonal approach frees up the main loop to go through all entities and call a shared </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Update()</span></strong><span class="koboSpan" id="kobo.214.1"> method on them all. </span><span class="koboSpan" id="kobo.214.2">Each entity can now deal with its own world within its own override of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Update</span></strong><span class="koboSpan" id="kobo.216.1"> function. </span><span class="koboSpan" id="kobo.216.2">The following code snippet is an example of how you might manage this </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">new approach:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.218.1">Better Pong code</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
Entity entities[];
//Main game loop
while(looping)
{
    for(Entity e : entities)
    {
        e.Update();
    }
//Collision and rendering…
}</span></pre> <p><span class="koboSpan" id="kobo.220.1">Unreal Engine’s implementation </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.221.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">Update</span></strong><span class="koboSpan" id="kobo.223.1"> is called “</span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">Tick</span></strong><span class="koboSpan" id="kobo.225.1">.” </span><span class="koboSpan" id="kobo.225.2">It fires once every rendered frame and allows developers to provide each actor they make with a different behavior. </span><span class="koboSpan" id="kobo.225.3">There is, however, a big issue with the update method pattern, which is why we will be exploring it in more depth in </span><a href="B18297_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.226.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Now that we’ve covered the update method pattern, we are going to move on to the implementation of the behavior tree pattern in Unreal Engine 5 by exploring the behavior tree system inside the Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">Engine editor.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.230.1">Working with behavior trees</span></h1>
<p><span class="koboSpan" id="kobo.231.1">The last pattern for this chapter is a little specific but no less useful than the others. </span><span class="koboSpan" id="kobo.231.2">Behavior trees</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.232.1"> define decision trees for AI brains to run. </span><span class="koboSpan" id="kobo.232.2">These trees define how information stored about the situation the AI thinks it is in will affect the actions it takes. </span><span class="koboSpan" id="kobo.232.3">Instead of compartmentalizing code into discrete blocks like other AI brain solutions, the behavior tree favors fragmentation with the aim of reuse. </span><span class="koboSpan" id="kobo.232.4">This flows back to the idea from the beginning of the chapter about the reuse of code for efficiency. </span><span class="koboSpan" id="kobo.232.5">A tree may look complex with many branches and leaves (yes, that is what we call the composites and tasks that make up a behavior tree), but on closer inspection, you will see that there are only a few building blocks and their arrangement is what creates the illusion of complex </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">decision making.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">The flow through a simple tree starts at the root and evaluates each node in the layer below in ascending order from 0 (order matters here) until it gets a success response. </span><span class="koboSpan" id="kobo.234.2">At this point, the tree knows it has found the correct task for its situation and can reset. </span><span class="koboSpan" id="kobo.234.3">As mentioned before, there are two types of simple nodes: composite and task. </span><span class="koboSpan" id="kobo.234.4">Composite nodes direct the flow of logic with their own sets of rules, whilst tasks are the actions and can succeed or fail depending on the logic contained within them (either in Blueprint or C++ code), and can never have a layer below them. </span><span class="koboSpan" id="kobo.234.5">The behavior tree executes each node in order until they reach the end of the list, or a node fails. </span><span class="koboSpan" id="kobo.234.6">They succeed when all their </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">children succeed.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">We will be using selector and sequence nodes, both of which are types of composite nodes. </span><span class="koboSpan" id="kobo.236.2">A selector node executes all of its children from left to right; it stops executing when one of its children succeeds. </span><span class="koboSpan" id="kobo.236.3">A sequence node also executes all of its children from left to right; however, unlike the selector node, it stops executing when one of its children fails. </span><span class="koboSpan" id="kobo.236.4">There are other more specialized nodes, but these two composite nodes are the foundations for any system you could wish </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">to design.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">The other composite </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.239.1">node type, which we won’t be using, is the </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">simple parallel</span></strong><span class="koboSpan" id="kobo.241.1"> node type. </span><span class="koboSpan" id="kobo.241.2">The simple parallel node</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.242.1"> allows you to run two child nodes at the same time: one must be a task, and the other can contain a complete sub-tree or branch of the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">behavior tree.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 4.4 – The three types of composite nodes: Selector, Sequence, and Simple Parallel" src="image/Figure_04.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 4.4 – The three types of composite nodes: Selector, Sequence, and Simple Parallel</span></p>
<p><span class="koboSpan" id="kobo.246.1">A notable use of behavior trees in games is </span><em class="italic"><span class="koboSpan" id="kobo.247.1">Halo 2</span></em><span class="koboSpan" id="kobo.248.1">. </span><span class="koboSpan" id="kobo.248.2">As mentioned above, the order of the nodes in the tree matters and can radically change how AI behaves as it will tend to favor branches higher in the order. </span><span class="koboSpan" id="kobo.248.3">To differentiate the varied enemy types, Microsoft designed different behavior trees for each one. </span><em class="italic"><span class="koboSpan" id="kobo.249.1">Grunts</span></em><span class="koboSpan" id="kobo.250.1"> have a higher-order branch for fleeing so they tend to seem more scared, whereas </span><em class="italic"><span class="koboSpan" id="kobo.251.1">Elites</span></em><span class="koboSpan" id="kobo.252.1"> can re-order their own trees based on what the player is doing to make them seem adaptable. </span><span class="koboSpan" id="kobo.252.2">Notably, if you get in a vehicle enemy, </span><em class="italic"><span class="koboSpan" id="kobo.253.1">Elites</span></em><span class="koboSpan" id="kobo.254.1"> will raise the priority of them getting in a vehicle as vehicle-to-vehicle combat is more fun than the alternative and vice versa. </span><span class="koboSpan" id="kobo.254.2">There are many more tricks going on in that game, but this is not the place to continue, so back </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">to UE5.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">Let’s look at building a </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.257.1">behavior tree for a simple </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">real-time strategy</span></strong><span class="koboSpan" id="kobo.259.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.260.1">RTS</span></strong><span class="koboSpan" id="kobo.261.1">) AI in the RTS framework. </span><span class="koboSpan" id="kobo.261.2">We will introduce the various building blocks of behavior trees, including selectors, sequences, decorators, services, </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">and tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">For this implementation, we are going to use Blueprint to create the service (a collection of functions called by a behavior tree node) and tasks as opposed to using C++, as the main focus is on the implementation of the behavior tree pattern in Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">Engine 5.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">The framework contains a</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.266.1"> series of assets that have already been set up for you. </span><span class="koboSpan" id="kobo.266.2">Any Blueprint logic that we’ve created has been commented, if you would like to explore them further. </span><span class="koboSpan" id="kobo.266.3">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Content/RTS/Blueprints</span></strong><span class="koboSpan" id="kobo.268.1"> folder, you will find a series of unreal assets used to create the basic elements of our RTS </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">example game:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.270.1">GM_RTS</span></strong><span class="koboSpan" id="kobo.271.1">: This is the game mode. </span><span class="koboSpan" id="kobo.271.2">It contains references to the various classes for the framework </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">to work.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.273.1">PC_RTS</span></strong><span class="koboSpan" id="kobo.274.1">: This is the player controller. </span><span class="koboSpan" id="kobo.274.2">It contains the functionality to left-click selectable units and right-click on the world in order to tell the unit where </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">to go.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.276.1">BP_CameraPawn</span></strong><span class="koboSpan" id="kobo.277.1">: This is our pawn. </span><span class="koboSpan" id="kobo.277.2">It is a simple pawn blueprint with a camera that is set up to be placed directly in the center of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the map.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.279.1">BPI_Units:</span></strong><span class="koboSpan" id="kobo.280.1"> This is our Blueprint interface. </span><span class="koboSpan" id="kobo.280.2">It contains three functions: </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">SetMoveLocation</span></strong><span class="koboSpan" id="kobo.282.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Stop</span></strong><span class="koboSpan" id="kobo.284.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.286.1">AttackTarget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.288.1">SetMoveLocation</span></strong><span class="koboSpan" id="kobo.289.1"> has a vector input, </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.290.1">Target Location</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.291.1">AttackTarget</span></strong><span class="koboSpan" id="kobo.292.1"> has an object </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">input, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.294.1">TargetToAttack</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.295.1">Stop</span></strong><span class="koboSpan" id="kobo.296.1"> is just a function name and does not have any inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">or outputs</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.298.1">BP_EliteUnit</span></strong><span class="koboSpan" id="kobo.299.1">: This is our character blueprint. </span><span class="koboSpan" id="kobo.299.2">It is the AI character that we are going to be </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">building upon.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.301.1">This Blueprint extends from the Unreal base character class and implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">BPI_Units</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.303.1">Blueprint interface.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.304.1">The skeletal mesh component has been set up to use a green-tinted material instance placed on the default mesh, which is inherited from the base character class. </span><span class="koboSpan" id="kobo.304.2">We are making use of the standard mannequin character </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">mesh here.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.306.1">This Blueprint currently contains </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">no functionality.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.308.1">BP_EnemyUnit</span></strong><span class="koboSpan" id="kobo.309.1">: This is a second character blueprint. </span><span class="koboSpan" id="kobo.309.2">This is a simple character blueprint with </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">no functionality.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.311.1">The skeletal mesh component has been set up with a red-tinted material instance so that it is </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">clearly identifiable.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.313.1">So, we are </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.314.1">going to build an AI unit that the player will be able to control. </span><span class="koboSpan" id="kobo.314.2">The player will only be able to tell the unit where to move. </span><span class="koboSpan" id="kobo.314.3">They will do this by first selecting the unit using a left-click and then selecting a desired location for the unit to move to by right-clicking on </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the floor.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The unit will then move to the location. </span><span class="koboSpan" id="kobo.316.2">When not moving, the unit will search to see if any enemy units are within a radius of its current location. </span><span class="koboSpan" id="kobo.316.3">If it finds an enemy, the unit will then turn to face the enemy and shoot at it (using a simple line trace </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">for now).</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">To achieve this, we need to create a series of assets. </span><span class="koboSpan" id="kobo.318.2">We are going to create an AI controller asset, for which we will create a Blackboard asset that contains the variables used inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">behavior tree.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.320.1">Creating the AI controller</span></h2>
<p><span class="koboSpan" id="kobo.321.1">The first thing</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.322.1"> we need to create is an AI controller Blueprint asset. </span><span class="koboSpan" id="kobo.322.2">This asset </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.323.1">allows us to replace the human controller for a pawn with an AI solution using a behavior tree. </span><span class="koboSpan" id="kobo.323.2">For this, we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.325.1">Inside the Unreal Engine Editor, open the </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Content Browser</span></strong><span class="koboSpan" id="kobo.327.1"> and navigate to the  </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Content/RTS/Blueprints</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.329.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.330.1">Right-click within the folder in the </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Content Browser</span></strong><span class="koboSpan" id="kobo.332.1"> and create a new </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.333.1">Blueprint Class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.335.1">Expand the </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">ALL CLASSES</span></strong><span class="koboSpan" id="kobo.337.1"> rollout and search </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">AIController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.341.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">AIController</span></strong><span class="koboSpan" id="kobo.343.1"> entry from the list and </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.345.1">Select</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.347.1"><img alt="Figure 4.5 – The Pick Parent Class dialog with the AIController parent class selected as the chosen parent class for the new Blueprint" src="image/Figure_04.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.348.1">Figure 4.5 – The Pick Parent Class dialog with the AIController parent class selected as the chosen parent class for the new Blueprint</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.349.1">Name </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.350.1">the new</span><a id="_idIndexMarker159"/> <span class="No-Break"><span class="koboSpan" id="kobo.351.1">Blueprint </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">AIC_EliteUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.354.1">Now we have our new AI controller, we now need to set it as the default AI controller for the </span><em class="italic"><span class="koboSpan" id="kobo.355.1">Elite</span></em><span class="koboSpan" id="kobo.356.1"> unit. </span><span class="koboSpan" id="kobo.356.2">This will ensure that whenever an Elite unit is spawned or placed within the game, it will have a controller. </span><span class="koboSpan" id="kobo.356.3">To assign the default AI controller, we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.358.1">From the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Blueprints</span></strong><span class="koboSpan" id="kobo.360.1"> folder, open the </span><strong class="bold"><span class="koboSpan" id="kobo.361.1">BP_EliteUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.362.1">Blueprint asset.</span></span></li>
<li><span class="koboSpan" id="kobo.363.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Class Defaults</span></strong><span class="koboSpan" id="kobo.365.1"> button in the </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">top menu.</span></span></li>
<li><span class="koboSpan" id="kobo.367.1">In </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.368.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">Details</span></strong><span class="koboSpan" id="kobo.370.1"> panel, set </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.371.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">AI Controller Class</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.373.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">AIC_EliteUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.376.1">Now we have an AI controller, we can start building our AI system. </span><span class="koboSpan" id="kobo.376.2">Before we can create the behavior tree, we first need to set up a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.377.1">Blackboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.378.1"> asset.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.379.1">Creating the Blackboard asset</span></h2>
<p><span class="koboSpan" id="kobo.380.1">Blackboards</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.381.1"> are used to define variables (known as keys) and</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.382.1"> store their values, which will allow our behavior tree to </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">make decisions.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">To create the Blackboard asset, we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.386.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Content Browser</span></strong><span class="koboSpan" id="kobo.388.1"> window, right-click and select </span><strong class="bold"><span class="koboSpan" id="kobo.389.1">Artificial Intelligence</span></strong><span class="koboSpan" id="kobo.390.1"> | </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.391.1">Blackboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">.</span></span><div class="IMG---Figure" id="_idContainer074"><span class="koboSpan" id="kobo.393.1"><img alt="Figure 4.6 – The Artificial Intelligence options when creating a new asset" src="image/Figure_04.06_B18297.jpg"/></span></div></li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.394.1">Figure 4.6 – The Artificial Intelligence options when creating a new asset</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.395.1">Name the new </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">Blackboard </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.397.1">Asset</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">BB_EliteUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.400.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">BB_EliteUnit </span></strong><span class="No-Break"><span class="koboSpan" id="kobo.402.1">Blackboard asset.</span></span></li>
<li><span class="koboSpan" id="kobo.403.1">Add two new keys and set the </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">Key Type</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.405.1">as shown:</span></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">MoveToLocation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">Vector</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">TargetEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Object</span></strong></span></li></ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.412.1"><img alt="Figure 4.7 – The Blackboard asset with two keys" src="image/Figure_04.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.413.1">Figure 4.7 – The Blackboard asset with two keys</span></p>
<p><span class="koboSpan" id="kobo.414.1">Now that we </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.415.1">have our Blackboard setup with our </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.416.1">variables (keys), we can go ahead and create the behavior tree asset and get building our </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">AI system.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.418.1">Building the behavior tree</span></h2>
<p><span class="koboSpan" id="kobo.419.1">Now we have our</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.420.1"> Blackboard, we can create our behavior tree asset and link the main </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">assets together:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.422.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">Content Browser</span></strong><span class="koboSpan" id="kobo.424.1"> window, right-click and select </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">Artificial Intelligence</span></strong><span class="koboSpan" id="kobo.426.1"> | </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.427.1">Behavior Tree</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.429.1">Name the new </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">Behavior Tree</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.431.1">asset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">BT_EliteUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.434.1">Open the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">BT_EliteUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.436.1"> asset.</span></span></li>
<li><span class="koboSpan" id="kobo.437.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">Blackboard Asset</span></strong><span class="koboSpan" id="kobo.439.1"> setting in the </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">Details</span></strong><span class="koboSpan" id="kobo.441.1"> panel </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.443.1">BB_EliteUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.445.1"><img alt="Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior Tree" src="image/Figure_04.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.446.1">Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior Tree</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.447.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">AIC_EliteUnit</span></strong><span class="koboSpan" id="kobo.449.1"> Blueprint asset (the AI controller) and activate the behavior</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.450.1"> tree when the unit is possessed using </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Event </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.452.1">On Possess</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.454.1"><img alt="Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed" src="image/Figure_04.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed</span></p>
<p><span class="koboSpan" id="kobo.456.1">With that done, we now have created the behavior tree asset; we can start building the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">AI system.</span></span></p>
<h3><span class="koboSpan" id="kobo.458.1">Basic movement branch</span></h3>
<p><span class="koboSpan" id="kobo.459.1">To start building the brains</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.460.1"> of our system, we are going to set up </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.462.1">A selector node, which is used to branch out into other sections of </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">the tree</span></span></li>
<li><span class="koboSpan" id="kobo.464.1">A sequence node, which allows us to move through multiple tasks, in order, from left </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">to right</span></span></li>
<li><span class="koboSpan" id="kobo.466.1">Our first task, which will use the existing </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">Move </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.468.1">To</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1"> task</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.470.1">This will enable our character to be moved around the world. </span><span class="koboSpan" id="kobo.470.2">This part of the system requires no additional logic, just setting up within the behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">tree itself.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">So, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">start</span></span><span class="No-Break"><a id="_idIndexMarker169"/></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> building:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.475.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">BT_EliteUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.477.1">behavior tree.</span></span></li>
<li><span class="koboSpan" id="kobo.478.1">Drag from the dark gray section at the bottom of the root node and create a </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">Selector</span></strong><span class="koboSpan" id="kobo.480.1"> node by selecting it from the </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">Composites</span></strong><span class="koboSpan" id="kobo.482.1"> section of the popup; name </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">this </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">RootSelector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.486.1"><img alt="Figure 4.10 – Options available when dragging from the root node in the behavior tree" src="image/Figure_04.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.487.1">Figure 4.10 – Options available when dragging from the root node in the behavior tree</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.488.1">From the bottom of the new </span><strong class="bold"><span class="koboSpan" id="kobo.489.1">Selector</span></strong><span class="koboSpan" id="kobo.490.1"> node, drag out again and add a </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">Sequence</span></strong><span class="koboSpan" id="kobo.492.1"> node. </span><span class="koboSpan" id="kobo.492.2">Name this </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">node </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">MoveToTargetLocation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.496.1">For one final time, drag from the bottom of the new </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">Sequence</span></strong><span class="koboSpan" id="kobo.498.1"> node and add </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">Move To</span></strong><span class="koboSpan" id="kobo.500.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">Tasks</span></strong><span class="koboSpan" id="kobo.502.1"> section of the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">selection popup:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.504.1"><img alt="Figure 4.11 – Behavior tree creation popup with Move To highlighted" src="image/Figure_04.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.505.1">Figure 4.11 – Behavior tree creation popup with Move To highlighted</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.506.1">Set the </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.507.1">Blackboard key to </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">MoveToLocation</span></strong><span class="koboSpan" id="kobo.509.1"> – this is the vector key in the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">Blackboard asset.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.511.1">At the moment, this behavior tree will run; however, the task (</span><em class="italic"><span class="koboSpan" id="kobo.512.1">Move To</span></em><span class="koboSpan" id="kobo.513.1">) will try to move the character to </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">0</span></strong><span class="koboSpan" id="kobo.515.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">0</span></strong><span class="koboSpan" id="kobo.517.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">0</span></strong><span class="koboSpan" id="kobo.519.1"> because we have yet to set a value for the </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">MoveToLocation</span></strong><span class="koboSpan" id="kobo.521.1"> key on </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">the Blackboard.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">The Blackboard keys can be set from multiple places if you can provide a reference to the owner of </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">the Blackboard.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">We’ve already provided the connection between the player controller Blueprint and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">BP_EliteUnit</span></strong><span class="koboSpan" id="kobo.527.1"> character. </span><span class="koboSpan" id="kobo.527.2">Now we can set up the character to do something with </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">those values:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.529.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">BP_EliteUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.531.1">character Blueprint.</span></span></li>
<li><span class="koboSpan" id="kobo.532.1">Create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">Event Possessed</span></strong><span class="koboSpan" id="kobo.534.1"> logic chain that casts </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">New Controller </span></strong><span class="koboSpan" id="kobo.536.1">to </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">AIC_EliteUnit</span></strong><span class="koboSpan" id="kobo.538.1"> and then stores the reference as a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">AIController</span></strong><span class="koboSpan" id="kobo.540.1">. </span><span class="koboSpan" id="kobo.540.2">Do this by creating the Blueprint nodes as shown (to create the </span><strong class="bold"><span class="koboSpan" id="kobo.541.1">Set AIController</span></strong><span class="koboSpan" id="kobo.542.1"> node, right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.543.1">As AIC Elite Unit</span></strong><span class="koboSpan" id="kobo.544.1"> pin and select </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">Promote to Variable.</span></strong><span class="koboSpan" id="kobo.546.1"> Call the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">variable </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">AIController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">):</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.550.1"><img alt="Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint" src="image/Figure_04.12_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.551.1">Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.552.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">Interfaces</span></strong><span class="koboSpan" id="kobo.554.1"> section of the </span><strong class="bold"><span class="koboSpan" id="kobo.555.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.556.1"> tab, double-click the </span><strong class="bold"><span class="koboSpan" id="kobo.557.1">Set Move Location</span></strong><span class="koboSpan" id="kobo.558.1"> label. </span><span class="koboSpan" id="kobo.558.2">This will create an </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">Event Set Move </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.560.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.562.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">Event Set Move Location</span></strong><span class="koboSpan" id="kobo.564.1"> node, promote the </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">TargetLocation </span></strong><span class="koboSpan" id="kobo.566.1">vector to a variable. </span><span class="koboSpan" id="kobo.566.2">Call the </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">variable </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">MoveToLocation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Drag the</span><strong class="bold"><span class="koboSpan" id="kobo.571.1"> AIController</span></strong><span class="koboSpan" id="kobo.572.1"> variable into the graph, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">Get Blackboard</span></strong><span class="koboSpan" id="kobo.574.1"> node, and from that, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">Set Value as </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">Vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.577.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.578.1">From </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.579.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.580.1">Key Name</span></strong><span class="koboSpan" id="kobo.581.1"> pin, drag out and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Make Literal Name</span></strong><span class="koboSpan" id="kobo.583.1"> node. </span><span class="koboSpan" id="kobo.583.2">Set </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">Value</span></strong><span class="koboSpan" id="kobo.585.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">MoveToLocation</span></strong><span class="koboSpan" id="kobo.587.1"> – this is the key name on </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">the Blackboard.</span></span></li>
<li><span class="koboSpan" id="kobo.589.1">Use the </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">MoveToLocation</span></strong><span class="koboSpan" id="kobo.591.1"> vector variable as the </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">Vector </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.593.1">Value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.594.1"> input.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.595.1"><img alt="Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character Blueprint" src="image/Figure_04.13_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.596.1">Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character Blueprint</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.597.1">This logic will, when the event is called, pass </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">Target Location</span></strong><span class="koboSpan" id="kobo.599.1"> through to the behavior tree by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">MoveToLocation</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.601.1">key value.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.602.1">Repeat this </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.603.1">process for the </span><strong class="bold"><span class="koboSpan" id="kobo.604.1">Stop</span></strong><span class="koboSpan" id="kobo.605.1"> interface function from the </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">Interfaces</span></strong><span class="koboSpan" id="kobo.607.1"> section of the </span><strong class="bold"><span class="koboSpan" id="kobo.608.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.609.1"> tab, except instead of using a pin on the event to set the </span><strong class="bold"><span class="koboSpan" id="kobo.610.1">MoveToLocation</span></strong><span class="koboSpan" id="kobo.611.1"> vector, use a </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">Get Actor </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.613.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1"> node.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.615.1"><img alt="Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint" src="image/Figure_04.14_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.616.1">Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint</span></p>
<p><span class="koboSpan" id="kobo.617.1">The last thing left to do is tell the </span><strong class="bold"><span class="koboSpan" id="kobo.618.1">Move To</span></strong><span class="koboSpan" id="kobo.619.1"> task on the behavior tree to observe changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">MoveToLocation</span></strong><span class="koboSpan" id="kobo.621.1"> key on </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the Blackboard:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.623.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">Move To</span></strong><span class="koboSpan" id="kobo.625.1"> node on the </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">behavior tree.</span></span></li>
<li><span class="koboSpan" id="kobo.627.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.628.1">Details</span></strong><span class="koboSpan" id="kobo.629.1"> panel, check</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.630.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">Observe Blackboard </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.632.1">Value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.633.1"> box.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.634.1"><img alt="Figure 4.15 – Observe Blackboard Value checked on Move To task node" src="image/Figure_04.15_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.635.1">Figure 4.15 – Observe Blackboard Value checked on Move To task node</span></p>
<p><span class="koboSpan" id="kobo.636.1">Now that the basic movement is set up, the character can be instructed to move around the world. </span><span class="koboSpan" id="kobo.636.2">Next, we are going to add a branch to our tree that will focus on the shooting part of </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">our system.</span></span></p>
<h3><span class="koboSpan" id="kobo.638.1">Shooting branch and task</span></h3>
<p><span class="koboSpan" id="kobo.639.1">The next element of</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.640.1"> the system we are going to build is a means to enable the character to shoot enemies. </span><span class="koboSpan" id="kobo.640.2">For this, we are going to need to create a new task to build into </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">the tree:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.642.1">To start with, click the </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">New Task</span></strong><span class="koboSpan" id="kobo.644.1"> button at the top of the </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">Behavior Tree</span></strong><span class="koboSpan" id="kobo.646.1"> editor and select </span><strong class="bold"><span class="koboSpan" id="kobo.647.1">BTTask_BlueprintBase</span></strong><span class="koboSpan" id="kobo.648.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">the list.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.650.1"><img alt="Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected" src="image/Figure_04.16_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.652.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Save Asset As</span></strong><span class="koboSpan" id="kobo.654.1"> pop-up window, ensure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">Blueprints</span></strong><span class="koboSpan" id="kobo.656.1"> folder is selected and set the name </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">BTT_ShootTarget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.660.1"><img alt="Figure 4.17 – Save Asset As window for behavior tree tasks" src="image/Figure_04.17_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.661.1">Figure 4.17 – Save Asset As window for behavior tree tasks</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.662.1">This has now created a behavior tree task asset, which should open automatically. </span><span class="koboSpan" id="kobo.662.2">If it doesn’t, you will find it as a Blueprint asset in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.663.1">Content Browser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.665.1">With the task created, we now need to add some logic for what the task </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">will do.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.667.1">A </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.668.1">task works by utilizing the </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">Event Receive Execute AI</span></strong><span class="koboSpan" id="kobo.670.1"> node, which provides references to the owning controller and the controlled pawn. </span><span class="koboSpan" id="kobo.670.2">This allows us to communicate easily with the pawn. </span><span class="koboSpan" id="kobo.670.3">In this case, we are going to call the interface event </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">AttackTarget</span></strong><span class="koboSpan" id="kobo.672.1">, which we will set up to just print a </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Shoot</span></strong><span class="koboSpan" id="kobo.674.1"> message </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">for now.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.676.1">Behavior tree tasks need any logic chains to end with a </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">Finish Execute</span></strong><span class="koboSpan" id="kobo.678.1"> node. </span><span class="koboSpan" id="kobo.678.2">The node has one input pin, a Boolean for </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">Success</span></strong><span class="koboSpan" id="kobo.680.1">. </span><span class="koboSpan" id="kobo.680.2">If the logic has completed the task, then this should be set to </span><strong class="bold"><span class="koboSpan" id="kobo.681.1">True</span></strong><span class="koboSpan" id="kobo.682.1">, if it hasn’t, it should be set to </span><strong class="bold"><span class="koboSpan" id="kobo.683.1">False</span></strong><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">For this example, we will only have a </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">True</span></strong><span class="koboSpan" id="kobo.686.1"> result as all we are doing is calling an event on the </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">character Blueprint.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.688.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">BTT_ShootTarget</span></strong><span class="koboSpan" id="kobo.690.1"> Blueprint, add an </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">Event Receive Execute AI</span></strong><span class="koboSpan" id="kobo.692.1"> node either by right-clicking in the viewport and searching for it or by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">Override</span></strong><span class="koboSpan" id="kobo.694.1"> dropdown that appears on the </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">Functions</span></strong><span class="koboSpan" id="kobo.696.1"> rollout title when you hover </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">over it.</span></span></li>
<li><span class="koboSpan" id="kobo.698.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.699.1">Controlled Pawn</span></strong><span class="koboSpan" id="kobo.700.1"> pin and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">AttackTarget</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.702.1">interface event.</span></span></li>
<li><span class="koboSpan" id="kobo.703.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.704.1">Target to Attack</span></strong><span class="koboSpan" id="kobo.705.1"> input pin, drag out and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">Get Blackboard Value as Object </span></strong><span class="koboSpan" id="kobo.707.1">node. </span><span class="koboSpan" id="kobo.707.2">This will allow us to get the value of an </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">object key.</span></span></li>
<li><span class="koboSpan" id="kobo.709.1">Right-click the </span><strong class="bold"><span class="koboSpan" id="kobo.710.1">Key</span></strong><span class="koboSpan" id="kobo.711.1"> input pin, select </span><strong class="bold"><span class="koboSpan" id="kobo.712.1">Promote to Variable</span></strong><span class="koboSpan" id="kobo.713.1">, and name the new variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.715.1"> – it is vital that this matches the name of the key on </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">the Blackboard.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.719.1"> variable to be </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">Instance Editable</span></strong><span class="koboSpan" id="kobo.721.1"> by clicking the eye to the right of the variable type in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.722.1">Variables</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1"> list.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.724.1"><img alt="Figure 4.18 – Instance Editable set to True on the TargetEntity variable" src="image/Figure_04.18_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.725.1">Figure 4.18 – Instance Editable set to True on the TargetEntity variable</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.726.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Finish Execute</span></strong><span class="koboSpan" id="kobo.728.1"> node after </span><strong class="bold"><span class="koboSpan" id="kobo.729.1">Attack Target</span></strong><span class="koboSpan" id="kobo.730.1"> and set </span><strong class="bold"><span class="koboSpan" id="kobo.731.1">Success</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.732.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.733.1">True</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.735.1"><img alt="Figure 4.19 – Complete BTT_ShootTarget Blueprint logic" src="image/Figure_04.19_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Figure 4.19 – Complete BTT_ShootTarget Blueprint logic</span></p>
<p><span class="koboSpan" id="kobo.737.1">The task is</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.738.1"> now created. </span><span class="koboSpan" id="kobo.738.2">Before we add it to the tree, we need to add a response to the interface call on the character. </span><span class="koboSpan" id="kobo.738.3">For now, we will just add a </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">Print String</span></strong><span class="koboSpan" id="kobo.740.1"> node </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">Shoot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.744.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">BP_EliteUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.746.1">character Blueprint.</span></span></li>
<li><span class="koboSpan" id="kobo.747.1">Double-click </span><strong class="bold"><span class="koboSpan" id="kobo.748.1">AttackTarget</span></strong><span class="koboSpan" id="kobo.749.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.750.1">Interfaces</span></strong><span class="koboSpan" id="kobo.751.1"> rollout in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.752.1">My Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.754.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">Print String</span></strong><span class="koboSpan" id="kobo.756.1"> node to the new </span><strong class="bold"><span class="koboSpan" id="kobo.757.1">Event Attack Target</span></strong><span class="koboSpan" id="kobo.758.1"> and replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">Hello</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.760.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">Shoot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.763.1"><img alt="Figure 4.20 – Temporary attack target logic" src="image/Figure_04.20_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.764.1">Figure 4.20 – Temporary attack target logic</span></p>
<p><span class="koboSpan" id="kobo.765.1">We will replace this with a proper solution later. </span><span class="koboSpan" id="kobo.765.2">For now, this will serve the purpose of confirming that the event is being called by the task in the </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">behavior tree.</span></span></p>
<p><span class="koboSpan" id="kobo.767.1">Now that we have our task </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.768.1">and interface event set up, we can add the task to the </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">behavior tree:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.770.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">BT_EliteUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.772.1">behavior tree.</span></span></li>
<li><span class="koboSpan" id="kobo.773.1">Drag from the bottom of the </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">RootSelector</span></strong><span class="koboSpan" id="kobo.775.1"> node and create a new </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">Sequence</span></strong><span class="koboSpan" id="kobo.777.1"> node. </span><span class="koboSpan" id="kobo.777.2">Call this </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">node </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">ShootNearbyTargets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.781.1">Place this new node to the left of the </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">MoveToTargetLocation</span></strong><span class="koboSpan" id="kobo.783.1"> node. </span><span class="koboSpan" id="kobo.783.2">This ensures that this node is considered first (i.e., it has a </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">higher priority).</span></span></li>
<li><span class="koboSpan" id="kobo.785.1">Drag from the bottom of the </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">ShootNearbyTargets</span></strong><span class="koboSpan" id="kobo.787.1"> sequence node to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">Rotate to face BB</span></strong><span class="koboSpan" id="kobo.789.1"> entry task – this will cause the character to face </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">its target.</span></span></li>
<li><span class="koboSpan" id="kobo.791.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.792.1">Blackboard Key</span></strong><span class="koboSpan" id="kobo.793.1"> on the </span><strong class="bold"><span class="koboSpan" id="kobo.794.1">Rotate to face BB</span></strong><span class="koboSpan" id="kobo.795.1"> entry task </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">TargetEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.799.1">Drag from the bottom of the </span><strong class="bold"><span class="koboSpan" id="kobo.800.1">ShootNearbyTargets</span></strong><span class="koboSpan" id="kobo.801.1"> sequence node again and add a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">BTT_ShootTarget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1"> task.</span></span></li>
<li><span class="koboSpan" id="kobo.804.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.805.1">Blackboard Key</span></strong><span class="koboSpan" id="kobo.806.1"> on the </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">BTT_ShootTarget</span></strong><span class="koboSpan" id="kobo.808.1"> task to </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.810.1"> if not </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">set automatically.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.812.1"><img alt="Figure 4.21 – The behavior tree so far with a new sequence and tasks added" src="image/Figure_04.21_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.813.1">Figure 4.21 – The behavior tree so far with a new sequence and tasks added</span></p>
<p><span class="koboSpan" id="kobo.814.1">The main structure </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.815.1">of the branches is now complete; what we don’t have, however, is any way of identifying and setting the target identity. </span><span class="koboSpan" id="kobo.815.2">We are going to use a service to find our nearest target and a decorator to identify when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.817.1"> key has changed in order to choose when to complete the tasks in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">ShootNearbyTargets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1"> sequence.</span></span></p>
<h3><span class="koboSpan" id="kobo.820.1">Identifying enemy targets with a service</span></h3>
<p><span class="koboSpan" id="kobo.821.1">To identify the </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.822.1">enemies around the character, we are going to place a sphere trace within a service on the </span><strong class="bold"><span class="koboSpan" id="kobo.823.1">RootSelector</span></strong><span class="koboSpan" id="kobo.824.1"> selector node. </span><span class="koboSpan" id="kobo.824.2">This will provide the required information to the decision-making processes below as to what part of the tree will run, reducing the need to do tasks that don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">return successes.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">So, let’s start by creating </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">a service:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.828.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">New Service</span></strong><span class="koboSpan" id="kobo.830.1"> button at the top of the </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">Behavior </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.832.1">Tree</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.833.1"> editor.</span></span></li>
<li><span class="koboSpan" id="kobo.834.1">Ensure the asset is being saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">Blueprint</span></strong><span class="koboSpan" id="kobo.836.1"> folder and set </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">Name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.838.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">BTS_Find</span></strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">NearestTarget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.842.1">Open the new asset (if it doesn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">open automatically).</span></span></li>
<li><span class="koboSpan" id="kobo.844.1">Create a new float variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">SearchRadius</span></strong><span class="koboSpan" id="kobo.846.1">, set its default as </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">500</span></strong><span class="koboSpan" id="kobo.848.1">, and make it</span><strong class="bold"> </strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.849.1">Instance Editable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.851.1">Create a new Blackboard key selector variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.853.1"> and make it </span><strong class="bold"><span class="koboSpan" id="kobo.854.1">Instance Editable</span></strong><span class="koboSpan" id="kobo.855.1">. </span><span class="koboSpan" id="kobo.855.2">Just like when creating the </span><em class="italic"><span class="koboSpan" id="kobo.856.1">Shoot Target</span></em><span class="koboSpan" id="kobo.857.1"> task, it is vital this is spelled correctly, matching the Blackboard </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">key name.</span></span></li>
<li><span class="koboSpan" id="kobo.859.1">Override the </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">Receive Tick AI</span></strong><span class="koboSpan" id="kobo.861.1"> function by either right-clicking on the graph and searching for the node or using the </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">override dropdown.</span></span></li>
<li><span class="koboSpan" id="kobo.863.1">Add </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.864.1">a </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">Sphere Trace For Objects</span></strong><span class="koboSpan" id="kobo.866.1"> node and set it up </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">as shown:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.868.1"><img alt="Figure 4.22 – Sphere trace for pawns other than the unit doing the search" src="image/Figure_04.22_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.869.1">Figure 4.22 – Sphere trace for pawns other than the unit doing the search</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.870.1">Check the </span><strong class="bold"><span class="koboSpan" id="kobo.871.1">Return Value</span></strong><span class="koboSpan" id="kobo.872.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.873.1">True</span></strong><span class="koboSpan" id="kobo.874.1"> and set the </span><strong class="bold"><span class="koboSpan" id="kobo.875.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.876.1"> Blackboard value to the </span><strong class="bold"><span class="koboSpan" id="kobo.877.1">Hit Actor</span></strong><span class="koboSpan" id="kobo.878.1"> output of the </span><strong class="bold"><span class="koboSpan" id="kobo.879.1">Out Hit</span></strong><span class="koboSpan" id="kobo.880.1"> struct pin using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">Break Hit Result</span></strong><span class="koboSpan" id="kobo.882.1"> node, </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">as shown:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.884.1"><img alt="Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor" src="image/Figure_04.23_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.885.1">Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.886.1">If the </span><strong class="bold"><span class="koboSpan" id="kobo.887.1">Return Value</span></strong><span class="koboSpan" id="kobo.888.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.889.1">False</span></strong><span class="koboSpan" id="kobo.890.1">, clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.892.1"> key using a </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">Clear Blackboard Value</span></strong><span class="koboSpan" id="kobo.894.1"> node. </span><span class="koboSpan" id="kobo.894.2">This can be created by dragging from the </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">TargetEntity</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.896.1">variable </span></span><span class="No-Break"><a id="_idIndexMarker181"/></span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.898.1">The service Blueprint is now complete and looks as shown in the following screenshot. </span><span class="koboSpan" id="kobo.898.2">If you would like to visualize the sphere trace in order to determine whether the </span><strong class="bold"><span class="koboSpan" id="kobo.899.1">Search Radius</span></strong><span class="koboSpan" id="kobo.900.1"> variable is suitable, set the </span><strong class="bold"><span class="koboSpan" id="kobo.901.1">Draw Debug Type</span></strong><span class="koboSpan" id="kobo.902.1"> dropdown in the </span><strong class="bold"><span class="koboSpan" id="kobo.903.1">Sphere Trace For Objects</span></strong><span class="koboSpan" id="kobo.904.1"> node to </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">For </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.906.1">One Frame</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.908.1"><img alt="Figure 4.24 – Completed service logic" src="image/Figure_04.24_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.909.1">Figure 4.24 – Completed service logic</span></p>
<p><span class="koboSpan" id="kobo.910.1">With the service created, we can now add it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">Root</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.912.1"> selector:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.913.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">BT_EliteUnit</span></strong><span class="koboSpan" id="kobo.915.1"> behavior tree, right-click the </span><strong class="bold"><span class="koboSpan" id="kobo.916.1">RootSelector</span></strong><span class="koboSpan" id="kobo.917.1"> node, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.918.1">Add Service…</span></strong><span class="koboSpan" id="kobo.919.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.920.1">BTS Find </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.921.1">Nearest Target</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.923.1">Make sure the </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">Target Entity</span></strong><span class="koboSpan" id="kobo.925.1"> value is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.927.1"> and that the search radius is showing as </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">500</span></strong><span class="koboSpan" id="kobo.929.1">. </span><span class="koboSpan" id="kobo.929.2">The search variable can be changed depending on the needs</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.930.1"> of the behavior tree it is being </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">added to.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.932.1"><img alt="Figure 4.25 – RootSelector with service added" src="image/Figure_04.25_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.933.1">Figure 4.25 – RootSelector with service added</span></p>
<p><span class="koboSpan" id="kobo.934.1">With the service added, the </span><strong class="bold"><span class="koboSpan" id="kobo.935.1">RootSelector</span></strong><span class="koboSpan" id="kobo.936.1"> should now look as shown in the preceding screenshot. </span><span class="koboSpan" id="kobo.936.2">You may need to rearrange your nodes to accommodate its </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">increased size.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">Now that we have the selector set up to find the nearest target, we can use the result of that service to define whether the shooting part of our behavior tree can </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">be executed.</span></span></p>
<h3><span class="koboSpan" id="kobo.940.1">Adding a decorator to activate the shooting sequence</span></h3>
<p><span class="koboSpan" id="kobo.941.1">In order to</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.942.1"> ensure that the character only tries to rotate and shoot at a target that exists, we need to make sure we only run those tasks when </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.944.1"> has a valid value (this is why we clear the value when the sphere trace returns no hit results). </span><span class="koboSpan" id="kobo.944.2">We are going to add a decorator to </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">ShootNearbyTargets</span></strong><span class="koboSpan" id="kobo.946.1">. </span><span class="koboSpan" id="kobo.946.2">A decorator (known as a conditional in other behavior tree systems) defines whether a branch or node can be executed. </span><span class="koboSpan" id="kobo.946.3">We will use the decorator to monitor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.948.1"> Blackboard key value to see if we have anything to shoot; when we do, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">ShootNearbyTargets</span></strong><span class="koboSpan" id="kobo.950.1"> sequence can </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">be executed:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.952.1">Right-click the </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">ShootNearbyTargets</span></strong><span class="koboSpan" id="kobo.954.1"> sequence node, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.955.1">Add Decorator…</span></strong><span class="koboSpan" id="kobo.956.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">choose </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.958.1">Blackboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.960.1">Select the decorator (the blue box that has now appeared) and rename the </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">node </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">TargetFound</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.964.1">Ensure</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.965.1"> that </span><strong class="bold"><span class="koboSpan" id="kobo.966.1">Blackboard Key</span></strong><span class="koboSpan" id="kobo.967.1"> = </span><strong class="bold"><span class="koboSpan" id="kobo.968.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.969.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.970.1">Key Query</span></strong><span class="koboSpan" id="kobo.971.1"> = </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.972.1">Is Set</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.974.1"><img alt="Figure 4.26 – The final behavior tree" src="image/Figure_04.26_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.975.1">Figure 4.26 – The final behavior tree</span></p>
<p><span class="koboSpan" id="kobo.976.1">If you now test the system by playing in the viewport, you should be able to select and move the green character near either of the red characters. </span><span class="koboSpan" id="kobo.976.2">When the green character stops, it will find the nearest target, turn, and should create a print string of </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">Shoot</span></strong><span class="koboSpan" id="kobo.978.1">. </span><span class="koboSpan" id="kobo.978.2">It will continue to do so until the target is no longer valid, which, at this point, will be an eternity as we are not dealing any damage to the unit. </span><span class="koboSpan" id="kobo.978.3">You also won’t be able to move the character once it finds a target because there is currently no way of getting the AI to move away from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">BTT_ShootTarget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.980.1"> task.</span></span></p>
<p><span class="koboSpan" id="kobo.981.1">To damage the enemy unit, making use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">Health</span></strong><span class="koboSpan" id="kobo.983.1"> component we created earlier, we need to replace the </span><strong class="bold"><span class="koboSpan" id="kobo.984.1">Print String</span></strong><span class="koboSpan" id="kobo.985.1"> node in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">BP_EliteUnit</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.987.1">Attack Target</span></strong><span class="koboSpan" id="kobo.988.1"> event with </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.989.1">some logic to confirm the line of sight and then </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">apply damage:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.991.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">BP_EliteUnit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.993.1">character Blueprint.</span></span></li>
<li><span class="koboSpan" id="kobo.994.1">Delete the </span><strong class="bold"><span class="koboSpan" id="kobo.995.1">Print String</span></strong><span class="koboSpan" id="kobo.996.1"> node from the </span><strong class="bold"><span class="koboSpan" id="kobo.997.1">Event Attack Target</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.998.1">logic chain.</span></span></li>
<li><span class="koboSpan" id="kobo.999.1">Cast the </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">TargetToAttack</span></strong><span class="koboSpan" id="kobo.1001.1"> object to </span><strong class="bold"><span class="koboSpan" id="kobo.1002.1">Actor</span></strong><span class="koboSpan" id="kobo.1003.1"> in order to get the actor’s location and use that as part of a </span><strong class="bold"><span class="koboSpan" id="kobo.1004.1">Line Trace By Channel</span></strong><span class="koboSpan" id="kobo.1005.1">, as shown in the following screenshot. </span><span class="koboSpan" id="kobo.1005.2">The line trace has been set up to draw onscreen for 5 seconds so we can confirm the trace is </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">happening correctly.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.1007.1"><img alt="Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor" src="image/Figure_04.27_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1008.1">Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1009.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">Break Hit Result</span></strong><span class="koboSpan" id="kobo.1011.1"> node from the </span><strong class="bold"><span class="koboSpan" id="kobo.1012.1">Out Hit</span></strong><span class="koboSpan" id="kobo.1013.1"> pin of </span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">the Line Trace By Channel</span></strong><span class="koboSpan" id="kobo.1015.1"> and compare </span><strong class="bold"><span class="koboSpan" id="kobo.1016.1">Hit Actor</span></strong><span class="koboSpan" id="kobo.1017.1"> to the </span><strong class="bold"><span class="koboSpan" id="kobo.1018.1">Target to Attack</span></strong><span class="koboSpan" id="kobo.1019.1"> variable from the </span><strong class="bold"><span class="koboSpan" id="kobo.1020.1">Event Attack Target</span></strong><span class="koboSpan" id="kobo.1021.1"> node. </span><span class="koboSpan" id="kobo.1021.2">If </span><strong class="bold"><span class="koboSpan" id="kobo.1022.1">True</span></strong><span class="koboSpan" id="kobo.1023.1">, add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">Apply Damage</span></strong><span class="koboSpan" id="kobo.1025.1"> node with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">100</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1027.1">Base Damage</span></strong><span class="koboSpan" id="kobo.1028.1">; if </span><strong class="bold"><span class="koboSpan" id="kobo.1029.1">False</span></strong><span class="koboSpan" id="kobo.1030.1">, the trace has hit something else, so at this stage of development, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">Print String</span></strong><span class="koboSpan" id="kobo.1032.1"> node for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">No Line </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">of Sight</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.1036.1"><img alt="Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes at the bottom left are routed from the As Actor pin of the Cast to Actor node" src="image/Figure_04.28_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1037.1">Figure 4.28 – Apply damage to target actor if confirmed. </span><span class="koboSpan" id="kobo.1037.2">The reroute nodes at the bottom left are routed from the As Actor pin of the Cast to Actor node</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.1038.1">Lastly, to </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.1039.1">enable the enemy unit to be destroyed, we need to utilize the </span><strong class="bold"><span class="koboSpan" id="kobo.1040.1">OnComponentDead</span></strong><span class="koboSpan" id="kobo.1041.1"> event from the </span><strong class="bold"><span class="koboSpan" id="kobo.1042.1">Health</span></strong><span class="koboSpan" id="kobo.1043.1"> component by linking it to a </span><strong class="bold"><span class="koboSpan" id="kobo.1044.1">Destroy </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1045.1">Actor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1"> node:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.1047.1"><img alt="Figure 4.29 – Health component death event linked to a Destroy Actor node" src="image/Figure_04.29_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1048.1">Figure 4.29 – Health component death event linked to a Destroy Actor node</span></p>
<p><span class="koboSpan" id="kobo.1049.1">Next, we will look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">final thoughts.</span></span></p>
<h3><span class="koboSpan" id="kobo.1051.1">Testing and final thoughts</span></h3>
<p><span class="koboSpan" id="kobo.1052.1">Testing the game now should remove the enemy instead of continually printing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">Shoot</span></strong><span class="koboSpan" id="kobo.1054.1">. </span><span class="koboSpan" id="kobo.1054.2">This will result in the target entity being cleared, which in turn will allow you to move the </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">character again.</span></span></p>
<p><span class="koboSpan" id="kobo.1056.1">While we now have a successful AI-controlled unit that moves and shoots, there is one other thing that is worth exploring, which is the </span><strong class="bold"><span class="koboSpan" id="kobo.1057.1">Observer aborts</span></strong><span class="koboSpan" id="kobo.1058.1"> setting on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">TargetFound</span></strong><span class="koboSpan" id="kobo.1060.1"> decorator. </span><span class="koboSpan" id="kobo.1060.2">We originally left this set as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">None</span></strong><span class="koboSpan" id="kobo.1062.1">, which means the unit will complete its </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">Move To</span></strong><span class="koboSpan" id="kobo.1064.1"> task before considering shooting. </span><span class="koboSpan" id="kobo.1064.2">We can change this to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">shoot</span></strong><span class="koboSpan" id="kobo.1066.1"> as soon as it detects an enemy with a simple change of </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">this value:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1068.1">Select the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">TargetFound</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1"> decorator.</span></span></li>
<li><span class="koboSpan" id="kobo.1071.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1072.1">Details</span></strong><span class="koboSpan" id="kobo.1073.1"> panel, set the </span><strong class="bold"><span class="koboSpan" id="kobo.1074.1">Notify Observer</span></strong><span class="koboSpan" id="kobo.1075.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1076.1">On </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1077.1">Result Change</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1079.1">Change the </span><strong class="bold"><span class="koboSpan" id="kobo.1080.1">Observer aborts</span></strong><span class="koboSpan" id="kobo.1081.1"> to </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1082.1">Lower Priority</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1084.1">Test the game again. </span><span class="koboSpan" id="kobo.1084.2">You should now see that if you tell the unit to move past one of the enemies, it will stop en route to engage with the target. </span><span class="koboSpan" id="kobo.1084.3">This is because the decorator has identified a change in the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">TargetEntity</span></strong><span class="koboSpan" id="kobo.1086.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">BTS_FindNearestTarget</span></strong><span class="koboSpan" id="kobo.1088.1"> service and can now interrupt any lower-priority branch of the behavior tree, so any node which is to the right of it in the selector, which in this case includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">MoveToTargetLocation</span></strong><span class="koboSpan" id="kobo.1090.1"> sequence, which holds the </span><strong class="bold"><span class="koboSpan" id="kobo.1091.1">Move </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1092.1">To</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1"> task.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.1094.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1095.1">In this chapter, we have discussed the game development patterns that are present as premade tools and systems inside Unreal Engine. </span><span class="koboSpan" id="kobo.1095.2">Namely, the component, update, and behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">tree patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.1097.1">We made a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">Health</span></strong><span class="koboSpan" id="kobo.1099.1"> component that will hopefully prove useful in your future projects, along with a simple behavior tree showing each major piece of the system. </span><span class="koboSpan" id="kobo.1099.2">Armed with this knowledge, you should be able to make a functional AI system for any of your future </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">Unreal projects.</span></span></p>
<p><span class="koboSpan" id="kobo.1101.1">The next chapter will take what we have learned about the update method and explain how we can do better. </span><span class="koboSpan" id="kobo.1101.2">What is the impact of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">Tick</span></strong><span class="koboSpan" id="kobo.1103.1"> within the engine and how can you measure </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">that impact?</span></span></p>
</div>


<div class="Content" id="_idContainer099">
<h1 id="_idParaDest-67" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1.1">Part 2: Anonymous Modular Design</span></h1>
</div>
<div id="_idContainer100">
<p><span class="koboSpan" id="kobo.2.1">In this part, we will begin creating more efficient code to build modular solutions that communicate with each other efficiently and cleanly, without the use of direct references </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">and casts.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">We will start by reducing the need for gated polling in our code by replacing it with cleaner communication methods, and we will explore interfaces and event delegates to allow our code to be decoupled. </span><span class="koboSpan" id="kobo.4.2">This will culminate in a coding design paradigm we call Anonymous Modular Design, which should make our object-oriented code the most maintainable and expandable it </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">can be.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Forgetting Tick</span></em></li>
<li><a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Clean Communication – Interface and Event Observer Patterns</span></em></li>
<li><a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">A Perfectly Decoupled System</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer101">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer102">
</div>
</div>
</body></html>