<html><head></head><body>
		<div><p><a id="_idTextAnchor339"/></p>
			<h1 id="_idParaDest-328"><em class="italic"><a id="_idTextAnchor340"/>Chapter 17</em>: Sound Spatialization and the HUD</h1>
			<p>In this chapter, we will be adding all the sound effects and the HUD. We have done this in two of the previous projects, but we will do things a bit differently this time. We will explore the concept of sound <strong class="bold">spatialization</strong> and how SFML makes this otherwise complicated concept nice and easy. In addition, we will build a HUD class to encapsulate our code that draws information to the screen.</p>
			<p>We will complete these tasks in the following order.</p>
			<ul>
				<li>What is spatialization?</li>
				<li>How SFML handles spatialization</li>
				<li>Building a SoundManager class</li>
				<li>Deploying emitters</li>
				<li>Using the SoundManager class</li>
				<li>Building a <code>HUD</code> class</li>
				<li>Using the <code>HUD</code> class</li>
			</ul>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor341"/>What is spatialization?</h1>
			<p><strong class="bold">Spatialization</strong> is the act of making something relative to the space it is a part of, or within. In our daily lives, everything in the natural world, by default, is spatialized. If a motorbike whizzes past from left to right, we will hear the sound grow from faint to loud from one side to the other. As it passes by, it will become more prominent in the other ear, before fading into the distance once more. If we were to wake up one morning and the world was no longer spatialized, it would be exceptionally weird.</p>
			<p>If we can make our video games a little bit more like the real world, our players can become more immersed. Our zombie game would have been a lot more fun if the player could have heard them faintly in the distance and their inhuman wailing grew louder as they drew closer, from one direction or another.</p>
			<p>It is probably obvious that the mathematics of spatialization will be complex. How do we calculate how loud a given sound will be in a specific speaker based on the distance and direction from the player (the hearer of the sound) to the object that is making the sound (the emitter)?</p>
			<p>Fortunately, SFML does all the complicated processes for us. All we need to do is get familiar with a few technical terms and then we can start using SFML to spatialize our sound effects.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor342"/>Emitters, attenuation, and listeners</h2>
			<p>We will need to be aware of a few pieces of information in order to give SFML what it needs to do its work. We will need to be aware of where the sound is coming from in our game world. This source of the sound is called an <strong class="bold">emitter</strong>. In a game, the emitter could be a zombie, a vehicle, or in the case of our current project, a fire tile. We have already been keeping track of the position of the objects in our game, so giving SFML the emitter's location will be quite straightforward.</p>
			<p>The next factor we need to be aware of is <strong class="bold">attenuation</strong>. Attenuation is the rate at which a wave deteriorates. You could simplify that statement and make it specific to sound and say that attenuation is how quickly the sound reduces in volume. It isn't technically accurate, but it is a good enough description for the purposes of this chapter and our game. </p>
			<p>The final factor that we need to consider is the <strong class="bold">listener</strong>. When SFML spatializes the sound, where is it spatializing it relative to; where are the "ears" of the game.? In most games, the logical thing to do is use the player character. In our game, we will use Thomas (our player character).</p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor343"/>Handling spatialization using SFML</h1>
			<p>SFML has several functions that allow us to handle emitters, attenuation, and listeners. Let's take a look at them hypothetically and then we will write some code to add spatialized sound to our project for real.</p>
			<p>We can set up a sound effect ready to be played, as we have done so often already, like this:</p>
			<pre>// Declare SoundBuffer in the usual way
SoundBuffer zombieBuffer;
// Declare a Sound object as-per-usual
Sound zombieSound;
// Load the sound from a file like we have done so often
zombieBuffer.loadFromFile("sound/zombie_growl.wav");
// Associate the Sound object with the Buffer
zombieSound.setBuffer(zombieBuffer);</pre>
			<p>We can set the position of the emitter using the <code>setPosition</code> function shown in the following code:</p>
			<pre>// Set the horizontal and vertical positions of the emitter
// In this case the emitter is a zombie
// In the Zombie Arena project we could have used 
// getPosition().x and getPosition().y
// These values are arbitrary
float x = 500;
float y = 500;
zombieSound.setPosition(x, y, 0.0f);</pre>
			<p>As suggested in the comments of the previous code, how exactly we can obtain the coordinates of the emitter will probably be dependent on the type of game. As shown in the previous code, this would be quite simple in the Zombie Arena project. We will have a few challenges to overcome when we set the position in this project.</p>
			<p>We can set the attenuation level as follows:</p>
			<pre>zombieSound.setAttenuation(15);</pre>
			<p>The actual attenuation level can be a little ambiguous. The effect that we want the player to get might be different from the accurate scientific formula that is used to reduce the volume over distance based on attenuation. Getting the right attenuation level is usually achieved by experimenting. The higher the level of attenuation, the quicker the sound level reduces to silence.</p>
			<p>Also, we might want to set a zone around the emitter where the volume is not attenuated at all. We might do this if the feature isn't appropriate beyond a certain range or if we have many sound sources and don't won't to "overdo" the feature. To do so, we can use the <code>setMinimumDistance</code> function as shown here:</p>
			<pre>zombieSound.setMinDistance(150);</pre>
			<p>With the previous line of code, attenuation would not  be calculated until the listener is 150 pixels/units away from the emitter.</p>
			<p>Some other useful functions from the SFML library include the <code>setLoop</code> function. This function will tell SFML to keep playing the sound over and over when <code>true</code> is passed in as a parameter, like in the following code:</p>
			<pre>zombieSound.setLoop(true);</pre>
			<p>The sound would continue to play until we end it with the following code:</p>
			<pre>zombieSound.stop();</pre>
			<p>From time to time, we would want to know the status of a sound (playing or stopped). We can achieve this with the <code>getStatus</code> function, as demonstrated in the following code:</p>
			<pre>if (zombieSound.getStatus() == Sound::Status::Stopped)
{
    // The sound is NOT playing
    // Take whatever action here
}
if (zombieSound.getStatus() == Sound::Status::Playing)
{
    // The sound IS playing
    // Take whatever action here
}</pre>
			<p>There is just one more aspect of using sound spatialization with SFML that we need to cover. The listener. Where is the listener? We can set the position of the listener with the following code:</p>
			<pre>// Where is the listener? 
// How we get the values of x and y varies depending upon the game
// In the Zombie Arena game or the Thomas Was Late game
// We can use getPosition()
Listener::setPosition(m_Thomas.getPosition().x, 
    m_Thomas.getPosition().y, 0.0f);</pre>
			<p>The preceding code will make all the sounds play relative to that location. This is just what we need for the distant roar of a fire tile or incoming zombie, but for regular sound effects like jumping, this is a problem. We could start handling an emitter for the location of the player, but SFML makes things simple for us. Whenever we want to play a "normal" sound, we simply call <code>setRelativeToListener</code>, as shown in the following code, and then play the sound in the exact same way we have done so far. Here is how we might play a "normal" unspatialized jump sound effect:</p>
			<pre>jumpSound.setRelativeToListener(true);
jumpSound.play();</pre>
			<p>All we need to do is call <code>Listener::setPosition</code> again before we play any spatialized sounds.</p>
			<p>We now have a wide repertoire of SFML sound functions, and we are ready to make some spatialized noise for real.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor344"/>Building the SoundManager class</h1>
			<p>You might recall from the previous project that all the sound code took up quite a few lines of code. Now, consider that, with spatialization, it's going to get longer still. To keep our code manageable, we will code a class to manage all our sound effects being played. In addition, to help us with spatialization, we will add a function to the <code>Engine</code> class as well, but we will discuss that when we come to it, later in this chapter.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor345"/>Coding SoundManager.h</h2>
			<p>Let's get started by coding and examining the header file. </p>
			<p>Right-click <code>SoundManager.h</code>. Finally, click the <code>SoundManager</code> class.</p>
			<p>Add and examine the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Audio.hpp&gt;
using namespace sf;
class SoundManager
{
    private:
        // The buffers
        SoundBuffer m_FireBuffer;
        SoundBuffer m_FallInFireBuffer;
        SoundBuffer m_FallInWaterBuffer;
        SoundBuffer m_JumpBuffer;
        SoundBuffer m_ReachGoalBuffer;
        // The Sounds
        Sound m_Fire1Sound;
        Sound m_Fire2Sound;
        Sound m_Fire3Sound;
        Sound m_FallInFireSound;
        Sound m_FallInWaterSound;
        Sound m_JumpSound;
        Sound m_ReachGoalSound;
        // Which sound should we use next, fire 1, 2 or 3
        int m_NextSound = 1;
    public:
        SoundManager();
        void playFire(Vector2f emitterLocation, 
            Vector2f listenerLocation);
        void playFallInFire();
        void playFallInWater();
        void playJump();
        void playReachGoal();
};</pre>
			<p>There is nothing tricky in the code we just added. There are five <code>SoundBuffer</code> objects and eight <code>Sound</code> objects. Three of the <code>Sound</code> objects will play the same <code>SoundBuffer</code>. This explains the reason for the different number of <code>Sound</code>/<code>SoundBuffer</code> objects. We do this so that we can have multiple roaring sound effects playing, with different spatialized parameters, simultaneously.</p>
			<p>Note the <code>m_NextSound</code> variable, which will help us keep track of which of these simultaneous sounds we should use next.</p>
			<p>There is a constructor, <code>SoundManager</code>, where we will set up all our sound effects, and there are five functions that will play the sound effects. Four of these functions simply play "normal" sound effects and their code will be simpler. </p>
			<p>One of the functions, <code>playFire</code>, will handle the spatialized sound effects and will be a bit more in-depth. Notice the parameters of the <code>playFire</code> function. It receives a <code>Vector2f</code>, which is the location of the emitter and a second <code>Vector2f</code>, which is the location of the listener.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor346"/>Coding the SoundManager.cpp file</h2>
			<p>Now, we can code the function definitions. The constructor and the <code>playFire</code> functions have a large amount of code, so we will look at them individually. The other functions are short and sweet, so we will handle them all at once.</p>
			<p>Right-click <code>SoundManager.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>SoundManager</code> class.</p>
			<h3>Coding the constructor</h3>
			<p>Add the following code for the include directives and the constructor to <code>SoundManager.cpp</code>:</p>
			<pre>#include "SoundManager.h"
#include &lt;SFML/Audio.hpp&gt;
using namespace sf;
SoundManager::SoundManager()
{
    // Load the sound in to the buffers
    m_FireBuffer.loadFromFile("sound/fire1.wav");
    m_FallInFireBuffer.loadFromFile("sound/fallinfire.wav");
    m_FallInWaterBuffer.loadFromFile("sound/fallinwater.wav");
    m_JumpBuffer.loadFromFile("sound/jump.wav");
    m_ReachGoalBuffer.loadFromFile("sound/reachgoal.wav");
    // Associate the sounds with the buffers
    m_Fire1Sound.setBuffer(m_FireBuffer);
    m_Fire2Sound.setBuffer(m_FireBuffer);
    m_Fire3Sound.setBuffer(m_FireBuffer);
    m_FallInFireSound.setBuffer(m_FallInFireBuffer);
    m_FallInWaterSound.setBuffer(m_FallInWaterBuffer);
    m_JumpSound.setBuffer(m_JumpBuffer);
    m_ReachGoalSound.setBuffer(m_ReachGoalBuffer);
            
    // When the player is 50 pixels away sound is full volume
    float minDistance = 150;
    // The sound reduces steadily as the player moves further away
    float attenuation = 15;
    // Set all the attenuation levels
    m_Fire1Sound.setAttenuation(attenuation);
    m_Fire2Sound.setAttenuation(attenuation);
    m_Fire3Sound.setAttenuation(attenuation);
    // Set all the minimum distance levels
    m_Fire1Sound.setMinDistance(minDistance);
    m_Fire2Sound.setMinDistance(minDistance);
    m_Fire3Sound.setMinDistance(minDistance);
    // Loop all the fire sounds
    // when they are played
    m_Fire1Sound.setLoop(true);
    m_Fire2Sound.setLoop(true);
    m_Fire3Sound.setLoop(true);
}</pre>
			<p>In the previous code, we loaded five sound files into the five <code>SoundBuffer</code> objects. Next, we associated the eight <code>Sound</code> objects with one of the <code>SoundBuffer</code> objects. Notice that <code>m_Fire1Sound</code>, <code>m_Fire2Sound</code>, and <code>m_Fire3Sound</code> are all going to be playing from the same <code>SoundBuffer</code>, <code>m_FireBuffer</code>.</p>
			<p>Next, we set the attenuation and minimum distance for the three fire sounds. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The values of <code>150</code> and <code>15</code>, respectively, were arrived at through experimentation. Once the game is running, it is advisable to experiment with these values by changing them around and seeing (or rather, hearing) the difference.</p>
			<p>Finally, for the constructor, we use the <code>setLoop</code> function on each of the fire-related <code>Sound</code> objects. Now, when we call <code>play</code>, they will play continuously.</p>
			<h3>Coding the playFire function</h3>
			<p>Add the <code>playFire</code> function as follows. Then, we can discuss it:</p>
			<pre>void SoundManager::playFire(
    Vector2f emitterLocation, Vector2f listenerLocation)
{
    // Where is the listener? Thomas.
    Listener::setPosition(listenerLocation.x, 
        listenerLocation.y, 0.0f);
    switch(m_NextSound)
    {
    case 1:
        // Locate/move the source of the sound
        m_Fire1Sound.setPosition(emitterLocation.x, 
            emitterLocation.y, 0.0f);
        if (m_Fire1Sound.getStatus() == Sound::Status::Stopped)
        {
            // Play the sound, if its not already
            m_Fire1Sound.play();
        }
        break;
    case 2:
        // Do the same as previous for the second sound
        m_Fire2Sound.setPosition(emitterLocation.x, 
            emitterLocation.y, 0.0f);
        if (m_Fire2Sound.getStatus() == Sound::Status::Stopped)
        {
            m_Fire2Sound.play();
        }
        break;
    case 3:
        // Do the same as previous for the third sound
        m_Fire3Sound.setPosition(emitterLocation.x, 
            emitterLocation.y, 0.0f);
        if (m_Fire3Sound.getStatus() == Sound::Status::Stopped)
        {
            m_Fire3Sound.play();
        }
        break;
    }
    // Increment to the next fire sound
    m_NextSound++;
    // Go back to 1 when the third sound has been started
    if (m_NextSound &gt; 3)
    {
        m_NextSound = 1;
    }
}</pre>
			<p>The first thing we do is call <code>Listener::setPosition</code> and set the location of the listener based on the <code>Vector2f</code> that is passed in as a parameter.</p>
			<p>Next, the code enters a <code>switch</code> block that tests the value of <code>m_NextSound</code>. Each of the <code>case</code> statements does the exact same thing but to either <code>m_Fire1Sound</code>, <code>m_Fire2Sound</code>, or <code>m_Fire3Sound</code>. </p>
			<p>In each of the <code>case</code> blocks, we set the position of the emitter using the passed in parameter with the <code>setPosition</code> function. The next part of the code in each <code>case</code> block checks whether the sound is currently stopped, and, if it is, plays the sound. Soon, we will see how we arrive at the positions for the emitter and listener that are passed into this function.</p>
			<p>The final part of the <code>playFire</code> function increments <code>m_NextSound</code> and ensures that it can only be equal to 1, 2, or 3, as required by the <code>switch</code> block.</p>
			<h3>Coding the rest of the SoundManager functions</h3>
			<p>Add these four simple functions:</p>
			<pre>void SoundManager::playFallInFire()
{
    m_FallInFireSound.setRelativeToListener(true);
    m_FallInFireSound.play();
}
void SoundManager::playFallInWater()
{
    m_FallInWaterSound.setRelativeToListener(true);
    m_FallInWaterSound.play();
}
void SoundManager::playJump()
{
    m_JumpSound.setRelativeToListener(true);
    m_JumpSound.play();
}
void SoundManager::playReachGoal()
{
    m_ReachGoalSound.setRelativeToListener(true);
    m_ReachGoalSound.play();
}</pre>
			<p>The <code>playFallInFire</code>, <code>playFallInWater</code>, and <code>playReachGoal</code> functions do just two things. First, they each call <code>setRelativeToListener</code> so that the sound effect is not spatialized, making the sound effect "normal", not directional, and then they call <code>play</code> on the appropriate <code>Sound</code> object.</p>
			<p>That concludes the <code>SoundManager</code> class. Now, we can use it in the <code>Engine</code> class.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor347"/>Adding SoundManager to the game engine</h1>
			<p>Open the <code>Engine.h</code> file and add an instance of the new <code>SoundManager</code> class, as shown in the following highlighted code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "TextureHolder.h"
#include "Thomas.h"
#include "Bob.h"
#include "LevelManager.h"
<strong class="bold">#include "SoundManager.h"</strong>
using namespace sf;
class Engine
{
private:
    // The texture holder
    TextureHolder th;
    // Thomas and his friend, Bob
    Thomas m_Thomas;
    Bob m_Bob;
    // A class to manage all the levels
    LevelManager m_LM;
<strong class="bold">    // Create a SoundManager</strong>
<strong class="bold">    SoundManager m_SM;</strong>
    const int TILE_SIZE = 50;
    const int VERTS_IN_QUAD = 4;</pre>
			<p>At this point, we could use <code>m_SM</code> to call the various <code>play...</code> functions. Unfortunately, there is still a bit more work to be done in order to manage the locations of the emitters (fire tiles).</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor348"/>Populating the sound emitters</h1>
			<p>Open the <code>Engine.h</code> file and add a new prototype for a <code>populateEmitters</code> function and a new STL <code>vector</code> of <code>Vector2f</code> objects:</p>
			<pre>    ...
    ...
    ...
    // Run will call all the private functions
    bool detectCollisions(PlayableCharacter&amp; character);
<strong class="bold">    // Make a vector of the best places to emit sounds from</strong>
<strong class="bold">    void populateEmitters(vector &lt;Vector2f&gt;&amp; vSoundEmitters,</strong>
<strong class="bold">        int** arrayLevel);</strong>
<strong class="bold">    // A vector of Vector2f for the fire emitter locations</strong>
<strong class="bold">    vector &lt;Vector2f&gt; m_FireEmitters;</strong>
    
public:
    ...
    ...
    ...</pre>
			<p>The <code>populateEmitters</code> function takes a <code>vector</code> of <code>Vector2f</code> objects as a parameter, as well as a pointer to pointer to <code>int</code> (a two-dimensional array). The <code>vector</code> will hold the location of each emitter in a level. The array is the two-dimensional array that holds the layout of a level.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor349"/>Coding the populateEmitters function</h2>
			<p>The job of the <code>populateEmitters</code> function is to scan through all the elements of <code>arrayLevel</code> and decide where to put the emitters. It will store its results in <code>m_FireEmitters</code>.</p>
			<p>Right-click <code>PopulateEmitters.cpp</code>. Finally, click the <code>populateEmitters</code>.</p>
			<p>Add the code in its entirety. Be sure to study the code as you do, so that we can discuss it:</p>
			<pre>#include "Engine.h"
using namespace sf;
using namespace std;
void Engine::populateEmitters(
    vector &lt;Vector2f&gt;&amp; vSoundEmitters, 
   int** arrayLevel)
{
    // Make sure the vector is empty
    vSoundEmitters.empty();
    // Keep track of the previous emitter
    // so we don't make too many
    FloatRect previousEmitter;
    // Search for fire in the level
    for (int x = 0; x &lt; (int)m_LM.getLevelSize().x; x++)
    {
        for (int y = 0; y &lt; (int)m_LM.getLevelSize().y; y++)
        {
            if (arrayLevel[y][x] == 2)// fire is present
            {
                // Skip over any fire tiles too 
                // near a previous emitter
                if (!FloatRect(x * TILE_SIZE,
                    y * TILE_SIZE,
                    TILE_SIZE,
                    TILE_SIZE).intersects(previousEmitter))
                {
                    // Add the coordinates of this water block
                    vSoundEmitters.push_back(
                        Vector2f(x * TILE_SIZE, y * TILE_SIZE));
                    // Make a rectangle 6 blocks x 6 blocks,
                    // so we don't make any more emitters 
                    // too close to this one
                    previousEmitter.left = x * TILE_SIZE;
                    previousEmitter.top = y * TILE_SIZE;
                    previousEmitter.width = TILE_SIZE * 6;
                    previousEmitter.height = TILE_SIZE * 6;
                }
            }
        }
    }
    return;
}</pre>
			<p>Some of the code might appear complex at first glance. Understanding the technique we are using to choose where an emitter will be makes this simpler. In our levels, there are large blocks of fire tiles. For example, in one of the levels, there are more than 30 fire tiles together in a group. The code makes sure that there is only one emitter within a given rectangle. This rectangle is stored in <code>previousEmitter</code> and is 300 pixels by 300 pixels (<code>TILE_SIZE * 6</code>).</p>
			<p>The code sets up a nested <code>for</code> loop that loops through <code>arrayLevel</code>, looking for fire tiles. When it finds one, it makes sure that it does not intersect with <code>previousEmitter</code>. Only then does it use the <code>pushBack</code> function to add another emitter to <code>vSoundEmitters</code>. After doing so, it also updates <code>previousEmitter</code> to avoid getting large clusters of sound emitters.</p>
			<p>Let's make some noise.</p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor350"/>Playing sounds</h1>
			<p>Open the <code>LoadLevel.cpp</code> file and add the call to the new <code>populateEmitters</code> function, as highlighted in the following code:</p>
			<pre>void Engine::loadLevel()
{
    m_Playing = false;
    // Delete the previously allocated memory
    for (int i = 0; i &lt; m_LM.getLevelSize().y; ++i)
    {
        delete[] m_ArrayLevel[i];
    }
    delete[] m_ArrayLevel;
    // Load the next 2d array with the map for the level
    // And repopulate the vertex array as well
    m_ArrayLevel = m_LM.nextLevel(m_VALevel);
<strong class="bold">    // Prepare the sound emitters</strong>
<strong class="bold">    populateEmitters(m_FireEmitters, m_ArrayLevel);</strong>
    // How long is this new time limit
    m_TimeRemaining = m_LM.getTimeLimit();
    // Spawn Thomas and Bob
    m_Thomas.spawn(m_LM.getStartPosition(), GRAVITY);
    m_Bob.spawn(m_LM.getStartPosition(), GRAVITY);
    // Make sure this code isn't run again
    m_NewLevelRequired = false;
}</pre>
			<p>The first sound to add is the jump sound. We remember that the keyboard handling code is in the pure virtual functions within both the <code>Bob</code> and <code>Thomas</code> classes and that the <code>handleInput</code> function returns <code>true</code> when a jump has been successfully initiated.</p>
			<p>Open the <code>Input.cpp</code> file and add the following highlighted lines of code to play a jump sound when Thomas or Bob successfully begins a jump:</p>
			<pre>// Handle input specific to Thomas
if (m_Thomas.handleInput())
{
    // Play a jump sound
<strong class="bold">    m_SM.playJump();</strong>
}
// Handle input specific to Bob
if (m_Bob.handleInput())
{
    // Play a jump sound
<strong class="bold">    m_SM.playJump();</strong>
}</pre>
			<p>Open the <code>Update.cpp</code> file and add the following highlighted line of code to play a success sound when Thomas and Bob have simultaneously reached the goal for the current level:</p>
			<pre>// Detect collisions and see if characters have reached the goal tile
// The second part of the if condition is only executed
// when Thomas is touching the home tile
if (detectCollisions(m_Thomas) &amp;&amp; detectCollisions(m_Bob))
{
    // New level required
    m_NewLevelRequired = true;
    // Play the reach goal sound
<strong class="bold">    m_SM.playReachGoal();</strong>
}
else
{
    // Run Bobs collision detection
    detectCollisions(m_Bob);
}</pre>
			<p>Also, within the <code>Update.cpp</code> file, we will add code to loop through the <code>m_FireEmitters</code> vector and decide when we need to call the <code>playFire</code> function of the <code>SoundManager</code> class.</p>
			<p>Look closely at the small amount of context around the new highlighted code. It is essential to add this code in exactly the right place:</p>
			<pre>}// End if playing
<strong class="bold">// Check if a fire sound needs to be played</strong>
<strong class="bold">vector&lt;Vector2f&gt;::iterator it;</strong>
<strong class="bold">// Iterate through the vector of Vector2f objects</strong>
<strong class="bold">for (it = m_FireEmitters.begin(); it != m_FireEmitters.end(); it++)</strong>
<strong class="bold">{</strong>
<strong class="bold">    // Where is this emitter?</strong>
<strong class="bold">    // Store the location in pos</strong>
<strong class="bold">    float posX = (*it).x;</strong>
<strong class="bold">    float posY = (*it).y;</strong>
<strong class="bold">    // is the emitter near the player?</strong>
<strong class="bold">    // Make a 500 pixel rectangle around the emitter</strong>
<strong class="bold">    FloatRect localRect(posX - 250, posY - 250, 500, 500);</strong>
<strong class="bold">    // Is the player inside localRect?</strong>
<strong class="bold">    if (m_Thomas.getPosition().intersects(localRect))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Play the sound and pass in the location as well</strong>
<strong class="bold">        m_SM.playFire(Vector2f(posX, posY), m_Thomas.getCenter());</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong>
    
// Set the appropriate view around the appropriate character</pre>
			<p>The preceding code is a bit like collision detection for sound. Whenever Thomas strays within a 500 by 500-pixel rectangle surrounding a fire emitter, the <code>playFire</code> function is called, passing in the coordinates of the emitter and of Thomas. The <code>playFire</code> function does the rest of the work and plays a spatialized, looping sound effect.</p>
			<p>Open the <code>DetectCollisions.cpp</code> file, find the appropriate place, and add the following highlighted code. The two highlighted lines of code trigger the sound effect when either character falls into a water or fire tile:</p>
			<pre>// Has character been burnt or drowned?
// Use head as this allows him to sink a bit
if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)
{
    if (character.getHead().intersects(block))
    {
        character.spawn(m_LM.getStartPosition(), GRAVITY);
        // Which sound should be played?
        if (m_ArrayLevel[y][x] == 2)// Fire, ouch!
        {
            // Play a sound
<strong class="bold">            m_SM.playFallInFire();</strong>
        }
        else // Water
        {
            // Play a sound
<strong class="bold">            m_SM.playFallInWater();</strong>
        }
    }
}</pre>
			<p>Playing the game will now allow you to hear all the sounds, including cool spatialization, when you're near a fire tile.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor351"/>Implementing the HUD class</h1>
			<p>The HUD is super-simple and not really anything different compared to the Zombie Arena project. What we will do that is different is wrap all the code up in a new <code>HUD</code> class. If we declare all the <code>Font</code>, <code>Text</code>, and other variables as members of this new class, we can then initialize them in the constructor and provide getter functions to all their values. This will keep the <code>Engine</code> class clear from loads of declarations and initializations.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor352"/>Coding HUD.h</h2>
			<p>First, we will code the <code>HUD.h</code> file with all the member variables and function declarations. Right-click <code>HUD.h</code>. Finally, click the <code>HUD</code> class.</p>
			<p>Add the following code to <code>HUD.h</code>:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Hud
{
private:
    Font m_Font;
    Text m_StartText;
    Text m_TimeText;
    Text m_LevelText;
public:
    Hud();
    Text getMessage();
    Text getLevel();
    Text getTime();
    void setLevel(String text);
    void setTime(String text);
};</pre>
			<p>In the preceding code, we added one <code>Font</code> instance and three <code>Text</code> instances. The <code>Text</code> objects will be used to show a message prompting the user to start, the time remaining, and the current level number. </p>
			<p>The public functions are more interesting. First, there is the constructor where most of the code will go. The constructor will initialize the <code>Font</code> and <code>Text</code> objects, as well as position them on the screen relative to the current screen resolution. </p>
			<p>The three getter functions, <code>getMessage</code>, <code>getLevel</code>, and <code>getTime</code>, will return a <code>Text</code> object to the calling code so that it can draw them to the screen.</p>
			<p>The <code>setLevel</code> and <code>setTime</code> functions will be used to update the text shown in <code>m_LevelText</code> and <code>m_TimeText</code>, respectively.</p>
			<p>Now, we can code all the definitions for the functions we have just declared.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor353"/>Coding the HUD.cpp file</h2>
			<p>Right-click <code>HUD.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>HUD</code> class.</p>
			<p>Add the include directives and the following code. Then, we will discuss it:</p>
			<pre>#include "Hud.h"
Hud::Hud()
{
    Vector2u resolution;
    resolution.x = VideoMode::getDesktopMode().width;
    resolution.y = VideoMode::getDesktopMode().height;
    // Load the font
    m_Font.loadFromFile("fonts/Roboto-Light.ttf");
    // when Paused
    m_StartText.setFont(m_Font);
    m_StartText.setCharacterSize(100);
    m_StartText.setFillColor(Color::White);
    m_StartText.setString("Press Enter when ready!");
    // Position the text
    FloatRect textRect = m_StartText.getLocalBounds();
    m_StartText.setOrigin(textRect.left +
        textRect.width / 2.0f,
        textRect.top +
        textRect.height / 2.0f);
    m_StartText.setPosition(
        resolution.x / 2.0f, resolution.y / 2.0f);
    // Time
    m_TimeText.setFont(m_Font);
    m_TimeText.setCharacterSize(75);
    m_TimeText.setFillColor(Color::White);
    m_TimeText.setPosition(resolution.x - 150, 0);
    m_TimeText.setString("------");
    // Level
    m_LevelText.setFont(m_Font);
    m_LevelText.setCharacterSize(75);
    m_LevelText.setFillColor(Color::White);
    m_LevelText.setPosition(25, 0);
    m_LevelText.setString("1");
}</pre>
			<p>First, we store the horizontal and vertical resolution in a <code>Vector2u</code> called <code>resolution</code>. Next, we load the font from the <code>fonts</code> directory that we added back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>. </p>
			<p>The next four lines of code set the font, the color, the size, and the text of <code>m_StartText</code>. The block of code after this captures the size of the rectangle that wraps <code>m_StartText</code> and performs a calculation to work out how to position it centrally on the screen. If you want a more thorough explanation of this part of the code, then refer to <a href="B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 3</em></a>, <em class="italic">C++ Strings and SFML Time – Player Input and HUD</em>.</p>
			<p>In the final two blocks of code in the constructor, the font, text size, color, position, and actual text for <code>m_TimeText</code> and <code>m_LevelText</code> are set. In a moment, we will see that these two <code>Text</code> objects will be updatable through two setter functions, whenever it is required.</p>
			<p>Add the following getter and setter functions immediately underneath the code we have just added:</p>
			<pre>Text Hud::getMessage()
{
    return m_StartText;
}
Text Hud::getLevel()
{
    return m_LevelText;
}
Text Hud::getTime()
{
    return m_TimeText;
}
void Hud::setLevel(String text)
{
    m_LevelText.setString(text);
}
void Hud::setTime(String text)
{
    m_TimeText.setString(text);
}</pre>
			<p>The first three functions in the previous code simply return the appropriate <code>Text</code> object, that is, <code>m_StartText</code>, <code>m_LevelText</code>, or <code>m_TimeText</code>. We will use these functions shortly when we draw the HUD to the screen. The final two functions, <code>setLevel</code> and <code>setTime</code>, use the <code>setString</code> functions to update the appropriate <code>Text</code> object with the value that will be passed in from the <code>update</code> function of the <code>Engine</code> class, every 500 frames.</p>
			<p>With all that done, we can put the HUD class to work in our game engine.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor354"/>Using the HUD class</h1>
			<p>Open <code>Engine.h</code>, add an include for our new class, declare an instance of the new <code>HUD</code> class, and declare and initialize two new member variables that will keep track of how often we update the HUD. As we learned in the previous projects, we don't need to update the HUD every frame.</p>
			<p> Add the following highlighted code to <code>Engine.h</code>:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "TextureHolder.h"
#include "Thomas.h"
#include "Bob.h"
#include "LevelManager.h"
#include "SoundManager.h"
<strong class="bold">#include "HUD.h"</strong>
using namespace sf;
class Engine
{
private:
    // The texture holder
    TextureHolder th;
    // Thomas and his friend, Bob
    Thomas m_Thomas;
    Bob m_Bob;
    // A class to manage all the levels
    LevelManager m_LM;
    // Create a SoundManager
    SoundManager m_SM;
<strong class="bold">    // The Hud</strong>
<strong class="bold">    Hud m_Hud;</strong>
<strong class="bold">    int m_FramesSinceLastHUDUpdate = 0;</strong>
<strong class="bold">    int m_TargetFramesPerHUDUpdate = 500;</strong>
    const int TILE_SIZE = 50;</pre>
			<p>Next, we need to add some code to the <code>update</code> function of the <code>Engine</code> class. Open <code>Update.cpp</code> and add the following highlighted code to update the HUD once every 500 frames:</p>
			<pre>    // Set the appropriate view around the appropriate character
    if (m_SplitScreen)
    {
        m_LeftView.setCenter(m_Thomas.getCenter());
        m_RightView.setCenter(m_Bob.getCenter());
    }
    else
    {
        // Centre full screen around appropriate character
        if (m_Character1)
        {
            m_MainView.setCenter(m_Thomas.getCenter());
        }
        else
        {
            m_MainView.setCenter(m_Bob.getCenter());
        }
    }
<strong class="bold">    // Time to update the HUD?</strong>
<strong class="bold">    // Increment the number of frames since </strong>
<strong class="bold">   // the last HUD calculation</strong>
<strong class="bold">    m_FramesSinceLastHUDUpdate++;</strong>
<strong class="bold">    // Update the HUD every m_TargetFramesPerHUDUpdate frames</strong>
<strong class="bold">    if (m_FramesSinceLastHUDUpdate &gt; m_TargetFramesPerHUDUpdate)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Update game HUD text</strong>
<strong class="bold">        stringstream ssTime;</strong>
<strong class="bold">        stringstream ssLevel;</strong>
<strong class="bold">        // Update the time text</strong>
<strong class="bold">        ssTime &lt;&lt; (int)m_TimeRemaining;</strong>
<strong class="bold">        m_Hud.setTime(ssTime.str());</strong>
<strong class="bold">        // Update the level text</strong>
<strong class="bold">        ssLevel &lt;&lt; "Level:" &lt;&lt; m_LM.getCurrentLevel();</strong>
<strong class="bold">        m_Hud.setLevel(ssLevel.str());</strong>
<strong class="bold">        m_FramesSinceLastHUDUpdate = 0;</strong>
<strong class="bold">    }</strong>
}// End of update function</pre>
			<p>In the preceding code, <code>m_FramesSinceLastUpdate</code> is incremented each frame. When <code>m_FramesSinceLastUpdate</code> exceeds <code>m_TargetFramesPerHUDUpdate</code>, then execution enters the <code>if</code> block. Inside the <code>if</code> block, we use <code>stringstream</code> objects to update our <code>Text</code>, like we did in the previous projects. In this project, we are using the <code>HUD</code> class, so we call the <code>setTime</code> and <code>setLevel</code> functions by passing in the current values that the <code>Text</code> objects need to be set to.</p>
			<p>The final step in the <code>if</code> block is to set <code>m_FramesSinceLastUpdate</code> back to zero so it can start counting toward the next update.</p>
			<p>Finally, open the <code>Draw.cpp</code> file and add the following highlighted code to draw the HUD each frame:</p>
			<pre>    else
    {
        // Split-screen view is active
        // First draw Thomas' side of the screen
        // Switch to background view
        m_Window.setView(m_BGLeftView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_LeftView
        m_Window.setView(m_LeftView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
            
        // Draw thomas
        m_Window.draw(m_Bob.getSprite());
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        
        // Now draw Bob's side of the screen
        // Switch to background view
        m_Window.setView(m_BGRightView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_RightView
        m_Window.setView(m_RightView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
                
    }
    // Draw the HUD
    // Switch to m_HudView
    m_Window.setView(m_HudView);
<strong class="bold">    m_Window.draw(m_Hud.getLevel());</strong>
<strong class="bold">    m_Window.draw(m_Hud.getTime());</strong>
<strong class="bold">    if (!m_Playing)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_Window.draw(m_Hud.getMessage());</strong>
<strong class="bold">    }</strong>
    // Show everything we have just drawn
    m_Window.display();
}// End of draw</pre>
			<p>The preceding code draws the HUD by using the getter functions from the HUD class. Notice that the call to draw the message that prompts the player to start is only used when the game is not currently playing <code>(!m_Playing)</code>.</p>
			<p>Run the game and play a few levels to see the time tick down and the levels tick up. When you get back to level 1 again, notice that you have 10% less time than before.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor355"/>Summary</h1>
			<p>In this chapter, we have explored sound spatialization. Our "Thomas Was Late" game is not only fully playable now, but we have added directional sound effects and a simple but informative HUD. We can also add new levels with ease. At this point, we could call it a day.</p>
			<p>It would be nice to add a bit more sparkle. In the next chapter, we will look into two gaming concepts. First, we will look at particle systems, which are how we can handle things such as explosions or other special effects. To achieve this, we will need to learn a bit more C++. Due to this, the topic of multiple inheritance will be introduced.</p>
			<p>After that, we will add the final flourish to the game when we learn about OpenGL and the programmable graphics pipeline. We will then be able to dip our toes into the <strong class="bold">GLSL</strong> language, which allows us to write code that executes directly on the GPU so that we can create some special effects.</p>
		</div>
	</body></html>