<html><head></head><body>
		<div id="_idContainer110">
			<p><a id="_idTextAnchor339"/></p>
			<h1 id="_idParaDest-328"><em class="italic"><a id="_idTextAnchor340"/>Chapter 17</em>: Sound Spatialization and the HUD</h1>
			<p>In this chapter, we will be adding all the sound effects and the HUD. We have done this in two of the previous projects, but we will do things a bit differently this time. We will explore the concept of sound <strong class="bold">spatialization</strong> and how SFML makes this otherwise complicated concept nice and easy. In addition, we will build a HUD class to encapsulate our code that draws information to the screen.</p>
			<p>We will complete these tasks in the following order.</p>
			<ul>
				<li>What is spatialization?</li>
				<li>How SFML handles spatialization</li>
				<li>Building a SoundManager class</li>
				<li>Deploying emitters</li>
				<li>Using the SoundManager class</li>
				<li>Building a <strong class="source-inline">HUD</strong> class</li>
				<li>Using the <strong class="source-inline">HUD</strong> class</li>
			</ul>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor341"/>What is spatialization?</h1>
			<p><strong class="bold">Spatialization</strong> is the act of making something relative to the space it is a part of, or within. In our daily lives, everything in the natural world, by default, is spatialized. If a motorbike whizzes past from left to right, we will hear the sound grow from faint to loud from one side to the other. As it passes by, it will become more prominent in the other ear, before fading into the distance once more. If we were to wake up one morning and the world was no longer spatialized, it would be exceptionally weird.</p>
			<p>If we can make our video games a little bit more like the real world, our players can become more immersed. Our zombie game would have been a lot more fun if the player could have heard them faintly in the distance and their inhuman wailing grew louder as they drew closer, from one direction or another.</p>
			<p>It is probably obvious that the mathematics of spatialization will be complex. How do we calculate how loud a given sound will be in a specific speaker based on the distance and direction from the player (the hearer of the sound) to the object that is making the sound (the emitter)?</p>
			<p>Fortunately, SFML does all the complicated processes for us. All we need to do is get familiar with a few technical terms and then we can start using SFML to spatialize our sound effects.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor342"/>Emitters, attenuation, and listeners</h2>
			<p>We will need to be aware of a few pieces of information in order to give SFML what it needs to do its work. We will need to be aware of where the sound is coming from in our game world. This source of the sound is called an <strong class="bold">emitter</strong>. In a game, the emitter could be a zombie, a vehicle, or in the case of our current project, a fire tile. We have already been keeping track of the position of the objects in our game, so giving SFML the emitter's location will be quite straightforward.</p>
			<p>The next factor we need to be aware of is <strong class="bold">attenuation</strong>. Attenuation is the rate at which a wave deteriorates. You could simplify that statement and make it specific to sound and say that attenuation is how quickly the sound reduces in volume. It isn't technically accurate, but it is a good enough description for the purposes of this chapter and our game. </p>
			<p>The final factor that we need to consider is the <strong class="bold">listener</strong>. When SFML spatializes the sound, where is it spatializing it relative to; where are the "ears" of the game.? In most games, the logical thing to do is use the player character. In our game, we will use Thomas (our player character).</p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor343"/>Handling spatialization using SFML</h1>
			<p>SFML has several functions that allow us to handle emitters, attenuation, and listeners. Let's take a look at them hypothetically and then we will write some code to add spatialized sound to our project for real.</p>
			<p>We can set up a sound effect ready to be played, as we have done so often already, like this:</p>
			<p class="source-code">// Declare SoundBuffer in the usual way</p>
			<p class="source-code">SoundBuffer zombieBuffer;</p>
			<p class="source-code">// Declare a Sound object as-per-usual</p>
			<p class="source-code">Sound zombieSound;</p>
			<p class="source-code">// Load the sound from a file like we have done so often</p>
			<p class="source-code">zombieBuffer.loadFromFile("sound/zombie_growl.wav");</p>
			<p class="source-code">// Associate the Sound object with the Buffer</p>
			<p class="source-code">zombieSound.setBuffer(zombieBuffer);</p>
			<p>We can set the position of the emitter using the <strong class="source-inline">setPosition</strong> function shown in the following code:</p>
			<p class="source-code">// Set the horizontal and vertical positions of the emitter</p>
			<p class="source-code">// In this case the emitter is a zombie</p>
			<p class="source-code">// In the Zombie Arena project we could have used </p>
			<p class="source-code">// getPosition().x and getPosition().y</p>
			<p class="source-code">// These values are arbitrary</p>
			<p class="source-code">float x = 500;</p>
			<p class="source-code">float y = 500;</p>
			<p class="source-code">zombieSound.setPosition(x, y, 0.0f);</p>
			<p>As suggested in the comments of the previous code, how exactly we can obtain the coordinates of the emitter will probably be dependent on the type of game. As shown in the previous code, this would be quite simple in the Zombie Arena project. We will have a few challenges to overcome when we set the position in this project.</p>
			<p>We can set the attenuation level as follows:</p>
			<p class="source-code">zombieSound.setAttenuation(15);</p>
			<p>The actual attenuation level can be a little ambiguous. The effect that we want the player to get might be different from the accurate scientific formula that is used to reduce the volume over distance based on attenuation. Getting the right attenuation level is usually achieved by experimenting. The higher the level of attenuation, the quicker the sound level reduces to silence.</p>
			<p>Also, we might want to set a zone around the emitter where the volume is not attenuated at all. We might do this if the feature isn't appropriate beyond a certain range or if we have many sound sources and don't won't to "overdo" the feature. To do so, we can use the <strong class="source-inline">setMinimumDistance</strong> function as shown here:</p>
			<p class="source-code">zombieSound.setMinDistance(150);</p>
			<p>With the previous line of code, attenuation would not  be calculated until the listener is 150 pixels/units away from the emitter.</p>
			<p>Some other useful functions from the SFML library include the <strong class="source-inline">setLoop</strong> function. This function will tell SFML to keep playing the sound over and over when <strong class="source-inline">true</strong> is passed in as a parameter, like in the following code:</p>
			<p class="source-code">zombieSound.setLoop(true);</p>
			<p>The sound would continue to play until we end it with the following code:</p>
			<p class="source-code">zombieSound.stop();</p>
			<p>From time to time, we would want to know the status of a sound (playing or stopped). We can achieve this with the <strong class="source-inline">getStatus</strong> function, as demonstrated in the following code:</p>
			<p class="source-code">if (zombieSound.getStatus() == Sound::Status::Stopped)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // The sound is NOT playing</p>
			<p class="source-code">    // Take whatever action here</p>
			<p class="source-code">}</p>
			<p class="source-code">if (zombieSound.getStatus() == Sound::Status::Playing)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // The sound IS playing</p>
			<p class="source-code">    // Take whatever action here</p>
			<p class="source-code">}</p>
			<p>There is just one more aspect of using sound spatialization with SFML that we need to cover. The listener. Where is the listener? We can set the position of the listener with the following code:</p>
			<p class="source-code">// Where is the listener? </p>
			<p class="source-code">// How we get the values of x and y varies depending upon the game</p>
			<p class="source-code">// In the Zombie Arena game or the Thomas Was Late game</p>
			<p class="source-code">// We can use getPosition()</p>
			<p class="source-code">Listener::setPosition(m_Thomas.getPosition().x, </p>
			<p class="source-code">    m_Thomas.getPosition().y, 0.0f);</p>
			<p>The preceding code will make all the sounds play relative to that location. This is just what we need for the distant roar of a fire tile or incoming zombie, but for regular sound effects like jumping, this is a problem. We could start handling an emitter for the location of the player, but SFML makes things simple for us. Whenever we want to play a "normal" sound, we simply call <strong class="source-inline">setRelativeToListener</strong>, as shown in the following code, and then play the sound in the exact same way we have done so far. Here is how we might play a "normal" unspatialized jump sound effect:</p>
			<p class="source-code">jumpSound.setRelativeToListener(true);</p>
			<p class="source-code">jumpSound.play();</p>
			<p>All we need to do is call <strong class="source-inline">Listener::setPosition</strong> again before we play any spatialized sounds.</p>
			<p>We now have a wide repertoire of SFML sound functions, and we are ready to make some spatialized noise for real.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor344"/>Building the SoundManager class</h1>
			<p>You might recall from the previous project that all the sound code took up quite a few lines of code. Now, consider that, with spatialization, it's going to get longer still. To keep our code manageable, we will code a class to manage all our sound effects being played. In addition, to help us with spatialization, we will add a function to the <strong class="source-inline">Engine</strong> class as well, but we will discuss that when we come to it, later in this chapter.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor345"/>Coding SoundManager.h</h2>
			<p>Let's get started by coding and examining the header file. </p>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">SoundManager.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">SoundManager</strong> class.</p>
			<p>Add and examine the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Audio.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class SoundManager</p>
			<p class="source-code">{</p>
			<p class="source-code">    private:</p>
			<p class="source-code">        // The buffers</p>
			<p class="source-code">        SoundBuffer m_FireBuffer;</p>
			<p class="source-code">        SoundBuffer m_FallInFireBuffer;</p>
			<p class="source-code">        SoundBuffer m_FallInWaterBuffer;</p>
			<p class="source-code">        SoundBuffer m_JumpBuffer;</p>
			<p class="source-code">        SoundBuffer m_ReachGoalBuffer;</p>
			<p class="source-code">        // The Sounds</p>
			<p class="source-code">        Sound m_Fire1Sound;</p>
			<p class="source-code">        Sound m_Fire2Sound;</p>
			<p class="source-code">        Sound m_Fire3Sound;</p>
			<p class="source-code">        Sound m_FallInFireSound;</p>
			<p class="source-code">        Sound m_FallInWaterSound;</p>
			<p class="source-code">        Sound m_JumpSound;</p>
			<p class="source-code">        Sound m_ReachGoalSound;</p>
			<p class="source-code">        // Which sound should we use next, fire 1, 2 or 3</p>
			<p class="source-code">        int m_NextSound = 1;</p>
			<p class="source-code">    public:</p>
			<p class="source-code">        SoundManager();</p>
			<p class="source-code">        void playFire(Vector2f emitterLocation, </p>
			<p class="source-code">            Vector2f listenerLocation);</p>
			<p class="source-code">        void playFallInFire();</p>
			<p class="source-code">        void playFallInWater();</p>
			<p class="source-code">        void playJump();</p>
			<p class="source-code">        void playReachGoal();</p>
			<p class="source-code">};</p>
			<p>There is nothing tricky in the code we just added. There are five <strong class="source-inline">SoundBuffer</strong> objects and eight <strong class="source-inline">Sound</strong> objects. Three of the <strong class="source-inline">Sound</strong> objects will play the same <strong class="source-inline">SoundBuffer</strong>. This explains the reason for the different number of <strong class="source-inline">Sound</strong>/<strong class="source-inline">SoundBuffer</strong> objects. We do this so that we can have multiple roaring sound effects playing, with different spatialized parameters, simultaneously.</p>
			<p>Note the <strong class="source-inline">m_NextSound</strong> variable, which will help us keep track of which of these simultaneous sounds we should use next.</p>
			<p>There is a constructor, <strong class="source-inline">SoundManager</strong>, where we will set up all our sound effects, and there are five functions that will play the sound effects. Four of these functions simply play "normal" sound effects and their code will be simpler. </p>
			<p>One of the functions, <strong class="source-inline">playFire</strong>, will handle the spatialized sound effects and will be a bit more in-depth. Notice the parameters of the <strong class="source-inline">playFire</strong> function. It receives a <strong class="source-inline">Vector2f</strong>, which is the location of the emitter and a second <strong class="source-inline">Vector2f</strong>, which is the location of the listener.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor346"/>Coding the SoundManager.cpp file</h2>
			<p>Now, we can code the function definitions. The constructor and the <strong class="source-inline">playFire</strong> functions have a large amount of code, so we will look at them individually. The other functions are short and sweet, so we will handle them all at once.</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">SoundManager.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">SoundManager</strong> class.</p>
			<h3>Coding the constructor</h3>
			<p>Add the following code for the include directives and the constructor to <strong class="source-inline">SoundManager.cpp</strong>:</p>
			<p class="source-code">#include "SoundManager.h"</p>
			<p class="source-code">#include &lt;SFML/Audio.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">SoundManager::SoundManager()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Load the sound in to the buffers</p>
			<p class="source-code">    m_FireBuffer.loadFromFile("sound/fire1.wav");</p>
			<p class="source-code">    m_FallInFireBuffer.loadFromFile("sound/fallinfire.wav");</p>
			<p class="source-code">    m_FallInWaterBuffer.loadFromFile("sound/fallinwater.wav");</p>
			<p class="source-code">    m_JumpBuffer.loadFromFile("sound/jump.wav");</p>
			<p class="source-code">    m_ReachGoalBuffer.loadFromFile("sound/reachgoal.wav");</p>
			<p class="source-code">    // Associate the sounds with the buffers</p>
			<p class="source-code">    m_Fire1Sound.setBuffer(m_FireBuffer);</p>
			<p class="source-code">    m_Fire2Sound.setBuffer(m_FireBuffer);</p>
			<p class="source-code">    m_Fire3Sound.setBuffer(m_FireBuffer);</p>
			<p class="source-code">    m_FallInFireSound.setBuffer(m_FallInFireBuffer);</p>
			<p class="source-code">    m_FallInWaterSound.setBuffer(m_FallInWaterBuffer);</p>
			<p class="source-code">    m_JumpSound.setBuffer(m_JumpBuffer);</p>
			<p class="source-code">    m_ReachGoalSound.setBuffer(m_ReachGoalBuffer);</p>
			<p class="source-code">            </p>
			<p class="source-code">    // When the player is 50 pixels away sound is full volume</p>
			<p class="source-code">    float minDistance = 150;</p>
			<p class="source-code">    // The sound reduces steadily as the player moves further away</p>
			<p class="source-code">    float attenuation = 15;</p>
			<p class="source-code">    // Set all the attenuation levels</p>
			<p class="source-code">    m_Fire1Sound.setAttenuation(attenuation);</p>
			<p class="source-code">    m_Fire2Sound.setAttenuation(attenuation);</p>
			<p class="source-code">    m_Fire3Sound.setAttenuation(attenuation);</p>
			<p class="source-code">    // Set all the minimum distance levels</p>
			<p class="source-code">    m_Fire1Sound.setMinDistance(minDistance);</p>
			<p class="source-code">    m_Fire2Sound.setMinDistance(minDistance);</p>
			<p class="source-code">    m_Fire3Sound.setMinDistance(minDistance);</p>
			<p class="source-code">    // Loop all the fire sounds</p>
			<p class="source-code">    // when they are played</p>
			<p class="source-code">    m_Fire1Sound.setLoop(true);</p>
			<p class="source-code">    m_Fire2Sound.setLoop(true);</p>
			<p class="source-code">    m_Fire3Sound.setLoop(true);</p>
			<p class="source-code">}</p>
			<p>In the previous code, we loaded five sound files into the five <strong class="source-inline">SoundBuffer</strong> objects. Next, we associated the eight <strong class="source-inline">Sound</strong> objects with one of the <strong class="source-inline">SoundBuffer</strong> objects. Notice that <strong class="source-inline">m_Fire1Sound</strong>, <strong class="source-inline">m_Fire2Sound</strong>, and <strong class="source-inline">m_Fire3Sound</strong> are all going to be playing from the same <strong class="source-inline">SoundBuffer</strong>, <strong class="source-inline">m_FireBuffer</strong>.</p>
			<p>Next, we set the attenuation and minimum distance for the three fire sounds. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The values of <strong class="source-inline">150</strong> and <strong class="source-inline">15</strong>, respectively, were arrived at through experimentation. Once the game is running, it is advisable to experiment with these values by changing them around and seeing (or rather, hearing) the difference.</p>
			<p>Finally, for the constructor, we use the <strong class="source-inline">setLoop</strong> function on each of the fire-related <strong class="source-inline">Sound</strong> objects. Now, when we call <strong class="source-inline">play</strong>, they will play continuously.</p>
			<h3>Coding the playFire function</h3>
			<p>Add the <strong class="source-inline">playFire</strong> function as follows. Then, we can discuss it:</p>
			<p class="source-code">void SoundManager::playFire(</p>
			<p class="source-code">    Vector2f emitterLocation, Vector2f listenerLocation)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Where is the listener? Thomas.</p>
			<p class="source-code">    Listener::setPosition(listenerLocation.x, </p>
			<p class="source-code">        listenerLocation.y, 0.0f);</p>
			<p class="source-code">    switch(m_NextSound)</p>
			<p class="source-code">    {</p>
			<p class="source-code">    case 1:</p>
			<p class="source-code">        // Locate/move the source of the sound</p>
			<p class="source-code">        m_Fire1Sound.setPosition(emitterLocation.x, </p>
			<p class="source-code">            emitterLocation.y, 0.0f);</p>
			<p class="source-code">        if (m_Fire1Sound.getStatus() == Sound::Status::Stopped)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Play the sound, if its not already</p>
			<p class="source-code">            m_Fire1Sound.play();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 2:</p>
			<p class="source-code">        // Do the same as previous for the second sound</p>
			<p class="source-code">        m_Fire2Sound.setPosition(emitterLocation.x, </p>
			<p class="source-code">            emitterLocation.y, 0.0f);</p>
			<p class="source-code">        if (m_Fire2Sound.getStatus() == Sound::Status::Stopped)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_Fire2Sound.play();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 3:</p>
			<p class="source-code">        // Do the same as previous for the third sound</p>
			<p class="source-code">        m_Fire3Sound.setPosition(emitterLocation.x, </p>
			<p class="source-code">            emitterLocation.y, 0.0f);</p>
			<p class="source-code">        if (m_Fire3Sound.getStatus() == Sound::Status::Stopped)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_Fire3Sound.play();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Increment to the next fire sound</p>
			<p class="source-code">    m_NextSound++;</p>
			<p class="source-code">    // Go back to 1 when the third sound has been started</p>
			<p class="source-code">    if (m_NextSound &gt; 3)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_NextSound = 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The first thing we do is call <strong class="source-inline">Listener::setPosition</strong> and set the location of the listener based on the <strong class="source-inline">Vector2f</strong> that is passed in as a parameter.</p>
			<p>Next, the code enters a <strong class="source-inline">switch</strong> block that tests the value of <strong class="source-inline">m_NextSound</strong>. Each of the <strong class="source-inline">case</strong> statements does the exact same thing but to either <strong class="source-inline">m_Fire1Sound</strong>, <strong class="source-inline">m_Fire2Sound</strong>, or <strong class="source-inline">m_Fire3Sound</strong>. </p>
			<p>In each of the <strong class="source-inline">case</strong> blocks, we set the position of the emitter using the passed in parameter with the <strong class="source-inline">setPosition</strong> function. The next part of the code in each <strong class="source-inline">case</strong> block checks whether the sound is currently stopped, and, if it is, plays the sound. Soon, we will see how we arrive at the positions for the emitter and listener that are passed into this function.</p>
			<p>The final part of the <strong class="source-inline">playFire</strong> function increments <strong class="source-inline">m_NextSound</strong> and ensures that it can only be equal to 1, 2, or 3, as required by the <strong class="source-inline">switch</strong> block.</p>
			<h3>Coding the rest of the SoundManager functions</h3>
			<p>Add these four simple functions:</p>
			<p class="source-code">void SoundManager::playFallInFire()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_FallInFireSound.setRelativeToListener(true);</p>
			<p class="source-code">    m_FallInFireSound.play();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundManager::playFallInWater()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_FallInWaterSound.setRelativeToListener(true);</p>
			<p class="source-code">    m_FallInWaterSound.play();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundManager::playJump()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_JumpSound.setRelativeToListener(true);</p>
			<p class="source-code">    m_JumpSound.play();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundManager::playReachGoal()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ReachGoalSound.setRelativeToListener(true);</p>
			<p class="source-code">    m_ReachGoalSound.play();</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">playFallInFire</strong>, <strong class="source-inline">playFallInWater</strong>, and <strong class="source-inline">playReachGoal</strong> functions do just two things. First, they each call <strong class="source-inline">setRelativeToListener</strong> so that the sound effect is not spatialized, making the sound effect "normal", not directional, and then they call <strong class="source-inline">play</strong> on the appropriate <strong class="source-inline">Sound</strong> object.</p>
			<p>That concludes the <strong class="source-inline">SoundManager</strong> class. Now, we can use it in the <strong class="source-inline">Engine</strong> class.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor347"/>Adding SoundManager to the game engine</h1>
			<p>Open the <strong class="source-inline">Engine.h</strong> file and add an instance of the new <strong class="source-inline">SoundManager</strong> class, as shown in the following highlighted code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include "Thomas.h"</p>
			<p class="source-code">#include "Bob.h"</p>
			<p class="source-code">#include "LevelManager.h"</p>
			<p class="source-code"><strong class="bold">#include "SoundManager.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Engine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // The texture holder</p>
			<p class="source-code">    TextureHolder th;</p>
			<p class="source-code">    // Thomas and his friend, Bob</p>
			<p class="source-code">    Thomas m_Thomas;</p>
			<p class="source-code">    Bob m_Bob;</p>
			<p class="source-code">    // A class to manage all the levels</p>
			<p class="source-code">    LevelManager m_LM;</p>
			<p class="source-code"><strong class="bold">    // Create a SoundManager</strong></p>
			<p class="source-code"><strong class="bold">    SoundManager m_SM;</strong></p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p class="source-code">    const int VERTS_IN_QUAD = 4;</p>
			<p>At this point, we could use <strong class="source-inline">m_SM</strong> to call the various <strong class="source-inline">play...</strong> functions. Unfortunately, there is still a bit more work to be done in order to manage the locations of the emitters (fire tiles).</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor348"/>Populating the sound emitters</h1>
			<p>Open the <strong class="source-inline">Engine.h</strong> file and add a new prototype for a <strong class="source-inline">populateEmitters</strong> function and a new STL <strong class="source-inline">vector</strong> of <strong class="source-inline">Vector2f</strong> objects:</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    // Run will call all the private functions</p>
			<p class="source-code">    bool detectCollisions(PlayableCharacter&amp; character);</p>
			<p class="source-code"><strong class="bold">    // Make a vector of the best places to emit sounds from</strong></p>
			<p class="source-code"><strong class="bold">    void populateEmitters(vector &lt;Vector2f&gt;&amp; vSoundEmitters,</strong></p>
			<p class="source-code"><strong class="bold">        int** arrayLevel);</strong></p>
			<p class="source-code"><strong class="bold">    // A vector of Vector2f for the fire emitter locations</strong></p>
			<p class="source-code"><strong class="bold">    vector &lt;Vector2f&gt; m_FireEmitters;</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p>The <strong class="source-inline">populateEmitters</strong> function takes a <strong class="source-inline">vector</strong> of <strong class="source-inline">Vector2f</strong> objects as a parameter, as well as a pointer to pointer to <strong class="source-inline">int</strong> (a two-dimensional array). The <strong class="source-inline">vector</strong> will hold the location of each emitter in a level. The array is the two-dimensional array that holds the layout of a level.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor349"/>Coding the populateEmitters function</h2>
			<p>The job of the <strong class="source-inline">populateEmitters</strong> function is to scan through all the elements of <strong class="source-inline">arrayLevel</strong> and decide where to put the emitters. It will store its results in <strong class="source-inline">m_FireEmitters</strong>.</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">PopulateEmitters.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. Now, we can code the new function, <strong class="source-inline">populateEmitters</strong>.</p>
			<p>Add the code in its entirety. Be sure to study the code as you do, so that we can discuss it:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">void Engine::populateEmitters(</p>
			<p class="source-code">    vector &lt;Vector2f&gt;&amp; vSoundEmitters, </p>
			<p class="source-code">   int** arrayLevel)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Make sure the vector is empty</p>
			<p class="source-code">    vSoundEmitters.empty();</p>
			<p class="source-code">    // Keep track of the previous emitter</p>
			<p class="source-code">    // so we don't make too many</p>
			<p class="source-code">    FloatRect previousEmitter;</p>
			<p class="source-code">    // Search for fire in the level</p>
			<p class="source-code">    for (int x = 0; x &lt; (int)m_LM.getLevelSize().x; x++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int y = 0; y &lt; (int)m_LM.getLevelSize().y; y++)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            if (arrayLevel[y][x] == 2)// fire is present</p>
			<p class="source-code">            {</p>
			<p class="source-code">                // Skip over any fire tiles too </p>
			<p class="source-code">                // near a previous emitter</p>
			<p class="source-code">                if (!FloatRect(x * TILE_SIZE,</p>
			<p class="source-code">                    y * TILE_SIZE,</p>
			<p class="source-code">                    TILE_SIZE,</p>
			<p class="source-code">                    TILE_SIZE).intersects(previousEmitter))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    // Add the coordinates of this water block</p>
			<p class="source-code">                    vSoundEmitters.push_back(</p>
			<p class="source-code">                        Vector2f(x * TILE_SIZE, y * TILE_SIZE));</p>
			<p class="source-code">                    // Make a rectangle 6 blocks x 6 blocks,</p>
			<p class="source-code">                    // so we don't make any more emitters </p>
			<p class="source-code">                    // too close to this one</p>
			<p class="source-code">                    previousEmitter.left = x * TILE_SIZE;</p>
			<p class="source-code">                    previousEmitter.top = y * TILE_SIZE;</p>
			<p class="source-code">                    previousEmitter.width = TILE_SIZE * 6;</p>
			<p class="source-code">                    previousEmitter.height = TILE_SIZE * 6;</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return;</p>
			<p class="source-code">}</p>
			<p>Some of the code might appear complex at first glance. Understanding the technique we are using to choose where an emitter will be makes this simpler. In our levels, there are large blocks of fire tiles. For example, in one of the levels, there are more than 30 fire tiles together in a group. The code makes sure that there is only one emitter within a given rectangle. This rectangle is stored in <strong class="source-inline">previousEmitter</strong> and is 300 pixels by 300 pixels (<strong class="source-inline">TILE_SIZE * 6</strong>).</p>
			<p>The code sets up a nested <strong class="source-inline">for</strong> loop that loops through <strong class="source-inline">arrayLevel</strong>, looking for fire tiles. When it finds one, it makes sure that it does not intersect with <strong class="source-inline">previousEmitter</strong>. Only then does it use the <strong class="source-inline">pushBack</strong> function to add another emitter to <strong class="source-inline">vSoundEmitters</strong>. After doing so, it also updates <strong class="source-inline">previousEmitter</strong> to avoid getting large clusters of sound emitters.</p>
			<p>Let's make some noise.</p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor350"/>Playing sounds</h1>
			<p>Open the <strong class="source-inline">LoadLevel.cpp</strong> file and add the call to the new <strong class="source-inline">populateEmitters</strong> function, as highlighted in the following code:</p>
			<p class="source-code">void Engine::loadLevel()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Playing = false;</p>
			<p class="source-code">    // Delete the previously allocated memory</p>
			<p class="source-code">    for (int i = 0; i &lt; m_LM.getLevelSize().y; ++i)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        delete[] m_ArrayLevel[i];</p>
			<p class="source-code">    }</p>
			<p class="source-code">    delete[] m_ArrayLevel;</p>
			<p class="source-code">    // Load the next 2d array with the map for the level</p>
			<p class="source-code">    // And repopulate the vertex array as well</p>
			<p class="source-code">    m_ArrayLevel = m_LM.nextLevel(m_VALevel);</p>
			<p class="source-code"><strong class="bold">    // Prepare the sound emitters</strong></p>
			<p class="source-code"><strong class="bold">    populateEmitters(m_FireEmitters, m_ArrayLevel);</strong></p>
			<p class="source-code">    // How long is this new time limit</p>
			<p class="source-code">    m_TimeRemaining = m_LM.getTimeLimit();</p>
			<p class="source-code">    // Spawn Thomas and Bob</p>
			<p class="source-code">    m_Thomas.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">    m_Bob.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">    // Make sure this code isn't run again</p>
			<p class="source-code">    m_NewLevelRequired = false;</p>
			<p class="source-code">}</p>
			<p>The first sound to add is the jump sound. We remember that the keyboard handling code is in the pure virtual functions within both the <strong class="source-inline">Bob</strong> and <strong class="source-inline">Thomas</strong> classes and that the <strong class="source-inline">handleInput</strong> function returns <strong class="source-inline">true</strong> when a jump has been successfully initiated.</p>
			<p>Open the <strong class="source-inline">Input.cpp</strong> file and add the following highlighted lines of code to play a jump sound when Thomas or Bob successfully begins a jump:</p>
			<p class="source-code">// Handle input specific to Thomas</p>
			<p class="source-code">if (m_Thomas.handleInput())</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Play a jump sound</p>
			<p class="source-code"><strong class="bold">    m_SM.playJump();</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">// Handle input specific to Bob</p>
			<p class="source-code">if (m_Bob.handleInput())</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Play a jump sound</p>
			<p class="source-code"><strong class="bold">    m_SM.playJump();</strong></p>
			<p class="source-code">}</p>
			<p>Open the <strong class="source-inline">Update.cpp</strong> file and add the following highlighted line of code to play a success sound when Thomas and Bob have simultaneously reached the goal for the current level:</p>
			<p class="source-code">// Detect collisions and see if characters have reached the goal tile</p>
			<p class="source-code">// The second part of the if condition is only executed</p>
			<p class="source-code">// when Thomas is touching the home tile</p>
			<p class="source-code">if (detectCollisions(m_Thomas) &amp;&amp; detectCollisions(m_Bob))</p>
			<p class="source-code">{</p>
			<p class="source-code">    // New level required</p>
			<p class="source-code">    m_NewLevelRequired = true;</p>
			<p class="source-code">    // Play the reach goal sound</p>
			<p class="source-code"><strong class="bold">    m_SM.playReachGoal();</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Run Bobs collision detection</p>
			<p class="source-code">    detectCollisions(m_Bob);</p>
			<p class="source-code">}</p>
			<p>Also, within the <strong class="source-inline">Update.cpp</strong> file, we will add code to loop through the <strong class="source-inline">m_FireEmitters</strong> vector and decide when we need to call the <strong class="source-inline">playFire</strong> function of the <strong class="source-inline">SoundManager</strong> class.</p>
			<p>Look closely at the small amount of context around the new highlighted code. It is essential to add this code in exactly the right place:</p>
			<p class="source-code">}// End if playing</p>
			<p class="source-code"><strong class="bold">// Check if a fire sound needs to be played</strong></p>
			<p class="source-code"><strong class="bold">vector&lt;Vector2f&gt;::iterator it;</strong></p>
			<p class="source-code"><strong class="bold">// Iterate through the vector of Vector2f objects</strong></p>
			<p class="source-code"><strong class="bold">for (it = m_FireEmitters.begin(); it != m_FireEmitters.end(); it++)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // Where is this emitter?</strong></p>
			<p class="source-code"><strong class="bold">    // Store the location in pos</strong></p>
			<p class="source-code"><strong class="bold">    float posX = (*it).x;</strong></p>
			<p class="source-code"><strong class="bold">    float posY = (*it).y;</strong></p>
			<p class="source-code"><strong class="bold">    // is the emitter near the player?</strong></p>
			<p class="source-code"><strong class="bold">    // Make a 500 pixel rectangle around the emitter</strong></p>
			<p class="source-code"><strong class="bold">    FloatRect localRect(posX - 250, posY - 250, 500, 500);</strong></p>
			<p class="source-code"><strong class="bold">    // Is the player inside localRect?</strong></p>
			<p class="source-code"><strong class="bold">    if (m_Thomas.getPosition().intersects(localRect))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Play the sound and pass in the location as well</strong></p>
			<p class="source-code"><strong class="bold">        m_SM.playFire(Vector2f(posX, posY), m_Thomas.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">// Set the appropriate view around the appropriate character</p>
			<p>The preceding code is a bit like collision detection for sound. Whenever Thomas strays within a 500 by 500-pixel rectangle surrounding a fire emitter, the <strong class="source-inline">playFire</strong> function is called, passing in the coordinates of the emitter and of Thomas. The <strong class="source-inline">playFire</strong> function does the rest of the work and plays a spatialized, looping sound effect.</p>
			<p>Open the <strong class="source-inline">DetectCollisions.cpp</strong> file, find the appropriate place, and add the following highlighted code. The two highlighted lines of code trigger the sound effect when either character falls into a water or fire tile:</p>
			<p class="source-code">// Has character been burnt or drowned?</p>
			<p class="source-code">// Use head as this allows him to sink a bit</p>
			<p class="source-code">if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (character.getHead().intersects(block))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        character.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">        // Which sound should be played?</p>
			<p class="source-code">        if (m_ArrayLevel[y][x] == 2)// Fire, ouch!</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Play a sound</p>
			<p class="source-code"><strong class="bold">            m_SM.playFallInFire();</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">        else // Water</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Play a sound</p>
			<p class="source-code"><strong class="bold">            m_SM.playFallInWater();</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Playing the game will now allow you to hear all the sounds, including cool spatialization, when you're near a fire tile.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor351"/>Implementing the HUD class</h1>
			<p>The HUD is super-simple and not really anything different compared to the Zombie Arena project. What we will do that is different is wrap all the code up in a new <strong class="source-inline">HUD</strong> class. If we declare all the <strong class="source-inline">Font</strong>, <strong class="source-inline">Text</strong>, and other variables as members of this new class, we can then initialize them in the constructor and provide getter functions to all their values. This will keep the <strong class="source-inline">Engine</strong> class clear from loads of declarations and initializations.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor352"/>Coding HUD.h</h2>
			<p>First, we will code the <strong class="source-inline">HUD.h</strong> file with all the member variables and function declarations. Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">HUD.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">HUD</strong> class.</p>
			<p>Add the following code to <strong class="source-inline">HUD.h</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Hud</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Font m_Font;</p>
			<p class="source-code">    Text m_StartText;</p>
			<p class="source-code">    Text m_TimeText;</p>
			<p class="source-code">    Text m_LevelText;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    Hud();</p>
			<p class="source-code">    Text getMessage();</p>
			<p class="source-code">    Text getLevel();</p>
			<p class="source-code">    Text getTime();</p>
			<p class="source-code">    void setLevel(String text);</p>
			<p class="source-code">    void setTime(String text);</p>
			<p class="source-code">};</p>
			<p>In the preceding code, we added one <strong class="source-inline">Font</strong> instance and three <strong class="source-inline">Text</strong> instances. The <strong class="source-inline">Text</strong> objects will be used to show a message prompting the user to start, the time remaining, and the current level number. </p>
			<p>The public functions are more interesting. First, there is the constructor where most of the code will go. The constructor will initialize the <strong class="source-inline">Font</strong> and <strong class="source-inline">Text</strong> objects, as well as position them on the screen relative to the current screen resolution. </p>
			<p>The three getter functions, <strong class="source-inline">getMessage</strong>, <strong class="source-inline">getLevel</strong>, and <strong class="source-inline">getTime</strong>, will return a <strong class="source-inline">Text</strong> object to the calling code so that it can draw them to the screen.</p>
			<p>The <strong class="source-inline">setLevel</strong> and <strong class="source-inline">setTime</strong> functions will be used to update the text shown in <strong class="source-inline">m_LevelText</strong> and <strong class="source-inline">m_TimeText</strong>, respectively.</p>
			<p>Now, we can code all the definitions for the functions we have just declared.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor353"/>Coding the HUD.cpp file</h2>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">HUD.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">HUD</strong> class.</p>
			<p>Add the include directives and the following code. Then, we will discuss it:</p>
			<p class="source-code">#include "Hud.h"</p>
			<p class="source-code">Hud::Hud()</p>
			<p class="source-code">{</p>
			<p class="source-code">    Vector2u resolution;</p>
			<p class="source-code">    resolution.x = VideoMode::getDesktopMode().width;</p>
			<p class="source-code">    resolution.y = VideoMode::getDesktopMode().height;</p>
			<p class="source-code">    // Load the font</p>
			<p class="source-code">    m_Font.loadFromFile("fonts/Roboto-Light.ttf");</p>
			<p class="source-code">    // when Paused</p>
			<p class="source-code">    m_StartText.setFont(m_Font);</p>
			<p class="source-code">    m_StartText.setCharacterSize(100);</p>
			<p class="source-code">    m_StartText.setFillColor(Color::White);</p>
			<p class="source-code">    m_StartText.setString("Press Enter when ready!");</p>
			<p class="source-code">    // Position the text</p>
			<p class="source-code">    FloatRect textRect = m_StartText.getLocalBounds();</p>
			<p class="source-code">    m_StartText.setOrigin(textRect.left +</p>
			<p class="source-code">        textRect.width / 2.0f,</p>
			<p class="source-code">        textRect.top +</p>
			<p class="source-code">        textRect.height / 2.0f);</p>
			<p class="source-code">    m_StartText.setPosition(</p>
			<p class="source-code">        resolution.x / 2.0f, resolution.y / 2.0f);</p>
			<p class="source-code">    // Time</p>
			<p class="source-code">    m_TimeText.setFont(m_Font);</p>
			<p class="source-code">    m_TimeText.setCharacterSize(75);</p>
			<p class="source-code">    m_TimeText.setFillColor(Color::White);</p>
			<p class="source-code">    m_TimeText.setPosition(resolution.x - 150, 0);</p>
			<p class="source-code">    m_TimeText.setString("------");</p>
			<p class="source-code">    // Level</p>
			<p class="source-code">    m_LevelText.setFont(m_Font);</p>
			<p class="source-code">    m_LevelText.setCharacterSize(75);</p>
			<p class="source-code">    m_LevelText.setFillColor(Color::White);</p>
			<p class="source-code">    m_LevelText.setPosition(25, 0);</p>
			<p class="source-code">    m_LevelText.setString("1");</p>
			<p class="source-code">}</p>
			<p>First, we store the horizontal and vertical resolution in a <strong class="source-inline">Vector2u</strong> called <strong class="source-inline">resolution</strong>. Next, we load the font from the <strong class="source-inline">fonts</strong> directory that we added back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>. </p>
			<p>The next four lines of code set the font, the color, the size, and the text of <strong class="source-inline">m_StartText</strong>. The block of code after this captures the size of the rectangle that wraps <strong class="source-inline">m_StartText</strong> and performs a calculation to work out how to position it centrally on the screen. If you want a more thorough explanation of this part of the code, then refer to <a href="B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 3</em></a>, <em class="italic">C++ Strings and SFML Time – Player Input and HUD</em>.</p>
			<p>In the final two blocks of code in the constructor, the font, text size, color, position, and actual text for <strong class="source-inline">m_TimeText</strong> and <strong class="source-inline">m_LevelText</strong> are set. In a moment, we will see that these two <strong class="source-inline">Text</strong> objects will be updatable through two setter functions, whenever it is required.</p>
			<p>Add the following getter and setter functions immediately underneath the code we have just added:</p>
			<p class="source-code">Text Hud::getMessage()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_StartText;</p>
			<p class="source-code">}</p>
			<p class="source-code">Text Hud::getLevel()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_LevelText;</p>
			<p class="source-code">}</p>
			<p class="source-code">Text Hud::getTime()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_TimeText;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Hud::setLevel(String text)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LevelText.setString(text);</p>
			<p class="source-code">}</p>
			<p class="source-code">void Hud::setTime(String text)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_TimeText.setString(text);</p>
			<p class="source-code">}</p>
			<p>The first three functions in the previous code simply return the appropriate <strong class="source-inline">Text</strong> object, that is, <strong class="source-inline">m_StartText</strong>, <strong class="source-inline">m_LevelText</strong>, or <strong class="source-inline">m_TimeText</strong>. We will use these functions shortly when we draw the HUD to the screen. The final two functions, <strong class="source-inline">setLevel</strong> and <strong class="source-inline">setTime</strong>, use the <strong class="source-inline">setString</strong> functions to update the appropriate <strong class="source-inline">Text</strong> object with the value that will be passed in from the <strong class="source-inline">update</strong> function of the <strong class="source-inline">Engine</strong> class, every 500 frames.</p>
			<p>With all that done, we can put the HUD class to work in our game engine.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor354"/>Using the HUD class</h1>
			<p>Open <strong class="source-inline">Engine.h</strong>, add an include for our new class, declare an instance of the new <strong class="source-inline">HUD</strong> class, and declare and initialize two new member variables that will keep track of how often we update the HUD. As we learned in the previous projects, we don't need to update the HUD every frame.</p>
			<p> Add the following highlighted code to <strong class="source-inline">Engine.h</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include "Thomas.h"</p>
			<p class="source-code">#include "Bob.h"</p>
			<p class="source-code">#include "LevelManager.h"</p>
			<p class="source-code">#include "SoundManager.h"</p>
			<p class="source-code"><strong class="bold">#include "HUD.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Engine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // The texture holder</p>
			<p class="source-code">    TextureHolder th;</p>
			<p class="source-code">    // Thomas and his friend, Bob</p>
			<p class="source-code">    Thomas m_Thomas;</p>
			<p class="source-code">    Bob m_Bob;</p>
			<p class="source-code">    // A class to manage all the levels</p>
			<p class="source-code">    LevelManager m_LM;</p>
			<p class="source-code">    // Create a SoundManager</p>
			<p class="source-code">    SoundManager m_SM;</p>
			<p class="source-code"><strong class="bold">    // The Hud</strong></p>
			<p class="source-code"><strong class="bold">    Hud m_Hud;</strong></p>
			<p class="source-code"><strong class="bold">    int m_FramesSinceLastHUDUpdate = 0;</strong></p>
			<p class="source-code"><strong class="bold">    int m_TargetFramesPerHUDUpdate = 500;</strong></p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p>Next, we need to add some code to the <strong class="source-inline">update</strong> function of the <strong class="source-inline">Engine</strong> class. Open <strong class="source-inline">Update.cpp</strong> and add the following highlighted code to update the HUD once every 500 frames:</p>
			<p class="source-code">    // Set the appropriate view around the appropriate character</p>
			<p class="source-code">    if (m_SplitScreen)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_LeftView.setCenter(m_Thomas.getCenter());</p>
			<p class="source-code">        m_RightView.setCenter(m_Bob.getCenter());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Centre full screen around appropriate character</p>
			<p class="source-code">        if (m_Character1)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_MainView.setCenter(m_Thomas.getCenter());</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_MainView.setCenter(m_Bob.getCenter());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Time to update the HUD?</strong></p>
			<p class="source-code"><strong class="bold">    // Increment the number of frames since </strong></p>
			<p class="source-code"><strong class="bold">   // the last HUD calculation</strong></p>
			<p class="source-code"><strong class="bold">    m_FramesSinceLastHUDUpdate++;</strong></p>
			<p class="source-code"><strong class="bold">    // Update the HUD every m_TargetFramesPerHUDUpdate frames</strong></p>
			<p class="source-code"><strong class="bold">    if (m_FramesSinceLastHUDUpdate &gt; m_TargetFramesPerHUDUpdate)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Update game HUD text</strong></p>
			<p class="source-code"><strong class="bold">        stringstream ssTime;</strong></p>
			<p class="source-code"><strong class="bold">        stringstream ssLevel;</strong></p>
			<p class="source-code"><strong class="bold">        // Update the time text</strong></p>
			<p class="source-code"><strong class="bold">        ssTime &lt;&lt; (int)m_TimeRemaining;</strong></p>
			<p class="source-code"><strong class="bold">        m_Hud.setTime(ssTime.str());</strong></p>
			<p class="source-code"><strong class="bold">        // Update the level text</strong></p>
			<p class="source-code"><strong class="bold">        ssLevel &lt;&lt; "Level:" &lt;&lt; m_LM.getCurrentLevel();</strong></p>
			<p class="source-code"><strong class="bold">        m_Hud.setLevel(ssLevel.str());</strong></p>
			<p class="source-code"><strong class="bold">        m_FramesSinceLastHUDUpdate = 0;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End of update function</p>
			<p>In the preceding code, <strong class="source-inline">m_FramesSinceLastUpdate</strong> is incremented each frame. When <strong class="source-inline">m_FramesSinceLastUpdate</strong> exceeds <strong class="source-inline">m_TargetFramesPerHUDUpdate</strong>, then execution enters the <strong class="source-inline">if</strong> block. Inside the <strong class="source-inline">if</strong> block, we use <strong class="source-inline">stringstream</strong> objects to update our <strong class="source-inline">Text</strong>, like we did in the previous projects. In this project, we are using the <strong class="source-inline">HUD</strong> class, so we call the <strong class="source-inline">setTime</strong> and <strong class="source-inline">setLevel</strong> functions by passing in the current values that the <strong class="source-inline">Text</strong> objects need to be set to.</p>
			<p>The final step in the <strong class="source-inline">if</strong> block is to set <strong class="source-inline">m_FramesSinceLastUpdate</strong> back to zero so it can start counting toward the next update.</p>
			<p>Finally, open the <strong class="source-inline">Draw.cpp</strong> file and add the following highlighted code to draw the HUD each frame:</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Split-screen view is active</p>
			<p class="source-code">        // First draw Thomas' side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGLeftView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_LeftView</p>
			<p class="source-code">        m_Window.setView(m_LeftView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">            </p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        </p>
			<p class="source-code">        // Now draw Bob's side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGRightView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_RightView</p>
			<p class="source-code">        m_Window.setView(m_RightView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Draw the HUD</p>
			<p class="source-code">    // Switch to m_HudView</p>
			<p class="source-code">    m_Window.setView(m_HudView);</p>
			<p class="source-code"><strong class="bold">    m_Window.draw(m_Hud.getLevel());</strong></p>
			<p class="source-code"><strong class="bold">    m_Window.draw(m_Hud.getTime());</strong></p>
			<p class="source-code"><strong class="bold">    if (!m_Playing)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Hud.getMessage());</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    // Show everything we have just drawn</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}// End of draw</p>
			<p>The preceding code draws the HUD by using the getter functions from the HUD class. Notice that the call to draw the message that prompts the player to start is only used when the game is not currently playing <strong class="source-inline">(!m_Playing)</strong>.</p>
			<p>Run the game and play a few levels to see the time tick down and the levels tick up. When you get back to level 1 again, notice that you have 10% less time than before.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor355"/>Summary</h1>
			<p>In this chapter, we have explored sound spatialization. Our "Thomas Was Late" game is not only fully playable now, but we have added directional sound effects and a simple but informative HUD. We can also add new levels with ease. At this point, we could call it a day.</p>
			<p>It would be nice to add a bit more sparkle. In the next chapter, we will look into two gaming concepts. First, we will look at particle systems, which are how we can handle things such as explosions or other special effects. To achieve this, we will need to learn a bit more C++. Due to this, the topic of multiple inheritance will be introduced.</p>
			<p>After that, we will add the final flourish to the game when we learn about OpenGL and the programmable graphics pipeline. We will then be able to dip our toes into the <strong class="bold">GLSL</strong> language, which allows us to write code that executes directly on the GPU so that we can create some special effects.</p>
		</div>
	</body></html>