["```cpp\n$ ninja clang\n```", "```cpp\n$ clang -Xclang -ast-dump foo.c\n```", "```cpp\nint foo(int c) { return c + 1; }\n```", "```cpp\nTranslationUnitDecl 0x560f3929f5a8 <<invalid sloc>> <invalid sloc>\n|…\n`-FunctionDecl 0x560f392e1350 <foo.c:2:1, col:30> col:5 foo 'int (int)'\n  |-ParmVarDecl 0x560f392e1280 <col:9, col:13> col:13 used c 'int'\n  `-CompoundStmt 0x560f392e14c8 <col:16, col:30>\n    `-ReturnStmt 0x560f392e14b8 <col:17, col:28>\n      `-BinaryOperator 0x560f392e1498 <col:24, col:28> 'int' '+'\n        |-ImplicitCastExpr 0x560f392e1480 <col:24> 'int' <LValueToRValue>\n        | `-DeclRefExpr 0x560f392e1440 <col:24> 'int' lvalue ParmVar 0x560f392e1280 'c' 'int'\n        `-IntegerLiteral 0x560f392e1460 <col:28> 'int' 1\n```", "```cpp\n// If `T` is representing 'int'…\nQualType toConstVolatileTy(Type *T) {\n  return QualType(T, Qualifier::Const | Qualifier::Volatile);\n} // Then the returned QualType represents `volatile const int`\n```", "```cpp\n// `FD` has the type of `const FunctionDecl&`\nconst auto* Body = dyn_cast<CompoundStmt>(FD.getBody());\nfor(const auto* S : Body->body()) {\n  if(const auto* L = dyn_cast<WhileStmt>(S)) {\n    if(const auto* Cond = dyn_cast<CXXBoolLiteralExpr>      (L->getCond()))\n      if(Cond->getValue()) {\n        // The exit condition is `true`!!\n      }\n  }\n}\n```", "```cpp\nfunctionDecl(compountStmt(hasAnySubstatement(\n  whileStmt(\n    hasCondition(cxxBoolLiteral(equals(true)))))));\n```", "```cpp\nusing namespace ast_matchers;\n…\nMatchFinder Finder;\n// Add AST matching patterns to `MatchFinder`\nFinder.addMatch(traverse(TK_AsIs, pattern1), Callback1);\nFinder.addMatch(traverse(TK_AsIs, pattern2), Callback2);\n…\n// Match a given AST. `Tree` has the type of `ASTContext&`\n// If there is a match in either of the above patterns,\n// functions in Callback1 or Callback2 will be invoked // accordingly\nFinder.matchAST(Tree);\n// …Or match a specific AST node. `FD` has the type of // `FunctionDecl&`\nFinder.match(FD, Tree);\n```", "```cpp\nstruct B {\n  B(int);\n};\nB foo() { return 87; }\n```", "```cpp\nFunctionDecl\n`-CompoundStmt\n  `-ReturnStmt\n    `-ExprWithCleanups\n      `-CXXConstructExpr\n        `-MaterializeTemporaryExpr\n          `-ImplicitCastExpr\n            `-ImplicitCastExpr\n              `-CXXConstructExpr\n                `-IntegerLiteral 'int' 87\n```", "```cpp\nFunctionDecl\n`-CompoundStmt\n  `-ReturnStmt\n    `-IntegerLiteral 'int' 87\n```", "```cpp\nstruct MyMatchCallback : public MatchFinder::MatchCallback {\n  void run(const MatchFinder::MatchResult &Result) override {\n    // Reach here if there is a match on the corresponding     // pattern\n    // Handling \"bound\" result from `Result`, if there is any\n  }\n};\n```", "```cpp\nforStmt(hasBody(…));\n```", "```cpp\nforStmt(hasBody(…),\n        hasCondition(…));\n```", "```cpp\nforStmt(\n  hasCondition(\n    expr().bind(\"exit_condition\")));\n```", "```cpp\n…\nvoid run(const MatchFinder::MatchResult &Result) override {\n  cons auto& Nodes = Result.Nodes;\n  const Expr* CondExpr = Nodes.getNodeAs<Expr>    (\"exit_condition\");\n  // Use `CondExpr`…\n}\n```", "```cpp\n    auto PatExitCondition = binaryOperator(\n                               hasOperatorName(\"<\"),\n                               hasRHS(integerLiteral()\n                               .bind(\"trip_count\")));\n    auto Pattern = functionDecl(\n                     compountStmt(hasAnySubstatement(\n                  forStmt(hasCondition(PatExitCondition)))));\n    MatchFinder Finder;\n    auto* Callback = new MyMatchCallback();\n    Finder.addMatcher(traverse(TK_IgnoreUnlessSpelledInSource,\n                               Pattern), Callback);\n    ```", "```cpp\n    void run(const MatchFinder::MatchResult &Result) override {\n      const auto& Nodes = Result.Nodes;\n      const auto* TripCount = \n            Nodes.getNodeAs<IntegerLiteral>(\"trip_count\");\n      if (TripCount)\n        TripCount->dump(); // print to llvm::errs()\n    }\n    ```", "```cpp\nint foo(int c) {\n  if (c > 10) {\n    return c + 100;\n  } else {\n    return 94;\n  }\n}\nvoid bar(int x) {\n  int a;\n  if (x > 10) {\n    a = 87;\n  } else {\n    a = x – 100;\n  }\n}\n```", "```cpp\nint foo(int c) {\n  return c > 10? c + 100 : 94;\n}\nvoid bar(int x) {\n  int a;\n  a = x > 10? 87 : x – 100;\n}\n```", "```cpp\n$ clang …(flags to run the plugin) ./test.c\n./test.c:2:3: warning: this if statement can be converted to ternary operator:\n  if (c > 10) {\n  ^\n./test.c:3:12: note: with true expression being this:\n    return c + 100;\n           ^\n./test.c:5:12: note: with false expression being this:\n    return 94;\n           ^\n./test.c:11:3: warning: this if statement can be converted to ternary operator:\n  if (x > 10) {\n  ^\n./test.c:12:9: note: with true expression being this:\n    a = 87;\n        ^\n./test.c:14:9: note: with false expression being this:\n    a = x - 100;\n        ^\n2 warnings generated.\n```", "```cpp\n\"use of undeclared identifier %0\"\n```", "```cpp\ndef err_undeclared_var_use : Error<\"use of undeclared identifier %0\">;\n```", "```cpp\n    // `Ctx` has the type of `ASTContext&`\n    DiagnosticsEngine& Diag = Ctx.getDiagnostics();\n    ```", "```cpp\n    Diag.Report(err_undeclared_var_use takes one placeholder argument – namely, the identifier name – which is supplied through concatenating the Report function call with << operators:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    \"you cannot put %1 into %0\"\n    ```", "```cpp\n    Diag.Report(diag::err_invalid_placement)\n                 << \"boiling oil\" << \"water\";\n    ```", "```cpp\n    \"you exceed the daily %select directive consists of curly braces in which different message options are separated by |. Outside the curly braces, a number – 0, in the preceding code – indicates which supplement data is used to select the option within the braces. The following is an example of this:\n\n    ```", "```cpp\n    Diag.Report(diag::warn_exceed_limit) << 0;\n    ```", "```cpp\n\n    ```", "```cpp\n    // `SLoc` has the type of `SourceLocation`\n    Diag.Report(SLoc:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    auto MyDiagID = Diag.MyDiagID, that has a message template of Today's weather is %0 at its note diagnostic level. You can use this diagnostic ID just like any other ID:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    struct TernaryConverterAction : public PluginASTAction {\n      std::unique_ptr<ASTConsumer>\n        CreateASTConsumer(CompilerInstance &CI,\n                          StringRef InFile) override;\n    };\n    ```", "```cpp\n    struct TernaryConverterAction : public PluginASTAction {\n      …\n      ActionType getActionType() override { return ParseArgs member function, on the other hand, handles (frontend) command-line options specific to this plugin. In other words, you can create custom command-line flags for your plugin. In our case, we are going to create two flags: -no-detect-return and -no-detect-assignment. This allows us to decide whether we wish to detect potential ternary conversions regarding return statements or assignment statements, respectively:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    using namespace ast_matchers;\n    struct TernaryConverterAction : public PluginASTAction {\n      …\n    private:\n      std::unique_ptr<MatchFinder> unique_ptr type member variables: one for holding MatchFinder and two MatchCallback ones for return-based and assignment-based patterns.Why Use unique_ptr?The rationale behind using `unique_ptr` to store those three objects – or storing those objects *persistently* – is because the `ASTConsumer` instance we created at the end of `CreateASTConsumer` (`ASTFinder->newASTConsumer()`) keeps references to those three objects. Thus, we need a way to keep them alive during the lifetime of the frontend.In addition to that, we registered the pattern for traversal with MatchFinder by using `MatchFinder::addMatcher`, the `traverse` function, and `MatchCallback` instances. If you're not familiar with these APIs, feel free to check out the *ASTMatcher* section.Now, we only need to compose the matching patterns and implement some callbacks to print out warning messages if there is a match – as the `TODO` comments suggested in the preceding snippet.\n    ```", "```cpp\n    FunctionDecl \n      |_CompoundStmt\n        |_(Other AST nodes we don't care)\n        |_IfStmt\n          |_(true branch: contain only one return/assign         statement)\n          |_(false branch: contain only one return/assign         statement)\n    ```", "```cpp\n    functionDecl(\n      compoundStmt(hasAnySubstatement\n        IfStmt(\n          hasThen(/*CompoundStmt, you should always use quantifier directives such as hasAnySubstatement to match its body statements.We are going to use the previous `TODO` comments to customize for either return-based or assignment-based situations. Let's use subpattern variables to replace those `TODO` comments and put the preceding code into another function:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    StatementMatcher buildReturnMatcher() {\n      return compoundStmt(statementCountIs directive to match the code blocks with only one statement. Also, we specified that we don't want an empty return via hasReturnValue(…). The argument for hasReturnValue is necessary since the latter takes at least one argument, but since we don't care what type of node it is, we are using expr() as some sort of wildcard pattern.For assignment-based patterns, things get a little bit complicated: we don't just want to match a single assignment statement (modeled by the `BinaryOperator` class) in both branches – the LHS of those assignments need to be `DeclRefExpr` expressions that point to the same `Decl` instance. Unfortunately, we are not able to express all these predicates using ASTMatch's DSL. What we can do, however, is push off some of those checks into `MatchCallback` later, and only use DSL directives to check the *shape* of our desired patterns:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    StatementMatcher buildAssignmentMatcher() {\n      return compoundStmt(statementCountIs(1),\n                          hasAnySubstatement(\n                            binaryOperator(\n                              hasOperatorName(\"=\"),\n                              hasLHS(DeclRefExpr is bound to the same name, meaning that the AST node that occurred later will overwrite the previously bound node. So, eventually, we won't get DeclRefExpr nodes from both branches as we previously planned.Therefore, let's use a different tags for `DeclRefExpr` that match from both branches: `dest.true` for the true branch and `dest.false` for the false branch. Let's tweak the preceding code to reflect this strategy:\n\n    ```", "```cpp\n    void\n    MatchAssignmentCallback::run(const MatchResult &Result) override {\n      const auto& Nodes = Result.Nodes;\n      // Check if destination of both assignments are the   // same\n      const auto *DestTrue =\n                 Nodes.getNodeAs<DeclRefExpr>(\"dest.true\"),\n                 *DestFalse = \n                 Nodes.getNodeAs<DeclRefExpr>(\"dest.false\");\n      if (DestTrue->getDecl() == DestFalse->getDecl()) {\n        // Can be converted into ternary operator!\n      }\n    }\n    ```", "```cpp\n\n    ```", "```cpp\n    StatementMatcher\n    buildIfStmtMatcher(StatementMatcher truePattern,\n                       StatementMatcher falsePattern) {\n      return functionDecl(\n        compoundStmt(hasAnySubstatement\n          IfStmt(\n            hasThen(truePattern)\n            hasElse(falsePattern)).IfStmt since we want to tell our users where the potential places that can be converted into ternary operators are:\n\n    ```", "```cpp\n    void\n    MatchAssignmentCallback::run(const MatchResult &Result) override {\n      …\n      auto& Diag = Result.Context->getDiagnostics();\n      auto DiagWarnMain = Diag.getCustomDiagID(\n        DiagnosticsEngine::Warning,\n        \"this if statement can be converted to ternary      operator:\");\n      auto DiagNoteTrueExpr = Diag.getCustomDiagID(\n        DiagnosticsEngine::Note,\n        \"with true expression being this:\");\n      auto DiagNoteFalseExpr = Diag.getCustomDiagID(\n        DiagnosticsEngine::Note,\n        \"with false expression being this:\");\n      …\n    }\n    ```", "```cpp\n    void\n    MatchAssignmentCallback::run(const MatchResult &Result) override {\n      …\n      if (DestTrue && DestFalse) {\n          if (DestTrue->getDecl() == DestFalse->getDecl()) {\n            // Can be converted to ternary!\n            const auto* If = Nodes.getNodeAs<IfStmt>        (\"if_stmt\");\n            Diag.Report(If->getBeginLoc(), DiagWarnMain);\n            const auto* TrueValExpr = \n                        Nodes.getNodeAs<Expr>(\"val.true\");\n            const auto* FalseValExpr = \n                        Nodes.getNodeAs<Expr>(\"val.false\");\n            Diag.Report(TrueValExpr->getBeginLoc(), \n                        DiagNoteTrueExpr);\n            Diag.Report(FalseValExpr->getBeginLoc(), \n                        DiagNoteFalseExpr);\n          }\n        }\n    }\n    ```", "```cpp\n\n    ```", "```cpp\n    std::unique_ptr<ASTConsumer>\n    TernaryConverterAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {\n      …\n      // Return matcher\n      if (!NoReturn) {\n      ReturnMatchCB = std::make_unique<MatchReturnCallback>();\n        ASTFinder->addMatcher(\n          traverse(TK_IgnoreUnlessSpelledInSource,                          \n                   buildIfStmtMatcher(\n                     buildReturnMatcher(\".true\"),                                                 \n                     buildReturnMatcher(\".false\"))),\n          ReturnMatchCB.get()\n        );\n      }\n      // Assignment matcher\n      if (!NoAssignment) {\n        AssignMatchCB = std::make_     unique<MatchAssignmentCallback>();\n        ASTFinder->addMatcher(\n          traverse(TK_IgnoreUnlessSpelledInSource,\n                   buildIfStmtMatcher(\n                     buildAssignmentMatcher(\".true\"),\n                     buildAssignmentMatcher(\".false\"))),\n          AssignMatchCB.get()\n        );\n      }\n      return std::move(ASTFinder->newASTConsumer());\n    }\n    ```", "```cpp\n    -no-detect-return and -no-detect-assignment in this project, please add the command-line options highlighted here:\n\n    ```", "```cpp\n\n    ```"]