- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains answers to the questions from all chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6, Extending the Preprocessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time tokens are harvested from the provided source code, but in
    some cases, tokens might be generated dynamically inside the `Preprocessor`. For
    example, the `__LINE__` built-in macro is expanded to the current line number,
    and the `__DATE__` macro is expanded to the current calendar date. How does Clang
    put that generated textual content into the `SourceManager`'s source code buffer?
    How does Clang assign `SourceLocation` to these tokens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developers can leverage the `clang::ScratchBuffer` class to insert dynamic `Token`
    instances.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When we were talking about implementing a custom `PragmaHandler`, we were using
    `Preprocessor::Lex` to fetch tokens followed after the pragma name, until we hit
    the `eod` token type. Can we keep lexing *beyond* the `eod` token? What interesting
    thing will you do if you can consume arbitrary tokens follow after the `#pragma`
    directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes, we can keep lexing beyond the `eod` token. It simply consumes the contents
    following the `#pragma` line. In this way, you can create a custom `#pragma` that
    allows you to write *arbitrary* content (below it) – for instance, writing programming
    languages that are not supported by Clang. Here is an example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `macro guard` project from the *Developing custom preprocessor plugins
    and callbacks* section, the warning message has the format of `[WARNING] In <source
    location>: ….`. Apparently, this is not the typical compiler warning we see from
    `Clang`, which looks like `<source location>: warning: …`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `warning` string is even colored in supported terminals. How can we print
    a warning message like that? Is there an infrastructure in Clang for doing that?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Developers can use the diagnostics framework in Clang to print messages like
    this. In the *Printing diagnostics messages* section of [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)*,
    Handling AST*, we will show you some of the usages of this framework.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 8, Working with Compiler Flags and Toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common to override the assembling and linking stage, since different platforms
    tend to support different assemblers and linkers. But is it possible to override
    the *compiling* stage (which is Clang)? If it is possible, how do we do it? What
    might be the possible reasons for people to do that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can override the `ToolChain::SelectTool` method and provide an alternative
    `Tool` instance (which represents the compilation stage) according to the argument.
    Here is an example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: When we were working on `tools::zipline::Linker::ConstructJob`, we simply use
    `llvm_unreachable` to bail out the compilation process if the user provides an
    unsupported compressor name through the `-fuse-ld` flag. Can we replace it with
    Clang's `Driver` class provides a shortcut to access the diagnostic framework.
    Inside a derived class of `Tool`, you can use `getToolChain().getDriver()` to
    get a `Driver` instance, then print out the diagnostic message using the `Driver::Diag`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like we can use `-Xclang` to pass flags directly to the frontend, we can
    also pass assembler-specific or linker-specific flags directly to the assembler
    or linker using driver flags such as `-Wa` (for assembler) and `-Wl` (for linker).
    How do we consume those flags in our custom assembler and linker stages within
    Zipline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `ConstructJob` method, you can read the value of `options::OPT_Wa_COMMA`
    and `options::OPT_Wl_COMMA` to retrieve assembler- and linker-specific command
    line flags, respectively. Here is an example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Chapter 9, Working with PassManager and AnalysisManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the StrictOpt example in the *Writing a LLVM Pass for the new PassManager*
    section, how do we write a Pass without deriving the `PassInfoMixin` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PassInfoMixin` class only defines a utility function for you, `name`,
    which returns the name of this Pass. Therefore, you can easily create one by yourself.
    Here is an example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'How do we develop custom instrumentation for the new PassManager? How do we
    do it without modifying the LLVM source tree? (Hint: Use the Pass plugin we learned
    in this chapter.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass instrumentation is a piece of code that runs before and/or after an LLVM
    Pass. This blog post shows an example of developing a custom Pass instrumentation
    via the Pass plugin: [https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f](mailto:https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
