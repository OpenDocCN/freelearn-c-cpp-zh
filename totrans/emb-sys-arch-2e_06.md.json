["```cpp\n#define NVIC_ISER_BASE (0xE000E100)\nstatic inline void nvic_irq_enable(uint8_t n)\n{\n  int i = n / 32;\n  volatile uint32_t *nvic_iser =\n    ((volatile uint32_t *)(NVIC_ISER_BASE + 4 * i));\n  *nvic_iser |= (1 << (n % 32));\n}\n```", "```cpp\n#define NVIC_ICER_BASE (0xE000E180)\nstatic inline void nvic_irq_disable(uint8_t n)\n{\n  int i = n / 32;\n  volatile uint32_t *nvic_icer =\n    ((volatile uint32_t *)(NVIC_ICER_BASE + 4 * i));\n  *nvic_icer |= (1 << (n % 32));\n}\n```", "```cpp\n#define NVIC_IPRI_BASE (0xE000E400)\nstatic inline void nvic_irq_setprio(uint8_t n,\n    uint8_t prio)\n{\n  volatile uint8_t *nvic_ipri = ((volatile uint8_t *)\n   (NVIC_IPRI_BASE + n));\n  *nvic_ipri = prio;\n}\n```", "```cpp\n#define FLASH_BASE (0x40023C00)\n#define FLASH_ACR (*(volatile uint32_t *)(FLASH_BASE +\n   0x00))\n```", "```cpp\nvoid flash_set_waitstates(void) {\n  FLASH_ACR = 5 | (1 << 10) | (1 << 9);\n}\n```", "```cpp\n#define RCC_BASE (0x40023800)\n#define RCC_CR (*(volatile uint32_t *)(RCC_BASE + 0x00))\n#define RCC_PLLCFGR (*(volatile uint32_t *)(RCC_BASE +\n    0x04))\n#define RCC_CFGR (*(volatile uint32_t *)(RCC_BASE + 0x08))\n#define RCC_CR (*(volatile uint32_t *)(RCC_BASE + 0x00))\n```", "```cpp\n#define RCC_CR_PLLRDY (1 << 25)\n#define RCC_CR_PLLON (1 << 24)\n#define RCC_CR_HSERDY (1 << 17)\n#define RCC_CR_HSEON (1 << 16)\n#define RCC_CR_HSIRDY (1 << 1)\n#define RCC_CR_HSION (1 << 0)\n#define RCC_CFGR_SW_HSI 0x0\n#define RCC_CFGR_SW_HSE 0x1\n#define RCC_CFGR_SW_PLL 0x2\n#define RCC_PLLCFGR_PLLSRC (1 << 22)\n#define RCC_PRESCALER_DIV_NONE 0\n#define RCC_PRESCALER_DIV_2 8\n#define RCC_PRESCALER_DIV_4 9\n```", "```cpp\n#define CPU_FREQ (168000000)\n#define PLL_FULL_MASK (0x7F037FFF)\n#define PLLM 8\n#define PLLN 336\n#define PLLP 2\n#define PLLQ 7\n#define PLLR 0\n```", "```cpp\n#define DMB() asm volatile (\"dmb\");\n```", "```cpp\nvoid rcc_config(void)\n{\n  uint32_t reg32;\n  RCC_CR |= RCC_CR_HSION;\n  DMB();\n  while ((RCC_CR & RCC_CR_HSIRDY) == 0)\n    ;\n```", "```cpp\n  reg32 = RCC_CFGR;\n  reg32 &= ~((1 << 1) | (1 << 0));\n  RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);\n  DMB();\n```", "```cpp\n  RCC_CR |= RCC_CR_HSEON;\n  DMB();\n  while ((RCC_CR & RCC_CR_HSERDY) == 0)\n    ;\n```", "```cpp\n  reg32 = RCC_CFGR;\n  reg32 &= ~0xF0;\n  RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_NONE << 4));\n  DMB();\n  reg32 = RCC_CFGR;\n  reg32 &= ~0x1C00;\n  RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_2 << 10));\n  DMB();\n  reg32 = RCC_CFGR;\n  reg32 &= ~0x07 << 13;\n  RCC_CFGR = (reg32 | (RCC_PRESCALER_DIV_4 << 13));\n  DMB();\n```", "```cpp\n  reg32 = RCC_PLLCFGR;\n  reg32 &= ~PLL_FULL_MASK;\n  RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | PLLM |\n    (PLLN << 6) | (((PLLP >> 1) - 1) << 16) |\n    (PLLQ << 24);\n  DMB();\n```", "```cpp\n  RCC_CR |= RCC_CR_PLLON;\n  DMB();\n  while ((RCC_CR & RCC_CR_PLLRDY) == 0);\n```", "```cpp\n  reg32 = RCC_CFGR;\n  reg32 &= ~((1 << 1) | (1 << 0));\n  RCC_CFGR = (reg32 | RCC_CFGR_SW_PLL);\n  DMB();\n  while ((RCC_CFGR & ((1 << 1) | (1 << 0))) !=\n    RCC_CFGR_SW_PLL);\n```", "```cpp\n#define RCC (*(volatile uint32_t*))(0x400FE060)\n#define RCC2 (*(volatile uint32_t*))(0x400FE070)\n```", "```cpp\n#define RCC_RESET (0x078E3AD1)\n#define RCC2_RESET (0x07802810)\n```", "```cpp\n#define RIS (*(volatile uint32_t*))(0x400FE050)\n#define PLL_LRIS (1 << 6)\n```", "```cpp\nvoid rcc_config(void)\n{\n  RCC = RCC_RESET;\n  RCC2 = RCC2_RESET;\n  DMB();\n  RCC = RCC_SYSDIV_50MHZ | RCC_PWMDIV_64 |\n    RCC_XTAL_8MHZ_400MHZ | RCC_USEPWMDIV;\n```", "```cpp\n  RCC2 = RCC2_SYSDIV2_4;\n  DMB();\n```", "```cpp\n  RCC &= ~RCC_OFF;\n  RCC2 &= ~RCC2_OFF;\n```", "```cpp\n  RCC |= RCC_BYPASS | RCC_USESYSDIV;\n  DMB();\n```", "```cpp\n while ((RIS & PLL_LRIS) == 0)   ;\n```", "```cpp\n  RCC &= ~RCC_BYPASS;\n  RCC2 &= ~RCC2_BYPASS;\n}\n```", "```cpp\n#define APB1_CLOCK_ER (*(uint32_t *)(0x4002001c))\n#define WDG_APB1_CLOCK_ER_VAL (1 << 9)\nAPB1_CLOCK_ER |= WDG_APB1_CLOCK_ER_VAL;\n```", "```cpp\n#define SYSTICK_BASE (0xE000E010)\n#define SYSTICK_CSR (*(volatile uint32_t *)(SYSTICK_BASE +\n    0x00))\n#define SYSTICK_RVR (*(volatile uint32_t *)(SYSTICK_BASE +\n    0x04))\n#define SYSTICK_CVR (*(volatile uint32_t *)(SYSTICK_BASE +\n    0x08))\n#define SYSTICK_CALIB (*(volatile uint32_t *)(SYSTICK_BASE\n    + 0x0C))\n```", "```cpp\nvoid systick_enable(void) {\n  SYSTICK_RVR = ((CPU_FREQ / 1000) - 1);\n  SYSTICK_CVR = 0;\n  SYSTICK_CSR = (1 << 0) | (1 << 1) | (1 << 2);\n}\n```", "```cpp\nvolatile unsigned int jiffies = 0;\nvoid isr_systick(void)\n{\n  ++jiffies;\n}\n```", "```cpp\nvoid main(void) {\n  flash_set_waitstates();\n  clock_config();\n  systick_enable();\n  while(1) {\n    WFI();\n  }\n}\n```", "```cpp\n#define WFI() asm volatile (\"wfi\")\n```", "```cpp\n#define TIM2_BASE (0x40000000)\n#define TIM2_CR1 (*(volatile uint32_t *)(TIM2_BASE + 0x00))\n#define TIM2_DIER (*(volatile uint32_t *)(TIM2_BASE +\n    0x0c))\n#define TIM2_SR (*(volatile uint32_t *)(TIM2_BASE + 0x10))\n#define TIM2_PSC (*(volatile uint32_t *)(TIM2_BASE + 0x28))\n#define TIM2_ARR (*(volatile uint32_t *)(TIM2_BASE + 0x2c))\n```", "```cpp\n#define TIM_DIER_UIE (1 << 0)\n#define TIM_SR_UIF (1 << 0)\n#define TIM_CR1_CLOCK_ENABLE (1 << 0)\n#define TIM_CR1_UPD_RS (1 << 2)\n```", "```cpp\nvoid isr_tim2(void)\n{\n  static volatile uint32_t timer2_ticks = 0;\n  TIM2_SR &= ~TIM_SR_UIF;\n  timer2_ticks++;\n}\n```", "```cpp\nisr_tim2 , // TIM2_IRQ 28\n```", "```cpp\n#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))\n#define APB1_CLOCK_RST (*(volatile uint32_t *)\n     (0x40023820))\n#define TIM2_APB1_CLOCK_ER_VAL (1 << 0)\n#define NVIC_TIM2_IRQN (28)\n```", "```cpp\nint timer_init(uint32_t clock, uint32_t interval_ms)\n{\n  uint32_t val = 0;\n  uint32_t psc = 1;\n  uint32_t err = 0;\n  clock = (clock / 1000) * interval_ms;\n  while (psc < 65535) {\n    val = clock / psc;\n    err = clock % psc;\n    if ((val < 65535) && (err == 0)) {\n      val--;\n      break;\n    }\n    val = 0;\n    psc++;\n  }\n  if (val == 0)\n    return -1;\n  nvic_irq_enable(NVIC_TIM2_IRQN);\n  nvic_irq_setprio(NVIC_TIM2_IRQN, 0);\n  APB1_CLOCK_RST |= TIM2_APB1_CLOCK_ER_VAL;\n  DMB();\n  TIM2_PSC = psc;\n  TIM2_ARR = val;\n  TIM2_CR1 |= TIM_CR1_CLOCK_ENABLE;\n  TIM2_DIER |= TIM_DIER_UIE;\n  DMB();\n  return 0;\n}\n```", "```cpp\n#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))\n#define GPIOD_AHB1_CLOCK_ER (1 << 3)\nAHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;\n```", "```cpp\n#define GPIOD_BASE 0x40020c00\n#define GPIOD_MODE (*(volatile uint32_t *)(GPIOD_BASE +\n    0x00))\n#define GPIOD_OTYPE (*(volatile uint32_t *)(GPIOD_BASE +\n    0x04))\n#define GPIOD_PUPD (*(volatile uint32_t *)(GPIOD_BASE +\n    0x0c))\n#define GPIOD_ODR (*(volatile uint32_t *)(GPIOD_BASE +\n    0x14))\n#define GPIOD_BSRR (*(volatile uint32_t *)(GPIOD_BASE +\n    0x18))\n```", "```cpp\n#define GPIOD_AFL (*(volatile uint32_t *)(GPIOD_BASE +\n    0x20))\n#define GPIOD_AFH (*(volatile uint32_t *)(GPIOD_BASE +\n    0x24))\n```", "```cpp\n#define LED_PIN (15)\nvoid led_setup(void)\n{\n  uint32_t mode_reg;\n```", "```cpp\n  AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;\n```", "```cpp\n   GPIOD_MODE &= ~ (0x03 << (LED_PIN * 2));\n```", "```cpp\n   GPIOD_MODE |= 1 << (LED_PIN * 2);\n```", "```cpp\n   GPIOD_PUPD &= ~(0x03 << (LED_PIN * 2));\n   GPIOD_PUPD |= 0x02 << (LED_PIN * 2);\n}\n```", "```cpp\nvoid led_on(void)\n{\n  GPIOD_BSRR |= 1 << LED_PIN;\n}\n```", "```cpp\nvoid led_off(void)\n{\n  GPIOD_BSRR |= 1 << (LED_PIN + 16);\n}\n```", "```cpp\nvoid led_toggle(void)\n{\n  if ((GPIOD_ODR & (1 << LED_PIN)) == (1 << LED_PIN))\n    led_off();\n  else\n    led_on();\n}\n```", "```cpp\nvoid isr_tim2(void)\n{\n  TIM2_SR &= ~TIM_SR_UIF;\n  led_toggle();\n}\n```", "```cpp\nvoid main(void) {\n  flash_set_waitstates();\n  clock_config();\n  led_setup();\n  timer_init(CPU_FREQ, 1, 1000);\n  while(1)\n  WFI();\n}\n```", "```cpp\nGPIOD_MODE &= ~ (0x03 << (LED_PIN * 2));\nGPIOD_MODE |= (2 << (LED_PIN * 2));\n```", "```cpp\nuint32_t value;\nif (LED_PIN < 8) {\n   value = GPIOD_AFL & (~(0xf << (LED_PIN * 4)));\n   GPIOD_AFL = value | (0x2 << (LED_PIN * 4));\n} else {\n   value = GPIOD_AFH & (~(0xf << ((LED_PIN - 8) * 4)));\n   GPIOD_AFH = value |(0x2 << ((LED_PIN - 8) * 4));\n}\n```", "```cpp\nvoid led_pwm_setup(void)\n{\n  AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;\n  GPIOD_MODE &= ~ (0x03 << (LED_PIN * 2));\n  GPIOD_MODE |= (2 << (LED_PIN * 2));\n  GPIOD_OSPD &= ~(0x03 << (LED_PIN * 2));\n  GPIOD_OSPD |= (0x03 << (LED_PIN * 2));\n  GPIOD_PUPD &= ~(0x03 << (LED_PIN * 2));\n  GPIOD_PUPD |= (0x02 << (LED_PIN * 2));\n  GPIOD_AFH &= ~(0xf << ((LED_PIN - 8) * 4));\n  GPIOD_AFH |= (0x2 << ((LED_PIN - 8) * 4));\n}\n```", "```cpp\nint pwm_init(uint32_t clock, uint32_t dutycycle)\n{\n```", "```cpp\n  APB1_CLOCK_RST &= ~TIM4_APB1_CLOCK_ER_VAL;\n  APB1_CLOCK_ER |= TIM4_APB1_CLOCK_ER_VAL;\n```", "```cpp\n  TIM4_CCER &= ~TIM_CCER_CC4_ENABLE;\n  TIM4_CR1 = 0;\n  TIM4_PSC = 0;\n```", "```cpp\n  uint32_t val = clock / 100000;\n```", "```cpp\n  lvl = (val * threshold) / 100;\n  if (lvl != 0)\n    lvl--;\n```", "```cpp\n  TIM4_ARR = val - 1;\n  TIM4_CCR4 = lvl;\n```", "```cpp\n  TIM4_CCMR1 &= ~(0x03 << 0);\n  TIM4_CCMR1 &= ~(0x07 << 4);\n```", "```cpp\n  TIM4_CCMR1 &= ~(0x03 << 0);\n  TIM4_CCMR1 &= ~(0x07 << 4);\n  TIM4_CCMR1 |= TIM_CCMR1_OC1M_PWM1;\n  TIM4_CCMR2 &= ~(0x03 << 8);\n  TIM4_CCMR2 &= ~(0x07 << 12);\n  TIM4_CCMR2 |= TIM_CCMR2_OC4M_PWM1;\n```", "```cpp\n  TIM4_CCMR2 |= TIM_CCMR2_OC4M_PWM1;\n  TIM4_CCER |= TIM_CCER_CC4_ENABLE;\n  TIM4_CR1 |= TIM_CR1_CLOCK_ENABLE | TIM_CR1_ARPE;\n}\n```", "```cpp\nvoid main(void) {\n  flash_set_waitstates();\n  clock_config();\n  led_pwm_setup();\n  pwm_init(CPU_FREQ, 50);\n  while(1)\n    WFI();\n}\n```", "```cpp\nvoid isr_tim2(void) {\n  static uint32_t tim2_ticks = 0;\n  TIM2_SR &= ~TIM_SR_UIF;\n  if (tim2_ticks > 16)\n    tim2_ticks = 0;\n  if (tim2_ticks > 8)\n    pwm_init(master_clock, 10 * (16 - tim2_ticks));\n  else\n    pwm_init(master_clock, 10 * tim2_ticks);\n  tim2_ticks++;\n}\n```", "```cpp\nvoid main(void) {\n  flash_set_waitstates();\n  clock_config();\n  led_pwm_setup();\n  pwm_init(CPU_FREQ, 0);\n  timer_init(CPU_FREQ, 1, 50);\n  while(1)\n    WFI();\n}\n```", "```cpp\n#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))\n#define GPIOA_AHB1_CLOCK_ER (1 << 0)\n```", "```cpp\n#define GPIOA_BASE 0x40020000\n#define GPIOA_MODE (*(volatile uint32_t *)(GPIOA_BASE +\n     0x00))\n#define GPIOA_IDR (*(volatile uint32_t *)(GPIOA_BASE +\n     0x10))\n```", "```cpp\n#define BUTTON_PIN (0)\nvoid button_setup(void)\n{\n  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;\n  GPIOA_MODE &= ~ (0x03 << (BUTTON_PIN * 2));\n}\n```", "```cpp\nint button_is_pressed(void)\n{\n  return (GPIOA_IDR & (1 << BUTTON_PIN)) >> BUTTON_PIN;\n}\n```", "```cpp\n#define EXTI_CR_BASE (0x40013808)\n#define EXTI_CR0 (*(volatile uint32_t *)(EXTI_CR_BASE +\n    0x00))\n#define EXTI_CR_EXTI0_MASK (0x0F)\n```", "```cpp\n#define NVIC_EXTI0_IRQN (6)\n```", "```cpp\n#define EXTI_BASE (0x40013C00)\n#define EXTI_IMR (*(volatile uint32_t *)(EXTI_BASE + 0x00))\n#define EXTI_EMR (*(volatile uint32_t *)(EXTI_BASE + 0x04))\n#define EXTI_RTSR (*(volatile uint32_t *)(EXTI_BASE +\n    0x08))\n#define EXTI_FTSR (*(volatile uint32_t *)(EXTI_BASE +\n    0x0c))\n#define EXTI_SWIER (*(volatile uint32_t *)(EXTI_BASE +\n    0x10))\n#define EXTI_PR (*(volatile uint32_t *)(EXTI_BASE + 0x14))\n```", "```cpp\nvoid button_setup(void)\n{\n  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;\n  GPIOA_MODE &= ~ (0x03 << (BUTTON_PIN * 2));\n  EXTI_CR0 &= ~EXTI_CR_EXTI0_MASK;\n  nvic_irq_enable(NVIC_EXTI0_IRQN);\n  EXTI_IMR |= 1 << BUTTON_PIN;\n  EXTI_EMR |= 1 << BUTTON_PIN;\n  EXTI_RTSR |= 1 << BUTTON_PIN;\n}\n```", "```cpp\nvolatile uint32_t button_presses = 0;\nvoid isr_exti0(void)\n{\n  EXTI_PR |= 1 << BUTTON_PIN;\n  button_presses++;\n}\n```", "```cpp\n#define APB2_CLOCK_ER (*(volatile uint32_t *)(0x40023844))\n#define ADC1_APB2_CLOCK_ER_VAL (1 << 8)\n#define ADC1_BASE (0x40012000)\n#define ADC1_SR (*(volatile uint32_t *)(ADC1_BASE + 0x00))\n#define ADC1_CR1 (*(volatile uint32_t *)(ADC1_BASE +\n     0x04))\n#define ADC1_CR2 (*(volatile uint32_t *)(ADC1_BASE +\n     0x08))\n#define ADC1_SMPR1 (*(volatile uint32_t *)(ADC1_BASE +\n     0x0c))\n#define ADC1_SMPR2 (*(volatile uint32_t *)(ADC1_BASE +\n     0x10))\n#define ADC1_SQR3 (*(volatile uint32_t *)(ADC1_BASE +\n     0x34))\n#define ADC1_DR (*(volatile uint32_t *)(ADC1_BASE + 0x4c))\n#define ADC_CR1_SCAN (1 << 8)\n#define ADC_CR2_EN (1 << 0)\n#define ADC_CR2_CONT (1 << 1)\n#define ADC_CR2_SWSTART (1 << 30)\n#define ADC_SR_EOC (1 << 1)\n#define ADC_SMPR_SMP_480CYC (0x7)\n```", "```cpp\n#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))\n#define GPIOB_AHB1_CLOCK_ER (1 << 1)\n#define GPIOB_BASE (0x40020400)\n#define GPIOB_MODE (*(volatile uint32_t *)(GPIOB_BASE +\n     0x00))\n#define ADC_PIN (1)\n#define ADC_PIN_CHANNEL (9)\n```", "```cpp\n#define ADC_COM_BASE (0x40012300)\n#define ADC_COM_CCR (*(volatile uint32_t *)(ADC_COM_BASE +\n    0x04))\n```", "```cpp\nint adc_init(void)\n{\n  APB2_CLOCK_ER |= ADC1_APB2_CLOCK_ER_VAL;\n  AHB1_CLOCK_ER |= GPIOB_AHB1_CLOCK_ER;\n```", "```cpp\n  GPIOB_MODE |= 0x03 << (ADC_PIN * 2);\n```", "```cpp\n  ADC1_CR2 &= ~(ADC_CR2_EN);\n  ADC_COM_CCR &= ~(0x03 << 16);\n  ADC1_CR1 &= ~(ADC_CR1_SCAN);\n  ADC1_CR2 &= ~(ADC_CR2_CONT);\n```", "```cpp\n  if (ADC_PIN_CHANNEL > 9) {\n    uint32_t val = ADC1_SMPR2;\n    val = ADC_SMPR_SMP_480CYC << ((ADC_PIN_CHANNEL - 10) *\n    3);\n    ADC1_SMPR2 = val;\n  } else {\n    uint32_t val = ADC1_SMPR1;\n    val = ADC_SMPR_SMP_480CYC << (ADC_PIN_CHANNEL * 3);\n    ADC1_SMPR1 = val;\n  }\n```", "```cpp\n  ADC1_SQR3 |= (ADC_PIN_CHANNEL);\n```", "```cpp\n  ADC1_CR2 |= ADC_CR2_EN;\n  return 0;\n}\n```", "```cpp\nint adc_read(void)\n{\n  ADC1_CR2 |= ADC_CR2_SWSTART;\n  while (ADC1_CR2 & ADC_CR2_SWSTART)\n    ;\n  while ((ADC1_SR & ADC_SR_EOC) == 0)\n    ;\n```", "```cpp\n  return (int)(ADC1_DR);\n}\n```", "```cpp\n#define IWDG_BASE (0x40003000)\n#define IWDG_KR (*(volatile uint32_t *)(IWDG_BASE + 0x00))\n#define IWDG_PR (*(volatile uint32_t *)(IWDG_BASE + 0x04))\n#define IWDG_RLR (*(volatile uint32_t *)(IWDG_BASE + 0x08))\n#define IWDG_SR (*(volatile uint32_t *)(IWDG_BASE + 0x0c))\n```", "```cpp\n#define IWDG_KR_RESET 0x0000AAAA\n#define IWDG_KR_UNLOCK 0x00005555\n#define IWDG_KR_START 0x0000CCCC\n```", "```cpp\n#define IWDG_SR_RVU (1 << 1)\n#define IWDG_SR_PVU (1 << 0)\n```", "```cpp\nint iwdt_init(uint32_t interval_ms)\n{\n   uint32_t pre = 0;\n   uint32_t counter;\n```", "```cpp\n   counter = interval_ms << 5;\n```", "```cpp\n   counter >>= 2;\n   while (counter > 0xFFF) {\n     pre++;\n     counter >>= 1;\n   }\n```", "```cpp\n   if (counter == 0)\n     counter = 1;\n   if (pre > 6)\n     return -1;\n```", "```cpp\n   while(IWDG_SR & IWDG_SR_PR_BUSY);\n   IWDG_KR = IWDG_KR_UNLOCK;\n   IWDG_PR = pre;\n   while (IWDG_SR & IWDG_SR_RLR_BUSY);\n   IWDG_KR = IWDG_KR_UNLOCK;\n   IWDG_RLR = counter;\n```", "```cpp\n   IWDG_KR = IWDG_KR_START;\n   return 0;\n}\n```", "```cpp\nvoid iwdt_reset(void)\n{\n   IWDG_KR = IWDG_KR_RESET;\n}\n```", "```cpp\nvoid main(void) {\n  flash_set_waitstates();\n  clock_config();\n  button_setup();\n  iwdt_init(2000);\n  while(1)\n    WFI();\n}\n```", "```cpp\nvoid isr_exti0(void)\n{\n  EXTI_PR |= (1 << BUTTON_PIN);\n  iwdt_reset();\n}\n```"]