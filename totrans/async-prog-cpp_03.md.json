["```cpp\ncmake . && cmake —build .\n```", "```cpp\nvoid func() {\n    std::cout << \"Using function pointer\\n\";\n}\nstd::thread t1(func);\n```", "```cpp\nauto lambda_func = []() {\n    std::cout << \"Using lambda function\\n\";\n};\nstd::thread t2(lambda_func);\n```", "```cpp\nstd::thread t3([]() {\n    std::cout << \"Using embedded lambda function\\n\";\n});\n```", "```cpp\nclass FuncObjectClass {\n   public:\n    void operator()() {\n        std::cout << \"Using function object class\\n\";\n    }\n};\nstd::thread t4{FuncObjectClass()};\n```", "```cpp\nclass Obj {\n  public:\n    void func() {\n        std::cout << \"Using a non-static member function\"\n                  << std::endl;\n    }\n};\nObj obj;\nstd::thread t5(&Obj::func, &obj);\n```", "```cpp\nclass Obj {\n  public:\n    static void static_func() {\n        std::cout << \"Using a static member function\\n\";\n    }\n};\nstd::thread t6(&Obj::static_func);\n```", "```cpp\nconst auto processor_count = std::thread::hardware_concurrency();\n```", "```cpp\n#include <iostream>\n#include <thread>\nint main() {\n    std::thread t1([]() {\n        for (int i = 0; i < 100; ++i) {\n            std::cout << \"1 \" << \"2 \" << \"3 \" << \"4 \"\n                      << std::endl;\n        }\n    });\n    std::thread t2([]() {\n        for (int i = 0; i < 100; ++i) {\n            std::cout << \"5 \" << \"6 \" << \"7 \" << \"8 \"\n                      << std::endl;\n        }\n    });\n    t1.join();\n    t2.join();\n    return 0;\n}\n```", "```cpp\n6 1 2 3 4\n1 5 2 6 3 4 7 8\n1 2 3 5 6 7 8\n```", "```cpp\nstd::ostringstream oss;\noss << \"1 \" << \"2 \" << \"3 \" << \"4 \" << \"\\n\";\nstd::cout << oss.str();\n```", "```cpp\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nint main() {\n    std::thread t1([]() {\n        for (int i = 0; i < 100; ++i) {\n            sync_cout << \"1 \" << \"2 \" << \"3 \" << \"4 \"\n                      << std::endl;\n        }\n    });\n    std::thread t2([]() {\n        for (int i = 0; i < 100; ++i) {\n            sync_cout << \"5 \" << \"6 \" << \"7 \" << \"8 \"\n                      << std::endl;\n        }\n    });\n    t1.join();\n    t2.join();\n    return 0;\n}\n```", "```cpp\n1 2 3 4\n1 2 3 4\n5 6 7 8\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid func() {\n    std::this_thread::sleep_for(1s);\n}\nint main() {\n    std::thread t(func);\n    std::cout << \"Thread ID: \" << t.get_id() << std::endl;\n    t.join();\n    return 0;\n}\n```", "```cpp\nvoid funcByValue(const std::string& str, int val) {\n    sync_cout << «str: « << str << «, val: « << val\n              << std::endl;\n}\nstd::string str{\"Passing by value\"};\nstd::thread t(funcByValue, str, 1);\n```", "```cpp\nvoid modifyValues(std::string& str, int& val) {\n    str += \" (Thread)\";\n    val++;\n}\nstd::string str{\"Passing by reference\"};\nint val = 1;\nstd::thread t(modifyValues, std::ref(str), std::ref(val));\n```", "```cpp\nvoid printVector(const std::vector<int>& v) {\n    sync_cout << \"Vector: \";\n    for (int num : v) {\n        sync_cout << num << \" \";\n    }\n    sync_cout << std::endl;\n}\nstd::vector<int> v{1, 2, 3, 4, 5};\nstd::thread t(printVector, std::cref(v));\n```", "```cpp\nstd::thread t(printVector, std::move(v));\n```", "```cpp\nstd::string str{\"Hello\"};\nstd::thread t([&]() {\n    sync_cout << \"str: \" << str << std::endl;\n});\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <random>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nnamespace {\nint result = 0;\n};\nvoid func(int& result) {\n    std::this_thread::sleep_for(1s);\n    result = 1 + (rand () % 10);\n}\nInt main() {\n    std::thread t(func, std::ref(result));\n    t.join();\n    sync_cout << \"Result: \" << result << std::endl;\n}\n```", "```cpp\nstd::thread t([&]() { func(result); });\nt.join();\nsync_cout << \"Result: \" << result << std::endl;\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <mutex>\n#include <random>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nnamespace {\nint result = 0;\nstd::mutex mtx;\n};\nvoid funcWithMutex() {\n    std::this_thread::sleep_for(1s);\n    int localVar = 1 + (rand() % 10);\n    std::lock_guard<std::mutex> lock(mtx);\n    result = localVar;\n}\nInt main() {\n    std::thread t(funcWithMutex);\n    t.join();\n    sync_cout << \"Result: \" << result << std::endl;\n}\n```", "```cpp\n#include <chrono>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid func() {\n    for (auto i=0; i<10; ++i) {\n        std::this_thread::sleep_for(500ms);\n    }\n}\nint main() {\n    std::thread t1(func);\n    std::thread t2 = std::move(t1);\n    t2.join();\n    return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid func() {\n    std::this_thread::sleep_for(100ms);\n}\nint main() {\n    std::thread t1;\n    std::cout << \"Is t1 joinable? \" << t1.joinable()\n              << std::endl;\n    std::thread t2(func);\n    t1.swap(t2);\n    std::cout << \"Is t1 joinable? \" << t1.joinable()\n              << std::endl;\n    std::cout << \"Is t2 joinable? \" << t2.joinable()\n              << std::endl;\n    t1.join();\n    std::cout << \"Is t1 joinable? \" << t1.joinable()\n              << std::endl;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nnamespace {\nint timeout = 3;\n}\nvoid daemonThread() {\n    sync_cout << \"Daemon thread starting...\\n\";\n    while (timeout-- > 0) {\n        sync_cout << \"Daemon thread is running...\\n\";\n        std::this_thread::sleep_for(1s);\n    }\n    sync_cout << \"Daemon thread exiting...\\n\";\n}\nint main() {\n    std::thread t(daemonThread);\n    t.detach();\n    std::this_thread::sleep_for(\n              std::chrono::seconds(timeout + 1));\n    sync_cout << \"Main thread exiting...\\n\";\n    Return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid func() {\n    std::this_thread::sleep_for(1s);\n}\nint main() {\n    std::jthread t(func);\n    sync_cout << \"Thread ID: \" << t.get_id() << std::endl;\n    return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <functional>\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nclass JthreadWrapper {\n   public:\n    JthreadWrapper(\n       const std::function<void(const std::string&)>& func,\n       const std::string& str)\n        : t(func, str), name(str) {\n        sync_cout << \"Thread \" << name\n                  << \" being created\" << std::endl;\n    }\n    ~JthreadWrapper() {\n        sync_cout << \"Thread \" << name\n                  << \" being destroyed\" << std::endl;\n    }\n   private:\n    std::jthread t;\n    std::string name;\n};\n```", "```cpp\nvoid func(const std::string& name) {\n    sync_cout << \"Thread \" << name << \" starting...\\n\";\n    std::this_thread::sleep_for(1s);\n    sync_cout << \"Thread \" << name << \" finishing...\\n\";\n}\nint main() {\n    JthreadWrapper t1(func, «t1»);\n    JthreadWrapper t2(func, \"t2\");\n    JthreadWrapper t3(func, \"t3\");\n    std::this_thread::sleep_for(2s);\n    sync_cout << \"Main thread exiting...\" << std::endl;\n    return 0;\n}\n```", "```cpp\nThread t1 being created\nThread t1 starting...\nThread t2 being created\nThread t2 starting...\nThread t3 being created\nThread t3 starting...\nThread t1 finishing...\nThread t2 finishing...\nThread t3 finishing...\nMain thread exiting...\nThread t3 being destroyed\nThread t2 being destroyed\nThread t1 being destroyed\n```", "```cpp\n#include <iostream>\n#include <random>\n#include <string>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono;\nnamespace {\nint val = 0;\nstd::mutex mtx;\n}\nint main() {\n    auto work = [&](const std::string& name) {\n        while (true) {\n            bool work_to_do = rand() % 2;\n            if (work_to_do) {\n                sync_cout << name << \": working\\n\";\n                std::lock_guard<std::mutex> lock(mtx);\n                for (auto start = steady_clock::now(),\n                          now = start;\n                          now < start + 3s;\n                          now = steady_clock::now()) {\n                }\n            } else {\n                sync_cout << name << \": yielding\\n\";\n                std::this_thread::yield();\n            }\n        }\n    };\n    std::jthread t1(work, \"t1\");\n    std::jthread t2(work, \"t2\");\n    return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <functional>\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nclass Counter {\n    using Callback = std::function<void(void)>;\n   public:\n    Counter(const Callback &callback) {\n        t = std::jthread([&]() {\n            while (running.load() == true) {\n                callback ();\n                std::this_thread::sleep_for(1s);\n            }\n        });\n    }\n    void stop() { running.store(false); }\n   private:\n    std::jthread t;\n    std::atomic_bool running{true};\n};\n```", "```cpp\nint main() {\n    Counter counter([&]() {\n        sync_cout << \"Callback: Running...\\n\";\n    });\n    std::this_thread::sleep_for(3s);\n    counter.stop();\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <string_view>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\ntemplate <typename T>\nvoid show_stop_props(std::string_view name,\n                     const T& stop_item) {\n    sync_cout << std::boolalpha\n              << name\n              << \": stop_possible = \"\n              << stop_item.stop_possible()\n              << \", stop_requested = \"\n              << stop_item.stop_requested()\n              << '\\n';\n};\n```", "```cpp\nauto worker1 = std::jthread(func_with_stop_token);\nstd::stop_token stop_token = worker1.get_stop_token();\nshow_stop_props(\"stop_token\", stop_token);\n```", "```cpp\nvoid func_with_stop_token(std::stop_token stop_token) {\n    for (int i = 0; i < 10; ++i) {\n        std::this_thread::sleep_for(300ms);\n        if (stop_token.stop_requested()) {\n            sync_cout << \"stop_worker: \"\n                      << \"Stopping as requested\\n\";\n            return;\n        }\n        sync_cout << \"stop_worker: Going back to sleep\\n\";\n    }\n}\n```", "```cpp\nworker1.request_stop();\nworker1.join();\nshow_stop_props(\"stop_token after request\", stop_token);\n```", "```cpp\nauto worker2 = std::jthread(func_with_stop_token);\nstd::stop_source stop_source = worker2.get_stop_source();\nshow_stop_props(\"stop_source\", stop_source);\nauto stopper = std::thread( [](std::stop_source source) {\n        std::this_thread::sleep_for(500ms);\n        sync_cout << \"Request stop for worker2 \"\n                  << \"via source\\n\";\n        source.request_stop();\n    }, stop_source);\nstopper.join();\nstd::this_thread::sleep_for(200ms);\nshow_stop_props(\"stop_source after request\", stop_source);\n```", "```cpp\nstd::stop_callback callback(worker1.get_stop_token(), []{\n    sync_cout << \"stop_callback for worker1 \"\n              << \"executed by thread \"\n              << std::this_thread::get_id() << '\\n';\n});\nsync_cout << \"main_thread: \"\n          << std::this_thread::get_id() << '\\n';\nstd::stop_callback callback_after_stop(\n    worker2.get_stop_token(),[] {\n        sync_cout << \"stop_callback for worker2 \"\n                  << \"executed by thread \"\n                  << std::this_thread::get_id() << '\\n';\n});\n```", "```cpp\n{\n    std::stop_callback scoped_callback(\n        worker2.get_stop_token(), []{\n          sync_cout << \"Scoped stop callback \"\n                    << \"will not execute\\n\";\n      }\n    );\n}\n```", "```cpp\nsync_cout << \"main_thread: \"\n          << std::this_thread::get_id() << '\\n';\nstd::stop_callback callback_after_stop(\n    worker2.get_stop_token(), []{\n        sync_cout << \"stop_callback for worker2 \"\n                  << \"executed by thread \"\n                  << std::this_thread::get_id() << '\\n';\n    }\n);\n```", "```cpp\n#include <atomic>\n#include <chrono>\n#include <exception>\n#include <iostream>\n#include <mutex>\n#include <thread>\nusing namespace std::chrono_literals;\nstd::exception_ptr captured_exception;\nstd::mutex mtx;\nvoid func() {\n    try {\n        std::this_thread::sleep_for(1s);\n        throw std::runtime_error(\n                  \"Error in func used within thread\");\n    } catch (...) {\n        std::lock_guard<std::mutex> lock(mtx);\n        captured_exception = std::current_exception();\n    }\n}\nint main() {\n    std::thread t(func);\n    while (!captured_exception) {\n        std::this_thread::sleep_for(250ms);\n        std::cout << „In main thread\\n\";\n    }\n    try {\n        std::rethrow_exception(captured_exception);\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception caught in main thread: \"\n                  << e.what() << std::endl;\n    }\n    t.join();\n}\n```", "```cpp\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nthread_local int val = 0;\nvoid setValue(int newval) { val = newval; }\nvoid printValue() { sync_cout << val << ' '; }\nvoid multiplyByTwo(int arg) {\n    setValue(arg);\n    val *= 2;\n    printValue();\n}\nint main() {\n    val = 1;  // Value in main thread\n    std::thread t1(multiplyByTwo, 1);\n    std::thread t2(multiplyByTwo, 2);\n    std::thread t3(multiplyByTwo, 3);\n    t1.join();\n    t2.join();\n    t3.join();\n    std::cout << val << std::endl;\n}\n```", "```cpp\n2 4 6 1\n```", "```cpp\n#include <chrono>\n#include <functional>\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nusing namespace std::chrono;\ntemplate<typename Duration>\nclass Timer {\n   public:\n    typedef std::function<void(void)> Callback;\n    Timer(const Duration interval,\n          const Callback& callback) {\n        auto value = duration_cast<milliseconds>(interval);\n        sync_cout << \"Timer: Starting with interval of \"\n                  << value << std::endl;\n        t = std::jthread([&](std::stop_token stop_token) {\n            while (!stop_token.stop_requested()) {\n                sync_cout << \"Timer: Running callback \"\n                          << val.load() << std::endl;\n                val++;\n                callback();\n                sync_cout << \"Timer: Sleeping...\\n\";\n                std::this_thread::sleep_for(interval);\n            }\n            sync_cout << „Timer: Exit\\n\";\n        });\n    }\n    void stop() {\n        t.request_stop();\n    }\n   private:\n    std::jthread t;\n    std::atomic_int32_t val{0};\n};\n```", "```cpp\nint main(void) {\n    sync_cout << \"Main: Create timer\\n\";\n    Timer timer(1s, [&]() {\n        sync_cout << \"Callback: Running...\\n\";\n    });\n    std::this_thread::sleep_for(3s);\n    sync_cout << \"Main thread: Stop timer\\n\";\n    timer.stop();\n    std::this_thread::sleep_for(500ms);\n    sync_cout << \"Main thread: Exit\\n\";\n    return 0;\n}\n```", "```cpp\nMain: Create timer\nTimer: Starting with interval of 1000ms\nTimer: Running callback 0\nCallback: Running...\nTimer: Sleeping...\nTimer: Running callback 1\nCallback: Running...\nTimer: Sleeping...\nTimer: Running callback 2\nCallback: Running...\nTimer: Sleeping...\nMain thread: Stop timer\nTimer: Exit\nMain thread: Exit\n```"]