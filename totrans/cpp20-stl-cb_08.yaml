- en: '*Chapter 8*: Utility Classes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Standard Library includes an assortment of utility classes designed
    for specific tasks. Some are common, and you've probably seen many of these classes
    in other recipes in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers a broad range of utilities, including time measurement,
    generic types, smart pointers, and more, in the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage optional values with `std::optional`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::any` for type safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store different types with `std::variant`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time events with `std::chrono`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use fold expressions for variadic tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage allocated memory with `std::unique_ptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share objects with `std::shared_ptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use weak pointers with shared objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share members of a managed object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare random number engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare random number distribution generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08).
  prefs: []
  type: TYPE_NORMAL
- en: Manage optional values with std::optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced with C++17, the `std::optional` class holds an *optional value*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the case where you have a function that may or may not return a value
    – for example, a function that checks if a number is *prime* but returns the first
    factor if there is one. This function should return either a value or a `bool`
    status. We could create a `struct` that carries both value and status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's a clumsy solution but it works, and it's not uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be made a lot simpler with the `optional` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With `optional`, we can return a value or a non-value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The optional class allows us to easily return the optional value and easily
    test for a value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll look at some examples of how to use the `optional` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `optional` class is quite simple. We construct an optional value using
    standard template notation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We access the value of the `optional` with the `*` pointer dereference operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We test if the `optional` has a value using its `bool` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `a` were constructed without a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would reflect the `else` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can further simplify this by declaring a *type alias*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to operate on `oint` objects, with `oint` objects as the result,
    we can provide operator overloads:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can operate on the `oint` objects directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we declare `b` with the default constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we get the `else` branch output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::optional` class is made for simplicity. It provides operator overloads
    for many common functions. It also includes member functions for further flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `optional` class provides an `operator bool` overload for determining if
    the object has a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you may use the `has_value()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the value, you may use the `operator*` overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you may use the `value()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reset()` member function destroys the value and resets the state of the
    `optional` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `optional` class provides exception support with the `value()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Only the `value()` method throws an exception. The behavior of the `*` operator
    is *undefined* for an invalid value.
  prefs: []
  type: TYPE_NORMAL
- en: Use std::any for type safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced with C++17, the `std::any` class provides a type-safe container for
    a single object of any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is a default-constructed `any` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This object has no value. We can test that with the `has_value()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We assign a value to the `any` object with the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `any` object has a value, and a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `type()` method returns a `type_info` object. The `type_info::name()` method
    returns an implementation-defined name for the type in a C-string. In this case,
    for GCC, the `i` means `int`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `any_cast<`*type*`>()` non-member function to cast the value for
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can re-assign the `any` object with different values of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I've abbreviated the long type name from GCC but you get the idea. The same
    `any` object that once held an `int` now contains an STL `string` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main usefulness of the `any` class is in creating a polymorphic function.
    Let''s examine how to do that in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll build a polymorphic function using the `any` class.
    A polymorphic function is one that can take objects of different types in its
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our polymorphic function takes an `any` object and prints its type and value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `p_any()` function first tests to see if the object has a value. It then
    tests the `type()` method against various types and takes appropriate action for
    each type.
  prefs: []
  type: TYPE_NORMAL
- en: Before the `any` class, we would have had to write four different specializations
    for this function, and we still wouldn't be able to easily handle the default
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this function from `main()`, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our polymorphic function handles the various types with a minimum of code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::any` copy constructor and assignment operator use *direct initialization*
    to make a non-`const` copy of the target object as the *contained* object. The
    type of the contained object is stored separately as a `typeid` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once initialized, the `any` object has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace()` replaces the contained object, constructing the new object in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset()` destroys the contained object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has_value()` returns `true` if there is a contained object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type()` returns a `typeid` object, representing the type of the contained
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator=()` replaces the contained object by a *copy* or *move* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `any` class also supports the following non-member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`any_cast<T>()`, a template function, provides type-safe access to the contained
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the `any_cast<T>()` function returns a copy of the contained
    object. You may use `any_cast<T&>()` to return a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::swap()` specializes the `std::swap` algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you try to cast an `any` object with the wrong type, it throws a `bad_any_cast`
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Store different types with std::variant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced with C++17, the `std::variant` class may hold different values, one
    at a time, where each value must fit in the same allocated memory space. It's
    useful for holding alternative types for use in a single context.
  prefs: []
  type: TYPE_NORMAL
- en: Differences from the primitive union structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `variant` class is a *tagged union*. It differs from the primitive `union`
    structure in that only one type may be in effect at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primitive `union` type, inherited from C, is a structure where the same
    datum may be accessed as different types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `union` has two members, types `struct` and `uint32_t`,
    where `struct` has four `uint8_t` members. This gives us two *different perspectives
    of the same 32-bit memory space*. We can view the same `ipv4` address as either
    a 32-bit unsigned integer (**Little Endian** or **LE**) or four 8-bit unsigned
    integers in the common *dotted quad* notation. This provides a bitwise polymorphy
    that can be useful at the systems level.
  prefs: []
  type: TYPE_NORMAL
- en: '`variant` doesn''t work like that. The `variant` class is a *tagged union*,
    where each datum is tagged with its type. If we store a value as `uint32_t`, we
    may only access it as `uint32_t`. This makes `variant` type safe but not a replacement
    for `union`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we demonstrate the use of `std::variant` with a small catalogue
    of household pets of various species.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple class to hold an `Animal`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name of the animal and the sound that the animal makes are passed in the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual species classes inherit from `Animal`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of these classes set the sound for their specific species by calling the
    parent constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can define our `variant` type in an alias:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `variant` can hold any of the types, `Cat`, `Dog`, or `Wookie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we create a `list` using our `v_animal` alias as the type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each element in the list is of a type included in the `variant` definition.
  prefs: []
  type: TYPE_NORMAL
- en: The `variant` class provides several different ways to access elements. First,
    we'll look at the `visit()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visit()` calls a *functor* with the object currently contained in the `variant`.
    First, let''s define a functor that accepts any of our pets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple functor class with overloads for each of the `Animal` sub-classes.
    We call it with `visit()`, with each of our `list` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `variant` class also provides an `index()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Each `variant` object is indexed, based on the order in which the types were
    declared in the template arguments. Our `v_animal` type was defined with `std::variant<Cat,
    Dog, Wookie>`, and these types are indexed as `0` – `2`, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_if<T>()` function tests a given element against a type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `get_if<T>()` function returns a pointer if the type of the element matches
    `T`; otherwise, it returns `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `holds_alternative<T>()` function returns `true` or `false`. We
    can use this to test a type against an element, without returning the element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::variant` class is a single-object container. An instance of `variant<X,
    Y, Z>` must hold exactly one object of type `X`, `Y`, or `Z`. It holds both the
    value and the type of its current object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index()` method tells us the type of the current object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `holds_alternative<T>()` non-member function returns `true` if `T` is the
    type of the current object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the current object with the `get()` non-member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine the test for type and retrieval with the `get_if()` non-member
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `visit()` non-member function invokes a callable object with the current
    variant object as its single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `visit()` function is the only way to retrieve an object without testing
    its type. In combination with a functor that can handle each type, this can be
    very flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Time events with std::chrono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::chrono` library provides tools for measuring and reporting time and
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these classes and functions were introduced with C++11\. There have
    been significant changes and updates for C++20, but at the time of writing, many
    of those updates are not yet implemented on the systems I've tested.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `chrono` library, this recipe explores techniques for timing events.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `system_clock` class is used for reporting the current date and time. The
    `steady_clock` and `high_resolution_clock` classes are used for timing events.
    Let''s look at the differences between these clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these names can be long and unwieldy, we''ll use some type aliases
    throughout this recipe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `duration` class represents an interval between two points in time. These
    aliases are convenient for using different intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the current time and date by using the `system_clock` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `system_clock::now()` function returns a `time_point` object. The `<chrono>`
    library includes a `format()` specialization for `time_point` that uses `strftime()`
    format specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<iomanip>` header includes `put_time()`, which works like `strftime()`
    for `ostream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`put_time()` takes a pointer to a C-style `time_t*` value. `system_clock::to_time_t`
    converts a `time_point` object to `time_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives the same output as our `format()` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `system_clock` to time an event. First, we need something to
    time. Here''s a function that counts prime numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function counts the prime numbers between 2 and `0x1FFFF` (131,071), which
    should take a few seconds on most modern systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we write a `timer` function to time our `count_primes()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function takes an function `f` and returns `duration<double>`. We use `system_clock::now()`
    to mark the time before and after the call to `f()`. We take the difference between
    the two times and return it in a `duration` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call our `timer()` from `main()`, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This passes the `count_primes()` function to `timer()` and stores the `duration`
    object in `secs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `count()` method on the `duration` object returns the duration in the specified
    units – in this case, `double`, representing *seconds* of duration.
  prefs: []
  type: TYPE_NORMAL
- en: This was run on a VM running *Debian* with GCC. The exact time will vary on
    different systems.
  prefs: []
  type: TYPE_NORMAL
- en: The `system_clock` class is designed to provide the current *wall clock* time.
    While its resolution may support timing purposes, it is not guaranteed to be *monotonic*.
    In other words, it may not always provide consistent *ticks* (timing intervals).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `chrono` library provides a more suitable clock in `steady_clock`. It has
    the same interface as `system_clock` but provides more reliable ticks for timing
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`steady_clock` is designed to provide reliably consistent monotonic ticks,
    suitable for timing events. It uses a relative time reference, so it''s not useful
    for wall clock time. While `system_clock` measures by beginning from a fixed point
    in time (1 January 1970, 00:00 UTC), `steady_clock` uses a relative time.'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is `high_resolution_clock`, which provides the shortest tick
    period available on a given system but is not implemented consistently across
    different implementations. It may be an alias for `system_clock` or `steady_clock`,
    and it may or may not be monotonic. `high_resolution_clock` is not recommended
    for general-purpose use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `timer()` function returns `seconds`, which is an alias for `duration<double>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The duration class takes an optional second template parameter, a `std::ratio`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<chrono>` header provides convenience types for many decimal ratios, including
    `milli` and `micro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we require something else, we may provide our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`fps24` represents the number of frames of film shot at the standard 24 frames
    per second. The ratio is 1/24 of a second.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to easily convert between different ranges of duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Because the `fps24` alias uses `unsigned long` instead of `double`, a type conversion
    is required. The `floor` function provides this by discarding the fractional part.
    `round()` and `ceil()` are also available in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, the `chrono` library provides `format()` specializations for
    the standard `duration` ratios:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: These results will vary on different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two major pieces to the `chrono` library, the *clock* classes and
    the `duration` class.
  prefs: []
  type: TYPE_NORMAL
- en: The clock classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The clock classes include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_clock` – provides wall clock time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`steady_clock` – provides guaranteed monotonic ticks for duration measurements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`high_resolution_clock` – provides the shortest available tick period. It may
    be an alias of `system_clock` or `steady_clock` on some systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `system_clock` to display the current time and date. We use `steady_clock`
    to measure intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the clock classes has a `now()` method that returns `time_point`, representing
    the current value of the clock. `now()` is a static member function, so it''s
    called on the class without instantiating an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The std::duration class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `duration` class is used to hold a time interval – that is, the difference
    between two `time_point` objects. It is generally constructed with a `time_point`
    object's subtraction (`-`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `time_point` subtraction operator doubles as a constructor for `duration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `duration` class has template parameters for type representation and a
    `ratio` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `Period` template parameter defaults to a `ratio` of 1:1, which is seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library provides `ratio` aliases (such as `micro` and `milli`) for powers-of-10
    from `atto` (1/1,000,000,000,000,000,000) through `exa` (1,000,000,000,000,000,000/1).
    This allows us to create standard durations, as we did in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `count()` method gives us the duration in the `Rep` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to easily access the duration for display or other purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Use fold expressions for variadic tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::tuple` class is essentially a more complex, and less convenient, `struct`.
    The interface for `tuple` is cumbersome, although *class template argument deduction*
    and *structured binding* have made it somewhat easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'I tend to use `struct` before `tuple` for most applications, with one significant
    exception: the one real advantage of `tuple` is that it can be used with *fold
    expressions* in a variadic context.'
  prefs: []
  type: TYPE_NORMAL
- en: Fold expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Designed to make it easier to expand a variadic parameter pack, *fold expressions*
    are a new feature with C++17\. Prior to fold expressions, expanding a parameter
    pack required a recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a fold expression, this is much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four types of fold expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unary right fold: `(args op ...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unary left fold: `(... op args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary right fold: `(args op ... op init)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary left fold: `(init op ... op args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expression in the example above is a *binary left fold*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This expands to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Fold expressions are a great convenience for many purposes. Let's look at how
    we can use them with tuples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create a template function that operates on a tuple
    with varying numbers and types of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The heart of this recipe is a function that takes a tuple of unknown size and
    type and prints each element with `format()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The heart of this function is in the lambda expression. It uses the `index_sequence`
    object to generate a parameter pack of index values. We then use a fold expression
    to call `get<I>` with each index value. The templated lambda requires C++20.
  prefs: []
  type: TYPE_NORMAL
- en: You could use a separate function in place of the lambda, but I like keeping
    it in a single scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call this from `main()` with a variety of tuples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The challenge with `tuple` is its restrictive interface. You can retrieve elements
    with `std::tie()`, with *structured bindings*, or the `std::get<>` function. None
    of these techniques are useful if you don't know the number and type of elements
    in the `tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get around this limitation by using the `index_sequence` class. `index_sequence`
    is a specialization of `integer_sequence` that provides a parameter pack of the
    `size_t` elements, which we can use to index our `tuple`. We call our lambda function
    with `make_index_sequence` to set up a parameter pack in the lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The templated lambda is constructed with a parameter pack of `size_t` indexes
    for the `get()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get()` function takes the index value as a template parameter. We use
    a *unary left fold expression* to call `get<I>()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The fold expression takes each element of the function's parameter pack and
    applies the comma operator. The right-hand side of the comma has a `format()`
    function that prints each element of the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it possible to deduce the number of elements in the tuple, which
    makes it useable in a variadic context. Keep in mind that, as with template functions
    in general, the compiler will generate a separate specialization of this function
    for each combination of `tuple` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use this technique for other tasks. For example, here''s a function
    that returns the sum of all the `int` values in a `tuple` of unknown size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this with several `tuple` objects of varying numbers of `int` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Manage allocated memory with std::unique_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Smart pointers* are an excellent tool for managing allocated *heap memory*.'
  prefs: []
  type: TYPE_NORMAL
- en: Heap memory is managed at the lowest level by the C functions, `malloc()` and
    `free()`. `malloc()` allocates a block of memory from the heap, and `free()` returns
    it to the heap. These functions do not perform initialization and do not call
    constructors or destructors. If you fail to return allocated memory to the heap
    with a call to `free()`, the behavior is undefined and often leads to memory leaks
    and security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides the `new` and `delete` operators to allocate and free heap memory,
    in place of `malloc()` and `free()`. The `new` and `delete` operators call object
    constructors and destructors but still do not manage memory. If you allocate memory
    with `new` and fail to free it with `delete`, you will leak memory.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced with C++14, smart pointers comply with the **Resource Acquisition
    Is Initialization** (**RAII**) idiom. This means that when memory is allocated
    for an object, that object's constructor is called. And when the object's destructor
    is called, the memory is automatically returned to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when we create a new smart pointer with `make_unique()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '`make_unique()` allocates memory for a `Thing` object, calls the `Thing` default
    constructor, constructs a `unique_ptr<Thing>` object, and returns the `unique_ptr`.
    When `p` goes out of scope, the `Thing` destructor is called, and the memory is
    automatically returned to the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the memory management, a smart pointer works very much like a primitive
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '`unique_ptr` is a smart pointer that allows only one instance of the pointer.
    It may be moved, but it may not be copied. Let''s take a closer look at how to
    use `unique_ptr`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we examine `std::unique_ptr` with a demonstration class that
    prints when its constructors and destructor are called:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a simple demonstration class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class has a default constructor, a parameterized constructor, and a destructor.
    Each of these has a simple print statement to tell us what was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we just construct a `unique_ptr`, it does not allocate memory or construct
    a managed object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `new` operator, it allocates memory and constructs a `Thing`
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `new` operator constructs a `Thing` object by calling the default constructor.
    The `unique_ptr<Thing>` destructor calls the `Thing` destructor when the smart
    pointer reaches the end of its scope.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thing` default constructor does not initialize the `thname` string, leaving
    its default value, `"unk"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `make_unique()` to get the same result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The `make_unique()` helper function takes care of the memory allocation and
    returns a `unique_ptr` object. This is the recommended way to construct a `unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any arguments you pass to `make_unique()` are used in constructing the target
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The parameterized constructor assigns a value to `thname`, so our `Thing` object
    is now `"Thing 1"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a function that takes a `unique_ptr<Thing>` argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we try to pass a `unique_ptr` to this function, we get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the function call tries to make a copy of the `unique_ptr`
    object, but the `unique_ptr` copy constructor is *deleted* to prevent copying.
    The solution is to have the function take a `const&` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call `process_thing()` with a temporary object, which is immediately
    destroyed at the end of the function scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *smart pointer* is simply an object that presents a pointer interface while
    owning and managing the resources of another object.
  prefs: []
  type: TYPE_NORMAL
- en: The `unique_ptr` class is distinguished by its deleted copy constructor and
    copy assignment operator, which prevents the smart pointer from being copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may not copy a `unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can move a `unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: After the `move`, `p1` is invalid and `p2` is `"Thing 1"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unique_ptr` interface has a method to reset a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reset()` method may also be used to replace the managed object with another
    of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Share objects with std::shared_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::shared_ptr` class is a smart pointer that owns its managed object
    and maintains a *use counter* to keep track of copies. This recipe explores the
    use of `shared_ptr` to manage memory while sharing copies of the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more detail about smart pointers, see the introduction to the *Manage allocated
    memory with std::unique_ptr* recipe earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we examine `std::shared_ptr` with a demonstration class that
    prints when its constructors and destructor are called:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a simple demonstration class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class has a default constructor, a parameterized constructor, and a destructor.
    Each of these has a simple print statement to tell us what was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shared_ptr` class works very much like other smart pointers, in that it
    may be constructed with the `new` operator or with its helper, the `make_shared()`
    function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The `make_shared()` function is recommended, as it manages the construction
    process and is less prone to error.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other smart pointers, the managed object is destroyed, and its memory
    is returned to the heap when the pointer goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a function to check the use count of a `shared_ptr` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`thname` is a member of the `Thing` class, so we access it through the pointer
    with the `p->` member dereference operator. The `use_count()` function is a member
    of the `shared_ptr` class, so we access it with the `p.` object member operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call this with our pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'When we make copies of our pointers, the use count increases, but no new objects
    are constructed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'When we check any of the other copies, we get the same result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Each pointer reports the same use count.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the copies go out of scope, they are destroyed, and the use count is decremented:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Destroying a copy reduces the use count but does not destroy the managed object.
    The object is destroyed when the final copy goes out of scope and the use count
    reaches zero:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Destroying `pb` (a copy) and `p1` (the original) leaves three copies of the
    pointer (`pa`, `bc`, and `pd`), so the managed object remains.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining three pointer copies are destroyed at the end of the scope in
    which they were created. Then the object is destroyed and its memory returned
    to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shared_ptr` class is distinguished by its management of multiple pointers
    to the same managed object.
  prefs: []
  type: TYPE_NORMAL
- en: The `shared_ptr` object's copy constructor and copy assignment operator increment
    a *use counter*. The destructor decrements the use counter until it reaches zero,
    then destroys the managed object, and returns its memory to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The `shared_ptr` class manages both the managed object and a heap-allocated
    *control block*. The control block contains the use counter, along with other
    housekeeping objects. The control block is managed and shared between copies along
    with the managed object. This allows the original `shared_ptr` object to cede
    control to its copies, so that the last remaining `shared_ptr` may manage the
    object and its memory.
  prefs: []
  type: TYPE_NORMAL
- en: Use weak pointers with shared objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strictly speaking, `std::weak_ptr` is not a smart pointer. Rather, it's an *observer*
    that operates in cooperation with `shared_ptr`. A `weak_ptr` object does not hold
    a pointer on its own.
  prefs: []
  type: TYPE_NORMAL
- en: There are circumstances where `shared_ptr` objects may create dangling pointers
    or race conditions, which could lead to memory leaks or other problems. The solution
    is to use `weak_ptr` objects with `shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we examine the use of `std::weak_ptr` with `std::shared_ptr`,
    using a demonstration class that prints when its constructors and destructor are
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the same class we''ve used to demonstrate `shared_ptr` and `unique_ptr`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class has a default constructor, a parameterized constructor, and a destructor.
    Each of these has a simple print statement to tell us what was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a function to examine a `weak_ptr` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `weak_ptr` does not operate as a pointer on its own; it requires the use of
    a `shared_ptr`. The `lock()` function returns a `shared_ptr` object, which can
    then be used to access the managed object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `weak_ptr` requires an associated `shared_ptr`, we''ll start `main()`
    by creating a `shared_ptr<Thing>` object. When we create a `weak_ptr` object without
    assigning the `shared_ptr`, the `expired` flag is initially set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The `make_shared()` function allocates memory and constructs a `Thing` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `weak_ptr<Thing>` declaration constructs a `weak_ptr` object without assigning
    a `shared_ptr`. So, when we check the `expired` flag, it's `true`, indicating
    that there is no associated `shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_weak_thing()` function is not able to obtain a lock because there is
    no `shared_ptr` available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we assign the `shared_ptr` to the `weak_ptr`, we can use the `weak_ptr`
    to access the managed object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The `get_weak_thing()` function is now able to obtain a lock and access the
    managed object. The `lock()` method returns a `shared_ptr`, and the `use_count()`
    reflects the fact that there is now a second `shared_ptr` managing the `Thing`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The new `shared_ptr` is destroyed at the end of the `get_weak_thing()` scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `weak_ptr` class has a constructor that takes a `shared_ptr` for one-step
    construction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The `use_count()` is `2` again. Remember that the previous `shared_ptr` was
    destroyed when its enclosing `get_weak_thing()` scope ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we reset `shared_ptr`, its associated `weak_ptr` objects are expired:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: After the `reset()`, the use count reaches zero, and the managed object is destroyed
    and the memory released.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `weak_ptr` object is an *observer* that holds a non-owning reference to a
    `shared_ptr` object. The `weak_ptr` observes the `shared_ptr` so that it knows
    when the managed object is, and is not, available. This allows use of a `shared_ptr`
    in circumstances where you may not always know if the managed object is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `weak_ptr` class has a `use_count()` function that returns the use count
    of `shared_ptr`, or `0` if the managed object has been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '`weak_ptr` also has an `expired()` function that reports if the managed object
    has been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lock()` function is the preferred way to access the shared pointer. It
    checks `expired()` to see if the managed object is available. If so, it returns
    a new `shared_ptr` that shares ownership with the managed object. Otherwise, it
    returns an empty `shared_ptr`. It does all that as one atomic operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One important use case for `weak_ptr` is when there''s a possibility of circular
    references to `shared_ptr` objects. For example, consider the case of two classes
    that link to each other (perhaps in a hierarchy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'We have print statements in the destructors, so we can see when the objects
    are destroyed. We can now create two objects that point at each other with `shared_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, notice that the destructors are never called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Because the objects maintain shared pointers that refer to each other, the use
    counts never reach zero, and the managed objects are never destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can resolve this problem by changing one of the classes to use a `weak_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in `main()` remains the same, and we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: By changing one `shared_ptr` to a `weak_ptr`, we have resolved the circular
    reference, and the objects are now properly destroyed at the end of their scope.
  prefs: []
  type: TYPE_NORMAL
- en: Share members of a managed object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::shared_ptr` class provides an *aliasing constructor* to share a pointer
    managed by another unrelated pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: This returns an aliased `shared_ptr` object that uses the resources of `ref`
    but returns a pointer to `ptr`. The `use_count` is shared with ref. The deleter
    is shared with `ref`. But `get()` returns `ptr`. This allows us to share a member
    of a managed object without sharing the entire object, and without allowing the
    entire object to be deleted while we're still using the member.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we create a managed object and share members of that object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a class for the managed object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class has two members, `string` types for `name` and `sound` of the `animal`
    object. We also have print statements for the constructor and the destructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a function to create an animal but only share its name and sound:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function creates `shared_ptr` with an `animal` object, constructed with
    a name and a sound. We then create aliased `shared_ptr` objects for the name and
    sound. When we return the `name` and `sound` pointers, the `animal` pointer goes
    out of scope. It is not deleted because the aliased pointers keep the use count
    from reaching zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function, we call `make_animal()` and inspect the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the aliased pointers each show a `use_count` of `2`. When the
    `make_animal()` function creates the aliased pointers, they each increase the
    use count of the `animal` pointer. When the function ends, the `animal` pointer
    goes out of scope, leaving its use count at 2, which is reflected in the aliased
    pointers. The aliased pointers go out of scope at the end of `main()`, which allows
    the `animal` pointer to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *aliased* shared pointer seems a bit abstract, but it's simpler than it
    appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shared pointer uses a *control block* to manage its resources. One control
    block is associated with one managed object and is shared among the pointers that
    share that object. The control block generally contains:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the managed object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *deleter*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *allocator*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of `shared_ptr` objects that own the managed object (this is the
    *use count*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of `weak_ptr` objects that refer to the managed object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of an aliased shared pointer, the control block includes the pointer
    to the *aliased object*. Everything else remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Aliased shared pointers participate in the use count, just like non-aliased
    shared pointers, preventing the managed object from being destroyed until the
    use count reaches zero. The deleter is not changed, so it destroys the managed
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use any pointer to construct an aliased shared pointer. Usually,
    the pointer refers to a member within the aliased object. If the aliased pointer
    does not refer to an element of the managed object, you will need to manage its
    construction and destruction separately.
  prefs: []
  type: TYPE_NORMAL
- en: Compare random number engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `random` library provides a selection of random number generators, each
    with different strategies and properties. In this recipe, we examine a function
    to compare the different options by creating a histogram of their output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we compare the different random number generators provided
    by the C++ `random` library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with some constants to provide uniform parameters for the random number
    generators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`n_samples` is the number of samples to examine, `n_partitions` is the number
    of partitions in which to display the samples, and `n_max` is the maximum size
    of a bar in the histogram (this will vary some due to rounding).'
  prefs: []
  type: TYPE_NORMAL
- en: These numbers provide a reasonable display of the differences between the engines.
    Increasing the ratio of *samples* versus *partitions* tends to smooth out the
    curves and obscure the differences between the engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the function that collects random number samples and displays a histogram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a nutshell, this function stores a histogram of collected samples in a `vector`.
    It then displays the histogram as a series of asterisks on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `histogram()` from `main()`, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A screenshot of output from the first two random number engines'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – A screenshot of output from the first two random number engines
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows histograms of the first two random number engines. Your
    output will vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we raise the value of `n_samples` to 100,000, you''ll see that the variance
    between engines becomes more difficult to discern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A screenshot of output with 100,000 samples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – A screenshot of output with 100,000 samples
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the random number engines has a functor interface that returns the
    next random number in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The functor returns a random value, evenly distributed between the `min()` and
    `max()` values. All the random number engines have this interface in common.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `histogram()` function takes advantage of this uniformity by using the
    class of the random number engine in a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: (**RNG** is a common abbreviation for **Random Number Generator**. The library
    documentation refers to these classes as *engines*, which is synonymous with RNG
    for our purposes.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We instantiate an object with the RNG class and create a histogram in a `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to easily compare the results of the various random number engines
    with this technique.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the random number engines in the library have different methodologies
    and characteristics. When you run the histogram multiple times, you'll notice
    that most of the engines have the same distribution each time they're run. That's
    because they are *deterministic* – that is, they generate the same sequence of
    numbers each time. `std::random_device` is non-deterministic on most systems.
    You can use it to seed one of the other engines if you need more variation. It
    is also common to seed an RNG with the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::default_random_engine` is a suitable choice for most purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Compare random number distribution generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Standard Library provides a selection of random number distribution
    generators, each with its own properties. In this recipe, we examine a function
    to compare the different options by creating a histogram of their output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the random number engines, the distribution generators have some common
    interface elements. Unlike the random number engines, the distribution generators
    have a variety of properties to set. We can create a template function to print
    a histogram of the various distributions, but the initializations of the various
    distribution generators vary significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with some constants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `n_samples` constant is the number of samples to generate for each histogram
    – in this case, 10,000\.
  prefs: []
  type: TYPE_NORMAL
- en: The `n_max` constant is used as a divisor while generating our histograms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our histogram function takes a distribution generator as an argument and prints
    a histogram for that distribution algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `dist_histogram()` function uses a `map` to store the histogram. It then
    displays the histogram as a series of asterisks on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `dist_histogram()` from `main()`, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calling the `dist_histogram()` function is more complex than it was for the
    random number generators. Each random distribution class has a different set of
    parameters, according to its algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For the full list, refer to the `distribution.cpp` file in the GitHub archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – A screenshot of random distribution histograms'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – A screenshot of random distribution histograms
  prefs: []
  type: TYPE_NORMAL
- en: Each of the distribution algorithms produces very different output. You will
    want to experiment with the different options for each random distribution generator.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the distribution generators has a functor that returns the next value
    in the random distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The functor takes a random number generator (RNG) object as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: For our purposes, we're using the `std::default_random_engine` for our RNG.
  prefs: []
  type: TYPE_NORMAL
- en: As with the RNG histogram, this is a useful tool to visualize the various random
    distribution algorithms available in the `random` library. You will want to experiment
    with the various parameters available for each algorithm.
  prefs: []
  type: TYPE_NORMAL
