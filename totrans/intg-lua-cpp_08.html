<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-175"><a id="_idTextAnchor177"/>8</h1>
<h1 id="_idParaDest-176"><a id="_idTextAnchor178"/>Abstracting a C++ Type Exporter</h1>
<p>In the previous chapter, we learned how to export a C++ class to Lua as a user-defined type. An instance of the class is exported to Lua to serve as the prototype for <span class="No-Break">the type.</span></p>
<p>The exercise from the previous chapter required you to create a factory class for the type. However, with that requirement, each type needs its own <span class="No-Break">factory class.</span></p>
<p>In this chapter, we will learn how to implement a general C++ type exporter so that you can use it as the factory class for any C++ type, without redoing <span class="No-Break">the work.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Reviewing the <span class="No-Break">factory implementation</span></li>
<li>Designing a <span class="No-Break">type exporter</span></li>
<li>Stubbing the <span class="No-Break">type exporter</span></li>
<li><span class="No-Break">Defining </span><span class="No-Break"><strong class="source-inline">LuaModuleDef</strong></span></li>
<li><span class="No-Break">Re-implementing </span><span class="No-Break"><strong class="source-inline">luaNew</strong></span></li>
<li>Are you <span class="No-Break">flexible enough?</span></li>
</ul>
<h1 id="_idParaDest-177"><a id="_idTextAnchor179"/>Technical requirements</h1>
<p>You can access the source code for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor180"/>Reviewing the factory implementation</h1>
<p>We will review the<a id="_idIndexMarker358"/> exercise from the previous chapter. The solution this book has adopted requires progressive and minimal changes. It also leads naturally to the feature covered in <span class="No-Break">this chapter.</span></p>
<p>If you have not implemented your own solution and are willing to stop here for a moment, this is another chance to give it a shot. Many technologies are simple in explanation but hard to grasp. The best way to understand them is to review and practice them, hands-on, again <a id="_idIndexMarker359"/>and again until you get an "<span class="No-Break">aha" moment.</span></p>
<p>Now, we will review a solution. The focus is on the changes and <span class="No-Break">key concepts.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor181"/>Defining the factory</h2>
<p>To make a factory, we<a id="_idIndexMarker360"/> only need to change <strong class="source-inline">Destinations.h</strong> and <strong class="source-inline">Destinations.cc</strong>. In your preferred IDE, you can open the <strong class="source-inline">end</strong> project for <span class="No-Break"><em class="italic">Chapter 7</em></span> and the <strong class="source-inline">begin</strong> project for this chapter to check <span class="No-Break">the differences.</span></p>
<p>Let us first look at the header file for the factory class declaration. You can find the following declarations in <strong class="source-inline">Destinations.h</strong> in the <strong class="source-inline">begin</strong> project for <span class="No-Break">this chapter:</span></p>
<pre class="source-code">
class Destinations
{
public:
    Destinations();
    ~Destinations();
    void wish(const std::vector&lt;std::string&gt; &amp;places);
    void went(const std::vector&lt;std::string&gt; &amp;places);
    std::vector&lt;std::string&gt; listVisited() const;
    std::vector&lt;std::string&gt; listUnvisited() const;
private:
    std::map&lt;std::string, bool&gt; wishlist;
};
class DestinationsFactory : public LuaModule
{
public:
    const std::string &amp;luaName() const override;
    const std::vector&lt;luaL_Reg&gt; &amp;
    luaRegs() const override;
};</pre>
<p>The change from the previous chapter is that we are creating a factory class named <strong class="source-inline">DestinationsFactory</strong>, which implements the <strong class="source-inline">LuaModule</strong> interface. In fact, we are moving the <strong class="source-inline">LuaModule</strong> implementation from <strong class="source-inline">Destinations</strong> to <strong class="source-inline">DestinationsFactory</strong> so that the <strong class="source-inline">Destinations</strong> type does not know anything about Lua. This is one of the benefits of a factory class. The system can be <span class="No-Break">better layered.</span></p>
<p class="callout-heading">Did you know?</p>
<p class="callout">If you use Linux or Mac, you can also<a id="_idIndexMarker361"/> use the <strong class="bold">diff</strong> program to check the differences between two files. In a <a id="_idIndexMarker362"/>terminal, type the following command to see what we have changed – <strong class="source-inline">diff </strong><span class="No-Break"><strong class="source-inline">Chapter07/end/Destinations.h Chapter08/begin/Destinations.h</strong></span><span class="No-Break">.</span></p>
<p>Next, we will review the <span class="No-Break">factory implementation.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor182"/>Implementing the factory</h2>
<p>The factory only <a id="_idIndexMarker363"/>has two member functions, which are implemented <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const std::string &amp;
DestinationsFactory::luaName() const
{
    return NAME;
}
const std::vector&lt;luaL_Reg&gt; &amp;
DestinationsFactory::luaRegs() const
{
    return FACTORY_REGS;
}</pre>
<p>Now, instead of <strong class="source-inline">REGS</strong>, <strong class="source-inline">luaRegs</strong> returns <strong class="source-inline">FACTORY_REGS</strong>, which is defined <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const std::vector&lt;luaL_Reg&gt; FACTORY_REGS = {
    {"new", luaNew},
    {NULL, NULL}};</pre>
<p>This means, now, we only export a single function, <strong class="source-inline">luaNew</strong>, <span class="No-Break">to Lua.</span></p>
<p>As explained in <span class="No-Break"><em class="italic">Chapter 6</em></span>, the Lua library expects the last entry to be <strong class="source-inline">{NULL, NULL}</strong> to mark the end of the array. This is a typical technique for C-based libraries because they usually get a pointer to an item as the input for an array and need to figure out where the <span class="No-Break">array ends.</span></p>
<p>Also, delete <strong class="source-inline">luaNew</strong> from <strong class="source-inline">REGS</strong> so <a id="_idIndexMarker364"/>that it looks like the <span class="No-Break">following list:</span></p>
<pre class="source-code">
const std::vector&lt;luaL_Reg&gt; REGS = {
    {"wish", luaWish},
    {"went", luaWent},
    {"list_visited", luaListVisited},
    {"list_unvisited", luaListUnvisited},
    {NULL, NULL}};</pre>
<p>Previously, <strong class="source-inline">REGS</strong> served <span class="No-Break">two purposes:</span></p>
<ul>
<li>The <strong class="source-inline">__index</strong> metatable for new instances created from Lua. This is done in <strong class="source-inline">luaNew</strong> with <strong class="source-inline">luaL_setfuncs(L, </strong><span class="No-Break"><strong class="source-inline">REGS.data(), 0)</strong></span><span class="No-Break">.</span></li>
<li>The registered Lua module, which is a plain Lua table. This is done with a call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">LuaExecutor::registerModule</strong></span><span class="No-Break">.</span></li>
</ul>
<p>Now, <strong class="source-inline">REGS</strong> only serves the first purpose and gives the second responsibility to <strong class="source-inline">FACTORY_REGS</strong>. This is yet another <span class="No-Break">structural improvement.</span></p>
<p>These are all the changes we need to create a factory. You can read the complete source code that you get from GitHub. However, there is not much code change, right? We were just moving things around, and we now have a different <span class="No-Break">object-creation mechanism.</span></p>
<p>Now, based on this factory concept, we are ready to move on to the main focus of this chapter. From now<a id="_idIndexMarker365"/> on, you can use the <strong class="source-inline">begin</strong> project as the basis for development. Let us start to design a general C++ <span class="No-Break">type exporter.</span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor183"/>Designing a type exporter</h1>
<p>First, let us define our<a id="_idIndexMarker366"/> scope. We want to generalize the factory we have just made and make it work with any C++ class – that is, the C++ class still needs to implement and provide the <strong class="source-inline">lua_CFunction</strong> wrappers in some way. It is possible to automate the creation of those wrappers, but that would require implementing a heavy C++ template library, which is not strictly related to Lua and is out of the scope of <span class="No-Break">this book.</span></p>
<p>With the scope defined, let us make some <span class="No-Break">high-level designs.</span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor184"/>Choosing a design pattern</h2>
<p>When we talk about <a id="_idIndexMarker367"/>making something <em class="italic">general</em> in C++, usually it<a id="_idIndexMarker368"/> means we need to use templates. To work with our Lua executor, we need to export <strong class="source-inline">LuaModule</strong>. So, we need to implement the exporter as a template class that can <span class="No-Break">provide </span><span class="No-Break"><strong class="source-inline">LuaModule</strong></span><span class="No-Break">.</span></p>
<p>How can we provide <strong class="source-inline">LuaModule</strong>? We can make the exporter inherit from the <strong class="source-inline">LuaModule</strong> interface, or make one of its member functions <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">LuaModule</strong></span><span class="No-Break">.</span></p>
<p>One of the popular design patterns for the latter <a id="_idIndexMarker369"/>option is the <strong class="bold">Builder</strong> pattern. This can be demonstrated with the <span class="No-Break">following pseudo-code:</span></p>
<pre class="source-code">
class LuaModuleBuilder
{
    LuaModuleBuilder withOptionA(...);
    LuaModuleBuilder withOptionB(...);
    ...
    LuaModule build();
};
LuaModuleBuilder builder;
auto module = builder.withOptionX(...).build();</pre>
<p>A builder usually has many functions to customize different properties for the thing it creates, alongside a <strong class="source-inline">build</strong> function to create the <span class="No-Break">final object.</span></p>
<p>Since our goal is to help with object creation alone, like in the factory exercise, and not to customize the object, the <em class="italic">Builder</em> pattern is overkill. We will choose the vanilla C++ inheritance. The exporter type can be defined <span class="No-Break">as follows:</span></p>
<pre class="source-code">
template &lt;typename T&gt;
class LuaModuleExporter : public LuaModule;</pre>
<p>This is <a id="_idIndexMarker370"/>a template <a id="_idIndexMarker371"/>class. It will export C++ type <strong class="source-inline">T</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">LuaModule</strong></span><span class="No-Break">.</span></p>
<p>Now, let us stub <span class="No-Break">the exporter.</span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor185"/>Stubbing the exporter</h1>
<p>We have two major<a id="_idIndexMarker372"/> considerations for the design of the exporter. First, it is <strong class="source-inline">LuaModule</strong>, so it needs to implement its pure virtual functions. Second, we want it to resemble what we implemented in the factory exercise, which means we have a pretty good idea of what to return in the <strong class="source-inline">luaRegs</strong> virtual <span class="No-Break">function implementation.</span></p>
<p>Let us get started. Add a new file named <strong class="source-inline">LuaModuleExporter.hpp</strong> and define the <strong class="source-inline">LuaModuleExporter</strong> class, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
template &lt;typename T&gt;
class LuaModuleExporter final : public LuaModule
{
public:
    LuaModuleExporter(
        const LuaModuleExporter &amp;) = delete;
    ~LuaModuleExporter() = default;
    static LuaModuleExporter&lt;T&gt; make()
    {
        return LuaModuleExporter&lt;T&gt;();
    }
private:
    LuaModuleExporter() {}
};</pre>
<p>This makes the exporter a final class and prevents it from being copy-constructed. Because the purpose of the exporter is to provide <strong class="source-inline">LuaModule</strong> and we do not have logic for it to get passed around by value, adding some restrictions can prevent bugs in the future. We achieve this by assigning the <strong class="source-inline">delete</strong> keyword to the copy constructor. We also want to <a id="_idIndexMarker373"/>control the object creation, so we make the constructor private. This has another effect – you cannot use <strong class="source-inline">new operator</strong> to create instances of <span class="No-Break">the class.</span></p>
<p>Now, add the implementation for <strong class="source-inline">LuaModule</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaModuleExporter final : public LuaModule
{
public:
    const std::string &amp;luaName() const override
    {
        return name;
    }
    const std::vector&lt;luaL_Reg&gt; &amp;luaRegs() const override
    {
        return factoryRegs;
    }
private:
    const std::string name = "TODO";
    const std::vector&lt;luaL_Reg&gt; factoryRegs = {
        {"new", luaNew},
        {NULL, NULL}};
    static int luaNew(lua_State *L)
    {
        return 0;
    }
};</pre>
<p>This is straightforward. On the Lua module level, we only want to export one function to create concrete objects. So, we will only register <strong class="source-inline">luaNew</strong>. The name of the module needs to be passed in. We will find a way when we implement <span class="No-Break">the details.</span></p>
<p>Thus, we have a <a id="_idIndexMarker374"/>stub for our exporter. This is a system-level design contract. Now, let us write the test code to see how it should <span class="No-Break">be used.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor186"/>Preparing the C++ test code</h2>
<p>In <strong class="source-inline">main.cpp</strong>, write <a id="_idIndexMarker375"/>the <strong class="source-inline">main</strong> function<a id="_idIndexMarker376"/> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    auto module = LuaModuleExporter&lt;
        Destinations&gt;::make();
    lua-&gt;registerModule(module);
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>Compared with the previous chapter, the only difference is how <strong class="source-inline">LuaModule</strong> is created. Now, it is created <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuaModuleExporter&lt;Destinations&gt;::make()</strong></span><span class="No-Break">.</span></p>
<p>At this point, the project should compile. When you run it, it should not crash on the C++ side; although, at <a id="_idIndexMarker377"/>this stage, it will not be able to do anything<a id="_idIndexMarker378"/> meaningful, and you should see an error message <span class="No-Break">from Lua.</span></p>
<p>Now, we will see what Lua code <span class="No-Break">we need.</span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor187"/>Preparing the Lua test script</h2>
<p>Write <strong class="source-inline">script.lua</strong> exactly <a id="_idIndexMarker379"/><span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker380"/></span><span class="No-Break">follows:</span></p>
<pre class="source-code">
dst = Destinations.new()
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())</pre>
<p>We used this code snippet in the previous chapter. This will help to validate whether we will get the same result later in <span class="No-Break">this chapter.</span></p>
<p>Next, let us start to make the <span class="No-Break">exporter work.</span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor188"/>Defining LuaModuleDef</h1>
<p>First, we need to<a id="_idIndexMarker381"/> provide the name of the module and then the <strong class="source-inline">__index</strong> metatable. Finally, we need to provide a name for the metatable. Recall that in <strong class="source-inline">Destinations.cc</strong>, the name of the metatable is hardcoded <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const std::string METATABLE_NAME(
    "Destinations.Metatable");</pre>
<p>Now, this needs to be passed to the exporter. Let us define a structure for the aforementioned three pieces of information. In <strong class="source-inline">LuaModule.h</strong>, add the <span class="No-Break">following declaration:</span></p>
<pre class="source-code">
template &lt;typename T&gt;
struct LuaModuleDef
{
    const std::string moduleName;
    const std::vector&lt;luaL_Reg&gt; moduleRegs;
    const std::string metatableName() const
    {
        return std::string(moduleName)
            .append(".Metatable");
    }
};</pre>
<p>This defines <strong class="source-inline">moduleName</strong> and <strong class="source-inline">moduleRegs</strong>. The metatable name is based on the module name, with <strong class="source-inline">".Metatable"</strong> appended <span class="No-Break">to it.</span></p>
<p>Note that this structure is also templated. This indicates that a definition is for a certain C++ type. We will use the template later in <span class="No-Break">this chapter.</span></p>
<p>Now, we can pass this structure to <span class="No-Break">the exporter.</span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor189"/>Using LuaModuleDef</h2>
<p>In <strong class="source-inline">LuaModuleExporter.hpp</strong>, accept <a id="_idIndexMarker382"/>an instance of <strong class="source-inline">LuaModuleDef</strong> during exporter creation. Rewrite the related code <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaModuleExporter final : public LuaModule
{
public:
    static LuaModuleExporter&lt;T&gt; make(
        const LuaModuleDef&lt;T&gt; &amp;luaModuleDef)
    {
        return LuaModuleExporter&lt;T&gt;(luaModuleDef);
    }
    const std::string &amp;luaName() const override
    {
        return luaModuleDef.moduleName;
    }
private:
    LuaModuleExporter(
        const LuaModuleDef&lt;T&gt; &amp;luaModuleDef)
        : luaModuleDef(luaModuleDef) {}
    const LuaModuleDef&lt;T&gt; luaModuleDef;
};</pre>
<p>The changes are <span class="No-Break">as follows:</span></p>
<ul>
<li>We added a private member <span class="No-Break">variable, </span><span class="No-Break"><strong class="source-inline">luaModuleDef</strong></span></li>
<li>We added an argument of type <strong class="source-inline">LuaModuleDef</strong> to <strong class="source-inline">make</strong> and the <span class="No-Break">private constructor</span></li>
<li>We changed <strong class="source-inline">luaName</strong> to <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">luaModuleDef.moduleName</strong></span></li>
<li>We deleted the private member variable, <strong class="source-inline">name</strong>, introduced <span class="No-Break">during stubbing</span></li>
</ul>
<p>Now, we can define <strong class="source-inline">LuaModuleDef</strong> for the <span class="No-Break"><strong class="source-inline">Destinations</strong></span><span class="No-Break"> class.</span></p>
<p>In <strong class="source-inline">Destinations.h</strong>, delete the declaration for <strong class="source-inline">DestinationsFactory</strong> and add the <span class="No-Break">following code:</span></p>
<pre class="source-code">
struct DestinationsLuaModuleDef
{
    static LuaModuleDef&lt;Destinations&gt; def;
};</pre>
<p>In <strong class="source-inline">Destinations.cpp</strong>, delete <a id="_idIndexMarker383"/>all implementations for <strong class="source-inline">DestinationsFactory</strong> and add the following code after the <span class="No-Break">anonymous namespace:</span></p>
<pre class="source-code">
LuaModuleDef DestinationsLuaModuleDef::def =
    LuaModuleDef&lt;Destinations&gt;{
        "Destinations",
        {{"wish", luaWish},
         {"went", luaWent},
         {"list_visited", luaListVisited},
         {"list_unvisited", luaListUnvisited},
         {NULL, NULL}},
    };</pre>
<p>Finally, in <strong class="source-inline">main.cpp</strong>, change the module creation code to the <span class="No-Break">following statement:</span></p>
<pre class="source-code">
auto module = LuaModuleExporter&lt;Destinations&gt;::make(
    DestinationsLuaModuleDef::def);</pre>
<p>This pumps <strong class="source-inline">LuaModuleDef</strong> for the <strong class="source-inline">Destinations</strong> class into the exporter. Make sure that the project<a id="_idIndexMarker384"/> <span class="No-Break">can compile.</span></p>
<p>Now, we will fill in the rest of the missing pieces to make the exporter <span class="No-Break">really work.</span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor190"/>Re-implementing luaNew</h1>
<p>Because we<a id="_idIndexMarker385"/> will store <strong class="source-inline">LuaModuleDef</strong> in <strong class="source-inline">LuaModuleExporter</strong>, to access it, we need to find the instance of <strong class="source-inline">LuaModuleExporter</strong>. Let us first implement a helper function <span class="No-Break">for this.</span></p>
<p>Since the exporter is also <strong class="source-inline">LuaModule</strong>, it already has an upvalue mechanism, implemented in <span class="No-Break"><em class="italic">Chapter 6</em></span>. <strong class="source-inline">LuaModule::pushLuaUpvalues</strong> will push the pointer to the <strong class="source-inline">LuaModule</strong> instance as an upvalue. To retrieve it, we can add the <span class="No-Break">following function:</span></p>
<pre class="source-code">
class LuaModuleExporter final : public LuaModule
{
private:
    static LuaModuleExporter&lt;T&gt; *getExporter(
        lua_State *L)
    {
        return reinterpret_cast&lt;LuaModuleExporter&lt;T&gt; *&gt;(
            lua_touserdata(L, lua_upvalueindex(1)));
    }
};</pre>
<p>This is the same as the <strong class="source-inline">getObj</strong> function in <span class="No-Break"><em class="italic">Chapter 6</em></span>, but now, it is a static <span class="No-Break">member function.</span></p>
<p>With a way to access the exporter instance from the static member functions, we can write <strong class="source-inline">LuaModuleExporter::luaNew</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    <strong class="bold">auto luaModuleDef = getExporter(L)-&gt;luaModuleDef;</strong>
    T *obj = new T();
    T **userdata = reinterpret_cast&lt;T **&gt;(
        lua_newuserdatauv(L, sizeof(obj), 0));
    *userdata = obj;
    <strong class="bold">auto metatableName = luaModuleDef.metatableName();</strong>
    int type = luaL_getmetatable(
        L, <strong class="bold">metatableName.c_str()</strong>);
    if (type == LUA_TNIL)
    {
        lua_pop(L, 1);
        luaL_newmetatable(L, metatableName.c_str());
        lua_pushvalue(L, -1);
        lua_setfield(L, -2, "__index");
        luaL_setfuncs(
            L, <strong class="bold">luaModuleDef.moduleRegs.data()</strong>, 0);
        lua_pushcfunction(L, luaDelete);
        lua_setfield(L, -2, "__gc");
    }
    lua_setmetatable(L, 1);
    return 1;
}</pre>
<p>This is actually copied from <strong class="source-inline">Destinations.cc</strong>. The changes, besides using <strong class="source-inline">T</strong> <strong class="source-inline">typename</strong> instead of the hardcoded class name, are highlighted in the preceding code. You can see that they are all about <span class="No-Break">pumping </span><span class="No-Break"><strong class="source-inline">LuaModuleDef</strong></span><span class="No-Break">.</span></p>
<p>If you have forgotten how <strong class="source-inline">luaNew</strong> works, you can check the previous chapter, where there are figures to show how the Lua stack changes <span class="No-Break">as well.</span></p>
<p>Finally, let us implement the stub for <strong class="source-inline">LuaModuleExporter::luaDelete</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaDelete(lua_State *L)
{
    T *obj = *reinterpret_cast&lt;T **&gt;(
        lua_touserdata(L, 1));
    delete obj;
    return 0;
}</pre>
<p><strong class="source-inline">luaDelete</strong> is<a id="_idIndexMarker386"/> registered as the <strong class="source-inline">__gc</strong> metamethod <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">luaNew</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Do you remember?</p>
<p class="callout">As explained in the previous chapter, we set <strong class="source-inline">luaDelete</strong> as the finalizer for the user data created in <strong class="source-inline">luaNew</strong>. During the Lua garbage collection process, the finalizer will be called, with an argument as the user <span class="No-Break">data reference.</span></p>
<p>You can also delete <strong class="source-inline">REGS</strong>, <strong class="source-inline">FACTORY_REGS</strong>, <strong class="source-inline">luaNew</strong>, and <strong class="source-inline">luaDelete</strong> in <strong class="source-inline">Destinations.cc</strong>. They are not <span class="No-Break">used anymore.</span></p>
<p>Now, we can test the exporter. Execute the project. If you have done everything correctly, you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
Destinations instance created: 0x12a704170
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
Destinations instance destroyed: 0x12a704170</pre>
<p>We have not really changed the test code from the previous chapter, except for how the <strong class="source-inline">Destinations</strong> class gets exported <span class="No-Break">to Lua.</span></p>
<p>If you have encountered any errors, do not feel discouraged. This is the most complex chapter in this book, and we need to implement code correctly in multiple files to make it work. Trace back your steps and fix the error. You can do it! Also, in GitHub, there are multiple checkpoint projects for this chapter, which you can refer to. As previously mentioned, we will not <a id="_idIndexMarker387"/>automate the generation of the <strong class="source-inline">lua_CFunction</strong> wrappers. Generalization also needs <span class="No-Break">a limit.</span></p>
<p>But, let us check how general our <span class="No-Break">implementation is.</span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor191"/>Are you flexible enough?</h1>
<p>To answer <a id="_idIndexMarker388"/>this<a id="_idIndexMarker389"/> question, let us rewrite <strong class="source-inline">script.lua</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
dst = Destinations.new(<strong class="bold">"Shanghai", "Tokyo"</strong>)
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())</pre>
<p>Yes, the new requirement is that, in the Lua code, when creating the <strong class="source-inline">Destinations</strong> objects, we can provide an initial list of <span class="No-Break">unvisited places.</span></p>
<p>This means that we need to support parameterized <span class="No-Break">object creation.</span></p>
<p>Can our exporter support this? This should be a common use case. </p>
<p>Now is a good time to ponder over life, get a cup of coffee, or whatever. We are almost near the end of <em class="italic">Part 3</em> of <span class="No-Break">this book.</span></p>
<p>If you recall, our object creation code is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
   ...
   T *obj = new T();
   ...
}</pre>
<p>As a seasoned C++ programmer, you may think that, because <strong class="source-inline">std::make_unique&lt;T&gt;</strong> can forward its arguments to the constructor of <strong class="source-inline">T</strong>, there must be a way to make <strong class="source-inline">LuaModuleExporter&lt;T&gt;::make</strong> do the same. Right, but the magic of <strong class="source-inline">std::make_unique&lt;T&gt;</strong> is at C++ compile time. So, how would you handle that when the arguments are passed in Lua code after the C++ code has <span class="No-Break">been compiled?</span></p>
<p>Worry not. Let us explore<a id="_idIndexMarker390"/> the <strong class="bold">factory method</strong> design pattern. A factory method is a contract defined as a method or an interface to create and return an object. However, how the object is created is not important and not part of <span class="No-Break">the contract.</span></p>
<p>To see how<a id="_idIndexMarker391"/> it <a id="_idIndexMarker392"/>works, let us implement one for <strong class="source-inline">LuaModuleDef</strong>. Add another member variable, named <strong class="source-inline">createInstance</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
struct LuaModuleDef
{
    const std::function&lt;T *(lua_State *)&gt;
    createInstance =
    [](lua_State *) -&gt; T* { return new T(); };
};</pre>
<p>This is a bit of advanced C++ usage. Therefore, it is important that you take the following <span class="No-Break">into account:</span></p>
<ul>
<li><strong class="source-inline">createInstance</strong> is declared as a member variable but not as a member function. This is because you can simply assign the member variable a different value during object construction to achieve a different behavior, but with a member function, you need to create a subclass to override the behavior. <em class="italic">We should prefer composition over inheritance whenever </em><span class="No-Break"><em class="italic">we can.</em></span></li>
<li><strong class="source-inline">createInstance</strong> is of type <strong class="source-inline">std::function</strong>. With this type, you can use the variable as if it were a function. If you are more familiar with Lua in this regard, you’ll understand that a named Lua function is also a variable. Here, we want to achieve the same effect. <strong class="source-inline">T *(lua_State *)</strong> is the type of the function. It means that the function expects one argument of type <strong class="source-inline">lua_State*</strong> and will return a pointer to type <strong class="source-inline">T</strong>. You can check the C++ reference manual to learn more <span class="No-Break">about </span><span class="No-Break"><strong class="source-inline">std::function</strong></span><span class="No-Break">.</span></li>
<li>Then, we provide a default implementation as a C++ lambda. This lambda simply creates an instance in the heap without any <span class="No-Break">constructor parameter.</span></li>
</ul>
<p>To use this factory method, change <strong class="source-inline">LuaModuleExporter::luaNew</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    ...
    T *obj = <strong class="bold">luaModuleDef.createInstance(L)</strong>;
    ...
}</pre>
<p>We have changed from new <strong class="source-inline">T()</strong> to <strong class="source-inline">luaModuleDef.createInstance(L)</strong>, and it still does the <span class="No-Break">same thing.</span></p>
<p>However, note <a id="_idIndexMarker393"/>that<a id="_idIndexMarker394"/> we no longer create the object <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaModuleExporter</strong></span><span class="No-Break">.</span></p>
<p>Finally, to answer the question, yes, we are <span class="No-Break">flexible enough.</span></p>
<p class="callout-heading">On modern C++</p>
<p class="callout">In 1998, C++ was<a id="_idIndexMarker395"/> standardized for the first time as C++98. It saw little change until 2011, with C++11. Since then, C++ has quickly adopted modern programming techniques in language specification. Lambdas and <strong class="source-inline">std::function</strong> are just two of the many examples. If you know some other languages (for example, Java), you can make some analogies (lamdba and functional interface), although the syntaxes are different. I implemented <strong class="source-inline">LuaModuleDef</strong> this way instead of using a more traditional method to show you some examples of modern C++ features. This is the future, and I encourage you to explore modern C++ in more detail. People working with Java, Kotlin, and Swift use such techniques by default. You can play an important role here by adopting these new techniques and helping C++ to <span class="No-Break">catch up.</span></p>
<p>In <strong class="source-inline">Destinations.cc</strong>, change the <strong class="source-inline">LuaModuleDef</strong> instance <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaModuleDef DestinationsLuaModuleDef::def =
LuaModuleDef&lt;Destinations&gt;{
    "Destinations",
    {{"wish", luaWish},
     ...
     {NULL, NULL}},
    [](lua_State *L) -&gt; Destinations *
    {
        Destinations *obj = new Destinations();
        std::vector&lt;std::string&gt; places;
        int nArgs = lua_gettop(L);
        for (int i = 1; i &lt;= nArgs; i++)
        {
            places.push_back(lua_tostring(L, i));
        }
        obj-&gt;wish(places);
        return obj;
    },
};</pre>
<p>This initializes the <strong class="source-inline">createInstance</strong> field with <a id="_idIndexMarker396"/>the<a id="_idIndexMarker397"/> provided lambda, rather than the default lambda. The new lambda does similar things to the <strong class="source-inline">luaWish</strong> wrapper. The beauty of this is that you have full control over this lambda. You can create another constructor for the <strong class="source-inline">Destinations</strong> class and simply invoke the <span class="No-Break">new constructor.</span></p>
<p>We can test the project with the new Lua script. You should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
Destinations instance created: 0x142004170
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London <strong class="bold">Shanghai Tokyo</strong>
Destinations instance destroyed: 0x142004170</pre>
<p>As you can see, <strong class="source-inline">Shanghai</strong> and <strong class="source-inline">Tokyo</strong> have<a id="_idIndexMarker398"/> been <a id="_idIndexMarker399"/>added to the <span class="No-Break">unvisited list.</span></p>
<p class="callout-heading">Even further design improvement</p>
<p class="callout">We are creating objects in <strong class="source-inline">LuaModuleDef</strong> but destroying them in <strong class="source-inline">LuaModuleExporter</strong>, and our use case does not involve transferring object ownership. For a better design, the same class should destroy the objects it creates, which we will implement in the <span class="No-Break">next chapter.</span></p>
<p>This time, for real, we <span class="No-Break">have finished.</span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor192"/>Summary</h1>
<p>In this chapter, we implemented a general C++ module exporter, mainly for the object creation part. This ensures that you can implement complex object creation logic once and reuse it with many C++ classes. Also, this chapter marks the end of <em class="italic">Part 3</em>, <em class="italic">How to Call C++ </em><span class="No-Break"><em class="italic">from Lua</em></span><span class="No-Break">.</span></p>
<p>In the following chapter, we will recap the different communication mechanisms between Lua and C++ and explore <span class="No-Break">them further.</span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>Exercise</h1>
<p>This is an open exercise. You can write a new C++ class, or find one from your work in the past, and then export it to Lua with <strong class="source-inline">LuaModuleExporter</strong>. Try to provide an interesting <strong class="source-inline">createInstance</strong> implementation <span class="No-Break">as well.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer054">
<h1 id="_idParaDest-192" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor194"/>Part 4 – Advanced Topics</h1>
<p>By this point of the book, you will have learned all the common mechanisms to integrate Lua <span class="No-Break">with</span><span class="No-Break"> C++.</span></p>
<p>In this part, you will recap what you have learned, which will also serve as a source for quick reference. You will also learn how to implement a standalone C++ module that can be loaded by Lua, as a dynamic loadable library. Then, you will learn some advanced memory management techniques and how to implement multithreading <span class="No-Break">with Lua.</span></p>
<p>This part comprises the <span class="No-Break">following chapters:</span></p>
<ul>
<li><em class="italic">Chapter 9</em>, <em class="italic">Recapping Lua-C++ Communication Mechanisms</em></li>
<li><em class="italic">Chapter 10</em>, <em class="italic">Managing Resources</em></li>
<li><em class="italic">Chapter 11</em>, <em class="italic">Multithreading with Lua</em></li>
</ul>
</div>
<div>
<div id="_idContainer055">
</div>
</div>
<div>
<div id="_idContainer056">
</div>
</div>
<div>
<div id="_idContainer057">
</div>
</div>
<div>
<div id="_idContainer058">
</div>
</div>
<div>
<div id="_idContainer059">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer060">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer061">
</div>
</div>
<div>
<div id="_idContainer062">
</div>
</div>
<div>
<div id="_idContainer063">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer064">
</div>
</div>
</div></body></html>