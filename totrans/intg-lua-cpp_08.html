<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-175"><a id="_idTextAnchor177"/>8</h1>
<h1 id="_idParaDest-176"><a id="_idTextAnchor178"/>Abstracting a C++ Type Exporter</h1>
<p>In the previous chapter, we learned how to export a C++ class to Lua as a user-defined type. An instance of the class is exported to Lua to serve as the prototype for the type.</p>
<p>The exercise from the previous chapter required you to create a factory class for the type. However, with that requirement, each type needs its own factory class.</p>
<p>In this chapter, we will learn how to implement a general C++ type exporter so that you can use it as the factory class for any C++ type, without redoing the work.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Reviewing the factory implementation</li>
<li>Designing a type exporter</li>
<li>Stubbing the type exporter</li>
<li>Defining <code>LuaModuleDef</code></li>
<li>Re-implementing <code>luaNew</code></li>
<li>Are you flexible enough?</li>
</ul>
<h1 id="_idParaDest-177"><a id="_idTextAnchor179"/>Technical requirements</h1>
<p>You can access the source code for this chapter here: <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08</a>.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor180"/>Reviewing the factory implementation</h1>
<p>We will review the<a id="_idIndexMarker358"/> exercise from the previous chapter. The solution this book has adopted requires progressive and minimal changes. It also leads naturally to the feature covered in this chapter.</p>
<p>If you have not implemented your own solution and are willing to stop here for a moment, this is another chance to give it a shot. Many technologies are simple in explanation but hard to grasp. The best way to understand them is to review and practice them, hands-on, again <a id="_idIndexMarker359"/>and again until you get an "aha" moment.</p>
<p>Now, we will review a solution. The focus is on the changes and key concepts.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor181"/>Defining the factory</h2>
<p>To make a factory, we<a id="_idIndexMarker360"/> only need to change <code>Destinations.h</code> and <code>Destinations.cc</code>. In your preferred IDE, you can open the <code>end</code> project for <em class="italic">Chapter 7</em> and the <code>begin</code> project for this chapter to check the differences.</p>
<p>Let us first look at the header file for the factory class declaration. You can find the following declarations in <code>Destinations.h</code> in the <code>begin</code> project for this chapter:</p>
<pre class="source-code">
class Destinations
{
public:
    Destinations();
    ~Destinations();
    void wish(const std::vector&lt;std::string&gt; &amp;places);
    void went(const std::vector&lt;std::string&gt; &amp;places);
    std::vector&lt;std::string&gt; listVisited() const;
    std::vector&lt;std::string&gt; listUnvisited() const;
private:
    std::map&lt;std::string, bool&gt; wishlist;
};
class DestinationsFactory : public LuaModule
{
public:
    const std::string &amp;luaName() const override;
    const std::vector&lt;luaL_Reg&gt; &amp;
    luaRegs() const override;
};</pre>
<p>The change from the previous chapter is that we are creating a factory class named <code>DestinationsFactory</code>, which implements the <code>LuaModule</code> interface. In fact, we are moving the <code>LuaModule</code> implementation from <code>Destinations</code> to <code>DestinationsFactory</code> so that the <code>Destinations</code> type does not know anything about Lua. This is one of the benefits of a factory class. The system can be better layered.</p>
<p class="callout-heading">Did you know?</p>
<p class="callout">If you use Linux or Mac, you can also<a id="_idIndexMarker361"/> use the <code>diff </code><code>Chapter07/end/Destinations.h Chapter08/begin/Destinations.h</code>.</p>
<p>Next, we will review the factory implementation.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor182"/>Implementing the factory</h2>
<p>The factory only <a id="_idIndexMarker363"/>has two member functions, which are implemented as follows:</p>
<pre class="source-code">
const std::string &amp;
DestinationsFactory::luaName() const
{
    return NAME;
}
const std::vector&lt;luaL_Reg&gt; &amp;
DestinationsFactory::luaRegs() const
{
    return FACTORY_REGS;
}</pre>
<p>Now, instead of <code>REGS</code>, <code>luaRegs</code> returns <code>FACTORY_REGS</code>, which is defined as follows:</p>
<pre class="source-code">
const std::vector&lt;luaL_Reg&gt; FACTORY_REGS = {
    {"new", luaNew},
    {NULL, NULL}};</pre>
<p>This means, now, we only export a single function, <code>luaNew</code>, to Lua.</p>
<p>As explained in <em class="italic">Chapter 6</em>, the Lua library expects the last entry to be <code>{NULL, NULL}</code> to mark the end of the array. This is a typical technique for C-based libraries because they usually get a pointer to an item as the input for an array and need to figure out where the array ends.</p>
<p>Also, delete <code>luaNew</code> from <code>REGS</code> so <a id="_idIndexMarker364"/>that it looks like the following list:</p>
<pre class="source-code">
const std::vector&lt;luaL_Reg&gt; REGS = {
    {"wish", luaWish},
    {"went", luaWent},
    {"list_visited", luaListVisited},
    {"list_unvisited", luaListUnvisited},
    {NULL, NULL}};</pre>
<p>Previously, <code>REGS</code> served two purposes:</p>
<ul>
<li>The <code>__index</code> metatable for new instances created from Lua. This is done in <code>luaNew</code> with <code>luaL_setfuncs(L, </code><code>REGS.data(), 0)</code>.</li>
<li>The registered Lua module, which is a plain Lua table. This is done with a call to <code>LuaExecutor::registerModule</code>.</li>
</ul>
<p>Now, <code>REGS</code> only serves the first purpose and gives the second responsibility to <code>FACTORY_REGS</code>. This is yet another structural improvement.</p>
<p>These are all the changes we need to create a factory. You can read the complete source code that you get from GitHub. However, there is not much code change, right? We were just moving things around, and we now have a different object-creation mechanism.</p>
<p>Now, based on this factory concept, we are ready to move on to the main focus of this chapter. From now<a id="_idIndexMarker365"/> on, you can use the <code>begin</code> project as the basis for development. Let us start to design a general C++ type exporter.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor183"/>Designing a type exporter</h1>
<p>First, let us define our<a id="_idIndexMarker366"/> scope. We want to generalize the factory we have just made and make it work with any C++ class – that is, the C++ class still needs to implement and provide the <code>lua_CFunction</code> wrappers in some way. It is possible to automate the creation of those wrappers, but that would require implementing a heavy C++ template library, which is not strictly related to Lua and is out of the scope of this book.</p>
<p>With the scope defined, let us make some high-level designs.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor184"/>Choosing a design pattern</h2>
<p>When we talk about <a id="_idIndexMarker367"/>making something <em class="italic">general</em> in C++, usually it<a id="_idIndexMarker368"/> means we need to use templates. To work with our Lua executor, we need to export <code>LuaModule</code>. So, we need to implement the exporter as a template class that can provide <code>LuaModule</code>.</p>
<p>How can we provide <code>LuaModule</code>? We can make the exporter inherit from the <code>LuaModule</code> interface, or make one of its member functions return <code>LuaModule</code>.</p>
<p>One of the popular design patterns for the latter <a id="_idIndexMarker369"/>option is the <strong class="bold">Builder</strong> pattern. This can be demonstrated with the following pseudo-code:</p>
<pre class="source-code">
class LuaModuleBuilder
{
    LuaModuleBuilder withOptionA(...);
    LuaModuleBuilder withOptionB(...);
    ...
    LuaModule build();
};
LuaModuleBuilder builder;
auto module = builder.withOptionX(...).build();</pre>
<p>A builder usually has many functions to customize different properties for the thing it creates, alongside a <code>build</code> function to create the final object.</p>
<p>Since our goal is to help with object creation alone, like in the factory exercise, and not to customize the object, the <em class="italic">Builder</em> pattern is overkill. We will choose the vanilla C++ inheritance. The exporter type can be defined as follows:</p>
<pre class="source-code">
template &lt;typename T&gt;
class LuaModuleExporter : public LuaModule;</pre>
<p>This is <a id="_idIndexMarker370"/>a template <a id="_idIndexMarker371"/>class. It will export C++ type <code>T</code> as <code>LuaModule</code>.</p>
<p>Now, let us stub the exporter.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor185"/>Stubbing the exporter</h1>
<p>We have two major<a id="_idIndexMarker372"/> considerations for the design of the exporter. First, it is <code>LuaModule</code>, so it needs to implement its pure virtual functions. Second, we want it to resemble what we implemented in the factory exercise, which means we have a pretty good idea of what to return in the <code>luaRegs</code> virtual function implementation.</p>
<p>Let us get started. Add a new file named <code>LuaModuleExporter.hpp</code> and define the <code>LuaModuleExporter</code> class, as follows:</p>
<pre class="source-code">
template &lt;typename T&gt;
class LuaModuleExporter final : public LuaModule
{
public:
    LuaModuleExporter(
        const LuaModuleExporter &amp;) = delete;
    ~LuaModuleExporter() = default;
    static LuaModuleExporter&lt;T&gt; make()
    {
        return LuaModuleExporter&lt;T&gt;();
    }
private:
    LuaModuleExporter() {}
};</pre>
<p>This makes the exporter a final class and prevents it from being copy-constructed. Because the purpose of the exporter is to provide <code>LuaModule</code> and we do not have logic for it to get passed around by value, adding some restrictions can prevent bugs in the future. We achieve this by assigning the <code>delete</code> keyword to the copy constructor. We also want to <a id="_idIndexMarker373"/>control the object creation, so we make the constructor private. This has another effect – you cannot use <code>new operator</code> to create instances of the class.</p>
<p>Now, add the implementation for <code>LuaModule</code> as follows:</p>
<pre class="source-code">
class LuaModuleExporter final : public LuaModule
{
public:
    const std::string &amp;luaName() const override
    {
        return name;
    }
    const std::vector&lt;luaL_Reg&gt; &amp;luaRegs() const override
    {
        return factoryRegs;
    }
private:
    const std::string name = "TODO";
    const std::vector&lt;luaL_Reg&gt; factoryRegs = {
        {"new", luaNew},
        {NULL, NULL}};
    static int luaNew(lua_State *L)
    {
        return 0;
    }
};</pre>
<p>This is straightforward. On the Lua module level, we only want to export one function to create concrete objects. So, we will only register <code>luaNew</code>. The name of the module needs to be passed in. We will find a way when we implement the details.</p>
<p>Thus, we have a <a id="_idIndexMarker374"/>stub for our exporter. This is a system-level design contract. Now, let us write the test code to see how it should be used.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor186"/>Preparing the C++ test code</h2>
<p>In <code>main.cpp</code>, write <a id="_idIndexMarker375"/>the <code>main</code> function<a id="_idIndexMarker376"/> as follows:</p>
<pre class="source-code">
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    auto module = LuaModuleExporter&lt;
        Destinations&gt;::make();
    lua-&gt;registerModule(module);
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>Compared with the previous chapter, the only difference is how <code>LuaModule</code> is created. Now, it is created with <code>LuaModuleExporter&lt;Destinations&gt;::make()</code>.</p>
<p>At this point, the project should compile. When you run it, it should not crash on the C++ side; although, at <a id="_idIndexMarker377"/>this stage, it will not be able to do anything<a id="_idIndexMarker378"/> meaningful, and you should see an error message from Lua.</p>
<p>Now, we will see what Lua code we need.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor187"/>Preparing the Lua test script</h2>
<p>Write <code>script.lua</code> exactly <a id="_idIndexMarker379"/>as <a id="_idIndexMarker380"/>follows:</p>
<pre class="source-code">
dst = Destinations.new()
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())</pre>
<p>We used this code snippet in the previous chapter. This will help to validate whether we will get the same result later in this chapter.</p>
<p>Next, let us start to make the exporter work.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor188"/>Defining LuaModuleDef</h1>
<p>First, we need to<a id="_idIndexMarker381"/> provide the name of the module and then the <code>__index</code> metatable. Finally, we need to provide a name for the metatable. Recall that in <code>Destinations.cc</code>, the name of the metatable is hardcoded as follows:</p>
<pre class="source-code">
const std::string METATABLE_NAME(
    "Destinations.Metatable");</pre>
<p>Now, this needs to be passed to the exporter. Let us define a structure for the aforementioned three pieces of information. In <code>LuaModule.h</code>, add the following declaration:</p>
<pre class="source-code">
template &lt;typename T&gt;
struct LuaModuleDef
{
    const std::string moduleName;
    const std::vector&lt;luaL_Reg&gt; moduleRegs;
    const std::string metatableName() const
    {
        return std::string(moduleName)
            .append(".Metatable");
    }
};</pre>
<p>This defines <code>moduleName</code> and <code>moduleRegs</code>. The metatable name is based on the module name, with <code>".Metatable"</code> appended to it.</p>
<p>Note that this structure is also templated. This indicates that a definition is for a certain C++ type. We will use the template later in this chapter.</p>
<p>Now, we can pass this structure to the exporter.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor189"/>Using LuaModuleDef</h2>
<p>In <code>LuaModuleExporter.hpp</code>, accept <a id="_idIndexMarker382"/>an instance of <code>LuaModuleDef</code> during exporter creation. Rewrite the related code as follows:</p>
<pre class="source-code">
class LuaModuleExporter final : public LuaModule
{
public:
    static LuaModuleExporter&lt;T&gt; make(
        const LuaModuleDef&lt;T&gt; &amp;luaModuleDef)
    {
        return LuaModuleExporter&lt;T&gt;(luaModuleDef);
    }
    const std::string &amp;luaName() const override
    {
        return luaModuleDef.moduleName;
    }
private:
    LuaModuleExporter(
        const LuaModuleDef&lt;T&gt; &amp;luaModuleDef)
        : luaModuleDef(luaModuleDef) {}
    const LuaModuleDef&lt;T&gt; luaModuleDef;
};</pre>
<p>The changes are as follows:</p>
<ul>
<li>We added a private member variable, <code>luaModuleDef</code></li>
<li>We added an argument of type <code>LuaModuleDef</code> to <code>make</code> and the private constructor</li>
<li>We changed <code>luaName</code> to return <code>luaModuleDef.moduleName</code></li>
<li>We deleted the private member variable, <code>name</code>, introduced during stubbing</li>
</ul>
<p>Now, we can define <code>LuaModuleDef</code> for the <code>Destinations</code> class.</p>
<p>In <code>Destinations.h</code>, delete the declaration for <code>DestinationsFactory</code> and add the following code:</p>
<pre class="source-code">
struct DestinationsLuaModuleDef
{
    static LuaModuleDef&lt;Destinations&gt; def;
};</pre>
<p>In <code>Destinations.cpp</code>, delete <a id="_idIndexMarker383"/>all implementations for <code>DestinationsFactory</code> and add the following code after the anonymous namespace:</p>
<pre class="source-code">
LuaModuleDef DestinationsLuaModuleDef::def =
    LuaModuleDef&lt;Destinations&gt;{
        "Destinations",
        {{"wish", luaWish},
         {"went", luaWent},
         {"list_visited", luaListVisited},
         {"list_unvisited", luaListUnvisited},
         {NULL, NULL}},
    };</pre>
<p>Finally, in <code>main.cpp</code>, change the module creation code to the following statement:</p>
<pre class="source-code">
auto module = LuaModuleExporter&lt;Destinations&gt;::make(
    DestinationsLuaModuleDef::def);</pre>
<p>This pumps <code>LuaModuleDef</code> for the <code>Destinations</code> class into the exporter. Make sure that the project<a id="_idIndexMarker384"/> can compile.</p>
<p>Now, we will fill in the rest of the missing pieces to make the exporter really work.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor190"/>Re-implementing luaNew</h1>
<p>Because we<a id="_idIndexMarker385"/> will store <code>LuaModuleDef</code> in <code>LuaModuleExporter</code>, to access it, we need to find the instance of <code>LuaModuleExporter</code>. Let us first implement a helper function for this.</p>
<p>Since the exporter is also <code>LuaModule</code>, it already has an upvalue mechanism, implemented in <em class="italic">Chapter 6</em>. <code>LuaModule::pushLuaUpvalues</code> will push the pointer to the <code>LuaModule</code> instance as an upvalue. To retrieve it, we can add the following function:</p>
<pre class="source-code">
class LuaModuleExporter final : public LuaModule
{
private:
    static LuaModuleExporter&lt;T&gt; *getExporter(
        lua_State *L)
    {
        return reinterpret_cast&lt;LuaModuleExporter&lt;T&gt; *&gt;(
            lua_touserdata(L, lua_upvalueindex(1)));
    }
};</pre>
<p>This is the same as the <code>getObj</code> function in <em class="italic">Chapter 6</em>, but now, it is a static member function.</p>
<p>With a way to access the exporter instance from the static member functions, we can write <code>LuaModuleExporter::luaNew</code> as follows:</p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    <strong class="bold">auto luaModuleDef = getExporter(L)-&gt;luaModuleDef;</strong>
    T *obj = new T();
    T **userdata = reinterpret_cast&lt;T **&gt;(
        lua_newuserdatauv(L, sizeof(obj), 0));
    *userdata = obj;
    <strong class="bold">auto metatableName = luaModuleDef.metatableName();</strong>
    int type = luaL_getmetatable(
        L, <strong class="bold">metatableName.c_str()</strong>);
    if (type == LUA_TNIL)
    {
        lua_pop(L, 1);
        luaL_newmetatable(L, metatableName.c_str());
        lua_pushvalue(L, -1);
        lua_setfield(L, -2, "__index");
        luaL_setfuncs(
            L, <strong class="bold">luaModuleDef.moduleRegs.data()</strong>, 0);
        lua_pushcfunction(L, luaDelete);
        lua_setfield(L, -2, "__gc");
    }
    lua_setmetatable(L, 1);
    return 1;
}</pre>
<p>This is actually copied from <code>Destinations.cc</code>. The changes, besides using <code>T</code> <code>typename</code> instead of the hardcoded class name, are highlighted in the preceding code. You can see that they are all about pumping <code>LuaModuleDef</code>.</p>
<p>If you have forgotten how <code>luaNew</code> works, you can check the previous chapter, where there are figures to show how the Lua stack changes as well.</p>
<p>Finally, let us implement the stub for <code>LuaModuleExporter::luaDelete</code> as follows:</p>
<pre class="source-code">
static int luaDelete(lua_State *L)
{
    T *obj = *reinterpret_cast&lt;T **&gt;(
        lua_touserdata(L, 1));
    delete obj;
    return 0;
}</pre>
<p><code>luaDelete</code> is<a id="_idIndexMarker386"/> registered as the <code>__gc</code> metamethod in <code>luaNew</code>.</p>
<p class="callout-heading">Do you remember?</p>
<p class="callout">As explained in the previous chapter, we set <code>luaDelete</code> as the finalizer for the user data created in <code>luaNew</code>. During the Lua garbage collection process, the finalizer will be called, with an argument as the user data reference.</p>
<p>You can also delete <code>REGS</code>, <code>FACTORY_REGS</code>, <code>luaNew</code>, and <code>luaDelete</code> in <code>Destinations.cc</code>. They are not used anymore.</p>
<p>Now, we can test the exporter. Execute the project. If you have done everything correctly, you should see the following output:</p>
<pre class="source-code">
Destinations instance created: 0x12a704170
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
Destinations instance destroyed: 0x12a704170</pre>
<p>We have not really changed the test code from the previous chapter, except for how the <code>Destinations</code> class gets exported to Lua.</p>
<p>If you have encountered any errors, do not feel discouraged. This is the most complex chapter in this book, and we need to implement code correctly in multiple files to make it work. Trace back your steps and fix the error. You can do it! Also, in GitHub, there are multiple checkpoint projects for this chapter, which you can refer to. As previously mentioned, we will not <a id="_idIndexMarker387"/>automate the generation of the <code>lua_CFunction</code> wrappers. Generalization also needs a limit.</p>
<p>But, let us check how general our implementation is.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor191"/>Are you flexible enough?</h1>
<p>To answer <a id="_idIndexMarker388"/>this<a id="_idIndexMarker389"/> question, let us rewrite <code>script.lua</code> as follows:</p>
<pre class="source-code">
dst = Destinations.new(<strong class="bold">"Shanghai", "Tokyo"</strong>)
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())</pre>
<p>Yes, the new requirement is that, in the Lua code, when creating the <code>Destinations</code> objects, we can provide an initial list of unvisited places.</p>
<p>This means that we need to support parameterized object creation.</p>
<p>Can our exporter support this? This should be a common use case. </p>
<p>Now is a good time to ponder over life, get a cup of coffee, or whatever. We are almost near the end of <em class="italic">Part 3</em> of this book.</p>
<p>If you recall, our object creation code is as follows:</p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
   ...
   T *obj = new T();
   ...
}</pre>
<p>As a seasoned C++ programmer, you may think that, because <code>std::make_unique&lt;T&gt;</code> can forward its arguments to the constructor of <code>T</code>, there must be a way to make <code>LuaModuleExporter&lt;T&gt;::make</code> do the same. Right, but the magic of <code>std::make_unique&lt;T&gt;</code> is at C++ compile time. So, how would you handle that when the arguments are passed in Lua code after the C++ code has been compiled?</p>
<p>Worry not. Let us explore<a id="_idIndexMarker390"/> the <strong class="bold">factory method</strong> design pattern. A factory method is a contract defined as a method or an interface to create and return an object. However, how the object is created is not important and not part of the contract.</p>
<p>To see how<a id="_idIndexMarker391"/> it <a id="_idIndexMarker392"/>works, let us implement one for <code>LuaModuleDef</code>. Add another member variable, named <code>createInstance</code>, as follows:</p>
<pre class="source-code">
struct LuaModuleDef
{
    const std::function&lt;T *(lua_State *)&gt;
    createInstance =
    [](lua_State *) -&gt; T* { return new T(); };
};</pre>
<p>This is a bit of advanced C++ usage. Therefore, it is important that you take the following into account:</p>
<ul>
<li><code>createInstance</code> is declared as a member variable but not as a member function. This is because you can simply assign the member variable a different value during object construction to achieve a different behavior, but with a member function, you need to create a subclass to override the behavior. <em class="italic">We should prefer composition over inheritance whenever </em><em class="italic">we can.</em></li>
<li><code>createInstance</code> is of type <code>std::function</code>. With this type, you can use the variable as if it were a function. If you are more familiar with Lua in this regard, you’ll understand that a named Lua function is also a variable. Here, we want to achieve the same effect. <code>T *(lua_State *)</code> is the type of the function. It means that the function expects one argument of type <code>lua_State*</code> and will return a pointer to type <code>T</code>. You can check the C++ reference manual to learn more about <code>std::function</code>.</li>
<li>Then, we provide a default implementation as a C++ lambda. This lambda simply creates an instance in the heap without any constructor parameter.</li>
</ul>
<p>To use this factory method, change <code>LuaModuleExporter::luaNew</code>, as follows:</p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    ...
    T *obj = <strong class="bold">luaModuleDef.createInstance(L)</strong>;
    ...
}</pre>
<p>We have changed from new <code>T()</code> to <code>luaModuleDef.createInstance(L)</code>, and it still does the same thing.</p>
<p>However, note <a id="_idIndexMarker393"/>that<a id="_idIndexMarker394"/> we no longer create the object in <code>LuaModuleExporter</code>.</p>
<p>Finally, to answer the question, yes, we are flexible enough.</p>
<p class="callout-heading">On modern C++</p>
<p class="callout">In 1998, C++ was<a id="_idIndexMarker395"/> standardized for the first time as C++98. It saw little change until 2011, with C++11. Since then, C++ has quickly adopted modern programming techniques in language specification. Lambdas and <code>std::function</code> are just two of the many examples. If you know some other languages (for example, Java), you can make some analogies (lamdba and functional interface), although the syntaxes are different. I implemented <code>LuaModuleDef</code> this way instead of using a more traditional method to show you some examples of modern C++ features. This is the future, and I encourage you to explore modern C++ in more detail. People working with Java, Kotlin, and Swift use such techniques by default. You can play an important role here by adopting these new techniques and helping C++ to catch up.</p>
<p>In <code>Destinations.cc</code>, change the <code>LuaModuleDef</code> instance as follows:</p>
<pre class="source-code">
LuaModuleDef DestinationsLuaModuleDef::def =
LuaModuleDef&lt;Destinations&gt;{
    "Destinations",
    {{"wish", luaWish},
     ...
     {NULL, NULL}},
    [](lua_State *L) -&gt; Destinations *
    {
        Destinations *obj = new Destinations();
        std::vector&lt;std::string&gt; places;
        int nArgs = lua_gettop(L);
        for (int i = 1; i &lt;= nArgs; i++)
        {
            places.push_back(lua_tostring(L, i));
        }
        obj-&gt;wish(places);
        return obj;
    },
};</pre>
<p>This initializes the <code>createInstance</code> field with <a id="_idIndexMarker396"/>the<a id="_idIndexMarker397"/> provided lambda, rather than the default lambda. The new lambda does similar things to the <code>luaWish</code> wrapper. The beauty of this is that you have full control over this lambda. You can create another constructor for the <code>Destinations</code> class and simply invoke the new constructor.</p>
<p>We can test the project with the new Lua script. You should see the following output:</p>
<pre class="source-code">
Destinations instance created: 0x142004170
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London <strong class="bold">Shanghai Tokyo</strong>
Destinations instance destroyed: 0x142004170</pre>
<p>As you can see, <code>Shanghai</code> and <code>Tokyo</code> have<a id="_idIndexMarker398"/> been <a id="_idIndexMarker399"/>added to the unvisited list.</p>
<p class="callout-heading">Even further design improvement</p>
<p class="callout">We are creating objects in <code>LuaModuleDef</code> but destroying them in <code>LuaModuleExporter</code>, and our use case does not involve transferring object ownership. For a better design, the same class should destroy the objects it creates, which we will implement in the next chapter.</p>
<p>This time, for real, we have finished.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor192"/>Summary</h1>
<p>In this chapter, we implemented a general C++ module exporter, mainly for the object creation part. This ensures that you can implement complex object creation logic once and reuse it with many C++ classes. Also, this chapter marks the end of <em class="italic">Part 3</em>, <em class="italic">How to Call C++ </em><em class="italic">from Lua</em>.</p>
<p>In the following chapter, we will recap the different communication mechanisms between Lua and C++ and explore them further.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>Exercise</h1>
<p>This is an open exercise. You can write a new C++ class, or find one from your work in the past, and then export it to Lua with <code>LuaModuleExporter</code>. Try to provide an interesting <code>createInstance</code> implementation as well.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-192" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor194"/>Part 4 – Advanced Topics</h1>
<p>By this point of the book, you will have learned all the common mechanisms to integrate Lua with C++.</p>
<p>In this part, you will recap what you have learned, which will also serve as a source for quick reference. You will also learn how to implement a standalone C++ module that can be loaded by Lua, as a dynamic loadable library. Then, you will learn some advanced memory management techniques and how to implement multithreading with Lua.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><em class="italic">Chapter 9</em>, <em class="italic">Recapping Lua-C++ Communication Mechanisms</em></li>
<li><em class="italic">Chapter 10</em>, <em class="italic">Managing Resources</em></li>
<li><em class="italic">Chapter 11</em>, <em class="italic">Multithreading with Lua</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>