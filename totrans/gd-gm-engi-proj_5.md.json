["```cpp\nextends KinematicBody2D\n\nvar velocity = Vector2(250, 250)\n\nfunc _physics_process(delta):\n    var collide = move_and_collide(velocity * delta)\n    if collide:\n        velocity = velocity.bounce(collide.normal)\n```", "```cpp\nextends KinematicBody2D\nenum {IDLE, RUN, JUMP, HURT, DEAD}\nvar state\nvar anim\nvar new_anim\n\nfunc ready():\n    change_state(IDLE)\n\nfunc change_state(new_state):\n    state = new_state\n    match state:\n        IDLE:\n            new_anim = 'idle'\n        RUN:\n            new_anim = 'run'\n        HURT:\n            new_anim = 'hurt'\n        JUMP:\n            new_anim = 'jump_up'\n        DEAD:\n            hide()\n\nfunc _physics_process(delta):\n    if new_anim != anim:\n        anim = new_anim\n        $AnimationPlayer.play(anim)\n```", "```cpp\nextends KinematicBody2D\n\nexport (int) var run_speed\nexport (int) var jump_speed\nexport (int) var gravity\n\nenum {IDLE, RUN, JUMP, HURT, DEAD}\nvar state\nvar anim\nvar new_anim\nvar velocity = Vector2()\n\nfunc get_input():\n    if state == HURT:\n        return # don't allow movement during hurt state\n    var right = Input.is_action_pressed('right')\n    var left = Input.is_action_pressed('left')\n    var jump = Input.is_action_just_pressed('jump')\n\n    # movement occurs in all states\n    velocity.x = 0\n    if right:\n        velocity.x += run_speed\n        $Sprite.flip_h = false\n    if left:\n        velocity.x -= run_speed\n        $Sprite.flip_h = true\n    # only allow jumping when on the ground\n    if jump and is_on_floor():\n        change_state(JUMP)\n        velocity.y = jump_speed\n    # IDLE transitions to RUN when moving\n    if state == IDLE and velocity.x != 0:\n        change_state(RUN)\n    # RUN transitions to IDLE when standing still\n    if state == RUN and velocity.x == 0:\n        change_state(IDLE)\n    # transition to JUMP when falling off an edge\n    if state in [IDLE, RUN] and !is_on_floor():\n        change_state(JUMP)\n```", "```cpp\nfunc _physics_process(delta):\n    velocity.y += gravity * delta\n    get_input()\n    if new_anim != anim:\n        anim = new_anim\n        $AnimationPlayer.play(anim)\n    # move the player\n    velocity = move_and_slide(velocity, Vector2(0, -1))\n```", "```cpp\n    if state == JUMP and is_on_floor():\n        change_state(IDLE)\n```", "```cpp\n    if state == JUMP and velocity.y > 0:        new_anim = 'jump_down'Testing the moves\n```", "```cpp\nfunc start(pos):\n    position = pos\n    show()\n    change_state(IDLE)\n```", "```cpp\nsignal life_changed\nsignal dead\n\nvar life\n```", "```cpp\n    life = 3\n    emit_signal('life_changed', life)\n```", "```cpp\nfunc hurt():\n    if state != HURT:\n        change_state(HURT)\n```", "```cpp\nHURT:\n    new_anim = 'hurt'\n    velocity.y = -200\n    velocity.x = -100 * sign(velocity.x)\n    life -= 1\n    emit_signal('life_changed', life)\n    yield(get_tree().create_timer(0.5), 'timeout')\n    change_state(IDLE)\n    if life <= 0:\n        change_state(DEAD)\nDEAD:\n    emit_signal('dead')\n    hide()\n```", "```cpp\nif state == HURT:\n    return\n```", "```cpp\n0 → 1 → 2 → 3 → 4 → 3 → 2 → 1 \n```", "```cpp\nextends Area2D\n\nsignal pickup\n\nvar textures = {'cherry': 'res://assets/sprites/cherry.png',\n                'gem': 'res://assets/sprites/gem.png'}\n\nfunc init(type, pos):\n    $Sprite.texture = load(textures[type])\n    position = pos\n```", "```cpp\nfunc _on_Collectible_body_entered(body):\n    emit_signal('pickup')\n    queue_free()\n```", "```cpp\nextends Node2D\n\nonready var pickups = $Pickups\n\nfunc _ready():\n    pickups.hide()\n    $Player.start($PlayerSpawn.position)\n```", "```cpp\nsignal score_changed\nvar score \n\nfunc _ready():\n    score = 0\n    emit_signal('score_changed', score)\n    pickups.hide()\n    $Player.start($PlayerSpawn.position)\n    set_camera_limits()\n\nfunc set_camera_limits():\n    var map_size = $World.get_used_rect()\n    var cell_size = $World.cell_size\n    $Player/Camera2D.limit_left = (map_size.position.x - 5) * cell_size.x\n    $Player/Camera2D.limit_right = (map_size.end.x + 5) * cell_size.x\n```", "```cpp\nfunc spawn_pickups():\n    for cell in pickups.get_used_cells():\n        var id = pickups.get_cellv(cell)\n        var type = pickups.tile_set.tile_get_name(id)\n        if type in ['gem', 'cherry']:\n            var c = Collectible.instance()\n            var pos = pickups.map_to_world(cell)\n            c.init(type, pos + pickups.cell_size/2)\n            add_child(c)\n            c.connect('pickup', self, '_on_Collectible_pickup')\n\nfunc _on_Collectible_pickup():\n    score += 1\n    emit_signal('score_changed', score)\n\nfunc _on_Player_dead():\n    pass\n```", "```cpp\nvar Collectible = preload('res://items/Collectible.tscn')\n```", "```cpp\n    velocity = move_and_slide(velocity, Vector2(0, -1))\n    if state == HURT:\n        return\n    for idx in range(get_slide_count()):\n        var collision = get_slide_collision(idx)\n        if collision.collider.name == 'Danger':\n            hurt()\n```", "```cpp\nextends KinematicBody2D\n\nexport (int) var speed\nexport (int) var gravity\n\nvar velocity = Vector2()\nvar facing = 1\n\nfunc _physics_process(delta):\n    $Sprite.flip_h = velocity.x > 0\n    velocity.y += gravity * delta\n    velocity.x = facing * speed\n\n    velocity = move_and_slide(velocity, Vector2(0, -1))\n    for idx in range(get_slide_count()):\n        var collision = get_slide_collision(idx)\n        if collision.collider.name == 'Player':\n            collision.collider.hurt()\n        if collision.normal.x != 0:\n            facing = sign(collision.normal.x)\n            velocity.y = -100\n\n    if position.y > 1000:\n        queue_free()\n```", "```cpp\nfunc take_damage():\n    $AnimationPlayer.play('death')\n    $CollisionShape2D.disabled = true\n    set_physics_process(false)\n```", "```cpp\nfunc _on_AnimationPlayer_animation_finished(anim_name):\n  if anim_name == 'death':\n    queue_free()\n```", "```cpp\nfor idx in range(get_slide_count()):\n    var collision = get_slide_collision(idx)\n    if collision.collider.name == 'Danger':\n        hurt()\n    if collision.collider.is_in_group('enemies'):\n        var player_feet = (position + $CollisionShape2D.shape.extents).y\n        if player_feet < collision.collider.position.y:\n            collision.collider.take_damage()\n            velocity.y = -200\n        else:\n            hurt()\n```", "```cpp\nextends MarginContainer\n\nonready var life_counter = [$HBoxContainer/LifeCounter/L1,\n                            $HBoxContainer/LifeCounter/L2,\n                            $HBoxContainer/LifeCounter/L3,\n                            $HBoxContainer/LifeCounter/L4,\n                            $HBoxContainer/LifeCounter/L5]\n\nfunc _on_Player_life_changed(value):\n    for heart in range(life_counter.size()):\n        life_counter[heart].visible = value > heart\n\nfunc _on_score_changed(value):\n    $HBoxContainer/ScoreLabel.text = str(value)\n```", "```cpp\n$Player.connect('life_changed', $CanvasLayer/HUD,  \n                '_on_Player_life_changed')\n$Player.connect('dead', self, '_on_Player_dead')\nconnect('score_changed', $CanvasLayer/HUD, '_on_score_changed') \n```", "```cpp\nextends Node\n\nvar num_levels = 2\nvar current_level = 1\n\nvar game_scene = 'res://Main.tscn'\nvar title_screen = 'res://ui/TitleScreen.tscn'\n\nfunc restart():\n    get_tree().change_scene(title_screen)\n\nfunc next_level():\n    current_level += 1\n    if current_level <= num_levels:\n        get_tree().reload_current_scene()\n```", "```cpp\nextends Node\n\nfunc _ready():\n    # make sure your level numbers are 2 digits (\"01\", etc.)\n    var level_num = str(GameState.current_level).pad_zeros(2)\n    var path = 'res://levels/Level%s.tscn' % level_num\n    var map = load(path).instance()\n    add_child(map)\n```", "```cpp\nextends Control\n\nfunc _input(event):\n    if event.is_action_pressed('ui_select'):\n        get_tree().change_scene(GameState.game_scene)\n```", "```cpp\nfunc _on_Player_dead():\n    GameState.restart()\n```", "```cpp\nfunc _on_Door_body_entered(body):\n    GameState.next_level()\n```", "```cpp\nif position.y > 1000:\n    change_state(DEAD)\n```", "```cpp\nvar max_jumps = 2\nvar jump_count = 0\n```", "```cpp\nJUMP:\n    new_anim = 'jump_up'\n    jump_count = 1\n```", "```cpp\nif jump and state == JUMP and jump_count < max_jumps:\n    new_anim = 'jump_up'\n    velocity.y = jump_speed / 1.5\n    jump_count += 1\n```", "```cpp\nif state == JUMP and is_on_floor():\n    change_state(IDLE)\n    $Dust.emitting = true # add this line\n```", "```cpp\nenum {IDLE, RUN, JUMP, HURT, DEAD, CROUCH}\n```", "```cpp\nCROUCH:\n    new_anim = 'crouch'\n```", "```cpp\nvar down = Input.is_action_pressed('crouch')\n\nif down and is_on_floor():\n    change_state(CROUCH)\nif !down and state == CROUCH:\n    change_state(IDLE)\n```", "```cpp\nif state == IDLE and velocity.x != 0:\n    change_state(RUN)\n```", "```cpp\nif state in [IDLE, CROUCH] and velocity.x != 0:\n    change_state(RUN)\n```", "```cpp\nexport (int) var climb_speed\nvar is_on_ladder = false\n```", "```cpp\nCLIMB:\n    new_anim = 'climb'\n```", "```cpp\nvar climb = Input.is_action_pressed('climb')\n\nif climb and state != CLIMB and is_on_ladder:\n    change_state(CLIMB)\nif state == CLIMB:\n    if climb:\n        velocity.y = -climb_speed\n    elif down:\n        velocity.y = climb_speed\n    else:\n        velocity.y = 0\n        $AnimationPlayer.play(\"climb\")\nif state == CLIMB and not is_on_ladder:\n    change_state(IDLE)\n```", "```cpp\nif state != CLIMB:\n    velocity.y += gravity * delta\n```", "```cpp\nfunc _on_Ladder_body_entered(body):\n    if body.name == \"Player\":\n        body.is_on_ladder = true\n\nfunc _on_Ladder_body_exited(body):\n    if body.name == \"Player\":\n        body.is_on_ladder = false\n```", "```cpp\nextends KinematicBody2D\n\nexport (Vector2) var velocity\n\nfunc _physics_process(delta):\n    var collision = move_and_collide(velocity * delta)\n    if collision:\n        velocity = velocity.bounce(collision.normal)\n```", "```cpp\nfunc _physics_process(delta):\n    var collision = move_and_collide(velocity * delta)\n    if collision:\n        velocity.x *= -1\n```"]