<html><head></head><body>
		<div id="_idContainer142">
			<h1 id="_idParaDest-149" class="chapter-number"><a id="_idTextAnchor148"/>5</h1>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>3D Minigolf: Dive into 3D by Building a Minigolf Course</h1>
			<p>The previous projects in this book have been designed in 2D space. This is intentional to introduce the features and concepts of Godot while keeping the projects’ scopes limited. In this chapter, you’ll venture into the 3D side of game development. For some, 3D development feels significantly more difficult to manage. For others, it is more straightforward. In either case, there is certainly an additional layer of complexity for you <span class="No-Break">to understand.</span></p>
			<p>If you’ve never worked with any kind of 3D software before, you may find yourself encountering many new concepts. This chapter will explain them as much as possible, but remember to refer to the Godot documentation whenever you need a more in-depth understanding of a <span class="No-Break">particular topic.</span></p>
			<p>The game you’ll make in this chapter<a id="_idIndexMarker352"/> is called <em class="italic">3D Minigolf</em>. In it, you’ll build a small minigolf course, a ball, and an interface for aiming and shooting the ball toward <span class="No-Break">the hole.</span></p>
			<p>Here are some of the things you’ll learn in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Navigating Godot’s <span class="No-Break">3D editor</span></li>
				<li><strong class="source-inline">Node3D</strong> and <span class="No-Break">its properties</span></li>
				<li>Importing 3D meshes and using 3D <span class="No-Break">collision shapes</span></li>
				<li>How to use <span class="No-Break">3D cameras</span></li>
				<li>Setting up lighting <span class="No-Break">and environment</span></li>
				<li>An introduction to PBR <span class="No-Break">and materials</span></li>
			</ul>
			<p>Before diving in, a brief introduction to 3D <span class="No-Break">in Godot.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Technical requirements</h1>
			<p>Download the game assets from the following link and unzip them into your new <span class="No-Break">project folder:</span></p>
			<p><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</span></a></p>
			<p>You can also find the complete code for this chapter on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf</span></a></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Introduction to 3D</h1>
			<p>One of the strengths <a id="_idIndexMarker353"/>of Godot is its ability to handle both 2D and 3D games. Much of what you’ve learned earlier in this book will apply equally well in 3D – nodes, scenes, signals, etc. But changing from 2D to 3D also brings with it a whole new layer of complexity and capabilities. First, you’ll find that there are some additional features available in the 3D editor window, and it’s a good idea to familiarize yourself with how <span class="No-Break">to navigate.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Orienting in 3D space</h2>
			<p>Open <a id="_idIndexMarker354"/>a new project and click on the <strong class="bold">3D</strong> button at the top of the editor window to see the 3D <span class="No-Break">project view:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B19289_05_01.jpg" alt="Figure 5.1: The 3D workspace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: The 3D workspace</p>
			<p>The first things you <a id="_idIndexMarker355"/>should notice are the three colored lines in the center. These are the <strong class="source-inline">x</strong> (red), <strong class="source-inline">y</strong> (green), and <strong class="source-inline">z</strong> (blue) axes. The point where they meet is the <strong class="bold">origin</strong>, with coordinates of <strong class="source-inline">(0, </strong><span class="No-Break"><strong class="source-inline">0, 0)</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">3D coordinates</p>
			<p class="callout">Just as you used <strong class="source-inline">Vector2(x, y)</strong> to indicate a position in 2D space, you’ll use <strong class="source-inline">Vector3(x, y, z)</strong> to describe a position in <span class="No-Break">three dimensions.</span></p>
			<p>One issue that often arises when working in 3D is that different applications use different conventions for orientation. Godot <a id="_idIndexMarker356"/>uses the <strong class="bold">Y-UP</strong> orientation, so when looking at the axes, if <strong class="source-inline">x</strong> is pointing to the left/right, then <strong class="source-inline">y</strong> is up/down and <strong class="source-inline">z</strong> is forward/back. If you use other popular 3D software, you may find that some of them use <strong class="bold">Z-Up</strong>. It’s <a id="_idIndexMarker357"/>good to be aware of this, as it can lead to confusion when moving between <span class="No-Break">different programs.</span></p>
			<p>Another<a id="_idIndexMarker358"/> important thing to be aware of is the unit of measure. In 2D, Godot measures everything in pixels, which makes sense as the natural basis for measurement when drawing on the screen. However, when working in 3D space, pixels aren’t really useful. Two objects of the same size will occupy different areas on the screen depending on how far away they are from the camera (more about cameras soon). For this reason, in 3D space, all objects in Godot are measured in generic units. While it’s most common to refer to them as “meters,” you’re free to call these units whatever you like: inches, millimeters, or even light years, depending on the scale of your <span class="No-Break">game world.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Godot’s 3D editor</h2>
			<p>Before<a id="_idIndexMarker359"/> moving too deeply into building a game, it will be useful to review how to navigate in 3D space. The view camera is controlled using the mouse <span class="No-Break">and keyboard:</span></p>
			<ul>
				<li><em class="italic">Mouse wheel up/down</em>: Zoom in/out on the <span class="No-Break">current target</span></li>
				<li><em class="italic">Middle button</em> + <em class="italic">drag</em>: Orbit the camera around the <span class="No-Break">current target</span></li>
				<li><em class="italic">Shift</em> + <em class="italic">middle button</em> + <em class="italic">drag</em>: Pan the <span class="No-Break">camera up/down/left/right</span></li>
				<li><em class="italic">Right button</em> + <em class="italic">drag</em>: Rotate the camera <span class="No-Break">in place</span></li>
			</ul>
			<p>Note that some of these movements are based on a camera target, or <strong class="bold">focus</strong>. To focus on an object in space, you can select it and <span class="No-Break">press </span><span class="No-Break"><em class="italic">F</em></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Freelook navigation</p>
			<p class="callout">If you’re familiar with popular 3D games such as <em class="italic">Minecraft</em>, you can press <em class="italic">Shift</em> + <em class="italic">F</em> to switch to FreeLook mode. In this mode, you can use the <em class="italic">W</em>/<em class="italic">A</em>/<em class="italic">S</em>/<em class="italic">D</em> keys to fly around the scene while aiming with the mouse. Press <em class="italic">Shift</em> + <em class="italic">F</em> again to exit <span class="No-Break">FreeLook mode.</span></p>
			<p>You can also affect the camera’s view by clicking on the <strong class="bold">Perspective</strong> label in the upper-left corner of the viewport. Here, you can snap the camera to a particular orientation such as <strong class="bold">Top View</strong> or <span class="No-Break"><strong class="bold">Front View</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B19289_05_02.jpg" alt="Figure 5.2: Perspective menu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Perspective menu</p>
			<p>This can be especially useful on large displays when combined with the use of multiple viewports. Click the <strong class="bold">View</strong> menu and you can split the screen into multiple views, allowing you <a id="_idIndexMarker360"/>to see an object from all <span class="No-Break">sides simultaneously.</span></p>
			<p class="callout-heading">Keyboard shortcuts</p>
			<p class="callout">Note that each of these menu options has a keyboard shortcut associated with it. You can click on <strong class="bold">Editor</strong> -&gt; <strong class="bold">Editor Settings</strong> -&gt; <strong class="bold">3D</strong> to see and adjust the keyboard shortcuts to <span class="No-Break">your liking.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Adding 3D objects</h2>
			<p>It’s time to <a id="_idIndexMarker361"/>add your first 3D node. Just as all 2D nodes inherit from <strong class="source-inline">Node2D</strong>, which provides properties such as <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong>, 3D nodes inherit from <strong class="source-inline">Node3D</strong>, which provides spatial properties. Add one to the scene and you’ll see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B19289_05_03.jpg" alt="Figure 5.3: Node3D with a gizmo"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: Node3D with a gizmo</p>
			<p>That colorful object you see is not the node, but rather a<a id="_idIndexMarker362"/> 3D <strong class="bold">gizmo</strong>. The gizmo is a <a id="_idIndexMarker363"/>tool that allows you to move and rotate objects in space. The three rings control rotation, while the three arrows move the object along the three axes. Notice that the rings and arrows are color-coded to match the axis colors. The arrows move the object <em class="italic">along</em> the corresponding axis, while the rings rotate the object <em class="italic">around</em> a particular axis. There are also three small squares that lock one axis and allow you to move along the object in <span class="No-Break">a plane.</span></p>
			<p>Take a few <a id="_idIndexMarker364"/>minutes to experiment and get familiar with the gizmo. Delete the node and add another if you find yourself <span class="No-Break">getting lost.</span></p>
			<p>Sometimes the gizmo gets in the way. You can click on the mode icons to restrict yourself to only one type of transformation: <strong class="bold">Movement</strong>, <strong class="bold">Rotation</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="bold">Scaling</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B19289_05_04.jpg" alt="Figure 5.4: Select mode icons"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: Select mode icons</p>
			<p>The <em class="italic">Q</em>/<em class="italic">W</em>/<em class="italic">E</em>/<em class="italic">R</em> keys are shortcuts for these buttons, allowing you to quickly change <span class="No-Break">between modes.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Global versus local space</h2>
			<p>By default, the<a id="_idIndexMarker365"/> gizmo <a id="_idIndexMarker366"/>control operates in a global space. Try rotating the object – no matter how you turn it, the gizmo’s movement arrows still point along the global axes. Now try this: put the <strong class="source-inline">Node3D</strong> node back into its original position and orientation (or delete it and add a new one). Rotate the object around one axis and then click the <strong class="bold">Use Local Space</strong> button (note the <span class="No-Break"><strong class="bold">T</strong></span><span class="No-Break"> shortcut):</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B19289_05_05.jpg" alt="Figure 5.5: Toggling Local Space mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5: Toggling Local Space mode</p>
			<p>Observe<a id="_idIndexMarker367"/> what happens to the gizmo arrows. They now point <a id="_idIndexMarker368"/>along the object’s <em class="italic">local</em> axes and not the world’s axes. When you click and drag the arrows, they move the object relative to its own rotation. You can toggle back to global space by clicking the button again. Switching back and forth between these two modes can make it much easier to place an object exactly where you <span class="No-Break">want it.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Transforms</h2>
			<p>Look at the<a id="_idIndexMarker369"/> Inspector for <strong class="source-inline">Node3D</strong>. Under the <strong class="bold">Transform</strong> section, you’ll see the node’s <strong class="bold">Position</strong>, <strong class="bold">Rotation</strong>, and <strong class="bold">Scale</strong> properties. As you move the object around, you’ll see these values change. Just as in 2D, these values are <em class="italic">relative</em> to the <span class="No-Break">node’s parent.</span></p>
			<p>Together, these three quantities make up the node’s <strong class="bold">transform</strong> property. When changing the node’s spatial properties in code, you have access to its <strong class="source-inline">transform</strong> property, which is a Godot <strong class="source-inline">Transform3D</strong> object. <strong class="source-inline">Transform3D</strong> has two sub-properties: <strong class="source-inline">origin</strong> and <strong class="source-inline">basis</strong>. The <strong class="source-inline">origin</strong> property represents the body’s position, while the <strong class="source-inline">basis</strong> property contains three vectors that define the body’s local coordinate axes. Think of the three axis arrows in the gizmo when you were in <strong class="bold">Local </strong><span class="No-Break"><strong class="bold">Space</strong></span><span class="No-Break"> mode.</span></p>
			<p>You’ll see how to use these properties later in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Meshes</h2>
			<p>Just like <strong class="source-inline">Node2D</strong>, a <strong class="source-inline">Node3D</strong> node has no size or appearance of its own. In 2D, you added <strong class="source-inline">Sprite2D</strong> to display a texture attached to a node. In 3D, you’ll typically want to add a <strong class="bold">mesh</strong>. A mesh<a id="_idIndexMarker370"/> is a mathematical description of a three-dimensional shape. It consists of a collection of points<a id="_idIndexMarker371"/> called <strong class="bold">vertices</strong>. These vertices are connected by lines, called <strong class="bold">edges</strong>, and<a id="_idIndexMarker372"/> multiple edges (at least three) together <a id="_idIndexMarker373"/>make <span class="No-Break">a </span><span class="No-Break"><strong class="bold">face</strong></span><span class="No-Break">.</span></p>
			<p>A cube, for example, is composed of eight vertices, twelve edges, and <span class="No-Break">six faces:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B19289_05_06.jpg" alt="Figure 5.6: Vertices, edges, and faces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6: Vertices, edges, and faces</p>
			<p>If you’ve ever<a id="_idIndexMarker374"/> used 3D design software, this may already be familiar to you. If you haven’t, and you’re interested in learning about 3D modeling, <em class="italic">Blender</em> is a very popular open source tool for designing 3D objects. You can find many tutorials and lessons on the internet to help you get started <span class="No-Break">with Blender.</span></p>
			<h3>Primitives</h3>
			<p>If you haven’t already <a id="_idIndexMarker375"/>created or downloaded a 3D model, or if you just need a simple shape quickly, Godot has the ability to create certain 3D meshes directly. Add a <strong class="source-inline">MeshInstance3D</strong> node as a child of your <strong class="source-inline">Node3D</strong> node, and in the Inspector, look for the <span class="No-Break"><strong class="bold">Mesh</strong></span><span class="No-Break"> property:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B19289_05_07.jpg" alt="Figure 5.7: Adding a new mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7: Adding a new mesh</p>
			<p>These <a id="_idIndexMarker376"/>predefined shapes are <a id="_idIndexMarker377"/>called <strong class="bold">primitives</strong>, and they represent a handy collection of common useful shapes. Select <strong class="bold">New BoxMesh</strong> and you’ll see a cube appear on <span class="No-Break">the screen.</span></p>
			<h3>Importing meshes</h3>
			<p>Whatever<a id="_idIndexMarker378"/> modeling software you may use, you will need to export your models in a format that is readable by Godot. Godot supports a number of file formats <span class="No-Break">for importing:</span></p>
			<ul>
				<li><strong class="source-inline">glTF</strong> – supported in both text (<strong class="source-inline">.gltf</strong>) and binary (<strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">glb</strong></span><span class="No-Break">) versions</span></li>
				<li><strong class="source-inline">DAE (COLLADA)</strong> – an old format that is <span class="No-Break">still supported</span></li>
				<li><strong class="source-inline">OBJ (Wavefront)</strong> – supported, but limited due to the <span class="No-Break">format limitations</span></li>
				<li><strong class="source-inline">ESCN</strong> – a Godot-specific file format that Blender <span class="No-Break">can export</span></li>
				<li><strong class="source-inline">FBX</strong> – a commercial format that has <span class="No-Break">limited support</span></li>
			</ul>
			<p>The recommended format is <strong class="source-inline">.gltf</strong>. It has the most features and is very well supported in Godot. See <a id="_idIndexMarker379"/>the appendix for details about exporting <strong class="source-inline">.gltf</strong> files from Blender for use <span class="No-Break">in Godot.</span></p>
			<p>You’ll see how to import some pre-built <strong class="source-inline">.gltf</strong> scenes later in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Cameras</h2>
			<p>Try <a id="_idIndexMarker380"/>running the scene with your cube mesh. Where is it? In 3D, you won’t see anything in the game viewport unless you have a <strong class="source-inline">Camera3D</strong> camera in the scene. Add one, and you’ll see a new node that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B19289_05_08.jpg" alt="Figure 5.8: Camera widget"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8: Camera widget</p>
			<p>Use the camera’s gizmo to position it a little bit above and point toward <span class="No-Break">the cube:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B19289_05_09.jpg" alt="Figure 5.9: Aiming the camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9: Aiming the camera</p>
			<p>The pinkish-purple, pyramid-shaped object is called the<a id="_idIndexMarker381"/> camera’s <strong class="bold">frustum</strong>. It represents the camera’s view and can be made narrow or wide to affect the<a id="_idIndexMarker382"/> camera’s <strong class="bold">field of view</strong>. The triangular shape at the top of the frustum indicates the camera’s “<span class="No-Break">up” direction.</span></p>
			<p>As you’re moving the<a id="_idIndexMarker383"/> camera around, you can press the <strong class="bold">Preview</strong> button in the upper-right of the viewport to check what the camera sees. Go ahead and experiment with positioning the camera and adjusting <span class="No-Break">its </span><span class="No-Break"><strong class="bold">FOV</strong></span><span class="No-Break">.</span></p>
			<h3>Orientation</h3>
			<p>Note that <a id="_idIndexMarker384"/>the camera’s frustum faces along the <strong class="bold">-Z</strong>axis. This is the forward direction in Godot’s 3D space. For example, this is what you would do if you wanted to move a 3D object along its local forward axis where <strong class="source-inline">transform.basis</strong> is the object’s local set <span class="No-Break">of axes:</span></p>
			<pre class="source-code">
position += -transform.basis.z * speed * delta</pre>
			<p>These new concepts and editor functions will help you to navigate and work in 3D space. Refer back to this section if you need a reminder of what a particular 3D-related term means. In the next section, you’ll start setting up your first <span class="No-Break">3D project.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Project setup</h1>
			<p>Now that<a id="_idIndexMarker385"/> you’ve learned how to navigate in Godot’s 3D editor, you’re ready to start on the minigolf game. As with the other projects, download the game assets from the following link and unzip them into your project folder. The unzipped <strong class="source-inline">assets</strong> folder contains images, 3D models, and other items you’ll need to complete <span class="No-Break">the game.</span></p>
			<p>Create a new project and download the project assets <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition"><span class="No-Break">https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition</span></a><span class="No-Break">.</span></p>
			<p>You’ll notice a few different folders in <strong class="source-inline">assets</strong>. The <strong class="source-inline">courses</strong> folder has some pre-built minigolf holes for you to try out and compare to the ones you make. Don’t look at them yet – try and follow the steps to make your <span class="No-Break">own first.</span></p>
			<p>This game will use the left mouse click as an input. Open <strong class="bold">Project Settings</strong> and select the <strong class="bold">Input Map</strong> tab. Add a new action called <strong class="source-inline">click</strong> and then click the plus sign to add the <strong class="bold">Left Mouse Button</strong> input <span class="No-Break">to it:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B19289_05_10.jpg" alt="Figure 5.10: Assigning a mouse button input"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10: Assigning a mouse button input</p>
			<p>While <a id="_idIndexMarker386"/>you’re in <strong class="bold">Project Settings</strong>, you can also set how the game behaves when the game window is resized. During gameplay, the user may choose to resize the window, which could disrupt the layout of your UI or show a distorted view of the game. To prevent this, navigate to the <strong class="bold">Display/Window</strong> section and find the <strong class="bold">Stretch/Mode</strong> setting. Change it <span class="No-Break">to </span><span class="No-Break"><strong class="bold">viewport</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B19289_05_11.jpg" alt="Figure 5.11: Setting window stretch mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11: Setting window stretch mode</p>
			<p>That completes the setup of the project. Now, you can move on to building the first part of the game: the <span class="No-Break">minigolf course.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Creating the course</h1>
			<p>For the<a id="_idIndexMarker387"/> first scene, add a <strong class="source-inline">Node3D</strong> node called <strong class="source-inline">Hole</strong> and <a id="_idIndexMarker388"/>save the scene. As you did in <em class="italic">Jungle Jump</em>, you’re going to make a generic scene containing all the nodes and code that any hole will need, then inherit from this scene to make as many individual holes as you want to have in <span class="No-Break">the game.</span></p>
			<p>Next, add a <strong class="source-inline">GridMap</strong> node to <span class="No-Break">the scene.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Understanding GridMaps</h2>
			<p><strong class="source-inline">GridMap</strong> is the 3D <a id="_idIndexMarker389"/>equivalent of the <strong class="source-inline">TileMap</strong> node you used earlier in the book. It allows you to use a collection of meshes (contained in a <strong class="source-inline">MeshLibrary</strong> collection – similar to <strong class="source-inline">TileSet</strong>) and lay them out in a grid. Because it operates in 3D, you can stack the meshes in any direction, although for this project you’ll stick to <span class="No-Break">one plane.</span></p>
			<h3>Making a MeshLibrary collection</h3>
			<p>In the <strong class="source-inline">res://assets/</strong> folder, you’ll find a pre-generated <strong class="source-inline">MeshLibrary</strong> feature named <strong class="source-inline">golf_tiles.tres</strong> containing all the necessary course parts along with their <span class="No-Break">collision shapes.</span></p>
			<p>To create <a id="_idIndexMarker390"/>your own <strong class="source-inline">MeshLibrary</strong> function, you’ll make a 3D scene containing the individual meshes you want to use, add collisions to them, and then export that scene into a <strong class="source-inline">MeshLibrary</strong> collection. If you open <strong class="source-inline">golf_tiles.tscn</strong>, you’ll see the original scene that was used to <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">golf_tiles.tres</strong></span><span class="No-Break">.</span></p>
			<p>In this scene, you’ll see all the individual golf course tile meshes, as they were imported from Blender, where they were originally modeled. To add collision shapes to each one, Godot has a handy shortcut: select a mesh and you’ll see a <strong class="bold">Mesh</strong> menu appear in the toolbar at the top of <span class="No-Break">the viewport:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B19289_05_12.jpg" alt="Figure 5.12: The Mesh menu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12: The Mesh menu</p>
			<p>Select <strong class="bold">Create Trimesh Static Body</strong> and Godot will add a <strong class="source-inline">StaticBody3D</strong> node along with a <strong class="source-inline">CollisionShape3D</strong> node using the <span class="No-Break">mesh’s data.</span></p>
			<p>Once all the collisions<a id="_idIndexMarker391"/> are added, you can choose <strong class="bold">Scene</strong> -&gt; <strong class="bold">Export As</strong> -&gt; <strong class="bold">Mesh Library</strong> to convert the scene into a Resource that <strong class="source-inline">GridMap</strong> <span class="No-Break">can use.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Drawing the first hole</h2>
			<p>Drag<a id="_idIndexMarker392"/> the <strong class="source-inline">MeshLibrary</strong> file into the <strong class="bold">Mesh Library</strong> property of the <strong class="source-inline">GridMap</strong> node. You’ll see a list of the available tiles appear on the right side of the <span class="No-Break">editor viewport.</span></p>
			<p>To match the size of the tiles, set <strong class="bold">Cell/Size</strong> to <strong class="source-inline">(1, </strong><span class="No-Break"><strong class="source-inline">1, 1)</strong></span><span class="No-Break">.</span></p>
			<p>To make sure the collisions with the ball will look good, find <strong class="bold">Physics Material</strong> and set its <strong class="bold">Rough</strong> setting to <strong class="bold">On</strong> and <strong class="bold">Bounce</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.5</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B19289_05_13.jpg" alt="Figure 5.13: Working with Physics Material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13: Working with Physics Material</p>
			<p>Try drawing by selecting a tile piece from the list and placing it in the scene by left-clicking. You can rotate a piece around the <strong class="source-inline">y</strong> axis by pressing <strong class="bold">S</strong>. To remove a tile, right-click <span class="No-Break">on it.</span></p>
			<p>For now, stick to a simple layout. You can get fancy later when everything <span class="No-Break">is working:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B19289_05_14.jpg" alt="Figure 5.14: Example course layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14: Example course layout</p>
			<p>You can check <a id="_idIndexMarker393"/>out what this will look like when the game runs. Add a <strong class="source-inline">Camera3D</strong> feature to the scene and move it to a position where it can look down on the course. Remember, you can press <strong class="bold">Preview</strong> to check what the <span class="No-Break">camera sees.</span></p>
			<p>Play the scene. You’ll notice that everything is very dark, unlike how it looks in the editor window. By default, a 3D scene has no <em class="italic">environment</em> or <span class="No-Break"><em class="italic">lighting</em></span><span class="No-Break"> configured.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Environment and lighting</h2>
			<p>Lighting is a<a id="_idIndexMarker394"/> complex subject all on its own. Choosing where to<a id="_idIndexMarker395"/> place lights and how they’re configured can dramatically affect how a <span class="No-Break">scene looks.</span></p>
			<p>Godot provides three lighting nodes <span class="No-Break">in 3D:</span></p>
			<ul>
				<li><strong class="source-inline">OmniLight3D</strong>: For light that is emitted in all directions, such as from a <span class="No-Break">light bulb</span></li>
				<li><strong class="source-inline">DirectionalLight3D</strong>: Light from a distant source, such <span class="No-Break">as sunlight</span></li>
				<li><strong class="source-inline">SpotLight3D</strong>: A cone-shaped light projected from a point, similar to a flashlight <span class="No-Break">or lantern</span></li>
			</ul>
			<p>In addition to<a id="_idIndexMarker396"/> placing individual lights, you can also set up <em class="italic">ambient</em> light – light that is produced by the environment – using a <span class="No-Break"><strong class="source-inline">WorldEnvironment</strong></span><span class="No-Break"> node.</span></p>
			<p>Rather than start from scratch, Godot will let you start with the default lighting setup that you see in the editor window using the buttons in <span class="No-Break">the toolbar:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B19289_05_15.jpg" alt="Figure 5.15: Lighting and environment settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15: Lighting and environment settings</p>
			<p>The first two buttons<a id="_idIndexMarker397"/> allow you to toggle the preview sun (directional light) and environment. Note that the environment doesn’t just affect lighting, it generates a sky texture <span class="No-Break">as well.</span></p>
			<p>If you click on the three dots, you can see the default settings for these. Click the <strong class="bold">Add</strong> buttons to add them both as nodes in your scene. You’ll now have the <strong class="source-inline">WorldEnvironment</strong> node and a <strong class="source-inline">DirectionalLight3D</strong> node in <span class="No-Break">your scene.</span></p>
			<p>If you zoom in on your mesh, you may notice that the shadows don’t look very good. The default shadow settings need to be adjusted, so select <strong class="source-inline">DirectionalLight3D</strong> and change <strong class="bold">Max Distance</strong> from <strong class="source-inline">100</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">40</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>Adding the hole</h2>
			<p>Now that you <a id="_idIndexMarker398"/>have the course laid out, you need a way to detect when the ball falls into <span class="No-Break">the hole.</span></p>
			<p>Add an <strong class="source-inline">Area3D</strong> node named <strong class="source-inline">Hole</strong>. This node works exactly like its 2D version – it can signal when a body enters its defined shape. Add a <strong class="source-inline">CollisionShape3D</strong> child to the area. In the <strong class="bold">Shape</strong> property, choose <strong class="bold">New CylinderShape3D</strong> and set its <strong class="bold">Height</strong> to <strong class="source-inline">0.25</strong> and <strong class="bold">Radius</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.08</strong></span><span class="No-Break">.</span></p>
			<p>Position <strong class="source-inline">Hole</strong> where you placed the hole tile for your course. Make sure the cylinder shape doesn’t project above the top of the hole, or the ball will count as “in” when it hasn’t dropped in yet. You might find it useful to use the <strong class="bold">Perspective</strong> button and change to <strong class="bold">Top View</strong> to make sure you’ve got it <span class="No-Break">centered properly:</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B19289_05_16.jpg" alt="Figure 5.16: Positioning the hole"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16: Positioning the hole</p>
			<p>You also need to mark the starting position for the ball, so add a <strong class="source-inline">Marker3D</strong> node named <strong class="source-inline">Tee</strong> to the scene. Position it where you want the ball to start. Make sure you place it above the surface so that the ball doesn’t spawn inside <span class="No-Break">the ground.</span></p>
			<p>With that, you’re finished making the first course. Take a few minutes to look around and make sure<a id="_idIndexMarker399"/> you’re happy with the layout. Remember, this shouldn’t be a complex or challenging layout. It’s going to introduce the player to the game, and you’ll be using it to test that everything is working correctly later. To do that, you next need to create the <span class="No-Break">golf ball.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/>Making the ball</h1>
			<p>Since the ball <a id="_idIndexMarker400"/>needs physics – gravity, friction, collision with walls, and so on – <strong class="source-inline">RigidBody3D</strong> will be the best choice of node. Rigid bodies work similarly in 3D to the ones you’ve used before in 2D, and you’ll use the same methods to interact with them, such as <strong class="source-inline">_integrate_forces()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">apply_impulse()</strong></span><span class="No-Break">.</span></p>
			<p>Create a new scene with a <strong class="source-inline">RigidBody3D</strong> node named <strong class="source-inline">Ball</strong> and <span class="No-Break">save it.</span></p>
			<p>Since you need a simple sphere shape and Godot includes primitive shapes, there’s no need for a fancy 3D model here. Add a <strong class="source-inline">MeshInstance3D</strong> child and choose <strong class="bold">New SphereMesh</strong> for the <strong class="bold">Mesh</strong> property in <span class="No-Break">the Inspector.</span></p>
			<p>The default size is much too large, so click on the <strong class="bold">Mesh</strong> property to expand it and set <strong class="bold">Radius</strong> to <strong class="source-inline">0.05</strong> and <strong class="bold">Height</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.1</strong></span><span class="No-Break">.</span></p>
			<p>Add a <strong class="source-inline">CollisionShape3D</strong> node and give it a <strong class="source-inline">SphereShape3D</strong>. Set its <strong class="bold">Radius</strong> setting to <strong class="source-inline">0.05</strong> to match <span class="No-Break">the mesh.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Testing the ball</h2>
			<p>Add an<a id="_idIndexMarker401"/> instance of the <strong class="source-inline">Ball</strong> scene to your course. Position it over one of the tiles and play the scene. You should see the ball fall and land on <span class="No-Break">the ground.</span></p>
			<p>You can also temporarily give the ball some motion by setting the <strong class="bold">Linear/Velocity</strong> property. Try setting it to different values and playing the scene. Remember that the <strong class="source-inline">y</strong>axis is up. Don’t forget to set it back to <strong class="source-inline">(0, 0, 0)</strong> before you <span class="No-Break">move on.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Improving ball collisions</h2>
			<p>You<a id="_idIndexMarker402"/> may have noticed when adjusting the velocity that the ball sometimes goes through the wall and/or bounces oddly, especially if you choose a high-velocity value. There are several things you can do to improve the <span class="No-Break">ball’s behavior.</span></p>
			<p>First, you can <a id="_idIndexMarker403"/>use <strong class="bold">continuous collision detection</strong> (<strong class="bold">CCD</strong>). Using CCD alters the way the physics engine calculates collisions. Normally, the engine operates by first moving the object and then testing for and resolving collisions. This is fast and works for most common situations. When using CCD, the engine projects the object’s movement along its path and attempts to predict where the collision may occur. This is slower (computationally) than the default behavior, especially when simulating many objects, but it is much more accurate. Since you only have one ball in a very small environment, CCD is a good option because it won’t introduce any noticeable performance penalty. You can find <a id="_idIndexMarker404"/>it in the Inspector as <span class="No-Break"><strong class="bold">Continuous CD</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B19289_05_17.jpg" alt="Figure 5.17: The ﻿CCD toggle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17: The CCD toggle</p>
			<p>The ball also needs a little more action, so in the <strong class="bold">Physics Material</strong> property, choose <strong class="bold">New</strong> and set the <strong class="bold">Bounce</strong> value to <strong class="source-inline">0.25</strong>. This property determines how “bouncy” a collision will be. The value can range from <strong class="source-inline">0</strong> (no bounce at all) to <strong class="source-inline">1.0</strong> (<span class="No-Break">the bounciest):</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B19289_05_18.jpg" alt="Figure 5.18: Physics material bounce settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18: Physics material bounce settings</p>
			<p>You may also have noticed that the ball takes a long time to come to a complete stop. Set the <strong class="bold">Linear/Damp</strong> property to <strong class="source-inline">0.5</strong> and <strong class="bold">Angular/Damp</strong> to <strong class="source-inline">1</strong>. These values can be thought of as analogous to air resistance – causing the object to slow down regardless of interaction with the surface. Increasing these means the player won’t have to wait as long for the ball to stop moving, and it won’t appear to be spinning in place after it <span class="No-Break">stops rolling.</span></p>
			<p>You’re finished <a id="_idIndexMarker405"/>setting up the ball, but here’s another good place to pause and make sure you have everything the way you want it before moving on. Does the ball feel like it’s bouncing and rolling convincingly? When it hits a wall, does it bounce too much or too little? When you’ve adjusted the ball’s behavior to your satisfaction, move on to the next section, where you’ll set up how to launch <span class="No-Break">the ball.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/>Adding UI</h1>
			<p>Now that<a id="_idIndexMarker406"/> the ball is on the course, you need a way to aim and hit it. There are many possible control schemes for this type of game. For this project, you’ll use a <span class="No-Break">two-step process:</span></p>
			<ol>
				<li><strong class="bold">Aim</strong>: An arrow appears, swinging back and forth. Clicking the mouse button sets the <span class="No-Break">aim direction.</span></li>
				<li><strong class="bold">Shoot</strong>: A power bar moves up and down. Clicking the mouse sets the power and launches <span class="No-Break">the ball.</span></li>
			</ol>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>Aiming the arrow</h2>
			<p>Drawing an<a id="_idIndexMarker407"/> object in 3D is not as easy as it is in 2D. In many cases, you’ll have to switch to a 3D modeling program such as Blender to create your game’s objects. However, in this case, Godot’s primitives will do fine. To make an arrow, you need two meshes: a long thin rectangle and a <span class="No-Break">triangular prism.</span></p>
			<p class="callout-heading">Making your own model</p>
			<p class="callout">If you’re comfortable using a separate 3D modeling program such as <em class="italic">Blender</em>, feel free to use that to create the arrow mesh instead of following the following procedure. Just drop the exported model into your Godot project folder and load it with a <strong class="source-inline">MeshInstance3D</strong> node. See the last chapter for details about importing models directly <span class="No-Break">from Blender.</span></p>
			<p>Start a new scene by adding a <strong class="source-inline">Node3D</strong> node called <strong class="source-inline">Arrow</strong> and give it a <strong class="source-inline">MeshInstance3D</strong> child. Give this mesh a <strong class="source-inline">BoxMesh</strong> function and set the box’s <strong class="bold">Size</strong> setting to <strong class="source-inline">(0.5, 0.2, 2)</strong>. This will be the body of the arrow, but before moving on, there is a problem. If you rotate the parent node, the mesh rotates around its center. You need it to rotate around its end, so change the <strong class="bold">Position</strong> setting of the <strong class="source-inline">MeshInstance3D</strong> node to <strong class="source-inline">(0, 0, -1)</strong>. Remember, this property is measured relative to the node’s parent, so this is offsetting the mesh from the <span class="No-Break"><strong class="source-inline">Node3D</strong></span><span class="No-Break"> node:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B19289_05_19.jpg" alt="Figure 5.19: Offsetting the base"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19: Offsetting the base</p>
			<p>Try rotating the root node (<strong class="source-inline">Arrow</strong>) with the gizmo to confirm that the shape is now <span class="No-Break">offset correctly.</span></p>
			<p>When it’s viewed in the game, the arrow should be semi-transparent. You can also give it a color to make it stand out more. To change a mesh’s visual properties, you need to <span class="No-Break">use </span><span class="No-Break"><strong class="bold">Material</strong></span><span class="No-Break">.</span></p>
			<p>Under the<a id="_idIndexMarker408"/> mesh properties (where you set the size), you’ll see a <strong class="bold">Material</strong> property that’s currently empty. Click the arrow to create a new <strong class="source-inline">StandardMaterial3D</strong> node in <span class="No-Break">this box:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B19289_05_20.jpg" alt="Figure 5.20: Offsetting the base"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20: Offsetting the base</p>
			<p>If you click this new material object to expand it, you’ll see a long list of new properties. Don’t worry, there are only two that you need <span class="No-Break">to change.</span></p>
			<p>First, expand the <strong class="bold">Transparency</strong> section and set <strong class="bold">Transparency</strong> to <strong class="bold">Alpha</strong>. This property tells the rendering engine that this object can allow light to pass <span class="No-Break">through it.</span></p>
			<p>Next, the color of an object is set in the <strong class="bold">Albedo</strong> section. Click the <strong class="bold">Color</strong> property and choose a yellowish color. Make sure to set the <strong class="bold">Alpha</strong> value to something around the middle, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">128</strong></span><span class="No-Break">.</span></p>
			<p>Now, to create the pointy end of the arrow, add another <strong class="source-inline">MeshInstance3D</strong> node, and this time, choose a <strong class="source-inline">PrismMesh</strong> mesh. Set its <strong class="bold">Size</strong> setting to <strong class="source-inline">(1.5, 1.5, 0.2)</strong> so that you have a flat triangular shape. To place it at the end of the rectangle, change its <strong class="bold">Position</strong> setting to (<strong class="source-inline">0, 0, -2.75)</strong> and its <strong class="bold">Rotation</strong> setting to <strong class="source-inline">(-90, </strong><span class="No-Break"><strong class="source-inline">0, 0)</strong></span><span class="No-Break">.</span></p>
			<p>Finally, scale the whole arrow down by setting the root node’s <strong class="bold">Scale</strong> setting to (<strong class="source-inline">0.25, </strong><span class="No-Break"><strong class="source-inline">0.25, 0.25)</strong></span><span class="No-Break">.</span></p>
			<p>You also need to set<a id="_idIndexMarker409"/> the prism’s material just as you did with the other section. To do this quickly, select the box shape and find its material property again. In the dropdown for the material, choose <strong class="bold">Copy</strong>. You can then go to the prism mesh and paste the same material onto it. Note that since they have the same material, any change you make to one shape will apply to <span class="No-Break">both shapes:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B19289_05_21.jpg" alt="Figure 5.21: Positioning the arrow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21: Positioning the arrow</p>
			<p>Your aiming <a id="_idIndexMarker410"/>arrow is complete. Save the scene and instance it into your <span class="No-Break"><strong class="source-inline">Hole</strong></span><span class="No-Break"> scene.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>UI display</h2>
			<p>Create a<a id="_idIndexMarker411"/> new scene using a <strong class="source-inline">CanvasLayer</strong> layer named <strong class="source-inline">UI</strong>. In this scene, you’ll show the power bar as well as the shot count for the player’s score. Just as it did in 2D, this node will cause its contents to be drawn above the <span class="No-Break">main scene.</span></p>
			<p>Add a <strong class="source-inline">Label</strong> node, then a <strong class="source-inline">MarginContainer</strong> node. In that, add a <strong class="source-inline">VboxContainer</strong> node, and in that, two <strong class="source-inline">Label</strong> nodes and a <strong class="source-inline">TextureProgressBar</strong> node. Name them <span class="No-Break">as shown:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B19289_05_22.jpg" alt="Figure 5.22: The UI node layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22: The UI node layout</p>
			<p>In the <strong class="source-inline">MarginContainer</strong> section, set <strong class="bold">Theme Overrides/Constants</strong> to <strong class="source-inline">20</strong>. Add the <strong class="source-inline">Xolonium-Regular.ttf</strong> font to both of the <strong class="source-inline">Label</strong> nodes and set their font sizes to <strong class="source-inline">30</strong>. Set the <strong class="bold">Text</strong> setting of <strong class="source-inline">Shots</strong> to <strong class="bold">Shots: 0</strong> and <strong class="source-inline">PowerLabel</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Power</strong></span><span class="No-Break">.</span></p>
			<p>Add the font<a id="_idIndexMarker412"/> for the <strong class="source-inline">Message</strong> label, using a larger font size of <strong class="source-inline">80</strong>, and set its text to <strong class="source-inline">Get Ready!</strong>. Choose <strong class="bold">Center</strong> from the <strong class="bold">Anchor Presets</strong> menu, then click the eye symbol next to the message to <span class="No-Break">hide it.</span></p>
			<p>Drag one of the colored bar textures from <strong class="source-inline">res://assets</strong> into the <strong class="bold">Texture/Progress</strong> section of <strong class="source-inline">PowerBar</strong>. By default, <strong class="source-inline">TextureProgressBar</strong> grows from left to right, so for a vertical orientation, change <strong class="bold">Fill Mode</strong> to <strong class="bold">Bottom to Top</strong>. Change <strong class="bold">Value</strong> to a few different values to see <span class="No-Break">the result.</span></p>
			<p>The completed UI layout should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B19289_05_23.jpg" alt="Figure 5.23: The UI preview"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.23: The UI preview</p>
			<p>Add an <a id="_idIndexMarker413"/>instance of <strong class="source-inline">UI</strong> in the <strong class="source-inline">Hole</strong> scene. Because it’s <strong class="source-inline">CanvasLayer</strong>, it will be drawn on top of the 3D <span class="No-Break">camera view.</span></p>
			<p>Now that you’ve finished drawing the course and you’ve added the UI, you have all of the visual elements that the player will see while playing. Your next task will be to make these parts work together by adding <span class="No-Break">some code.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Scripting the game</h1>
			<p>In this <a id="_idIndexMarker414"/>section, you’ll create the scripts needed to make everything work together. The flow of the game will be <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Place the ball at <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Tee</strong></span><span class="No-Break">.</span></li>
				<li>Switch to <strong class="bold">Aim</strong> mode and animate the arrow until the <span class="No-Break">player clicks.</span></li>
				<li>Switch to <strong class="bold">Power</strong> mode and animate the power bar until the <span class="No-Break">player clicks.</span></li>
				<li>Launch <span class="No-Break">the ball.</span></li>
				<li>Repeat the process from <em class="italic">step 2</em> until the ball falls into <span class="No-Break">the hole.</span></li>
			</ol>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>UI code</h2>
			<p>Add this script to<a id="_idIndexMarker415"/> the <strong class="source-inline">UI</strong> instance to update the <span class="No-Break">UI elements:</span></p>
			<pre class="source-code">
extends CanvasLayer
@onready var power_bar = $MarginContainer/VBoxContainer/PowerBar
@onready var shots = $MarginContainer/VBoxContainer/Shots
var bar_textures = {
    "green": preload("res://assets/bar_green.png"),
    "yellow": preload("res://assets/bar_yellow.png"),
    "red": preload("res://assets/bar_red.png")
}
func update_shots(value):
    shots.text = "Shots: %s" % value
func update_power_bar(value):
    power_bar.texture_progress = bar_textures["green"]
    if value &gt; 70:
        power_bar.texture_progress = bar_textures["red"]
    elif value &gt; 40:
        power_bar.texture_progress = bar_textures["yellow"]
    power_bar.value = value
func show_message(text):
    $Message.text = text
    $Message.show()
    await get_tree().create_timer(2).timeout
    $Message.hide()</pre>
			<p>These <a id="_idIndexMarker416"/>functions provide a way to update the UI elements when they need to display a new value. As you did in <em class="italic">Space Rocks</em>, changing the progress bar’s texture based on its value gives a nice low/medium/high feel to the <span class="No-Break">power level.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>Main script</h2>
			<p>Add a script<a id="_idIndexMarker417"/> to the <strong class="source-inline">Hole</strong> scene and start with <span class="No-Break">these variables:</span></p>
			<pre class="source-code">
extends Node3D
enum {AIM, SET_POWER, SHOOT, WIN}
@export var power_speed = 100
@export var angle_speed = 1.1
var angle_change = 1
var power = 0
var power_change = 1
var shots = 0
var state = AIM</pre>
			<p>The <strong class="source-inline">enum</strong> lists the states the game can be in, while the <strong class="source-inline">power</strong> and <strong class="source-inline">angle</strong> variables will be used to set their respective values and change them over time. You can control the animation speed (and therefore the difficulty) by adjusting the two <span class="No-Break">exported variables.</span></p>
			<p>Next, set the initial values before starting <span class="No-Break">to play:</span></p>
			<pre class="source-code">
func _ready():
    $Arrow.hide()
    $Ball.position = $Tee.position
    change_state(AIM)
    $UI.show_message("Get Ready!")</pre>
			<p>The<a id="_idIndexMarker418"/> ball gets moved to the tee position, and you change to the <strong class="source-inline">AIM</strong> state <span class="No-Break">to begin.</span></p>
			<p>Here’s what needs to happen for each <span class="No-Break">game state:</span></p>
			<pre class="source-code">
func change_state(new_state):
    state = new_state
    match state:
        AIM:
            $Arrow.position = $Ball.position
            $Arrow.show()
        SET_POWER:
            power = 0
        SHOOT:
            $Arrow.hide()
            $Ball.shoot($Arrow.rotation.y, power / 15)
            shots += 1
            $UI.update_shots(shots)
        WIN:
            $Ball.hide()
            $Arrow.hide()
            $UI.show_message("Win!")</pre>
			<p><strong class="source-inline">AIM</strong> places the aiming arrow at the ball’s position and makes it visible. Recall that you offset the arrow, so it will appear to be pointing out from the ball. When you rotate the arrow, you’ll rotate it around the <strong class="source-inline">y</strong> axis so that it remains parallel to <span class="No-Break">the ground.</span></p>
			<p>Also, note<a id="_idIndexMarker419"/> that when entering the <strong class="source-inline">SHOOT</strong> state, you call the <strong class="source-inline">shoot()</strong> function on the ball, which you haven’t defined yet. You’ll add that in the <span class="No-Break">next section.</span></p>
			<p>The next step is to check for <span class="No-Break">user input:</span></p>
			<pre class="source-code">
func _input(event):
    if event.is_action_pressed("click"):
        match state:
            AIM:
                change_state(SET_POWER)
            SET_POWER:
                change_state(SHOOT)</pre>
			<p>The only input for the game (so far) is clicking the left mouse button. Depending on what state you’re currently in, clicking it will transition to the <span class="No-Break">next state.</span></p>
			<p>In <strong class="source-inline">_process()</strong>, you’ll determine what to animate based on the state. For now, it just calls the function that animates the <span class="No-Break">appropriate property:</span></p>
			<pre class="source-code">
func _process(delta):
    match state:
        AIM:
            animate_arrow(delta)
        SET_POWER:
            animate_power(delta)
        SHOOT:
            pass</pre>
			<p>Both of these functions are similar. They gradually change a value between two extremes, reversing direction when the limit is reached. Note that the arrow is animating<a id="_idIndexMarker420"/> over a 180° range (+90° <span class="No-Break">to -90°):</span></p>
			<pre class="source-code">
func animate_arrow(delta):
    $Arrow.rotation.y += angle_speed * angle_change * delta
    if $Arrow.rotation.y &gt; PI / 2:
        angle_change = -1
    if $Arrow.rotation.y &lt; -PI / 2:
        angle_change = 1
func animate_power(delta):
    power += power_speed * power_change * delta
    if power &gt;= 100:
        power_change = -1
    if power &lt;= 0:
        power_change = 1
    $UI.update_power_bar(power)</pre>
			<p>To detect when the ball drops into the hole, select the <strong class="source-inline">Area3D</strong> node that you positioned at the hole and connect its <span class="No-Break"><strong class="source-inline">body_entered</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_hole_body_entered(body):
    if body.name == "Ball":
        print("win!")
        change_state(WIN)</pre>
			<p>Lastly, the player will need to be able to start the whole process again after the ball comes to <span class="No-Break">a stop.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>Ball script</h2>
			<p>In the <a id="_idIndexMarker421"/>ball’s script, there are two functions needed. First, an <em class="italic">impulse</em> must be applied to the ball to start it moving. Second, when the ball stops moving, it needs to notify the main scene so that the player can take the <span class="No-Break">next shot.</span></p>
			<p>Make sure you add this script to the <strong class="source-inline">Ball</strong> scene, not the instance of the ball in the <span class="No-Break"><strong class="source-inline">Hole</strong></span><span class="No-Break"> scene:</span></p>
			<pre class="source-code">
extends RigidBody3D
signal stopped
func shoot(angle, power):
    var force = Vector3.FORWARD.rotated(Vector3.UP, angle)
    apply_central_impulse(force * power)
func _integrate_forces(state):
    if state.linear_velocity.length() &lt; 0.1:
        stopped.emit()
        state.linear_velocity = Vector3.ZERO
    if position.y &lt; -20:
        get_tree().reload_current_scene()</pre>
			<p>As you saw in the <em class="italic">Space Rocks</em> game, you can use the physics state in <strong class="source-inline">_integrate_forces()</strong> to safely stop the ball if the speed has gotten very low. Due to floating point issues, the velocity may not slow to <strong class="source-inline">0</strong> on its own. Its <strong class="source-inline">linear_velocity</strong> value may be something like <strong class="source-inline">0.00000001</strong> for quite some time after it appears to stop. Rather than wait, you can just stop the ball if the speed falls <span class="No-Break">below </span><span class="No-Break"><strong class="source-inline">0.1</strong></span><span class="No-Break">.</span></p>
			<p>There’s also the chance that the ball happens to bounce over the wall and fall off the course. If this <a id="_idIndexMarker422"/>happens, you can reload the scene to let the player <span class="No-Break">start over.</span></p>
			<p>Go back to the <strong class="source-inline">Hole</strong> scene and connect the <strong class="source-inline">Ball</strong> instance’s <span class="No-Break"><strong class="source-inline">stopped</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_ball_stopped():
    if state == SHOOT:
        change_state(AIM)</pre>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor175"/>Testing it out</h2>
			<p>Try playing <a id="_idIndexMarker423"/>the scene. You should see the arrow rotating at the ball’s position. When you click the mouse button, the arrow stops, and the power bar starts moving up and down. When you click again, the ball <span class="No-Break">is launched.</span></p>
			<p>If any of those steps don’t work, don’t go any further. Go back and try to find what you missed in the <span class="No-Break">previous section.</span></p>
			<p>Once everything is working, you’ll notice some areas that need improvement. First, when the ball stops moving, the arrow may not point in the direction you want. The reason for this is that the starting angle is always <strong class="source-inline">0</strong>, which points along the <strong class="source-inline">z</strong>axis, and then the arrow swings +/-90° from there. In the next two sections, you’ll have a choice of two options for how to improve <span class="No-Break">the aiming.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>Option 1 for improving aiming</h2>
			<p>Aiming <a id="_idIndexMarker424"/>can be improved by pointing the 180° arc directly toward the hole at <span class="No-Break">the beginning.</span></p>
			<p>Add a variable called <strong class="source-inline">hole_dir</strong> to the top of the script. You can find this direction by using some <span class="No-Break">vector math:</span></p>
			<pre class="source-code">
func set_start_angle():
    var hole_position = Vector2($Hole.position.z,
        $Hole.position.x)
    var ball_position = Vector2($Ball.position.z,
        $Ball.position.x)
    hole_dir = (ball_position - hole_position).angle()
    $Arrow.rotation.y = hole_dir</pre>
			<p>Remember<a id="_idIndexMarker425"/> that the ball’s position is its center, so it’s slightly above the surface, while the hole’s center is a bit below it. Because of this, a vector pointing from the ball to the hole would also point at a downward angle into the ground. To prevent this and keep the arrow level, you can use only the <strong class="source-inline">x</strong> and <strong class="source-inline">z</strong> values from the <strong class="source-inline">position</strong> to <span class="No-Break">produce </span><span class="No-Break"><strong class="source-inline">Vector2</strong></span><span class="No-Break">.</span></p>
			<p>Now, the initial angle can be set when starting the <span class="No-Break"><strong class="source-inline">AIM</strong></span><span class="No-Break"> state:</span></p>
			<pre class="source-code">
func change_state(new_state):
    state = new_state
    match state:
        AIM:
            $Arrow.position = $Ball.position
            $Arrow.show()
            set_start_angle()</pre>
			<p>And the animation of the arrow can use that initial direction as the basis for the +/-<span class="No-Break">90° swing:</span></p>
			<pre class="source-code">
func animate_arrow(delta):
    $Arrow.rotation.y += angle_speed * angle_change * delta
    if $Arrow.rotation.y &gt; hole_dir + PI / 2:
        angle_change = -1
    if $Arrow.rotation.y &lt; hole_dir - PI / 2:
        angle_change = 1</pre>
			<p>Try playing again. The arrow should now always point in the general direction of the hole. This is better, but you still may have a difficult <span class="No-Break">time aiming.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Option 2 for improving aiming</h2>
			<p>If you’d <a id="_idIndexMarker426"/>prefer to have more control over your aiming, then instead of animating the arrow and clicking to set the aim, you could directly control the arrow by moving the <span class="No-Break">mouse side-to-side.</span></p>
			<p>To accomplish this, you can make use of one of Godot’s <strong class="source-inline">InputEvent</strong> types: <strong class="source-inline">InputEventMouseMotion</strong>. This event occurs whenever the mouse moves, and it includes a <strong class="source-inline">relative</strong> property representing how far the mouse moved in the previous frame. You can use this value to rotate that arrow by a <span class="No-Break">small amount.</span></p>
			<p>First, disable the arrow animation by removing the <strong class="source-inline">AIM</strong> section <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">_process()</strong></span><span class="No-Break">.</span></p>
			<p>Add a variable so that you can control how much the arrow will rotate based on the <span class="No-Break">mouse movement:</span></p>
			<pre class="source-code">
@export var mouse_sensitivity = 150</pre>
			<p>Then, write the following code to <strong class="source-inline">_input()</strong> to check for mouse movement and rotate <span class="No-Break">the arrow:</span></p>
			<pre class="source-code">
func _input(event):
    if event is InputEventMouseMotion:
        if state == AIM:
            $Arrow.rotation.y -= event.relative.x / mouse_sensitivity</pre>
			<h3>Capturing the mouse</h3>
			<p>You <a id="_idIndexMarker427"/>may have noticed that as you’re moving the mouse, it can leave the game window, and when you click, you don’t interact with the game anymore. Most 3D games solve this problem by <em class="italic">capturing</em> the mouse – locking the mouse to the window. When you do this, you also need to give the player a way to free the mouse so that they can close the program or click on other windows, and a way to re-capture it to come back to <span class="No-Break">the game.</span></p>
			<p>For this game, you’ll capture the mouse at first, and then if the player presses <em class="italic">Esc</em>, free it and pause the game. Clicking in the game window will un-pause <span class="No-Break">and resume.</span></p>
			<p>All of this functionality is controlled through the <strong class="source-inline">Input.mouse_mode</strong> property. Then, <strong class="source-inline">mouse_mode</strong> can be set to one of the <span class="No-Break">following values:</span></p>
			<ul>
				<li><strong class="source-inline">MOUSE_MODE_VISIBLE</strong>: This is the default mode. The mouse is visible and free to move in and out of <span class="No-Break">the window.</span></li>
				<li><strong class="source-inline">MOUSE_MODE_HIDDEN</strong>: The mouse cursor <span class="No-Break">is hidden.</span></li>
				<li><strong class="source-inline">MOUSE_MODE_CAPTURED</strong>: The mouse is hidden and its position is locked to <span class="No-Break">the window.</span></li>
				<li><strong class="source-inline">MOUSE_MODE_CONFINED</strong>: The mouse is visible, but confined to <span class="No-Break">the window.</span></li>
			</ul>
			<p>Start by <a id="_idIndexMarker428"/>capturing the mouse <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Input.mouse_mode = Input.MOUSE_MODE_CAPTURED</pre>
			<p>In <strong class="source-inline">_process()</strong>, you don’t want to animate things while the mouse <span class="No-Break">is released:</span></p>
			<pre class="source-code">
func _process(delta):
    if Input.mouse_mode == Input.MOUSE_MODE_VISIBLE:
        return</pre>
			<p>To release the mouse, add this condition <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_input()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if event.is_action_pressed("ui_cancel") and Input.mouse_mode == Input.MOUSE_MODE_CAPTURED:
    Input.mouse_mode = Input.MOUSE_MODE_VISIBLE</pre>
			<p>Then, to re-capture the mouse when the window is clicked, add this right <span class="No-Break">before </span><span class="No-Break"><strong class="source-inline">match_state</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if event.is_action_pressed("click"):
    if Input.mouse_mode == Input.MOUSE_MODE_VISIBLE:
        Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
        return</pre>
			<p>Play the scene to try <span class="No-Break">it out.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Camera improvements</h2>
			<p>Another <a id="_idIndexMarker429"/>problem, especially if you have laid out a relatively large course, is that if you place your camera near the tee, it won’t show the other parts of the course well, or at all. You need your camera to move, showing other parts of the course so the player can <span class="No-Break">aim comfortably.</span></p>
			<p>There are two main ways you could address <span class="No-Break">this problem:</span></p>
			<ol>
				<li>Multiple cameras: place several cameras at different locations around the course. Attach <strong class="source-inline">Area3D</strong> nodes to them, and when the ball enters a camera’s area, make that camera active by setting its <strong class="source-inline">current</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
				<li>Moving camera: stick to having one camera, but make it move along with the ball, so the player’s perspective is always based on the <span class="No-Break">ball’s location.</span></li>
			</ol>
			<p>Both of these schemes have pros and cons. Option 1 requires more planning, deciding exactly where to position the cameras, and how many to use. For that reason, this section will focus on <span class="No-Break">option 2.</span></p>
			<p>In many 3D games, the player can control a camera that rotates and moves. Typically, this control scheme uses a combination of mouse and keyboard. Since you’re already using mouse movement for aiming (if you chose that option), the <em class="italic">W</em>/<em class="italic">A</em>/<em class="italic">S</em>/<em class="italic">D</em> keys are a good choice. The mouse wheel can be used to control the <span class="No-Break">camera’s zoom.</span></p>
			<p>Add these new actions in the <strong class="bold">Input </strong><span class="No-Break"><strong class="bold">Map</strong></span><span class="No-Break"> property:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B19289_05_24.jpg" alt="Figure 5.24: Input map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.24: Input map</p>
			<h3>Creating a gimbal</h3>
			<p>The<a id="_idIndexMarker430"/> camera movement needs to have some restrictions. For one, it should always remain level and not become tilted side to side. Try this: take a camera and rotate it a small amount around <strong class="source-inline">y</strong> (the gizmo’s green ring), then a small amount around <strong class="source-inline">x</strong> (the red ring). Now, reverse the <strong class="source-inline">y</strong> rotation and click the <strong class="bold">Preview</strong> button. See how the camera has <span class="No-Break">become tilted?</span></p>
			<p>The solution to this problem is to place the <a id="_idIndexMarker431"/>camera on a <strong class="bold">gimbal</strong> – a device designed to keep an object level during movement. You can create a gimbal using two <strong class="source-inline">Node3D</strong> nodes, which will control the camera’s left/right and up/down <span class="No-Break">movement respectively.</span></p>
			<p>First, make sure to remove any other <strong class="source-inline">Camera3D</strong> nodes in the scene, so that you don’t have any conflict over which camera is <span class="No-Break">being used.</span></p>
			<p>Create a new scene and add two <strong class="source-inline">Node3D</strong> nodes and a <strong class="source-inline">Camera3D</strong> node, naming them as shown in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.25</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B19289_05_25.jpg" alt="Figure 5.25: Camera gimbal node setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.25: Camera gimbal node setup</p>
			<p>Set the <strong class="bold">Position</strong> setting of <strong class="source-inline">Camera3D</strong> to <strong class="source-inline">(0, 0, 10)</strong> so that it’s offset and looking toward <span class="No-Break">the origin.</span></p>
			<p>Here’s how the gimbal works: the outer node is allowed to rotate <em class="italic">only</em> in <strong class="source-inline">y</strong>, while the inner one rotates <em class="italic">only</em> in <strong class="source-inline">x</strong>. You can try it yourself, but make sure to turn on <strong class="bold">Use Local Space</strong> (see the <em class="italic">Introduction to 3D space</em> section). Remember to only move the <em class="italic">green</em> ring of the outer gimbal node, and only the <em class="italic">red</em> ring of the inner one. Don’t change the camera at all. Reset all rotations back to zero once you’ve <span class="No-Break">finished experimenting.</span></p>
			<p>To control this motion in the game, attach a script to the root node and add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
extends Node3D
@export var cam_speed = PI / 2
@export var zoom_speed = 0.1
var zoom = 0.2
func _input(event):
    if event.is_action_pressed("cam_zoom_in"):
        zoom -= zoom_speed
    if event.is_action_pressed("cam_zoom_out"):
        zoom += zoom_speed
func _process(delta):
    zoom = clamp(zoom, 0.1, 2.0)
    scale = Vector3.ONE * zoom
    var y = Input.get_axis("cam_left", "cam_right")
    rotate_y(y * cam_speed * delta)
    var x = Input.get_axis("cam_up", "cam_down")
    $GimbalInner.rotate_x(x * cam_speed * delta)
    $GimbalInner.rotation.x = clamp($GimbalInner.rotation.x,         -PI / 2, -0.2)</pre>
			<p>As you<a id="_idIndexMarker432"/> can see, the right/left actions rotate the root <strong class="source-inline">Node3D</strong> node around its <strong class="source-inline">y</strong>axis, while the up/down actions rotate <strong class="source-inline">GimbalInner</strong> on its <strong class="source-inline">x</strong>axis. The entire gimbal system’s <strong class="source-inline">scale</strong> property is used to handle zooming. Finally, the rotation and zoom are limited by using <strong class="source-inline">clamp()</strong>, preventing the user from flipping the camera upside down or zooming too close or <span class="No-Break">far away.</span></p>
			<p>Add an instance of <strong class="source-inline">CameraGimbal</strong> to the <span class="No-Break"><strong class="source-inline">Hole</strong></span><span class="No-Break"> scene.</span></p>
			<p>The next step is to make the camera follow the ball. You can do this in <strong class="source-inline">_process()</strong> by setting the camera’s position to <span class="No-Break">the ball’s:</span></p>
			<pre class="source-code">
if state != WIN:
    $CameraGimbal.position = $Ball.position</pre>
			<p>Play the scene <a id="_idIndexMarker433"/>and test that you can rotate and zoom the camera and that it moves when the ball when you make <span class="No-Break">a shot.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Designing a full course</h2>
			<p>Once the<a id="_idIndexMarker434"/> ball falls into the hole, the player should advance to play the next hole. Add this variable at the top <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">hole.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@export var next_hole : PackedScene</pre>
			<p>This will let you set the next hole that will be loaded. In the Inspector, select the <strong class="bold">Next Hole</strong> property to choose what scene to <span class="No-Break">load next.</span></p>
			<p>Add the loading code in the <span class="No-Break"><strong class="source-inline">WIN</strong></span><span class="No-Break"> state:</span></p>
			<pre class="source-code">
WIN:
$Ball.hide()
$Arrow.hide()
    await get_tree().create_timer(1).timeout
    if next_hole:
        get_tree().change_scene_to_packed(next_hole)</pre>
			<p>Your <strong class="source-inline">Hole</strong> scene is intended to be the generic scaffold for building multiple holes the player can play through. Now that you have it working, you can use it to make multiple scenes using <strong class="bold">Scene</strong> -&gt; <strong class="bold">New </strong><span class="No-Break"><strong class="bold">Inherited Scene</strong></span><span class="No-Break">.</span></p>
			<p>Using this technique, you can make as many holes as you want and chain them together into the full golf course. Here’s the second hole in the <span class="No-Break">example project:</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B19289_05_26.jpg" alt="Figure 5.26: Example course layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.26: Example course layout</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor180"/>Visual effects</h1>
			<p>The appearance <a id="_idIndexMarker435"/>of the ball and the other meshes in your scene have been intentionally left very plain. You can think of the flat, white ball as a blank canvas, ready to be painted. First, a bit <span class="No-Break">of vocabulary:</span></p>
			<ul>
				<li><strong class="bold">Textures</strong>: Textures<a id="_idIndexMarker436"/> are flat, 2D images <a id="_idIndexMarker437"/>that are <em class="italic">wrapped</em> around 3D objects. Imagine wrapping a gift: the flat paper is folded around the package, conforming to its shape. Textures can be simple or complex, depending on the shape they’re designed to be <span class="No-Break">applied to.</span></li>
				<li><strong class="bold">Shaders</strong>: While<a id="_idIndexMarker438"/> textures determine <em class="italic">what</em> is drawn <a id="_idIndexMarker439"/>on an object’s surface, shaders determine <em class="italic">how</em> it is drawn. Imagine a wall with a texture that shows a pattern of bricks. How would it look if it were wet? The mesh and texture would be the same, but the way the light reflects from it would be quite different. This is the function of shaders – to alter the appearance of an object by altering how light interacts with it. Shaders are typically written in a specialized programming language and can use a great deal of advanced math, the details of which are beyond the scope of this book. However, Godot provides an alternative method of creating a shader for your objects that<a id="_idIndexMarker440"/> allows a great deal of customization without needing to write shader <span class="No-Break">code: </span><span class="No-Break"><strong class="source-inline">StandardMaterial3D</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Materials</strong>: Godot <a id="_idIndexMarker441"/>uses a graphics rendering <a id="_idIndexMarker442"/>model <a id="_idIndexMarker443"/>called <strong class="bold">Physically Based Rendering</strong> (<strong class="bold">PBR</strong>). The goal of PBR is to render graphics in a way that accurately models the way light works in the real world. These effects are applied to meshes using their material property. Materials are essentially containers for textures and shaders. The material’s properties determine how the texture and shader effects are applied. Using Godot’s built-in material properties, you can simulate a wide range of physical materials, such as stone, cloth, or metal. If the built-in properties aren’t enough for your purposes, you can write your own shader code to add even <span class="No-Break">more effects.</span></li>
			</ul>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Adding materials</h2>
			<p>In the <strong class="source-inline">Ball</strong> scene, select <strong class="source-inline">MeshInstance</strong> and in its <strong class="bold">Mesh</strong> properties find <strong class="bold">Material</strong> and add a new <span class="No-Break"><strong class="source-inline">StandardMaterial3D</strong></span><span class="No-Break"> node.</span></p>
			<p>Expand <a id="_idIndexMarker444"/>the material and you’ll see a large number of properties, far more than can be covered here. This section will focus on some of the most useful ones for making the ball look more appealing. You are encouraged to visit <a href="https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html">https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html</a> for a full explanation of all <span class="No-Break">the settings.</span></p>
			<p>To begin, try experimenting with <span class="No-Break">these parameters:</span></p>
			<ul>
				<li><strong class="bold">Albedo</strong>: This property sets the base color of the material. Change this to make the ball whatever color you’d like. If you’re working with an object that needs a texture, this is where you’d add it <span class="No-Break">as well.</span></li>
				<li><strong class="bold">Metallic and Roughness</strong>: These parameters control how the surface reflects light. Both can be set to values between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>. The <strong class="bold">Metallic</strong> value controls <em class="italic">shininess</em>. Higher values will reflect more light, as with metallic substances. The <strong class="bold">Roughness</strong> value applies an amount of blur to the reflection. Lower values are more reflective, such as the polished surface of a mirror. You can simulate a wide variety of materials by adjusting these two properties. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.27</em> is a guide to how the <strong class="bold">Roughness</strong> and <strong class="bold">Metallic</strong> properties affect the appearance of an object. Keep in mind that lighting and other factors will alter the appearance<a id="_idIndexMarker445"/> as well. Understanding how light and reflections interact with surface properties is a big part of designing effective <span class="No-Break">3D objects:</span></li>
			</ul>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B19289_05_27.jpg" alt="Figure 5.27: Metallic and Roughness values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.27: Metallic and Roughness values</p>
			<ul>
				<li><strong class="bold">Normal Map</strong>: Normal mapping is a 3D graphics technique for simulating the appearance of bumps and dents on a surface. Modeling these in the mesh itself would result in a large increase in the number of polygons, or faces, making up the object, leading to reduced performance. Instead, a 2D texture is used that maps the pattern of light and shadow that would result from these small surface features. The lighting engine then uses that information to alter the reflection as if those details were actually there. A properly constructed normal map can add a great amount of detail to an otherwise <span class="No-Break">bland-looking object.</span></li>
			</ul>
			<p>The ball is a perfect example of a good use case for normal mapping because a real golf ball has hundreds of dimples on its surface, but the sphere primitive you’re using is a smooth surface. Using a regular texture could add spots, but they would look flat as if they were <a id="_idIndexMarker446"/>painted on the surface. A normal map to simulate those dimples would look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B19289_05_28.jpg" alt="Figure 5.28: A normal map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.28: A normal map</p>
			<p>The pattern of red and blue contains information telling the engine which direction it should assume the surface is facing at that point, and therefore which direction the light should bounce in that position. Note the stretching along the top and bottom – that’s because this image is made to be wrapped around a <span class="No-Break">sphere shape.</span></p>
			<p>Enable the <strong class="bold">Normal Map</strong> property and drag <strong class="source-inline">res://assets/ball_normal_map.png</strong> into the <strong class="bold">Texture</strong> field. Try this with the <strong class="bold">Albedo</strong> color set to white at first, so you can best see the effect. Adjust the <strong class="bold">Depth</strong> parameter to increase or decrease the strength of the effect. A negative value will make the dimples look inset. Something between <strong class="source-inline">-0.5</strong> and <strong class="source-inline">-1.0</strong> <span class="No-Break">works best:</span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B19289_05_29.jpg" alt="Figure 5.29: A ball with a normal map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.29: A ball with a normal map</p>
			<p>Take some time to experiment with these settings and find a combination you like. Don’t forget to<a id="_idIndexMarker447"/> try playing the scene as well, as the ambient lighting of the <strong class="source-inline">WorldEnvironment</strong> feature will affect the <span class="No-Break">final result.</span></p>
			<p>In the next section, you’ll learn how to adjust the <strong class="source-inline">WorldEnvironment</strong> settings to change the look of <span class="No-Break">the scene.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Lighting and Environment</h1>
			<p>You’ve been using the <a id="_idIndexMarker448"/>default lighting setup, which you added to your scene back in the first section. While you may be happy with this lighting setup, you can also adjust it to dramatically change the appearance of <span class="No-Break">your game.</span></p>
			<p>The <strong class="source-inline">WorldEnvironment</strong> node contains an <strong class="source-inline">Environment</strong> property that controls the background, sky, ambient light, and other aspects of the scene’s appearance. Select the node and click the<a id="_idIndexMarker449"/> property to <span class="No-Break">expand it:</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B19289_05_30.jpg" alt="Figure 5.30: Environment properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.30: Environment properties</p>
			<p>There are a lot of <a id="_idIndexMarker450"/>settings here, some of which are only really useful in <a id="_idIndexMarker451"/>specific advanced situations. However, these are the ones you’ll find yourself using the <span class="No-Break">most often:</span></p>
			<ul>
				<li><strong class="bold">Background and Sky</strong>: Here, you<a id="_idIndexMarker452"/> can configure the background appearance of the 3D scene. You can choose a solid color or a <strong class="source-inline">Sky</strong> material. Sky materials can either be special textures that wrap around the scene (see the next game for an example) or one that’s automatically generated by the engine. The default sky that you’re using now is the latter: <strong class="source-inline">ProceduralSkyMaterial</strong>. Expand it to take a look at the properties – you can configure the sky’s colors and the <span class="No-Break">sun’s appearance.</span></li>
				<li><strong class="bold">Ambient Light</strong>: This is<a id="_idIndexMarker453"/> global light that affects all meshes with the same intensity. You can set its color and how much of it is generated by the sky. To see the effect, try setting the color to white and reducing the <strong class="bold">Sky Contribution</strong> <span class="No-Break">a bit.</span></li>
				<li><strong class="bold">Screen Space Reflection</strong> (<strong class="bold">SSR</strong>), <strong class="bold">Screen Space Ambient Occlusion</strong> (<strong class="bold">SSAO</strong>), <strong class="bold">Screen Space Indirect Lighting</strong> (<strong class="bold">SSIL</strong>), and <strong class="bold">Signed Distance Field Global </strong><span class="No-Break"><strong class="bold">Illumination</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SDFGI</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>These options<a id="_idIndexMarker454"/> provide <a id="_idIndexMarker455"/>more advanced control over how lighting and shadows are processed. An entire book could be written about the art of good lighting, but for<a id="_idIndexMarker456"/> the purposes<a id="_idIndexMarker457"/> of this section, you<a id="_idIndexMarker458"/> should know that each of these features introduces a tradeoff between realistic rendering and performance. Most advanced lighting features are not available at all for low-end devices, such as mobile or older PC hardware. If you’d like to learn more, the Godot documentation has an extensive introduction to the usage of these <span class="No-Break">lighting features.</span></p>
			<p>The <strong class="bold">Glow</strong> lighting feature <a id="_idIndexMarker459"/>simulates the filmic effect<a id="_idIndexMarker460"/> of light that “bleeds” into its surroundings, making objects appear to be emitting light. Note that this is different from the <strong class="bold">Emission</strong> property of materials, which causes objects to actually emit light. Glow is enabled by default, but at a very subtle setting that may not be apparent in <span class="No-Break">bright lighting.</span></p>
			<p>Feel free to experiment with the various environment settings. If you get completely lost and want to return to the default, delete the <strong class="source-inline">WorldEnvironment</strong> node, and you’ll be able to add the default version back again from <span class="No-Break">the menu.</span></p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Summary</h1>
			<p>This chapter introduced you to 3D development. One of Godot’s great strengths is that the same tools and workflow are used in both 2D and 3D. Everything you learned about the process of creating scenes, instancing, and using signals works in the same way. For example, an interface you build with control nodes for a 2D game can be dropped into a 3D game and will work just <span class="No-Break">the same.</span></p>
			<p>In this chapter, you learned how to navigate the 3D editor to view and place nodes using gizmos. You learned about meshes and how to quickly make your own objects using Godot’s primitives. You used <strong class="source-inline">GridMap</strong> to lay out your minigolf course. You learned about using cameras, lighting, and the world environment to design how your game will appear on the screen. Finally, you got a taste of using PBR rendering via Godot’s <span class="No-Break"><strong class="source-inline">SpatialMaterial</strong></span><span class="No-Break"> resource.</span></p>
			<p>In the next project, you’ll continue working in 3D and extend your understanding of transforms <span class="No-Break">and meshes.</span></p>
		</div>
	</body></html>