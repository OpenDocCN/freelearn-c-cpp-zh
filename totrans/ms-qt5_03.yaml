- en: Chapter 3.  Dividing Your Project and Ruling Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 分割你的项目并统治你的代码
- en: The last chapter delved into qmake to study what lies beneath the signal/slot
    system and covered a reasonable approach to implementing platform-specific code.
    This chapter wants to show you how a project can be properly divided to enjoy
    the maximum leverage from the Qt framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章深入探讨了qmake，研究了信号/槽系统背后的内容，并介绍了一种实现平台特定代码的合理方法。本章旨在向您展示如何正确分割项目，以充分利用Qt框架。
- en: To do this, you will create a gallery application that handles albums and pictures.
    You will be able to create, read, update and delete any album and display the
    pictures in a grid of thumbnails or in full resolution. Everything will be persisted
    in a SQL database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你将创建一个处理相册和图片的画廊应用程序。你将能够创建、读取、更新和删除任何相册，并以缩略图网格或全分辨率显示图片。所有内容都将持久化在SQL数据库中。
- en: 'This chapter lays the foundations of the gallery by creating a core library
    that will be used in the following two chapters: [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*, and [Chapter
    5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile UI"), *Dominating
    the Mobile UI*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过创建一个将在以下两个章节中使用的核心库来奠定画廊的基础：[第4章](part0040.xhtml#aid-164MG2 "第4章. 拿下桌面UI")，*拿下桌面UI*，和[第5章](part0048.xhtml#aid-1DOR02
    "第5章. 统治移动UI")，*统治移动UI*。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Application/library project separation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序/库项目分离
- en: Database interaction with Qt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt进行数据库交互
- en: Smart pointers with C++14
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++14中的智能指针
- en: Model/View architecture in Qt with an implementation of the model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt中的模型/视图架构及其模型实现
- en: Designing a maintainable project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可维护项目
- en: The first step in designing a maintainable project is to properly split it in
    clearly defined modules. A common approach is to separate the engine from the
    user interface. This separation forces you to reduce coupling between the different
    parts of your code and make it more modular.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计可维护项目的第一步是将它适当地分割成明确定义的模块。一种常见的方法是将引擎与用户界面分开。这种分离迫使你减少代码不同部分之间的耦合，使其更加模块化。
- en: 'This is exactly the approach we will take with the `gallery` application. The
    project will be divided into three sub-projects:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们将采取的`gallery`应用程序的方法。项目将被分割成三个子项目：
- en: '![Designing a maintainable project](img/image00366.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![设计可维护项目](img/image00366.jpeg)'
- en: 'The sub-projects are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 子项目如下：
- en: '**gallery-core**: This is a library containing the core of the application
    logic: the data classes (or business classes), persistent storage (in SQL), and
    the model that makes the storage available to the UI through a single entry point.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gallery-core**：这是一个包含应用程序逻辑核心的库：数据类（或业务类）、持久化存储（在SQL中），以及通过单个入口点使存储对UI可用的模型。'
- en: '**gallery-desktop**: This is a Qt widgets application that will depend on the `gallery-core`
    library to retrieve data and display it to the user. This project will be covered
    in [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop UI"), *Conquering
    the Desktop UI*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gallery-desktop**：这是一个依赖于`gallery-core`库来获取数据并向用户显示的Qt小部件应用程序。该项目将在[第4章](part0040.xhtml#aid-164MG2
    "第4章. 拿下桌面UI")，*拿下桌面UI*中介绍。'
- en: '**gallery-mobile**: This is a QML application targeted at mobile platforms
    (Android and iOS). It will also rely on `gallery-core`. This project will be covered
    in [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile UI"), *Dominating
    the Mobile UI*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gallery-mobile**：这是一个针对移动平台（Android和iOS）的QML应用程序。它也将依赖于`gallery-core`。该项目将在[第5章](part0048.xhtml#aid-1DOR02
    "第5章. 统治移动UI")，*统治移动UI*中介绍。'
- en: 'As you can see, each layer has a single responsibility. This principle is applied
    to both the project structure and the code organization. Throughout these three
    projects, we will endeavor to live up to the motto of the chapter: "Divide your
    project and rule your code".'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每一层都有单一的责任。这个原则既应用于项目结构，也应用于代码组织。在这三个项目中，我们将努力实现章节的座右铭：“分割你的项目，统治你的代码”。
- en: 'To separate your Qt project this way, we will create a different kind of project,
    a **Subdirs** project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式分离你的Qt项目，我们将创建一种不同类型的项目，即**Subdirs**项目：
- en: Click on **File** | **New ****File ****or ****Project**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**文件** | **新建文件**或**项目**。
- en: In the **Projects** types, select **Other Project** | **Subdirs Project** | **Choose**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目类型**中，选择**其他项目** | **Subdirs项目** | **选择**。
- en: Name it `ch03-gallery-core` and then click on **Choose**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`ch03-gallery-core`，然后点击**选择**。
- en: Select your latest Qt Desktop Kit, and then click on **Next** | **Finish & Add
    Subproject**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你最新的Qt桌面套件，然后点击**下一步** | **完成并添加子项目**。
- en: Here, Qt Creator created the parent project, `ch03-gallery-core`, which will
    host our three sub-projects (`gallery-core`, `gallery-desktop`, and `gallery-mobile`).
    The parent project has neither code nor a compilation unit in itself, it is simply
    a convenient way to group multiple `.pro` projects and express the dependencies
    between them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Qt Creator创建了父项目`ch03-gallery-core`，它将托管我们的三个子项目（`gallery-core`、`gallery-desktop`和`gallery-mobile`）。父项目本身没有代码也没有编译单元，它只是将多个`.pro`项目分组并表达它们之间依赖关系的一种方便方式。
- en: 'The next step is to create the first `subdir` project, which Qt Creator proposed
    immediately when you clicked on **Finish & Add Subproject**. We will start with `gallery-core`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建第一个`subdir`项目，这是你在点击**完成并添加子项目**后Qt Creator立即提出的。我们将从`gallery-core`开始：
- en: Select **Library** in the **Projects** tab.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**选项卡中选择**库**。
- en: Select **C++ Library**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**C++库**。
- en: Choose the **Shared Library** type, and name it `gallery-core`, and click on **Next**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**共享库**类型，并将其命名为`gallery-core`，然后点击**下一步**。
- en: Select the modules, **QtCore**, and **QtSql**, and then click on **Next**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模块，**QtCore**和**QtSql**，然后点击**下一步**。
- en: Type **Album** in the **Class name** field, and click on **Next**. Qt Creator
    will generate the basic skeleton of a library with this class as an example.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类名**字段中输入**Album**，然后点击**下一步**。Qt Creator将生成以这个类为例的库的基本框架。
- en: Check that the project is properly added as a sub-project of `ch03-gallery-core.pro`
    and click on **Finish**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认项目已正确添加为`ch03-gallery-core.pro`的子项目，然后点击**完成**。
- en: 'Before delving into `gallery-core` code, let''s study what Qt Creator just
    made for us. Open the parent `.pro` file, `ch03-gallery-core.pro`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究`gallery-core`代码之前，让我们研究一下Qt Creator为我们做了什么。打开父级`.pro`文件，`ch03-gallery-core.pro`：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Until now, we used the `TEMPLATE = app` syntax in our `.pro` files. The `subdirs`
    project template indicates to Qt that it should search for sub-projects to compile.
    When we added the `gallery-core` project to `ch03-gallery-core.pro`, Qt Creator
    added it to the `SUBDIRS` variable. As you can see, `SUBDIRS` is a list, so you
    can add as many sub-projects as you want.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在`.pro`文件中使用了`TEMPLATE = app`语法。`subdirs`项目模板指示Qt去寻找要编译的子项目。当我们把`gallery-core`项目添加到`ch03-gallery-core.pro`中时，Qt
    Creator将其添加到了`SUBDIRS`变量中。正如你所见，`SUBDIRS`是一个列表，所以你可以添加任意多的子项目。
- en: 'When compiling `ch03-gallery-core.pro`, Qt will scan each `SUBDIRS` value to
    compile them. We can now switch to `gallery-core.pro`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译`ch03-gallery-core.pro`时，Qt会扫描每个`SUBDIRS`值来编译它们。我们现在可以切换到`gallery-core.pro`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see how this works:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: The `QT` has appended the `sql` module and removed the `gui` module. By default, **QtGui**
    is always included and has to be removed explicitly.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT`已附加了`sql`模块并删除了`gui`模块。默认情况下，**QtGui**总是包含在内，必须显式删除。'
- en: The `TEMPLATE` value is different, again. We use `lib` to tell qmake to generate
    a Makefile that will output a shared library named `gallery-core` (as specified
    by the `TARGET` variable).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEMPLATE`的值再次不同。我们使用`lib`来告诉qmake生成一个Makefile，该Makefile将输出一个名为`gallery-core`的共享库（由`TARGET`变量指定）。'
- en: The `DEFINES += GALLERY_CORE_LIBRARY` syntax is a compilation flag that lets
    the compiler know when it should import or export library symbols. We will come
    back soon to this notion.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFINES += GALLERY_CORE_LIBRARY`语法是一个编译标志，它让编译器知道何时导入或导出库符号。我们很快就会回到这个概念。'
- en: The `HEADERS` contains our first class `Album.h`, but also another generated
    header: `gallery-core_global.h`. This file is syntactic sugar provided by Qt to
    ease the pain of a cross-platform library.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEADERS`包含了我们的第一个类`Album.h`，还有一个由Qt生成的头文件：`gallery-core_global.h`。这个文件是Qt提供的一种语法糖，用于简化跨平台库的痛苦。'
- en: The `unix { ... }` scope specifies the installation destination of the library.
    This platform scope is generated because we created the project on Linux. By default
    it will try to install the library in the system library path (`/usr/lib`).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix { ... }`范围指定了库的安装目标。这个平台范围是生成的，因为我们是在Linux上创建的项目。默认情况下，它将尝试在系统库路径（`/usr/lib`）中安装库。'
- en: Please remove the `unix` scope altogether, we don't need to make the library
    available system-wide.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请完全删除`unix`范围，我们不需要使库在系统范围内可用。
- en: 'To have a better understanding of the cross-platform shared object issue, you
    can open `gallery-core_global.h`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解跨平台共享对象问题，你可以打开`gallery-core_global.h`：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We encounter again the `GALLERYCORE_LIBRARY` defined in `gallery-core.pro`
    file. Qt Creator generated a useful piece of code for us: the cross-platform way
    to handle symbol visibility in a shared library.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次遇到了在 `gallery-core.pro` 文件中定义的 `GALLERYCORE_LIBRARY`。Qt Creator为我们生成了一段有用的代码：在共享库中处理符号可见性的跨平台方式。
- en: When your application links to a shared library, symbol functions, variables,
    or classes must be marked in a special way to be visible by the application using
    the shared library. The default visibility of a symbol depends on the platform.
    Some platforms will hide symbols by default, other platforms will make them public.
    Of course, each platform and compiler has its own macros to express this public/private
    notion.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序链接到共享库时，符号函数、变量或类必须以特殊方式标记，以便使用共享库的应用程序可见。符号的默认可见性取决于平台。某些平台默认隐藏符号，其他平台将它们公开。当然，每个平台和编译器都有自己的宏来表示这种公共/私有概念。
- en: 'To obviate the whole `#ifdef windows #else` boilerplate code, Qt provides a `Q_DECL_EXPORT`
    (if we are compiling the library) and `Q_DECL_IMPORT` (if we are compiling your
    application using the shared library). Thus, throughout the symbols you want to
    mark as public, you just have to use the `GALLERYCORESHARED_EXPORT` macro.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '为了避免整个 `#ifdef windows #else` 模板代码，Qt 提供了 `Q_DECL_EXPORT`（如果我们正在编译库）和 `Q_DECL_IMPORT`（如果我们正在使用共享库编译您的应用程序）。因此，在您想要标记为公共的符号中，您只需使用
    `GALLERYCORESHARED_EXPORT` 宏。'
- en: 'An example is available in the `Album.h` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例在 `Album.h` 文件中：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You include the proper `gallery-core_global.h` file to have access to the macro
    and you use it just after the `class` keyword. It does not pollute your code too
    much and is still cross-platform.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您包含适当的 `gallery-core_global.h` 文件以访问宏，并在 `class` 关键字之后使用它。它不会过多地污染您的代码，并且仍然是跨平台的。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another possibility is to make a **Statically Linked Library**. This path is
    interesting if you want fewer dependencies to handle (a single binary is always
    easier to deploy). There are several downsides:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是创建一个 **静态链接库**。如果您想要处理更少的依赖项（单个二进制文件总是更容易部署），这个路径很有趣。但有几个缺点：
- en: 'Increased compilation time: each time you modify the library, the application
    will have to be recompiled as well.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加编译时间：每次您修改库时，应用程序也必须重新编译。
- en: Tighter coupling, multiple applications cannot link to your library. Each one
    of them must embed it.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更紧密的耦合，多个应用程序不能链接到您的库。每个都必须嵌入它。
- en: Defining data classes
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据类
- en: We are building our gallery from the ground up. We will start with the implementation
    of our data classes to be able to properly write the database layer. The application
    aims to organize pictures into albums. Hence, the two obvious classes are `Album`
    and `Picture`. In our example, an album simply has a name. A `Picture` class must
    belong to an `Album` class and has a file path (the path on your filesystem where
    the original file is located).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从头开始构建我们的画廊。我们将从实现数据类开始，以便能够正确编写数据库层。应用程序的目标是将图片组织到专辑中。因此，两个明显的类是 `Album`
    和 `Picture`。在我们的示例中，一个专辑仅仅有一个名称。`Picture` 类必须属于 `Album` 类，并有一个文件路径（原始文件在文件系统中的路径）。
- en: 'The `Album` class has already been created on project creation. Open the `Album.h`
    file and update it to include the following implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Album` 类在项目创建时就已经创建好了。打开 `Album.h` 文件，并更新它以包含以下实现：'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the `Album` class contains only a `mId` variable (the database
    ID) and a `mName` variable. In a typical **OOP** (**Object Oriented Paradigm**)
    fashion, the `Album` class would have had a `QVector<Picture>mPictures` field.
    We did not do it on purpose. By decoupling these two objects, we will have more
    flexibility when we want to load an album without pulling the potential thousands
    of associated pictures. The other problem in having `mPictures` in the `Album`
    class is that the developer (you or anybody else) using this code will ask himself:
    when is `mPictures` loaded? Should I do a partial load of the `Album` and have
    an incomplete `Album` or should I always load `Album` with every picture in it?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Album` 类仅包含一个 `mId` 变量（数据库 ID）和一个 `mName` 变量。按照典型的 **OOP**（面向对象范式）风格，`Album`
    类本应有一个 `QVector<Picture>mPictures` 字段。我们故意没有这样做。通过解耦这两个对象，当我们想要加载一个专辑而不需要拉取潜在的数千张相关图片时，我们将拥有更多的灵活性。在
    `Album` 类中拥有 `mPictures` 的另一个问题是，使用此代码的开发者（您或其他人）会问自己：何时加载 `mPictures`？我应该只部分加载
    `Album` 并得到一个不完整的 `Album`，还是应该总是加载包含所有图片的 `Album`？
- en: By completely removing the field, the question ceases to exist, and the code
    is simpler to grasp. The developer knows intuitively that he will have to explicitly
    load the pictures if he want them; otherwise, he can continue with this simple
    `Album` class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完全删除该字段，问题就消失了，代码也更容易理解。开发者会直觉地知道，如果他想使用图片，就必须显式地加载它们；否则，他可以继续使用这个简单的 `Album`
    类。
- en: 'The getters and setters are obvious enough; we will let you implement them
    without showing them to you. We will only take a look at the `Album` class'' constructor
    in `Album.cpp`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器已经很明确了；我们将让您在不向您展示的情况下实现它们。我们只会看看 `Album.cpp` 中的 `Album` 类的构造函数：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `mId` variable is initialized to `-1` to be sure that, by default, an invalid
    id is used, and the `mName` variable is assigned a `name` value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`mId` 变量被初始化为 `-1` 以确保默认使用一个无效的 ID，并且 `mName` 变量被分配一个 `name` 值。'
- en: 'We can now proceed to the `Picture` class. Create a new C++ class named `Picture`
    and open `Picture.h` to modify it like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续到 `Picture` 类。创建一个新的 C++ 类名为 `Picture` 并打开 `Picture.h` 进行如下修改：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do not forget to add the `GALLERYCORESHARED_EXPORT` macro right before the `class`
    keyword to export the class from the library. As a data structure, `Picture` has
    a `mId` variable, belongs to a `mAlbumId` variable, and has a `mUrl` value. We
    use the `QUrl` type to make path manipulation easier to use depending on the platform
    (desktop or mobile).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `class` 关键字之前添加 `GALLERYCORESHARED_EXPORT` 宏，以便从库中导出类。作为一个数据结构，`Picture`
    有一个 `mId` 变量，属于一个 `mAlbumId` 变量，并且有一个 `mUrl` 值。我们使用 `QUrl` 类型来使路径操作更容易使用，这取决于平台（桌面或移动）。
- en: 'Let''s take a look at `Picture.cpp`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Picture.cpp`：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first constructor, the static function, `QUrl::fromLocalFile`, is called
    to provide a `QUrl` object to the other constructor, which takes a `QUrl` parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个构造函数中，静态函数 `QUrl::fromLocalFile` 被调用，为其他构造函数提供一个 `QUrl` 对象，该构造函数接受一个 `QUrl`
    参数。
- en: The ability to call other constructors is a nice addition in C++11.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 中，能够调用其他构造函数是一个很好的补充。
- en: Storing your data in a database
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的数据存储在数据库中
- en: 'Now that the data classes are ready, we can proceed to implement the database
    layer. Qt provides a ready-to-use `sql` module. Various databases are supported
    in Qt using SQL database drivers. In `gallery-desktop`, we will use the `SQLITE3`
    driver, which is included in the `sql` module and perfectly fits the use case:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据类已经准备好了，我们可以继续实现数据库层。Qt 提供了一个现成的 `sql` 模块。Qt 使用 SQL 数据库驱动程序支持各种数据库。在 `gallery-desktop`
    中，我们将使用包含在 `sql` 模块中的 `SQLITE3` 驱动程序，它非常适合用例：
- en: '**A very simple database schema**: No need for complex queries'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个非常简单的数据库模式**：不需要复杂的查询'
- en: '**Very few or no concurrent transactions**: No need for a complex transaction
    model'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非常少或没有并发事务**：不需要复杂的交易模型'
- en: '**A single-purpose database**: No need to spawn a system service, the database
    is stored in a single file and does not need to be accessed by multiple applications'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一用途数据库**：不需要启动系统服务，数据库存储在一个单独的文件中，并且不需要被多个应用程序访问'
- en: 'The database will be accessed from multiple locations; we need to have a single
    entry point for it. Create a new C++ class named `DatabaseManager` and modify `DatabaseManager.h`
    to look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库将从多个位置访问；我们需要有一个单一的入口点。创建一个新的 C++ 类名为 `DatabaseManager` 并修改 `DatabaseManager.h`
    以如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing to notice is that we implement the singleton pattern in the
    `DatabaseManager` class, like we did in the *Transforming SysInfo in a singleton*
    section from [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2.  Discovering QMake
    Secrets"), *Discovering QMake Secrets*. The `DatabaseManager` class will open
    the connection in the `mDatabase` field and lend it to other possible classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们在 `DatabaseManager` 类中实现了单例模式，就像我们在第 2 章的“在单例中转换 SysInfo”部分所做的那样，即
    [第 2 章](part0025.xhtml#aid-NQU22 "第 2 章。发现 QMake 秘密")，*发现 QMake 秘密*。`DatabaseManager`
    类将在 `mDatabase` 字段中打开连接并将其借给其他可能的类。
- en: 'Also, `QSqlDatabase` is forward-declared and used as a pointer for the `mDatabase`
    field. We could have included the `QSqlDatabase` header, but we would have had
    a non-desired side-effect: every file, which includes `DatabaseManager`, must
    also include `QSqlDatabase`. Thus, if we ever have some transitive inclusion in
    our application (which links to the `gallery-core` library), the application is
    forced to enable the `sql` module. As a consequence, the storage layer leaks through
    the library. The application should not have any knowledge about the storage layer
    implementation. For all the application cares, it could be in SQL, XML, or anything
    else; the library is a black box that should honor the contract and persist the
    data.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`QSqlDatabase`被前置声明并用作`mDatabase`字段的指针。我们本可以包含`QSqlDatabase`头文件，但这样会有一个不希望出现的副作用：包含`DatabaseManager`的每个文件都必须也包含`QSqlDatabase`。因此，如果我们应用程序中存在一些传递性包含（链接到`gallery-core`库），应用程序将被迫启用`sql`模块。因此，存储层通过库泄漏。应用程序不应了解存储层实现。对于应用程序来说，它可以是SQL、XML或其他任何东西；库是一个应该遵守合同并持久化数据的黑盒。
- en: 'Let''s switch to `DatabaseManager.cpp` and open the database connection:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到`DatabaseManager.cpp`并打开数据库连接：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The correct database driver is selected on the `mDatabase` field initialization
    with the `QSqlDatabase::addDatabase("QSQLITE")` function call. The following steps
    are just a matter of configuring the database name (which is incidentally the
    file path in SQLITE3) and opening the connection with the `mDatabase->open()`
    function. In the `DatabaseManager` destructor, the connection is closed and the `mDatabase`
    pointer is properly deleted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mDatabase`字段初始化时，通过`QSqlDatabase::addDatabase("QSQLITE")`函数调用选择正确的数据库驱动。接下来的步骤只是配置数据库名称（碰巧是SQLITE3中的文件路径）和通过`mDatabase->open()`函数打开连接。在`DatabaseManager`析构函数中，关闭连接并正确删除`mDatabase`指针。
- en: The database link is now opened; all we have to do is to execute our `Album`
    and `Picture` queries. Implementing the **CRUD** (**Create**/**Read**/**Update**/**Delete**)
    for both our data classes in `DatabaseManager` would quickly push `DatabaseManager.cpp`
    to be several hundreds of lines long. Add a few more tables and you can already
    see what a monster `DatabaseManager` would turn into.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接现在已打开；我们只需执行我们的`Album`和`Picture`查询。在`DatabaseManager`中为我们的数据类实现**CRUD**（**创建**/**读取**/**更新**/**删除**）操作会迅速将`DatabaseManager.cpp`的长度增加到数百行。添加更多表，你就可以看到`DatabaseManager`会变成一个怪物。
- en: 'For this reason, each of our data classes will have a dedicated database class,
    responsible for all the database CRUD operations. We will start with the `Album`
    class; create a new C++ class named `AlbumDao` (data access object) and update `AlbumDao.h`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的每个数据类都将有一个专门的数据库类，负责所有的数据库CRUD操作。我们将从`Album`类开始；创建一个新的C++类名为`AlbumDao`（数据访问对象）并更新`AlbumDao.h`：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `AlbumDao` class's constructor takes a `QSqlDatabase&` parameter. This parameter
    is the database connection that will be used for all the SQL queries done by the `AlbumDao`
    class. The `init()` function aims to create the `albums` table and should be called
    when `mDatabase` is opened.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumDao`类的构造函数接受一个`QSqlDatabase&`参数。这个参数是`AlbumDao`类将用于所有SQL查询的数据库连接。`init()`函数的目的是创建`albums`表，应该在`mDatabase`打开时调用。'
- en: 'Let''s see the implementation of `AlbumDao.cpp`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`AlbumDao.cpp`的实现：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As usual, the `mDatabase` field is initialized with the database parameter.
    In the `init()` function, we can see a real SQL request in action. If the table `albums`
    class does not exist, a `QSqlQuery` query is created that will use the `mDatabase`
    connection to be executed. If you omit `mDatabase`, the query will use a default
    anonymous connection. The `query.exec()` function is the simplest manner of executing
    a query: you simply pass the `QString` type of your query and it''s done. Here
    we create the `albums` table with the fields matching the data class `Album` (`id`
    and `name`).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`mDatabase`字段使用数据库参数进行初始化。在`init()`函数中，我们可以看到实际SQL请求的执行过程。如果`albums`表类不存在，将创建一个`QSqlQuery`查询，该查询将使用`mDatabase`连接来执行。如果你省略`mDatabase`，查询将使用默认的匿名连接。`query.exec()`函数是执行查询的最简单方式：你只需传递查询的`QString`类型，然后操作就完成了。在这里，我们创建`albums`表，其字段与数据类`Album`（`id`和`name`）相匹配。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `QSqlQuery::exec()` function returns a `bool` value that indicates if the
    request has been successful. In your production code, always check this value.
    You can further investigate the error with `QSqlQuery::lastError()`. An example
    is available in the source code of the chapter in `DatabaseManager::debugQuery()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSqlQuery::exec()` 函数返回一个 `bool` 值，表示请求是否成功。在你的生产代码中，始终检查这个值。你可以使用 `QSqlQuery::lastError()`
    进一步调查错误。一个示例可以在章节的源代码中找到，在 `DatabaseManager::debugQuery()` 中。'
- en: 'The skeleton of `AlbumDao` class is done. The next step is to link it to the `DatabaseManager`
    class. Update the `DatabaseManager` class like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumDao` 类的骨架已经完成。下一步是将它与 `DatabaseManager` 类链接起来。更新 `DatabaseManager` 类如下：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `albumDao` field is declared as a `public const AlbumDao` in the `DatabaseManager.h`
    file. This needs some explanation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`albumDao` 字段在 `DatabaseManager.h` 文件中被声明为 `public const AlbumDao`。这需要一些解释：'
- en: The `public` visibility is to give access to `DatabaseManager` clients to the `albumDao`
    field. The API becomes intuitive enough; if you want to make a database operation
    on an `album`, just call `DatabaseManager::instance().albumDao`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 可见性是为了让 `DatabaseManager` 客户端能够访问 `albumDao` 字段。API 已经足够直观；如果你想在 `album`
    上执行数据库操作，只需调用 `DatabaseManager::instance().albumDao`。'
- en: The `const` keyword is to make sure that nobody can modify `albumDao`. Because
    it is `public`, we cannot guarantee the safety of the object (anybody could modify
    the object). As a side-effect, we force every public function of `AlbumDao` to
    be `const`. This makes sense; after all, the `AlbumDao` field could have been
    a namespace with a bunch of functions. It is more convenient for it to be a class
    because we can keep the reference to the database connection with the `mDatabase`
    field.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` 关键字是为了确保没有人可以修改 `albumDao`。因为它 `public`，我们无法保证对象的安全性（任何人都可以修改对象）。作为副作用，我们强制
    `AlbumDao` 的每个公共函数都是 `const`。这很有意义；毕竟，`AlbumDao` 字段可能是一个包含许多函数的命名空间。将其作为一个类更方便，因为我们可以用
    `mDatabase` 字段保持对数据库连接的引用。'
- en: In the `DatabaseManager` constructor, the `albumDao` class is initialized with
    the `mDatabase` dereferenced pointer. The `albumDao.init()` function is called
    after the database connection has opened.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DatabaseManager` 构造函数中，`albumDao` 类使用 `mDatabase` 解引用指针进行初始化。在数据库连接打开后，调用
    `albumDao.init()` 函数。
- en: 'We can now proceed to implement more interesting SQL queries. We can start
    with the creation of a new album in the `AlbumDao` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续实现更有趣的 SQL 查询。我们可以从在 `AlbumDao` 类中创建一个新的专辑开始：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `addAlbum()` function takes an `album` parameter to extract its information
    and execute the corresponding query. Here, we approach the prepared query notion:
    the `query.prepare()` function takes a `query` parameter which contains placeholders
    for parameters provided later. We will provide the `name` parameter with the syntax `:name`.
    Two syntaxes are supported: Oracle style with a colon-name (for example, `:name`)
    or ODBC style with a question mark (for example, `?name`).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAlbum()` 函数接受一个 `album` 参数，提取其信息并执行相应的查询。在这里，我们采用了预查询的概念：`query.prepare()`
    函数接受一个 `query` 参数，其中包含稍后提供的参数的占位符。我们将使用 `:name` 语法提供 `name` 参数。支持两种语法：Oracle 风格的冒号-名称（例如，`:name`）或
    ODBC 风格的问号（例如，`?name`）。'
- en: We then bind the bind `:name` syntax to the value of the `album.name()` function.
    Because `QSqlQuery::bind()` expects a `QVariant` as a parameter value, we have
    to add the `include` directive to this class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `bind :name` 语法绑定到 `album.name()` 函数的值。因为 `QSqlQuery::bind()` 期望一个 `QVariant`
    作为参数值，所以我们必须向这个类添加 `include` 指令。
- en: In a nutshell, a `QVariant` is a generic data holder that accepts a wide range
    of primitive types (`char`, `int`, `double`, and so on) and complex types (`QString`, `QByteArray`, `QUrl`,
    and so on).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`QVariant` 是一个通用数据持有者，可以接受广泛的原始类型（`char`、`int`、`double` 等）和复杂类型（`QString`、`QByteArray`、`QUrl`
    等）。
- en: When the `query.exec()` function is executed, the bound values are properly
    replaced. The `prepare()` statement technique makes the code more robust to SQL
    injection (injecting a hidden request would fail) and more readable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `query.exec()` 函数时，绑定的值会被正确替换。`prepare()` 语句技术使代码对 SQL 注入（注入一个隐藏请求会失败）更加健壮，并且更易于阅读。
- en: The execution of the query modifies the state of the object query itself. The
    `QSqlQuery` query is not simply a SQL query executor, it also contains the state
    of the active query. We can retrieve information about the query with the `query.lastInsertId()`
    function, which returns a `QVariant` value containing the ID of the album row
    we just inserted. This `id` is given to the `album` provided in the `addAlbum()`
    parameter. Because we modify `album`, we cannot mark the parameter as `const`.
    Being strict about the `const` correctness of your code is a good hint for a fellow
    developer, who can deduce that your function might (or not) modify the passed
    parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的执行会修改查询对象`query`本身的状态。`QSqlQuery`查询不仅是一个SQL查询执行器，它还包含活动查询的状态。我们可以使用`query.lastInsertId()`函数检索有关查询的信息，该函数返回一个包含我们刚刚插入的相册行ID的`QVariant`值。这个`id`被赋予在`addAlbum()`参数中提供的`album`。因为我们修改了`album`，所以我们不能将参数标记为`const`。对代码的`const`正确性严格把关是给其他开发者一个好的提示，他们可以推断出你的函数可能会（或可能不会）修改传递的参数。
- en: 'The remaining update and delete operations follow strictly the same pattern
    used for `addAlbum()`. We will just provide the expected function signatures in
    the next code snippet. Please refer to the source code of the chapter for the
    complete implementation. However, we need to implement the request to retrieve
    all the albums in the database. This one deserves a closer look:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的更新和删除操作严格遵循与`addAlbum()`相同的模式。我们将在下一个代码片段中提供预期的函数签名。请参考该章节的源代码以获取完整的实现。然而，我们需要实现检索数据库中所有相册的请求。这个请求值得仔细看看：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `albums()` function must return a `QVector<Album*>` value. If we take a
    look at the body of the function, we see yet another property of `QSqlQuery`.
    To walk through multiple rows for a given request, `query` handles an internal
    cursor pointing to the current row. We can then proceed to create a `new Album*()`
    function and fill it with the row data with the `query.value()` statement, which
    takes a column name parameter and returns a `QVariant` value that is casted to
    the proper type. This new `album` parameter is appended to the `list` and, finally,
    this `list` is returned to the caller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`albums()`函数必须返回一个`QVector<Album*>`值。如果我们看一下函数的主体，我们会看到`QSqlQuery`的另一个属性。为了遍历给定请求的多行，`query`处理一个指向当前行的内部游标。然后我们可以继续创建一个`new
    Album*()`函数，并使用`query.value()`语句填充行数据，该语句接受一个列名参数并返回一个被转换为正确类型的`QVariant`值。这个新的`album`参数被添加到`list`中，最后，这个`list`被返回给调用者。'
- en: 'The `PictureDao` class is very similar to the `AlbumDao` class, both in usage
    and implementation. The main difference is that a picture has a foreign key to
    an album. The `PictureDao` function must be conditioned by an `albumId` parameter.
    The following code snippet shows the `PictureDao` header and the `init()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`PictureDao`类在用法和实现上与`AlbumDao`类非常相似。主要区别在于图片有一个指向相册的外键。`PictureDao`函数必须根据`albumId`参数进行条件限制。下面的代码片段显示了`PictureDao`头文件和`init()`函数：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, multiple functions take an `albumId` parameter to make the link
    between the picture and the owning `album` parameter. In the `init()` function,
    the foreign key is expressed in the `album_id INTEGER` syntax. SQLITE3 does not
    have a proper foreign key type. It is a very simple database and there is no strict
    constraint for this type of field; a simple integer is used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，多个函数接受一个`albumId`参数，以在图片和拥有`album`参数之间建立联系。在`init()`函数中，外键以`album_id INTEGER`语法表示。SQLITE3没有合适的外键类型。它是一个非常简单的数据库，并且没有对这个类型字段进行严格的约束；这里使用了一个简单的整数。
- en: Finally, the `PictureDao` function is added in the `DatabaseManager` class exactly
    as we did for `albumDao`. One could argue that, if there are a lot of `Dao` classes,
    adding a `const Dao` member in the `DatabaseManager` class and calling the `init()`
    function quickly becomes cumbersome.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`DatabaseManager`类中添加了`PictureDao`函数，其方式与我们为`albumDao`所做的一样。有人可能会争论，如果有很多`Dao`类，那么在`DatabaseManager`类中添加一个`const
    Dao`成员并快速调用`init()`函数会变得很繁琐。
- en: A possible solution could be to make an abstract `Dao` class, with a pure virtual `init()`
    function. The `DatabaseManager` class would have a `Dao` registry, which maps
    each `Dao` to a `QString` key with a `QHash<QString, const Dao> mDaos`. The `init()`
    function call would then be called in a `for` loop and a `Dao` object would be
    accessed using the `QString` key. This is outside the scope of this project, but
    is nevertheless an interesting approach.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是创建一个抽象的 `Dao` 类，其中包含一个纯虚的 `init()` 函数。`DatabaseManager` 类将有一个 `Dao`
    注册表，它将每个 `Dao` 映射到一个 `QString` 键，并使用 `QHash<QString, const Dao> mDaos`。然后，`init()`
    函数调用将在 `for` 循环中进行，并使用 `QString` 键访问 `Dao` 对象。这超出了本项目范围，但仍然是一个有趣的方法。
- en: Protecting your code with a smart pointer
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针保护你的代码
- en: 'The code we just described is fully functional, but, it can be strengthened,
    specifically with the function, `AlbumDao::albums()`. In this function, we iterate
    through the database rows and create a new `Album` to fill a list. We can zoom
    in on this specific code section:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的代码是完全有效的，但它可以通过 `AlbumDao::albums()` 函数来加强，特别是这个函数。在这个函数中，我们遍历数据库行并创建一个新的
    `Album` 来填充列表。我们可以聚焦于这个特定的代码段：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s say that the `name` column has been renamed to `title`. If you forget
    to update `query.value("name")`, you might run into trouble. The Qt framework
    does not rely on exceptions, but this cannot be said for every API available in
    the wild. An exception here would cause a memory leak: the `Album* album` function
    has been allocated on the heap but not released. To handle this, you would have
    to surround the risky code with a `try` `catch` statement and deallocate the `album`
    parameter if an exception has been thrown. Maybe this error should bubble up;
    hence, your `try``catch` statement is only there to handle the potential memory
    leak. Can you picture the spaghetti code weaving in front of you?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `name` 列已经被重命名为 `title`。如果你忘记更新 `query.value("name")`，你可能会遇到麻烦。Qt 框架不依赖于异常，但并非所有野外的
    API 都是这样。这里的异常会导致内存泄漏：`Album* album` 函数已经在堆上分配，但未释放。为了处理这种情况，你需要在有风险的代码周围加上 `try`
    `catch` 语句，并在抛出异常时释放 `album` 参数。也许这个错误应该向上冒泡；因此，你的 `try` `catch` 语句只是为了处理潜在的内存泄漏。你能想象在你面前编织的意大利面代码吗？
- en: The real issue with pointers is the uncertainty of their ownership. Once it
    has been allocated, who is the owner of a pointer? Who is responsible for deallocating
    the object? When you pass a pointer as a parameter, when does the caller retain
    the ownership or release it to the callee?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的真正问题是所有权的不可确定性。一旦分配，指针的所有者是谁？谁负责释放对象？当你将指针作为参数传递时，调用者何时保留所有权或将其释放给被调用者？
- en: 'Since C++11, a major milestone has been reached in memory management: the smart
    pointer feature has been stabilized and can greatly improve the safety of your
    code. The goal is to explicitly indicate the ownership of a pointer through simple
    template semantics. There are three types of smart pointer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，内存管理达到了一个重要的里程碑：智能指针功能已经稳定，可以大大提高你代码的安全性。目标是通过对简单的模板语义进行显式地指示指针的所有权。有三种类型的智能指针：
- en: The `unique_ptr` pointer indicates that the owner is the only owner of the pointer
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_ptr` 指针表明所有者是唯一的指针所有者'
- en: The `shared_ptr` pointer indicates that the pointer's ownership is shared among
    several clients
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr` 指针表明指针的所有权在多个客户端之间共享'
- en: The `weak_ptr` pointer indicates that the pointer does not belong to the client
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak_ptr` 指针表明指针不属于客户端'
- en: For now, we will focus on the  `unique_ptr` pointer to understand smart pointer
    mechanics.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于 `unique_ptr` 指针来理解智能指针的机制。
- en: 'A `unique_ptr` pointer is simply a variable allocated on the stack that takes
    the ownership of the pointer you provide with it. Let''s allocate an `Album` with
    this semantic:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 指针实际上是在栈上分配的一个变量，它接管了你提供的指针的所有权。让我们用这种语义来分配一个 `Album`：'
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The whole smart pointer API is available in the `memory` header. When we declared `album`
    as a `unique_ptr`, we did two things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 整个智能指针 API 都可以在 `memory` 头文件中找到。当我们将 `album` 声明为 `unique_ptr` 时，我们做了两件事：
- en: We allocated on the stack a `unique_ptr<Album>`. The `unique_ptr` pointer relies
    on templates to check at compile time the validity of the pointer type.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在栈上分配了一个 `unique_ptr<Album>`。`unique_ptr` 指针依赖于模板在编译时检查指针类型的有效性。
- en: We granted the ownership of `albumPointer` memory to `album`. From this point
    on, `album` is the owner of the pointer.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `albumPointer` 内存的所有权授予了 `album`。从这一点开始，`album` 就是指针的所有者。
- en: This simple line has important ramifications. First and foremost, you do not
    have to worry anymore about the pointer life cycle. Because a `unique_ptr` pointer
    is allocated on the stack, it will be destroyed as soon as it goes out of scope.
    In this example, when we exit `foo()`, `album` will be removed from the stack.
    The `unique_ptr` implementation will take care of calling the `Album` destructor
    and deallocating the memory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单的一行有重要的影响。首先，你再也不必担心指针的生命周期了。因为 `unique_ptr` 指针是在堆栈上分配的，所以一旦超出作用域就会销毁。在这个例子中，当我们退出
    `foo()` 时，`album` 将从堆栈中移除。`unique_ptr` 实现将负责调用 `Album` 析构函数并释放内存。
- en: Secondly, you explicitly indicate the ownership of your pointer at compile time.
    Nobody can deallocate the `albumPointer` content if they do not voluntarily fiddle
    with your `unique_ptr` pointer. Your fellow developers will also know with a single
    glance who is the owner of your pointer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你在编译时明确指出了你指针的所有权。如果他们没有自愿地摆弄你的 `unique_ptr` 指针，没有人可以释放 `albumPointer` 的内容。你的同事开发者也可以一眼看出谁是你的指针的所有者。
- en: Note that, even though `album` is a type of `unique_ptr<Album>`, you can still
    call `Album` functions (for example, `album->setName()`) using the `->` operator.
    This is possible thanks to the overload of this operator. The usage of the `unique_ptr`
    pointer becomes transparent.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `album` 是 `unique_ptr<Album>` 类型，但你仍然可以使用 `->` 操作符调用 `Album` 函数（例如，`album->setName()`）。这是由于这个操作符的重载。`unique_ptr`
    指针的使用变得透明。
- en: 'Well, this use case is nice, but the purpose of a pointer is to be able to
    allocate a chunk of memory and share it. Let''s say the `foo()` function allocates
    the `album unique_ptr` pointer and then transfers the ownership to `bar()`. This
    would look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个用例很不错，但指针的目的是能够分配一块内存并共享它。比如说，`foo()` 函数分配了 `album unique_ptr` 指针，然后将所有权转让给
    `bar()`。这看起来是这样的：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we introduce the `std::move()` function: its goal is to transfer the
    ownership of a `unique_ptr` function. Once `bar(std::move(album))` has been called, `album`
    becomes invalid. You can test it with a simple `if` statement: `if (album) { ...
    }`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们介绍 `std::move()` 函数：它的目的是转移 `unique_ptr` 函数的所有权。一旦调用 `bar(std::move(album))`，`album`
    就变得无效。你可以用一个简单的 `if` 语句来测试它：`if (album) { ... }`。
- en: From now on, the `bar()` function becomes the owner of the pointer (through `barAlbum`)
    by allocating a new `unique_ptr` on the stack and it will deallocate the pointer
    on its exit. You do not have to worry about the cost of a `unique_ptr` pointer,
    as these objects are very lightweight and it is unlikely that they will affect
    the performance of your application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，`bar()` 函数通过在堆栈上分配一个新的 `unique_ptr` 来成为指针的所有者（通过 `barAlbum`），并在退出时释放指针。你不必担心
    `unique_ptr` 指针的成本，因为这些对象非常轻量级，它们不太可能影响你应用程序的性能。
- en: Again, the signature of `bar()` tells the developer that this function expects
    to take the ownership of the passed `Album`. Trying to pass around `unique_ptr`
    without the `move()` function will lead to a compile error.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`bar()` 函数的签名告诉开发者这个函数期望接收传递的 `Album` 的所有权。试图在没有使用 `move()` 函数的情况下传递 `unique_ptr`
    将导致编译错误。
- en: 'Another thing to note is the different meanings of the `.` (dot) and the `->`
    (arrow) when working with a `unique_ptr` pointer:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，在处理 `unique_ptr` 指针时，`.`（点）和 `->`（箭头）的不同含义：
- en: The `->` operator dereferences to the pointer members and lets your call function
    on your real object
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->` 操作符解引用到指针成员，并允许你调用真实对象的函数'
- en: The `.` operator gives you access to the `unique_ptr` object functions
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 操作符让你可以访问 `unique_ptr` 对象的函数'
- en: 'The `unique_ptr` pointer provides various functions. Among the most important
    are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 指针提供了各种函数。其中最重要的包括：'
- en: The `get()` function returns the raw pointer. The `album.get()` returns an `Album*`
    value.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()` 函数返回原始指针。`album.get()` 返回一个 `Album*` 值。'
- en: The `release()` function releases the ownership of the pointer and returns the
    raw pointer. The `album.release()` function returns an `Album*` value.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release()` 函数释放了指针的所有权并返回原始指针。`album.release()` 函数返回一个 `Album*` 值。'
- en: The `reset(pointer p = pointer())` function destroys the currently managed pointer
    and takes ownership of the given parameter. An example would be the `barAlbum.reset()`
    function, which destroys the currently owned `Album*`. With a parameter, `barAlbum.reset(new
    Album())` also destroys the owned object and takes the ownership of the provided
    parameter.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset(pointer p = pointer())`函数销毁当前管理的指针，并获取给定参数的所有权。一个例子是`barAlbum.reset()`函数，它销毁当前拥有的`Album*`。带有参数的`barAlbum.reset(new
    Album())`也会销毁拥有的对象，并获取提供的参数的所有权。'
- en: 'Finally, you can dereference the object with the `*` operation, meaning `*album`
    will return an `Album&` value. This dereferencing is convenient, but you will
    see that the more a smart pointer is used, the less you will need it. Most of
    the time, you will replace a raw pointer with the following syntax:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`*`操作符取消引用对象，这意味着`*album`将返回一个`Album&`值。这种取消引用很方便，但您会看到，智能指针使用得越多，您就越不需要它。大多数时候，您会用以下语法替换原始指针：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because we pass the `unique_ptr` by reference, `bar()` does not take ownership
    of the pointer and will not try do deallocate it upon its exit. With this, there
    is no need to use `move(album)` in `foo()`; the `bar()` function will just do
    operations on the `album` parameter but will not take its ownership.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们通过引用传递`unique_ptr`，`bar()`不会获取指针的所有权，并在退出时不会尝试释放它。因此，在`foo()`中不需要使用`move(album)`；`bar()`函数将只对`album`参数进行操作，但不会获取其所有权。
- en: Now, let's consider `shared_ptr`. A `shared_ptr` pointer keeps a reference counter
    on a pointer. Each time a `shared_ptr` pointer references the same object, the
    counter is incremented; when this `shared_ptr` pointer goes out of scope, the
    counter is decremented. When the counter reaches zero, the object is deallocated.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑`shared_ptr`。`shared_ptr`指针在指针上保持一个引用计数器。每次`shared_ptr`指针引用相同的对象时，计数器会增加；当这个`shared_ptr`指针超出作用域时，计数器会减少。当计数器达到零时，对象将被释放。
- en: 'Let''s rewrite our `foo()`/`bar()` example with a `shared_ptr` pointer:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`shared_ptr`指针重写我们的`foo()`/`bar()`示例：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the syntax is very similar to the `unique_ptr` pointer. The
    reference counter is incremented each time a new `shared_ptr` pointer is allocated
    and points to the same data, and is decremented on the function exit. You can
    check the current count by calling the `album.use_count()` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，语法与`unique_ptr`指针非常相似。每次分配新的`shared_ptr`指针并指向相同的数据时，引用计数器会增加，在函数退出时减少。您可以通过调用`album.use_count()`函数来检查当前的计数。
- en: 'The last smart pointer we will cover is the `weak_ptr` pointer. As the name
    suggests, it does not take any ownership or increment the reference counter. When
    a function specifies a `weak_ptr`, it indicates to the callers that it is just
    a client and not an owner of the pointer. If we re implement `bar()` with a `weak_ptr`
    pointer, we get:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个智能指针是`weak_ptr`指针。正如其名所示，它不会获取任何所有权或增加引用计数。当函数指定一个`weak_ptr`时，它向调用者表明它只是一个客户端，而不是指针的所有者。如果我们用`weak_ptr`指针重新实现`bar()`，我们得到：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the story stopped here, there would not be any interest in using a `weak_ptr`
    versus a raw pointer. The `weak_ptr` has a major advantage for the dangling pointer
    issue. If you are building a cache, you typically do not want to keep strong references
    to your object. On the other hand, you want to know if the objects are still valid.
    By using `weak_ptr`, you know when an object has been deallocated. Now, consider
    the raw pointer approach: your pointer might be invalid but you do not know the
    state of the memory.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果故事到此为止，使用`weak_ptr`与原始指针之间就不会有任何兴趣。`weak_ptr`在悬空指针问题上有一个主要优势。如果您正在构建缓存，通常您不希望保留对对象的强引用。另一方面，您想知道对象是否仍然有效。通过使用`weak_ptr`，您知道对象何时被释放。现在，考虑原始指针方法：您的指针可能无效，但您不知道内存的状态。
- en: 'There is another semantic introduced in C++14 that we have to cover: `make_unique`.
    This keyword aims to replace the `new` keyword and construct a `unique_ptr` object
    in an exception-safe manner. This is how it is used:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++14中引入了另一个语义，我们必须涵盖：`make_unique`。这个关键字旨在替换`new`关键字，并以异常安全的方式构造一个`unique_ptr`对象。这是它的用法：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `make_unique` keyword wraps the `new` keyword to make it exception-safe,
    specifically in this situation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`关键字封装了`new`关键字，使其异常安全，特别是在这种情况下：'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code will be executed in the following order:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将按以下顺序执行：
- en: Allocate and construct the `Album` function.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配和构造`Album`函数。
- en: Allocate and construct the `Picture` function.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配和构造`Picture`函数。
- en: Execute the `foo()` function.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `foo()` 函数。
- en: 'If `new Picture()` throws an exception, the memory allocated by `new Album()`
    will be leaked. This is fixed by using the `make_unique` keyword:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `new Picture()` 抛出异常，由 `new Album()` 分配的内存将会泄漏。这个问题可以通过使用 `make_unique` 关键字来解决：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `make_unique` keyword returns a `unique_ptr` pointer; the C++ standard committee
    also provided an equivalent for `shared_ptr` in the form of `make_shared`, which
    follows the same principle.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique` 关键字返回一个 `unique_ptr` 指针；C++ 标准委员会还提供了 `shared_ptr` 的等效形式 `make_shared`，遵循相同的原理。'
- en: 'All these new C++ semantics try very hard to get rid of `new` and `delete`.
    Yet, it may be cumbersome to write all the `unique_ptr` and `make_unique` stuff.
    The `auto` keyword comes to the rescue in our `album` creation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些新的 C++ 语义都尽力消除 `new` 和 `delete`。然而，编写所有的 `unique_ptr` 和 `make_unique` 可能会有些繁琐。在
    `album` 创建中，`auto` 关键字提供了帮助：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a radical departure from the common C++ syntax. The variable type is
    deduced, there is no explicit pointer, and the memory is automatically managed.
    After some time with smart pointers, you will see fewer and fewer raw pointers
    in your code (and even fewer `delete`, which is such a relief). The remaining
    raw pointers will simply indicate that a client is using the pointer but does
    not own it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这与常见的 C++ 语法有很大的不同。变量类型是推断出来的，没有显式的指针，内存是自动管理的。在使用智能指针一段时间后，你会在代码中看到越来越少的原始指针（甚至更少的
    `delete`，这真是一种解脱）。剩余的原始指针将简单地表明客户端正在使用指针，但并不拥有它。
- en: Overall, C++11 and C++14 smart pointers are a real step up in C++ code writing.
    Before them, the bigger the code base, the more insecure we felt about memory
    management. Our brain is just bad at properly grasping complexity at such a level.
    Smart pointers simply make you feel safe about what you write. On the other hand,
    you retain full control of the memory. For performance-critical code, you can
    always handle the memory yourself. For everything else, smart pointers are an
    elegant way of explicitly indicating your object's ownership and freeing your
    mind.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，C++11 和 C++14 的智能指针在 C++ 代码编写中是一个真正的进步。在此之前，代码库越大，我们对内存管理的安全感就越低。我们的头脑在处理这种级别的复杂性时总是不够好。智能指针简单地说让你对自己的代码感到安全。另一方面，你仍然可以完全控制内存。对于性能关键代码，你始终可以自己处理内存。对于其他所有事情，智能指针是明确表示对象所有权和解放思想的一种优雅方式。
- en: 'We are now equipped to rewrite the little insecure snippet in the `AlbumDao::albums()`
    function. Update `AlbumDao::albums()` like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重新编写 `AlbumDao::albums()` 函数中的小片段。更新 `AlbumDao::albums()` 如下：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Wow! The signature of the `album()` function has turned into something very
    peculiar. Smart pointers are supposed to make your life easier, right? Let''s
    break it down to understand a major point of smart pointers with Qt: container
    behavior.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！`album()` 函数的签名已经变成了一个非常奇特的东西。智能指针本应使你的生活变得更简单，对吧？让我们分解一下，以了解 Qt 中智能指针的一个主要点：容器行为。
- en: The initial goal of the rewrite was to secure the creation of `album`. We want
    the `list` to be the explicit owner of the `album`. This would have changed our `list`
    type (that is `albums()` return type) to `QVector<unique_ptr<Album>>`. However,
    when the `list` type is returned, its elements will be copied (remember, we previously
    defined the return type to `QVector<Album>`). A natural way out of this would
    be to return a `QVector<unique_ptr<Album>>*` type to retain the uniqueness of
    our `Album` elements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的初始目标是确保 `album` 的创建。我们希望 `list` 成为 `album` 的明确所有者。这将使我们的 `list` 类型（即 `albums()`
    返回类型）变为 `QVector<unique_ptr<Album>>`。然而，当返回 `list` 类型时，其元素将被复制（记住，我们之前定义的返回类型为
    `QVector<Album>`）。从这个角度来看，一个自然的解决方案是返回 `QVector<unique_ptr<Album>>*` 类型以保持 `Album`
    元素的唯一性。
- en: 'Behold, here lies a major pain: the `QVector` class overloads the copy operator.
    Hence, when the `list` type is returned, the uniqueness of our `unique_ptr` elements
    cannot be guaranteed by the compiler and it will throw a compile error. This is
    why we have to resort to a `vector` object coming from the standard library and
    write the long type: `unique_ptr<vector<unique_ptr<Album>>>`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这里的主要痛点：`QVector` 类重载了复制操作符。因此，当返回 `list` 类型时，编译器无法保证我们的 `unique_ptr` 元素的唯一性，并且会抛出编译错误。这就是为什么我们必须求助于标准库中的
    `vector` 对象，并编写长类型：`unique_ptr<vector<unique_ptr<Album>>>`。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take a look at the official response for support of the `unique_ptr` pointer
    in the Qt container. It is clear beyond any possible doubt: [http://lists.qt-project.org/pipermail/interest/2013-July/007776.html](http://lists.qt-project.org/pipermail/interest/2013-July/007776.html).
    The short answer is: no, it will never be done. Do not even mention it. Ever.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下官方对Qt容器中`unique_ptr`指针支持的回应。毫无疑问：[http://lists.qt-project.org/pipermail/interest/2013-July/007776.html](http://lists.qt-project.org/pipermail/interest/2013-July/007776.html)。简短的回答是：不，它永远不会完成。永远不要提及它。
- en: 'If we translate this new `albums()` signature into plain English it will read:
    the `album()` function returns a vector of `Album`. This vector is the owner of
    the `Album` elements it contains and you will be the owner of the vector.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个新的`albums()`签名翻译成普通英语，它将读作：`album()`函数返回一个`Album`的向量。这个向量是其包含的`Album`元素的拥有者，而你将是向量的拥有者。
- en: To finish covering this implementation of `albums()`, you may notice that we
    did not use the `auto` and `make_unique` keywords for the `list` declaration.
    Our library will be used on a mobile in [Chapter 5](part0048.xhtml#aid-1DOR02
    "Chapter 5.  Dominating the Mobile UI"), *Dominating the Mobile UI*, and C++14
    is not yet supported on this platform. Therefore, we have to restrain our code
    to C++11.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成对`albums()`实现的覆盖，你可能注意到我们没有在`list`声明中使用`auto`和`make_unique`关键字。我们的库将在[第5章](part0048.xhtml#aid-1DOR02
    "第5章。掌握移动UI")的移动设备上使用，*掌握移动UI*，并且该平台尚不支持C++14。因此，我们必须将我们的代码限制在C++11中。
- en: We also encounter the use of the `move` function in the instruction `list->push_back(move(album))`.
    Until that line, the `album` is "owned" by the `while` scope, the move gives the
    ownership to the list. At the last instruction, `return list`, we should have
    written `move(list)`, but C++11 accepts the direct return and will automatically
    make the `move()` function for us.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也遇到了在指令`list->push_back(move(album))`中使用`move`函数的情况。直到那一行，`album`是`while`作用域的“所有者”，移动操作将所有权转移给了列表。在最后的指令`return
    list`中，我们应该写成`move(list)`，但C++11接受直接返回，并且会自动为我们调用`move()`函数。
- en: What we covered in this section is that the `AlbumDao` class is completely matched
    in `PictureDao`. Please refer to the source code of the chapter to see the full `PictureDao`
    class implementation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中涵盖的内容是`AlbumDao`类与`PictureDao`完全匹配。请参考章节的源代码以查看完整的`PictureDao`类实现。
- en: Implementing the model
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模型
- en: The data is ready to be exposed to potential clients (the applications that
    will display and edit its content). However, a direct connection between the client
    and the database will make a very strong coupling. If we decide to switch to another
    storage type, the view would have to be rewritten, partially at least.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据已经准备好向潜在的客户（将显示和编辑其内容的应用程序）公开。然而，客户端和数据库之间的直接连接将导致非常强的耦合。如果我们决定切换到另一种存储类型，视图至少部分需要重写。
- en: 'This is where the model comes to our rescue. It is an abstract layer that communicates
    with the data (our database) and exposes this data to the client in a data-specific,
    implementation-agnostic form. This approach is a direct offspring of the **MVC**
    (**Model View Controller**) concept. Let''s recapitulate how MVC works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模型来拯救我们的地方。它是一个抽象层，与数据（我们的数据库）进行通信，并以数据特定的、实现无关的形式向客户端公开这些数据。这种方法是**MVC**（**模型-视图-控制器**）概念的直接后代。让我们回顾一下MVC是如何工作的：
- en: The Model manages the data. It is responsible for requesting for the data and
    updating it.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型管理数据。它负责请求数据并更新数据。
- en: The View displays the data to the user.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图向用户显示数据。
- en: The Controller interacts with both the Model and the View. It is responsible
    for feeding the View with the correct data and sending commands to the Model based
    on the user interaction received from the View.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器与模型和视图都进行交互。它负责向视图提供正确的数据，并根据从视图接收到的用户交互向模型发送命令。
- en: This paradigm enables swapping various parts without disturbing the others.
    Multiple views can display the same data, the data layer can be changed, and the
    upper parts will not be aware of it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种范式使得在不干扰其他部分的情况下交换各种部分成为可能。多个视图可以显示相同的数据，数据层可以更改，而上层将不会意识到这一点。
- en: 'Qt combines the View and the Controller to form the Model/View architecture.
    The separation of the storage and the presentation is retained while being simpler
    to implement than a full MVC approach. To allow editing and view customization,
    Qt introduces the concept of Delegate, which is connected to both the Model and
    the View:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 将视图和控制结合在一起形成模型/视图架构。在实现上比完整的 MVC 方法更简单的同时，保留了存储和表示的分离。为了允许编辑和视图定制，Qt 引入了代理的概念，该代理连接到模型和视图：
- en: '![Implementing the model](img/image00367.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![实现模型](img/image00367.jpeg)'
- en: The Qt documentation about Model/View is truly plethoric. It is nevertheless
    easy to get lost in the details; it feels sometimes a bit overwhelming. We will
    try to clear things up by implementing the `AlbumModel` class and seeing how it
    works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 关于模型/视图的文档确实非常丰富。然而，有时在细节中迷失方向；有时感觉有点令人不知所措。我们将通过实现 `AlbumModel` 类并观察其工作方式来尝试澄清这些问题。
- en: 'Qt offers various Model sub-classes that all extend from `QAbstractItemModel`.
    Before starting the implementation, we have to carefully choose which base class
    will be extended. Keep in mind that our data are variations on lists: we will
    have a list of albums, and each album will have a list of pictures. Let''s see
    what Qt offers us:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了各种模型子类，它们都扩展自 `QAbstractItemModel`。在开始实现之前，我们必须仔细选择要扩展的基类。记住，我们的数据是列表的变体：我们将有一个专辑列表，每个专辑将有一个图片列表。让我们看看
    Qt 提供了什么：
- en: '`QAbstractItemModel`: This class is the most abstract, and therefore, the most
    complex, to implement. We will have to redefine a lot of functions to properly
    use it.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QAbstractItemModel`：这是一个最抽象的类，因此也是最难实现的。我们将不得不重新定义很多函数来正确使用它。'
- en: '`QStringListModel`: This class is a model that supplies strings to views. It
    is too simple. Our model is more complex (we have custom objects).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStringListModel`：这是一个向视图提供字符串的模型。它太简单了。我们的模型更复杂（我们有自定义对象）。'
- en: '`QSqlTableModel` (or `QSqLQueryModel`): This class is a very interesting contender.
    It automatically handles multiple SQL queries. On the other hand, it works only
    for very simple table schemas. In the `pictures` table, for example, the `album_id`
    foreign key makes it very hard to fit this model. You might save some lines of
    code, but if feels like trying to shoehorn a round peg into a square hole.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSqlTableModel`（或 `QSqLQueryModel`）：这个类是一个非常有趣的竞争者。它自动处理多个 SQL 查询。另一方面，它仅适用于非常简单的表模式。例如，在
    `pictures` 表中，`album_id` 外键使其很难适应这个模型。你可能可以节省一些代码行，但感觉就像试图将一个圆形的木塞塞入一个方形的孔中。'
- en: '`QAbstractListModel`: This class provides a model that offers one-dimensional
    lists. This fits nicely with our requirements, saves a lot of key strokes, and
    is still flexible enough.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QAbstractListModel`：这个类提供了一个提供一维列表的模型。这非常适合我们的需求，节省了很多键盘敲击，并且仍然足够灵活。'
- en: 'We will go with the `QabstractListModel` class and create a new C++ class named `AlbumModel`.
    Update the `AlbumModel.h` file to look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `QabstractListModel` 类并创建一个新的 C++ 类名为 `AlbumModel`。更新 `AlbumModel.h` 文件，使其看起来像这样：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `AlbumModel` class extends the `QAbstractListModel` class and has only
    two members:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumModel` 类扩展了 `QAbstractListModel` 类，并且只有两个成员：'
- en: '`mDb`: This is the link to the database. In the Model/View schema, the model
    will communicate with the data layer through `mDb`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mDb`：这是数据库的链接。在模型/视图架构中，模型将通过 `mDb` 与数据层进行通信。'
- en: '`mAlbums`: This acts as a buffer that will avoid hitting the database too much.
    The type should remind you of what we wrote for `AlbumDao::albums()` with the
    smart pointers.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mAlbums`：这充当一个缓冲区，将避免过多地访问数据库。类型应该让你想起我们为 `AlbumDao::albums()` 编写的智能指针。'
- en: The only specific functions the `AlbumModel` class has are `addAlbum()` and `isIndexValid()`.
    The rest are overrides of `QAbstractListModel` functions. We will go through each
    of these functions to understand how a model works.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumModel` 类唯一的特定函数是 `addAlbum()` 和 `isIndexValid()`。其余的都是 `QAbstractListModel`
    函数的重写。我们将逐一介绍这些函数，以了解模型是如何工作的。'
- en: 'First, let''s see how the `AlbumModel` class is constructed in the `AlbumModel.cpp`
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `AlbumModel` 类在 `AlbumModel.cpp` 文件中的构建方式：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `mDb` file is initialized with the `DatabaseManager` singleton address,
    and, after that, we see the now famous `AlbumDao::albums()` in action.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`mDb` 文件使用 `DatabaseManager` 单例地址初始化，之后我们看到现在著名的 `AlbumDao::albums()` 正在发挥作用。'
- en: The `vector` type is returned and initializes `mAlbums`. This syntax make the
    ownership transfer automatic without any need for an explicit call to the `std::move()`
    function. If there are any stored albums in the database, `mAlbums` is immediately
    filled with those.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`vector`类型并初始化`mAlbums`。这种语法使得所有权转移是自动的，无需显式调用`std::move()`函数。如果数据库中存储有任何专辑，`mAlbums`将立即填充这些专辑。
- en: Each time the model interacts with the view (to notify us about changes or to
    serve data), `mAlbums` will be used. Because it is in memory only, reading will
    be very fast. Of course, we have to be careful about maintaining `mAlbum` coherently
    with the database state, but everything will stay inside the `AlbumModel` inner
    mechanics.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每次模型与视图交互（通知我们变化或提供数据）时，都会使用`mAlbums`。因为它仅在内存中，所以读取将非常快。当然，我们必须小心保持`mAlbum`与数据库状态的连贯性，但所有操作都将保持在`AlbumModel`内部机制中。
- en: 'As we said earlier, the model aims to be the central point to interact with
    the data. Each time the data changes, the model will emit a signal to notify the
    view; each time the view wants to display data, it will request the model for
    it. The `AlbumModel` class overrides everything needed for read and write access.
    The read functions are:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，该模型旨在成为与数据交互的中心点。每次数据发生变化时，模型都会发出一个信号来通知视图；每次视图想要显示数据时，它将请求模型提供数据。`AlbumModel`类覆盖了读写访问所需的所有内容。读函数包括：
- en: '`rowCount()`: This function is used to get the list size'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowCount()`: 此函数用于获取列表大小'
- en: '`data()`: This function is used to get a specific piece of information about
    the data to display'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data()`: 此函数用于获取要显示的数据的特定信息'
- en: '`roleNames()`: This function is used to indicate to the framework the name
    for each "role". We will explain in a few paragraphs what a role is'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roleNames()`: 此函数用于向框架指示每个“角色”的名称。我们将在接下来的几段中解释什么是角色'
- en: 'The editing functions are:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑函数包括：
- en: '`setData()`: This function is used to update data'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData()`: 此函数用于更新数据'
- en: '`removeRows()`: This function is used to remove data'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeRows()`: 此函数用于删除数据'
- en: We will start with the read part, where the view asks the model for the data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从读取部分开始，其中视图请求模型提供数据。
- en: 'Because we will display a list of albums, the first thing the view should know
    is how many items are available. This is done in the `rowCount()` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将显示专辑列表，所以视图首先应该知道有多少可用项。这是在`rowCount()`函数中完成的：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Being our buffer object, using `mAlbums->size()` is perfect. There is no need
    to query the database, as `mAlbums` is already filled with all the albums of the
    database. The `rowCount()` function has an unknown parameter: a `const QModelIndex&
    parent`. Here, it is not used, but we have to explain what lies beneath this type
    before continuing our journey in the `AlbumModel` class.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的缓冲对象，使用`mAlbums->size()`是完美的。没有必要查询数据库，因为`mAlbums`已经填充了数据库中的所有专辑。`rowCount()`函数有一个未知参数：一个`const
    QModelIndex& parent`。在这里，它没有被使用，但我们必须在继续`AlbumModel`类的旅程之前解释这个类型背后的含义。
- en: 'The `QModelIndex` class is a central notion of the Model/View framework in
    Qt. It is a lightweight object used to locate data within a model. We use a simple `QAbstractListModel`
    class, but Qt is able to handle three representation types:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`QModelIndex`类是Qt中Model/View框架的一个核心概念。它是一个轻量级对象，用于在模型中定位数据。我们使用一个简单的`QAbstractListModel`类，但Qt能够处理三种表示类型：'
- en: '![Implementing the model](img/image00368.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![实现模型](img/image00368.jpeg)'
- en: There is no better explanation than an official Qt diagram
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比官方Qt图表更好的解释了
- en: 'Let''s now see the models in detail:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细看看模型：
- en: '**List Model**: In this model, the data is stored in a one-dimensional array
    (rows)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表模型**：在这个模型中，数据存储在一个一维数组中（行）'
- en: '**Table Model**: In this model, the data is stored in a two-dimensional array
    (rows and columns)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格模型**：在这个模型中，数据存储在一个二维数组中（行和列）'
- en: '**Tree Model**: In this model, the data is stored in a hierarchical relationship
    (parent/children)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树模型**：在这个模型中，数据以父子关系存储'
- en: 'To handle all these model types, Qt came up with the `QModelIndex` class, which
    is an abstract way of dealing with them. The `QModelIndex` class has the functions
    for each of the use cases: `row()`, `column()`, and `parent()`/`child()`. Each
    instance of a `QModelIndex` is meant to be short-lived: the model might be updated
    and thus the index will become invalid.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理所有这些模型类型，Qt提出了`QModelIndex`类，这是一种处理它们的抽象方式。`QModelIndex`类具有针对每个用例的函数：`row()`、`column()`和`parent()`/`child()`。每个`QModelIndex`实例都意味着是短暂的：模型可能会更新，因此索引将变得无效。
- en: The model will produce indexes according to its data type and will provide these
    indexes to the view. The view will then use them to query back new data to the
    model without needing to know if an `index.row()` function corresponds to a database
    row or a `vector` index.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 模型将根据其数据类型生成索引，并将这些索引提供给视图。然后视图将使用它们查询模型以获取新的数据，而无需知道`index.row()`函数是否对应于数据库行或`vector`索引。
- en: 'We can see the `index` parameter in action with the implementation of `data()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`data()`实现的`index`参数来看到`index`参数的作用：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The view will ask for data with two parameters: an `index` and a `role`. As
    we have already covered the `index`, we can focus on the `role` responsibility.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 视图将使用两个参数请求数据：一个`index`和一个`role`。因为我们已经涵盖了`index`，我们可以专注于`role`的责任。
- en: When the data is displayed, it will probably be an aggregation of multiple data.
    For example, displaying the picture will consist of a thumbnail and the picture
    name. Each one of these data elements needs to be retrieved by the view. The `role`
    parameter fills this need, it associates each data element to a tag for the view
    to know what category of data is shown.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被显示时，它可能是由多个数据聚合而成的。例如，显示图片将包括缩略图和图片名称。这些数据元素中的每一个都需要由视图检索。`role`参数满足这一需求，它将每个数据元素与一个标签关联，以便视图知道显示的数据类别。
- en: 'Qt provides various default roles (`DisplayRole`, `DecorationRole`, `EditRole`,
    and so on) and you can define your own if needed. This is what we did in the `AlbumModel.h`
    file with the `enum Roles`: we added an `IdRole` and a `NameRole`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了各种默认角色（`DisplayRole`、`DecorationRole`、`EditRole`等），如果需要，您可以定义自己的角色。这就是我们在`AlbumModel.h`文件中通过`enum
    Roles`所做的事情：我们添加了`IdRole`和`NameRole`。
- en: 'The body of the `data()` function is now within our reach! We first test the
    validity of the `index` with a helper function, `isIndexValid()`. Take a look
    at the source code of the chapter to see what it does in detail. The view asked
    for data at a specific `index`: we retrieve the `album` row at the given `index`
    with `*mAlbums->at(index.row())`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`函数的主体现在在我们手中！我们首先使用辅助函数`isIndexValid()`测试`index`的有效性。查看该章节的源代码以详细了解其功能。视图请求在特定的`index`处获取数据：我们使用`*mAlbums->at(index.row())`检索给定`index`处的`album`行。'
- en: This returns a `unique_ptr<Album>` value at the `index.row()` index and we dereference
    it to have an `Album&`. The `const` modifier is interesting here because we are
    in a read function, and it makes no sense to modify the `album` row. The `const`
    modifier adds this check at compile time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`index.row()`索引处返回一个`unique_ptr<Album>`值，并且我们取消引用它以获得一个`Album&`。在这里，`const`修饰符很有趣，因为我们处于一个读取函数中，修改`album`行没有意义。`const`修饰符在编译时添加了这个检查。
- en: The `switch` on the `role` parameter tells us what data category should be returned.
    The `data()` function returns a `QVariant` value, which is the Awiss Army Knife
    of types in Qt. We can safely return the `album.id()`, `album.name()`, or a default `QVariant()`
    if we do not handle the specified role.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`role`参数上的`switch`告诉我们应该返回哪种数据类别。`data()`函数返回一个`QVariant`值，这是Qt中类型的瑞士军刀。如果我们没有处理指定的角色，我们可以安全地返回`album.id()`、`album.name()`或默认的`QVariant()`。'
- en: 'The last read function to cover is `roleNames()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要覆盖的读取函数是`roleNames()`：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this level of abstraction, we do not know what type of view will be used
    to display our data. If the views are written in QML, they will need some meta-information
    about the data structure. The `roleNames()` function provides this information
    so the role names can be accessed via QML. If you are writing for a desktop widget
    view only, you can safely ignore this function. The library we are currently building
    will be used for QML; this is why we override this function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个抽象级别，我们不知道将使用哪种视图来显示我们的数据。如果视图是用QML编写的，它们将需要有关数据结构的一些元信息。`roleNames()`函数提供了这些信息，因此可以通过QML访问角色名称。如果您只为桌面小部件视图编写，可以安全地忽略此函数。我们目前正在构建的库将用于QML；这就是为什么我们重写了这个函数。
- en: The reading part of the model is now over. The client view has everything it
    needs to properly query and display the data. We shall now investigate the editing
    part of `AlbumModel`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的读取部分现在已完成。客户端视图已经拥有了正确查询和显示数据所需的一切。我们现在将研究 `AlbumModel` 的编辑部分。
- en: 'We will start with the creation of a new album. The view will build a new `Album`
    object and pass it to `Album::addAlbum()` to be properly persisted:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个新的专辑开始。视图将构建一个新的 `Album` 对象，并将其传递给 `Album::addAlbum()` 以正确持久化：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Indexes are a way to navigate within the model data. This first thing we do
    is to determinate what will be the index of this new album by getting the `mAlbums`
    size with `rowCount()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是导航模型数据的一种方式。我们首先做的事情是通过 `rowCount()` 获取 `mAlbums` 的大小，以确定这个新专辑的索引。
- en: 'From here, we start to use specific model functions: `beginInsertRows()` and `endInsertRows()`.
    These functions wrap real data modifications. Their purpose is to automatically
    trigger signals for whoever might be interested:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们开始使用特定的模型函数：`beginInsertRows()` 和 `endInsertRows()`。这些函数封装了实际的数据修改。它们的目的在于自动触发可能感兴趣的任何人的信号：
- en: '`beginInsertRows()`: This function informs that rows are about to change for
    the given indexes'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beginInsertRows()`：此函数通知给定索引的行即将更改'
- en: '`endInsertRows()`: This function informs that rows have been changed'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endInsertRows()`：此函数通知行已更改'
- en: The first parameter of the `beginInsertRows()` function is the `parent` for
    this new element. The root for a model is always an empty `QModelIndex()` constructor.
    Because we do not handle any hierarchical relationship in `AlbumModel`, it is
    safe to always add the new element to the root. The following parameters are the
    first and last modified indexes. We insert a single element per call, so we provide `rowIndex`
    twice. To illustrate the usage of this signal, a view might, for example, display
    a loading message telling the user "Saving 5 new albums".
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`beginInsertRows()` 函数的第一个参数是新元素的 `parent`。对于模型，根始终是空的 `QModelIndex()` 构造函数。因为我们没有在
    `AlbumModel` 中处理任何层次关系，所以始终将新元素添加到根是安全的。后续参数是第一个和最后一个修改的索引。我们每次调用插入一个元素，所以我们提供
    `rowIndex` 两次。为了说明这个信号的使用，例如，一个视图可能会显示一个加载消息，告诉用户“正在保存 5 个新专辑”。'
- en: For `endInsertRows()`, the interested view might hide the saving message and
    display "Save finished".
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `endInsertRows()`，感兴趣的视图可能会隐藏保存消息并显示“保存完成”。
- en: This may look strange at first, but it enables Qt to handle automatically a
    lot of signaling for us and in a generic way. You will see very soon how well
    this works when designing the UI of the application in [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这可能会看起来有些奇怪，但它使 Qt 能够以通用的方式自动为我们处理很多信号。你很快就会看到，当在 [第 4 章](part0040.xhtml#aid-164MG2
    "第 4 章。征服桌面 UI") 设计应用程序的 UI 时，这种做法是如何很好地工作的，*征服桌面 UI*。
- en: The real insertion begins after the `beginInsertRows()` instruction. We start
    by creating a copy of the `album` row with `unique_ptr<Album> newAlbum`. This
    object is then inserted in the database with `mDb.albumDao.addAlbum(*newAlbum)`.
    Do not forget that the `AlbumDao::addAlbum()` function also modifies the passed
    album by setting its `mId` to the last SQLITE3-inserted ID.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的插入操作在 `beginInsertRows()` 指令之后开始。我们首先使用 `unique_ptr<Album> newAlbum` 创建 `album`
    行的副本。然后，使用 `mDb.albumDao.addAlbum(*newAlbum)` 将此对象插入数据库中。不要忘记，`AlbumDao::addAlbum()`
    函数还会修改传入的专辑，将其 `mId` 设置为最后一个 SQLITE3 插入的 ID。
- en: Finally, `newAlbum` is added to `mAlbums` and its ownership is transferred as
    well with `std::move()`. The return gives the index object of this new album,
    which is simply the row wrapped in a `QModelIndex` object.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`newAlbum` 被添加到 `mAlbums` 中，并且其所有权也通过 `std::move()` 转移。返回值提供了这个新专辑的索引对象，它简单地将行封装在一个
    `QModelIndex` 对象中。
- en: 'Let''s continue the editing functions with `setData()`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编辑函数，使用 `setData()`：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function is called when the view wants to update the data. The signature
    is very similar to `data()`, with the additional parameter value.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图想要更新数据时，会调用此函数。其签名与 `data()` 非常相似，但增加了额外的参数值。
- en: The body also follows the same logic. Here, the `album` row is an `Album&`,
    without the `const` keyword. The only possible value to edit is the name, which
    is done on the object and then persisted to the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 主体部分也遵循相同的逻辑。在这里，`album` 行是一个 `Album&`，没有 `const` 关键字。唯一可以编辑的值是名称，这是在对象上完成的，然后持久化到数据库中。
- en: We have to emit ourselves the `dataChanged()` signal to notify whoever is interested
    that a row changed for the given indexes (the start index and end index). This
    powerful mechanism centralizes all the states of the data, enabling possible views
    (album list and current album detail for example) to be automatically refreshed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须发出`dataChanged()`信号来通知所有感兴趣的人，对于给定的索引（起始索引和结束索引），有一行发生了变化。这个强大的机制集中了所有数据的状态，使得可能的视图（例如相册列表和当前相册详情）能够自动刷新。
- en: The return of the function simply indicates if the data update was successful.
    In a production application, you should test the database processing success and
    return the relevant value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值简单地指示数据更新是否成功。在生产应用程序中，您应该测试数据库处理的成功并返回相关值。
- en: 'Finally, the last editing function we will cover is `removeRows()`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍最后一个编辑函数`removeRows()`：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function signature should start to look familiar by now. When a view wants
    to remove rows, it has to provide the starting row, the number of rows to delete,
    and the parent of the row.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名现在应该看起来很熟悉了。当一个视图想要删除行时，它必须提供起始行、要删除的行数以及行的父级。
- en: 'After that, just as we did for `addAlbum()`, we wrap the effective removal
    with two functions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，就像我们对`addAlbum()`所做的那样，我们用两个函数包装有效的删除操作：
- en: The `beginRemoveRows()` function, which expects the parent, the starting index,
    and the last index
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beginRemoveRows()`函数，它期望父级、起始索引和最后一个索引'
- en: The `endRemoveRows()` function, which simply triggers automatic signals in the
    model framework
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endRemoveRows()`函数，它只是简单地触发模型框架中的自动信号'
- en: The rest of the function is not very hard to follow. We loop on the rows left
    to delete and, for each one, we delete it from the database and remove it from
    `mAlbums`. We simply retrieve the album from our in-memory `mAlbums` vector and
    process the real database deletion with `mDb.albumDao.removeAlbum(album.id())`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分并不难理解。我们遍历要删除的行，并对每一行，我们从数据库中删除它，并从`mAlbums`中移除它。我们简单地从我们的内存`mAlbums`向量中检索相册，并使用`mDb.albumDao.removeAlbum(album.id())`处理实际的数据库删除操作。
- en: The `AlbumModel` class is now completely covered. You can now create a new C++
    class and name it `PictureModel`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumModel`类现在已经完全介绍完毕。您现在可以创建一个新的C++类，并将其命名为`PictureModel`。'
- en: We will not cover the `PictureModel` class in so much detail. The major parts
    are the same (you simply swap the data class `Album` for `Picture`). There is
    however one main difference: `PictureModel` always handles pictures for a given
    album. This design choice illustrates how two models can be linked with only some
    simple signals.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会详细讨论`PictureModel`类。主要部分是相同的（你只需将数据类`Album`替换为`Picture`）。然而，有一个主要区别：`PictureModel`始终处理给定相册的图片。这个设计选择说明了如何仅通过一些简单的信号将两个模型链接起来。
- en: 'Here is the updated version of `PictureModel.h`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`PictureModel.h`的更新版本：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The interesting parts are those concerning the album. As you can see, the constructor
    expects an `AlbumModel`. This class also stores the current `mAlbumId` to be able
    to request the pictures for a given album only. Let''s see what the constructor
    really does:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是关于相册的部分。如您所见，构造函数期望一个`AlbumModel`。这个类也存储当前的`mAlbumId`，以便只能请求给定相册的图片。让我们看看构造函数实际上做了什么：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, the `albumModel` class is used only to connect a signal to
    our slot `deletePicturesForAlbum()` which is self-explanatory. This makes sure
    that the database is always valid: a picture should be deleted if the owning album
    is deleted. This will be done automatically when `AlbumModel` emits the `rowsRemoved`
    signal.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`albumModel`类仅用于将信号连接到我们的槽`deletePicturesForAlbum()`，这一点不言自明。这确保了数据库始终有效：如果拥有相册被删除，则应该删除图片。当`AlbumModel`发出`rowsRemoved`信号时，这将自动完成。
- en: 'Now, `mPictures` is not initialized with all the pictures of the database.
    Because we chose to restrict `PictureModel` to work on the pictures for a given
    album, we do not know at the construction of `PictureModel` which album to choose.
    The loading can only be done when the album is selected, in `setAlbumId()`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`mPictures`不是初始化为数据库中的所有图片。因为我们选择将`PictureModel`限制为只处理给定相册的图片，所以在`PictureModel`的构造时我们不知道要选择哪个相册。加载只能在相册被选择时进行，在`setAlbumId()`中：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the album changes, we completely reload `PictureModel`. The reloading phase
    is wrapped with the `beginResetModel()` and `endResetModel()` functions. They
    notify any attached views that their state should be reset as well. Any previous
    data (for example, `QModelIndex`) reported from the model becomes invalid.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当相册发生变化时，我们会完全重新加载 `PictureModel`。重新加载阶段被 `beginResetModel()` 和 `endResetModel()`
    函数包裹。它们会通知任何附加的视图，它们的状态也应该被重置。模型之前报告的任何数据（例如，`QModelIndex`）都变得无效。
- en: 'The `loadPictures()` function is quite straightforward:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadPictures()` 函数相当直接：'
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By convention, we decided that, if a negative `album id` is provided, we clear
    the pictures. To do it, we reinitialize `mPictures` with the call `mPictures.reset(new
    vector<unique_ptr<Picture>>())`. This will call the destructor on the owned vector,
    which in turn will do the same for the `Picture` elements. We force `mPictures`
    to always have a valid vector object to avoid any possible null reference (in `PictureModel::rowCount()`
    for example).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们决定，如果提供了一个负的 `album id`，则清除图片。为此，我们使用调用 `mPictures.reset(new vector<unique_ptr<Picture>>())`
    来重新初始化 `mPictures`。这将调用拥有向量的析构函数，进而对 `Picture` 元素执行相同的操作。我们强制 `mPictures` 总是拥有一个有效的向量对象，以避免任何可能的空引用（例如，在
    `PictureModel::rowCount()` 中）。
- en: 'After that, we simply assign the database pictures for the given `albumId`
    to `mPictures`. Because we work with smart pointers at every level, we do not
    even see any specific semantics here. Still, `mPicture` is a `unique_ptr<vector<unique_ptr<Picture>>>`.
    When the `=` operator is called, the `unique_ptr` pointer overloads it and two
    things happen:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需将给定 `albumId` 的数据库图片分配给 `mPictures`。因为我们每个级别都使用智能指针，所以我们甚至看不到任何特定的语义。不过，`mPicture`
    是一个 `unique_ptr<vector<unique_ptr<Picture>>>`。当调用 `=` 操作符时，`unique_ptr` 会重载它，发生以下两个操作：
- en: The ownership of the right-hand side (the pictures retrieved from the database)
    is transferred to `mPictures`
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧（从数据库检索到的图片）的所有权转移到了 `mPictures`
- en: The old content of `mPictures` is automatically deleted
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mPictures` 的旧内容会自动删除'
- en: It is effectively the same as calling `mPictures.reset()` and then `mPictures
    = move(mDb.pictureDao.picturesForAlbum(albumId))`. With the `=` overload, everything
    is streamlined and much more pleasant to read.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上等同于调用 `mPictures.reset()` 然后执行 `mPictures = move(mDb.pictureDao.picturesForAlbum(albumId))`。使用
    `=` 重载，一切都会变得流畅得多，阅读起来也更加愉快。
- en: The `PictureModel` shows you how flexible the model paradigm can be. You can
    easily adapt it to your own use case without making any strong coupling. After
    all, the `albumModel` is only used to connect to a single signal; there are no
    retained references. The remainder of the class is available in the source code
    of the chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`PictureModel` 展示了模型范式可以有多灵活。你可以轻松地将其适应到自己的用例中，而无需进行任何强耦合。毕竟，`albumModel` 只用于连接到单个信号；没有保留的引用。类的其余部分可以在章节的源代码中找到。'
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The chapter was a journey to create a well-defined `gallery-core` library. We
    studied advanced techniques with `.pro` files to split your project into sub-modules,
    persisted data in a SQLITE3 database with the help of smart pointers, and finally
    studied how the Model/View architecture works in Qt.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一次创建一个定义良好的 `gallery-core` 库的旅程。我们使用 `.pro` 文件研究了高级技术，以将项目拆分为子模块，在智能指针的帮助下将数据持久化到
    SQLITE3 数据库中，并最终研究了 Qt 中的模型/视图架构是如何工作的。
- en: 'From now on, a project organization with Qt should hold no terrors for you.
    The next chapter will continue right where we stopped: the library is ready, now
    let''s make great QWidgets to have a stunning gallery application and look at
    the other side of the model: the View layer.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，Qt 的项目组织对你来说应该不再令人生畏。下一章将继续我们停止的地方：库已经准备好了，现在让我们制作出伟大的 QWidgets，以拥有一个令人惊叹的画廊应用程序，并查看模型的另一面：视图层。
