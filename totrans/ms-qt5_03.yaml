- en: Chapter 3.  Dividing Your Project and Ruling Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter delved into qmake to study what lies beneath the signal/slot
    system and covered a reasonable approach to implementing platform-specific code.
    This chapter wants to show you how a project can be properly divided to enjoy
    the maximum leverage from the Qt framework.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you will create a gallery application that handles albums and pictures.
    You will be able to create, read, update and delete any album and display the
    pictures in a grid of thumbnails or in full resolution. Everything will be persisted
    in a SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter lays the foundations of the gallery by creating a core library
    that will be used in the following two chapters: [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*, and [Chapter
    5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile UI"), *Dominating
    the Mobile UI*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Application/library project separation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database interaction with Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart pointers with C++14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model/View architecture in Qt with an implementation of the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a maintainable project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in designing a maintainable project is to properly split it in
    clearly defined modules. A common approach is to separate the engine from the
    user interface. This separation forces you to reduce coupling between the different
    parts of your code and make it more modular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly the approach we will take with the `gallery` application. The
    project will be divided into three sub-projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a maintainable project](img/image00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sub-projects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gallery-core**: This is a library containing the core of the application
    logic: the data classes (or business classes), persistent storage (in SQL), and
    the model that makes the storage available to the UI through a single entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gallery-desktop**: This is a Qt widgets application that will depend on the `gallery-core`
    library to retrieve data and display it to the user. This project will be covered
    in [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop UI"), *Conquering
    the Desktop UI*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gallery-mobile**: This is a QML application targeted at mobile platforms
    (Android and iOS). It will also rely on `gallery-core`. This project will be covered
    in [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile UI"), *Dominating
    the Mobile UI*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, each layer has a single responsibility. This principle is applied
    to both the project structure and the code organization. Throughout these three
    projects, we will endeavor to live up to the motto of the chapter: "Divide your
    project and rule your code".'
  prefs: []
  type: TYPE_NORMAL
- en: 'To separate your Qt project this way, we will create a different kind of project,
    a **Subdirs** project:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File** | **New ****File ****or ****Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Projects** types, select **Other Project** | **Subdirs Project** | **Choose**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `ch03-gallery-core` and then click on **Choose**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your latest Qt Desktop Kit, and then click on **Next** | **Finish & Add
    Subproject**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, Qt Creator created the parent project, `ch03-gallery-core`, which will
    host our three sub-projects (`gallery-core`, `gallery-desktop`, and `gallery-mobile`).
    The parent project has neither code nor a compilation unit in itself, it is simply
    a convenient way to group multiple `.pro` projects and express the dependencies
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the first `subdir` project, which Qt Creator proposed
    immediately when you clicked on **Finish & Add Subproject**. We will start with `gallery-core`:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Library** in the **Projects** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **C++ Library**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Shared Library** type, and name it `gallery-core`, and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the modules, **QtCore**, and **QtSql**, and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **Album** in the **Class name** field, and click on **Next**. Qt Creator
    will generate the basic skeleton of a library with this class as an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the project is properly added as a sub-project of `ch03-gallery-core.pro`
    and click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before delving into `gallery-core` code, let''s study what Qt Creator just
    made for us. Open the parent `.pro` file, `ch03-gallery-core.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Until now, we used the `TEMPLATE = app` syntax in our `.pro` files. The `subdirs`
    project template indicates to Qt that it should search for sub-projects to compile.
    When we added the `gallery-core` project to `ch03-gallery-core.pro`, Qt Creator
    added it to the `SUBDIRS` variable. As you can see, `SUBDIRS` is a list, so you
    can add as many sub-projects as you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiling `ch03-gallery-core.pro`, Qt will scan each `SUBDIRS` value to
    compile them. We can now switch to `gallery-core.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QT` has appended the `sql` module and removed the `gui` module. By default, **QtGui**
    is always included and has to be removed explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TEMPLATE` value is different, again. We use `lib` to tell qmake to generate
    a Makefile that will output a shared library named `gallery-core` (as specified
    by the `TARGET` variable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DEFINES += GALLERY_CORE_LIBRARY` syntax is a compilation flag that lets
    the compiler know when it should import or export library symbols. We will come
    back soon to this notion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HEADERS` contains our first class `Album.h`, but also another generated
    header: `gallery-core_global.h`. This file is syntactic sugar provided by Qt to
    ease the pain of a cross-platform library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unix { ... }` scope specifies the installation destination of the library.
    This platform scope is generated because we created the project on Linux. By default
    it will try to install the library in the system library path (`/usr/lib`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please remove the `unix` scope altogether, we don't need to make the library
    available system-wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better understanding of the cross-platform shared object issue, you
    can open `gallery-core_global.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We encounter again the `GALLERYCORE_LIBRARY` defined in `gallery-core.pro`
    file. Qt Creator generated a useful piece of code for us: the cross-platform way
    to handle symbol visibility in a shared library.'
  prefs: []
  type: TYPE_NORMAL
- en: When your application links to a shared library, symbol functions, variables,
    or classes must be marked in a special way to be visible by the application using
    the shared library. The default visibility of a symbol depends on the platform.
    Some platforms will hide symbols by default, other platforms will make them public.
    Of course, each platform and compiler has its own macros to express this public/private
    notion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obviate the whole `#ifdef windows #else` boilerplate code, Qt provides a `Q_DECL_EXPORT`
    (if we are compiling the library) and `Q_DECL_IMPORT` (if we are compiling your
    application using the shared library). Thus, throughout the symbols you want to
    mark as public, you just have to use the `GALLERYCORESHARED_EXPORT` macro.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is available in the `Album.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You include the proper `gallery-core_global.h` file to have access to the macro
    and you use it just after the `class` keyword. It does not pollute your code too
    much and is still cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another possibility is to make a **Statically Linked Library**. This path is
    interesting if you want fewer dependencies to handle (a single binary is always
    easier to deploy). There are several downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Increased compilation time: each time you modify the library, the application
    will have to be recompiled as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tighter coupling, multiple applications cannot link to your library. Each one
    of them must embed it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are building our gallery from the ground up. We will start with the implementation
    of our data classes to be able to properly write the database layer. The application
    aims to organize pictures into albums. Hence, the two obvious classes are `Album`
    and `Picture`. In our example, an album simply has a name. A `Picture` class must
    belong to an `Album` class and has a file path (the path on your filesystem where
    the original file is located).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Album` class has already been created on project creation. Open the `Album.h`
    file and update it to include the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Album` class contains only a `mId` variable (the database
    ID) and a `mName` variable. In a typical **OOP** (**Object Oriented Paradigm**)
    fashion, the `Album` class would have had a `QVector<Picture>mPictures` field.
    We did not do it on purpose. By decoupling these two objects, we will have more
    flexibility when we want to load an album without pulling the potential thousands
    of associated pictures. The other problem in having `mPictures` in the `Album`
    class is that the developer (you or anybody else) using this code will ask himself:
    when is `mPictures` loaded? Should I do a partial load of the `Album` and have
    an incomplete `Album` or should I always load `Album` with every picture in it?'
  prefs: []
  type: TYPE_NORMAL
- en: By completely removing the field, the question ceases to exist, and the code
    is simpler to grasp. The developer knows intuitively that he will have to explicitly
    load the pictures if he want them; otherwise, he can continue with this simple
    `Album` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The getters and setters are obvious enough; we will let you implement them
    without showing them to you. We will only take a look at the `Album` class'' constructor
    in `Album.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `mId` variable is initialized to `-1` to be sure that, by default, an invalid
    id is used, and the `mName` variable is assigned a `name` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to the `Picture` class. Create a new C++ class named `Picture`
    and open `Picture.h` to modify it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to add the `GALLERYCORESHARED_EXPORT` macro right before the `class`
    keyword to export the class from the library. As a data structure, `Picture` has
    a `mId` variable, belongs to a `mAlbumId` variable, and has a `mUrl` value. We
    use the `QUrl` type to make path manipulation easier to use depending on the platform
    (desktop or mobile).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at `Picture.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first constructor, the static function, `QUrl::fromLocalFile`, is called
    to provide a `QUrl` object to the other constructor, which takes a `QUrl` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to call other constructors is a nice addition in C++11.
  prefs: []
  type: TYPE_NORMAL
- en: Storing your data in a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the data classes are ready, we can proceed to implement the database
    layer. Qt provides a ready-to-use `sql` module. Various databases are supported
    in Qt using SQL database drivers. In `gallery-desktop`, we will use the `SQLITE3`
    driver, which is included in the `sql` module and perfectly fits the use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A very simple database schema**: No need for complex queries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Very few or no concurrent transactions**: No need for a complex transaction
    model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A single-purpose database**: No need to spawn a system service, the database
    is stored in a single file and does not need to be accessed by multiple applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database will be accessed from multiple locations; we need to have a single
    entry point for it. Create a new C++ class named `DatabaseManager` and modify `DatabaseManager.h`
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that we implement the singleton pattern in the
    `DatabaseManager` class, like we did in the *Transforming SysInfo in a singleton*
    section from [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2.  Discovering QMake
    Secrets"), *Discovering QMake Secrets*. The `DatabaseManager` class will open
    the connection in the `mDatabase` field and lend it to other possible classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `QSqlDatabase` is forward-declared and used as a pointer for the `mDatabase`
    field. We could have included the `QSqlDatabase` header, but we would have had
    a non-desired side-effect: every file, which includes `DatabaseManager`, must
    also include `QSqlDatabase`. Thus, if we ever have some transitive inclusion in
    our application (which links to the `gallery-core` library), the application is
    forced to enable the `sql` module. As a consequence, the storage layer leaks through
    the library. The application should not have any knowledge about the storage layer
    implementation. For all the application cares, it could be in SQL, XML, or anything
    else; the library is a black box that should honor the contract and persist the
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to `DatabaseManager.cpp` and open the database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The correct database driver is selected on the `mDatabase` field initialization
    with the `QSqlDatabase::addDatabase("QSQLITE")` function call. The following steps
    are just a matter of configuring the database name (which is incidentally the
    file path in SQLITE3) and opening the connection with the `mDatabase->open()`
    function. In the `DatabaseManager` destructor, the connection is closed and the `mDatabase`
    pointer is properly deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The database link is now opened; all we have to do is to execute our `Album`
    and `Picture` queries. Implementing the **CRUD** (**Create**/**Read**/**Update**/**Delete**)
    for both our data classes in `DatabaseManager` would quickly push `DatabaseManager.cpp`
    to be several hundreds of lines long. Add a few more tables and you can already
    see what a monster `DatabaseManager` would turn into.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, each of our data classes will have a dedicated database class,
    responsible for all the database CRUD operations. We will start with the `Album`
    class; create a new C++ class named `AlbumDao` (data access object) and update `AlbumDao.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `AlbumDao` class's constructor takes a `QSqlDatabase&` parameter. This parameter
    is the database connection that will be used for all the SQL queries done by the `AlbumDao`
    class. The `init()` function aims to create the `albums` table and should be called
    when `mDatabase` is opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the implementation of `AlbumDao.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the `mDatabase` field is initialized with the database parameter.
    In the `init()` function, we can see a real SQL request in action. If the table `albums`
    class does not exist, a `QSqlQuery` query is created that will use the `mDatabase`
    connection to be executed. If you omit `mDatabase`, the query will use a default
    anonymous connection. The `query.exec()` function is the simplest manner of executing
    a query: you simply pass the `QString` type of your query and it''s done. Here
    we create the `albums` table with the fields matching the data class `Album` (`id`
    and `name`).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QSqlQuery::exec()` function returns a `bool` value that indicates if the
    request has been successful. In your production code, always check this value.
    You can further investigate the error with `QSqlQuery::lastError()`. An example
    is available in the source code of the chapter in `DatabaseManager::debugQuery()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The skeleton of `AlbumDao` class is done. The next step is to link it to the `DatabaseManager`
    class. Update the `DatabaseManager` class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `albumDao` field is declared as a `public const AlbumDao` in the `DatabaseManager.h`
    file. This needs some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `public` visibility is to give access to `DatabaseManager` clients to the `albumDao`
    field. The API becomes intuitive enough; if you want to make a database operation
    on an `album`, just call `DatabaseManager::instance().albumDao`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const` keyword is to make sure that nobody can modify `albumDao`. Because
    it is `public`, we cannot guarantee the safety of the object (anybody could modify
    the object). As a side-effect, we force every public function of `AlbumDao` to
    be `const`. This makes sense; after all, the `AlbumDao` field could have been
    a namespace with a bunch of functions. It is more convenient for it to be a class
    because we can keep the reference to the database connection with the `mDatabase`
    field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `DatabaseManager` constructor, the `albumDao` class is initialized with
    the `mDatabase` dereferenced pointer. The `albumDao.init()` function is called
    after the database connection has opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to implement more interesting SQL queries. We can start
    with the creation of a new album in the `AlbumDao` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addAlbum()` function takes an `album` parameter to extract its information
    and execute the corresponding query. Here, we approach the prepared query notion:
    the `query.prepare()` function takes a `query` parameter which contains placeholders
    for parameters provided later. We will provide the `name` parameter with the syntax `:name`.
    Two syntaxes are supported: Oracle style with a colon-name (for example, `:name`)
    or ODBC style with a question mark (for example, `?name`).'
  prefs: []
  type: TYPE_NORMAL
- en: We then bind the bind `:name` syntax to the value of the `album.name()` function.
    Because `QSqlQuery::bind()` expects a `QVariant` as a parameter value, we have
    to add the `include` directive to this class.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, a `QVariant` is a generic data holder that accepts a wide range
    of primitive types (`char`, `int`, `double`, and so on) and complex types (`QString`, `QByteArray`, `QUrl`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: When the `query.exec()` function is executed, the bound values are properly
    replaced. The `prepare()` statement technique makes the code more robust to SQL
    injection (injecting a hidden request would fail) and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of the query modifies the state of the object query itself. The
    `QSqlQuery` query is not simply a SQL query executor, it also contains the state
    of the active query. We can retrieve information about the query with the `query.lastInsertId()`
    function, which returns a `QVariant` value containing the ID of the album row
    we just inserted. This `id` is given to the `album` provided in the `addAlbum()`
    parameter. Because we modify `album`, we cannot mark the parameter as `const`.
    Being strict about the `const` correctness of your code is a good hint for a fellow
    developer, who can deduce that your function might (or not) modify the passed
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining update and delete operations follow strictly the same pattern
    used for `addAlbum()`. We will just provide the expected function signatures in
    the next code snippet. Please refer to the source code of the chapter for the
    complete implementation. However, we need to implement the request to retrieve
    all the albums in the database. This one deserves a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `albums()` function must return a `QVector<Album*>` value. If we take a
    look at the body of the function, we see yet another property of `QSqlQuery`.
    To walk through multiple rows for a given request, `query` handles an internal
    cursor pointing to the current row. We can then proceed to create a `new Album*()`
    function and fill it with the row data with the `query.value()` statement, which
    takes a column name parameter and returns a `QVariant` value that is casted to
    the proper type. This new `album` parameter is appended to the `list` and, finally,
    this `list` is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PictureDao` class is very similar to the `AlbumDao` class, both in usage
    and implementation. The main difference is that a picture has a foreign key to
    an album. The `PictureDao` function must be conditioned by an `albumId` parameter.
    The following code snippet shows the `PictureDao` header and the `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, multiple functions take an `albumId` parameter to make the link
    between the picture and the owning `album` parameter. In the `init()` function,
    the foreign key is expressed in the `album_id INTEGER` syntax. SQLITE3 does not
    have a proper foreign key type. It is a very simple database and there is no strict
    constraint for this type of field; a simple integer is used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `PictureDao` function is added in the `DatabaseManager` class exactly
    as we did for `albumDao`. One could argue that, if there are a lot of `Dao` classes,
    adding a `const Dao` member in the `DatabaseManager` class and calling the `init()`
    function quickly becomes cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution could be to make an abstract `Dao` class, with a pure virtual `init()`
    function. The `DatabaseManager` class would have a `Dao` registry, which maps
    each `Dao` to a `QString` key with a `QHash<QString, const Dao> mDaos`. The `init()`
    function call would then be called in a `for` loop and a `Dao` object would be
    accessed using the `QString` key. This is outside the scope of this project, but
    is nevertheless an interesting approach.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your code with a smart pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code we just described is fully functional, but, it can be strengthened,
    specifically with the function, `AlbumDao::albums()`. In this function, we iterate
    through the database rows and create a new `Album` to fill a list. We can zoom
    in on this specific code section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that the `name` column has been renamed to `title`. If you forget
    to update `query.value("name")`, you might run into trouble. The Qt framework
    does not rely on exceptions, but this cannot be said for every API available in
    the wild. An exception here would cause a memory leak: the `Album* album` function
    has been allocated on the heap but not released. To handle this, you would have
    to surround the risky code with a `try` `catch` statement and deallocate the `album`
    parameter if an exception has been thrown. Maybe this error should bubble up;
    hence, your `try``catch` statement is only there to handle the potential memory
    leak. Can you picture the spaghetti code weaving in front of you?'
  prefs: []
  type: TYPE_NORMAL
- en: The real issue with pointers is the uncertainty of their ownership. Once it
    has been allocated, who is the owner of a pointer? Who is responsible for deallocating
    the object? When you pass a pointer as a parameter, when does the caller retain
    the ownership or release it to the callee?
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++11, a major milestone has been reached in memory management: the smart
    pointer feature has been stabilized and can greatly improve the safety of your
    code. The goal is to explicitly indicate the ownership of a pointer through simple
    template semantics. There are three types of smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: The `unique_ptr` pointer indicates that the owner is the only owner of the pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shared_ptr` pointer indicates that the pointer's ownership is shared among
    several clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `weak_ptr` pointer indicates that the pointer does not belong to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, we will focus on the  `unique_ptr` pointer to understand smart pointer
    mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `unique_ptr` pointer is simply a variable allocated on the stack that takes
    the ownership of the pointer you provide with it. Let''s allocate an `Album` with
    this semantic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole smart pointer API is available in the `memory` header. When we declared `album`
    as a `unique_ptr`, we did two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We allocated on the stack a `unique_ptr<Album>`. The `unique_ptr` pointer relies
    on templates to check at compile time the validity of the pointer type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We granted the ownership of `albumPointer` memory to `album`. From this point
    on, `album` is the owner of the pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This simple line has important ramifications. First and foremost, you do not
    have to worry anymore about the pointer life cycle. Because a `unique_ptr` pointer
    is allocated on the stack, it will be destroyed as soon as it goes out of scope.
    In this example, when we exit `foo()`, `album` will be removed from the stack.
    The `unique_ptr` implementation will take care of calling the `Album` destructor
    and deallocating the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you explicitly indicate the ownership of your pointer at compile time.
    Nobody can deallocate the `albumPointer` content if they do not voluntarily fiddle
    with your `unique_ptr` pointer. Your fellow developers will also know with a single
    glance who is the owner of your pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, even though `album` is a type of `unique_ptr<Album>`, you can still
    call `Album` functions (for example, `album->setName()`) using the `->` operator.
    This is possible thanks to the overload of this operator. The usage of the `unique_ptr`
    pointer becomes transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this use case is nice, but the purpose of a pointer is to be able to
    allocate a chunk of memory and share it. Let''s say the `foo()` function allocates
    the `album unique_ptr` pointer and then transfers the ownership to `bar()`. This
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we introduce the `std::move()` function: its goal is to transfer the
    ownership of a `unique_ptr` function. Once `bar(std::move(album))` has been called, `album`
    becomes invalid. You can test it with a simple `if` statement: `if (album) { ...
    }`.'
  prefs: []
  type: TYPE_NORMAL
- en: From now on, the `bar()` function becomes the owner of the pointer (through `barAlbum`)
    by allocating a new `unique_ptr` on the stack and it will deallocate the pointer
    on its exit. You do not have to worry about the cost of a `unique_ptr` pointer,
    as these objects are very lightweight and it is unlikely that they will affect
    the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the signature of `bar()` tells the developer that this function expects
    to take the ownership of the passed `Album`. Trying to pass around `unique_ptr`
    without the `move()` function will lead to a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to note is the different meanings of the `.` (dot) and the `->`
    (arrow) when working with a `unique_ptr` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: The `->` operator dereferences to the pointer members and lets your call function
    on your real object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.` operator gives you access to the `unique_ptr` object functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `unique_ptr` pointer provides various functions. Among the most important
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `get()` function returns the raw pointer. The `album.get()` returns an `Album*`
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `release()` function releases the ownership of the pointer and returns the
    raw pointer. The `album.release()` function returns an `Album*` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reset(pointer p = pointer())` function destroys the currently managed pointer
    and takes ownership of the given parameter. An example would be the `barAlbum.reset()`
    function, which destroys the currently owned `Album*`. With a parameter, `barAlbum.reset(new
    Album())` also destroys the owned object and takes the ownership of the provided
    parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, you can dereference the object with the `*` operation, meaning `*album`
    will return an `Album&` value. This dereferencing is convenient, but you will
    see that the more a smart pointer is used, the less you will need it. Most of
    the time, you will replace a raw pointer with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because we pass the `unique_ptr` by reference, `bar()` does not take ownership
    of the pointer and will not try do deallocate it upon its exit. With this, there
    is no need to use `move(album)` in `foo()`; the `bar()` function will just do
    operations on the `album` parameter but will not take its ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's consider `shared_ptr`. A `shared_ptr` pointer keeps a reference counter
    on a pointer. Each time a `shared_ptr` pointer references the same object, the
    counter is incremented; when this `shared_ptr` pointer goes out of scope, the
    counter is decremented. When the counter reaches zero, the object is deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `foo()`/`bar()` example with a `shared_ptr` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax is very similar to the `unique_ptr` pointer. The
    reference counter is incremented each time a new `shared_ptr` pointer is allocated
    and points to the same data, and is decremented on the function exit. You can
    check the current count by calling the `album.use_count()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last smart pointer we will cover is the `weak_ptr` pointer. As the name
    suggests, it does not take any ownership or increment the reference counter. When
    a function specifies a `weak_ptr`, it indicates to the callers that it is just
    a client and not an owner of the pointer. If we re implement `bar()` with a `weak_ptr`
    pointer, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the story stopped here, there would not be any interest in using a `weak_ptr`
    versus a raw pointer. The `weak_ptr` has a major advantage for the dangling pointer
    issue. If you are building a cache, you typically do not want to keep strong references
    to your object. On the other hand, you want to know if the objects are still valid.
    By using `weak_ptr`, you know when an object has been deallocated. Now, consider
    the raw pointer approach: your pointer might be invalid but you do not know the
    state of the memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another semantic introduced in C++14 that we have to cover: `make_unique`.
    This keyword aims to replace the `new` keyword and construct a `unique_ptr` object
    in an exception-safe manner. This is how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make_unique` keyword wraps the `new` keyword to make it exception-safe,
    specifically in this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will be executed in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate and construct the `Album` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate and construct the `Picture` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `foo()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `new Picture()` throws an exception, the memory allocated by `new Album()`
    will be leaked. This is fixed by using the `make_unique` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `make_unique` keyword returns a `unique_ptr` pointer; the C++ standard committee
    also provided an equivalent for `shared_ptr` in the form of `make_shared`, which
    follows the same principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these new C++ semantics try very hard to get rid of `new` and `delete`.
    Yet, it may be cumbersome to write all the `unique_ptr` and `make_unique` stuff.
    The `auto` keyword comes to the rescue in our `album` creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a radical departure from the common C++ syntax. The variable type is
    deduced, there is no explicit pointer, and the memory is automatically managed.
    After some time with smart pointers, you will see fewer and fewer raw pointers
    in your code (and even fewer `delete`, which is such a relief). The remaining
    raw pointers will simply indicate that a client is using the pointer but does
    not own it.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, C++11 and C++14 smart pointers are a real step up in C++ code writing.
    Before them, the bigger the code base, the more insecure we felt about memory
    management. Our brain is just bad at properly grasping complexity at such a level.
    Smart pointers simply make you feel safe about what you write. On the other hand,
    you retain full control of the memory. For performance-critical code, you can
    always handle the memory yourself. For everything else, smart pointers are an
    elegant way of explicitly indicating your object's ownership and freeing your
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now equipped to rewrite the little insecure snippet in the `AlbumDao::albums()`
    function. Update `AlbumDao::albums()` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! The signature of the `album()` function has turned into something very
    peculiar. Smart pointers are supposed to make your life easier, right? Let''s
    break it down to understand a major point of smart pointers with Qt: container
    behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: The initial goal of the rewrite was to secure the creation of `album`. We want
    the `list` to be the explicit owner of the `album`. This would have changed our `list`
    type (that is `albums()` return type) to `QVector<unique_ptr<Album>>`. However,
    when the `list` type is returned, its elements will be copied (remember, we previously
    defined the return type to `QVector<Album>`). A natural way out of this would
    be to return a `QVector<unique_ptr<Album>>*` type to retain the uniqueness of
    our `Album` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behold, here lies a major pain: the `QVector` class overloads the copy operator.
    Hence, when the `list` type is returned, the uniqueness of our `unique_ptr` elements
    cannot be guaranteed by the compiler and it will throw a compile error. This is
    why we have to resort to a `vector` object coming from the standard library and
    write the long type: `unique_ptr<vector<unique_ptr<Album>>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at the official response for support of the `unique_ptr` pointer
    in the Qt container. It is clear beyond any possible doubt: [http://lists.qt-project.org/pipermail/interest/2013-July/007776.html](http://lists.qt-project.org/pipermail/interest/2013-July/007776.html).
    The short answer is: no, it will never be done. Do not even mention it. Ever.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we translate this new `albums()` signature into plain English it will read:
    the `album()` function returns a vector of `Album`. This vector is the owner of
    the `Album` elements it contains and you will be the owner of the vector.'
  prefs: []
  type: TYPE_NORMAL
- en: To finish covering this implementation of `albums()`, you may notice that we
    did not use the `auto` and `make_unique` keywords for the `list` declaration.
    Our library will be used on a mobile in [Chapter 5](part0048.xhtml#aid-1DOR02
    "Chapter 5.  Dominating the Mobile UI"), *Dominating the Mobile UI*, and C++14
    is not yet supported on this platform. Therefore, we have to restrain our code
    to C++11.
  prefs: []
  type: TYPE_NORMAL
- en: We also encounter the use of the `move` function in the instruction `list->push_back(move(album))`.
    Until that line, the `album` is "owned" by the `while` scope, the move gives the
    ownership to the list. At the last instruction, `return list`, we should have
    written `move(list)`, but C++11 accepts the direct return and will automatically
    make the `move()` function for us.
  prefs: []
  type: TYPE_NORMAL
- en: What we covered in this section is that the `AlbumDao` class is completely matched
    in `PictureDao`. Please refer to the source code of the chapter to see the full `PictureDao`
    class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data is ready to be exposed to potential clients (the applications that
    will display and edit its content). However, a direct connection between the client
    and the database will make a very strong coupling. If we decide to switch to another
    storage type, the view would have to be rewritten, partially at least.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the model comes to our rescue. It is an abstract layer that communicates
    with the data (our database) and exposes this data to the client in a data-specific,
    implementation-agnostic form. This approach is a direct offspring of the **MVC**
    (**Model View Controller**) concept. Let''s recapitulate how MVC works:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model manages the data. It is responsible for requesting for the data and
    updating it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View displays the data to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller interacts with both the Model and the View. It is responsible
    for feeding the View with the correct data and sending commands to the Model based
    on the user interaction received from the View.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This paradigm enables swapping various parts without disturbing the others.
    Multiple views can display the same data, the data layer can be changed, and the
    upper parts will not be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt combines the View and the Controller to form the Model/View architecture.
    The separation of the storage and the presentation is retained while being simpler
    to implement than a full MVC approach. To allow editing and view customization,
    Qt introduces the concept of Delegate, which is connected to both the Model and
    the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the model](img/image00367.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Qt documentation about Model/View is truly plethoric. It is nevertheless
    easy to get lost in the details; it feels sometimes a bit overwhelming. We will
    try to clear things up by implementing the `AlbumModel` class and seeing how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt offers various Model sub-classes that all extend from `QAbstractItemModel`.
    Before starting the implementation, we have to carefully choose which base class
    will be extended. Keep in mind that our data are variations on lists: we will
    have a list of albums, and each album will have a list of pictures. Let''s see
    what Qt offers us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QAbstractItemModel`: This class is the most abstract, and therefore, the most
    complex, to implement. We will have to redefine a lot of functions to properly
    use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QStringListModel`: This class is a model that supplies strings to views. It
    is too simple. Our model is more complex (we have custom objects).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSqlTableModel` (or `QSqLQueryModel`): This class is a very interesting contender.
    It automatically handles multiple SQL queries. On the other hand, it works only
    for very simple table schemas. In the `pictures` table, for example, the `album_id`
    foreign key makes it very hard to fit this model. You might save some lines of
    code, but if feels like trying to shoehorn a round peg into a square hole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QAbstractListModel`: This class provides a model that offers one-dimensional
    lists. This fits nicely with our requirements, saves a lot of key strokes, and
    is still flexible enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will go with the `QabstractListModel` class and create a new C++ class named `AlbumModel`.
    Update the `AlbumModel.h` file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AlbumModel` class extends the `QAbstractListModel` class and has only
    two members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mDb`: This is the link to the database. In the Model/View schema, the model
    will communicate with the data layer through `mDb`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mAlbums`: This acts as a buffer that will avoid hitting the database too much.
    The type should remind you of what we wrote for `AlbumDao::albums()` with the
    smart pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only specific functions the `AlbumModel` class has are `addAlbum()` and `isIndexValid()`.
    The rest are overrides of `QAbstractListModel` functions. We will go through each
    of these functions to understand how a model works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how the `AlbumModel` class is constructed in the `AlbumModel.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `mDb` file is initialized with the `DatabaseManager` singleton address,
    and, after that, we see the now famous `AlbumDao::albums()` in action.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` type is returned and initializes `mAlbums`. This syntax make the
    ownership transfer automatic without any need for an explicit call to the `std::move()`
    function. If there are any stored albums in the database, `mAlbums` is immediately
    filled with those.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the model interacts with the view (to notify us about changes or to
    serve data), `mAlbums` will be used. Because it is in memory only, reading will
    be very fast. Of course, we have to be careful about maintaining `mAlbum` coherently
    with the database state, but everything will stay inside the `AlbumModel` inner
    mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said earlier, the model aims to be the central point to interact with
    the data. Each time the data changes, the model will emit a signal to notify the
    view; each time the view wants to display data, it will request the model for
    it. The `AlbumModel` class overrides everything needed for read and write access.
    The read functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rowCount()`: This function is used to get the list size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data()`: This function is used to get a specific piece of information about
    the data to display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roleNames()`: This function is used to indicate to the framework the name
    for each "role". We will explain in a few paragraphs what a role is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The editing functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setData()`: This function is used to update data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeRows()`: This function is used to remove data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with the read part, where the view asks the model for the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we will display a list of albums, the first thing the view should know
    is how many items are available. This is done in the `rowCount()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Being our buffer object, using `mAlbums->size()` is perfect. There is no need
    to query the database, as `mAlbums` is already filled with all the albums of the
    database. The `rowCount()` function has an unknown parameter: a `const QModelIndex&
    parent`. Here, it is not used, but we have to explain what lies beneath this type
    before continuing our journey in the `AlbumModel` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QModelIndex` class is a central notion of the Model/View framework in
    Qt. It is a lightweight object used to locate data within a model. We use a simple `QAbstractListModel`
    class, but Qt is able to handle three representation types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the model](img/image00368.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is no better explanation than an official Qt diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the models in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List Model**: In this model, the data is stored in a one-dimensional array
    (rows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table Model**: In this model, the data is stored in a two-dimensional array
    (rows and columns)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree Model**: In this model, the data is stored in a hierarchical relationship
    (parent/children)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle all these model types, Qt came up with the `QModelIndex` class, which
    is an abstract way of dealing with them. The `QModelIndex` class has the functions
    for each of the use cases: `row()`, `column()`, and `parent()`/`child()`. Each
    instance of a `QModelIndex` is meant to be short-lived: the model might be updated
    and thus the index will become invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: The model will produce indexes according to its data type and will provide these
    indexes to the view. The view will then use them to query back new data to the
    model without needing to know if an `index.row()` function corresponds to a database
    row or a `vector` index.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `index` parameter in action with the implementation of `data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The view will ask for data with two parameters: an `index` and a `role`. As
    we have already covered the `index`, we can focus on the `role` responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: When the data is displayed, it will probably be an aggregation of multiple data.
    For example, displaying the picture will consist of a thumbnail and the picture
    name. Each one of these data elements needs to be retrieved by the view. The `role`
    parameter fills this need, it associates each data element to a tag for the view
    to know what category of data is shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt provides various default roles (`DisplayRole`, `DecorationRole`, `EditRole`,
    and so on) and you can define your own if needed. This is what we did in the `AlbumModel.h`
    file with the `enum Roles`: we added an `IdRole` and a `NameRole`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `data()` function is now within our reach! We first test the
    validity of the `index` with a helper function, `isIndexValid()`. Take a look
    at the source code of the chapter to see what it does in detail. The view asked
    for data at a specific `index`: we retrieve the `album` row at the given `index`
    with `*mAlbums->at(index.row())`.'
  prefs: []
  type: TYPE_NORMAL
- en: This returns a `unique_ptr<Album>` value at the `index.row()` index and we dereference
    it to have an `Album&`. The `const` modifier is interesting here because we are
    in a read function, and it makes no sense to modify the `album` row. The `const`
    modifier adds this check at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` on the `role` parameter tells us what data category should be returned.
    The `data()` function returns a `QVariant` value, which is the Awiss Army Knife
    of types in Qt. We can safely return the `album.id()`, `album.name()`, or a default `QVariant()`
    if we do not handle the specified role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last read function to cover is `roleNames()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At this level of abstraction, we do not know what type of view will be used
    to display our data. If the views are written in QML, they will need some meta-information
    about the data structure. The `roleNames()` function provides this information
    so the role names can be accessed via QML. If you are writing for a desktop widget
    view only, you can safely ignore this function. The library we are currently building
    will be used for QML; this is why we override this function.
  prefs: []
  type: TYPE_NORMAL
- en: The reading part of the model is now over. The client view has everything it
    needs to properly query and display the data. We shall now investigate the editing
    part of `AlbumModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the creation of a new album. The view will build a new `Album`
    object and pass it to `Album::addAlbum()` to be properly persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Indexes are a way to navigate within the model data. This first thing we do
    is to determinate what will be the index of this new album by getting the `mAlbums`
    size with `rowCount()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we start to use specific model functions: `beginInsertRows()` and `endInsertRows()`.
    These functions wrap real data modifications. Their purpose is to automatically
    trigger signals for whoever might be interested:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beginInsertRows()`: This function informs that rows are about to change for
    the given indexes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endInsertRows()`: This function informs that rows have been changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter of the `beginInsertRows()` function is the `parent` for
    this new element. The root for a model is always an empty `QModelIndex()` constructor.
    Because we do not handle any hierarchical relationship in `AlbumModel`, it is
    safe to always add the new element to the root. The following parameters are the
    first and last modified indexes. We insert a single element per call, so we provide `rowIndex`
    twice. To illustrate the usage of this signal, a view might, for example, display
    a loading message telling the user "Saving 5 new albums".
  prefs: []
  type: TYPE_NORMAL
- en: For `endInsertRows()`, the interested view might hide the saving message and
    display "Save finished".
  prefs: []
  type: TYPE_NORMAL
- en: This may look strange at first, but it enables Qt to handle automatically a
    lot of signaling for us and in a generic way. You will see very soon how well
    this works when designing the UI of the application in [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*.
  prefs: []
  type: TYPE_NORMAL
- en: The real insertion begins after the `beginInsertRows()` instruction. We start
    by creating a copy of the `album` row with `unique_ptr<Album> newAlbum`. This
    object is then inserted in the database with `mDb.albumDao.addAlbum(*newAlbum)`.
    Do not forget that the `AlbumDao::addAlbum()` function also modifies the passed
    album by setting its `mId` to the last SQLITE3-inserted ID.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `newAlbum` is added to `mAlbums` and its ownership is transferred as
    well with `std::move()`. The return gives the index object of this new album,
    which is simply the row wrapped in a `QModelIndex` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue the editing functions with `setData()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function is called when the view wants to update the data. The signature
    is very similar to `data()`, with the additional parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: The body also follows the same logic. Here, the `album` row is an `Album&`,
    without the `const` keyword. The only possible value to edit is the name, which
    is done on the object and then persisted to the database.
  prefs: []
  type: TYPE_NORMAL
- en: We have to emit ourselves the `dataChanged()` signal to notify whoever is interested
    that a row changed for the given indexes (the start index and end index). This
    powerful mechanism centralizes all the states of the data, enabling possible views
    (album list and current album detail for example) to be automatically refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: The return of the function simply indicates if the data update was successful.
    In a production application, you should test the database processing success and
    return the relevant value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last editing function we will cover is `removeRows()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The function signature should start to look familiar by now. When a view wants
    to remove rows, it has to provide the starting row, the number of rows to delete,
    and the parent of the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, just as we did for `addAlbum()`, we wrap the effective removal
    with two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `beginRemoveRows()` function, which expects the parent, the starting index,
    and the last index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `endRemoveRows()` function, which simply triggers automatic signals in the
    model framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the function is not very hard to follow. We loop on the rows left
    to delete and, for each one, we delete it from the database and remove it from
    `mAlbums`. We simply retrieve the album from our in-memory `mAlbums` vector and
    process the real database deletion with `mDb.albumDao.removeAlbum(album.id())`.
  prefs: []
  type: TYPE_NORMAL
- en: The `AlbumModel` class is now completely covered. You can now create a new C++
    class and name it `PictureModel`.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover the `PictureModel` class in so much detail. The major parts
    are the same (you simply swap the data class `Album` for `Picture`). There is
    however one main difference: `PictureModel` always handles pictures for a given
    album. This design choice illustrates how two models can be linked with only some
    simple signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated version of `PictureModel.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting parts are those concerning the album. As you can see, the constructor
    expects an `AlbumModel`. This class also stores the current `mAlbumId` to be able
    to request the pictures for a given album only. Let''s see what the constructor
    really does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `albumModel` class is used only to connect a signal to
    our slot `deletePicturesForAlbum()` which is self-explanatory. This makes sure
    that the database is always valid: a picture should be deleted if the owning album
    is deleted. This will be done automatically when `AlbumModel` emits the `rowsRemoved`
    signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `mPictures` is not initialized with all the pictures of the database.
    Because we chose to restrict `PictureModel` to work on the pictures for a given
    album, we do not know at the construction of `PictureModel` which album to choose.
    The loading can only be done when the album is selected, in `setAlbumId()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the album changes, we completely reload `PictureModel`. The reloading phase
    is wrapped with the `beginResetModel()` and `endResetModel()` functions. They
    notify any attached views that their state should be reset as well. Any previous
    data (for example, `QModelIndex`) reported from the model becomes invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadPictures()` function is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By convention, we decided that, if a negative `album id` is provided, we clear
    the pictures. To do it, we reinitialize `mPictures` with the call `mPictures.reset(new
    vector<unique_ptr<Picture>>())`. This will call the destructor on the owned vector,
    which in turn will do the same for the `Picture` elements. We force `mPictures`
    to always have a valid vector object to avoid any possible null reference (in `PictureModel::rowCount()`
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we simply assign the database pictures for the given `albumId`
    to `mPictures`. Because we work with smart pointers at every level, we do not
    even see any specific semantics here. Still, `mPicture` is a `unique_ptr<vector<unique_ptr<Picture>>>`.
    When the `=` operator is called, the `unique_ptr` pointer overloads it and two
    things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The ownership of the right-hand side (the pictures retrieved from the database)
    is transferred to `mPictures`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The old content of `mPictures` is automatically deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is effectively the same as calling `mPictures.reset()` and then `mPictures
    = move(mDb.pictureDao.picturesForAlbum(albumId))`. With the `=` overload, everything
    is streamlined and much more pleasant to read.
  prefs: []
  type: TYPE_NORMAL
- en: The `PictureModel` shows you how flexible the model paradigm can be. You can
    easily adapt it to your own use case without making any strong coupling. After
    all, the `albumModel` is only used to connect to a single signal; there are no
    retained references. The remainder of the class is available in the source code
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter was a journey to create a well-defined `gallery-core` library. We
    studied advanced techniques with `.pro` files to split your project into sub-modules,
    persisted data in a SQLITE3 database with the help of smart pointers, and finally
    studied how the Model/View architecture works in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, a project organization with Qt should hold no terrors for you.
    The next chapter will continue right where we stopped: the library is ready, now
    let''s make great QWidgets to have a stunning gallery application and look at
    the other side of the model: the View layer.'
  prefs: []
  type: TYPE_NORMAL
