["```cpp\ncmake . && cmake build .\n```", "```cpp\nauto threadFunc = [](std::promise<int> prom) {\n    try {\n        int result = func();\n        prom.set_value(result);\n    } catch (...) {\n        prom.set_exception(std::current_exception());\n    }\n};\nstd::promise<int> prom;\nstd::jthread t(threadFunc, std::move(prom));\n```", "```cpp\nusing namespace std::literals;\nstd::promise<std::string> prom;\nauto t = std::jthread([prm = std::move(prom)] mutable {\n    std::this_thread::sleep_for(100ms);\n    prm.set_value(\"Value successfully set\");\n});\n```", "```cpp\nstd::promise<int> prom;\nstd::future<int> fut = prom.get_future();\n```", "```cpp\ntry {\n    int result = fut.get();\n    std::cout << \"Result from thread: \" << result << '\\n';\n} catch (const std::exception& e) {\n    std::cerr << \"Exception: \" << e.what() << '\\n';\n}\n```", "```cpp\n#include <algorithm>\n#include <cctype>\n#include <chrono>\n#include <future>\n#include <iostream>\n#include <iterator>\n#include <sstream>\n#include <thread>\n#include <vector>\n#include <set>\nusing namespace std::chrono_literals;\n```", "```cpp\nstd::promise<void> numbers_promise, letters_promise;\nauto numbers_ready = numbers_promise.get_future();\nauto letter_ready = letters_promise.get_future();\n```", "```cpp\nstd::istringstream iss_numbers{\"10 5 2 6 4 1 3 9 7 8\"};\nstd::istringstream iss_letters{\"A b 53 C,d 83D 4B ca\"};\nstd::vector<int> numbers;\nstd::set<char> letters;\nstd::jthread input_data_thread([&] {\n    // Step 1: Emulating I/O operations.\n    std::copy(std::istream_iterator<int>{iss_numbers},\n              std::istream_iterator<int>{},\n              std::back_inserter(numbers));\n    // Notify completion of Step 1.\n    numbers_promise.set_value();\n    // Step 2: Emulating further I/O operations.\n    std::copy_if(std::istreambuf_iterator<char>\n                               {iss_letters},\n                   std::istreambuf_iterator<char>{},\n                   std::inserter(letters,\n                               letters.end()),\n                               ::isalpha);\n    // Notify completion of Step 2.\n    letters_promise.set_value();\n});\n// Wait for numbers vector to be filled.\nnumbers_ready.wait();\n```", "```cpp\nstd::sort(numbers.begin(), numbers.end());\nif (letter_ready.wait_for(1s) == std::future_status::timeout) {\n    for (int num : numbers) std::cout << num << ' ';\n    numbers.clear();\n}\n// Wait for letters vector to be filled.\nletter_ready.wait();\n```", "```cpp\nfor (int num : numbers) std::cout << num << ' ';\nstd::cout << std::endl;\nfor (char let : letters) std::cout << let << ' ';\nstd::cout << std::endl;\n```", "```cpp\nstd::shared_future<int> shared_fut = fut.share();\n```", "```cpp\n#define sync_cout std::osyncstream(std::cout)\nint main() {\n    std::promise<int> prom;\n    std::future<int> fut = prom.get_future();\n    std::shared_future<int> shared_fut = fut.share();\n    std::vector<std::jthread> threads;\n    for (int i = 1; i <= 5; ++i) {\n        threads.emplace_back([shared_fut, i]() {\n            sync_cout << \"Thread \" << i << \": Result = \"\n                      << shared_fut.get() << std::endl;\n        });\n    }\n    prom.set_value(5);\n    return 0;\n}\n```", "```cpp\nThread 5: Result = 5\nThread 3: Result = 5\nThread 4: Result = 5\nThread 2: Result = 5\nThread 1: Result = 5\n```", "```cpp\n// Using a thread.\nstd::packaged_task<int(int, int)> task1(\n                      std::pow<int, int>);\nstd::jthread t(std::move(task1), 2, 10);\n// Using a lambda function.\nstd::packaged_task<int(int, int)> task2([](int a, int b)\n{\n    return std::pow(a, b);\n});\ntask2(2, 10);\n// Binding to a function.\nstd::packaged_task<int()> task3(std::bind(std::pow<int, int>, 2, 10));\ntask3();\n```", "```cpp\nstd::future<int> result = task1.get_future();\n```", "```cpp\ntask1(2, 10);\n```", "```cpp\nvoid task_func(std::future<void>& output) {\n    std::packaged_task<void(bool&)> task{[](bool& done){\n        done = true;\n    }};\n    auto result = task.get_future();\n    bool done = false;\n    task.make_ready_at_thread_exit(done);\n    std::cout << \"task_func: done = \"\n              << std::boolalpha << done << std::endl;\n    auto status = result.wait_for(0s);\n    if (status == std::future_status::timeout)\n        std::cout << \"task_func: result not ready\\n\";\n    output = std::move(result);\n}\n```", "```cpp\nstd::future<void> result;\nstd::thread t{task_func, std::ref(result)};\nt.join();\nauto status = result.wait_for(0s);\nif (status == std::future_status::ready)\n    std::cout << «main: result ready\\n»;\n```", "```cpp\ntask_func: done = true\ntask_func: result not ready\nmain: result ready\n```", "```cpp\nstd::packaged_task<int(int, int)> task([](int a, int b){\n    return std::pow(a, b);\n});\nfor (int i=1; i<=10; ++i) {\n    std::future<int> result = task.get_future();\n    task(2, i);\n    std::cout << \"2^\" << i << \" = \"\n              << result.get() << std::endl;\n    task.reset();\n}\n```", "```cpp\n2^1 = 2\n2^2 = 4\n2^3 = 8\n2^4 = 16\n2^5 = 32\n2^6 = 64\n2^7 = 128\n2^8 = 256\n2^9 = 512\n2^10 = 1024\n```", "```cpp\nconst int CHECK_PERIOD_MS = 100;\nbool long_running_task(int ms,\n            const std::atomic_bool& cancellation_token) {\n    while (ms > 0 && !cancellation_token) {\n        ms -= CHECK_PERIOD_MS;\n        std::this_thrsead::sleep_for(100ms);\n    }\n    return cancellation_token;\n}\n```", "```cpp\nstd::atomic_bool cancellation_token{false};\nstd::cout << \"Starting long running tasks...\\n\";\nstd::packaged_task<bool(int, const std::atomic_bool&)>\n                task1(long_running_task);\nstd::future<bool> result1 = task1.get_future();\nstd::jthread t1(std::move(task1), 500,\n                std::ref(cancellation_token));\nstd::packaged_task<bool(int, const std::atomic_bool&)>\n                task2(long_running_task);\nstd::future<bool> result2 = task2.get_future();\nstd::jthread t2(std::move(task2), 1000,\n                std::ref(cancellation_token));\nstd::cout << \"Cancelling tasks after 600 ms...\\n\";\nthis_thread::sleep_for(600ms);\ncancellation_token = true;\nstd::cout << \"Task1, waiting for 500 ms. Cancelled = \"\n          << std::boolalpha << result1.get() << \"\\n\";\nstd::cout << \"Task2, waiting for 1 second. Cancelled = \"\n          << std::boolalpha << result2.get() << \"\\n\";\n```", "```cpp\nStarting long running tasks...\nCancelling tasks after 600 ms...\nTask1, waiting for 500 ms. Cancelled = false\nTask2, waiting for 1 second. Cancelled = true\n```", "```cpp\nvoid combineFunc(std::promise<std::tuple<int,\n                 std::string>> combineProm) {\n    try {\n        // Thread to simulate computing a value.\n        std::cout << \"Starting computeThread...\\n\";\n        auto computeVal = [](std::promise<int> prom)\n                            mutable {\n            std::this_thread::sleep_for(1s);\n            prom.set_value(42);\n        };\n        std::promise<int> computeProm;\n        auto computeFut = computeProm.get_future();\n        std::jthread computeThread(computeVal,\n                              std::move(computeProm));\n        // Thread to simulate downloading a file.\n        std::cout << \"Starting dataThread...\\n\";\n        auto fetchData = [](\n                 std::promise<std::string> prom) mutable {\n            std::this_thread::sleep_for(2s);\n            prom.set_value(\"data.txt\");\n        };\n        std::promise<std::string> fetchProm;\n        auto fetchFut = fetchProm.get_future();\n        std::jthread dataThread(fetchData,\n                                std::move(fetchProm));\n        combineProm.set_value({\n                    computeFut.get(),\n                    fetchFut.get()\n        });\n    } catch (...) {\n        combineProm.set_exception(\n                    std::current_exception());\n    }\n}\n```", "```cpp\ncombineProm.set_value({computeFut.get(), fetchFut.get()});\n```", "```cpp\nstd::promise<std::tuple<int, std::string>> combineProm;\nauto combineFuture = combineProm.get_future();\nstd::jthread combineThread(combineFunc,\n                           std::move(combineProm));\nauto [data, file] = combineFuture.get();\nstd::cout << \"Value [ \" << data\n          << \" ]  File [ « << file << « ]\\n»;\n```", "```cpp\nCreating combined promise...\nStarting computeThread...\nStarting dataThread...\nValue [ 42 ]  File [ data.txt ]\n```", "```cpp\n#define sync_cout std::osyncstream(std::cout)\ntemplate <typename Func>\nclass Task {\n   public:\n    Task(int id, Func& func)\n        : id_(id), func_(func), has_dependency_(false) {\n        sync_cout << \"Task \" << id\n                 << \" constructed without dependencies.\\n\";\n        fut_ = prom_.get_future().share();\n    }\n    template <typename... Futures>\n    Task(int id, Func& func, Futures&&... futures)\n        : id_(id), func_(func), has_dependency_(true) {\n        sync_cout << \"Task \" << id\n                  << « constructed with dependencies.\\n\";\n        fut_ = prom_.get_future().share();\n        add_dependencies(\n                  std::forward<Futures>(futures)...);\n    }\n    std::shared_future<void> get_dependency() {\n        return fut_;\n    }\n    void operator()() {\n        sync_cout << \"Running task \" << id_ << '\\n';\n        wait_completion();\n        func_();\n        sync_cout << \"Signaling completion of task \"\n                  << id_ << ‹\\n';\n        prom_.set_value();\n    }\n   private:\n    template <typename... Futures>\n    void add_dependencies(Futures&&... futures) {\n        (deps_.push_back(futures), ...);\n    }\n    void wait_completion() {\n        sync_cout << \"Waiting completion for task \"\n                  << id_ << ‹\\n';\n        if (!deps_.empty()) {\n            for (auto& fut : deps_) {\n                if (fut.valid()) {\n                    sync_cout << \"Fut valid so getting \"\n                              << \"value in task \"\n                              << id_ << ‹\\n';\n                    fut.get();\n                }\n            }\n        }\n    }\n   private:\n    int id_;\n    Func& func_;\n    std::promise<void> prom_;\n    std::shared_future<void> fut_;\n    std::vector<std::shared_future<void>> deps_;\n    bool has_dependency_;\n};\n```", "```cpp\nauto sleep1s = []() { std::this_thread::sleep_for(1s); };\nauto sleep2s = []() { std::this_thread::sleep_for(2s); };\nTask task1(1, sleep1s);\nTask task2(2, sleep2s, task1.get_dependency());\nTask task3(3, sleep1s, task2.get_dependency());\nTask task4(4, sleep2s, task2.get_dependency());\nTask task5(5, sleep2s, task3.get_dependency(),\n                       task4.get_dependency());\n```", "```cpp\nsync_cout << \"Starting the pipeline...\" << std::endl;\ntask1();\ntask2();\ntask3();\ntask4();\ntask5();\n```", "```cpp\nsync_cout << \"Waiting for the pipeline to finish...\\n\";\nauto finish_pipeline_fut = task5.get_dependency();\nfinish_pipeline_fut.get();\nsync_cout << \"All done!\" << std::endl;\n```", "```cpp\nTask 1 constructed without dependencies.\nGetting future from task 1\nTask 2 constructed with dependencies.\nGetting future from task 2\nTask 3 constructed with dependencies.\nGetting future from task 2\nTask 4 constructed with dependencies.\nGetting future from task 4\nGetting future from task 3\nTask 5 constructed with dependencies.\nStarting the pipeline...\nRunning task 1\nWaiting completion for task 1\nSignaling completion of task 1\nRunning task 2\nWaiting completion for task 2\nFut valid so getting value in task 2\nSignaling completion of task 2\nRunning task 3\nWaiting completion for task 3\nFut valid so getting value in task 3\nSignaling completion of task 3\nRunning task 4\nWaiting completion for task 4\nFut valid so getting value in task 4\nSignaling completion of task 4\nRunning task 5\nWaiting completion for task 5\nFut valid so getting value in task 5\nFut valid so getting value in task 5\nSignaling completion of task 5\nWaiting for the pipeline to finish...\nGetting future from task 5\nAll done!\n```", "```cpp\ntemplate <typename T>\nclass ThreadSafeQueue {\n   public:\n    void push(T value) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        queue_.push(std::move(value));\n        cond_var_.notify_one();\n    }\n    T pop() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        cond_var_.wait(lock, [&]{\n            return !queue_.empty();\n        });\n        T value = std::move(queue_.front());\n        queue_.pop();\n        return value;\n    }\n   private:\n    std::queue<T> queue_;\n    std::mutex mutex_;\n    std::condition_variable cond_var_;\n};\n```", "```cpp\nusing TaskQueue = ThreadSafeQueue<std::future<int>>;\n```", "```cpp\nvoid producer(TaskQueue& queue, int val) {\n    std::promise<int> prom;\n    auto fut = prom.get_future();\n    queue.push(std::move(fut));\n    std::this_thread::sleep_for(\n            std::chrono::milliseconds(rand() % MAX_WAIT));\n    prom.set_value(val);\n}\n```", "```cpp\nvoid consumer(TaskQueue& queue) {\n    std::this_thread::sleep_for(\n            std::chrono::milliseconds(rand() % MAX_WAIT));\n    std::future<int> fut = queue.pop();\n    try {\n        int result = fut.get();\n        std::cout << \"Result: \" << result << \"\\n\";\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << '\\n';\n    }\n}\n```", "```cpp\nconst unsigned VALUE_RANGE = 1000;\nconst unsigned RESULTS_TO_PRODUCE = 10; // Numbers of items to produce.\nconst unsigned MAX_WAIT = 500; // Maximum waiting time (ms) when producing items.\n```", "```cpp\nTaskQueue queue;\nauto producerFunc = [](TaskQueue& queue) {\n    auto n = RESULTS_TO_PRODUCE;\n    while (n-- > 0) {\n        int val = rand() % VALUE_RANGE;\n        std::cout << \"Producer: Sending value \" << val\n                  << std::endl;\n        producer(queue, val);\n    }\n};\nauto consumerFunc = [](TaskQueue& queue) {\n    auto n = RESULTS_TO_PRODUCE;\n    while (n-- > 0) {\n        std::cout << \"Consumer: Receiving value\"\n                  << std::endl;\n        consumer(queue);\n    }\n};\nstd::jthread producerThread(producerFunc, std::ref(queue));\nstd::jthread consumerThread(consumerFunc, std::ref(queue));\n```", "```cpp\nProducer: Sending value 383\nConsumer: Receiving value\nProducer: Sending value 915\nResult: 383\nConsumer: Receiving value\nProducer: Sending value 386\nResult: 915\nConsumer: Receiving value\nProducer: Sending value 421\nResult: 386\nConsumer: Receiving value\nProducer: Sending value 690\nResult: 421\nConsumer: Receiving value\nProducer: Sending value 926\nProducer: Sending value 426\nResult: 690\nConsumer: Receiving value\nProducer: Sending value 211\nResult: 926\nConsumer: Receiving value\nResult: 426\nConsumer: Receiving value\nProducer: Sending value 782\nProducer: Sending value 862\nResult: 211\nConsumer: Receiving value\nResult: 782\nConsumer: Receiving value\nResult: 862\n```"]