- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ Is Beautiful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*According to the mirror on* *the wall*'
  prefs: []
  type: TYPE_NORMAL
- en: Dear reader. In this chapter, we won’t be focusing on teaching you specific
    concepts, techniques, or practical skills. Instead, our goal is to guide you through
    a different kind of experience, one that allows you to step back from the details
    and immerse yourself in the aesthetic aspects of coding.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is designed to inspire you to see code in a new light, to recognize
    the patterns, symmetry, and even the poetry that can emerge when we write code
    with thoughtfulness and care.
  prefs: []
  type: TYPE_NORMAL
- en: Beauty is a unique and personal experience because it arises from the intricate
    interplay of individual perception, emotional resonance, cultural influences,
    and personal identity. Each person interprets beauty through their own sensory
    and cognitive filters, shaped by their life experiences, memories, and cultural
    background. Emotional connections, mood, and personal taste further influence
    what one finds beautiful, making it a deeply subjective experience that reflects
    one’s unique perspective on the world.
  prefs: []
  type: TYPE_NORMAL
- en: Some may find beauty in the fiery hues of a sunset over a Mediterranean island,
    while others might appreciate the crisp, cold allure of Scandinavian fjords. It
    is all personal.
  prefs: []
  type: TYPE_NORMAL
- en: So, while there may not be concrete lessons or objectives in this chapter, it
    offers a unique opportunity to connect with the craft of coding on a more emotional
    and intellectual level. Through this journey, we hope you’ll come to see code
    not just as a means to an end but as something inherently beautiful in its own
    right.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will experience that there is:'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing new to learn here...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... except the appreciation of beauty...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... while crafting code with techniques in mind that may disqualify you from
    ever sitting in front of a keyboard while writing professional code in an enterprise
    environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In search of beauty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each programming language is a unique work of art, beautifully distinct in its
    design, philosophy, and the possibilities it offers; just as diverse are the programmers
    who use them, each bringing their own preferences, creativity, and personality
    to the craft.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers are drawn to the elegant simplicity and structure of Python,
    relishing the clarity and expressiveness that its neatly organized whitespace
    brings to their code. Others, however, find their joy in languages such as Forth,
    where they can freely push and pop the stack with precision having full control
    and conciseness of such low-level manipulation, while seemingly enjoying the challenge
    of constructing powerful systems with minimalistic syntax. Now really, is there
    anyone using Forth anymore?
  prefs: []
  type: TYPE_NORMAL
- en: And then there are the bold adventurers who embrace the enigmatic world of Lisp,
    using its infamous long list of insipid and stubborn parenthesis. To these programmers,
    the apparent monotony of the syntax is a gateway to a rich and expressive metaprogramming
    landscape, where they can manipulate code as data in ways that feel almost alchemical,
    not to mention that they have direct access to Emacs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, there are those of us, the tribe of C++ programmers, who
    think the magical beauty of a program can fully be expressed by the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What more C++ beauty do we need on this planet? A line of code that looks like
    a series of winking smileys, and in the end, it returns the lucky number seven
    to the caller. There is not a huge amount of technicality lying in the preceding
    code, just a plain lambda returning a number, and to confuse you, dear reader,
    we have used the trailing returning type for the **main** , because why not?
  prefs: []
  type: TYPE_NORMAL
- en: Also, to add an even higher level of obscurity to our snippet, we have used,
    just for the sheer beauty of them, the infamous C++ digraphs. Unfortunately for
    them, the notorious trigraphs were deprecated in C++17 so we could not use them
    to spice up our code snippet. Actually, we could have used them, but we just wouldn’t
    dare.
  prefs: []
  type: TYPE_NORMAL
- en: All that mayhem and confusion done in one line only. The real question that
    comes is can we make this even more cumbersome beautiful for you, dear reader,
    to read? And certainly, the answer to this certain question is a certain yes.
    And can we build it? Yes, we can! Almost... But firstly, we just have to get rid
    of the numbers, because hey...
  prefs: []
  type: TYPE_NORMAL
- en: Who likes numbers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '... or more specifically, who needs numbers? Numbers can be highly confusing
    to people due to their abstract nature, and the fact that we don’t really need
    them in our everyday mundane life, which does not require higher-level thinking
    and the ability to grasp symbolic representations, makes them almost meaningless.'
  prefs: []
  type: TYPE_NORMAL
- en: Maybe this is why some tribes in the Amazon jungle didn’t even invent all of
    them (yes, I’m pointing at you, Munduruku tribe [1](B22235_09.xhtml#footnote-025)
    ). You have notions for none, one, two, up to five ... and then many. If it is
    enough for you, I can live with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B22235_09.xhtml#footnote-025-backlink) https://www.amazon.com/Alexs-Adventures-Numberland-Alex-Bellos/dp/1408809591'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the ancient wisdom of the Amerindian people to our programming
    quest: to come up with the most beautiful C++ code snippet the world can see today.
    So, let’s get rid of those pesky numbers, keeping just 0 and 1 (for the sake of
    the almighty bits so that they don’t feel excluded), and let’s go tribal with
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Oh, the sheer beauty of it. It brings tears of joy to our eyes, doesn’t it?
    Arguably, some picky programmers might have made some vitriolic comments about
    readability, maintainability, standard compliance, and so on... especially if
    they are using Microsoft’s (tiny, squishy) C++ compiler, which flatly refuses
    to compile the preceding code. But we rejoice with trembling that we made one
    of the compilers break, while all the other major players happily digest it and
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: But the code unfortunately contains a lot of duplicates, which we don’t really
    like. Nor do we need duplicates, so we should also get rid of at least one of
    them, shouldn’t we? Or all of them, why not?
  prefs: []
  type: TYPE_NORMAL
- en: Because that is the real beauty of the C++ language. The capability to always
    redefine yourself, to provide a better version of the code at all costs, not considering
    the sacrifice made. Death to readability. Death to maintainability! Long live
    the free code of chaos, mayhem, and confusion!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, brave warriors, our quest has been laid, prepare arms (I mean keyboards),
    and let’s save those bytes, just like the following code snippet shows us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just look again at the sheer beauty of it. Again, the power of C++ shines through
    the dark clouds, like a thousand supernovae, and makes possible everything our
    heart desires, such as replacing a key element of the language, for example, the
    **return** keyword with a **$** sign. Not that it is part of the standard character
    set the language specified as the valid character set, but we will have a discussion
    about this, and some bears, a little bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'But look at the bright side of the glass. At least we did not write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have to admit, we contemplated writing it and adding it to the book, but
    after a glimpse at the future, we just thought that everything has its limits.
    Even the resilience of the most seasoned developers when it comes to nonsense
    (but regardless, fun) code.
  prefs: []
  type: TYPE_NORMAL
- en: This is highly possibly the most evil piece of code we will present in this
    book because the level of evilness is comparable to the level of pain felt when
    you try to write a properly parenthesized Lisp program. Because what happens if
    you remove a parenthesis because there are too many, or, God forbid, add another
    one because you think it’d be a great idea? Believe me, dear reader, just don’t
    dare.
  prefs: []
  type: TYPE_NORMAL
- en: So, please pretend that the preceding code is not in the book, and even if it
    is, you haven’t seen it. And even if you have seen it, you wouldn’t dare change
    the number of parenthesis in it.
  prefs: []
  type: TYPE_NORMAL
- en: Enough of the piece of evilness; now it is time to return to our previous code,
    which is in the competition for the most beautiful piece of C++ code this book
    can present.
  prefs: []
  type: TYPE_NORMAL
- en: 'If only we could make it just a bit shorter, more concise, and more expressive,
    such as removing those ugly **define** and replacing them with something that
    expresses more beauty, more ... like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Oh, it really hurts my eyes. Sorry about it, and apologies beforehand, but we
    cannot make this any more beautiful without incurring a very serious headache
    for the authors.
  prefs: []
  type: TYPE_NORMAL
- en: While reading this, we suddenly realize that just because there is already an
    obfuscated C code competition, we don’t really need to overdo its C++ counterpart.
    C++ by definition can be obfuscated enough without us actively trying to obfuscate
    it, but now, after presenting the preceding chimera, we actively owe an apology
    and an explanation to you, dear reader (on the other end, chimeras can be beautiful
    too; you just need to have the right eye for it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first substantial observation we are concluding is that this code cannot
    be compiled by itself. If we try it, GCC will give errors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'ICC will complain, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'MSVC does not like that, as you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Clang isn’t successful either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, basically, the compilers have commonly agreed that they cannot agree on
    a common error message or a reason for failure, but at least none of them can
    compile that piece of code. There are a few very on-the-point error messages,
    such as **#** is possibly the result of a macro expansion (but the author of these
    lines would like to see a macro that expands to **#** because **#define D #**
    is just not working regardless of **D** ) or another message concerning that stray
    **%:** in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: All this macro expansion and so on just leads us in the direction of macros.
    If you, dear reader, are not familiar with C or C++ macros, please go grab a book
    on them, such as *The C++ Programming Language* , by Bjarne Stroustrop, because
    this book (the one you are reading right now) deals only with macros of mythical
    fame, while that one (i.e., *the* C++ book written by the father and creator of
    the language) teaches you to not to use them unless you really, really have to.
    And even then, sparsely.
  prefs: []
  type: TYPE_NORMAL
- en: 'But back to our code. All decent compilers have the means to provide the result
    of the preprocessed C++ file, so let’s examine it for our program. By invoking
    **g++** with the **–E** flag (or Clang with the same flag, or MSVC with the **/P**
    flag if you use the command line for it; otherwise, they will be accessible from
    the build directory of the project you are working on in Visual Studio), we get
    the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We just show what is necessary for now and skip the compiler-specific line info,
    which is also added to the preprocessed output. So, as we can see, the preprocessed
    output looks like a very valid C++ file (albeit not very readable)... to our surprise,
    however, we can see several **define** directives actively present in the file.
    They are prepended by the **%:** symbol, which, after digraph substitution, will
    be transformed into the hashtag symbol ( **#** ) and yield a valid program.
  prefs: []
  type: TYPE_NORMAL
- en: In order to further understand what is happening here, we must understand how
    the compiler deals with macros.
  prefs: []
  type: TYPE_NORMAL
- en: The C compiler (and of course C++ too) expands macros through a methodical process
    managed by the preprocessor, beginning with tokenizing the source code and identifying
    macros for substitution. For object-like macros, a straightforward text replacement
    occurs, whereas function-like macros involve substituting the arguments provided
    in the macro invocation. Function-like macros (the ones that have a pair of parentheses)
    undergo an argument prescan, where macro arguments are fully expanded before being
    substituted into the macro body. This prescan ensures that nested macro calls
    within arguments are expanded correctly and that the final macro body is rescanned
    to catch any further macros for expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the prescan does not apply when arguments are stringized or concatenated,
    nor does it affect macros that are already marked as ineligible for re-expansion.
    This behavior mandates that in order to have proper expansion, we force the compiler
    to do a second pass on the concatenation macros, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet ensures that all the required arguments are properly expanded.
  prefs: []
  type: TYPE_NORMAL
- en: Special macros such as **__LINE__** and **__TIME__** are treated uniquely to
    prevent further unintended expansions. After all expansions are complete, the
    preprocessor ensures that no eligible macros are left unexpanded before passing
    the final code to the compiler. This comprehensive process ensures that macros
    are expanded efficiently and correctly, even in complex scenarios involving nested
    macros and stringification operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have tried to explain how the macro substitution works on a level
    that is not that obvious for the first time, it is time to get back and finally
    compile our program. As you can remember, the preprocessed source still contained
    some statements that had **define** directives in them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, armed with this knowledge, we will reveal an arcane piece of knowledge
    to you, dear reader. In the end, this is a book about the mysticism of C++. This
    arcane piece of knowledge is something called **double preprocessing** . Before
    continuing, however, a small detour on how the compiler deals with your code.
  prefs: []
  type: TYPE_NORMAL
- en: During the initial stages of compiling a C++ source file, the compiler first
    undergoes preprocessing and compilation. In the preprocessing phase, the compiler
    expands macros (just like we have presented previously), processes conditional
    compilation directives ( **#ifdef** , **#ifndef** , etc.), includes header files,
    and removes comments, resulting in a complete translation unit with all external
    files and macros fully resolved. Following this, in the compilation phase, the
    preprocessed code is broken down into tokens during a phase called lexical analysis,
    which are then checked against the language’s syntax rules to construct a **parse
    tree** or **abstract syntax** **tree** ( **AST** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the phase called semantic analysis, where the compiler
    verifies the correct usage of types, variables, and functions, and potentially
    performs early optimizations. Finally, the compiler translates the AST into an
    **intermediate representation** ( **IR** ), setting the stage for further optimization
    and eventual machine code generation, but this is way out of the topics covered
    in this book. However, we would like to direct those of you who are interested
    in this topic to the famous “Dragon book”, also known as *Compilers: Principles,
    Techniques, and Tools* , by Alfred Aho, Jeffrey Ullman, Ravi Sethi, and Monica
    Lam. That is the go-to book for every programmer interested in developing a compiler,
    or just simply interested in learning about the techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: But back to our double preprocessing technique. By using this technique, we
    will pass in the previous preprocessed source file into a compiler, using a technique
    known in Linux as piping and on Windows as hacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Windows command that accomplishes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first part is producing the preprocessed file, which, in Visual C++ land,
    usually has the **.i** extension and the second part will take the preprocessed
    output, place it in **test.i** , and compile it as a C++ file (the **/Tp** switch
    is responsible for this). The result of this is the expected **test.exe** , which,
    after execution, performs exactly as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Linux, the sequence of commands is also very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first part, before the pipe, produces the preprocessed code using **clang++**
    , which, using Linux pipe magic, is sent into **g++** , because why not ☺. For
    this simple scenario, it wouldn’t have mattered if we had used the other way around,
    because these two compilers go hand in hand and they share the basic command-line
    options, such as **–x c++** to specify that the code it would compile is some
    sort of C++ code, or the version of the C++ standard this code complies to. The
    most important argument to the second compiler call is the last **-** sign, which
    tells the compiler to read the code from the stdin, instead of a file.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. Using this arcane technique, we can compile code that we thought
    would be impossible, but... please don’t use it. This code is marginal insanity;
    it is presented just because this book is about unconventional, mythical techniques,
    targeting the advanced C++ programmer community, so don’t let this piece ruin
    your programming style, or scare you away from the keyboard. We wouldn’t want
    to lose our readers halfway through the book. Instead of focusing on this, in
    the upcoming chapter, let’s occupy our minds with sheer nothingness.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of zero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zero is unique among numbers. The concept was present in ancient Egypt, and
    traces of it were found in ancient Babylon as a placeholder in their number system,
    but it wasn’t treated as a true number at that point.
  prefs: []
  type: TYPE_NORMAL
- en: The ancient Greeks have had some resentment towards it because, regardless that
    they knew its importance, initially, due to some philosophical constraints, they
    didn’t use it as a proper number, because not, to be or not to be, but how can
    nothing be, that was the question in the ancient Agora.
  prefs: []
  type: TYPE_NORMAL
- en: The breakthrough came in India around the 5th century CE when mathematician
    Brahmagupta defined zero as a number and established rules for its arithmetic
    use. This concept spread to the Islamic world, notably through the works of Al-Khwarizmi,
    and then to Europe, where Fibonacci played a key role in its adoption in the 12th
    century. Thank you, Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero has several important properties: it is the additive identity, meaning
    adding zero to any number leaves the number unchanged. Multiplying any number
    by zero results in zero, and division by zero is undefined. Zero is an even number
    and serves as a neutral element on the number line, being neither positive nor
    negative. In exponents, raising zero to any positive power gives zero, while any
    non-zero number raised to the power of zero equals one.'
  prefs: []
  type: TYPE_NORMAL
- en: These properties make zero fundamental in mathematics, and with this, we can
    all agree that zero is one of the most important (if not the most important) numbers
    that ever existed; its place is up right next to π, or *e* , or *i* , which we
    all know is the square root of all evil, or –1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have presented concrete proof that there is no other number like zero,
    we also give the following statement: C++ is a unique language. In its latest
    iteration, as of 2024, at the current time, in C++, there are six different ways
    to initialize a value to zero, honoring the fact that zero is the most important
    number. Ever. Just see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down, line by line, as there are not that many lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**int z;** – Here, a global variable, **z** , of the **int** type is declared.
    Since it’s a global variable, it is automatically initialized to **0** by the
    compiler (if a global **int** variable isn’t explicitly initialized, it defaults
    to zero). This is something we can trust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**int z1 = 0;** – Copy initialization. The **z1** variable is declared as an
    **int** type and initialized to **0** using copy initialization. This involves
    assigning the value of **0** to **z1** after it is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**int z2(0);** – Direct initialization. The **z2** variable is declared and
    initialized to **0** using direct initialization, which involves passing the value
    of **0** directly to the constructor of the **int** type. Not that it has any,
    but you get the idea.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**int z3{0};** – Brace initialization (uniform initialization). The **z3**
    variable is declared and initialized to **0** using brace initialization. It helps
    prevent issues such as narrowing conversions and provides a consistent syntax
    for initializing different types. This is a peculiar initialization, and we will
    get back to this syntax a bit later in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**int z4 = {0};** – Copy list initialization. The **z4** variable is declared
    and initialized to **0** using copy list initialization, a combination of copy
    initialization and brace initialization. It’s similar to **z3** but explicitly
    uses the assignment syntax, and when we talk about simple things such as numbers,
    there is really no difference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**int z5{};** – Value initialization. The **z5** variable is initialized using
    empty braces, **{}** , known as value initialization. For fundamental types such
    as **int** , this results in **z5** being initialized to **0** . This method is
    often used to ensure that a variable is zero-initialized without explicitly assigning
    a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Isn’t it beautiful, the amount of consideration that was put into making a
    variable correspond to the number zero? So, one might just ask: why are the local
    variables of C++ not initialized to zero (or their default value), just in case?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question is partly historical and partly pragmatic. Since
    C++ is based on C, and C was designed to be as close to the metal (silicone) as
    possible, the compiler did not waste precious processor cycles to initialize a
    value to their default value, if at some stage later it was used to set to a different
    value needed by the programmer. Elementary, dear reader, as one of the most famous
    detectives would say.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, without me providing any more details, I really hope you
    have recognized the most vexing parse in **int z6();** .
  prefs: []
  type: TYPE_NORMAL
- en: The “most vexing parse” is a term used to describe a specific issue in C++ involving
    the declaration of objects that can be misinterpreted by the compiler due to ambiguities
    in the syntax. It usually arises when you declare a variable using parentheses,
    which can sometimes be interpreted as a function declaration rather than a variable
    definition, just like in our specific example.
  prefs: []
  type: TYPE_NORMAL
- en: A parenthesis concerning parentheses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are here, we have to mention that there were quite a lot of mentions
    of parenthesis in this chapter. So, we are presenting possibly the most important
    pair of parentheses you can encounter during the course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please look at the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Those two functions look almost identical, except for the tiny pair of parentheses
    around the **return** value. But the presence of those two parentheses makes the
    biggest difference. The weird-looking **decltype(auto)** introduced in C++14 is
    a type specifier that combines the functionality of **decltype** with automatic
    type deduction, allowing you to declare a variable with a type that is determined
    by the expression it is initialized with, while also retaining certain properties
    of that expression. Unlike **auto** , which deduces types based on value categories,
    **decltype(auto)** retains the value category (e.g., reference or non-reference)
    of the expression it is based on.
  prefs: []
  type: TYPE_NORMAL
- en: More mundanely, the function number returns an **int** , while the function
    reference returns **int&** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify the correctness of what we previously wrote, the following
    code snippets can be of great help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet examines the return type provided by the **number**
    function. As the name hastily suggests, it will return, well... a number. When
    compiled with MSVC and executed, the following is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The other compilers also have the same behavior, except they do not print out
    the full type of the variable, because **gcc** and **clang** for the **int** type
    just return a single **i** and that wouldn’t have been so spectacular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine the following sequence of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost identical to the one before this, except that it uses the **reference**
    method instead of **number** . Not surprisingly, the result of the execution is
    (again, appealing to MSVC) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, with the preceding code, we have just proved that a pair of extra parentheses
    combined with **decltype(auto)** can provide some spectacular outcomes. Be warned.
    Let’s say we omit **decltype** , such as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The compiler then ignores the parentheses and just returns a normal number.
    The C++ standard specifies this behavior in the **[dcl.type.decltype]** section
    and the authors warmly recommend reading through it, in order to have a full understanding
    of what happens behind the scenes and a valid reasoning for it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, because we are C++ programmers, always in pursuit of speed, high-quality,
    and clear code, you could ask why we had to duplicate the code to identify whether
    we have a reference or not. Wouldn’t it have been perfectly valid to write something
    like the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost the same as above-above (above-above is like above, but refers
    to one above before the actual above), except that we have added an extra check
    to verify the type of the reference (and also removed **std::cout** in favor of
    **printf** because it generates much cleaner assembly code, and also put it in
    the body of a function). Indeed, let’s say we put it into this context and call
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the correct and expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, we get the same result with other, not-that-tiny-and-squishy
    compilers, too.
  prefs: []
  type: TYPE_NORMAL
- en: This function template uses a forwarding reference ( **T&& var** ) to handle
    both **lvalue** and **rvalue** references, making it capable of deducing and preserving
    the reference type of the passed variable. By using the type traits library, we
    check whether **T** is a reference type using **is_reference<T>::value** , and
    further distinguish between **lvalue** and **rvalue** references using **is_lvalue_reference<T>::value**
    .
  prefs: []
  type: TYPE_NORMAL
- en: If it’s a reference, we print whether it’s an **lvalue** or **rvalue** reference
    along with the type of the variable without the reference using **remove_reference<T>::type**
    .
  prefs: []
  type: TYPE_NORMAL
- en: If it’s not a reference, we directly print the type of the variable. This approach
    works because of the perfect forwarding mechanics in C++, allowing **T** to be
    deduced as the exact type of the passed variable, preserving its reference nature.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that it was mandatory to use the forwarding reference, **T&& var**
    ; if we had used just **T var** , it would not work the same way for reference
    types. This is because, in this form, **T** would have been deduced as a non-reference
    type, so **var** inside the function would have been always a copy of the original
    argument, not a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an extra goodie for you, dear reader, here are some extracts of the assembly
    output of one of the compilers (GCC, in our case). You can see how it generates
    two distinct functions, and most importantly, what goes inside those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9.1: Comparing the assembly listings of various printType instantiations'
  prefs: []
  type: TYPE_NORMAL
- en: We can see two instantiations of the **printType** function for each of the
    types returned by the two functions, and how in each of them the various calls
    to the type traits were successfully implemented at the source code level, thus
    leading to the removal of unnecessary branches. We can also observe the removal
    of the unnecessary strings (nowhere is **"rvalue ref"** found in the generated
    code because the compiler identified that the branch containing it is nowhere
    to be found in the final code).
  prefs: []
  type: TYPE_NORMAL
- en: Isn’t C++ beautiful?
  prefs: []
  type: TYPE_NORMAL
- en: C++uties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time that the author of these lines has to admit something. He’s tired
    of ugly code trying to win the C++ beauty contest. Regardless of how hard we try
    to convince ourselves that the code we presented a few sections before is beautiful
    and is worth remembering, well, it is not. It is ugly and horrible, and please
    forget, dear reader, that you ever had to read something like that. Apologies.
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, we solemnly promise that we are up to no more mischief and
    will treat you only with beautiful code. No more ugly macros, no more shady substitutions,
    no more arcane techniques. Just pure, joyful, lovable C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of this reinvention of ourselves (as the writer of beautiful C++
    code), we present you the next program, which possibly is the cutest one you can
    get your hands on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B22235_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please bear with us, for the sake of brevity, we have omitted the includes for
    **std::string** , **std::cout** , and **std::unique_ptr** . Who said C++ can’t
    be cute?
  prefs: []
  type: TYPE_NORMAL
- en: But sadly, the preceding code is not widely recognized as being standard C++
    (seemingly, there is no clear consensus among compiler developers on which Unicode
    identifiers to consider valid in the source code, regardless of **[tab:lex.name.allowed]**
    in the latest C++ standard), but not all hope is lost, as GCC accepts it. Maybe
    there was a bear hugger in the ranks of their developers.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, the code presented does not do too much, just feeds some bears
    with their proper meal, considering their nutrition needs, dietary requirements,
    and affiliations with various dietary patterns and current culinary trends present
    in Bearland. Didn’t we deliver a cute program, a possible contender to the winner
    of the most beautiful C++ code?
  prefs: []
  type: TYPE_NORMAL
- en: There are a good number of books we encourage our dear esteemed readers to read,
    if they want their programs to follow common sense guidelines, be readable, stable,
    easily maintainable and up to the latest standards. Sadly none of those books
    detail how to write fun programs, because writing fun programs, or writing programs
    for fun involves a different mindset, and is rarely done for profit.
  prefs: []
  type: TYPE_NORMAL
- en: Programming can be an art form, producing code that surprises and delights,
    having code can include Easter eggs, humorous output, applying playful user interaction,
    or unusual visualizations. Playfulness could be as simple as using emojis as identifiers
    (as in our bear example) or making quirky applications with oddball logic. Fun
    programming often rejects the rigidity of formal practices in favor of creative
    solutions that may be inefficient or overly complex just for the sake of enjoyment,
    such as crafting an obfuscated piece of code, just because we find it to be fun.
  prefs: []
  type: TYPE_NORMAL
- en: Fun in programming can also come from solving intriguing puzzles or exploring
    unconventional programming paradigms (functional, esoteric languages such as Brainfuck
    or LOLCODE), or building projects purely out of curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: While formal books on “beautiful” or “clean” code emphasize correctness, safety,
    and readability, fun programming opens the door to spontaneity, art, and entertainment,
    so no wonder that our last happening for this chapter is taking part in the last
    one. It is short, it is cute, and it looks like something out of a fairy tale.
    With bears. Because who doesn’t like bears?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all that is shining is gold, and not every piece of code that seems exciting
    and bears complex features is necessarily of high quality. The allure of shiny,
    intricate code can sometimes overshadow the fundamental qualities that define
    good programming practices. Good, stable code is frequently characterized by its
    straightforwardness and predictability rather than its flair. This type of code
    may seem unremarkable or mundane compared to more fun constructs, but it is precisely
    this simplicity that ensures robustness and ease of understanding. When you have
    to, please try to write boring, simple code, as it will be much easier to read
    in half a year from now, but every time you can afford to, please squeeze in a
    bear or two in your fun side project. Unless you plan to read it, too.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, Alex will go on a crusade to advocate the proper use of
    modern C++ libraries, in order to debunk the myth that C++ libraries are also
    stuck in the Stone Age.
  prefs: []
  type: TYPE_NORMAL
