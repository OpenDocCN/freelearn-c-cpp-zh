- en: The Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml), *Enhancing the QT
    Graphical Applications*, we developed an analog clock, a drawing program, and
    an editor with the Qt graphical library. In this chapter, we continue by developing
    the Othello and Noughts and Crosses games with the Qt library. You will find a
    description of these games after this introduction. We start in this chapter with
    basic versions, where two players play against each other. In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml),
    *The Computer Plays*, we improve the games so that the computer plays against
    the human.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to game theory. We develop a game grid where the players take turns
    to add their marks to the game grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We announce the winner. In Othello, after each move, we calculate how many of
    the opponent's marks can be changed. When every position of the game grid has
    been occupied, we declare the winner or a draw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Noughts and Crosses, we count the number of marks in a row. If there are
    five marks in a row, we declare the winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We continue to use C++ features such as classes, fields, and methods. We also
    continue to use Qt features such as windows and widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Othello
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Othello, the game grid is empty at the beginning of the game. During the
    game, two players take turns adding marks, colored in black and white, to the
    game grid. Each time a player adds a mark, we look at the other marks and see
    if the new mark causes any of the opponent’s marks to be enclosed. In that case,
    we swap the color of the opponent’s enclosed marks.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if the black player adds a black mark in a position where the
    three marks to the left are white and the fourth mark is black, the three white
    marks are being enclosed by the two black marks, and they are swapped to black
    marks. When every position on the game grid has been occupied by white and black
    marks, we count the marks and the player with the most marks is the winner. If
    there is an equal number of black and white marks, it is a draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our game should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7a9a4b5-274d-46fc-8bde-d9d10a94b08f.png)'
  prefs: []
  type: TYPE_IMG
- en: The game widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we need a game grid. The `GameWidget` class is common to all the
    applications of this chapter and of [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The
    Computer Plays*. In [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt
    Graphical Applications* and [Chapter 6](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml), *Enhancing
    the QT Graphical Applications*, we developed the `DocumentWidget` class, since
    we worked with document-based applications. In this chapter and [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The
    Computer Plays,* we instead develop the `GameWidget` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `DocumentWidget` class of the two previous chapters and the `GameWidget` class
    of this chapter and the next chapter have both similarities and differences. They
    are both subclasses of the Qt class `QWidget`, and they are both intended to be
    embedded in a window. However, while `DocumentWidget` was intended to hold a document,
    `GameWidget` is intended to hold a game grid. It draws the grid and catches mouse
    clicks in the positions of the grid. `GameWidget` is an abstract class that lets
    it its subclass define methods that are called when the user clicks the mouse
    or when a mark in one of the positions of the game grid needs to be repainted.
  prefs: []
  type: TYPE_NORMAL
- en: However, we reuse the `MainWindow` class from the previous chapters to hold
    the main window of the application, with its menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: '**GameWidget.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the number of rows and columns of the game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clearGrid` method sets every position in the game grid to zero, which
    is assumed to represent an empty position. Therefore, every class that inherits
    `GameWidget` shall let the value zero represent an empty position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resizeEvent` method is called when the user changes the size of the window.
    Since the number of rows and columns is constant, the width and height of each
    position is changed in accordance with the new size of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` is called when the user presses one of the mouse buttons,
    `paintEvent` is called when the window needs to be repainted, and `closeEvent`
    is called when the user clicks on the close box at the top-right corner of the
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMark` and `drawMark` methods are pure virtual methods intended to
    be overridden by subclasses; `mouseMark` is called when the user clicks at a position
    in the grid, and `drawMark` is called when a position needs to be repainted. They
    are pure virtual methods, whereas `GameWidget` is abstract, which means that it
    is only possible to use `GameWidget` as a base class. The subclasses of `GameWidget`
    must override the methods to become non-abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isQuitOk` method displays a message box that asks the user if they really
    want to quit the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isQuitEnabled` method is called before the `Game` menu becomes visible.
    The `Quit` item is enabled when a game is in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onQuit` and `onExit` methods are called when the user selects the Quit
    or Exit menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isGameInProgress` and `setGameInProgress` methods return and set the value
    of the `m_gameInProgress` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` and `set` methods get and set a value at a position in the game grid.
    The value is an integer; remember that an empty position is assumed to hold the
    value zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_gameInProgress` field is true as long as a game is in progress. The
    `m_rows` and `m_columns` fields hold the number of rows and columns of the game
    grid; `m_rowHeight` and `m_columnWidth` hold the height and width in pixels of
    each position in the game grid. Finally, `m_gameGrid` is a pointer to a buffer
    holding the values of the positions of the game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `GameWidget.cpp` file holds the definitions of the methods of the `GameWidget` class,
    the mouse event methods, and the menu methods, as well as the drawings and settings
    of the marks.
  prefs: []
  type: TYPE_NORMAL
- en: '**GameWidget.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the number of rows and columns of the grid, dynamically
    allocates its memory, and calls `clearGrid` to clear the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` method returns the value at the position indicated by the row and
    column and `set` sets the value. The buffer holding the values is organized in
    rows. That is, the first part of the buffer holds the first row, and then the
    second row, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clearGrid` method sets every position to zero, since zero is assumed to
    represent an empty position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Quit` menu item is enabled as long as a game is in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If a game is in progress when the user selects to quit the game, a message
    box with a confirmation question is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user presses the `Yes` button, `true` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `onQuit` method is called when the user selects the Quit menu item. If the
    call to `isQuitOk` returns true, `m_gameInProgress` is set to false and update
    is called, which eventually forces a repaint of the window where the game grid
    is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onExit` method is called when the user selects the Exit menu item. If
    the call to `isQuitOk` returns true, the application is exited. This is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resizeEvent` method is called when the user resizes the window. The row
    height and column width are recalculated since the number of rows and columns
    is constant regardless of the size of the window. We divide the height and width
    of the window by the number of rows and columns plus two, since we add extra rows
    and columns as margins. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` method is called when the user clicks on the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The column width and row height are subtracted from the mouse point, since
    the game grid is enclosed by margins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse point is located inside one of the game grid positions, and that
    position is empty (zero), the pure virtual method `mouseMark` is called, which
    takes care of the actual action of the mouse click. In the next section, black
    and white marks are added to the game grid, and in the Noughts and Crosses application
    later on. Noughts and crosses are added to the game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rows and columns clicked are located in the game grid (rather than in
    the margins outside the game grid) and the position is empty (zero), we call the `mouseMark`, which
    is a pure virtual method, with the row and column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called when the window needs to be repainted. If
    a game is in progress (`m_gameInProgress` is true), the rows and columns are written,
    and then for each position in the game grid, the pure virtual method `drawMark`
    is called, which takes care of the actual painting of each position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we iterate through the rows and for each row, we write a letter from
    `A` to `Z`. There are 26 letters of the alphabet, and we assume there are no more
    than 26 rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we iterate through the columns, and for each column, we write its number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A pure virtual method is a method that is not intended to be defined in the
    class, only in its subclasses. A class holding at least one pure virtual method
    becomes abstract, which means that it is not possible to create objects of the
    class. The class can only be used as a base class in a class hierarchy. A class
    that inherits an abstract class must define each pure virtual method of the base
    class, or become abstract itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we iterate through the game grid, and for each position, we call the
    pure virtual method `drawMark` with the rectangle of the position and its current
    mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `closeEvent` method is called when the user clicks on the close box at
    the top-right corner of the window. If the call to `isQuitOk` returns true, the
    window is closed, and the application is exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The OthelloWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Othello` class is a subclass of `MainWindow` from [Chapter 6](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml),
    *Enhancing the QT Graphical Applications*. It adds menus to the window and sets
    the `OthelloWidget` class here, which is a subclass of `GameWidget`, to its central
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWindow.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_othelloWidgetPtr` field holds a pointer to the widget located in the
    center of the window. It points at an object of the `OthelloWidget` class. This
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `OthelloWindow.cpp` file defines the methods of the `OthelloWIndow` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWindow.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the title of the window to `Othello` and the size to *1000*
    x *500* pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'An `OthelloWidget` object is dynamically created and placed at the center of
    the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the menu `Game` to the menu bar and connect the `onMenuShow` method
    to the menu, which causes it to be called before the menu becomes visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can choose the black or white color to make the first move. The `isBlackStartsEnabled`
    and `isWhiteStartsEnabled` methods are called before the items become visible.
    The items become disabled when a game is in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When a game is in progress, the user can quit the game. The item becomes disabled
    when no game is in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can exit the application at any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor deallocates the `Othello` widget in the center of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The OthelloWidget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`OthelloWidget` is a subclass of the `GameWidget` class we defined at the beginning
    of this chapter. It becomes a non-abstract class by overriding `mouseMark` and
    `drawMark`, which are called when the user clicks at a position in the game grid
    and when a position needs to be repainted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWidget.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A mark in Othello can be black or white. We use the `Mark` enumeration to store
    values on the game grid. The `Empty` item holds a value of zero, which is assumed
    to be `GameWidget` to represent an empty position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isBlackStartsEnabled` and `isWhiteStartsEnabled` listeners are called
    before the `BlackStarts` and `WhiteStarts` menu items become visible in order
    to enable them. Note that the listeners and methods must be marked as public slots
    for the menu framework to allow them as listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onBlackStarts` and `onWhiteStarts` methods are called when the `BlackStarts`
    and `WhiteStarts` menu items are selected by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkWinner` method checks if every position on the game grid has been
    occupied by a black or white mark. If it has, the marks are counted, and the winner
    is announced unless it is a draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `turn` method is called when one of the players has made a move. It calculates
    the positions to be turned as a result of the move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculateMark` method calculates the set of marks to be turned if the
    player places the mark in the position given by the row and column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `m_nextMark` field is alternatively given the values `Black` and `White`
    of the preceding `Mark` enumeration, depending on which player is about to do
    the next move.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is initialized by `onBlackStarts` or `onWhiteStarts`, as shown in the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `OthelloWidget` class holds the functionality of the game. It allows the
    player to add black and white marks to the game grid, turn marks, and announce
    the winner.
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWidget.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BlackStarts` and `WhiteStarts` menu items are enabled when there is not
    already a game in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onBlackStarts` and `onWhiteStarts` methods set a new game in progress,
    set the mark to make the first move (black or white), clear the grid, and update
    the window to paint an empty game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onMouseMark` is called when the player clicks an empty position on the
    game grid. We set the position with the next mark, turn every mark that is affected
    by the move, and update the window to reflect the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We check if the move has caused the game grid to become full and switch the
    next mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `drawMark` method is called when a position in the game grid needs to be
    repainted. We draw a black or white ellipse with black borders if the position
    is not empty. If the position is empty, we do nothing. Note that the framework
    clears the window before the call to repaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkWinner` method counts the number of positions that are occupied by
    black and white marks or are empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no empty positions left, the game is over, and we announce the
    winner, unless it is a draw. The winner is the player with the most marks in their
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `turn` method calls `calculateMark` to obtain the set of positions where
    the mark shall be turned. Then each position in the set is set to the mark in
    question.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this application, `turn` is the only method that calls `calculateMark`.
    However, in [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The Computer
    Plays*, `calculateMark` will also be called to calculate the move of the computer
    player. Therefore, the functionality of `turn` and `calculateMark` are divided
    into two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculateMark` method counts the number of marks that will be turned for
    each position on the game grid, in all eight directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Each integer pair in `directionArray` refers to a direction in accordance with
    the compass rising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of an array can be decided by dividing its total size (in bytes) by
    the size of its first value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the directions and, for each direction, keep moving as long
    as we find the mark of the opponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `row` and `column` fields hold the current row and column as long as we
    iterate in that direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We gather the marks we find during the iteration in `directionSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If we reach one of the borders of the game grid, or if we find an empty position,
    we break the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find the player''s mark, we add the direction set to the total set and
    break the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not find the player''s mark or an empty position, we have found the
    opponent''s mark, and we add its position to the direction set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function works in the same way as in the previous Qt applications.
    It creates an application, shows the Othello window, and executes the applications.
    The execution continues until the `exit` method is called, which it is when the
    user closes the window or selects the Exit menu item.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Noughts and crosses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Noughts and Crosses application sets up a game grid and allows two players
    to play each other. In Noughts and Crosses, two players take turns adding noughts
    and crosses to a game grid. The player that first manages to place five marks
    in a row wins the game. The marks can be placed horizontally, vertically, or diagonally.
    While each player tries to place five of their own marks in a row, they must also
    try to prevent the opponent from placing five marks in a row.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The Computer Plays*,
    the computer plays against the human.
  prefs: []
  type: TYPE_NORMAL
- en: The NaCWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We reuse the `GameWidget` from the game widget section. The `NaCWindow` class
    is similar to `OthelloWindow`. It adds the `Nought Begins` and `Cross Begins`
    menu items to the window's menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWindow.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `NaCWindow.cpp` file holds the definitions of the methods of the `NacWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWindow.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The NaCWidget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NaCWidget` class handles the functionality of Noughts and Crosses. It allows
    two players to play each other. In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml),
    *The Computer Plays*, we will write a game where the computer plays the human.
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWidget.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the Othello application, a position in the game grid can hold one
    of three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Empty` (which is zero)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nought`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Mark` enumeration corresponds to the `Empty`, `Nought`, and `Cross` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `NaCWidget.cpp` file holds the definitions of the methods of the `NaCWidget` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWidget.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isNoughtStartsEnabled` and `isCrossStartsEnabled` methods are called before
    the `Game` menu becomes visible. The `Noughts Begins` and `Cross Begins` menu
    items are enabled if there is no game in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onNoughtBegins` and `onCrossBegins` methods are called when the user selects
    the `Nought Begins` and `Cross Begins` menu items. They set the game in progress,
    set the first mark to make the first move (`m_nextMark`), and force a repainting
    of the game grid by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMark` method is called when the players click a position in the game
    grid. We set the next mark at the position, check if one of the players has won
    the game, swap the next move, and repaint the window by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `drawMark` method is called when a position in the game grid needs to be
    repainted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the pen color to black, and in the case of a nought, we draw an ellipse,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a cross, we draw two lines between the top-left and bottom-right
    corners and between the top-right and bottom-left corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of an empty position, we do nothing. Remember that the framework
    clears the window before the repainting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When a player has made a move, we check if the move has led to victory. We
    call `countMarks` in four directions to `checkWinner` and see if the move has
    caused five marks in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'For the north and south directions, the code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'For the west and east directions, the code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For the northwest and southeast directions, the code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'For southeast and northwest, it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If the move has caused five marks in a row, we display a message box with the
    winner (black or white). In Noughts and Crosses, there can be no draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The game grid is cleared, and is thereby ready for another game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `countMarks` method counts the number of marks in a row. We `countMarks`
    the number of marks in both directions. For instance, if both `rowStep` and `columnStep`
    are minus one, we decrease the current row and column by one for each iteration.
    That means that we call `countMarks` in the northeast direction in the first iteration.
    In the second iteration, we call `countMarks` in the opposite direction, that
    is, in the southwest direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We keep counting until we encounter one of the game grid borders, or we find
    a mark that is not the mark we are counting, that is, the mark of the opposite
    player or an empty mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second iteration, we subtract the row and column steps instead of adding
    them. In this way, we call `countMarks` in the opposite direction. We also initialize
    the current rows and columns by adding the steps in order, so we do not `countMarks`
    the middle mark twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function creates the application, shows the window, and executes
    the application until the user closes the window or selects the Exit menu item.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0111dd0-efe7-4911-8851-1bfa61a04170.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed the two games, Othello and Noughts and Crosses.
    We were introduced to game theory, and we developed a game grid where the players
    take turns to add their marks. In Othello, we developed methods to count the number
    of marks to change for each move, and in Noughts and Crosses, we developed methods
    to recognize if one of the players had managed to place five marks in a row—if
    they had, we declared them the winner.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml), *The Computer Plays*,
    we will develop more advanced versions of these games, where the computer plays
    against a human.
  prefs: []
  type: TYPE_NORMAL
