<html><head></head><body>
<div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.2.1">Code Formatting and Naming Conventions</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the vast and complex landscape of software development, some topics may seem less significant at first glance, yet they hold enormous value when considered in the broader context of creating robust and maintainable software. </span><span class="koboSpan" id="kobo.3.2">Code formatting is one such topic. </span><span class="koboSpan" id="kobo.3.3">While it might appear to be a mere aesthetic concern, it plays an essential role in enhancing code readability, simplifying maintenance, and fostering effective collaboration among team members. </span><span class="koboSpan" id="kobo.3.4">The significance of these aspects becomes even more pronounced in languages such as C++, where the structure and syntax can easily </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">become complex.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will delve deep into the nuances of code formatting, providing you with a comprehensive understanding of its importance. </span><span class="koboSpan" id="kobo.5.2">But understanding the “why” is only the first step; it’s equally crucial to know the “how.” </span><span class="koboSpan" id="kobo.5.3">Therefore, we will also explore the various tools available for automatically formatting your C++ code, taking a close look at their features and possibilities, as well as how they can be configured to meet your project’s specific needs. </span><span class="koboSpan" id="kobo.5.4">From industry-standard tools such as Clang-Format to editor-specific plugins, we’ll examine how to make these powerful utilities work </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">By the end of this chapter, you’ll have not only a thorough understanding of why code formatting is essential but also the practical knowledge to implement consistent and effective formatting across your C++ projects. </span><span class="koboSpan" id="kobo.7.2">So, let’s turn the page and embark on this </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">enlightening journey.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.9.1">Why is code formatting important?</span></h1>
<p><span class="koboSpan" id="kobo.10.1">The importance</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.11.1"> of code formatting in software development, especially in languages such as C++, can’t be overstated. </span><span class="koboSpan" id="kobo.11.2">Let’s begin with readability, which is crucial because code is often read more frequently than it is written. </span><span class="koboSpan" id="kobo.11.3">Proper indentation and spacing give the code a visual structure, facilitating a quick understanding of its flow and logic. </span><span class="koboSpan" id="kobo.11.4">In a well-formatted code base, it’s easier to scan through the code to identify key elements such as loops, conditionals, and sections. </span><span class="koboSpan" id="kobo.11.5">This, in turn, reduces the need for excessive comments since the code often </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">becomes self-explanatory.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">When it comes to maintainability, consistent code formatting is a boon. </span><span class="koboSpan" id="kobo.13.2">Well-structured code is easier to debug. </span><span class="koboSpan" id="kobo.13.3">For instance, a consistent indentation can quickly highlight unclosed brackets or scope issues, making it easier to spot errors. </span><span class="koboSpan" id="kobo.13.4">Well-formatted code also enables developers to isolate sections of code more effectively, which is essential for both debugging and refactoring. </span><span class="koboSpan" id="kobo.13.5">Additionally, maintainability is not just about the here and now; it’s about future-proofing the code. </span><span class="koboSpan" id="kobo.13.6">As the code base evolves, a consistent formatting style ensures that new additions are easier </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">to integrate.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Collaboration is another area where consistent code formatting plays a significant role. </span><span class="koboSpan" id="kobo.15.2">In a team setting, having a unified code style reduces the cognitive load for each team member. </span><span class="koboSpan" id="kobo.15.3">It allows developers to focus more on the logic and implementation of the code rather than getting sidetracked by stylistic inconsistencies. </span><span class="koboSpan" id="kobo.15.4">This is particularly beneficial during code reviews, where the uniform style enables reviewers to focus on the core logic and potential issues instead of being distracted by varying formatting styles. </span><span class="koboSpan" id="kobo.15.5">For new team members, a consistently formatted code base can be much easier to understand, helping them get up to speed </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">more quickly.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Moreover, code formatting plays a role in quality assurance and can be automated to some extent. </span><span class="koboSpan" id="kobo.17.2">Many teams utilize automated formatting tools to ensure that the code base maintains a consistent style, which not only reduces the likelihood of human error but can also be a factor in code quality metrics. </span><span class="koboSpan" id="kobo.17.3">Automated checks for code formatting can be integrated into the CI/CD pipeline, making it a part of the overall best practices for </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">Finally, let’s not </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.20.1">forget the impact of code formatting on version control. </span><span class="koboSpan" id="kobo.20.2">A consistent coding style ensures that version histories and diffs accurately reflect changes in code logic, not just style adjustments. </span><span class="koboSpan" id="kobo.20.3">This makes it easier to track changes, identify issues, and understand the evolution of the code base over time using</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.21.1"> tools</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.22.1"> such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">git blame</span></strong><span class="koboSpan" id="kobo.24.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">git history</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">In conclusion, proper code formatting serves both a functional and aesthetic purpose. </span><span class="koboSpan" id="kobo.27.2">It enhances readability, simplifies maintenance, and fosters collaboration, all of which contribute to the effective and efficient development of robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">maintainable software.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.29.1">Overview of existing tools that facilitate compliance with coding conventions</span></h1>
<p><span class="koboSpan" id="kobo.30.1">The world of C++ development has seen an ever-increasing focus on writing clean, maintainable code. </span><span class="koboSpan" id="kobo.30.2">One of the cornerstones of this approach is adherence to well-defined coding conventions. </span><span class="koboSpan" id="kobo.30.3">Thankfully, several tools can help automate this process, making it easier for developers to focus on solving actual problems rather than fretting over code aesthetics. </span><span class="koboSpan" id="kobo.30.4">In this section, we’ll take a broad look at some of the most popular and widely used tools for enforcing coding conventions in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">C++ projects.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.32.1">cpplint</span></h2>
<p><span class="koboSpan" id="kobo.33.1">cpplint is a </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.34.1">Python-based tool that</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.35.1"> aims to check your C++ code against Google’s style guide, providing a less flexible but highly focused toolset for maintaining coding conventions. </span><span class="koboSpan" id="kobo.35.2">If you or your team admire Google’s C++ coding standards, cpplint offers a straightforward path to ensure compliance within </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">cpplint comes with a set of predefined checks based on Google’s C++ style guide. </span><span class="koboSpan" id="kobo.37.2">These checks cover a variety of aspects, from file headers to indentation, and from variable naming to the inclusion of unnecessary headers. </span><span class="koboSpan" id="kobo.37.3">The tool is executed from the command line, and its output offers clear guidance on which parts of the code violate the guidelines, often providing hints on how to correct </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">these issues.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Being Python-based, cpplint enjoys the advantage of being cross-platform. </span><span class="koboSpan" id="kobo.39.2">You can easily integrate it into development environments across Windows, macOS, and Linux, making it a convenient choice for </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">diverse teams.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">The command-line nature of cpplint allows it to be easily integrated into a variety of development pipelines. </span><span class="koboSpan" id="kobo.41.2">It can be included in pre-commit hooks, part of a CI system, or even be set to run at specific intervals during development. </span><span class="koboSpan" id="kobo.41.3">Several IDEs and text editors also provide plugins to run cpplint automatically on file save or during </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">a build.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">While it doesn’t offer the same level of customization as some other tools, cpplint has the advantage of being backed by Google, and it follows a widely respected style guide. </span><span class="koboSpan" id="kobo.43.2">The tool has extensive documentation that not only explains how to use cpplint but also dives into the reasoning behind specific coding conventions, offering valuable insights into the principles of writing clean, maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">C++ code.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">The primary limitation of cpplint is its lack of flexibility. </span><span class="koboSpan" id="kobo.45.2">The tool is designed to enforce Google’s coding standards and offers limited scope for customization. </span><span class="koboSpan" id="kobo.45.3">This can be a drawback if your project has unique formatting requirements or if you’re working within a team that has already adopted a different set </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">of conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">In conclusion, cpplint</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.48.1"> serves as a focused tool for C++ developers who wish to adopt Google’s </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.49.1">C++ style guide within their projects. </span><span class="koboSpan" id="kobo.49.2">While it may not offer the wide range of customization features found in some other tools, its simplicity, ease of integration, and adherence to well-respected coding standards make it a valuable asset for many </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">development teams.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">More information about cpplint can be</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.52.1"> found on the official page (</span><a href="https://github.com/google/styleguide/tree/gh-pages/cpplint"><span class="koboSpan" id="kobo.53.1">https://github.com/google/styleguide/tree/gh-pages/cpplint</span></a><span class="koboSpan" id="kobo.54.1">) and in the forked GitHub repository maintained by </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">enthusiasts (</span></span><a href="https://github.com/cpplint/cpplint"><span class="No-Break"><span class="koboSpan" id="kobo.56.1">https://github.com/cpplint/cpplint</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.57.1">).</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.58.1">Artistic Style</span></h2>
<p><span class="koboSpan" id="kobo.59.1">In the realm of code </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.60.1">formatting tools, </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">Artistic Style</span></strong><span class="koboSpan" id="kobo.62.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Astyle</span></strong><span class="koboSpan" id="kobo.64.1">) holds a</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.65.1"> unique position. </span><span class="koboSpan" id="kobo.65.2">It is designed to be a fast, small, and, above all, simple tool that supports multiple programming languages, including C++. </span><span class="koboSpan" id="kobo.65.3">One of the standout features of Astyle is its ease of use, making it a particularly good choice for smaller projects or for teams who are venturing into the world of automated code formatting for the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">first time.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Astyle provides a set of predefined styles such as ANSI, GNU, and Google, among others, which can serve as good starting points for your project’s coding conventions. </span><span class="koboSpan" id="kobo.67.2">Additionally, it offers options to adjust indentation, align variables and pointers, and even sort modifiers, among other things. </span><span class="koboSpan" id="kobo.67.3">These can be controlled through command-line options or a </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">configuration file.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">A major benefit of Astyle is its cross-platform nature. </span><span class="koboSpan" id="kobo.69.2">It can be used on Windows, macOS, and Linux, making it a versatile choice for teams with diverse </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">development environments.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">One of the strong suits of Astyle is its ease of integration into various development pipelines. </span><span class="koboSpan" id="kobo.71.2">It can be easily hooked into pre-commit scripts, integrated into the most popular text editors, and even added to your </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">CI process.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Although it may not have as extensive a community as some other tools, Astyle has been around for quite some time and has built up a solid user base. </span><span class="koboSpan" id="kobo.73.2">Its documentation is straightforward to understand, providing clear guidance even for those who are new to the concept of automated </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">code formatting.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">While Astyle is</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.76.1"> feature-rich, it’s </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.77.1">worth noting that it might not be the best fit for extremely large or complex projects that require highly specialized formatting rules. </span><span class="koboSpan" id="kobo.77.2">It offers fewer customization options compared to some other tools, which could be a limitation if your project has very specific </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">formatting requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">In summary, Astyle serves as a robust and easy-to-use tool for automating code formatting in C++ projects. </span><span class="koboSpan" id="kobo.79.2">Its simplicity, ease of integration, and cross-platform support make it an attractive option for many developers. </span><span class="koboSpan" id="kobo.79.3">Whether you are new to automated code formatting or looking for a simpler alternative, Astyle offers a straightforward way to ensure that your code base adheres to consistent coding conventions. </span><span class="koboSpan" id="kobo.79.4">For more information, please refer</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.80.1"> to the project’s official </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">page: </span></span><a href="https://astyle.sourceforge.net/astyle.html"><span class="No-Break"><span class="koboSpan" id="kobo.82.1">https://astyle.sourceforge.net/astyle.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.83.1">.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.84.1">Uncrustify</span></h2>
<p><span class="koboSpan" id="kobo.85.1">When it comes </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.86.1">to the realm of code formatting in C++, Uncrustify stands out for its incredible </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.87.1">range of customization options. </span><span class="koboSpan" id="kobo.87.2">This powerful tool offers a level of granularity that few other formatters can match, making it an ideal choice for large and complex projects with highly specific formatting needs. </span><span class="koboSpan" id="kobo.87.3">If you’re someone who relishes the ability to fine-tune every aspect of your code’s appearance, then Uncrustify is worth a </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">closer look.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Uncrustify supports an extensive set of formatting options, allowing developers to customize everything from indentation levels and brace styles to the alignment of comments and code constructs. </span><span class="koboSpan" id="kobo.89.2">All these options can be set in a configuration file that can then be shared across a development team to ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">consistent formatting.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Uncrustify is cross-platform compatible and can be easily used in development environments on Windows, macOS, and Linux. </span><span class="koboSpan" id="kobo.91.2">It is not tied to any specific development environment and offers a variety of integration paths. </span><span class="koboSpan" id="kobo.91.3">It can be set up as a pre-commit hook in your version control system, integrated into popular IDEs through plugins, or even included as a step in your CI pipeline. </span><span class="koboSpan" id="kobo.91.4">Because of its command-line nature, integrating Uncrustify into various tools and workflows is </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">typically straightforward.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Uncrustify has an active community and its documentation, although sometimes considered dense, is comprehensive. </span><span class="koboSpan" id="kobo.93.2">This provides developers with a rich source of information for understanding the tool’s extensive capabilities. </span><span class="koboSpan" id="kobo.93.3">While the configuration can be challenging due to its sheer volume of options, numerous online resources and forums offer guidance, tips, and best practices for making the most of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">Uncrustify’s features.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">The most notable limitation of Uncrustify is its complexity. </span><span class="koboSpan" id="kobo.95.2">The tool’s strength – its myriad customization options – can also be a weakness, especially for smaller projects or teams that don’t require such a high level of configurability. </span><span class="koboSpan" id="kobo.95.3">Additionally, the steep learning curve could be a barrier for teams looking for a quick solution to implement consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">code formatting.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">In summary, Uncrustify </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.98.1">offers an unmatched level of customization for those looking to fine-tune</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.99.1"> their C++ code formatting to the nth degree. </span><span class="koboSpan" id="kobo.99.2">Its wide array of features, coupled with extensive documentation and an active community, makes it a robust choice for teams seeking to enforce very specific coding standards. </span><span class="koboSpan" id="kobo.99.3">If you’re up for the challenge of mastering its many options, Uncrustify can serve as an invaluable tool for maintaining a clean and consistent code base. </span><span class="koboSpan" id="kobo.99.4">For more detailed information, please refer to the official </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.100.1">GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">page: </span></span><a href="https://github.com/uncrustify/uncrustify"><span class="No-Break"><span class="koboSpan" id="kobo.102.1">https://github.com/uncrustify/uncrustify</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.103.1">.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.104.1">Editor plugins</span></h2>
<p><span class="koboSpan" id="kobo.105.1">In an age where development </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.106.1">teams are more diverse </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.107.1">than ever, relying on a single IDE for code formatting can be problematic. </span><span class="koboSpan" id="kobo.107.2">Not only does it force developers to adapt to a specific work environment – potentially hindering their performance – but it also creates challenges in maintaining a consistent code style across different IDEs. </span><span class="koboSpan" id="kobo.107.3">Furthermore, such reliance poses complications for integrating code formatting into CI/CD pipelines. </span><span class="koboSpan" id="kobo.107.4">This is where editor plugins come into play as a more flexible and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">universal solution.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">One of the key advantages of editor plugins is their wide availability across multiple text editors and IDEs. </span><span class="koboSpan" id="kobo.109.2">Whether your team prefers Visual Studio Code, Sublime Text, Vim, or Emacs, chances are there’s a plugin available that integrates with your chosen code formatting tool. </span><span class="koboSpan" id="kobo.109.3">This means every team member can work in the development environment they are most comfortable with, without compromising on </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">code consistency.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">ditor plugins often act as wrappers around standalone formatting tools such as Clang-Format, Astyle, and Uncrustify. </span><span class="koboSpan" id="kobo.111.2">This facilitates an easy transition, especially if your team is already using one of these tools. </span><span class="koboSpan" id="kobo.111.3">The configuration files for these tools can be shared, ensuring that the same formatting rules are applied irrespective of the editor </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">being used.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Since many editor plugins leverage standalone command-line tools for code formatting, they naturally fit well into CI/CD pipelines. </span><span class="koboSpan" id="kobo.113.2">This eliminates the need to rely on IDE-specific tools, which may not be easily adaptable to CI/CD systems. </span><span class="koboSpan" id="kobo.113.3">With a standalone tool, the same formatting checks can be performed both locally by developers and automatically within the CI/CD pipeline, ensuring consistency across </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">the board.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">While editor plugins offer a versatile approach to code formatting, they do come with their own set of limitations. </span><span class="koboSpan" id="kobo.115.2">First, not all editors may support the full range of available formatting tools, although most popular editors have a wide range of plugins. </span><span class="koboSpan" id="kobo.115.3">Second, while installing and configuring plugins is generally straightforward, it does require an initial setup effort from each developer on </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the team.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Editor plugins</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.118.1"> provide an accessible and </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.119.1">universal solution for implementing code formatting across diverse development environments. </span><span class="koboSpan" id="kobo.119.2">Their flexibility allows team members to choose their preferred editors without sacrificing code consistency, and their compatibility with standalone formatting tools makes them an excellent fit for inclusion in CI/CD pipelines. </span><span class="koboSpan" id="kobo.119.3">For teams that prioritize both developer autonomy and code consistency, editor plugins offer a balanced and </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">effective approach.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.121.1">Clang-Format</span></h2>
<p><span class="koboSpan" id="kobo.122.1">When it comes to discussing </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.123.1">code formatting tools that have gained significant traction in the</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.124.1"> C++ community, Clang-Format undoubtedly takes a front seat. </span><span class="koboSpan" id="kobo.124.2">Often considered the Swiss Army knife of code formatting, this tool combines robustness with a wealth of customization options. </span><span class="koboSpan" id="kobo.124.3">As this chapter’s favorite, we will delve deeper into its intricacies, exploring its extensive features and configurations in </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">subsequent sections.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">At its core, Clang-Format is designed to automatically reformat code so that it complies with a set of specified rules. </span><span class="koboSpan" id="kobo.126.2">These rules can range from handling whitespace and indentation to more complex aspects such as code block alignment and comment reformatting. </span><span class="koboSpan" id="kobo.126.3">Configuration is usually done via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">.clang-format</span></strong><span class="koboSpan" id="kobo.128.1"> file, where developers can define their style preferences in a </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">structured manner.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Clang-Format offers excellent cross-platform support, functioning seamlessly on Windows, macOS, and Linux. </span><span class="koboSpan" id="kobo.130.2">This ensures that irrespective of the development environment, your team can benefit from consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">code formatting.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Clang-Format shines due to its ease of integration. </span><span class="koboSpan" id="kobo.132.2">It can be invoked directly from the command line, included in scripts, or used via plugins in virtually any major text editor or IDE. </span><span class="koboSpan" id="kobo.132.3">This flexibility ensures that each developer can integrate it into their workflow, regardless of their choice </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">of editor.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">The command-line nature of Clang-Format also allows it to easily fit into CI/CD pipelines. </span><span class="koboSpan" id="kobo.134.2">With configuration files that can be stored and version-controlled alongside your code base, it ensures that the CI/CD system applies the same formatting rules as any developer </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">would locally.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">With strong backing from a broad community of developers and extensive documentation, Clang-Format has a wealth of resources available for new and experienced users alike. </span><span class="koboSpan" id="kobo.136.2">This community support becomes particularly beneficial when you’re looking to resolve issues or customize complex </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">formatting rules.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Given its capabilities and </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.139.1">my personal preference for this tool, the latter sections of this </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.140.1">chapter will dive deeper into the world of Clang-Format. </span><span class="koboSpan" id="kobo.140.2">From setting up your first </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">.clang-format</span></strong><span class="koboSpan" id="kobo.142.1"> file to exploring some of its more advanced features, we’ll cover how to make the most of what this powerful tool has </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">to offer.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.144.1">Clang-Format configuration – a deep dive into customizing your formatting rules</span></h1>
<p><span class="koboSpan" id="kobo.145.1">When it comes to </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.146.1">configuring Clang-Format, the possibilities are almost endless, allowing you to tweak even the most minute details of your code’s appearance. </span><span class="koboSpan" id="kobo.146.2">However, for those who are new to this tool or those who wish to quickly adopt a widely accepted set of rules, Clang-Format allows you to derive configurations from existing presets. </span><span class="koboSpan" id="kobo.146.3">These presets serve as solid foundations upon which you can build a tailored formatting style that suits your project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">specific needs.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.148.1">Leveraging existing presets</span></h2>
<p><span class="koboSpan" id="kobo.149.1">Clang-Format</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.150.1"> offers several built-in presets that adhere to popular coding standards. </span><span class="koboSpan" id="kobo.150.2">These include </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">LLVM</span></strong><span class="koboSpan" id="kobo.153.1">: Adheres to the LLVM </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">coding standards</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Google</span></strong><span class="koboSpan" id="kobo.156.1">: Follows Google’s C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">style guide</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Chromium</span></strong><span class="koboSpan" id="kobo.159.1">: Based on Chromium’s style guide, a variant of Google’s </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">style guide</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">Mozilla</span></strong><span class="koboSpan" id="kobo.162.1">: Follows the Mozilla </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">coding standards</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">WebKit</span></strong><span class="koboSpan" id="kobo.165.1">: Adheres to the WebKit </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">coding standards</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.167.1">To use one of these presets, simply set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">BasedOnStyle</span></strong><span class="koboSpan" id="kobo.169.1"> option in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">.clang-format</span></strong><span class="koboSpan" id="kobo.171.1"> configuration file, </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
BasedOnStyle: Google</span></pre>
<p><span class="koboSpan" id="kobo.174.1">This tells Clang-Format to apply the Google C++ style guide as a base and then apply any additional customizations </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">you specify.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.176.1">Extending and overriding presets</span></h2>
<p><span class="koboSpan" id="kobo.177.1">After choosing a </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.178.1">preset that aligns closest with your team’s </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.179.1">coding philosophy, you can start customizing specific rules. </span><span class="koboSpan" id="kobo.179.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">.clang-format</span></strong><span class="koboSpan" id="kobo.181.1"> file allows you to override or extend the preset’s rules by listing them under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">BasedOnStyle</span></strong><span class="koboSpan" id="kobo.183.1"> option. </span><span class="koboSpan" id="kobo.183.2">For example, an extended </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">.clang-format</span></strong><span class="koboSpan" id="kobo.185.1"> example can demonstrate how to fine-tune various aspects of code formatting. </span><span class="koboSpan" id="kobo.185.2">The following is a sample configuration file that starts with Google’s style as a base and then customizes several specific aspects, such as indentation width, brace wrapping, and the alignment of </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">consecutive assignments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
---
BasedOnStyle: Google
# Indentation
IndentWidth: 4
TabWidth: 4
UseTab: Never
# Braces
BreakBeforeBraces: Custom
BraceWrapping:
  AfterClass: true
  AfterControlStatement: false
  AfterEnum: true
  AfterFunction: true
  AfterNamespace: true
  AfterStruct: true
  AfterUnion: true
  BeforeCatch: false
  BeforeElse: false
# Alignment
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlignOperands: true
AlignTrailingComments: true
# Spaces and empty lines
SpaceBeforeParens: ControlStatements
SpaceInEmptyParentheses: false
SpacesInCStyleCastParentheses: false
SpacesInContainerLiterals: true
SpacesInSquareBrackets: false
MaxEmptyLinesToKeep: 2
# Column limit
ColumnLimit: 80</span></pre>
<p><span class="koboSpan" id="kobo.188.1">Let’s take</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.189.1"> a closer look at the options we </span><a id="_idIndexMarker433"/><span class="No-Break"><span class="koboSpan" id="kobo.190.1">chose here:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">IndentWidth</span></strong><span class="koboSpan" id="kobo.192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">TabWidth</span></strong><span class="koboSpan" id="kobo.194.1">: These set the number of spaces for indentation and tabs, respectively. </span><span class="koboSpan" id="kobo.194.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">UseTab: Never</span></strong><span class="koboSpan" id="kobo.196.1"> specifies not to use tabs </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">for indentation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">BreakBeforeBraces</span></strong><span class="koboSpan" id="kobo.199.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">BraceWrapping</span></strong><span class="koboSpan" id="kobo.201.1">: These options customize when to break before opening braces in various situations such as classes, functions, </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">and namespaces.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">AlignAfterOpenBracket</span></strong><span class="koboSpan" id="kobo.204.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">AlignConsecutiveAssignments</span></strong><span class="koboSpan" id="kobo.206.1">, and so on: These control how various code elements, such as open brackets and consecutive assignments, </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">are aligned.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">SpaceBeforeParens</span></strong><span class="koboSpan" id="kobo.209.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">SpaceInEmptyParentheses</span></strong><span class="koboSpan" id="kobo.211.1">, and so on: These manage spaces in different scenarios, such as before parentheses in control statements or within </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">empty parentheses.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">MaxEmptyLinesToKeep</span></strong><span class="koboSpan" id="kobo.214.1">: This option limits the maximum number of consecutive empty lines </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">to keep.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">ColumnLimit</span></strong><span class="koboSpan" id="kobo.217.1">: This option sets a column limit per line to ensure the code doesn’t exceed the specified limit, </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">enhancing readability.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.219.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">.clang-format</span></strong><span class="koboSpan" id="kobo.221.1"> file</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.222.1"> should be placed in the root </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.223.1">directory of your project and committed to your version control system so that every team member and your CI/CD pipeline can use the same configuration for consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">code formatting.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.225.1">Ignoring specific lines with Clang-Format</span></h2>
<p><span class="koboSpan" id="kobo.226.1">While Clang-Format is </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.227.1">an excellent tool for maintaining a consistent coding style across a project, there might be occasions when you’d prefer to keep certain lines or blocks of code untouched. </span><span class="koboSpan" id="kobo.227.2">Thankfully, Clang-Format provides the functionality to exclude specific lines or code blocks from formatting. </span><span class="koboSpan" id="kobo.227.3">This can be particularly useful for lines where the original formatting is essential for readability or lines that contain generated code that should not </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">be altered.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">To ignore a particular line or block of code, you can use special comment markers. </span><span class="koboSpan" id="kobo.229.2">Place </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">// clang-format off</span></strong><span class="koboSpan" id="kobo.231.1"> before the line or block of code that you want to ignore, and then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">// clang-format on</span></strong><span class="koboSpan" id="kobo.233.1"> after the line or block to resume normal formatting. </span><span class="koboSpan" id="kobo.233.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
int main() {
    // clang-format off
    int  variableNameNotFormatted=42;
    // clang-format on
    int properlyFormattedVariable = 43;
}</span></pre>
<p><span class="koboSpan" id="kobo.236.1">In this example, Clang-Format will not touch </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">int  variableNameNotFormatted=42;</span></strong><span class="koboSpan" id="kobo.238.1">, but will apply the specified formatting rules to </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">int properlyFormattedVariable = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">43;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">This feature offers a fine-grained level of control over the formatting process, allowing you to combine the benefits of automated formatting with the nuances that may be required for specific </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.243.1">coding situations. </span><span class="koboSpan" id="kobo.243.2">Feel free to include this in your chapter to provide a complete view of what Clang-Format offers for code </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">style management.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.245.1">Endless options for configuration</span></h2>
<p><span class="koboSpan" id="kobo.246.1">Since Clang-Format is based on the</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.247.1"> Clang compiler’s code parser, it can provide the most precise analysis of source code and, as a result, the most endless configuration options. </span><span class="koboSpan" id="kobo.247.2">The complete list of possible settings can be found on the official </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">page: </span></span><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html"><span class="No-Break"><span class="koboSpan" id="kobo.249.1">https://clang.llvm.org/docs/ClangFormatStyleOptions.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.250.1">.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.251.1">Version control and sharing</span></h2>
<p><span class="koboSpan" id="kobo.252.1">It’s generally a good</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.253.1"> practice to include your </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">.clang-format</span></strong><span class="koboSpan" id="kobo.255.1"> file in your project’s version control system. </span><span class="koboSpan" id="kobo.255.2">This ensures that every member of your team, as well as your CI/CD system, uses the same set of formatting rules, leading to a more consistent and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">code base.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.257.1">Integrating Clang-Format into the build system</span></h1>
<p><span class="koboSpan" id="kobo.258.1">In today’s software</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.259.1"> development landscape, CMake stands </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.260.1">as a de facto industry standard for build systems. </span><span class="koboSpan" id="kobo.260.2">It offers a powerful and flexible way to manage builds across different platforms and compilers. </span><span class="koboSpan" id="kobo.260.3">Integrating Clang-Format – a tool for automatically formatting C++ code – into your CMake build process can help ensure consistent code formatting across your project. </span><span class="koboSpan" id="kobo.260.4">In this section, we’ll delve into how this can be </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">achieved effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">First, you must start by identifying the Clang-Format executable on your system using CMake’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">find_program()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
# Find clang-format
find_program(CLANG_FORMAT_EXECUTABLE NAMES clang-format)</span></pre>
<p><span class="koboSpan" id="kobo.266.1">Next, you must gather all the source files you wish to format. </span><span class="koboSpan" id="kobo.266.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">file(GLOB_RECURSE ...)</span></strong><span class="koboSpan" id="kobo.268.1"> function is useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">this purpose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
# Gather all source files from the root directory recursively
file(GLOB_RECURSE ALL_SOURCE_FILES
    *.cpp
    *.cc
    *.c++
    *.c
    *.C
    *.h
    *.hpp
    *.hxx
)</span></pre>
<p><span class="koboSpan" id="kobo.271.1">However, there’s a slight hiccup: this approach also includes files from your build directory, which you likely don’t want to format. </span><span class="koboSpan" id="kobo.271.2">This also usually applies to third-party directories. </span><span class="koboSpan" id="kobo.271.3">Fortunately, you can filter these out using CMake’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">list(FILTER ...)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.273.1">function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
# Exclude files in the build directory
list(FILTER ALL_SOURCE_FILES EXCLUDE REGEX “^${CMAKE_BINARY_DIR}.*”)</span></pre>
<p><span class="koboSpan" id="kobo.275.1">Finally, you must </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.276.1">create a custom CMake target that, when</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.277.1"> built, runs Clang-Format on your gathered </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">source files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
# Create custom target to run clang-format
if(CLANG_FORMAT_EXECUTABLE)
    add_custom_target(
        clang-format
        COMMAND ${CLANG_FORMAT_EXECUTABLE} -i -style=file ${ALL_SOURCE_FILES}
        COMMENT “Running clang-format”
    )
else()
    message(“clang-format not found! </span><span class="koboSpan" id="kobo.279.2">Target ‘clang-format’ will not be available.”)
endif()</span></pre>
<p><span class="koboSpan" id="kobo.280.1">By doing this, you can create a custom target named </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">clang-format</span></strong><span class="koboSpan" id="kobo.282.1"> that developers can run to automatically format all the source files in the project while ignoring any files in the build directory. </span><span class="koboSpan" id="kobo.282.2">Executing this target can be done with a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">make clang-format</span></strong><span class="koboSpan" id="kobo.284.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">cmake --build . </span><span class="koboSpan" id="kobo.285.2">--target clang-format</span></strong><span class="koboSpan" id="kobo.286.1"> command, ensuring that consistent formatting is maintained </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">with ease.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">Including this</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.289.1"> Clang-Format and CMake integration</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.290.1"> in your build process not only helps in maintaining a consistent coding style but also facilitates easier code reviews and collaborative development. </span><span class="koboSpan" id="kobo.290.2">Feel free to incorporate these insights and code snippets into your project or any technical documentation you’re </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">working on.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.292.1">Clang-Format report examples</span></h1>
<p><span class="koboSpan" id="kobo.293.1">Let’s prepare a </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.294.1">simple example to demonstrate the Clang-Format tool in action. </span><span class="koboSpan" id="kobo.294.2">We will create a basic C++ source file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">main.cpp</span></strong><span class="koboSpan" id="kobo.296.1"> with some formatting issues. </span><span class="koboSpan" id="kobo.296.2">Then, we will run Clang-Format on this file to automatically correct the formatting and generate a report of the </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">changes made:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
#include &lt;iostream&gt;
class Sender {
public:
    void send(const std::string&amp; message) {
        std::cout &lt;&lt; “Sending: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Receiver {
public:
    void receive(const std::string&amp; message) {
        std::cout &lt;&lt; “Receiving: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Mediator {
public:
    Mediator(Sender sender, Receiver receiver)
        : sender_{std::move(sender)}, receiver_{std::move(receiver)} {}
    void send(const std::string&amp; message) {
        sender_.send(message);
    }
    void receive(const std::string&amp; message) {
        receiver_.receive(message);
    }
private:
    Sender sender_;
    Receiver receiver_;
};</span></pre>
<p><span class="koboSpan" id="kobo.299.1">We will try to analyze it </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.300.1">with the Clang-Format tool and a ruleset we defined earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">.clang-format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
make check-clang-format
[100%] Checking code format with clang-format
/home/user/clang-format/clang_format.cpp:4:2: error: code should be clang-formatted [-Wclang-format-violations]
{
 ^
/home/user/clang-format/clang_format.cpp:6:42: error: code should be clang-formatted [-Wclang-format-violations]
    void send(const std::string&amp; message){
                                         ^
/home/user/clang-format/clang_format.cpp:7:18: error: code should be clang-formatted [-Wclang-format-violations]
        std::cout&lt;&lt; “Sending: “ &lt;&lt;message&lt;&lt; std::endl;
                 ^
/home/user/clang-format/clang_format.cpp:7:35: error: code should be clang-formatted [-Wclang-format-violations]
        std::cout&lt;&lt; “Sending: “ &lt;&lt;message&lt;&lt; std::endl;
                                  ^
/home/user/clang-format/clang_format.cpp:7:42: error: code should be clang-formatted [-Wclang-format-violations]
        std::cout&lt;&lt; “Sending: “ &lt;&lt;message&lt;&lt; std::endl;
                                         ^
/home/user/clang-format/clang_format.cpp:11:6: error: code should be clang-formatted [-Wclang-format-violations]
class
     ^
/home/user/clang-format/clang_format.cpp:12:9: error: code should be clang-formatted [-Wclang-format-violations]
Receiver {
        ^
/home/user/clang-format/clang_format.cpp:12:11: error: code should be clang-formatted [-Wclang-format-violations]
Receiver {
          ^
/home/user/clang-format/clang_format.cpp:14:36: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp;message){
                                   ^
/home/user/clang-format/clang_format.cpp:14:44: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp;message){
                                           ^
/home/user/clang-format/clang_format.cpp:14:45: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp;message){
                                            ^
/home/user/clang-format/clang_format.cpp:16:6: error: code should be clang-formatted [-Wclang-format-violations]
    }};
     ^
/home/user/clang-format/clang_format.cpp:18:15: error: code should be clang-formatted [-Wclang-format-violations]
class Mediator{
              ^
/home/user/clang-format/clang_format.cpp:18:16: error: code should be clang-formatted [-Wclang-format-violations]
class Mediator{
               ^
/home/user/clang-format/clang_format.cpp:20:28: error: code should be clang-formatted [-Wclang-format-violations]
    Mediator(Sender sender,Receiver receiver)
                           ^
/home/user/clang-format/clang_format.cpp:21:69: error: code should be clang-formatted [-Wclang-format-violations]
        : sender_{std::move(sender)}, receiver_{std::move(receiver)} {}
                                                                    ^
/home/user/clang-format/clang_format.cpp:21:71: error: code should be clang-formatted [-Wclang-format-violations]
        : sender_{std::move(sender)}, receiver_{std::move(receiver)} {}
                                                                      ^
/home/user/clang-format/clang_format.cpp:22:44: error: code should be clang-formatted [-Wclang-format-violations]
    void send(const std::string&amp; message) {sender_.send(message);}
                                           ^
/home/user/clang-format/clang_format.cpp:22:66: error: code should be clang-formatted [-Wclang-format-violations]
    void send(const std::string&amp; message) {sender_.send(message);}
                                                                 ^
/home/user/clang-format/clang_format.cpp:24:47: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp; message) {
                                              ^
/home/user/clang-format/clang_format.cpp:25:36: error: code should be clang-formatted [-Wclang-format-violations]
        receiver_.receive(message);
                                   ^
/home/user/clang-format/clang_format.cpp:26:6: error: code should be clang-formatted [-Wclang-format-violations]
    }
     ^
/home/user/clang-format/clang_format.cpp:28:11: error: code should be clang-formatted [-Wclang-format-violations]
    Sender sender_;
          ^
make[3]: *** [CMakeFiles/check-clang-format.dir/build.make:71: CMakeFiles/check-clang-format] Error 1
make[2]: *** [CMakeFiles/Makefile2:139: CMakeFiles/check-clang-format.dir/all] Error 2
make[1]: *** [CMakeFiles/Makefile2:146: CMakeFiles/check-clang-format.dir/rule] Error 2
make: *** [Makefile:150: check-clang-format] Error 2</span></pre>
<p><span class="koboSpan" id="kobo.305.1">As you can see, the</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.306.1"> errors are not very descriptive. </span><span class="koboSpan" id="kobo.306.2">However, most of the time, developers can understand what’s wrong with the code. </span><span class="koboSpan" id="kobo.306.3">The tool is not only able to detect the issues but also fix them. </span><span class="koboSpan" id="kobo.306.4">Let’s run the tool to fix the formatting issues </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">make clang-format</span></strong><span class="koboSpan" id="kobo.308.1"> and see </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
#include &lt;iostream&gt;
class Sender
{
   public:
    void send(const std::string&amp; message)
    {
        std::cout &lt;&lt; “Sending: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Receiver
{
   public:
    void receive(const std::string&amp; message)
    {
        std::cout &lt;&lt; “Receiving: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Mediator
{
   public:
    Mediator(Sender sender, Receiver receiver)
        : sender_{std::move(sender)}, receiver_{std::move(receiver)}
    {
    }
    void send(const std::string&amp; message) { sender_.send(message); }
    void receive(const std::string&amp; message) { receiver_.receive(message); }
   private:
    Sender   sender_;
    Receiver receiver_;
};</span></pre>
<p><span class="koboSpan" id="kobo.311.1">The code is now properly </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.312.1">formatted and can be used in the project. </span><span class="koboSpan" id="kobo.312.2">This example can be included in your chapter to demonstrate the practical application of Clang-Format in a real-world scenario. </span><span class="koboSpan" id="kobo.312.3">In the future, developers may add more formatting rules to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">.clang-format</span></strong><span class="koboSpan" id="kobo.314.1"> file and re-format the whole project by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">make </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">clang-format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> command.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.318.1">Extending for code format checks for CI</span></h1>
<p><span class="koboSpan" id="kobo.319.1">When setting up </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.320.1">CI pipelines, it’s often beneficial to only check whether the code complies with the established formatting rules rather than automatically modifying the source files. </span><span class="koboSpan" id="kobo.320.2">This ensures that any code that doesn’t meet the style guidelines is flagged, prompting the developer to fix it manually. </span><span class="koboSpan" id="kobo.320.3">Clang-Format supports this use case with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">--dry-run</span></strong><span class="koboSpan" id="kobo.322.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">--Werror</span></strong><span class="koboSpan" id="kobo.324.1"> options, which, when combined, cause the tool to exit with a non-zero status code if any file </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">is reformatted.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">You can extend the existing CMake setup so that it includes a new custom target that only checks the code format. </span><span class="koboSpan" id="kobo.326.2">Here’s how to </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
# Create custom target to check clang-format
if(CLANG_FORMAT_EXECUTABLE)
    add_custom_target(
        check-clang-format
        COMMAND ${CLANG_FORMAT_EXECUTABLE} -style=file -Werror --dry-run ${ALL_SOURCE_FILES}
        COMMENT “Checking code format with clang-format”
    )
else()
    message(“clang-format not found! </span><span class="koboSpan" id="kobo.328.2">Target ‘check-clang-format’ will not be available.”)
endif()</span></pre>
<p><span class="koboSpan" id="kobo.329.1">In this extended setup, a new custom target named </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">check-clang-format</span></strong><span class="koboSpan" id="kobo.331.1"> has been added. </span><span class="koboSpan" id="kobo.331.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">--dry-run</span></strong><span class="koboSpan" id="kobo.333.1"> option ensures that no files are modified, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">-Werror</span></strong><span class="koboSpan" id="kobo.335.1"> causes Clang-Format to exit with an error code if any formatting discrepancies are found. </span><span class="koboSpan" id="kobo.335.2">This target can be run with </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">make check-clang-format</span></strong><span class="koboSpan" id="kobo.337.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">cmake --build . </span><span class="koboSpan" id="kobo.338.2">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">target check-clang-format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Now, in your CI </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.342.1">pipeline script, you can invoke this custom target to enforce code-style checks. </span><span class="koboSpan" id="kobo.342.2">If the code is not formatted according to the guidelines specified, the build will fail, alerting the team that there is a formatting issue that needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">be resolved.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">For example, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">.clang-format</span></strong><span class="koboSpan" id="kobo.346.1"> file, we set the indent width to four spaces, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">main.cpp</span></strong><span class="koboSpan" id="kobo.348.1"> file only </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">uses two:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
int main() {
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.351.1">Once we run the checker, it shows the problematic code without </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">changing it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
make check-clang-format
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/clang-format-tidy/build
[100%] Checking code format with clang-format
/home/user/clang-format-tidy/main.cpp:2:13: error: code should be clang-formatted [-Wclang-format-violations]
int main() {
            ^
make[3]: *** [CMakeFiles/check-clang-format.dir/build.make:71: CMakeFiles/check-clang-format] Error 1
make[2]: *** [CMakeFiles/Makefile2:137: CMakeFiles/check-clang-format.dir/all] Error 2
make[1]: *** [CMakeFiles/Makefile2:144: CMakeFiles/check-clang-format.dir/rule] Error 2
make: *** [Makefile:150: check-clang-format] Error 2</span></pre>
<p><span class="koboSpan" id="kobo.354.1">By adding this </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.355.1">custom target to your CMake setup, you add an additional layer of quality assurance to your project. </span><span class="koboSpan" id="kobo.355.2">It ensures that no code that violates the established formatting guidelines can make its way into the code base unnoticed. </span><span class="koboSpan" id="kobo.355.3">This is particularly helpful in collaborative environments where multiple developers might be contributing to the same project. </span><span class="koboSpan" id="kobo.355.4">Feel free to include this advanced example and its rationale in your </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">technical content.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.357.1">Clang-Format support across various editors</span></h1>
<p><span class="koboSpan" id="kobo.358.1">Clang-Format </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.359.1">enjoys extensive support across a multitude of text editors and IDEs, streamlining the code-formatting process irrespective of your development environment. </span><span class="koboSpan" id="kobo.359.2">One of the significant advantages of integrating Clang-Format directly into your IDE or text editor is the ability to invoke it effortlessly, right from your development environment. </span><span class="koboSpan" id="kobo.359.3">Even better, many editors support automatically triggering Clang-Format upon saving a file. </span><span class="koboSpan" id="kobo.359.4">This feature can be a massive boon to productivity and code quality as it ensures that every saved version of a source file adheres to the project’s coding standards without requiring </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">manual intervention.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">In Visual Studio Code, there are a few plugins that provide integration </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">with Clang-Format:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.363.1">C/C+</span></strong><span class="koboSpan" id="kobo.364.1">, by </span><a id="_idIndexMarker454"/><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Microsoft: </span></span><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><span class="No-Break"><span class="koboSpan" id="kobo.366.1">https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.367.1">Clang-Format</span></strong><span class="koboSpan" id="kobo.368.1">, by </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.369.1">Xaver </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">Hellauer: </span></span><a href="https://marketplace.visualstudio.com/items?itemName=xaver.clang-format"><span class="No-Break"><span class="koboSpan" id="kobo.371.1">https://marketplace.visualstudio.com/items?itemName=xaver.clang-format</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">ClangD</span></strong><span class="koboSpan" id="kobo.373.1">, by the </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.374.1">LLVM (the creators of Clang, Clang-Format, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">tools): </span></span><a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd"><span class="No-Break"><span class="koboSpan" id="kobo.376.1">https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.377.1">Vim and NeoVim users</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.378.1"> can leverage plugins such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">vim-clang-format</span></strong><span class="koboSpan" id="kobo.380.1"> to integrate Clang-Format, and even map it to specific keyboard shortcuts for quick formatting. </span><span class="koboSpan" id="kobo.380.2">Also, it can usually be enabled via an LSP provider plugin </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">or feature.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">For developers using the full-fledged version of Visual Studio, Clang-Format integration is built-in; you can easily specify a </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">.clang-format</span></strong><span class="koboSpan" id="kobo.384.1"> configuration file and the IDE will use it when you format </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Similarly, JetBrains’ CLion supports Clang-Format out of the box, allowing users to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">.clang-format</span></strong><span class="koboSpan" id="kobo.388.1"> configuration files directly into the project settings. </span><span class="koboSpan" id="kobo.388.2">This broad range of editor support makes it effortless to maintain consistent code formatting across diverse development teams as each team member can use their preferred tools without compromising on </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">code quality.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.390.1">Checking name styling</span></h1>
<p><span class="koboSpan" id="kobo.391.1">After meticulously</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.392.1"> formatting our code to ensure that spaces, asterisks, alignments, and brace positions are all in place, there remains one final frontier to unify – naming style. </span><span class="koboSpan" id="kobo.392.2">Ensuring consistency in naming conventions across classes, variables, functions, and other identifiers can often be a painstaking process, usually relegated to vigilant peer reviews. </span><span class="koboSpan" id="kobo.392.3">However, there’s an automated way to achieve this, thereby reducing manual effort </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">and error.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Clang-Tidy</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.395.1"> comes to the rescue for this purpose. </span><span class="koboSpan" id="kobo.395.2">While we’ll dive deeper into the various capabilities of Clang-Tidy in the next chapter, it’s worth noting that it’s more than just a linter. </span><span class="koboSpan" id="kobo.395.3">It offers a plethora of checks for not just syntactic sugar but also semantic analysis and readability. </span><span class="koboSpan" id="kobo.395.4">One of its most useful features in the context of naming conventions is the identifier naming check. </span><span class="koboSpan" id="kobo.395.5">By configuring this check, you can enforce project-wide rules for naming </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">various entities.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Let’s say you want </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.398.1">your class, struct, and enum names to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">CamelCase</span></strong><span class="koboSpan" id="kobo.400.1">, your namespaces, variables, functions, and methods to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">lower_case</span></strong><span class="koboSpan" id="kobo.402.1">, and your constants to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">UPPER_CASE</span></strong><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">Additionally, you prefer that private and protected variables have a trailing underscore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">_</span></strong><span class="koboSpan" id="kobo.406.1">, while public ones do not. </span><span class="koboSpan" id="kobo.406.2">All of these requirements can be configured in a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">.clang-tidy</span></strong><span class="koboSpan" id="kobo.408.1"> file, which Clang-Tidy will read to enforce your </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">naming rules:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
---
Checks:          ‘readability-identifier-naming’
FormatStyle:     file
CheckOptions:
  - key: readability-identifier-naming.NamespaceCase
    value: ‘lower_case’
  - key: readability-identifier-naming.InlineNamespaceCase
    value: ‘lower_case’
  - key: readability-identifier-naming.EnumCase
    value: ‘CamelCase’
  - key: readability-identifier-naming.EnumConstantCase
    value: ‘UPPER_CASE’
  - key: readability-identifier-naming.ClassCase
    value: ‘CamelCase’
  - key: readability-identifier-naming.StructCase
    value: ‘CamelCase’
  - key: readability-identifier-naming.ClassMethodCase
    value: ‘lower_case’
  - key: readability-identifier-naming.FunctionCase
    value: ‘lower_case’
  - key: readability-identifier-naming.VariableCase
    value: ‘lower_case’
  - key: readability-identifier-naming.GlobalVariableCase
    value: ‘lower_case’
  - key: readability-identifier-naming.StaticConstantCase
    value: ‘UPPER_CASE’
  - key: readability-identifier-naming.PublicMemberCase
    value: ‘lower_case’
  - key: readability-identifier-naming.ProtectedMemberCase
    value: ‘lower_case’
  - key: readability-identifier-naming.PrivateMemberCase
    value: ‘lower_case’
  - key: readability-identifier-naming.PrivateMemberSuffix
    value: ‘_’
  - key: readability-identifier-naming.ClassMemberCase
    value: ‘lower_case’</span></pre>
<p><span class="koboSpan" id="kobo.411.1">These rules </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.412.1">can be endlessly extended with the highest resolution. </span><span class="koboSpan" id="kobo.412.2">The full documentation for existing checks is available </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">at </span></span><a href="https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html"><span class="No-Break"><span class="koboSpan" id="kobo.414.1">https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.415.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">By incorporating Clang-Tidy into your build process and CI pipeline, you can automate the enforcement of these naming conventions, making the code base easier to read, maintain, and collaborate on. </span><span class="koboSpan" id="kobo.416.2">We will delve deeper into configuring and using Clang-Tidy for various other checks in the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">upcoming chapter.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.418.1">Integrating Clang-Tidy into the build system</span></h1>
<p><span class="koboSpan" id="kobo.419.1">We can adapt our existing </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.420.1">CMake setup so that it includes Clang-Tidy </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.421.1">checks, similar to what we did with Clang-Format. </span><span class="koboSpan" id="kobo.421.2">Here’s a sample CMake script that sets up custom targets for running Clang-Tidy on a </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">C++ project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
# Generate compilation database in the build directory
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# Find clang-tidy
find_program(CLANG_TIDY_EXECUTABLE NAMES clang-tidy)
# Gather all source files from the root directory recursively
file(GLOB_RECURSE ALL_SOURCE_FILES
    *.cpp
    *.cc
    *.c++
    *.c
    *.C
    *.h
    *.hpp
    *.hxx
)
# Exclude files in the build directory
list(FILTER ALL_SOURCE_FILES EXCLUDE REGEX “^${CMAKE_BINARY_DIR}.*”)
# Create custom target to run clang-tidy
if(CLANG_TIDY_EXECUTABLE)
    add_custom_target(
        clang-tidy
        COMMAND ${CLANG_TIDY_EXECUTABLE} -p=${CMAKE_BINARY_DIR} ${ALL_SOURCE_FILES}
        COMMENT “Running clang-tidy”
    )
else()
    message(“clang-tidy not found! </span><span class="koboSpan" id="kobo.423.2">Target ‘clang-tidy’ will not be available.”)
endif()
# Create custom target to check clang-tidy
if(CLANG_TIDY_EXECUTABLE)
    add_custom_target(
        check-clang-tidy
        COMMAND ${CLANG_TIDY_EXECUTABLE} -p=${CMAKE_BINARY_DIR} --warnings-as-errors=* ${ALL_SOURCE_FILES}
        COMMENT “Checking code quality with clang-tidy”
    )
else()
    message(“clang-tidy not found! </span><span class="koboSpan" id="kobo.423.3">Target ‘check-clang-tidy’ will not be available.”)
endif()</span></pre>
<p><span class="koboSpan" id="kobo.424.1">In this script, we </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.425.1">locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">clang-tidy</span></strong><span class="koboSpan" id="kobo.427.1"> executable using </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">find_program</span></strong><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">Similar to the Clang-Format setup, we then gather all the source</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.430.1"> files from the root directory recursively, making sure we exclude those in the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">build directory.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Two custom targets are </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">added here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">clang-tidy</span></strong><span class="koboSpan" id="kobo.435.1">: This target runs Clang-Tidy on all gathered source files. </span><span class="koboSpan" id="kobo.435.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">-p=${CMAKE_BINARY_DIR}</span></strong><span class="koboSpan" id="kobo.437.1"> flag specifies the build directory containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">compile_commands.json</span></strong><span class="koboSpan" id="kobo.439.1"> file, which Clang-Tidy uses for its checks. </span><span class="koboSpan" id="kobo.439.2">This JSON file is generated by CMake and contains information about how each source file in the project is compiled. </span><span class="koboSpan" id="kobo.439.3">It includes details such as the compiler options, include directories, defines, and so on. </span><span class="koboSpan" id="kobo.439.4">Clang-Tidy uses this information to understand the build context of each source file, allowing it to perform more accurate and </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">meaningful checks.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">check-clang-tidy</span></strong><span class="koboSpan" id="kobo.442.1">: This target performs the same operation but with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">--warnings-as-errors=*</span></strong><span class="koboSpan" id="kobo.444.1"> flag. </span><span class="koboSpan" id="kobo.444.2">This will treat all warnings as errors, which is especially useful for CI/CD pipelines to ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">code quality.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.446.1">As in your previous setup, running these custom targets can be done via </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">make clang-tidy</span></strong><span class="koboSpan" id="kobo.448.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">make check-clang-tidy</span></strong><span class="koboSpan" id="kobo.450.1"> or their equivalent </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">cmake --build . </span><span class="koboSpan" id="kobo.451.2">--target clang-tidy</span></strong><span class="koboSpan" id="kobo.452.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">cmake --build . </span><span class="koboSpan" id="kobo.453.2">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">target check-clang-tidy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">By integrating Clang-Tidy into your CMake build process, you’ll be providing another layer of automated code quality checks, much like you did with Clang-Format. </span><span class="koboSpan" id="kobo.456.2">Feel free to include this in your chapter for a comprehensive look at automated code </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">quality assurance.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.458.1">Checking source code name styling with Clang-Tidy</span></h1>
<p><span class="koboSpan" id="kobo.459.1">Now that we’ve </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.460.1">successfully configured Clang-Tidy’s rules </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.461.1">and integrated the tool into our CMake build system, it’s time for a real-world test. </span><span class="koboSpan" id="kobo.461.2">For this purpose, we’ll use a snippet of C++ code that deliberately violates the naming conventions </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">we’ve established:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
#include &lt;string&gt;
#include &lt;vector&gt;
namespace Filesystem { // CamelCase instead of lower_case
enum class Permissions : uint8_t { READ, WRITE, execute };
struct User {
    std::string name_; // redundant suffix _ for public member
    int Id = 0;        // CamelCase instead of lower_case
    Permissions permissions;
};
class file { // lower_case instead of CamelCase
public:
    file(int id, const std::string &amp;file_name,
         const std::vector&lt;User&gt; access_list)
        : id{id}, FileName_{file_name}, access_list_{access_list} {}
    int GetId() const // CamelCase instead of lower_case
    {
        return id;
    }
    auto &amp;getName() const // camelBack instead of lower_case
    {
        return FileName_;
    }
    const std::vector&lt;User&gt; &amp;access_list() const { return access_list_; }
private:
    int id;                // missing suffix _
    std::string FileName_; // CamelCase instead of lower_case
    std::vector&lt;User&gt; access_list_;
};
} // namespace Filesystem
int main() {
    auto user        = Filesystem::User{};
    user.name_       = “user”;
    user.permissions = Filesystem::Permissions::execute;
    auto file = Filesystem::file{0, “~/home/user/file”, {user}};
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.464.1">When we</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.465.1"> run </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">make clang-tidy</span></strong><span class="koboSpan" id="kobo.467.1">, Clang-Tidy </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.468.1">will spring into action, scanning the offending code and flagging any naming issues directly in the terminal output. </span><span class="koboSpan" id="kobo.468.2">I’ve only provided a partial output here to </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">save space:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
make check-clang-tidy
[100%] Checking code quality with clang-tidy
9 warnings generated.
</span><span class="koboSpan" id="kobo.470.2">/home/user/clang-format-tidy/main.cpp:4:11: error: invalid case style for namespace ‘Filesystem’ [readability-identifier-naming,-warnings-as-errors]
    4 | namespace Filesystem { // CamelCase instead of lower_case
      |           ^~~~~~~~~~
      |           filesystem
/home/user/clang-format-tidy/main.cpp:6:49: error: invalid case style for enum constant ‘execute’ [readability-identifier-naming,-warnings-as-errors]
    6 | enum class Permissions : uint8_t { READ, WRITE, execute };
      |                                                 ^~~~~~~
      |                                                 EXECUTE
/home/user/clang-format-tidy/main.cpp:9:17: error: invalid case style for public member ‘name_’ [readability-identifier-naming,-warnings-as-errors]
    9 |     std::string name_; // redundant suffix _ for public member
      |                 ^~~~~
      |                 name
/home/user/clang-format-tidy/main.cpp:10:9: error: invalid case style for public member ‘Id’ [readability-identifier-naming,-warnings-as-errors]
   10 |     int Id = 0;        // CamelCase instead of lower_case
      |         ^~
      |         id
/home/user/clang-format-tidy/main.cpp:14:7: error: invalid case style for class ‘file’ [readability-identifier-naming,-warnings-as-errors]
   14 | class file { // lower_case instead of CamelCase
      |       ^~~~
      |       File
   15 | public:
   16 |     file(int id, const std::string &amp;file_name,
      |     ~~~~
      |     File
/home/user/clang-format-tidy/main.cpp:20:9: error: invalid case style for function ‘GetId’ [readability-identifier-naming,-warnings-as-errors]
   20 |     int GetId() const // CamelCase instead of lower_case
      |         ^~~~~
      |         get_id
9 warnings treated as errors</span></pre>
<p><span class="koboSpan" id="kobo.471.1">This exercise </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.472.1">demonstrates the tangible benefits of </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.473.1">integrating Clang-Tidy into the build process. </span><span class="koboSpan" id="kobo.473.2">It not only identifies deviations from established naming conventions in the code but also provides an opportunity for immediate rectification. </span><span class="koboSpan" id="kobo.473.3">It’s an invaluable step toward maintaining a code base that is not just functional but also consistently well-structured. </span><span class="koboSpan" id="kobo.473.4">It’s advisable to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">make clang-tidy</span></strong><span class="koboSpan" id="kobo.475.1"> command in your CI pipeline. </span><span class="koboSpan" id="kobo.475.2">By doing so, you can automatically validate the naming conventions and other code styling rules for every commit made to your repository. </span><span class="koboSpan" id="kobo.475.3">This will help ensure that any new contributions to the code base conform to the established guidelines. </span><span class="koboSpan" id="kobo.475.4">If a commit fails the Clang-Tidy checks, the CI pipeline can flag it for review, making it easier to maintain a consistent, high-quality code base. </span><span class="koboSpan" id="kobo.475.5">This added layer of automation eliminates the need for manual checks for these issues, thus streamlining the code review process and making your development workflow </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">more efficient.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.477.1">Fixing naming issues automatically</span></h1>
<p><span class="koboSpan" id="kobo.478.1">The real </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.479.1">power of Clang-Tidy lies in its ability to not just identify</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.480.1"> issues but also to rectify them automatically. </span><span class="koboSpan" id="kobo.480.2">Manual fixes can be time-consuming and error-prone, making automation incredibly valuable in a fast-paced development environment. </span><span class="koboSpan" id="kobo.480.3">Fortunately, Clang-Tidy excels in this area. </span><span class="koboSpan" id="kobo.480.4">Most of the fixes suggested by the tool can be applied automatically, saving you countless hours of manual labor and potential errors. </span><span class="koboSpan" id="kobo.480.5">To apply these automatic fixes, simply run </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">make clang-tidy</span></strong><span class="koboSpan" id="kobo.482.1"> in your terminal. </span><span class="koboSpan" id="kobo.482.2">The tool will scan the code for violations, and where possible, it will automatically correct the code so that it aligns with your </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">configured guidelines:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
#include &lt;string&gt;
#include &lt;vector&gt;
namespace filesystem { // CamelCase instead of lower_case
enum class Permissions : uint8_t { READ, WRITE, EXECUTE };
struct User {
    std::string name; // redundant suffix _ for public member
    int id = 0;       // CamelCase instead of lower_case
    Permissions permissions;
};
class File { // lower_case instead of CamelCase
public:
    File(int id, const std::string &amp;file_name,
         const std::vector&lt;User&gt; access_list)
        : id_{id}, file_name_{file_name}, access_list_{access_list} {}
    int get_id() const // CamelCase instead of lower_case
    {
        return id_;
    }
    auto &amp;get_name() const // camelBack instead of lower_case
    {
        return file_name_;
    }
    const std::vector&lt;User&gt; &amp;access_list() const { return access_list_; }
private:
    int id_;                // missing suffix _
    std::string file_name_; // CamelCase instead of lower_case
    std::vector&lt;User&gt; access_list_;
};
} // namespace filesystem
int main() {
    auto user        = filesystem::User{};
    user.name        = “user”;
    user.permissions = filesystem::Permissions::EXECUTE;
    auto file = filesystem::File{0, “~/home/user/file”, {user}};
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.485.1">Note that not only were the classes, methods, and variables definitions updated but also references to them. </span><span class="koboSpan" id="kobo.485.2">This functionality makes Clang-Tidy not just a diagnostic tool but a valuable assistant in maintaining the overall quality of your </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">code base.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.487.1">Important caveats</span></h2>
<p><span class="koboSpan" id="kobo.488.1">There are some important caveats</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.489.1"> to consider when using Clang-Tidy. </span><span class="koboSpan" id="kobo.489.2">Let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">a look:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.491.1">Single versus multiple instances</span></strong><span class="koboSpan" id="kobo.492.1">: The CMake configuration we’ve discussed runs a single instance of Clang-Tidy to check and fix all the source files. </span><span class="koboSpan" id="kobo.492.2">While this may be sufficient for smaller projects, it can become a bottleneck for larger code bases with numerous checks. </span><span class="koboSpan" id="kobo.492.3">In such scenarios, it might be more efficient to divide the source code into logical groups and run multiple instances of Clang-Tidy in parallel. </span><span class="koboSpan" id="kobo.492.4">This strategy can significantly reduce the time it takes to scan the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">code base.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.494.1">Commit before fixing</span></strong><span class="koboSpan" id="kobo.495.1">: While Clang-Tidy’s ability to automatically fix issues is invaluable, it’s advised to use this feature only on code that has been committed to your version control system. </span><span class="koboSpan" id="kobo.495.2">Some of the checks provided by Clang-Tidy can be unstable and, in rare instances, may even introduce bugs. </span><span class="koboSpan" id="kobo.495.3">Committing your code beforehand ensures that you have a stable point to revert to if things </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">go awry.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.497.1">Syntax limitations</span></strong><span class="koboSpan" id="kobo.498.1">: Lastly, it’s worth noting that Clang-Tidy may not always be up-to-date with the latest C++ syntax. </span><span class="koboSpan" id="kobo.498.2">While it generally does an excellent job, there could be instances where it flags false positives or is unable to handle new language features. </span><span class="koboSpan" id="kobo.498.3">For example, let’s say the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">User</span></strong><span class="koboSpan" id="kobo.500.1"> struct was initialized using C++20 designated initializer lists, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">following example:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.502.1">
auto user = Filesystem::User{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.503.1">
    .name_ = “user”, .permissions = Filesystem::Permissions::execute};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.504.1">Clang-Tidy will fix the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">name_</span></strong><span class="koboSpan" id="kobo.506.1"> variable and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">execute</span></strong><span class="koboSpan" id="kobo.508.1"> constant in their definition but will</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.509.1"> completely ignore the initializer, which will eventually lead to a </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">compilation error.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.511.1">Being aware of these caveats allows you to employ Clang-Tidy more effectively and leverage its strengths while mitigating </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">potential risks.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.513.1">Example project</span></h1>
<p><span class="koboSpan" id="kobo.514.1">For those who wish to delve deeper into the details and get hands-on experience with the configuration and usage of Clang-Tidy and Clang-Format, an example project complete with the CMake setup and code snippets is available on GitHub (</span><a href="https://github.com/f-squirrel/clang-format-tidy"><span class="koboSpan" id="kobo.515.1">https://github.com/f-squirrel/clang-format-tidy</span></a><span class="koboSpan" id="kobo.516.1">). </span><span class="koboSpan" id="kobo.516.2">This will allow you to better understand the nuances and practical applications of integrating these tools into your C++ projects. </span><span class="koboSpan" id="kobo.516.3">Feel free to clone the repository, experiment with the code, and even contribute to enhancing </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">it further.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.518.1">Clang-Tidy support across various editors</span></h1>
<p><span class="koboSpan" id="kobo.519.1">The IDE and editor support</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.520.1"> for Clang-Tidy is broadly similar to that for Clang-Format, making it equally accessible and easy to integrate into your development workflow. </span><span class="koboSpan" id="kobo.520.2">The principal advantage of this integrated support is the immediate feedback loop it offers. </span><span class="koboSpan" id="kobo.520.3">As you code, Clang-Tidy warnings and errors will appear directly within your IDE, enabling you to spot potential issues without having to leave the development environment. </span><span class="koboSpan" id="kobo.520.4">This is immensely valuable for maintaining code quality in real time, rather than as a </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">separate step.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">Moreover, many IDEs also provide an interface to apply Clang-Tidy’s automatic fixes directly from within the editor, making it easier than ever to adhere to your coding standards. </span><span class="koboSpan" id="kobo.522.2">For example, the following screenshot of Visual Studio Code illustrates the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">inline warnings:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.524.1"><img alt="Figure 9.1 – Warnings" src="image/B19606_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.525.1">Figure 9.1 – Warnings</span></p>
<p><span class="koboSpan" id="kobo.526.1">The following screenshot shows the fixes that can be applied </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">to them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.528.1"><img alt="Figure 9.2 – Applicable fixes" src="image/B19606_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.529.1">Figure 9.2 – Applicable fixes</span></p>
<p><span class="koboSpan" id="kobo.530.1">This real-time, in-editor </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.531.1">feedback mechanism can significantly boost your productivity and code quality, making Clang-Tidy not just a static code analysis tool but an integral part of your </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">coding process.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.533.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.534.1">In this chapter, we navigated the essential landscape of automated code quality maintenance, focusing particularly on code formatting and naming conventions. </span><span class="koboSpan" id="kobo.534.2">We started by providing an overview of existing tools that can help enforce coding standards, then zeroed in on Clang-Format and Clang-Tidy as comprehensive solutions for these issues. </span><span class="koboSpan" id="kobo.534.3">We learned not only how to use these tools to automatically check and fix our code but also how to seamlessly integrate them into our build system, CI pipelines, and </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">code editors.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">By doing so, we’ve laid a strong foundation for ensuring that our code remains consistent and adheres to best practices, all with minimal manual intervention. </span><span class="koboSpan" id="kobo.536.2">This sets the stage perfectly for the next chapter, where we will dive deeper into the realm of static code analysis, further solidifying our commitment to high-quality, </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">maintainable code.</span></span></p>
</div>
</body></html>