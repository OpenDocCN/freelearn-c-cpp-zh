<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor157"/>9</h1>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Code Formatting and Naming Conventions</h1>
<p>In the vast and complex landscape of software development, some topics may seem less significant at first glance, yet they hold enormous value when considered in the broader context of creating robust and maintainable software. Code formatting is one such topic. While it might appear to be a mere aesthetic concern, it plays an essential role in enhancing code readability, simplifying maintenance, and fostering effective collaboration among team members. The significance of these aspects becomes even more pronounced in languages such as C++, where the structure and syntax can easily become complex.</p>
<p>In this chapter, we will delve deep into the nuances of code formatting, providing you with a comprehensive understanding of its importance. But understanding the “why” is only the first step; it’s equally crucial to know the “how.” Therefore, we will also explore the various tools available for automatically formatting your C++ code, taking a close look at their features and possibilities, as well as how they can be configured to meet your project’s specific needs. From industry-standard tools such as Clang-Format to editor-specific plugins, we’ll examine how to make these powerful utilities work for you.</p>
<p>By the end of this chapter, you’ll have not only a thorough understanding of why code formatting is essential but also the practical knowledge to implement consistent and effective formatting across your C++ projects. So, let’s turn the page and embark on this enlightening journey.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Why is code formatting important?</h1>
<p>The importance<a id="_idIndexMarker401"/> of code formatting in software development, especially in languages such as C++, can’t be overstated. Let’s begin with readability, which is crucial because code is often read more frequently than it is written. Proper indentation and spacing give the code a visual structure, facilitating a quick understanding of its flow and logic. In a well-formatted code base, it’s easier to scan through the code to identify key elements such as loops, conditionals, and sections. This, in turn, reduces the need for excessive comments since the code often becomes self-explanatory.</p>
<p>When it comes to maintainability, consistent code formatting is a boon. Well-structured code is easier to debug. For instance, a consistent indentation can quickly highlight unclosed brackets or scope issues, making it easier to spot errors. Well-formatted code also enables developers to isolate sections of code more effectively, which is essential for both debugging and refactoring. Additionally, maintainability is not just about the here and now; it’s about future-proofing the code. As the code base evolves, a consistent formatting style ensures that new additions are easier to integrate.</p>
<p>Collaboration is another area where consistent code formatting plays a significant role. In a team setting, having a unified code style reduces the cognitive load for each team member. It allows developers to focus more on the logic and implementation of the code rather than getting sidetracked by stylistic inconsistencies. This is particularly beneficial during code reviews, where the uniform style enables reviewers to focus on the core logic and potential issues instead of being distracted by varying formatting styles. For new team members, a consistently formatted code base can be much easier to understand, helping them get up to speed more quickly.</p>
<p>Moreover, code formatting plays a role in quality assurance and can be automated to some extent. Many teams utilize automated formatting tools to ensure that the code base maintains a consistent style, which not only reduces the likelihood of human error but can also be a factor in code quality metrics. Automated checks for code formatting can be integrated into the CI/CD pipeline, making it a part of the overall best practices for the project.</p>
<p>Finally, let’s not <a id="_idIndexMarker402"/>forget the impact of code formatting on version control. A consistent coding style ensures that version histories and diffs accurately reflect changes in code logic, not just style adjustments. This makes it easier to track changes, identify issues, and understand the evolution of the code base over time using<a id="_idIndexMarker403"/> tools<a id="_idIndexMarker404"/> such as <code>git blame</code> and <code>git history</code>.</p>
<p>In conclusion, proper code formatting serves both a functional and aesthetic purpose. It enhances readability, simplifies maintenance, and fosters collaboration, all of which contribute to the effective and efficient development of robust and maintainable software.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Overview of existing tools that facilitate compliance with coding conventions</h1>
<p>The world of C++ development has seen an ever-increasing focus on writing clean, maintainable code. One of the cornerstones of this approach is adherence to well-defined coding conventions. Thankfully, several tools can help automate this process, making it easier for developers to focus on solving actual problems rather than fretting over code aesthetics. In this section, we’ll take a broad look at some of the most popular and widely used tools for enforcing coding conventions in C++ projects.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>cpplint</h2>
<p>cpplint is a <a id="_idIndexMarker405"/>Python-based tool that<a id="_idIndexMarker406"/> aims to check your C++ code against Google’s style guide, providing a less flexible but highly focused toolset for maintaining coding conventions. If you or your team admire Google’s C++ coding standards, cpplint offers a straightforward path to ensure compliance within your project.</p>
<p>cpplint comes with a set of predefined checks based on Google’s C++ style guide. These checks cover a variety of aspects, from file headers to indentation, and from variable naming to the inclusion of unnecessary headers. The tool is executed from the command line, and its output offers clear guidance on which parts of the code violate the guidelines, often providing hints on how to correct these issues.</p>
<p>Being Python-based, cpplint enjoys the advantage of being cross-platform. You can easily integrate it into development environments across Windows, macOS, and Linux, making it a convenient choice for diverse teams.</p>
<p>The command-line nature of cpplint allows it to be easily integrated into a variety of development pipelines. It can be included in pre-commit hooks, part of a CI system, or even be set to run at specific intervals during development. Several IDEs and text editors also provide plugins to run cpplint automatically on file save or during a build.</p>
<p>While it doesn’t offer the same level of customization as some other tools, cpplint has the advantage of being backed by Google, and it follows a widely respected style guide. The tool has extensive documentation that not only explains how to use cpplint but also dives into the reasoning behind specific coding conventions, offering valuable insights into the principles of writing clean, maintainable C++ code.</p>
<p>The primary limitation of cpplint is its lack of flexibility. The tool is designed to enforce Google’s coding standards and offers limited scope for customization. This can be a drawback if your project has unique formatting requirements or if you’re working within a team that has already adopted a different set of conventions.</p>
<p>In conclusion, cpplint<a id="_idIndexMarker407"/> serves as a focused tool for C++ developers who wish to adopt Google’s <a id="_idIndexMarker408"/>C++ style guide within their projects. While it may not offer the wide range of customization features found in some other tools, its simplicity, ease of integration, and adherence to well-respected coding standards make it a valuable asset for many development teams.</p>
<p>More information about cpplint can be<a id="_idIndexMarker409"/> found on the official page (<a href="https://github.com/google/styleguide/tree/gh-pages/cpplint">https://github.com/google/styleguide/tree/gh-pages/cpplint</a>) and in the forked GitHub repository maintained by enthusiasts (<a href="https://github.com/cpplint/cpplint">https://github.com/cpplint/cpplint</a>).</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Artistic Style</h2>
<p>In the realm of code <a id="_idIndexMarker410"/>formatting tools, <strong class="bold">Artistic Style</strong> (<strong class="bold">Astyle</strong>) holds a<a id="_idIndexMarker411"/> unique position. It is designed to be a fast, small, and, above all, simple tool that supports multiple programming languages, including C++. One of the standout features of Astyle is its ease of use, making it a particularly good choice for smaller projects or for teams who are venturing into the world of automated code formatting for the first time.</p>
<p>Astyle provides a set of predefined styles such as ANSI, GNU, and Google, among others, which can serve as good starting points for your project’s coding conventions. Additionally, it offers options to adjust indentation, align variables and pointers, and even sort modifiers, among other things. These can be controlled through command-line options or a configuration file.</p>
<p>A major benefit of Astyle is its cross-platform nature. It can be used on Windows, macOS, and Linux, making it a versatile choice for teams with diverse development environments.</p>
<p>One of the strong suits of Astyle is its ease of integration into various development pipelines. It can be easily hooked into pre-commit scripts, integrated into the most popular text editors, and even added to your CI process.</p>
<p>Although it may not have as extensive a community as some other tools, Astyle has been around for quite some time and has built up a solid user base. Its documentation is straightforward to understand, providing clear guidance even for those who are new to the concept of automated code formatting.</p>
<p>While Astyle is<a id="_idIndexMarker412"/> feature-rich, it’s <a id="_idIndexMarker413"/>worth noting that it might not be the best fit for extremely large or complex projects that require highly specialized formatting rules. It offers fewer customization options compared to some other tools, which could be a limitation if your project has very specific formatting requirements.</p>
<p>In summary, Astyle serves as a robust and easy-to-use tool for automating code formatting in C++ projects. Its simplicity, ease of integration, and cross-platform support make it an attractive option for many developers. Whether you are new to automated code formatting or looking for a simpler alternative, Astyle offers a straightforward way to ensure that your code base adheres to consistent coding conventions. For more information, please refer<a id="_idIndexMarker414"/> to the project’s official page: <a href="https://astyle.sourceforge.net/astyle.html">https://astyle.sourceforge.net/astyle.html</a>.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Uncrustify</h2>
<p>When it comes <a id="_idIndexMarker415"/>to the realm of code formatting in C++, Uncrustify stands out for its incredible <a id="_idIndexMarker416"/>range of customization options. This powerful tool offers a level of granularity that few other formatters can match, making it an ideal choice for large and complex projects with highly specific formatting needs. If you’re someone who relishes the ability to fine-tune every aspect of your code’s appearance, then Uncrustify is worth a closer look.</p>
<p>Uncrustify supports an extensive set of formatting options, allowing developers to customize everything from indentation levels and brace styles to the alignment of comments and code constructs. All these options can be set in a configuration file that can then be shared across a development team to ensure consistent formatting.</p>
<p>Uncrustify is cross-platform compatible and can be easily used in development environments on Windows, macOS, and Linux. It is not tied to any specific development environment and offers a variety of integration paths. It can be set up as a pre-commit hook in your version control system, integrated into popular IDEs through plugins, or even included as a step in your CI pipeline. Because of its command-line nature, integrating Uncrustify into various tools and workflows is typically straightforward.</p>
<p>Uncrustify has an active community and its documentation, although sometimes considered dense, is comprehensive. This provides developers with a rich source of information for understanding the tool’s extensive capabilities. While the configuration can be challenging due to its sheer volume of options, numerous online resources and forums offer guidance, tips, and best practices for making the most of Uncrustify’s features.</p>
<p>The most notable limitation of Uncrustify is its complexity. The tool’s strength – its myriad customization options – can also be a weakness, especially for smaller projects or teams that don’t require such a high level of configurability. Additionally, the steep learning curve could be a barrier for teams looking for a quick solution to implement consistent code formatting.</p>
<p>In summary, Uncrustify <a id="_idIndexMarker417"/>offers an unmatched level of customization for those looking to fine-tune<a id="_idIndexMarker418"/> their C++ code formatting to the nth degree. Its wide array of features, coupled with extensive documentation and an active community, makes it a robust choice for teams seeking to enforce very specific coding standards. If you’re up for the challenge of mastering its many options, Uncrustify can serve as an invaluable tool for maintaining a clean and consistent code base. For more detailed information, please refer to the official <a id="_idIndexMarker419"/>GitHub page: <a href="https://github.com/uncrustify/uncrustify">https://github.com/uncrustify/uncrustify</a>.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>Editor plugins</h2>
<p>In an age where development <a id="_idIndexMarker420"/>teams are more diverse <a id="_idIndexMarker421"/>than ever, relying on a single IDE for code formatting can be problematic. Not only does it force developers to adapt to a specific work environment – potentially hindering their performance – but it also creates challenges in maintaining a consistent code style across different IDEs. Furthermore, such reliance poses complications for integrating code formatting into CI/CD pipelines. This is where editor plugins come into play as a more flexible and universal solution.</p>
<p>One of the key advantages of editor plugins is their wide availability across multiple text editors and IDEs. Whether your team prefers Visual Studio Code, Sublime Text, Vim, or Emacs, chances are there’s a plugin available that integrates with your chosen code formatting tool. This means every team member can work in the development environment they are most comfortable with, without compromising on code consistency.</p>
<p>ditor plugins often act as wrappers around standalone formatting tools such as Clang-Format, Astyle, and Uncrustify. This facilitates an easy transition, especially if your team is already using one of these tools. The configuration files for these tools can be shared, ensuring that the same formatting rules are applied irrespective of the editor being used.</p>
<p>Since many editor plugins leverage standalone command-line tools for code formatting, they naturally fit well into CI/CD pipelines. This eliminates the need to rely on IDE-specific tools, which may not be easily adaptable to CI/CD systems. With a standalone tool, the same formatting checks can be performed both locally by developers and automatically within the CI/CD pipeline, ensuring consistency across the board.</p>
<p>While editor plugins offer a versatile approach to code formatting, they do come with their own set of limitations. First, not all editors may support the full range of available formatting tools, although most popular editors have a wide range of plugins. Second, while installing and configuring plugins is generally straightforward, it does require an initial setup effort from each developer on the team.</p>
<p>Editor plugins<a id="_idIndexMarker422"/> provide an accessible and <a id="_idIndexMarker423"/>universal solution for implementing code formatting across diverse development environments. Their flexibility allows team members to choose their preferred editors without sacrificing code consistency, and their compatibility with standalone formatting tools makes them an excellent fit for inclusion in CI/CD pipelines. For teams that prioritize both developer autonomy and code consistency, editor plugins offer a balanced and effective approach.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Clang-Format</h2>
<p>When it comes to discussing <a id="_idIndexMarker424"/>code formatting tools that have gained significant traction in the<a id="_idIndexMarker425"/> C++ community, Clang-Format undoubtedly takes a front seat. Often considered the Swiss Army knife of code formatting, this tool combines robustness with a wealth of customization options. As this chapter’s favorite, we will delve deeper into its intricacies, exploring its extensive features and configurations in subsequent sections.</p>
<p>At its core, Clang-Format is designed to automatically reformat code so that it complies with a set of specified rules. These rules can range from handling whitespace and indentation to more complex aspects such as code block alignment and comment reformatting. Configuration is usually done via a <code>.clang-format</code> file, where developers can define their style preferences in a structured manner.</p>
<p>Clang-Format offers excellent cross-platform support, functioning seamlessly on Windows, macOS, and Linux. This ensures that irrespective of the development environment, your team can benefit from consistent code formatting.</p>
<p>Clang-Format shines due to its ease of integration. It can be invoked directly from the command line, included in scripts, or used via plugins in virtually any major text editor or IDE. This flexibility ensures that each developer can integrate it into their workflow, regardless of their choice of editor.</p>
<p>The command-line nature of Clang-Format also allows it to easily fit into CI/CD pipelines. With configuration files that can be stored and version-controlled alongside your code base, it ensures that the CI/CD system applies the same formatting rules as any developer would locally.</p>
<p>With strong backing from a broad community of developers and extensive documentation, Clang-Format has a wealth of resources available for new and experienced users alike. This community support becomes particularly beneficial when you’re looking to resolve issues or customize complex formatting rules.</p>
<p>Given its capabilities and <a id="_idIndexMarker426"/>my personal preference for this tool, the latter sections of this <a id="_idIndexMarker427"/>chapter will dive deeper into the world of Clang-Format. From setting up your first <code>.clang-format</code> file to exploring some of its more advanced features, we’ll cover how to make the most of what this powerful tool has to offer.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor166"/>Clang-Format configuration – a deep dive into customizing your formatting rules</h1>
<p>When it comes to <a id="_idIndexMarker428"/>configuring Clang-Format, the possibilities are almost endless, allowing you to tweak even the most minute details of your code’s appearance. However, for those who are new to this tool or those who wish to quickly adopt a widely accepted set of rules, Clang-Format allows you to derive configurations from existing presets. These presets serve as solid foundations upon which you can build a tailored formatting style that suits your project’s specific needs.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Leveraging existing presets</h2>
<p>Clang-Format<a id="_idIndexMarker429"/> offers several built-in presets that adhere to popular coding standards. These include the following:</p>
<ul>
<li><code>LLVM</code>: Adheres to the LLVM coding standards</li>
<li><code>Google</code>: Follows Google’s C++ style guide</li>
<li><code>Chromium</code>: Based on Chromium’s style guide, a variant of Google’s style guide</li>
<li><code>Mozilla</code>: Follows the Mozilla coding standards</li>
<li><code>WebKit</code>: Adheres to the WebKit coding standards</li>
</ul>
<p>To use one of these presets, simply set the <code>BasedOnStyle</code> option in your <code>.clang-format</code> configuration file, like so:</p>
<pre class="source-code">
BasedOnStyle: Google</pre>
<p>This tells Clang-Format to apply the Google C++ style guide as a base and then apply any additional customizations you specify.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Extending and overriding presets</h2>
<p>After choosing a <a id="_idIndexMarker430"/>preset that aligns closest with your team’s <a id="_idIndexMarker431"/>coding philosophy, you can start customizing specific rules. The <code>.clang-format</code> file allows you to override or extend the preset’s rules by listing them under the <code>BasedOnStyle</code> option. For example, an extended <code>.clang-format</code> example can demonstrate how to fine-tune various aspects of code formatting. The following is a sample configuration file that starts with Google’s style as a base and then customizes several specific aspects, such as indentation width, brace wrapping, and the alignment of consecutive assignments:</p>
<pre class="source-code">
---
BasedOnStyle: Google
# Indentation
IndentWidth: 4
TabWidth: 4
UseTab: Never
# Braces
BreakBeforeBraces: Custom
BraceWrapping:
  AfterClass: true
  AfterControlStatement: false
  AfterEnum: true
  AfterFunction: true
  AfterNamespace: true
  AfterStruct: true
  AfterUnion: true
  BeforeCatch: false
  BeforeElse: false
# Alignment
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlignOperands: true
AlignTrailingComments: true
# Spaces and empty lines
SpaceBeforeParens: ControlStatements
SpaceInEmptyParentheses: false
SpacesInCStyleCastParentheses: false
SpacesInContainerLiterals: true
SpacesInSquareBrackets: false
MaxEmptyLinesToKeep: 2
# Column limit
ColumnLimit: 80</pre>
<p>Let’s take<a id="_idIndexMarker432"/> a closer look at the options we <a id="_idIndexMarker433"/>chose here:</p>
<ol>
<li><code>IndentWidth</code> and <code>TabWidth</code>: These set the number of spaces for indentation and tabs, respectively. Here, <code>UseTab: Never</code> specifies not to use tabs for indentation.</li>
<li><code>BreakBeforeBraces</code> and <code>BraceWrapping</code>: These options customize when to break before opening braces in various situations such as classes, functions, and namespaces.</li>
<li><code>AlignAfterOpenBracket</code>, <code>AlignConsecutiveAssignments</code>, and so on: These control how various code elements, such as open brackets and consecutive assignments, are aligned.</li>
<li><code>SpaceBeforeParens</code>, <code>SpaceInEmptyParentheses</code>, and so on: These manage spaces in different scenarios, such as before parentheses in control statements or within empty parentheses.</li>
<li><code>MaxEmptyLinesToKeep</code>: This option limits the maximum number of consecutive empty lines to keep.</li>
<li><code>ColumnLimit</code>: This option sets a column limit per line to ensure the code doesn’t exceed the specified limit, enhancing readability.</li>
</ol>
<p>The <code>.clang-format</code> file<a id="_idIndexMarker434"/> should be placed in the root <a id="_idIndexMarker435"/>directory of your project and committed to your version control system so that every team member and your CI/CD pipeline can use the same configuration for consistent code formatting.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>Ignoring specific lines with Clang-Format</h2>
<p>While Clang-Format is <a id="_idIndexMarker436"/>an excellent tool for maintaining a consistent coding style across a project, there might be occasions when you’d prefer to keep certain lines or blocks of code untouched. Thankfully, Clang-Format provides the functionality to exclude specific lines or code blocks from formatting. This can be particularly useful for lines where the original formatting is essential for readability or lines that contain generated code that should not be altered.</p>
<p>To ignore a particular line or block of code, you can use special comment markers. Place <code>// clang-format off</code> before the line or block of code that you want to ignore, and then use <code>// clang-format on</code> after the line or block to resume normal formatting. Here’s an example:</p>
<pre class="source-code">
int main() {
    // clang-format off
    int  variableNameNotFormatted=42;
    // clang-format on
    int properlyFormattedVariable = 43;
}</pre>
<p>In this example, Clang-Format will not touch <code>int  variableNameNotFormatted=42;</code>, but will apply the specified formatting rules to <code>int properlyFormattedVariable = </code><code>43;</code>.</p>
<p>This feature offers a fine-grained level of control over the formatting process, allowing you to combine the benefits of automated formatting with the nuances that may be required for specific <a id="_idIndexMarker437"/>coding situations. Feel free to include this in your chapter to provide a complete view of what Clang-Format offers for code style management.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Endless options for configuration</h2>
<p>Since Clang-Format is based on the<a id="_idIndexMarker438"/> Clang compiler’s code parser, it can provide the most precise analysis of source code and, as a result, the most endless configuration options. The complete list of possible settings can be found on the official page: <a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">https://clang.llvm.org/docs/ClangFormatStyleOptions.html</a>.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Version control and sharing</h2>
<p>It’s generally a good<a id="_idIndexMarker439"/> practice to include your <code>.clang-format</code> file in your project’s version control system. This ensures that every member of your team, as well as your CI/CD system, uses the same set of formatting rules, leading to a more consistent and maintainable code base.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Integrating Clang-Format into the build system</h1>
<p>In today’s software<a id="_idIndexMarker440"/> development landscape, CMake stands <a id="_idIndexMarker441"/>as a de facto industry standard for build systems. It offers a powerful and flexible way to manage builds across different platforms and compilers. Integrating Clang-Format – a tool for automatically formatting C++ code – into your CMake build process can help ensure consistent code formatting across your project. In this section, we’ll delve into how this can be achieved effectively.</p>
<p>First, you must start by identifying the Clang-Format executable on your system using CMake’s <code>find_program()</code> function:</p>
<pre class="source-code">
# Find clang-format
find_program(CLANG_FORMAT_EXECUTABLE NAMES clang-format)</pre>
<p>Next, you must gather all the source files you wish to format. The <code>file(GLOB_RECURSE ...)</code> function is useful for this purpose:</p>
<pre class="source-code">
# Gather all source files from the root directory recursively
file(GLOB_RECURSE ALL_SOURCE_FILES
    *.cpp
    *.cc
    *.c++
    *.c
    *.C
    *.h
    *.hpp
    *.hxx
)</pre>
<p>However, there’s a slight hiccup: this approach also includes files from your build directory, which you likely don’t want to format. This also usually applies to third-party directories. Fortunately, you can filter these out using CMake’s <code>list(FILTER ...)</code> function:</p>
<pre class="source-code">
# Exclude files in the build directory
list(FILTER ALL_SOURCE_FILES EXCLUDE REGEX “^${CMAKE_BINARY_DIR}.*”)</pre>
<p>Finally, you must <a id="_idIndexMarker442"/>create a custom CMake target that, when<a id="_idIndexMarker443"/> built, runs Clang-Format on your gathered source files:</p>
<pre class="source-code">
# Create custom target to run clang-format
if(CLANG_FORMAT_EXECUTABLE)
    add_custom_target(
        clang-format
        COMMAND ${CLANG_FORMAT_EXECUTABLE} -i -style=file ${ALL_SOURCE_FILES}
        COMMENT “Running clang-format”
    )
else()
    message(“clang-format not found! Target ‘clang-format’ will not be available.”)
endif()</pre>
<p>By doing this, you can create a custom target named <code>clang-format</code> that developers can run to automatically format all the source files in the project while ignoring any files in the build directory. Executing this target can be done with a simple <code>make clang-format</code> or <code>cmake --build . --target clang-format</code> command, ensuring that consistent formatting is maintained with ease.</p>
<p>Including this<a id="_idIndexMarker444"/> Clang-Format and CMake integration<a id="_idIndexMarker445"/> in your build process not only helps in maintaining a consistent coding style but also facilitates easier code reviews and collaborative development. Feel free to incorporate these insights and code snippets into your project or any technical documentation you’re working on.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Clang-Format report examples</h1>
<p>Let’s prepare a <a id="_idIndexMarker446"/>simple example to demonstrate the Clang-Format tool in action. We will create a basic C++ source file named <code>main.cpp</code> with some formatting issues. Then, we will run Clang-Format on this file to automatically correct the formatting and generate a report of the changes made:</p>
<pre class="source-code">
#include &lt;iostream&gt;
class Sender {
public:
    void send(const std::string&amp; message) {
        std::cout &lt;&lt; “Sending: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Receiver {
public:
    void receive(const std::string&amp; message) {
        std::cout &lt;&lt; “Receiving: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Mediator {
public:
    Mediator(Sender sender, Receiver receiver)
        : sender_{std::move(sender)}, receiver_{std::move(receiver)} {}
    void send(const std::string&amp; message) {
        sender_.send(message);
    }
    void receive(const std::string&amp; message) {
        receiver_.receive(message);
    }
private:
    Sender sender_;
    Receiver receiver_;
};</pre>
<p>We will try to analyze it <a id="_idIndexMarker447"/>with the Clang-Format tool and a ruleset we defined earlier in <code>.clang-format</code>:</p>
<pre class="source-code">
make check-clang-format
[100%] Checking code format with clang-format
/home/user/clang-format/clang_format.cpp:4:2: error: code should be clang-formatted [-Wclang-format-violations]
{
 ^
/home/user/clang-format/clang_format.cpp:6:42: error: code should be clang-formatted [-Wclang-format-violations]
    void send(const std::string&amp; message){
                                         ^
/home/user/clang-format/clang_format.cpp:7:18: error: code should be clang-formatted [-Wclang-format-violations]
        std::cout&lt;&lt; “Sending: “ &lt;&lt;message&lt;&lt; std::endl;
                 ^
/home/user/clang-format/clang_format.cpp:7:35: error: code should be clang-formatted [-Wclang-format-violations]
        std::cout&lt;&lt; “Sending: “ &lt;&lt;message&lt;&lt; std::endl;
                                  ^
/home/user/clang-format/clang_format.cpp:7:42: error: code should be clang-formatted [-Wclang-format-violations]
        std::cout&lt;&lt; “Sending: “ &lt;&lt;message&lt;&lt; std::endl;
                                         ^
/home/user/clang-format/clang_format.cpp:11:6: error: code should be clang-formatted [-Wclang-format-violations]
class
     ^
/home/user/clang-format/clang_format.cpp:12:9: error: code should be clang-formatted [-Wclang-format-violations]
Receiver {
        ^
/home/user/clang-format/clang_format.cpp:12:11: error: code should be clang-formatted [-Wclang-format-violations]
Receiver {
          ^
/home/user/clang-format/clang_format.cpp:14:36: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp;message){
                                   ^
/home/user/clang-format/clang_format.cpp:14:44: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp;message){
                                           ^
/home/user/clang-format/clang_format.cpp:14:45: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp;message){
                                            ^
/home/user/clang-format/clang_format.cpp:16:6: error: code should be clang-formatted [-Wclang-format-violations]
    }};
     ^
/home/user/clang-format/clang_format.cpp:18:15: error: code should be clang-formatted [-Wclang-format-violations]
class Mediator{
              ^
/home/user/clang-format/clang_format.cpp:18:16: error: code should be clang-formatted [-Wclang-format-violations]
class Mediator{
               ^
/home/user/clang-format/clang_format.cpp:20:28: error: code should be clang-formatted [-Wclang-format-violations]
    Mediator(Sender sender,Receiver receiver)
                           ^
/home/user/clang-format/clang_format.cpp:21:69: error: code should be clang-formatted [-Wclang-format-violations]
        : sender_{std::move(sender)}, receiver_{std::move(receiver)} {}
                                                                    ^
/home/user/clang-format/clang_format.cpp:21:71: error: code should be clang-formatted [-Wclang-format-violations]
        : sender_{std::move(sender)}, receiver_{std::move(receiver)} {}
                                                                      ^
/home/user/clang-format/clang_format.cpp:22:44: error: code should be clang-formatted [-Wclang-format-violations]
    void send(const std::string&amp; message) {sender_.send(message);}
                                           ^
/home/user/clang-format/clang_format.cpp:22:66: error: code should be clang-formatted [-Wclang-format-violations]
    void send(const std::string&amp; message) {sender_.send(message);}
                                                                 ^
/home/user/clang-format/clang_format.cpp:24:47: error: code should be clang-formatted [-Wclang-format-violations]
    void receive(const std::string&amp; message) {
                                              ^
/home/user/clang-format/clang_format.cpp:25:36: error: code should be clang-formatted [-Wclang-format-violations]
        receiver_.receive(message);
                                   ^
/home/user/clang-format/clang_format.cpp:26:6: error: code should be clang-formatted [-Wclang-format-violations]
    }
     ^
/home/user/clang-format/clang_format.cpp:28:11: error: code should be clang-formatted [-Wclang-format-violations]
    Sender sender_;
          ^
make[3]: *** [CMakeFiles/check-clang-format.dir/build.make:71: CMakeFiles/check-clang-format] Error 1
make[2]: *** [CMakeFiles/Makefile2:139: CMakeFiles/check-clang-format.dir/all] Error 2
make[1]: *** [CMakeFiles/Makefile2:146: CMakeFiles/check-clang-format.dir/rule] Error 2
make: *** [Makefile:150: check-clang-format] Error 2</pre>
<p>As you can see, the<a id="_idIndexMarker448"/> errors are not very descriptive. However, most of the time, developers can understand what’s wrong with the code. The tool is not only able to detect the issues but also fix them. Let’s run the tool to fix the formatting issues <code>make clang-format</code> and see the results:</p>
<pre class="source-code">
#include &lt;iostream&gt;
class Sender
{
   public:
    void send(const std::string&amp; message)
    {
        std::cout &lt;&lt; “Sending: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Receiver
{
   public:
    void receive(const std::string&amp; message)
    {
        std::cout &lt;&lt; “Receiving: “ &lt;&lt; message &lt;&lt; std::endl;
    }
};
class Mediator
{
   public:
    Mediator(Sender sender, Receiver receiver)
        : sender_{std::move(sender)}, receiver_{std::move(receiver)}
    {
    }
    void send(const std::string&amp; message) { sender_.send(message); }
    void receive(const std::string&amp; message) { receiver_.receive(message); }
   private:
    Sender   sender_;
    Receiver receiver_;
};</pre>
<p>The code is now properly <a id="_idIndexMarker449"/>formatted and can be used in the project. This example can be included in your chapter to demonstrate the practical application of Clang-Format in a real-world scenario. In the future, developers may add more formatting rules to the <code>.clang-format</code> file and re-format the whole project by running the <code>make </code><code>clang-format</code> command.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Extending for code format checks for CI</h1>
<p>When setting up <a id="_idIndexMarker450"/>CI pipelines, it’s often beneficial to only check whether the code complies with the established formatting rules rather than automatically modifying the source files. This ensures that any code that doesn’t meet the style guidelines is flagged, prompting the developer to fix it manually. Clang-Format supports this use case with the <code>--dry-run</code> and <code>--Werror</code> options, which, when combined, cause the tool to exit with a non-zero status code if any file is reformatted.</p>
<p>You can extend the existing CMake setup so that it includes a new custom target that only checks the code format. Here’s how to do this:</p>
<pre class="source-code">
# Create custom target to check clang-format
if(CLANG_FORMAT_EXECUTABLE)
    add_custom_target(
        check-clang-format
        COMMAND ${CLANG_FORMAT_EXECUTABLE} -style=file -Werror --dry-run ${ALL_SOURCE_FILES}
        COMMENT “Checking code format with clang-format”
    )
else()
    message(“clang-format not found! Target ‘check-clang-format’ will not be available.”)
endif()</pre>
<p>In this extended setup, a new custom target named <code>check-clang-format</code> has been added. The <code>--dry-run</code> option ensures that no files are modified, while <code>-Werror</code> causes Clang-Format to exit with an error code if any formatting discrepancies are found. This target can be run with <code>make check-clang-format</code> or <code>cmake --build . --</code><code>target check-clang-format</code>.</p>
<p>Now, in your CI <a id="_idIndexMarker451"/>pipeline script, you can invoke this custom target to enforce code-style checks. If the code is not formatted according to the guidelines specified, the build will fail, alerting the team that there is a formatting issue that needs to be resolved.</p>
<p>For example, in our <code>.clang-format</code> file, we set the indent width to four spaces, but the <code>main.cpp</code> file only uses two:</p>
<pre class="source-code">
int main() {
  return 0;
}</pre>
<p>Once we run the checker, it shows the problematic code without changing it:</p>
<pre class="source-code">
make check-clang-format
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/clang-format-tidy/build
[100%] Checking code format with clang-format
/home/user/clang-format-tidy/main.cpp:2:13: error: code should be clang-formatted [-Wclang-format-violations]
int main() {
            ^
make[3]: *** [CMakeFiles/check-clang-format.dir/build.make:71: CMakeFiles/check-clang-format] Error 1
make[2]: *** [CMakeFiles/Makefile2:137: CMakeFiles/check-clang-format.dir/all] Error 2
make[1]: *** [CMakeFiles/Makefile2:144: CMakeFiles/check-clang-format.dir/rule] Error 2
make: *** [Makefile:150: check-clang-format] Error 2</pre>
<p>By adding this <a id="_idIndexMarker452"/>custom target to your CMake setup, you add an additional layer of quality assurance to your project. It ensures that no code that violates the established formatting guidelines can make its way into the code base unnoticed. This is particularly helpful in collaborative environments where multiple developers might be contributing to the same project. Feel free to include this advanced example and its rationale in your technical content.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Clang-Format support across various editors</h1>
<p>Clang-Format <a id="_idIndexMarker453"/>enjoys extensive support across a multitude of text editors and IDEs, streamlining the code-formatting process irrespective of your development environment. One of the significant advantages of integrating Clang-Format directly into your IDE or text editor is the ability to invoke it effortlessly, right from your development environment. Even better, many editors support automatically triggering Clang-Format upon saving a file. This feature can be a massive boon to productivity and code quality as it ensures that every saved version of a source file adheres to the project’s coding standards without requiring manual intervention.</p>
<p>In Visual Studio Code, there are a few plugins that provide integration with Clang-Format:</p>
<ul>
<li><strong class="bold">C/C+</strong>, by <a id="_idIndexMarker454"/>Microsoft: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools</a></li>
<li><strong class="bold">Clang-Format</strong>, by <a id="_idIndexMarker455"/>Xaver Hellauer: <a href="https://marketplace.visualstudio.com/items?itemName=xaver.clang-format">https://marketplace.visualstudio.com/items?itemName=xaver.clang-format</a></li>
<li><strong class="bold">ClangD</strong>, by the <a id="_idIndexMarker456"/>LLVM (the creators of Clang, Clang-Format, and other tools): <a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd</a></li>
</ul>
<p>Vim and NeoVim users<a id="_idIndexMarker457"/> can leverage plugins such as <code>vim-clang-format</code> to integrate Clang-Format, and even map it to specific keyboard shortcuts for quick formatting. Also, it can usually be enabled via an LSP provider plugin or feature.</p>
<p>For developers using the full-fledged version of Visual Studio, Clang-Format integration is built-in; you can easily specify a <code>.clang-format</code> configuration file and the IDE will use it when you format your code.</p>
<p>Similarly, JetBrains’ CLion supports Clang-Format out of the box, allowing users to import <code>.clang-format</code> configuration files directly into the project settings. This broad range of editor support makes it effortless to maintain consistent code formatting across diverse development teams as each team member can use their preferred tools without compromising on code quality.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Checking name styling</h1>
<p>After meticulously<a id="_idIndexMarker458"/> formatting our code to ensure that spaces, asterisks, alignments, and brace positions are all in place, there remains one final frontier to unify – naming style. Ensuring consistency in naming conventions across classes, variables, functions, and other identifiers can often be a painstaking process, usually relegated to vigilant peer reviews. However, there’s an automated way to achieve this, thereby reducing manual effort and error.</p>
<p>Clang-Tidy<a id="_idIndexMarker459"/> comes to the rescue for this purpose. While we’ll dive deeper into the various capabilities of Clang-Tidy in the next chapter, it’s worth noting that it’s more than just a linter. It offers a plethora of checks for not just syntactic sugar but also semantic analysis and readability. One of its most useful features in the context of naming conventions is the identifier naming check. By configuring this check, you can enforce project-wide rules for naming various entities.</p>
<p>Let’s say you want <a id="_idIndexMarker460"/>your class, struct, and enum names to be <code>CamelCase</code>, your namespaces, variables, functions, and methods to be <code>lower_case</code>, and your constants to be <code>UPPER_CASE</code>. Additionally, you prefer that private and protected variables have a trailing underscore, <code>_</code>, while public ones do not. All of these requirements can be configured in a simple <code>.clang-tidy</code> file, which Clang-Tidy will read to enforce your naming rules:</p>
<pre class="source-code">
---
Checks:          ‘readability-identifier-naming’
FormatStyle:     file
CheckOptions:
  - key: readability-identifier-naming.NamespaceCase
    value: ‘lower_case’
  - key: readability-identifier-naming.InlineNamespaceCase
    value: ‘lower_case’
  - key: readability-identifier-naming.EnumCase
    value: ‘CamelCase’
  - key: readability-identifier-naming.EnumConstantCase
    value: ‘UPPER_CASE’
  - key: readability-identifier-naming.ClassCase
    value: ‘CamelCase’
  - key: readability-identifier-naming.StructCase
    value: ‘CamelCase’
  - key: readability-identifier-naming.ClassMethodCase
    value: ‘lower_case’
  - key: readability-identifier-naming.FunctionCase
    value: ‘lower_case’
  - key: readability-identifier-naming.VariableCase
    value: ‘lower_case’
  - key: readability-identifier-naming.GlobalVariableCase
    value: ‘lower_case’
  - key: readability-identifier-naming.StaticConstantCase
    value: ‘UPPER_CASE’
  - key: readability-identifier-naming.PublicMemberCase
    value: ‘lower_case’
  - key: readability-identifier-naming.ProtectedMemberCase
    value: ‘lower_case’
  - key: readability-identifier-naming.PrivateMemberCase
    value: ‘lower_case’
  - key: readability-identifier-naming.PrivateMemberSuffix
    value: ‘_’
  - key: readability-identifier-naming.ClassMemberCase
    value: ‘lower_case’</pre>
<p>These rules <a id="_idIndexMarker461"/>can be endlessly extended with the highest resolution. The full documentation for existing checks is available at <a href="https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html">https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html</a>.</p>
<p>By incorporating Clang-Tidy into your build process and CI pipeline, you can automate the enforcement of these naming conventions, making the code base easier to read, maintain, and collaborate on. We will delve deeper into configuring and using Clang-Tidy for various other checks in the upcoming chapter.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/>Integrating Clang-Tidy into the build system</h1>
<p>We can adapt our existing <a id="_idIndexMarker462"/>CMake setup so that it includes Clang-Tidy <a id="_idIndexMarker463"/>checks, similar to what we did with Clang-Format. Here’s a sample CMake script that sets up custom targets for running Clang-Tidy on a C++ project:</p>
<pre class="source-code">
# Generate compilation database in the build directory
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# Find clang-tidy
find_program(CLANG_TIDY_EXECUTABLE NAMES clang-tidy)
# Gather all source files from the root directory recursively
file(GLOB_RECURSE ALL_SOURCE_FILES
    *.cpp
    *.cc
    *.c++
    *.c
    *.C
    *.h
    *.hpp
    *.hxx
)
# Exclude files in the build directory
list(FILTER ALL_SOURCE_FILES EXCLUDE REGEX “^${CMAKE_BINARY_DIR}.*”)
# Create custom target to run clang-tidy
if(CLANG_TIDY_EXECUTABLE)
    add_custom_target(
        clang-tidy
        COMMAND ${CLANG_TIDY_EXECUTABLE} -p=${CMAKE_BINARY_DIR} ${ALL_SOURCE_FILES}
        COMMENT “Running clang-tidy”
    )
else()
    message(“clang-tidy not found! Target ‘clang-tidy’ will not be available.”)
endif()
# Create custom target to check clang-tidy
if(CLANG_TIDY_EXECUTABLE)
    add_custom_target(
        check-clang-tidy
        COMMAND ${CLANG_TIDY_EXECUTABLE} -p=${CMAKE_BINARY_DIR} --warnings-as-errors=* ${ALL_SOURCE_FILES}
        COMMENT “Checking code quality with clang-tidy”
    )
else()
    message(“clang-tidy not found! Target ‘check-clang-tidy’ will not be available.”)
endif()</pre>
<p>In this script, we <a id="_idIndexMarker464"/>locate the <code>clang-tidy</code> executable using <code>find_program</code>. Similar to the Clang-Format setup, we then gather all the source<a id="_idIndexMarker465"/> files from the root directory recursively, making sure we exclude those in the build directory.</p>
<p>Two custom targets are added here:</p>
<ul>
<li><code>clang-tidy</code>: This target runs Clang-Tidy on all gathered source files. The <code>-p=${CMAKE_BINARY_DIR}</code> flag specifies the build directory containing the <code>compile_commands.json</code> file, which Clang-Tidy uses for its checks. This JSON file is generated by CMake and contains information about how each source file in the project is compiled. It includes details such as the compiler options, include directories, defines, and so on. Clang-Tidy uses this information to understand the build context of each source file, allowing it to perform more accurate and meaningful checks.</li>
<li><code>check-clang-tidy</code>: This target performs the same operation but with the <code>--warnings-as-errors=*</code> flag. This will treat all warnings as errors, which is especially useful for CI/CD pipelines to ensure code quality.</li>
</ul>
<p>As in your previous setup, running these custom targets can be done via <code>make clang-tidy</code> or <code>make check-clang-tidy</code> or their equivalent <code>cmake --build . --target clang-tidy</code> and <code>cmake --build . --</code><code>target check-clang-tidy</code>.</p>
<p>By integrating Clang-Tidy into your CMake build process, you’ll be providing another layer of automated code quality checks, much like you did with Clang-Format. Feel free to include this in your chapter for a comprehensive look at automated code quality assurance.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Checking source code name styling with Clang-Tidy</h1>
<p>Now that we’ve <a id="_idIndexMarker466"/>successfully configured Clang-Tidy’s rules <a id="_idIndexMarker467"/>and integrated the tool into our CMake build system, it’s time for a real-world test. For this purpose, we’ll use a snippet of C++ code that deliberately violates the naming conventions we’ve established:</p>
<pre class="source-code">
#include &lt;string&gt;
#include &lt;vector&gt;
namespace Filesystem { // CamelCase instead of lower_case
enum class Permissions : uint8_t { READ, WRITE, execute };
struct User {
    std::string name_; // redundant suffix _ for public member
    int Id = 0;        // CamelCase instead of lower_case
    Permissions permissions;
};
class file { // lower_case instead of CamelCase
public:
    file(int id, const std::string &amp;file_name,
         const std::vector&lt;User&gt; access_list)
        : id{id}, FileName_{file_name}, access_list_{access_list} {}
    int GetId() const // CamelCase instead of lower_case
    {
        return id;
    }
    auto &amp;getName() const // camelBack instead of lower_case
    {
        return FileName_;
    }
    const std::vector&lt;User&gt; &amp;access_list() const { return access_list_; }
private:
    int id;                // missing suffix _
    std::string FileName_; // CamelCase instead of lower_case
    std::vector&lt;User&gt; access_list_;
};
} // namespace Filesystem
int main() {
    auto user        = Filesystem::User{};
    user.name_       = “user”;
    user.permissions = Filesystem::Permissions::execute;
    auto file = Filesystem::file{0, “~/home/user/file”, {user}};
    return 0;
}</pre>
<p>When we<a id="_idIndexMarker468"/> run <code>make clang-tidy</code>, Clang-Tidy <a id="_idIndexMarker469"/>will spring into action, scanning the offending code and flagging any naming issues directly in the terminal output. I’ve only provided a partial output here to save space:</p>
<pre class="source-code">
make check-clang-tidy
[100%] Checking code quality with clang-tidy
9 warnings generated.
/home/user/clang-format-tidy/main.cpp:4:11: error: invalid case style for namespace ‘Filesystem’ [readability-identifier-naming,-warnings-as-errors]
    4 | namespace Filesystem { // CamelCase instead of lower_case
      |           ^~~~~~~~~~
      |           filesystem
/home/user/clang-format-tidy/main.cpp:6:49: error: invalid case style for enum constant ‘execute’ [readability-identifier-naming,-warnings-as-errors]
    6 | enum class Permissions : uint8_t { READ, WRITE, execute };
      |                                                 ^~~~~~~
      |                                                 EXECUTE
/home/user/clang-format-tidy/main.cpp:9:17: error: invalid case style for public member ‘name_’ [readability-identifier-naming,-warnings-as-errors]
    9 |     std::string name_; // redundant suffix _ for public member
      |                 ^~~~~
      |                 name
/home/user/clang-format-tidy/main.cpp:10:9: error: invalid case style for public member ‘Id’ [readability-identifier-naming,-warnings-as-errors]
   10 |     int Id = 0;        // CamelCase instead of lower_case
      |         ^~
      |         id
/home/user/clang-format-tidy/main.cpp:14:7: error: invalid case style for class ‘file’ [readability-identifier-naming,-warnings-as-errors]
   14 | class file { // lower_case instead of CamelCase
      |       ^~~~
      |       File
   15 | public:
   16 |     file(int id, const std::string &amp;file_name,
      |     ~~~~
      |     File
/home/user/clang-format-tidy/main.cpp:20:9: error: invalid case style for function ‘GetId’ [readability-identifier-naming,-warnings-as-errors]
   20 |     int GetId() const // CamelCase instead of lower_case
      |         ^~~~~
      |         get_id
9 warnings treated as errors</pre>
<p>This exercise <a id="_idIndexMarker470"/>demonstrates the tangible benefits of <a id="_idIndexMarker471"/>integrating Clang-Tidy into the build process. It not only identifies deviations from established naming conventions in the code but also provides an opportunity for immediate rectification. It’s an invaluable step toward maintaining a code base that is not just functional but also consistently well-structured. It’s advisable to include the <code>make clang-tidy</code> command in your CI pipeline. By doing so, you can automatically validate the naming conventions and other code styling rules for every commit made to your repository. This will help ensure that any new contributions to the code base conform to the established guidelines. If a commit fails the Clang-Tidy checks, the CI pipeline can flag it for review, making it easier to maintain a consistent, high-quality code base. This added layer of automation eliminates the need for manual checks for these issues, thus streamlining the code review process and making your development workflow more efficient.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/>Fixing naming issues automatically</h1>
<p>The real <a id="_idIndexMarker472"/>power of Clang-Tidy lies in its ability to not just identify<a id="_idIndexMarker473"/> issues but also to rectify them automatically. Manual fixes can be time-consuming and error-prone, making automation incredibly valuable in a fast-paced development environment. Fortunately, Clang-Tidy excels in this area. Most of the fixes suggested by the tool can be applied automatically, saving you countless hours of manual labor and potential errors. To apply these automatic fixes, simply run <code>make clang-tidy</code> in your terminal. The tool will scan the code for violations, and where possible, it will automatically correct the code so that it aligns with your configured guidelines:</p>
<pre class="source-code">
#include &lt;string&gt;
#include &lt;vector&gt;
namespace filesystem { // CamelCase instead of lower_case
enum class Permissions : uint8_t { READ, WRITE, EXECUTE };
struct User {
    std::string name; // redundant suffix _ for public member
    int id = 0;       // CamelCase instead of lower_case
    Permissions permissions;
};
class File { // lower_case instead of CamelCase
public:
    File(int id, const std::string &amp;file_name,
         const std::vector&lt;User&gt; access_list)
        : id_{id}, file_name_{file_name}, access_list_{access_list} {}
    int get_id() const // CamelCase instead of lower_case
    {
        return id_;
    }
    auto &amp;get_name() const // camelBack instead of lower_case
    {
        return file_name_;
    }
    const std::vector&lt;User&gt; &amp;access_list() const { return access_list_; }
private:
    int id_;                // missing suffix _
    std::string file_name_; // CamelCase instead of lower_case
    std::vector&lt;User&gt; access_list_;
};
} // namespace filesystem
int main() {
    auto user        = filesystem::User{};
    user.name        = “user”;
    user.permissions = filesystem::Permissions::EXECUTE;
    auto file = filesystem::File{0, “~/home/user/file”, {user}};
    return 0;
}</pre>
<p>Note that not only were the classes, methods, and variables definitions updated but also references to them. This functionality makes Clang-Tidy not just a diagnostic tool but a valuable assistant in maintaining the overall quality of your code base.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Important caveats</h2>
<p>There are some important caveats<a id="_idIndexMarker474"/> to consider when using Clang-Tidy. Let’s take a look:</p>
<ul>
<li><strong class="bold">Single versus multiple instances</strong>: The CMake configuration we’ve discussed runs a single instance of Clang-Tidy to check and fix all the source files. While this may be sufficient for smaller projects, it can become a bottleneck for larger code bases with numerous checks. In such scenarios, it might be more efficient to divide the source code into logical groups and run multiple instances of Clang-Tidy in parallel. This strategy can significantly reduce the time it takes to scan the entire code base.</li>
<li><strong class="bold">Commit before fixing</strong>: While Clang-Tidy’s ability to automatically fix issues is invaluable, it’s advised to use this feature only on code that has been committed to your version control system. Some of the checks provided by Clang-Tidy can be unstable and, in rare instances, may even introduce bugs. Committing your code beforehand ensures that you have a stable point to revert to if things go awry.</li>
<li><code>User</code> struct was initialized using C++20 designated initializer lists, as shown in the following example:<pre class="source-code">
auto user = Filesystem::User{</pre><pre class="source-code">
    .name_ = “user”, .permissions = Filesystem::Permissions::execute};</pre><p class="list-inset">Clang-Tidy will fix the <code>name_</code> variable and the <code>execute</code> constant in their definition but will<a id="_idIndexMarker475"/> completely ignore the initializer, which will eventually lead to a compilation error.</p></li>
</ul>
<p>Being aware of these caveats allows you to employ Clang-Tidy more effectively and leverage its strengths while mitigating potential risks.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor181"/>Example project</h1>
<p>For those who wish to delve deeper into the details and get hands-on experience with the configuration and usage of Clang-Tidy and Clang-Format, an example project complete with the CMake setup and code snippets is available on GitHub (<a href="https://github.com/f-squirrel/clang-format-tidy">https://github.com/f-squirrel/clang-format-tidy</a>). This will allow you to better understand the nuances and practical applications of integrating these tools into your C++ projects. Feel free to clone the repository, experiment with the code, and even contribute to enhancing it further.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Clang-Tidy support across various editors</h1>
<p>The IDE and editor support<a id="_idIndexMarker476"/> for Clang-Tidy is broadly similar to that for Clang-Format, making it equally accessible and easy to integrate into your development workflow. The principal advantage of this integrated support is the immediate feedback loop it offers. As you code, Clang-Tidy warnings and errors will appear directly within your IDE, enabling you to spot potential issues without having to leave the development environment. This is immensely valuable for maintaining code quality in real time, rather than as a separate step.</p>
<p>Moreover, many IDEs also provide an interface to apply Clang-Tidy’s automatic fixes directly from within the editor, making it easier than ever to adhere to your coding standards. For example, the following screenshot of Visual Studio Code illustrates the inline warnings:</p>
<div><div><img alt="Figure 9.1 – Warnings" src="img/B19606_09_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Warnings</p>
<p>The following screenshot shows the fixes that can be applied to them:</p>
<div><div><img alt="Figure 9.2 – Applicable fixes" src="img/B19606_09_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Applicable fixes</p>
<p>This real-time, in-editor <a id="_idIndexMarker477"/>feedback mechanism can significantly boost your productivity and code quality, making Clang-Tidy not just a static code analysis tool but an integral part of your coding process.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Summary</h1>
<p>In this chapter, we navigated the essential landscape of automated code quality maintenance, focusing particularly on code formatting and naming conventions. We started by providing an overview of existing tools that can help enforce coding standards, then zeroed in on Clang-Format and Clang-Tidy as comprehensive solutions for these issues. We learned not only how to use these tools to automatically check and fix our code but also how to seamlessly integrate them into our build system, CI pipelines, and code editors.</p>
<p>By doing so, we’ve laid a strong foundation for ensuring that our code remains consistent and adheres to best practices, all with minimal manual intervention. This sets the stage perfectly for the next chapter, where we will dive deeper into the realm of static code analysis, further solidifying our commitment to high-quality, maintainable code.</p>
</div>
</body></html>