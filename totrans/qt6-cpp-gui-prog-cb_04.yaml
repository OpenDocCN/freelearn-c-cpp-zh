- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QPainter and 2D Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to render 2D graphics on screen with Qt.
    Internally, Qt uses a low-level class called `QPainter` to render its widgets
    on the main window. Qt allows us to access and use the `QPainter` class for drawing
    vector graphics, text, 2D images, and even 3D graphics.
  prefs: []
  type: TYPE_NORMAL
- en: You can make use of the `QPainter` class to create your own custom widgets or
    to create programs that rely heavily on rendering computer graphics such as video
    games, photo editors, and 3D modeling tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing basic shapes on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting shapes to **Scalable Vector Graphics** (**SVG**) files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate transformation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images on screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying image effects to graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic paint program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a 2D canvas in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**
    and **Qt Creator 12.0.2**. All the code used in this chapter can be downloaded
    from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing basic shapes on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to draw simple vector shapes (a line, a rectangle,
    a circle, and so on) and display text on the main window using the `QPainter`
    class. We will also learn how to change the drawing style of these vector shapes
    using the `QPen` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s follow the steps listed here to display basic shapes in our Qt window:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create a new **Qt Widgets** **Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `mainwindow.ui` and remove the `menuBar`, `mainToolBar`, and `statusBar`
    objects so that we get a clean, empty main window. Right-click on the bar widgets
    and select **Remove Menu Bar** from the pop-up menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Removing the menu bar from the main window](img/B20976_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Removing the menu bar from the main window
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open up the `mainwindow.h` file and add the following code to include
    the `QPainter` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, declare the `paintEvent()` event handler below the class destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: void MainWindow::paintEvent(QPaintEvent *event) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will add text to the screen using the `QPainter` class inside
    the `paintEvent()` event handler. We set the text font settings before drawing
    it on the screen at the position of `(``20, 30)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will draw a straight line that starts from `(50, 60)` and ends at
    `(``100, 100)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also easily draw a rectangle by calling the `drawRect()` function using
    a `QPainter` class. This time, however, we also apply a background pattern to
    the shape before drawing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, declare a `QPen` class, set its color to `red`, and set its drawing style
    to `Qt::DashDotLine`. Then, apply the `QPen` class to `QPainter` and draw an ellipse
    shape at `(80, 200)` with a horizontal radius of `50` and a vertical radius of
    `20`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use the `QPainterPath` class to define a shape before passing it
    over to the `QPainter` class for rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also draw any other shapes by using `QPainterPath`, such as an ellipse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`QPainter` can also be used to draw an image file onto the screen. In the following
    example, we load an image file called `tux.png` and draw it on the screen at the
    `(100,` `150)` position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final result should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines](img/B20976_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to draw something on screen using `QPainter`, all you need to do
    is tell it what type of graphics it should be drawing (as in text, a vector shape,
    an image, a polygon) with the desired position and size. The `QPen` class determines
    what the outline of the graphic should look like, such as its color, line width,
    line style (solid, dashed, or dotted), cap style, join style, and so on. On the
    other hand, `QBrush` sets the style of the background of the graphics, such as
    the background color, pattern (solid color, gradient, dense brush, and crossing
    diagonal lines), and pixmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options for the graphics should be set before calling a `draw` function
    (such as `drawLine()`, `drawRect()`, or `drawEllipse()`). If your graphics do
    not appear on the screen and you see warnings such as `QPainter::setPen: Painter
    not active` and `QPainter::setBrush: Painter not active` appearing on the application
    output window in Qt Creator, it means that the `QPainter` class is not currently
    active and your program will not trigger its paint event. To solve this problem,
    set the main window as the parent of the `QPainter` class. Usually, if you’re
    writing code in the `mainwindow.cpp` file, all you need to do is to put `this`
    in the brackets when initializing `QPainter`. For example, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`QImage` can load images from both the computer directories and from the program
    resources.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of `QPainter` as a robot with a pen and an empty canvas. You just have
    to tell the robot what type of shape it should be drawing and its location on
    the canvas, then the robot will do its job based on your description.
  prefs: []
  type: TYPE_NORMAL
- en: To make your life easier, the `QPainter` class also provides numerous functions,
    such as `drawArc()`, `drawEllipse()`, `drawLine()`, `drawRect()`, and `drawPie()`,
    which allow you to easily render a predefined shape. In Qt, all the widget classes
    (including the main window) have an event handler called `QWidget::paintEvent()`.
    This event handler will be triggered whenever the operating system thinks that
    the main window should re-draw its widgets. Many things can lead to that decision,
    such as the main window being scaled, a widget changing its state (that is, a
    button being pressed), or functions such as `repaint()` or `update()` being invoked
    manually in the code. Different operating systems may behave differently when
    it comes to deciding whether or not to trigger the update event on the same set
    of conditions. If you’re making a program that requires continuous and consistent
    graphical updates, call `repaint()` or `update()` manually with a timer.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting shapes to SVG files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SVG is an XML-based language for describing 2D vector graphics. Qt provides
    classes for saving vector shapes as SVG files. This feature can be used to create
    a simple vector graphics editor similar to Adobe Illustrator and Inkscape. In
    the next example, we will continue using the same project file from the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s learn how to create a simple program that displays SVG graphics on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s create a menu bar by right-clicking the main window widget
    on the hierarchy window and selecting the **Create Menu Bar** option from the
    pop-up menu. After that, add a **File** option to the menu bar and a **Save as
    SVG** action underneath it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Create a Save as SVG option on the menu bar](img/B20976_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Create a Save as SVG option on the menu bar
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you will see an item called `triggered()`, and click the **OK**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Creating a slot function for the triggered() signal](img/B20976_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Creating a slot function for the triggered() signal
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have clicked the `on_actionSave_as_SVG_triggered()` has been automatically
    added to your main window class. At the bottom of your `mainwindow.h` file, you
    will see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding function is called when you click on the `QSvgGenerator` at the
    top of our source file. This header is very important as it’s required for generating
    SVG files. Then, we also need to include another class header called `QFileDialog`,
    which will be used to open the save dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add the `svg` module to our project file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'public:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explicit MainWindow(QWidget *parent = 0);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ~MainWindow();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: virtual void paintEvent(QPaintEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mainwindow.cpp file, move all the code from paintEvent() to the paintAll()
    function. Then, replace all the individual QPainter objects with a single, unified
    QPainter for drawing all the graphics. Also, call the begin() function before
    drawing anything and call the end() function after finishing drawing. The code
    should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We go on to create **ellipsePen** and **rectPath**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we go on to create `ellipsePath` and `image`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we have moved all the code from `paintEvent()` to `paintAll()`, we shall
    now call the `paintAll()` function inside `paintEvent()`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will write the code for exporting the graphics as an SVG file. The
    code will be written inside the slot function called `on_actionSave_as_SVG_triggered()`,
    which was generated by Qt. We start by calling the save file dialog and obtain
    the directory path with the desired filename from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, create a `QSvgGenerator` object and save the graphics to an SVG
    file by passing the `QSvgGenerator` object to the `paintAll()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, compile and run the program and you should be able to export the graphics
    by going to **File** | **Save** **as SVG**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Comparing the results between our program and the SVG file on
    a web browser](img/B20976_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Comparing the results between our program and the SVG file on a
    web browser
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, `QPainter` will use the paint engine from its parent object to draw
    the graphics assigned to it. If you don’t assign any parent to `QPainter`, you
    can manually assign a paint engine to it, which is what we have done in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we placed the code into `paintAll()` is that we want to reuse
    the same code for two different purposes: for displaying the graphics on the window
    and exporting the graphics to an SVG file. You can see that the default value
    of the generator variable in the `paintAll()` function is set to `0`, which means
    no `QSvgGenerator` object is required to run the function unless specified. Later
    on, in the `paintAll()` function, we check whether the generator object exists.
    If it does exist, use it as the paint engine for the painter, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, pass the main window to the `begin()` function (since we’re writing
    the code in the `mainwindow.cpp` file, we can directly use this to refer to the
    main window’s pointer) so that it will use the paint engine of the main window
    itself, which means the graphics will be drawn onto the surface of the main window.
    In this example, it’s required to use a single `QPainter` object to save the graphics
    into the SVG file. If you use multiple `QPainter` objects, the resulting SVG file
    will contain multiple XML header definitions, and thus the file will be deemed
    to be invalid by any graphics editor software out there.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFileDialog::getSaveFileName()` will open up the native save file dialog for
    the user to choose the save directory and set a desired filename. Once the user
    is done with that, the full path will be returned as a string, and we will be
    able to pass that information to the `QSvgGenerator` object to export the graphics.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the previous screenshot, the penguin in the SVG file has been
    cropped. This is because the canvas size of the SVG was set to follow the size
    of the main window. To help the poor penguin get its body back, scale the window
    bigger before exporting the SVG file.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SVG defines the graphics in XML format. Since it is a form of vector graphics,
    SVG files do not lose any quality if they are zoomed in on or resized. The SVG
    format not only allows you to store vector graphics in the working file, but it
    also allows you to store raster graphics and text, which is more or less similar
    to Adobe Illustrator’s format. The SVG also allows you to group, style, transform,
    and composite graphical objects into previously rendered objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the full specification of SVG graphics at [https://www.w3.org/TR/SVG](https://www.w3.org/TR/SVG).
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to use coordinate transformation and a timer
    to create a real-time clock display.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create our first graphical clock display, let’s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new `mainwindow.ui` and remove the `menuBar`, `mainToolBar`,
    and `statusBar` as we did before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, open up the `mainwindow.h` file and include the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, declare the `paintEvent()` function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: void MainWindow::paintEvent(QPaintEvent *event) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static const QPoint hourHand[3] = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(4, 4),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(-4, 4),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(0, -40)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static const QPoint minuteHand[3] = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(4, 4),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(-4, 4),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(0, -70)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static const QPoint secondHand[3] = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(2, 2),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(-2, 2),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QPoint(0, -90)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add the following code below the arrays to create the painter and
    move it to the center of the main window. Also, we adjust the size of the painter
    so that it fits nicely in the main window, even when the window is being resized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with that, we will start drawing the dials by using a for
    loop. Each dial is rotated by an increment of 6 degrees, so 60 dials would complete
    a full circle. Also, the dial will look slightly longer at every five minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we proceed with drawing the hands of the clock. Each hand’s rotation
    is calculated according to the current time and its respective equivalent location
    over 360 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s draw the minute hand of the clock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we also draw the hand for seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, but not least, create a timer to refresh the graphics every second so
    that the program will work like a real clock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the program now, and you should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – A real-time analog clock displayed on the Qt application](img/B20976_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – A real-time analog clock displayed on the Qt application
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the arrays contains three `QPoint` data instances, which form the shape
    of an elongated triangle. The arrays are then passed to the painter and rendered
    as a convex polygon using the `drawConvexPolygon()` function. Before drawing each
    of the clock hands, we use `painter.save()` to save the state of the `QPainter`
    object and then proceed with drawing the hand using coordinate transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re done with the drawing, we restore the painter to its previous state
    by calling `painter.restore()`. This function will undo all the transformations
    before `painter. restore()` so that the next clock hand will not inherit the transformations
    of the previous one. Without using `painter.save()` and `painter.restore()`, we
    will have to manually change the position, rotation, and scale before drawing
    the next hand.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of not using `painter.save()` and `painter.restore()` is when
    drawing the dials. Since each dial’s rotation is an increment of six degrees from
    the previous one, we don’t need to save the painter’s state at all. We just have
    to call `painter.rotate(6.0)` in a loop and each dial will inherit the previous
    dial’s rotation. We also use a modulus operator (`%`) to check whether the unit
    represented by the dial can be divided by five. If it can, then we draw it slightly
    longer.
  prefs: []
  type: TYPE_NORMAL
- en: Without using a timer to constantly call the `update()` slot, the clock will
    not function properly. This is because `paintEvent()` will not be called by Qt
    when there is no change to the state of the parent widget, which in this case
    is the main window. Therefore, we need to manually tell Qt that we need to refresh
    the graphics by calling `update()` every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `painter.setRenderHint(QPainter::Antialiasing)` function to enable
    anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will
    look very jagged and pixelated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Anti-aliasing produces a smoother result](img/B20976_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Anti-aliasing produces a smoother result
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `QPainter` class uses the coordinate system to determine the position and
    size of the graphics before rendering them on screen. This information can be
    altered to make the graphics appear at a different position, rotation, and size.
    This process of altering the coordinate information of a graphic is what we call
    coordinate transformation. There are several types of transformation: among them
    are **translation**, **rotation**, **scaling**, and **shearing**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Different types of transformations](img/B20976_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Different types of transformations
  prefs: []
  type: TYPE_NORMAL
- en: Qt uses a coordinate system that has its origin at the top-left corner, meaning
    the *x* values increase to the right and the *y* values increase downward. This
    coordinate system might be different from the coordinate system used by the physical
    device, such as a computer screen. Qt handles this automatically by using the
    `QPaintDevice` class, which maps Qt’s logical coordinates to the physical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '`QPainter` provides four transform operations to perform different types of
    transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPainter::translate()`: This offsets the graphic’s position by a given set
    of units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter::rotate()`: This rotates the graphics around the origin in a clockwise
    direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter::scale()`: This offsets the graphic’s size by a given factor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter::shear()`: This twists the graphic’s coordinate system around the
    origin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images on screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt not only allows us to draw shapes and images on screen, but it also allows
    us to overlay multiple images on top of each other and combine the pixel information
    from all the layers using different types of algorithms to create very interesting
    results. In this example, we will learn how to overlay images on top of each other
    and apply different composition effects to them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a simple demo that shows the effect of different image compositions
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, set up a new `menuBar`, `mainToolBar`, and `statusBar`, as we did in
    the first recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the `QPainter` class header to the `mainwindow.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, declare the `paintEvent()` virtual function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `mainwindow.cpp`, we will first load several image files using the `QImage`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a `QPainter` object and use it to draw two pairs of images, where
    one image is on top of the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, compile and run the program and you should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Displaying images normally](img/B20976_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Displaying images normally
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set the composition mode before drawing each image on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the program again and you will now see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Applying different composition modes to the images](img/B20976_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Applying different composition modes to the images
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When drawing images with Qt, the sequence of calling the `drawImage()` function
    will determine which image is being rendered first and which one is rendered later.
    This will affect the depth order of the images and yield different outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we called the `drawImage()` function four times to
    draw four different images on screen. The first `drawImage()` function renders
    `checker.png`, and the second `drawImage()` function renders `tux.png` (the penguin).
    The image that gets rendered later will always appear in front of the others,
    which is why the penguin is showing in front of the checkered pattern. The same
    goes for the butterfly and the checkered pattern on the right. The reason why
    you can still see the checkered pattern even though the butterfly is rendered
    in front of it is because the butterfly image is not fully opaque.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s invert the render sequence and see what happens. We will try to
    render the penguin first, followed by the checkered box. The same goes for the
    other pair of images on the right: the butterfly gets rendered first, followed
    by the checkered box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Both the penguin and butterfly are covered by the checkered
    boxes](img/B20976_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes
  prefs: []
  type: TYPE_NORMAL
- en: To apply a composition effect to the image, we’ll have to set the painter’s
    composition mode before drawing the image, by calling the `painter.setCompositionMode()`
    function. You can pick a desired composition mode from the auto-complete menu
    by typing `QPainter::CompositionMode`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we applied `QPainter::CompositionMode_Difference` to
    the checkered box on the left, which inverted its color. Next, we applied `QPainter::CompositionMode_Overlay`
    to the penguin, which makes it blend with the checkered pattern, and were able
    to see both images overlaying each other. On the right-hand side, we applied `QPainter::CompositionMode_Xor`
    to the checkered box, where, if differences exist between the source and destination,
    colors are shown; otherwise, it will be rendered black.
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s comparing differences with the white background, the non-transparent
    part of the checkered box becomes completely black. We also applied `QPainter::CompositionMode_SoftLight`
    to the butterfly image. This blends the pixels with the background with reduced
    contrast. If you want to disable the composition mode that you’ve just set for
    the previous rendering before proceeding to the next, simply set it back to the
    default mode, which is `QPainter::CompositionMode_SourceOver`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For example, we can overlay multiple images on top of each other and use Qt’s
    **Image Composition** feature to merge them together and calculate the resulting
    pixels on screen, based on the composition mode we used. This is often used in
    image editing software such as Photoshop and GIMP to composite image layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more than 30 types of composition modes available in Qt. Some of
    the most commonly used modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Clear`: The pixels in the destination are set to fully transparent, independent
    of the source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source`: The output is the source pixel. This mode is the inverse of `CompositionMode_Destination`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination`: The output is the destination pixel. This means that the blending
    has no effect. This mode is the inverse of `CompositionMode_Source`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source Over`: This is often referred to as `QPainter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination Over`: The output is the blend between the alpha of the destination
    on top of the source pixels. The opposite of this mode is `CompositionMode_SourceOver`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source In`: The output is the source, where the alpha is reduced by that of
    the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination In`: The output is the destination, where the alpha is reduced
    by that of the source. This mode is the inverse of `CompositionMode_SourceIn`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source Out`: The output is the source, where the alpha is reduced by the inverse
    of the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination Out`: The output is the destination, where the alpha is reduced
    by the inverse of the source. This mode is the inverse of `CompositionMode_SourceOut`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source Atop`: The source pixel is blended on top of the destination, with
    the alpha of the source pixel reduced by the alpha of the destination pixel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination Atop`: The destination pixel is blended on top of the source,
    with the alpha of the source pixel reduced by the alpha of the destination pixel.
    This mode is the inverse of `CompositionMode_SourceAtop`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xor`: This is short for `Exclusive OR`, which is an advanced blending mode
    that is primarily used for image analysis. Using this is much more complicated
    with this composition mode. First, the alpha of the source is reduced by the inverse
    of the destination alpha. Then, the alpha of the destination is reduced by the
    inverse of the source alpha. Finally, both the source and destination are then
    merged to produce the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, you can visit this link: [https://pyside.github.io](https://pyside.github.io).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the outcome of overlaying two images with different
    composition modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Different types of composition modes](img/B20976_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Different types of composition modes
  prefs: []
  type: TYPE_NORMAL
- en: Applying image effects to graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides an easy way to add image effects to any graphics drawn using the
    `QPainter` class. In this example, we will learn how to apply different image
    effects, such as drop shadow, blur, colorize, and opacity effects, to a graphic
    before displaying it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s learn how to apply image effects to text and graphics by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `menuBar`, `mainToolBar`, and `StatusBar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new resource file by going to **File** | **New File or Project** and
    add all the images required by the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Creating a new Qt resource file](img/B20976_04_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Creating a new Qt resource file
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open up `mainwindow.ui` and add four labels to the window. Two of the
    labels will be text, and the two others we will load with the images we have just
    added to the resource file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Application filled with text and images](img/B20976_04_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Application filled with text and images
  prefs: []
  type: TYPE_NORMAL
- en: 'You may already notice that the font sizes are way bigger than the default
    size. That can be achieved by adding a style sheet to the label widget, for example,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.cpp` and include the following headers at the
    top of the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, within the constructor of the `MainWindow` class, add the following code
    to create a `DropShadowEffect`, and apply it to one of the labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create `ColorizedEffect` and apply it to one of the images, in
    this case, the butterfly. We also set the effect color to red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we’re done with that, create `BlurEffect` and set its radius to `12`.
    Then, apply the graphics effect to the other label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, create an alpha effect and apply it to the penguin image. We set the
    opacity value to `0.2`, which means 20% opacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, compile and run the program and you should be able to see something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Different types of graphics effects being applied to the texts
    and images](img/B20976_04_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Different types of graphics effects being applied to the texts
    and images
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the graphic effects is a class of its own that inherits the `QGraphicsEffect`
    parent class. You can create your own custom effect by creating a new class that
    inherits `QGraphicsEffect` and re-implementing some of the functions in it.
  prefs: []
  type: TYPE_NORMAL
- en: Each effect has its own set of variables that are specifically created for it.
    For example, you can set the color of the colorized effect, but there is no such
    variable in the blur effect. This is because each effect is vastly different from
    the others, which is also why it needs to be a class of its own rather than using
    the same class for all the different effects.
  prefs: []
  type: TYPE_NORMAL
- en: It’s only possible to add a single graphics effect to a widget at a time. If
    you add more than one effect, only the last one will be applied to the widget,
    as it replaces the previous one. Other than that, be aware that if you create
    a graphics effect, for example, the drop shadow effect, you can’t assign it to
    two different widgets, as it will only get assigned to the last widget you applied
    it to. If you need to apply the same type of effect to several different widgets,
    create a few graphics effects of the same type and apply each of them to their
    respective widgets.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, Qt supports blur, drop shadow, colorize, and opacity effects. These
    effects can be used by calling the following classes: `QGraphicsBlurEffect`, `QGraphicsDropShadowEffect`,
    `QGraphicsColorizeEffect`, and `QGraphicsOpacityEffect`. All these classes are
    inherited from the `QGraphicsEffect` class. You can also create your own custom
    image effect by creating a subclass of `QGrapicsEffect` (or any other existing
    effects) and re-implementing the `draw()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The graphics effect changes only the bounding rectangle of the source. If you
    want to increase the margin of the bounding rectangle, re-implement the virtual
    `boundingRectFor()` function, and call `updateBoundingRect()` to notify the framework
    whenever this rectangle changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic paint program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have learned so much about the `QPainter` class and how to use it to
    display graphics on screen, I guess it’s time for us to do something fun where
    we can put our knowledge into practice.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make a basic paint program that allows
    us to draw lines on a canvas with different brush sizes and colors. We will also
    learn how to use the `QImage` class and mouse events in order to construct the
    paint program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start our fun project with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start by creating a new **Qt Widgets Application** project and removing
    the toolbar and status bar. We will keep the menu bar this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, set up the menu bar like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Setting up the menu bar](img/B20976_04_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Setting up the menu bar
  prefs: []
  type: TYPE_NORMAL
- en: 'We will leave the menu bar as it is for the moment, so let’s proceed to the
    `mainwindow.h` file. First, include the following header files, as they are required
    for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, declare the variables that we’ll be using for this project, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'public:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explicit MainWindow(QWidget *parent = 0);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ~MainWindow();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: virtual void mousePressEvent(QMouseEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: virtual void mouseMoveEvent(QMouseEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: virtual void mouseReleaseEvent(QMouseEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: virtual void paintEvent(QPaintEvent *event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mainwindow.cpp file and add the following code to the class constructor to
    set up some of the variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will construct the `mousePressEvent()` event and tell Qt what to do
    when the left mouse button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will construct the `mouseMoveEvent()` event and tell Qt what to do
    when the mouse is moving. In this case, we want to draw the lines on the canvas
    if the left mouse button is being held:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will also construct the `mouseReleaseEvent()` event, which will
    be triggered when the mouse button is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’re done with that, we will proceed to the `paintEvent()` event, which
    is surprisingly simple compared to the other examples we have seen in previous
    sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember how we have a menu bar sitting around doing nothing? Let’s right-click
    on each of the actions below the GUI editor and select **Go to slot…** in the
    pop-up menu. We want to tell Qt what to do when each of these options on the menu
    bar is selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Creating slot function for each of the menu actions](img/B20976_04_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Creating slot function for each of the menu actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select the default slot called `triggered()` and press the `mainwindow.h`
    and `mainwindow.cpp` files. Once you are done with all the actions, you should
    see something like this in your `mainwindow.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will tell Qt what to do when each of these slots is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we continue to implement the other slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we implement the rest of the slot functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we compile and run the program now, we will get a simple but usable paint
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Our lovely paint program in action!](img/B20976_04_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Our lovely paint program in action!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created a `QImage` widget when the program started. This
    widget acts as the canvas and will follow the size of the window whenever the
    window gets resized. In order to draw something on the canvas, we will need to
    use the mouse events provided by Qt. These events will tell us the position of
    the cursor, and we will be able to use this information to change the pixels on
    the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We use a Boolean variable called `drawing` to let the program know whether it
    should start drawing when a mouse button is pressed. In this case, when the left
    mouse button is pressed, the `drawing` variable will be set to `true`. We also
    save the current cursor position to the `lastPoint` variable when the left mouse
    button is pressed, so that Qt will know where it should start drawing. When the
    mouse moves, the `mouseMoveEvent()` event will be triggered by Qt. This is where
    we need to check whether the drawing variable is set to `true`. If it is, then
    `QPainter` can start drawing the lines onto the `QImage` widget based on the brush
    settings that we provide. The brush settings consist of `brushColor` and `brushSize`.
    These settings are saved as variables and can be altered by selecting a different
    setting from the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: Please remember to call the `update()` function when the user is drawing on
    the canvas. Otherwise, the canvas will remain empty even though we have changed
    the pixel information of the canvas. We also have to call the `update()` function
    when we select **File** | **Clear** from the menu bar to reset our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use `QImage::save()` to save the image file, which is very
    straightforward. We use the file dialog to let the user decide where to save the
    image and its desired filename. Then, we pass the information to `QImage`, and
    it will do the rest by itself. If we don’t specify the file format to the `QImage::save()`
    function, `QImage` will try to figure it out by looking at the extension of the
    desired filename.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a 2D canvas in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the previous examples of this chapter, we have discussed the methods
    and techniques used to render 2D graphics with Qt’s C++ API. However, we have
    yet to learn how to achieve similar results using the powerful QML script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we’ll be doing something quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the first step is to create a new project by going to **File** |
    **New File or Project** and selecting **Qt Quick Application** as the project
    template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Creating a new Qt Quick Application project](img/B20976_04_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Creating a new Qt Quick Application project
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done creating the new project, open up `main.qml`, which is listed
    under `qml.qrc` in the project pane. After that, set an ID for the window and
    adjust its `width` and `height` values to larger values, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a `Canvas` object under `myWindow` and call it `myCanvas`. After
    that, we make its `width` and `height` values the same as `myWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define what will happen when the `onPaint` event is triggered; in
    this case, we will draw a cross on the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s continue to write the code, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we add the following code to draw a tick beside the cross:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, draw a triangle shape by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, draw a half circle and a full circle with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we draw an arc:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we draw a 2D image from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, the preceding code alone will not successfully render an image on
    screen because you must also load the image file beforehand. Add the following
    code within the `Canvas` object to ask QML to load the image file when the program
    is started, then call the `requestPaint()` signal when the image is loaded so
    that the `onPaint()` event slot will be triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open up `qml.qrc` by right-clicking it in the project panel and select
    `tux.png` image file to our project resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – The tux.png image file is now listed under qml.qrc](img/B20976_04_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – The tux.png image file is now listed under qml.qrc
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build and run the program and you should get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Tux the penguin is amused by the geometrical shapes](img/B20976_04_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Tux the penguin is amused by the geometrical shapes
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we learned how to draw simple vector shapes on our
    screen using the `Canvas` element. Qt’s built-in modules make the complex rendering
    process more straightforward for programmers.
  prefs: []
  type: TYPE_NORMAL
