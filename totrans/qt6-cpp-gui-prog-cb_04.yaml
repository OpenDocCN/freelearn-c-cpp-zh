- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: QPainter and 2D Graphics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QPainter 和 2D 图形
- en: In this chapter, we will learn how to render 2D graphics on screen with Qt.
    Internally, Qt uses a low-level class called `QPainter` to render its widgets
    on the main window. Qt allows us to access and use the `QPainter` class for drawing
    vector graphics, text, 2D images, and even 3D graphics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Qt 在屏幕上渲染 2D 图形。内部，Qt 使用一个名为 `QPainter` 的低级类来在主窗口上渲染其小部件。Qt 允许我们访问和使用
    `QPainter` 类来绘制矢量图形、文本、2D 图像，甚至 3D 图形。
- en: You can make use of the `QPainter` class to create your own custom widgets or
    to create programs that rely heavily on rendering computer graphics such as video
    games, photo editors, and 3D modeling tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `QPainter` 类创建自己的自定义小部件，或者创建依赖于渲染计算机图形的程序，如视频游戏、照片编辑器和 3D 建模工具。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Drawing basic shapes on the screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上绘制基本形状
- en: Exporting shapes to **Scalable Vector Graphics** (**SVG**) files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将形状导出为 **可缩放矢量图形** (**SVG**) 文件
- en: '**Coordinate transformation**'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标变换**'
- en: Displaying images on screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像
- en: Applying image effects to graphics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像效果应用于图形
- en: Creating a basic paint program
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的绘图程序
- en: Rendering a 2D canvas in QML
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 QML 中渲染 2D 画布
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**
    and **Qt Creator 12.0.2**. All the code used in this chapter can be downloaded
    from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 **Qt 6.6.1 MinGW 64 位** 和 **Qt Creator 12.0.2**。本章中使用的所有代码都可以从以下 GitHub
    仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04)。
- en: Drawing basic shapes on the screen
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上绘制基本形状
- en: In this section, we will learn how to draw simple vector shapes (a line, a rectangle,
    a circle, and so on) and display text on the main window using the `QPainter`
    class. We will also learn how to change the drawing style of these vector shapes
    using the `QPen` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 `QPainter` 类在主窗口上绘制简单的矢量形状（一条线、一个矩形、一个圆等）并显示文本。我们还将学习如何使用 `QPen`
    类更改这些矢量形状的绘图样式。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s follow the steps listed here to display basic shapes in our Qt window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照这里列出的步骤来显示我们 Qt 窗口中的基本形状：
- en: First, let’s create a new **Qt Widgets** **Application** project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的 **Qt Widgets** **应用程序** 项目。
- en: 'Open up `mainwindow.ui` and remove the `menuBar`, `mainToolBar`, and `statusBar`
    objects so that we get a clean, empty main window. Right-click on the bar widgets
    and select **Remove Menu Bar** from the pop-up menu:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui` 并移除 `menuBar`、`mainToolBar` 和 `statusBar` 对象，以便我们得到一个干净、空的主窗口。右键单击栏小部件，从弹出菜单中选择
    **移除菜单栏**：
- en: '![Figure 4.1 – Removing the menu bar from the main window](img/B20976_04_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 从主窗口中移除菜单栏](img/B20976_04_001.jpg)'
- en: Figure 4.1 – Removing the menu bar from the main window
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 从主窗口中移除菜单栏
- en: 'Then, open up the `mainwindow.h` file and add the following code to include
    the `QPainter` header file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `mainwindow.h` 文件并添加以下代码以包含 `QPainter` 头文件：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, declare the `paintEvent()` event handler below the class destructor:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类析构函数下方声明 `paintEvent()` 事件处理程序：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: void MainWindow::paintEvent(QPaintEvent *event) {}
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void MainWindow::paintEvent(QPaintEvent *event) {}
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, we will add text to the screen using the `QPainter` class inside
    the `paintEvent()` event handler. We set the text font settings before drawing
    it on the screen at the position of `(``20, 30)`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将使用 `QPainter` 类在 `paintEvent()` 事件处理程序中向屏幕添加文本。我们在屏幕上 `(``20, 30)` 位置绘制文本之前设置文本字体设置：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we will draw a straight line that starts from `(50, 60)` and ends at
    `(``100, 100)`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将绘制一条从 `(50, 60)` 开始到 `(``100, 100)` 结束的直线：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also easily draw a rectangle by calling the `drawRect()` function using
    a `QPainter` class. This time, however, we also apply a background pattern to
    the shape before drawing it:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过调用 `drawRect()` 函数并使用 `QPainter` 类轻松地绘制一个矩形。然而，这次我们在绘制形状之前还应用了一个背景图案：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, declare a `QPen` class, set its color to `red`, and set its drawing style
    to `Qt::DashDotLine`. Then, apply the `QPen` class to `QPainter` and draw an ellipse
    shape at `(80, 200)` with a horizontal radius of `50` and a vertical radius of
    `20`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个 `QPen` 类，将其颜色设置为 `red`，并将绘制样式设置为 `Qt::DashDotLine`。然后，将 `QPen` 类应用于
    `QPainter` 并在 `(80, 200)` 位置绘制一个椭圆形状，水平半径为 `50`，垂直半径为 `20`：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use the `QPainterPath` class to define a shape before passing it
    over to the `QPainter` class for rendering:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 `QPainterPath` 类在传递给 `QPainter` 类进行渲染之前定义一个形状：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also draw any other shapes by using `QPainterPath`, such as an ellipse:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用 `QPainterPath` 绘制任何其他形状，例如椭圆：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`QPainter` can also be used to draw an image file onto the screen. In the following
    example, we load an image file called `tux.png` and draw it on the screen at the
    `(100,` `150)` position:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QPainter` 也可以用来在屏幕上绘制图像文件。在以下示例中，我们加载了一个名为 `tux.png` 的图像文件，并在屏幕上的 `(100,`
    `150)` 位置绘制它：'
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final result should look something like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果应该看起来像这样：
- en: '![Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines](img/B20976_04_002.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 图形和线条让企鹅图克斯感到不知所措](img/B20976_04_002.jpg)'
- en: Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 图形和线条让企鹅图克斯感到不知所措
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you want to draw something on screen using `QPainter`, all you need to do
    is tell it what type of graphics it should be drawing (as in text, a vector shape,
    an image, a polygon) with the desired position and size. The `QPen` class determines
    what the outline of the graphic should look like, such as its color, line width,
    line style (solid, dashed, or dotted), cap style, join style, and so on. On the
    other hand, `QBrush` sets the style of the background of the graphics, such as
    the background color, pattern (solid color, gradient, dense brush, and crossing
    diagonal lines), and pixmap.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 `QPainter` 在屏幕上绘制某些内容，您只需要告诉它应该绘制什么类型的图形（如文本、矢量形状、图像、多边形）以及所需的尺寸和位置。`QPen`
    类决定了图形轮廓的外观，例如其颜色、线宽、线型（实线、虚线或点线）、端点样式、连接样式等。另一方面，`QBrush` 设置图形背景的样式，例如背景颜色、图案（纯色、渐变、密集刷和交叉对角线）和位图。
- en: 'The options for the graphics should be set before calling a `draw` function
    (such as `drawLine()`, `drawRect()`, or `drawEllipse()`). If your graphics do
    not appear on the screen and you see warnings such as `QPainter::setPen: Painter
    not active` and `QPainter::setBrush: Painter not active` appearing on the application
    output window in Qt Creator, it means that the `QPainter` class is not currently
    active and your program will not trigger its paint event. To solve this problem,
    set the main window as the parent of the `QPainter` class. Usually, if you’re
    writing code in the `mainwindow.cpp` file, all you need to do is to put `this`
    in the brackets when initializing `QPainter`. For example, note the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '在调用 `draw` 函数（如 `drawLine()`、`drawRect()` 或 `drawEllipse()`）之前应设置图形选项。如果您的图形没有显示在屏幕上，并且在
    Qt Creator 的应用程序输出窗口中看到诸如 `QPainter::setPen: Painter not active` 和 `QPainter::setBrush:
    Painter not active` 的警告，这意味着 `QPainter` 类当前未激活，并且您的程序将不会触发其绘制事件。要解决这个问题，请将主窗口设置为
    `QPainter` 类的父类。通常，如果您在 `mainwindow.cpp` 文件中编写代码，您只需要在初始化 `QPainter` 时在括号中放置 `this`。例如，注意以下内容：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`QImage` can load images from both the computer directories and from the program
    resources.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage` 可以从计算机目录和程序资源中加载图像。'
- en: There’s more…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Think of `QPainter` as a robot with a pen and an empty canvas. You just have
    to tell the robot what type of shape it should be drawing and its location on
    the canvas, then the robot will do its job based on your description.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `QPainter` 想象为一个带有笔和空画布的机器人。您只需要告诉机器人应该绘制什么类型的形状以及它在画布上的位置，然后机器人将根据您的描述完成工作。
- en: To make your life easier, the `QPainter` class also provides numerous functions,
    such as `drawArc()`, `drawEllipse()`, `drawLine()`, `drawRect()`, and `drawPie()`,
    which allow you to easily render a predefined shape. In Qt, all the widget classes
    (including the main window) have an event handler called `QWidget::paintEvent()`.
    This event handler will be triggered whenever the operating system thinks that
    the main window should re-draw its widgets. Many things can lead to that decision,
    such as the main window being scaled, a widget changing its state (that is, a
    button being pressed), or functions such as `repaint()` or `update()` being invoked
    manually in the code. Different operating systems may behave differently when
    it comes to deciding whether or not to trigger the update event on the same set
    of conditions. If you’re making a program that requires continuous and consistent
    graphical updates, call `repaint()` or `update()` manually with a timer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的生活更轻松，`QPainter` 类还提供了许多函数，例如 `drawArc()`、`drawEllipse()`、`drawLine()`、`drawRect()`
    和 `drawPie()`，这些函数允许你轻松渲染预定义的形状。在 Qt 中，所有的小部件类（包括主窗口）都有一个事件处理程序，称为 `QWidget::paintEvent()`。当操作系统认为主窗口应该重新绘制其小部件时，此事件处理程序将被触发。许多事情可能导致这个决定，例如主窗口被缩放、小部件改变其状态（即按钮被按下），或者代码中手动调用
    `repaint()` 或 `update()` 函数。不同的操作系统在决定是否在相同条件下触发更新事件时可能会有不同的行为。如果你正在制作一个需要持续和一致图形更新的程序，请使用定时器手动调用
    `repaint()` 或 `update()`。
- en: Exporting shapes to SVG files
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将形状导出为 SVG 文件
- en: SVG is an XML-based language for describing 2D vector graphics. Qt provides
    classes for saving vector shapes as SVG files. This feature can be used to create
    a simple vector graphics editor similar to Adobe Illustrator and Inkscape. In
    the next example, we will continue using the same project file from the previous
    example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 是一种基于 XML 的语言，用于描述 2D 向量图形。Qt 提供了将向量形状保存为 SVG 文件的类。这个功能可以用来创建一个类似于 Adobe
    Illustrator 和 Inkscape 的简单向量图形编辑器。在下一个示例中，我们将继续使用之前示例中的相同项目文件。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s learn how to create a simple program that displays SVG graphics on screen:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何创建一个简单的程序，该程序可以在屏幕上显示 SVG 图形：
- en: 'First of all, let’s create a menu bar by right-clicking the main window widget
    on the hierarchy window and selecting the **Create Menu Bar** option from the
    pop-up menu. After that, add a **File** option to the menu bar and a **Save as
    SVG** action underneath it:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过在层次窗口中右键单击主窗口小部件并从弹出菜单中选择 **创建菜单栏** 选项来创建一个菜单栏。之后，将 **文件** 选项添加到菜单栏中，并在其下添加
    **另存为 SVG** 动作：
- en: '![Figure 4.3 – Create a Save as SVG option on the menu bar](img/B20976_04_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 在菜单栏上创建“另存为 SVG”选项](img/B20976_04_003.jpg)'
- en: Figure 4.3 – Create a Save as SVG option on the menu bar
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 在菜单栏上创建“另存为 SVG”选项
- en: 'After that, you will see an item called `triggered()`, and click the **OK**
    button:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你会看到一个名为 `triggered()` 的项，然后点击 **确定** 按钮：
- en: '![Figure 4.4 – Creating a slot function for the triggered() signal](img/B20976_04_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 为 triggered() 信号创建槽函数](img/B20976_04_004.jpg)'
- en: Figure 4.4 – Creating a slot function for the triggered() signal
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 为 triggered() 信号创建槽函数
- en: 'Once you have clicked the `on_actionSave_as_SVG_triggered()` has been automatically
    added to your main window class. At the bottom of your `mainwindow.h` file, you
    will see something like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你点击了 `on_actionSave_as_SVG_triggered()`，它就会自动添加到你的主窗口类中。在你的 `mainwindow.h`
    文件底部，你会看到类似以下内容：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding function is called when you click on the `QSvgGenerator` at the
    top of our source file. This header is very important as it’s required for generating
    SVG files. Then, we also need to include another class header called `QFileDialog`,
    which will be used to open the save dialog:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击源文件顶部的 `QSvgGenerator` 时，会调用前面的函数。这个头文件非常重要，因为它是生成 SVG 文件所必需的。然后，我们还需要包含另一个类头文件
    `QFileDialog`，它将被用来打开保存对话框：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to add the `svg` module to our project file, like so:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将 `svg` 模块添加到我们的项目文件中，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'public:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public:'
- en: explicit MainWindow(QWidget *parent = 0);
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: explicit MainWindow(QWidget *parent = 0);
- en: ~MainWindow();
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ~MainWindow();
- en: virtual void paintEvent(QPaintEvent *event);
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: virtual void paintEvent(QPaintEvent *event);
- en: 'mainwindow.cpp file, move all the code from paintEvent() to the paintAll()
    function. Then, replace all the individual QPainter objects with a single, unified
    QPainter for drawing all the graphics. Also, call the begin() function before
    drawing anything and call the end() function after finishing drawing. The code
    should look like this:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将mainwindow.cpp文件中的所有代码从paintEvent()函数移动到paintAll()函数中。然后，将所有单独的QPainter对象替换为用于绘制所有图形的单个统一QPainter对象。此外，在绘制任何内容之前调用begin()函数，在完成绘制后调用end()函数。代码应如下所示：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We go on to create **ellipsePen** and **rectPath**:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续创建**ellipsePen**和**rectPath**：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we go on to create `ellipsePath` and `image`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续创建`ellipsePath`和`image`：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we have moved all the code from `paintEvent()` to `paintAll()`, we shall
    now call the `paintAll()` function inside `paintEvent()`, like so:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将所有代码从`paintEvent()`移动到`paintAll()`，我们现在需要在`paintEvent()`中调用`paintAll()`函数，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we will write the code for exporting the graphics as an SVG file. The
    code will be written inside the slot function called `on_actionSave_as_SVG_triggered()`,
    which was generated by Qt. We start by calling the save file dialog and obtain
    the directory path with the desired filename from the user:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将编写将图形导出为SVG文件的代码。该代码将编写在由Qt生成的名为`on_actionSave_as_SVG_triggered()`的槽函数中。我们首先调用保存文件对话框，并从用户那里获取带有所需文件名的目录路径：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, create a `QSvgGenerator` object and save the graphics to an SVG
    file by passing the `QSvgGenerator` object to the `paintAll()` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，创建一个`QSvgGenerator`对象，并通过将`QSvgGenerator`对象传递给`paintAll()`函数将图形保存到SVG文件中：
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, compile and run the program and you should be able to export the graphics
    by going to **File** | **Save** **as SVG**:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行程序，你应该能够通过转到**文件** | **另存为 SVG**来导出图形：
- en: '![Figure 4.5 – Comparing the results between our program and the SVG file on
    a web browser](img/B20976_04_005.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 在网页浏览器中比较我们的程序和SVG文件的结果](img/B20976_04_005.jpg)'
- en: Figure 4.5 – Comparing the results between our program and the SVG file on a
    web browser
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 在网页浏览器中比较我们的程序和SVG文件的结果
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, `QPainter` will use the paint engine from its parent object to draw
    the graphics assigned to it. If you don’t assign any parent to `QPainter`, you
    can manually assign a paint engine to it, which is what we have done in this example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`QPainter`将使用其父对象的绘图引擎来绘制分配给它的图形。如果您没有为`QPainter`分配任何父对象，您可以手动为其分配一个绘图引擎，这正是我们在本例中所做的。
- en: 'The reason why we placed the code into `paintAll()` is that we want to reuse
    the same code for two different purposes: for displaying the graphics on the window
    and exporting the graphics to an SVG file. You can see that the default value
    of the generator variable in the `paintAll()` function is set to `0`, which means
    no `QSvgGenerator` object is required to run the function unless specified. Later
    on, in the `paintAll()` function, we check whether the generator object exists.
    If it does exist, use it as the paint engine for the painter, as shown in the
    following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放入`paintAll()`中的原因是我们希望相同的代码用于两个不同的目的：在窗口上显示图形和将图形导出为SVG文件。您可以看到，`paintAll()`函数中生成器变量的默认值设置为`0`，这意味着除非指定，否则不需要`QSvgGenerator`对象来运行该函数。稍后，在`paintAll()`函数中，我们检查生成器对象是否存在。如果它存在，则使用它作为画家的绘图引擎，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Otherwise, pass the main window to the `begin()` function (since we’re writing
    the code in the `mainwindow.cpp` file, we can directly use this to refer to the
    main window’s pointer) so that it will use the paint engine of the main window
    itself, which means the graphics will be drawn onto the surface of the main window.
    In this example, it’s required to use a single `QPainter` object to save the graphics
    into the SVG file. If you use multiple `QPainter` objects, the resulting SVG file
    will contain multiple XML header definitions, and thus the file will be deemed
    to be invalid by any graphics editor software out there.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将主窗口传递给`begin()`函数（由于我们在`mainwindow.cpp`文件中编写代码，我们可以直接使用它来引用主窗口的指针），这样它将使用主窗口本身的绘图引擎，这意味着图形将被绘制在主窗口的表面上。在本例中，需要使用单个`QPainter`对象将图形保存到SVG文件中。如果您使用多个`QPainter`对象，生成的SVG文件将包含多个XML头定义，因此任何图形编辑软件都会认为该文件无效。
- en: '`QFileDialog::getSaveFileName()` will open up the native save file dialog for
    the user to choose the save directory and set a desired filename. Once the user
    is done with that, the full path will be returned as a string, and we will be
    able to pass that information to the `QSvgGenerator` object to export the graphics.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFileDialog::getSaveFileName()`将为用户打开原生的保存文件对话框，以便用户选择保存目录并设置一个期望的文件名。一旦用户完成操作，完整的路径将作为字符串返回，然后我们可以将此信息传递给`QSvgGenerator`对象以导出图形。'
- en: Notice that in the previous screenshot, the penguin in the SVG file has been
    cropped. This is because the canvas size of the SVG was set to follow the size
    of the main window. To help the poor penguin get its body back, scale the window
    bigger before exporting the SVG file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的屏幕截图中，SVG文件中的企鹅已经被裁剪。这是因为SVG的画布大小被设置为跟随主窗口的大小。为了帮助可怜的企鹅找回身体，在导出SVG文件之前将窗口放大。
- en: There’s more…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: SVG defines the graphics in XML format. Since it is a form of vector graphics,
    SVG files do not lose any quality if they are zoomed in on or resized. The SVG
    format not only allows you to store vector graphics in the working file, but it
    also allows you to store raster graphics and text, which is more or less similar
    to Adobe Illustrator’s format. The SVG also allows you to group, style, transform,
    and composite graphical objects into previously rendered objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SVG以XML格式定义图形。由于它是一种矢量图形，如果放大或调整大小，SVG文件不会丢失任何质量。SVG格式不仅允许你在工作文件中存储矢量图形，还允许你存储位图图形和文本，这在一定程度上类似于Adobe
    Illustrator的格式。SVG还允许你将图形对象分组、样式化、变换和组合到之前渲染的对象中。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can check out the full specification of SVG graphics at [https://www.w3.org/TR/SVG](https://www.w3.org/TR/SVG).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.w3.org/TR/SVG](https://www.w3.org/TR/SVG)查看SVG图形的完整规范。
- en: Coordinate transformation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标变换
- en: In this example, we will learn how to use coordinate transformation and a timer
    to create a real-time clock display.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何使用坐标变换和计时器来创建实时时钟显示。
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create our first graphical clock display, let’s follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个图形时钟显示，让我们按照以下步骤进行：
- en: First, create a new `mainwindow.ui` and remove the `menuBar`, `mainToolBar`,
    and `statusBar` as we did before.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的`mainwindow.ui`并移除我们之前所做的`menuBar`、`mainToolBar`和`statusBar`。
- en: 'After that, open up the `mainwindow.h` file and include the following headers:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.h`文件并包含以下头文件：
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, declare the `paintEvent()` function, like so:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明`paintEvent()`函数，如下所示：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: void MainWindow::paintEvent(QPaintEvent *event) {
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void MainWindow::paintEvent(QPaintEvent *event) {
- en: static const QPoint hourHand[3] = {
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static const QPoint hourHand[3] = {
- en: QPoint(4, 4),
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(4, 4),
- en: QPoint(-4, 4),
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(-4, 4),
- en: QPoint(0, -40)
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(0, -40)
- en: '};'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: static const QPoint minuteHand[3] = {
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static const QPoint minuteHand[3] = {
- en: QPoint(4, 4),
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(4, 4),
- en: QPoint(-4, 4),
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(-4, 4),
- en: QPoint(0, -70)
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(0, -70)
- en: '};'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: static const QPoint secondHand[3] = {
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static const QPoint secondHand[3] = {
- en: QPoint(2, 2),
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(2, 2),
- en: QPoint(-2, 2),
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(-2, 2),
- en: QPoint(0, -90)
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QPoint(0, -90)
- en: '};'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, add the following code below the arrays to create the painter and
    move it to the center of the main window. Also, we adjust the size of the painter
    so that it fits nicely in the main window, even when the window is being resized:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在数组下方添加以下代码以创建绘图器和将其移动到主窗口的中心。同时，我们调整绘图器的大小，使其在窗口调整大小时也能很好地适应主窗口：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once you are done with that, we will start drawing the dials by using a for
    loop. Each dial is rotated by an increment of 6 degrees, so 60 dials would complete
    a full circle. Also, the dial will look slightly longer at every five minutes:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们将使用循环开始绘制表盘。每个表盘旋转增加6度，因此60个表盘将完成一个完整的圆圈。此外，每过五分钟，表盘看起来会略微变长：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we proceed with drawing the hands of the clock. Each hand’s rotation
    is calculated according to the current time and its respective equivalent location
    over 360 degrees:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续绘制时钟的指针。每个指针的旋转是根据当前时间和它在360度中的相应位置来计算的：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s draw the minute hand of the clock:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们绘制时钟的时针：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we also draw the hand for seconds:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们也绘制秒针：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Last, but not least, create a timer to refresh the graphics every second so
    that the program will work like a real clock:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，创建一个计时器每秒刷新一次图形，这样程序就能像真正的时钟一样工作：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile and run the program now, and you should see something like this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行程序，你应该会看到如下所示的内容：
- en: '![Figure 4.6 – A real-time analog clock displayed on the Qt application](img/B20976_04_006.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 在 Qt 应用程序上显示的实时模拟时钟](img/B20976_04_006.jpg)'
- en: Figure 4.6 – A real-time analog clock displayed on the Qt application
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 在 Qt 应用程序上显示的实时模拟时钟
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each of the arrays contains three `QPoint` data instances, which form the shape
    of an elongated triangle. The arrays are then passed to the painter and rendered
    as a convex polygon using the `drawConvexPolygon()` function. Before drawing each
    of the clock hands, we use `painter.save()` to save the state of the `QPainter`
    object and then proceed with drawing the hand using coordinate transformation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组包含三个 `QPoint` 数据实例，这些实例形成一个细长的三角形。然后，这些数组被传递给画家，并使用 `drawConvexPolygon()`
    函数渲染为一个凸多边形。在绘制每个时钟指针之前，我们使用 `painter.save()` 保存 `QPainter` 对象的状态，然后使用坐标变换继续绘制指针。
- en: Once we’re done with the drawing, we restore the painter to its previous state
    by calling `painter.restore()`. This function will undo all the transformations
    before `painter. restore()` so that the next clock hand will not inherit the transformations
    of the previous one. Without using `painter.save()` and `painter.restore()`, we
    will have to manually change the position, rotation, and scale before drawing
    the next hand.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成绘图，我们通过调用 `painter.restore()` 将画家恢复到其之前的状态。这个函数将撤销 `painter.restore()` 之前所有的变换，这样下一个时钟指针就不会继承上一个指针的变换。如果不使用
    `painter.save()` 和 `painter.restore()`，我们将在绘制下一个指针之前手动更改位置、旋转和缩放。
- en: A good example of not using `painter.save()` and `painter.restore()` is when
    drawing the dials. Since each dial’s rotation is an increment of six degrees from
    the previous one, we don’t need to save the painter’s state at all. We just have
    to call `painter.rotate(6.0)` in a loop and each dial will inherit the previous
    dial’s rotation. We also use a modulus operator (`%`) to check whether the unit
    represented by the dial can be divided by five. If it can, then we draw it slightly
    longer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 `painter.save()` 和 `painter.restore()` 的一个好例子是在绘制表盘时。由于每个表盘的旋转是前一个表盘的六度增量，我们根本不需要保存画家的状态。我们只需要在循环中调用
    `painter.rotate(6.0)`，每个表盘都会继承前一个表盘的旋转。我们还使用模运算符 (`%`) 来检查表盘所代表的单位是否能被五整除。如果可以，我们就绘制它稍微长一点。
- en: Without using a timer to constantly call the `update()` slot, the clock will
    not function properly. This is because `paintEvent()` will not be called by Qt
    when there is no change to the state of the parent widget, which in this case
    is the main window. Therefore, we need to manually tell Qt that we need to refresh
    the graphics by calling `update()` every second.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用定时器不断调用 `update()` 槽，时钟将无法正常工作。这是因为当父窗口（在这种情况下是主窗口）的状态没有变化时，Qt 不会调用 `paintEvent()`。因此，我们需要手动告诉
    Qt 我们需要每秒刷新一次图形，通过调用 `update()`。
- en: 'We used the `painter.setRenderHint(QPainter::Antialiasing)` function to enable
    anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will
    look very jagged and pixelated:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `painter.setRenderHint(QPainter::Antialiasing)` 函数在渲染时钟时启用反走样。没有反走样，图形看起来会非常锯齿和像素化：
- en: '![Figure 4.7 – Anti-aliasing produces a smoother result](img/B20976_04_007.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 反走样产生更平滑的结果](img/B20976_04_007.jpg)'
- en: Figure 4.7 – Anti-aliasing produces a smoother result
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 反走样产生更平滑的结果
- en: There’s more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `QPainter` class uses the coordinate system to determine the position and
    size of the graphics before rendering them on screen. This information can be
    altered to make the graphics appear at a different position, rotation, and size.
    This process of altering the coordinate information of a graphic is what we call
    coordinate transformation. There are several types of transformation: among them
    are **translation**, **rotation**, **scaling**, and **shearing**:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter` 类使用坐标系来确定图形在屏幕上渲染之前的位置和大小。这些信息可以被更改，使图形出现在不同的位置、旋转和大小。改变图形坐标信息的过程就是我们所说的坐标变换。有多种类型的变换：其中包含**平移**、**旋转**、**缩放**和**剪切**：'
- en: '![Figure 4.8 – Different types of transformations](img/B20976_04_008.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 不同类型的变换](img/B20976_04_008.jpg)'
- en: Figure 4.8 – Different types of transformations
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 不同类型的变换
- en: Qt uses a coordinate system that has its origin at the top-left corner, meaning
    the *x* values increase to the right and the *y* values increase downward. This
    coordinate system might be different from the coordinate system used by the physical
    device, such as a computer screen. Qt handles this automatically by using the
    `QPaintDevice` class, which maps Qt’s logical coordinates to the physical coordinates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 使用一个以左上角为原点的坐标系，这意味着 *x* 值向右增加，*y* 值向下增加。这个坐标系可能与物理设备（如计算机屏幕）使用的坐标系不同。Qt
    通过使用 `QPaintDevice` 类自动处理这个问题，它将 Qt 的逻辑坐标映射到物理坐标。
- en: '`QPainter` provides four transform operations to perform different types of
    transformation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter` 提供了四种变换操作以执行不同类型的变换：'
- en: '`QPainter::translate()`: This offsets the graphic’s position by a given set
    of units'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::translate()`: 这将图形的位置偏移给定的一组单位'
- en: '`QPainter::rotate()`: This rotates the graphics around the origin in a clockwise
    direction'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::rotate()`: 这将图形按顺时针方向围绕原点旋转'
- en: '`QPainter::scale()`: This offsets the graphic’s size by a given factor'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::scale()`: 这将图形的大小偏移给定的一个因子'
- en: '`QPainter::shear()`: This twists the graphic’s coordinate system around the
    origin'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::shear()`: 这将图形的坐标系围绕原点扭曲'
- en: Displaying images on screen
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像
- en: Qt not only allows us to draw shapes and images on screen, but it also allows
    us to overlay multiple images on top of each other and combine the pixel information
    from all the layers using different types of algorithms to create very interesting
    results. In this example, we will learn how to overlay images on top of each other
    and apply different composition effects to them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 不仅允许我们在屏幕上绘制形状和图像，还允许我们将多个图像叠加在一起，并使用不同类型的算法结合所有层的像素信息，从而创建非常有趣的结果。在本例中，我们将学习如何将图像叠加在一起并应用不同的合成效果。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s create a simple demo that shows the effect of different image compositions
    by following these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建一个简单的演示，展示不同图像合成效果：
- en: First, set up a new `menuBar`, `mainToolBar`, and `statusBar`, as we did in
    the first recipe.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，设置一个新的 `menuBar`、`mainToolBar` 和 `statusBar`，就像我们在第一个菜谱中所做的那样。
- en: 'Next, add the `QPainter` class header to the `mainwindow.h` file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `QPainter` 类头文件添加到 `mainwindow.h` 文件中：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, declare the `paintEvent()` virtual function, like so:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，声明 `paintEvent()` 虚拟函数，如下所示：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `mainwindow.cpp`, we will first load several image files using the `QImage`
    class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mainwindow.cpp` 中，我们将首先使用 `QImage` 类加载几个图像文件：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, create a `QPainter` object and use it to draw two pairs of images, where
    one image is on top of the other:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个 `QPainter` 对象并使用它来绘制两对图像，其中一对图像位于另一对图像之上：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, compile and run the program and you should see something like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行程序，你应该会看到类似这样的内容：
- en: '![Figure 4.9 – Displaying images normally](img/B20976_04_009.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 正常显示图像](img/B20976_04_009.jpg)'
- en: Figure 4.9 – Displaying images normally
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 正常显示图像
- en: 'Next, we will set the composition mode before drawing each image on screen:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在屏幕上绘制每个图像之前设置合成模式：
- en: '[PRE35]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compile and run the program again and you will now see something like this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行程序，你现在将看到类似这样的内容：
- en: '![Figure 4.10 – Applying different composition modes to the images](img/B20976_04_010.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 将不同的合成模式应用于图像](img/B20976_04_010.jpg)'
- en: Figure 4.10 – Applying different composition modes to the images
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 将不同的合成模式应用于图像
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When drawing images with Qt, the sequence of calling the `drawImage()` function
    will determine which image is being rendered first and which one is rendered later.
    This will affect the depth order of the images and yield different outcomes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Qt 绘制图像时，调用 `drawImage()` 函数的顺序将决定哪个图像先被渲染，哪个图像后被渲染。这将影响图像的深度顺序并产生不同的结果。
- en: In the previous example, we called the `drawImage()` function four times to
    draw four different images on screen. The first `drawImage()` function renders
    `checker.png`, and the second `drawImage()` function renders `tux.png` (the penguin).
    The image that gets rendered later will always appear in front of the others,
    which is why the penguin is showing in front of the checkered pattern. The same
    goes for the butterfly and the checkered pattern on the right. The reason why
    you can still see the checkered pattern even though the butterfly is rendered
    in front of it is because the butterfly image is not fully opaque.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们四次调用`drawImage()`函数来在屏幕上绘制四个不同的图像。第一个`drawImage()`函数渲染`checker.png`，第二个`drawImage()`函数渲染`tux.png`（企鹅）。稍后渲染的图像将始终出现在其他图像之前，这就是为什么企鹅出现在棋盘格图案之前。对于蝴蝶和右侧的棋盘格图案也是如此。尽管蝴蝶被渲染在它前面，但你仍然可以看到棋盘格图案的原因是蝴蝶图像不是完全不透明的。
- en: 'Now, let’s invert the render sequence and see what happens. We will try to
    render the penguin first, followed by the checkered box. The same goes for the
    other pair of images on the right: the butterfly gets rendered first, followed
    by the checkered box:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们反转渲染顺序，看看会发生什么。我们将尝试首先渲染企鹅，然后是棋盘格方框。对于右侧的其他图像对也是如此：蝴蝶首先被渲染，然后是棋盘格方框：
- en: '![Figure 4.11 – Both the penguin and butterfly are covered by the checkered
    boxes](img/B20976_04_011.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 企鹅和蝴蝶都被棋盘格方框覆盖](img/B20976_04_011.jpg)'
- en: Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 企鹅和蝴蝶都被棋盘格方框覆盖
- en: To apply a composition effect to the image, we’ll have to set the painter’s
    composition mode before drawing the image, by calling the `painter.setCompositionMode()`
    function. You can pick a desired composition mode from the auto-complete menu
    by typing `QPainter::CompositionMode`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要将合成效果应用到图像上，我们必须在绘制图像之前设置画家的合成模式，通过调用`painter.setCompositionMode()`函数。您可以通过输入`QPainter::CompositionMode`从自动完成菜单中选择所需的合成模式。
- en: In the previous example, we applied `QPainter::CompositionMode_Difference` to
    the checkered box on the left, which inverted its color. Next, we applied `QPainter::CompositionMode_Overlay`
    to the penguin, which makes it blend with the checkered pattern, and were able
    to see both images overlaying each other. On the right-hand side, we applied `QPainter::CompositionMode_Xor`
    to the checkered box, where, if differences exist between the source and destination,
    colors are shown; otherwise, it will be rendered black.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们将`QPainter::CompositionMode_Difference`应用于左侧的棋盘格方框，这反转了其颜色。接下来，我们将`QPainter::CompositionMode_Overlay`应用于企鹅，使其与棋盘格图案混合，从而能够看到两个图像重叠。在右侧，我们将`QPainter::CompositionMode_Xor`应用于棋盘格方框，如果源和目标之间存在差异，则显示颜色；否则，将渲染为黑色。
- en: Since it’s comparing differences with the white background, the non-transparent
    part of the checkered box becomes completely black. We also applied `QPainter::CompositionMode_SoftLight`
    to the butterfly image. This blends the pixels with the background with reduced
    contrast. If you want to disable the composition mode that you’ve just set for
    the previous rendering before proceeding to the next, simply set it back to the
    default mode, which is `QPainter::CompositionMode_SourceOver`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是与白色背景比较差异，所以棋盘格方框的不透明部分变成了完全黑色。我们还对蝴蝶图像应用了`QPainter::CompositionMode_SoftLight`。这会以降低对比度的方式将像素与背景混合。如果您想在继续进行下一渲染之前禁用之前设置的合成模式，只需将其设置回默认模式，即`QPainter::CompositionMode_SourceOver`。
- en: There’s more…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For example, we can overlay multiple images on top of each other and use Qt’s
    **Image Composition** feature to merge them together and calculate the resulting
    pixels on screen, based on the composition mode we used. This is often used in
    image editing software such as Photoshop and GIMP to composite image layers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在多个图像上方叠加，并使用Qt的**图像合成**功能将它们合并在一起，并根据我们使用的合成模式计算屏幕上的结果像素。这在像Photoshop和GIMP这样的图像编辑软件中经常用于合成图像图层。
- en: 'There are more than 30 types of composition modes available in Qt. Some of
    the most commonly used modes are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中提供了超过30种合成模式。以下是一些最常用的模式：
- en: '`Clear`: The pixels in the destination are set to fully transparent, independent
    of the source.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`清除`：目标像素设置为完全透明，与源无关。'
- en: '`Source`: The output is the source pixel. This mode is the inverse of `CompositionMode_Destination`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`源`：输出是源像素。此模式是`CompositionMode_Destination`的逆模式。'
- en: '`Destination`: The output is the destination pixel. This means that the blending
    has no effect. This mode is the inverse of `CompositionMode_Source`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标`: 输出是目标像素。这意味着混合没有效果。此模式是`CompositionMode_Source`的逆模式。'
- en: '`Source Over`: This is often referred to as `QPainter`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`源覆盖`: 这通常被称为`QPainter`。'
- en: '`Destination Over`: The output is the blend between the alpha of the destination
    on top of the source pixels. The opposite of this mode is `CompositionMode_SourceOver`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标覆盖`: 输出是覆盖在源像素上的目标alpha值的混合。此模式的相反是`CompositionMode_SourceOver`。'
- en: '`Source In`: The output is the source, where the alpha is reduced by that of
    the destination.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`源输入`: 输出是源，其中alpha值通过目标alpha值进行减少。'
- en: '`Destination In`: The output is the destination, where the alpha is reduced
    by that of the source. This mode is the inverse of `CompositionMode_SourceIn`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标输入`: 输出是目标，其中alpha值通过源alpha值进行减少。此模式是`CompositionMode_SourceIn`的逆模式。'
- en: '`Source Out`: The output is the source, where the alpha is reduced by the inverse
    of the destination.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`源输出`: 输出是源，其中alpha值通过目标值的倒数进行减少。'
- en: '`Destination Out`: The output is the destination, where the alpha is reduced
    by the inverse of the source. This mode is the inverse of `CompositionMode_SourceOut`.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标输出`: 输出是目标，其中alpha值通过源alpha值的倒数进行减少。此模式是`CompositionMode_SourceOut`的逆模式。'
- en: '`Source Atop`: The source pixel is blended on top of the destination, with
    the alpha of the source pixel reduced by the alpha of the destination pixel.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`源叠加`: 源像素在目标像素上方进行混合，源像素的alpha值通过目标像素的alpha值进行减少。'
- en: '`Destination Atop`: The destination pixel is blended on top of the source,
    with the alpha of the source pixel reduced by the alpha of the destination pixel.
    This mode is the inverse of `CompositionMode_SourceAtop`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标叠加`: 目标像素在源像素上方进行混合，源像素的alpha值通过目标像素的alpha值进行减少。此模式是`CompositionMode_SourceAtop`的逆模式。'
- en: '`Xor`: This is short for `Exclusive OR`, which is an advanced blending mode
    that is primarily used for image analysis. Using this is much more complicated
    with this composition mode. First, the alpha of the source is reduced by the inverse
    of the destination alpha. Then, the alpha of the destination is reduced by the
    inverse of the source alpha. Finally, both the source and destination are then
    merged to produce the output.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xor`: 这是“排他或”的缩写，这是一种主要用于图像分析的先进混合模式。使用此模式与这种合成模式相比要复杂得多。首先，通过目标alpha值的倒数减少源alpha值。然后，通过源alpha值的倒数减少目标alpha值。最后，将源和目标合并以产生输出。'
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information, you can visit this link: [https://pyside.github.io](https://pyside.github.io).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以访问此链接：[https://pyside.github.io](https://pyside.github.io)。
- en: 'The following figure shows the outcome of overlaying two images with different
    composition modes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用不同合成模式叠加两个图像的结果：
- en: '![Figure 4.12 – Different types of composition modes](img/B20976_04_012.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 不同类型的合成模式](img/B20976_04_012.jpg)'
- en: Figure 4.12 – Different types of composition modes
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 不同类型的合成模式
- en: Applying image effects to graphics
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像效果应用于图形
- en: Qt provides an easy way to add image effects to any graphics drawn using the
    `QPainter` class. In this example, we will learn how to apply different image
    effects, such as drop shadow, blur, colorize, and opacity effects, to a graphic
    before displaying it on screen.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一种简单的方法，可以将图像效果添加到使用`QPainter`类绘制的任何图形中。在本例中，我们将学习如何将不同的图像效果，如阴影、模糊、着色和透明度效果，应用于图形，然后再将其显示在屏幕上。
- en: How to do it…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s learn how to apply image effects to text and graphics by following these
    steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤学习如何将图像效果应用于文本和图形：
- en: Create a new `menuBar`, `mainToolBar`, and `StatusBar`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`menuBar`、`mainToolBar`和`StatusBar`。
- en: 'Create a new resource file by going to **File** | **New File or Project** and
    add all the images required by the project:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**文件** | **新建文件或项目**来创建一个新的资源文件，并将项目所需的所有图像添加进去：
- en: '![Figure 4.13 – Creating a new Qt resource file](img/B20976_04_013.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – 创建新的Qt资源文件](img/B20976_04_013.jpg)'
- en: Figure 4.13 – Creating a new Qt resource file
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – 创建新的Qt资源文件
- en: 'Next, open up `mainwindow.ui` and add four labels to the window. Two of the
    labels will be text, and the two others we will load with the images we have just
    added to the resource file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`mainwindow.ui`文件，并在窗口中添加四个标签。其中两个标签将是文本，另外两个我们将加载到资源文件中我们刚刚添加的图像：
- en: '![Figure 4.14 – Application filled with text and images](img/B20976_04_014.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – 填充文本和图像的应用](img/B20976_04_014.jpg)'
- en: Figure 4.14 – Application filled with text and images
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 填满文本和图像的应用程序
- en: 'You may already notice that the font sizes are way bigger than the default
    size. That can be achieved by adding a style sheet to the label widget, for example,
    as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到字体大小比默认大小大得多。这可以通过向标签小部件添加样式表来实现，例如，如下所示：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, open up `mainwindow.cpp` and include the following headers at the
    top of the source code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.cpp`并在源代码顶部包含以下头文件：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, within the constructor of the `MainWindow` class, add the following code
    to create a `DropShadowEffect`, and apply it to one of the labels:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`MainWindow`类的构造函数中，添加以下代码来创建一个`DropShadowEffect`并将其应用于一个标签：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we will create `ColorizedEffect` and apply it to one of the images, in
    this case, the butterfly. We also set the effect color to red:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`ColorizedEffect`并将其应用于其中一张图片，在这种情况下，是蝴蝶。我们还设置了效果颜色为红色：
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once we’re done with that, create `BlurEffect` and set its radius to `12`.
    Then, apply the graphics effect to the other label:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，创建`BlurEffect`并将其半径设置为`12`。然后，将图形效果应用于其他标签：
- en: '[PRE40]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Lastly, create an alpha effect and apply it to the penguin image. We set the
    opacity value to `0.2`, which means 20% opacity:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个alpha效果并将其应用于企鹅图片。我们将不透明度值设置为`0.2`，这意味着20%的不透明度：
- en: '[PRE41]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, compile and run the program and you should be able to see something like
    this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行程序，你应该能看到类似这样的效果：
- en: '![Figure 4.15 – Different types of graphics effects being applied to the texts
    and images](img/B20976_04_015.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 将不同类型的图形效果应用于文本和图像](img/B20976_04_015.jpg)'
- en: Figure 4.15 – Different types of graphics effects being applied to the texts
    and images
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 将不同类型的图形效果应用于文本和图像
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each of the graphic effects is a class of its own that inherits the `QGraphicsEffect`
    parent class. You can create your own custom effect by creating a new class that
    inherits `QGraphicsEffect` and re-implementing some of the functions in it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形效果都是一个继承自`QGraphicsEffect`父类的类。你可以通过创建一个新的继承自`QGraphicsEffect`的类并重新实现其中的一些函数来创建自己的自定义效果。
- en: Each effect has its own set of variables that are specifically created for it.
    For example, you can set the color of the colorized effect, but there is no such
    variable in the blur effect. This is because each effect is vastly different from
    the others, which is also why it needs to be a class of its own rather than using
    the same class for all the different effects.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个效果都有自己的一组变量，这些变量专门为它创建。例如，你可以设置着色效果的色彩，但在模糊效果中没有这样的变量。这是因为每个效果与其他效果大不相同，这也是为什么它需要成为一个单独的类，而不是使用相同的类来处理所有不同的效果。
- en: It’s only possible to add a single graphics effect to a widget at a time. If
    you add more than one effect, only the last one will be applied to the widget,
    as it replaces the previous one. Other than that, be aware that if you create
    a graphics effect, for example, the drop shadow effect, you can’t assign it to
    two different widgets, as it will only get assigned to the last widget you applied
    it to. If you need to apply the same type of effect to several different widgets,
    create a few graphics effects of the same type and apply each of them to their
    respective widgets.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一时间只能向小部件添加一个图形效果。如果你添加了多个效果，只有最后一个效果会被应用于小部件，因为它会替换前面的一个。除此之外，请注意，如果你创建了一个图形效果，例如，阴影效果，你不能将其分配给两个不同的小部件，因为它只会分配到最后一个应用了它的小部件。如果你需要将相同类型的效应应用于多个不同的小部件，请创建几个相同类型的图形效果，并将每个效果应用于相应的小部件。
- en: There’s more…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Currently, Qt supports blur, drop shadow, colorize, and opacity effects. These
    effects can be used by calling the following classes: `QGraphicsBlurEffect`, `QGraphicsDropShadowEffect`,
    `QGraphicsColorizeEffect`, and `QGraphicsOpacityEffect`. All these classes are
    inherited from the `QGraphicsEffect` class. You can also create your own custom
    image effect by creating a subclass of `QGrapicsEffect` (or any other existing
    effects) and re-implementing the `draw()` function.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Qt支持模糊、阴影、着色和不透明度效果。这些效果可以通过调用以下类来使用：`QGraphicsBlurEffect`、`QGraphicsDropShadowEffect`、`QGraphicsColorizeEffect`和`QGraphicsOpacityEffect`。所有这些类都是继承自`QGraphicsEffect`类的。你也可以通过创建`QGrapicsEffect`（或任何其他现有效果）的子类并重新实现其中的`draw()`函数来创建自己的自定义图像效果。
- en: The graphics effect changes only the bounding rectangle of the source. If you
    want to increase the margin of the bounding rectangle, re-implement the virtual
    `boundingRectFor()` function, and call `updateBoundingRect()` to notify the framework
    whenever this rectangle changes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图形效果只改变源矩形的边界框。如果你想增加边界框的边距，重新实现虚拟函数`boundingRectFor()`，并调用`updateBoundingRect()`来通知框架每次此矩形变化时：
- en: Creating a basic paint program
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的绘图程序
- en: Since we have learned so much about the `QPainter` class and how to use it to
    display graphics on screen, I guess it’s time for us to do something fun where
    we can put our knowledge into practice.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学到了很多关于`QPainter`类及其如何在屏幕上显示图形的知识，我想现在是时候让我们做一些有趣的事情，将我们的知识付诸实践了。
- en: In this recipe, we will learn how to make a basic paint program that allows
    us to draw lines on a canvas with different brush sizes and colors. We will also
    learn how to use the `QImage` class and mouse events in order to construct the
    paint program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何制作一个基本的绘图程序，允许我们使用不同的画笔大小和颜色在画布上绘制线条。我们还将学习如何使用`QImage`类和鼠标事件来构建绘图程序。
- en: How to do it…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s start our fun project with the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始我们的有趣项目：
- en: Again, we start by creating a new **Qt Widgets Application** project and removing
    the toolbar and status bar. We will keep the menu bar this time.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们首先创建一个新的**Qt Widgets Application**项目，并移除工具栏和状态栏。这次我们将保留菜单栏。
- en: 'After that, set up the menu bar like so:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按照如下设置菜单栏：
- en: '![Figure 4.16 – Setting up the menu bar](img/B20976_04_016.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – 设置菜单栏](img/B20976_04_016.jpg)'
- en: Figure 4.16 – Setting up the menu bar
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 设置菜单栏
- en: 'We will leave the menu bar as it is for the moment, so let’s proceed to the
    `mainwindow.h` file. First, include the following header files, as they are required
    for the project:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们暂时保持菜单栏不变，所以让我们继续到`mainwindow.h`文件。首先，包含以下头文件，因为它们是项目所需的：
- en: '[PRE42]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, declare the variables that we’ll be using for this project, like so:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明我们将在这个项目中使用的变量，如下所示：
- en: '[PRE43]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'public:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public:'
- en: explicit MainWindow(QWidget *parent = 0);
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: explicit MainWindow(QWidget *parent = 0);
- en: ~MainWindow();
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ~MainWindow();
- en: virtual void mousePressEvent(QMouseEvent *event);
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: virtual void mousePressEvent(QMouseEvent *event);
- en: virtual void mouseMoveEvent(QMouseEvent *event);
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: virtual void mouseMoveEvent(QMouseEvent *event);
- en: virtual void mouseReleaseEvent(QMouseEvent *event);
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: virtual void mouseReleaseEvent(QMouseEvent *event);
- en: virtual void paintEvent(QPaintEvent *event);
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: virtual void paintEvent(QPaintEvent *event);
- en: 'mainwindow.cpp file and add the following code to the class constructor to
    set up some of the variables:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`mainwindow.cpp`文件中添加以下代码到类构造函数中，以设置一些变量：
- en: '[PRE44]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we will construct the `mousePressEvent()` event and tell Qt what to do
    when the left mouse button is pressed:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将构建`mousePressEvent()`事件，并告诉Qt当左键被按下时应该做什么：
- en: '[PRE46]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we will construct the `mouseMoveEvent()` event and tell Qt what to do
    when the mouse is moving. In this case, we want to draw the lines on the canvas
    if the left mouse button is being held:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将构建`mouseMoveEvent()`事件，并告诉Qt当鼠标移动时应该做什么。在这种情况下，如果左键被按下，我们想在画布上绘制线条：
- en: '[PRE47]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After that, we will also construct the `mouseReleaseEvent()` event, which will
    be triggered when the mouse button is released:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们还将构建`mouseReleaseEvent()`事件，该事件将在鼠标按钮释放时触发：
- en: '[PRE48]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once you’re done with that, we will proceed to the `paintEvent()` event, which
    is surprisingly simple compared to the other examples we have seen in previous
    sections:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们将继续到`paintEvent()`事件，与之前章节中看到的其他示例相比，这个事件非常简单：
- en: '[PRE49]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Remember how we have a menu bar sitting around doing nothing? Let’s right-click
    on each of the actions below the GUI editor and select **Go to slot…** in the
    pop-up menu. We want to tell Qt what to do when each of these options on the menu
    bar is selected:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得我们有一个菜单栏在那里无所事事吗？让我们在GUI编辑器下面的每个动作上右键单击，并在弹出菜单中选择**转到槽函数…**。我们想要告诉Qt当菜单栏上的每个选项被选中时应该做什么：
- en: '![Figure 4.17 – Creating slot function for each of the menu actions](img/B20976_04_017.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17 – 为每个菜单动作创建槽函数](img/B20976_04_017.jpg)'
- en: Figure 4.17 – Creating slot function for each of the menu actions
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 为每个菜单动作创建槽函数
- en: 'Then, select the default slot called `triggered()` and press the `mainwindow.h`
    and `mainwindow.cpp` files. Once you are done with all the actions, you should
    see something like this in your `mainwindow.h` file:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择默认的槽函数`triggered()`，并按`mainwindow.h`和`mainwindow.cpp`文件。完成所有操作后，你应该能在你的`mainwindow.h`文件中看到如下内容：
- en: '[PRE50]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we will tell Qt what to do when each of these slots is triggered:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将告诉 Qt 在这些槽被触发时应该做什么：
- en: '[PRE51]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we continue to implement the other slots:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续实现其他槽：
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we implement the rest of the slot functions:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现其余的槽函数：
- en: '[PRE53]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we compile and run the program now, we will get a simple but usable paint
    program:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在编译并运行程序，我们将得到一个简单但可用的绘图程序：
- en: '![Figure 4.18 – Our lovely paint program in action!](img/B20976_04_018.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 我们可爱的绘图程序正在运行！](img/B20976_04_018.jpg)'
- en: Figure 4.18 – Our lovely paint program in action!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 我们可爱的绘图程序正在运行！
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we created a `QImage` widget when the program started. This
    widget acts as the canvas and will follow the size of the window whenever the
    window gets resized. In order to draw something on the canvas, we will need to
    use the mouse events provided by Qt. These events will tell us the position of
    the cursor, and we will be able to use this information to change the pixels on
    the canvas.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在程序启动时创建了一个 `QImage` 小部件。这个小部件充当画布，并且每当窗口大小改变时都会跟随窗口的大小。为了在画布上绘制东西，我们需要使用
    Qt 提供的鼠标事件。这些事件会告诉我们光标的位置，我们可以使用这些信息来改变画布上的像素。
- en: We use a Boolean variable called `drawing` to let the program know whether it
    should start drawing when a mouse button is pressed. In this case, when the left
    mouse button is pressed, the `drawing` variable will be set to `true`. We also
    save the current cursor position to the `lastPoint` variable when the left mouse
    button is pressed, so that Qt will know where it should start drawing. When the
    mouse moves, the `mouseMoveEvent()` event will be triggered by Qt. This is where
    we need to check whether the drawing variable is set to `true`. If it is, then
    `QPainter` can start drawing the lines onto the `QImage` widget based on the brush
    settings that we provide. The brush settings consist of `brushColor` and `brushSize`.
    These settings are saved as variables and can be altered by selecting a different
    setting from the menu bar.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为 `drawing` 的布尔变量来让程序知道当鼠标按钮被按下时是否应该开始绘图。在这种情况下，当左键被按下时，`drawing` 变量将被设置为
    `true`。我们还在左键被按下时将当前光标位置保存到 `lastPoint` 变量中，这样 Qt 就会知道它应该从哪里开始绘图。当鼠标移动时，Qt 将触发
    `mouseMoveEvent()` 事件。这就是我们需要检查绘图变量是否被设置为 `true` 的地方。如果是，那么 `QPainter` 可以根据我们提供的画笔设置开始在
    `QImage` 小部件上绘制线条。画笔设置包括 `brushColor` 和 `brushSize`。这些设置被保存为变量，并且可以通过从菜单栏选择不同的设置来更改。
- en: Please remember to call the `update()` function when the user is drawing on
    the canvas. Otherwise, the canvas will remain empty even though we have changed
    the pixel information of the canvas. We also have to call the `update()` function
    when we select **File** | **Clear** from the menu bar to reset our canvas.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当用户在画布上绘图时调用 `update()` 函数。否则，即使我们改变了画布的像素信息，画布也将保持空白。我们还需要在从菜单栏选择 **文件**
    | **清除** 时调用 `update()` 函数来重置我们的画布。
- en: In this example, we use `QImage::save()` to save the image file, which is very
    straightforward. We use the file dialog to let the user decide where to save the
    image and its desired filename. Then, we pass the information to `QImage`, and
    it will do the rest by itself. If we don’t specify the file format to the `QImage::save()`
    function, `QImage` will try to figure it out by looking at the extension of the
    desired filename.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `QImage::save()` 来保存图像文件，这非常直接。我们使用文件对话框让用户决定保存图像的位置和期望的文件名。然后，我们将信息传递给
    `QImage`，它将自行完成剩余的工作。如果我们没有指定 `QImage::save()` 函数的文件格式，`QImage` 将通过查看期望文件名的扩展名来尝试自己找出它。
- en: Rendering a 2D canvas in QML
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 QML 中渲染 2D 画布
- en: In all the previous examples of this chapter, we have discussed the methods
    and techniques used to render 2D graphics with Qt’s C++ API. However, we have
    yet to learn how to achieve similar results using the powerful QML script.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有前例中，我们讨论了使用 Qt 的 C++ API 渲染 2D 图形的方法和技术。然而，我们还没有学习如何使用强大的 QML 脚本达到类似的效果。
- en: How to do it…
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this project, we’ll be doing something quite different:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将做一些相当不同的事情：
- en: 'As usual, the first step is to create a new project by going to **File** |
    **New File or Project** and selecting **Qt Quick Application** as the project
    template:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，第一步是创建一个新的项目，通过访问 **文件** | **新建文件或项目** 并选择 **Qt 快速应用程序** 作为项目模板：
- en: '![Figure 4.19 – Creating a new Qt Quick Application project](img/B20976_04_019.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 创建新的 Qt 快速应用程序项目](img/B20976_04_019.jpg)'
- en: Figure 4.19 – Creating a new Qt Quick Application project
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 创建新的Qt Quick应用程序项目
- en: 'Once you are done creating the new project, open up `main.qml`, which is listed
    under `qml.qrc` in the project pane. After that, set an ID for the window and
    adjust its `width` and `height` values to larger values, like so:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完新项目后，打开`main.qml`，它在项目面板下的`qml.qrc`中列出。之后，为窗口设置一个ID，并将它的`width`和`height`值调整到更大的值，如下所示：
- en: '[PRE54]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, add a `Canvas` object under `myWindow` and call it `myCanvas`. After
    that, we make its `width` and `height` values the same as `myWindow`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`myWindow`下添加一个`Canvas`对象，并将其命名为`myCanvas`。之后，我们将它的`width`和`height`值设置为与`myWindow`相同：
- en: '[PRE55]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we define what will happen when the `onPaint` event is triggered; in
    this case, we will draw a cross on the window:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义当`onPaint`事件被触发时会发生什么；在这种情况下，我们将在窗口上绘制一个十字：
- en: '[PRE56]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s continue to write the code, like so:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续编写代码，如下所示：
- en: '[PRE57]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After that, we add the following code to draw a tick beside the cross:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加以下代码在十字交叉处绘制一个勾号：
- en: '[PRE58]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, draw a triangle shape by adding the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过添加以下代码绘制一个三角形形状：
- en: '[PRE59]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After that, draw a half circle and a full circle with the following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用以下代码绘制一个半圆和一个完整圆：
- en: '[PRE60]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we draw an arc:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们绘制一个圆弧：
- en: '[PRE61]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we draw a 2D image from a file:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从文件中绘制一个2D图像：
- en: '[PRE62]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'However, the preceding code alone will not successfully render an image on
    screen because you must also load the image file beforehand. Add the following
    code within the `Canvas` object to ask QML to load the image file when the program
    is started, then call the `requestPaint()` signal when the image is loaded so
    that the `onPaint()` event slot will be triggered:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，仅凭前面的代码无法在屏幕上成功渲染图像，因为你必须先加载图像文件。在`Canvas`对象中添加以下代码，以便在程序启动时让QML加载图像文件，然后在图像加载后调用`requestPaint()`信号，以便触发`onPaint()`事件槽：
- en: '[PRE63]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, open up `qml.qrc` by right-clicking it in the project panel and select
    `tux.png` image file to our project resource:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在项目面板中右键单击`qml.qrc`并选择将`tux.png`图像文件添加到我们的项目资源中打开它：
- en: '![Figure 4.20 – The tux.png image file is now listed under qml.qrc](img/B20976_04_020.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20 – tux.png图像文件现在在qml.qrc下列出](img/B20976_04_020.jpg)'
- en: Figure 4.20 – The tux.png image file is now listed under qml.qrc
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – tux.png图像文件现在在qml.qrc下列出
- en: 'Now, build and run the program and you should get the following:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行程序，你应该会得到以下结果：
- en: '![Figure 4.21 – Tux the penguin is amused by the geometrical shapes](img/B20976_04_021.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21 – 图形形状让企鹅图克斯感到有趣](img/B20976_04_021.jpg)'
- en: Figure 4.21 – Tux the penguin is amused by the geometrical shapes
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 – 图形形状让企鹅图克斯感到有趣
- en: In the preceding example, we learned how to draw simple vector shapes on our
    screen using the `Canvas` element. Qt’s built-in modules make the complex rendering
    process more straightforward for programmers.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们学习了如何使用`Canvas`元素在我们的屏幕上绘制简单的矢量形状。Qt的内置模块使程序员对复杂渲染过程的处理更加简单。
