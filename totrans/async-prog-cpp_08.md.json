["```cpp\nprocessing_result process_data(data_block data) {\n    while (do_processing == true) {\n        result_type result{ 0 };\n        result = process_data_block(previous_result);\n        update_database();\n        yield result;\n    }\n}\n```", "```cpp\n void coroutine() {\n    do_something();\n    co_yield;\n    do_something_else();\n    co_yield;\n    do_more_work();\n    co_return;\n}\n```", "```cpp\nvoid coro_func() {\n    co_return;\n}\nint main() {\n    coro_func();\n}\n```", "```cpp\nerror: coroutines require a traits template; cannot find 'std::coroutine_traits'\n```", "```cpp\nnote: perhaps '#include <coroutine>' is missing\n```", "```cpp\n#include <coroutine>\nvoid coro_func() {\n    co_return;\n}\nint main() {\n    coro_func();\n}\n```", "```cpp\n error: unable to find the promise type for this coroutine\n```", "```cpp\n#include <coroutine>\nstruct return_type {\n    struct promise_type {\n    };\n};\ntemplate<>\nstruct std::coroutine_traits<return_type> {\n    using promise_type = return_type::promise_type;\n};\nreturn_type coro_func() {\n    co_return;\n}\nint main() {\n    coro_func();\n}\n```", "```cpp\nerror: no member named 'return_void' in 'std::__n4861::coroutine_traits<return_type>::promise_type'\nerror: no member named 'initial_suspend' in 'std::__n4861::coroutine_traits<return_type>::promise_type'\nerror: no member named 'unhandled_exception' in 'std::__n4861::coroutine_traits<return_type>::promise_type'\nerror: no member named 'final_suspend' in 'std::__n4861::coroutine_traits<return_type>::promise_type'\nerror: no member named 'get_return_object' in 'std::__n4861::coroutine_traits<return_type>::promise_type'\n```", "```cpp\n#include <coroutine>\nstruct return_type {\n    struct promise_type {\n        return_type get_return_object() noexcept {\n            return return_type{ *this };\n        }\n        void return_void() noexcept {}\n        std::suspend_always initial_suspend() noexcept {\n            return {};\n        }\n        std::suspend_always final_suspend() noexcept {\n            return {};\n        }\n        void unhandled_exception() noexcept {}\n    };\n    explicit return_type(promise_type&) {\n    }\n    ~return_type() noexcept {\n    }\n};\nreturn_type coro_func() {\n    co_return;\n}\nint main() {\n    coro_func();\n}\n```", "```cpp\nreturn_type coro_func() {\n    co_yield \"Hello from the coroutine\\n\"s;\n    co_return;\n}\nint main() {\n    auto rt = coro_func();\n    std::cout << rt.get() << std::endl;\n    return 0;\n}\n```", "```cpp\nstd::suspend_always yield_value(std::string msg) noexcept {\n    output_data = std::move(msg);\n    return {};\n}\n```", "```cpp\nstd::coroutine_handle<promise_type> handle{};\nexplicit return_type(promise_type& promise) : handle{ std::coroutine_handle<promise_type>::from_promise(promise)} {\n}\n~return_type() noexcept {\n    if (handle) {\n        handle.destroy();\n    }\n}\n```", "```cpp\nstd::string get() {\n    if (!handle.done()) {\n        handle.resume();\n    }\n    return std::move(handle.promise().output_data);\n}\n```", "```cpp\n#include <coroutine>\n#include <iostream>\n#include <string>\nusing namespace std::string_literals;\nstruct return_type {\n    struct promise_type {\n        std::string output_data { };\n        return_type get_return_object() noexcept {\n            std::cout << \"get_return_object\\n\";\n            return return_type{ *this };\n        }\n        void return_void() noexcept {\n            std::cout << \"return_void\\n\";\n        }\n        std::suspend_always yield_value(\n                         std::string msg) noexcept {\n            std::cout << \"yield_value\\n\";\n            output_data = std::move(msg);\n            return {};\n        }\n        std::suspend_always initial_suspend() noexcept {\n            std::cout << \"initial_suspend\\n\";\n            return {};\n        }\n        std::suspend_always final_suspend() noexcept {\n            std::cout << \"final_suspend\\n\";\n            return {};\n        }\n        void unhandled_exception() noexcept {\n            std::cout << \"unhandled_exception\\n\";\n        }\n    };\n    std::coroutine_handle<promise_type> handle{};\n    explicit return_type(promise_type& promise)\n       : handle{ std::coroutine_handle<\n                 promise_type>::from_promise(promise)}{\n        std::cout << \"return_type()\\n\";\n    }\n    ~return_type() noexcept {\n        if (handle) {\n            handle.destroy();\n        }\n        std::cout << \"~return_type()\\n\";\n    }\n    std::string get() {\n        std::cout << \"get()\\n\";\n        if (!handle.done()) {\n            handle.resume();\n        }\n        return std::move(handle.promise().output_data);\n    }\n};\nreturn_type coro_func() {\n    co_yield \"Hello from the coroutine\\n\"s;\n    co_return;\n}\nint main() {\n    auto rt = coro_func();\n    std::cout << rt.get() << std::endl;\n    return 0;\n}\n```", "```cpp\nget_return_object\nreturn_type()\ninitial_suspend\nget()\nyield_value\nHello from the coroutine\n~return_type()\n```", "```cpp\nreturn_type coro_func() {\n    std::cout << co_await std::string{ };\n    co_return;\n}\nint main() {\n    auto rt = coro_func();\n    rt.put(\"Hello from main\\n\"s);\n    return 0;\n}\n```", "```cpp\nvoid put(std::string msg) {\n    handle.promise().input_data = std::move(msg);\n    if (!handle.done()) {\n        handle.resume();\n    }\n}\n```", "```cpp\nerror: no member named 'await_ready' in 'std::string' {aka 'std::__cxx11::basic_string<char>'}\n```", "```cpp\nauto await_transform(std::string) noexcept {\n    struct awaiter {\n        promise_type& promise;\n        bool await_ready() const noexcept {\n            return true;\n        }\n        std::string await_resume() const noexcept {\n            return std::move(promise.input_data);\n        }\n        void await_suspend(std::coroutine_handle<\n                           promise_type>) const noexcept {\n        }\n   };\n   return awaiter(*this);\n}\n```", "```cpp\n#include <coroutine>\n#include <iostream>\n#include <string>\nusing namespace std::string_literals;\nstruct return_type {\n    struct promise_type {\n        std::string input_data { };\n        return_type get_return_object() noexcept {\n            return return_type{ *this };\n        }\n        void return_void() noexcept {\n        }\n        std::suspend_always initial_suspend() noexcept {\n            return {};\n        }\n        std::suspend_always final_suspend() noexcept {\n            return {};\n        }\n        void unhandled_exception() noexcept {\n        }\n        auto await_transform(std::string) noexcept {\n            struct awaiter {\n                promise_type& promise;\n                bool await_ready() const noexcept {\n                    return true;\n                }\n                std::string await_resume() const noexcept {\n                    return std::move(promise.input_data);\n                }\n                void await_suspend(std::coroutine_handle<\n                                  promise_type>) const noexcept {\n                }\n            };\n            return awaiter(*this);\n        }\n    };\n    std::coroutine_handle<promise_type> handle{};\n    explicit return_type(promise_type& promise)\n      : handle{ std::coroutine_handle<\n                         promise_type>::from_promise(promise)} {\n    }\n    ~return_type() noexcept {\n        if (handle) {\n            handle.destroy();\n        }\n    }\n    void put(std::string msg) {\n        handle.promise().input_data = std::move(msg);\n        if (!handle.done()) {\n            handle.resume();\n        }\n    }\n};\nreturn_type coro_func() {\n    std::cout << co_await std::string{ };\n    co_return;\n}\nint main() {\n    auto rt = coro_func();\n    rt.put(\"Hello from main\\n\"s);\n    return 0;\n}\n```", "```cpp\nint main() {\n    sequence_generator<int64_t> fib = fibonacci();\n    std::cout << \"Generate ten Fibonacci numbers\\n\"s;\n    for (int i = 0; i < 10; ++i) {\n        fib.next();\n        std::cout << fib.value() << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"Generate ten more\\n\"s;\n    for (int i = 0; i < 10; ++i) {\n        fib.next();\n        std::cout << fib.value() << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"Let's do five more\\n\"s;\n    for (int i = 0; i < 5; ++i) {\n        fib.next();\n        std::cout << fib.value() << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n```", "```cpp\nsequence_generator<int64_t> fibonacci() {\n    int64_t a{ 0 };\n    int64_t b{ 1 };\n    int64_t c{ 0 };\n    while (true) {\n        co_yield a;\n        c = a + b;\n        a = b;\n        b = c;\n    }\n}\n```", "```cpp\nvoid next() {\n    if (!handle.done()) {\n        handle.resume();\n    }\n}\n```", "```cpp\nint64_t value() {\n    return handle.promise().output_data;\n}\n```", "```cpp\n#include <generator>\n#include <iostream>\nstd::generator<int> fibonacci_generator() {\n    int a{ };\n    int b{ 1 };\n    while (true) {\n        co_yield a;\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n}\nauto fib = fibonacci_generator();\nint main() {\n    int i = 0;\n    for (auto f = fib.begin(); f != fib.end(); ++f) {\n        if (i == 10) {\n            break;\n        }\n        std::cout << *f << \" \";\n        ++i;\n    }\n    std::cout << std::endl;\n}\n```", "```cpp\nstd::generator<int> fibonacci_generator(int limit) {\n    int a{ };\n    int b{ 1 };\n    while (limit--) {\n        co_yield a;\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n}\n```", "```cpp\nint64_t parse_string(const std::string& str) {\n    int64_t num{ 0 };\n    int64_t sign { 1 };\n    std::size_t c = 0;\n    while (c < str.size()) {\n        if (str[c] == '-') {\n            sign = -1;\n        }\n        else if (std::isdigit(str[c])) {\n            num = num * 10 + (str[c] - '0');\n        }\n        else if (str[c] == '#') {\n            break;\n        }\n        ++c;\n    }\n    return num * sign;\n}\n```", "```cpp\nasync_parse<int64_t, char> parse_string() {\n    while (true) {\n        char c = co_await char{ };\n        int64_t number { };\n        int64_t sign { 1 };\n        if (c != '-' && c != '+' && !std::isdigit(c)) {\n            continue;\n        }\n        if (c == '-') {\n            sign = -1;\n        }\n        else if (std::isdigit(c)) {\n            number = number * 10 + c - '0';\n        }\n        while (true) {\n            c = co_await char{};\n            if (std::isdigit(c)) {\n                number = number * 10 + c - '0';\n            }\n            else {\n                break;\n            }\n        }\n        co_yield number * sign;\n    }\n}\n```", "```cpp\ntemplate <typename Out, typename In>\nstruct async_parse {\n// …\n};\n```", "```cpp\nstd::optional<In> input_data { };\nOut output_data { };\n```", "```cpp\n void put(char c) {\n    handle.promise().input_data = c;\n    if (!handle.done()) {\n        handle.resume();\n    }\n}\n```", "```cpp\nauto await_transform(char) noexcept {\n    struct awaiter {\n        promise_type& promise;\n        [[nodiscard]] bool await_ready() const noexcept {\n            return promise.input_data.has_value();\n        }\n        [[nodiscard]] char await_resume() const noexcept {\n            assert (promise.input_data.has_value());\n            return *std::exchange(\n                            promise.input_data,\n                            std::nullopt);\n        }\n        void await_suspend(std::coroutine_handle<\n                           promise_type>) const noexcept {\n        }\n    };\n    return awaiter(*this);\n}\n```", "```cpp\nvoid unhandled_exception() noexcept {}\n```"]