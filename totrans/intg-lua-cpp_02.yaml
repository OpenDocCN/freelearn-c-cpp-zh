- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Lua Fundamentals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua 基础知识
- en: In this chapter, we will learn the basics of the Lua programming language. You
    do not need to be a Lua expert or even write any Lua code if you only work on
    the C++ side. However, understanding the basics will make you more efficient when
    integrating Lua into C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Lua 编程语言的基础知识。如果你只专注于 C++ 端，你不需要成为 Lua 专家，甚至不需要编写任何 Lua 代码。然而，了解基础知识将使你在将
    Lua 集成到 C++ 中时更加高效。
- en: 'If you already know Lua programming, you can skip this chapter. If you have
    not used Lua for a while, you can use this chapter to recap. If you want to learn
    more about Lua programming, you can get the official Lua book: *Programming in
    Lua*. If you do not know Lua programming, this chapter is for you. Coming from
    C++, you can read any Lua code with the brief explanations on Lua code in this
    book. You can believe in yourself and research online when you need to.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经了解 Lua 编程，你可以跳过本章。如果你有一段时间没有使用 Lua，你可以使用本章来复习。如果你想了解更多关于 Lua 编程的知识，你可以获取官方
    Lua 书籍：*Programming in Lua*。如果你不知道 Lua 编程，本章是为你准备的。如果你来自 C++，你可以阅读本书中关于 Lua 代码的简要说明来阅读任何
    Lua 代码。当你需要时，你可以相信自己并在线上进行研究。
- en: 'We will talk about the following language features:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下语言特性：
- en: Variables and types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和类型
- en: Control structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will use the interactive Lua interpreter to follow the code examples in
    this chapter. We have built it from the Lua source code in *Chapter 1*. You can
    also use a Lua interpreter from another channel, for example, the one installed
    by your operating system’s package manager. Before continuing, make sure you have
    access to one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用交互式 Lua 解释器来跟随本章中的代码示例。我们是从 *第 1 章* 中的 Lua 源代码构建的。你也可以使用来自其他渠道的 Lua 解释器，例如，由你的操作系统包管理器安装的那个。在继续之前，请确保你有访问权限。
- en: 'When you see code examples in this chapter, like the following one, you should
    try the example in an interactive Lua shell:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本章中看到代码示例，如以下示例，你应该在交互式 Lua 命令行中尝试该示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line is what the Lua interpreter outputs when it starts. Use `os.exit()`
    to quit the interpreter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 解释器启动时输出的第一行是。使用 `os.exit()` 退出解释器。
- en: 'You can find the source code for this chapter within the book’s GitHub repository:
    [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的源代码：[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02)
- en: Variables and types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和类型
- en: While you may well know that C++ is a statically-typed language, Lua is a dynamically-typed
    language. In C++, when you declare a variable, you give it a clear type. In Lua,
    each value carries its own type, and you do not need to explicitly specify a type.
    Also, you do not need to define a global variable before referencing it. Although
    you are encouraged to declare it – or better yet, use local variables. We will
    learn about local variables later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能很清楚 C++ 是一种静态类型语言，但 Lua 是一种动态类型语言。在 C++ 中，当你声明一个变量时，你会给它一个明确的类型。在 Lua 中，每个值都携带自己的类型，你不需要显式指定类型。此外，在引用它之前，你不需要定义全局变量。尽管鼓励你声明它——或者更好的是，使用局部变量。我们将在本章后面学习局部变量。
- en: 'In Lua, there are eight basic types: **nil**, **boolean**, **number**, **string**,
    **userdata**, **function**, **thread**, and **table**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lua 中，有八个基本类型：**nil**、**boolean**、**number**、**string**、**userdata**、**function**、**thread**
    和 **table**。
- en: 'We will learn about six of these in this chapter: `nil`, `boolean`, `number`,
    `string`, `table`, and `function`. Let’s try some before we go into the details:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习其中的六个：`nil`、`boolean`、`number`、`string`、`table` 和 `function`。在我们深入了解之前，让我们尝试一些：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What happens here is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况如下：
- en: Interactively, type `a` to check the value of the global variable `a`. Since
    it’s not defined yet, its value is `nil`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交互式地，输入 `a` 检查全局变量 `a` 的值。由于它尚未定义，其值为 `nil`。
- en: Check the type of variable `a` with `type(a)`. The value is `nil` in this case
    because it is not defined.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `type(a)` 检查变量 `a` 的类型。在这种情况下，值是 `nil`，因为它尚未定义。
- en: Assign `true` to `a`. Use `=` for assignment; the same as in C++.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `true` 赋值给 `a`。使用 `=` 进行赋值；与 C++ 中的用法相同。
- en: Now, its type is `boolean`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它的类型是 `boolean`。
- en: Assign `6` to `a`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `6` 赋值给 `a`。
- en: Now, its type is `number`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它的类型是 `number`。
- en: Assign `"bonjour"` to `a`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `"bonjour"` 赋值给 `a`。
- en: Now, its type is `string`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它的类型是 `string`。
- en: Every line executed there is also a Lua statement. Unlike a C++ statement, you
    do not need to put a semicolon at the end of it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里执行的每一行也是 Lua 语句。与 C++ 语句不同，你不需要在语句末尾放置分号。
- en: Next, we will learn more about some of the types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习更多关于这些类型的内容。
- en: Nil
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值
- en: 'The `nil` type has only one value to represent a non-value: `nil`. Its meaning
    is similar to that of **nullptr** (or **NULL**) in C++.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`nil` 类型只有一个值来表示非值：`nil`。它的意义与 C++ 中的 **nullptr**（或 **NULL**）类似。'
- en: Booleans
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: The `boolean` type has two values. They are *true* and *false*. It does what
    **bool** does in C++.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型有两个值。它们是 *true* 和 *false*。它在 Lua 中的行为与 C++ 中的 **bool** 相同。'
- en: Numbers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: The `number` type covers C++’s **int**, **float**, and **double**, and their
    variants (such as **long**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 类型涵盖了 C++ 的 **int**、**float** 和 **double** 以及它们的变体（例如 **long**）。'
- en: Here, we will also learn about Lua arithmetic operators and relational operators,
    as these are mostly used on numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还将学习 Lua 的算术运算符和关系运算符，因为它们主要用于数字。
- en: Arithmetic operators
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'An arithmetic operator is an operator that performs arithmetic operations on
    numbers. Lua supports *six* arithmetic operators:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符是执行数字算术运算的运算符。Lua 支持 *六个* 算术运算符：
- en: '`+`: Addition'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`: 加法'
- en: '`-`: Subtraction'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`: 减法'
- en: '`*`: Multiplication'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`: 乘法'
- en: '`/`: Division'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: 除法'
- en: '`%`: Modulus'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`: 取模'
- en: '`//`: Floor Division'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`: 向下取整除法'
- en: 'C++ has seven arithmetic operators: +, -, *, /, %, ++ and --. Lua’s arithmetic
    operators are similar to their C++ counterparts, except for the following differences:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有七个算术运算符：+、-、*、/、%、++ 和 --。Lua 的算术运算符与它们的 C++ 对应项类似，但有以下不同之处：
- en: There is no ++ or -- operator.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有自增（++）或自减（--）运算符。
- en: 'C++ does not have the `//` operator, which returns the integer part of the
    result after division. C++ can achieve the same implicitly with normal division
    because C++ is strongly-typed. This we can see in the following example:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ 没有返回除法结果整数部分的 `//` 运算符。由于 C++ 是强类型语言，C++ 可以通过正常除法隐式地实现相同的功能。以下是一个例子：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that Lua is a dynamically-typed language. This means 5 / 3 does not produce
    1 as C++ would do.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 Lua 是一种动态类型语言。这意味着 5 / 3 不会像 C++ 那样产生 1。
- en: Relational operators
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系运算符
- en: 'A relational operator is an operator that tests some kind of relation between
    two values. Lua supports *six* relational operators:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符是测试两个值之间某种关系的运算符。Lua 支持 *六个* 关系运算符：
- en: '`<`: Less than'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`: 小于'
- en: '`>`: Greater than'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`: 大于'
- en: '`<=`: Less than or equal to'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=`: 小于或等于'
- en: '`>=`: Greater than or equal to'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=`: 大于或等于'
- en: '`==`: Equal to'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`: 等于'
- en: '`~=`: Not equal to'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~=`: 不等于'
- en: The `~=` operator tests the negation of equality. This is the same as the `!=`
    operator in C++. The other ones are the same as they are in C++.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`~=` 运算符测试不等于。这与 C++ 中的 `!=` 运算符相同。其他运算符与 C++ 中的相同。'
- en: Strings
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are always a constant in Lua. You cannot change one character in a string
    and make it represent another string. You create a new string for that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lua 中，字符串始终是常量。你不能改变字符串中的一个字符并使其代表另一个字符串。你需要为那个新字符串创建一个新的字符串。
- en: 'We can delimit literal strings with double or single quotes. The rest is quite
    similar to C++ strings, as shown in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用双引号或单引号界定字面量字符串。其余部分与 C++ 字符串非常相似，如下例所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have two operators on strings that cannot be found in C++. To concatenate
    two strings, you can use the `..` operator. To check the length of the string,
    you can use the `#` operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串上有两个在 C++ 中找不到的运算符。要连接两个字符串，可以使用 `..` 运算符。要检查字符串的长度，可以使用 `#` 运算符。
- en: Like the C++ escape sequence, use `\` to escape special characters, as you can
    see in the line break in the preceding output. If you do not want to insert the
    newline escape sequence, `\n`, you can use a long string instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 转义序列类似，使用 `\` 转义特殊字符，如前一个输出中的换行符所示。如果你不想插入换行转义序列 `\n`，可以使用长字符串。
- en: Long strings
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长字符串
- en: 'You can use `[[` and `]]` to delimit multiple-line strings, for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `[[` 和 `]]` 来界定多行字符串，例如：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This defines a string that is equal to the single-line definition `"Hello\nC++\n"`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个等于单行定义 `"Hello\nC++\n"` 的字符串。
- en: Long strings can make strings more readable. You can define **XML** or **JSON**
    strings easily in Lua source code with long strings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 长字符串可以使字符串更易于阅读。你可以在 Lua 源代码中使用长字符串轻松定义 **XML** 或 **JSON** 字符串。
- en: 'If your long string contains `[[` or `]]` in its content, you can add some
    equal signs between the opening brackets, for example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的长字符串内容中包含 `[[` 或 `]]`，你可以在开括号之间添加一些等号，例如：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How many equal signs you add is up to you. However, one is usually enough.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加多少个等号取决于你。然而，通常一个就足够了。
- en: Tables
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表
- en: Lua tables are like **C++ std::map** containers but are more flexible. A table
    is the only way to construct complex data structures in Lua.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 表类似于 **C++ std::map** 容器，但更灵活。表是 Lua 中构建复杂数据结构的唯一方式。
- en: 'Let’s try a Lua table with some actions. In a Lua interpreter, type the following
    statements one by one and observe the outputs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个带有一些操作的 Lua 表。在一个 Lua 解释器中，逐个输入以下语句并观察输出：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This creates a table with the `{}` constructor and assigns a value of `100`
    to the `'x'` string key. Another way to construct this table is `a = {x = 100}`.
    To initialize a table with more keys, use `a = {x = 100, y =` `200}`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{}` 构造函数创建一个表，并将值 `100` 赋给字符串键 `'x'`。另一种构建此表的方法是 `a = {x = 100}`。要使用更多键初始化表，请使用
    `a = {x = 100, y = 200}`。
- en: '`a.x` is an alternative syntax for `a[''x'']`. Which one you use is a style
    preference. But usually, the dot syntax implies that the table is used as a record
    or in an object-oriented way.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.x` 是 `a[''x'']` 的另一种语法。你使用哪种取决于你的风格偏好。但通常，点语法意味着表被用作记录或面向对象的方式。'
- en: 'Except for `nil`, you can use all Lua types as table keys. You can also use
    different types as values in the same table. You have complete control, as seen
    next:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `nil` 之外，你可以使用所有 Lua 类型作为表键。你还可以在同一个表中使用不同类型的值。你拥有完全的控制权，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example explains four points related to the table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例解释了与表相关的四个要点：
- en: It first creates a table in the form of an array. Note that it is indexed starting
    from 1, not 0\. When you give a value-only entry to the table constructor, it
    will be treated as part of the array. Do you recall that `#` is the length operator?
    It can tell the length of the table when it is used to represent a sequence or
    an array.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它首先以数组的形式创建一个表。请注意，它是从 1 开始索引的，而不是从 0 开始。当你向表构造函数提供一个仅包含值的条目时，它将被视为数组的一部分。你还记得
    `#` 是长度运算符吗？当它用于表示序列或数组时，它可以告诉表的长度。
- en: Then it adds another entry using another table, `a`, as the key and the `"a
    table"` string as the value. This is perfectly fine.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它使用另一个表 `a` 作为键和 `"a table"` 字符串作为值添加另一个条目。这是完全可以的。
- en: Note that `b.a` is `nil` because `b.a` means `b['a']` with the `'a'` string
    key, not `b[a]`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`b.a` 是 `nil`，因为 `b.a` 表示使用 `'a'` 字符串键的 `b['a']`，而不是 `b[a]`。
- en: 'Finally, we try to check the length of the table again. We have added 3 entries
    in the table, but it outputs a length of 2\. Coming from C++, this may surprise
    you: Lua does not provide a built-in way to check table length. The length operator
    only provides convenience when a table is an array. You are able to use a table
    as an array and a map at the same time, but you would need to take full responsibility.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们再次尝试检查表长度。我们在表中添加了 3 个条目，但它输出长度为 2。来自 C++ 的你可能感到惊讶：Lua 不提供检查表长度的内置方式。长度运算符仅在表表示序列或数组时提供便利。你能够同时将表用作数组和映射，但你需要承担全部责任。
- en: Later in this chapter, when we learn about the `for` control structure, we will
    find out more about table traversal. Now we will learn about Lua functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，当我们学习 `for` 控制结构时，我们将了解更多关于表遍历的内容。现在我们将学习 Lua 函数。
- en: Functions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Lua functions serve a similar purpose as C++ functions. But unlike in C++, they
    are also a first-class citizen as one of the basic data types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 函数与 C++ 函数具有类似的作用。但与 C++ 不同，它们也是基本数据类型之一的一等公民。
- en: 'We can define a function by doing the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式定义一个函数：
- en: Start with the `function` keyword.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `function` 关键字开始。
- en: Follow it with a function name and a pair of parentheses, inside which you can
    define function parameters if needed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后面跟着一个函数名和一对括号，其中可以定义所需的函数参数。
- en: Implement the function body.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数体。
- en: End the function definition with the `end` keyword.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `end` 关键字结束函数定义。
- en: 'For example, we can define a function as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个函数如下：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will print out `"``Hello C++"`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `"Hello C++"`。
- en: 'To define a function to use with the Lua interpreter, you have two choice:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个用于 Lua 解释器的函数，你有两种选择：
- en: In an interactive interpreter, just start to type the function. When you end
    each line, the interpreter will know, and you can continue to type the next line
    of the function definition.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交互式解释器中，只需开始输入函数。当你结束每一行时，解释器会知道，你可以继续输入函数定义的下一行。
- en: Alternatively, you can define your functions in another file that can be later
    imported into the interpreter. This is easier to work on. We will use this way
    from now on. Try to put your functions in this section in a file named `1-functions.lua`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以在另一个文件中定义你的函数，该文件可以在以后导入到解释器中。这样做更容易工作。从现在开始，我们将使用这种方法。尽量将你的函数放在名为 `1-functions.lua`
    的文件中的这个部分。
- en: 'To invoke a function, use its name and a pair of parentheses. This is the same
    as how you invoke a C++ function, for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，使用其名称和一对括号。这和调用 C++ 函数的方式一样，例如：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`dofile()` is the Lua library method to load another Lua script. Here, we load
    the file where we have defined our Lua functions. If you have changed the script
    file, you can execute it again to load the latest script.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`dofile()` 是 Lua 库中用于加载另一个 Lua 脚本的方法。在这里，我们加载定义了 Lua 函数的文件。如果你已经更改了脚本文件，你可以再次执行它来加载最新的脚本。'
- en: Next, we will learn about function parameters and function return values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习关于函数参数和函数返回值的内容。
- en: Function parameters
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数
- en: Function parameters, also called arguments, are values provided to the function
    when the function is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数，也称为参数，是在函数被调用时提供给函数的值。
- en: 'You can define function parameters by providing parameter declarations inside
    the parentheses after the function name. This is the same as in C++, but you do
    not need to provide parameter types, for example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在函数名后面的括号内提供参数声明来定义函数参数。这和在 C++ 中一样，但你不需要提供参数类型，例如：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When calling the function, you can pass in fewer or more parameters than defined.
    For example, you can call the `bag` function we just defined:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，你可以传递比定义的更多或更少的参数。例如，你可以调用我们刚刚定义的 `bag` 函数：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see what happens when the number of parameters provided is different
    from the number defined:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到当提供的参数数量与定义的数量不同时会发生什么：
- en: When not enough parameters are passed, the remaining ones will have a `nil`
    value.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递的参数不足时，剩余的参数将具有 `nil` 值。
- en: When more parameters are passed, the additional ones will be discarded.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递的参数多于定义的参数时，额外的参数将被丢弃。
- en: You cannot define a default value for function parameters because Lua does not
    support it at the language level. But you can check in your function, and if a
    parameter is `nil`, assign it a default value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能为函数参数定义默认值，因为 Lua 在语言级别不支持它。但你可以检查你的函数，如果参数是 `nil`，则分配给它默认值。
- en: Function results
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数结果
- en: 'You can use the `return` keyword to return function results. It is possible
    to return multiple values. Let us define two functions that return one and two
    values, respectively:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `return` 关键字来返回函数结果。可以返回多个值。让我们定义两个函数，分别返回一个和两个值：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first function returns the `square` for the given parameter. The second
    function returns the `sin` and `cos` of the given parameter. Let us give our two
    functions a try:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数返回给定参数的 `square`。第二个函数返回给定参数的 `sin` 和 `cos`。让我们尝试一下我们的两个函数：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see from the output that the functions return one and two values, respectively.
    In this example, `math.pi`, `math.sin`, and `math.cos` are from the Lua `math`
    library, which is loaded by default in the interactive interpreter. Have you wondered
    how to make a basic library for our `sincos` function?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从输出中看到，函数分别返回一个和两个值。在这个例子中，`math.pi`、`math.sin` 和 `math.cos` 来自 Lua 的 `math`
    库，该库默认在交互式解释器中加载。你有没有想过如何为我们的 `sincos` 函数创建一个基本库？
- en: Putting a function in a table
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数放入表中
- en: 'From a holistic point of view, the Lua `math` library – and any other library
    – is just tables holding functions and constant values. You can define your own:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体的角度来看，Lua 的 `math` 库——以及任何其他库——只是包含函数和常量值的表。你可以定义自己的：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created a table here named `mathx` and assigned our `sincos` function to
    the `"``sincos"` key.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个名为 `mathx` 的表，并将我们的 `sincos` 函数分配给 `"``sincos"` 键。
- en: Now you know how to create your own Lua library. To finish our introduction
    to the Lua types, let us see why we should use local variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何创建自己的 Lua 库。为了完成我们对 Lua 类型的介绍，让我们看看为什么我们应该使用局部变量。
- en: Local variables and scopes
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量和作用域
- en: So far, we have been using global variables because we just reference one when
    we need to, right? Yes, it is convenient. But the downside is that they will never
    go out of scope and can be accessed by all functions, related or not. Coming from
    a C++ background, you will not agree to this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用全局变量，因为我们只需要引用一个，对吧？是的，这很方便。但缺点是它们永远不会超出作用域，并且可以被所有函数访问，无论它们是否相关。如果你来自
    C++ 背景，你不会同意这一点。
- en: We can use the `if` branch, within a `for` loop, or within a function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `for` 循环内使用 `if` 分支，或在函数内使用。
- en: 'Local variables are good for preventing pollution of the global environment.
    Try to define two functions to test this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量对于防止全局环境污染很有用。尝试定义两个函数来测试这一点：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the first function, a local variable is not used, so a global variable named
    `abc_leaked` will be created. In the second function, a local variable – `abc_local`
    – is used, which will be unknown outside its function scope. Let us see the effects:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个函数中，没有使用局部变量，因此将创建一个名为 `abc_leaked` 的全局变量。在第二个函数中，使用了一个局部变量——`abc_local`——它将在其函数作用域之外不可知。让我们看看效果：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From the outputs, we can verify the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以验证以下：
- en: First, we try the first function that does not use a local variable. Before
    calling the function, we verify that there is no global variable named `abc_leaked`.
    After calling the function, a global variable – `abc_leaked` – is created.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们尝试第一个没有使用局部变量的函数。在调用函数之前，我们验证没有名为 `abc_leaked` 的全局变量。调用函数后，创建了一个全局变量——`abc_leaked`。
- en: Then we try the second function that uses a local variable. No global variable
    is created in this case.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们尝试使用局部变量的第二个函数。在这种情况下，没有创建全局变量。
- en: You should always use local variables when you can. Next, let us familiarize
    ourselves with Lua’s control structures.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以时，你应该始终使用局部变量。接下来，让我们熟悉 Lua 的控制结构。
- en: Control structures
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: The Lua control structures are quite similar to the C++ control structures.
    Try to compare them with their C++ counterparts as you learn about them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 控制结构与 C++ 控制结构非常相似。在学习它们的时候，尝试将它们与它们的 C++ 对应物进行比较。
- en: For the code shown in this section, you can put them in another Lua script file
    named `2-controls.lua`, and import it with `dofile` in the Lua interpreter. You
    can put each example in a separate function so that you can test the code with
    different parameters. By now, you should be comfortable using the Lua interpreter,
    so we will not show how to do it in the rest of this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节中显示的代码，你可以将它们放入另一个名为 `2-controls.lua` 的 Lua 脚本文件中，并在 Lua 解释器中使用 `dofile`
    导入。你可以将每个示例放入一个单独的函数中，这样你就可以使用不同的参数测试代码。到现在为止，你应该已经熟悉了 Lua 解释器，所以我们不会在本章的其余部分展示如何使用它。
- en: We will first explore how to do conditional branching in Lua, and then we will
    venture into loops.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索如何在 Lua 中进行条件分支，然后我们将尝试循环。
- en: if then else
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if then else
- en: 'The Lua `if` control structure is similar to the C++ one. However, you do not
    need the parentheses around the test condition, and you do not use the curly brackets.
    Instead, you will need the `then` keyword and the `end` keyword to delimit the
    code branches, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 的 `if` 控制结构类似于 C++ 的。然而，你不需要在测试条件周围使用括号，也不使用花括号。相反，你需要使用 `then` 关键字和 `end`
    关键字来界定代码分支，例如：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `else` branch is optional if you have no operation for that. If you have
    only one statement in each branch, you can also choose to write everything in
    one line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有操作，`else` 分支是可选的。如果你每个分支只有一个语句，你也可以选择将所有内容写在一行中。
- en: The Lua language design emphasizes simplicity, so the `if` control structure
    is the only conditional branching control. What if you want to implement something
    that resembles a C++ **switch** control structure?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 语言设计强调简洁性，因此 `if` 控制结构是唯一的条件分支控制。如果你想要实现类似于 C++ 的 **switch** 控制结构，怎么办呢？
- en: Simulating switch
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟 switch
- en: 'There is no switch control structure in Lua. To simulate it, you can use `elseif`.
    The following code does that:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中没有 switch 控制结构。为了模拟它，你可以使用 `elseif`。以下代码就是这样做的：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This behaves the same as a C++ `if..else if` control structure. The `if` and
    `elseif` conditions will be checked one by one until one condition is met and
    the name of the day of the week is returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C++ 的 `if..else if` 控制结构行为相同。`if` 和 `elseif` 条件将逐个检查，直到满足一个条件并返回一周中某天的名称。
- en: while
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while
- en: 'The Lua `do` keyword and the `end` keyword. The following example prints the
    days of the week:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 的 `do` 关键字和 `end` 关键字。以下示例打印出一周中的日子：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We declare a table named `days` and use it as an array. When the `i` index reaches
    `8`, the loop will end because `days[8]` is `nil` and tests as `false`. Coming
    from C++, you may wonder why we can access the eighth element of a seven-element
    array. In Lua, there is no index out of bound issue when a table is accessed this
    way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个名为 `days` 的表，并使用它作为数组。当 `i` 索引达到 `8` 时，循环将结束，因为 `days[8]` 是 `nil` 并测试为
    `false`。来自 C++ 的你可能想知道为什么我们可以访问一个七元素数组的第八个元素。在 Lua 中，以这种方式访问表时，没有索引越界的问题。
- en: You can use `break` to end the loop immediately. This works for the `repeat`
    loop and the `for` loop as well, which we will explain next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `break` 立即结束循环。这对 `repeat` 循环和 `for` 循环都适用，我们将在下面解释。
- en: repeat
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: repeat
- en: The Lua `do..while` control structure does, but the ending condition is treated
    differently. Lua uses the `until` condition to end the loop instead of C++’s `while`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 的 `do..while` 控制结构也这样做，但结束条件被处理得不同。Lua 使用 `until` 条件来结束循环，而不是 C++ 的 `while`。
- en: 'Let us implement the same code shown for the `while` control structure but
    with `repeat` this time:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现之前为 `while` 控制结构展示的相同代码，但这次使用 `repeat`：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`#days` returns the length of the `day` array. The code block within `repeat..until`
    will loop until `i` reaches this length.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`#days` 返回 `day` 数组的长度。`repeat..until` 中的代码块将循环，直到 `i` 达到这个长度。'
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that for a Lua array, the index starts from 1.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于 Lua 数组，索引从 1 开始。
- en: 'To implement the same code with `do..while` in C++, do the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C++ 中使用 `do..while` 实现相同的代码，请执行以下操作：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The C++ implementation looks very similar to the Lua version, except for the
    ending condition as pointed out earlier: `i < days.size()`. We are checking for
    less than, not equal to.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的实现看起来与 Lua 版本非常相似，除了前面提到的结束条件：`i < days.size()`。我们检查的是小于，而不是等于。
- en: for, numerical
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for, 数值
- en: 'The numerical **for** loops through a list of numbers. It takes this form:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数值 **for** 循环遍历一个数字列表。它具有以下形式：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`var` is treated as a local variable scoped to the `for` block.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 被视为作用域限于 `for` 块的局部变量。'
- en: '`exp1` is the start value.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp1` 是起始值。'
- en: '`exp2` is the end value.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp2` 是结束值。'
- en: '`exp3` is the step and is optional. When not provided, the default step is
    1.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp3` 是步长，是可选的。如果没有提供，则默认步长为 1。'
- en: 'To understand this better, let us see an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们看一个例子：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`i` is the local variable and has an initial value of `1`. The loop will end
    when `i` becomes greater than `#days`. A step of `4` is also provided. So, after
    each iteration, the effect is `i = i + 4`. Once you run this code, you will find
    out that only Monday and Friday are printed.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` 是局部变量，初始值为 `1`。当 `i` 变得大于 `#days` 时，循环将结束。还提供了一个步长 `4`。因此，每次迭代后，效果是 `i
    = i + 4`。一旦运行此代码，你就会发现只有星期一和星期五被打印出来。'
- en: 'And, maybe to your surprise, the float type will work as well:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 也许会让你惊讶，浮点类型也可以工作：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As can be verified by the output, the `for` loop prints from `1.0` and increases
    the value by `1.5` every time, as long as the value is not greater than `4.0`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`for` 循环从 `1.0` 开始打印，每次增加 `1.5`，只要值不大于 `4.0`。
- en: for, generic
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for, 通用
- en: The generic `for` loop traverses all values returned by an `iterator function`.
    This form of `for` loops is very convenient for traversing tables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 `for` 循环遍历由 `迭代函数` 返回的所有值。这种形式的 `for` 循环在遍历表时非常方便。
- en: When we talked about numerical `for` loops, we saw how they can traverse index-based
    tables. However, a table in Lua can be more than an array. The most common iterators
    on tables are `pairs` and `ipairs`. They return the key and value pairs for the
    table. `pairs` return pairs in an undefined order, as in most hash map implementations.
    `ipairs` returns pairs in a sorted order.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论数值 `for` 循环时，我们看到了它们如何遍历基于索引的表。然而，Lua 中的表可以不仅仅是数组。表上最常见的迭代器是 `pairs` 和
    `ipairs`。它们返回表中的键值对。`pairs` 返回的键值对顺序未定义，就像大多数哈希表实现一样。`ipairs` 返回排序后的键值对。
- en: 'Even for an index-based table, if you want to traverse everything, the generic
    `for` loop can also be more convenient:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于基于索引的表，如果你想遍历所有内容，通用的 `for` 循环也可以更方便：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This loops through the whole array without referring to the array length. The
    `pairs` iterator returns the key and value pair, one by one, for each loop iteration
    until all elements in the table are enumerated. After this, the loop ends.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环遍历整个数组，而不需要引用数组长度。`pairs` 迭代器逐个返回键值对，直到枚举表中的所有元素。之后，循环结束。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about six out of the eight data types in Lua
    and the four control structures. We have also learned about local variables and
    why you should use them. This knowledge will prepare you for the rest of the book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Lua 的八种数据类型中的六种和四种控制结构。我们还学习了局部变量以及为什么你应该使用它们。这些知识将为你阅读本书的其余部分做好准备。
- en: By now, you should be able to read and understand most of the Lua code out there.
    Some details and topics were intentionally not included in this chapter. You can
    study more about them when you encounter them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够阅读和理解大多数 Lua 代码。一些细节和主题故意没有包含在本章中。当你遇到它们时，你可以了解更多关于它们的信息。
- en: In the next chapter, we will learn how to call Lua code from C++.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何从 C++ 调用 Lua 代码。
- en: Exercises
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Locate the standard string manipulation library in the Lua reference manual.
    Learn about `string.gmatch`, `string.gsub`, and pattern matching. What pattern
    represents all non-space characters?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lua 参考手册中定位标准字符串操作库。了解 `string.gmatch`、`string.gsub` 和模式匹配。什么模式代表所有非空格字符？
- en: Using `string.gmatch` and a generic `for` loop, reverse the sentence “C++ loves
    Lua.” The output should be “Lua loves C++.”
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `string.gmatch` 和一个通用的 `for` 循环，反转句子 “C++ loves Lua.” 输出应该是 “Lua loves C++。”
- en: Can you use `string.gsub` and achieve the same with one line of code?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能使用 `string.gsub` 并用一行代码实现相同的功能吗？
- en: References
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The official Lua reference manual: [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Lua 参考手册：[https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)
- en: Part 2 – Calling Lua from C++
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 从 C++ 调用 Lua
- en: Now that you are familiar with setting up C++ projects with Lua, you will start
    to learn how to call Lua code from C++.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了使用 Lua 设置 C++ 项目，你将开始学习如何从 C++ 调用 Lua 代码。
- en: You will start to implement a general C++ utility class to load and execute
    Lua code. First, you will learn how to load Lua scripts and call a Lua function.
    Then, you will explore how to pass arguments to Lua functions and handle return
    values. Finally, you will dig deeper to master working with Lua tables.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始实现一个通用的 C++ 工具类来加载和执行 Lua 代码。首先，你将学习如何加载 Lua 脚本和调用 Lua 函数。然后，你将探索如何向 Lua
    函数传递参数和处理返回值。最后，你将深入了解如何与 Lua 表一起工作。
- en: 'This part comprises the following chapters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '*Chapter 3*, *How to Call Lua from C++*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 3 章*，*如何从 C++ 调用 Lua*'
- en: '*Chapter 4*, *Mapping Lua Types to C++*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 4 章*，*将 Lua 类型映射到 C++*'
- en: '*Chapter 5*, *Working with Lua Tables*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 5 章*，*与 Lua 表一起工作*'
