- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lua Fundamentals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of the Lua programming language. You
    do not need to be a Lua expert or even write any Lua code if you only work on
    the C++ side. However, understanding the basics will make you more efficient when
    integrating Lua into C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already know Lua programming, you can skip this chapter. If you have
    not used Lua for a while, you can use this chapter to recap. If you want to learn
    more about Lua programming, you can get the official Lua book: *Programming in
    Lua*. If you do not know Lua programming, this chapter is for you. Coming from
    C++, you can read any Lua code with the brief explanations on Lua code in this
    book. You can believe in yourself and research online when you need to.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk about the following language features:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Variables and types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use the interactive Lua interpreter to follow the code examples in
    this chapter. We have built it from the Lua source code in *Chapter 1*. You can
    also use a Lua interpreter from another channel, for example, the one installed
    by your operating system’s package manager. Before continuing, make sure you have
    access to one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'When you see code examples in this chapter, like the following one, you should
    try the example in an interactive Lua shell:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line is what the Lua interpreter outputs when it starts. Use `os.exit()`
    to quit the interpreter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter within the book’s GitHub repository:
    [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Variables and types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you may well know that C++ is a statically-typed language, Lua is a dynamically-typed
    language. In C++, when you declare a variable, you give it a clear type. In Lua,
    each value carries its own type, and you do not need to explicitly specify a type.
    Also, you do not need to define a global variable before referencing it. Although
    you are encouraged to declare it – or better yet, use local variables. We will
    learn about local variables later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lua, there are eight basic types: **nil**, **boolean**, **number**, **string**,
    **userdata**, **function**, **thread**, and **table**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about six of these in this chapter: `nil`, `boolean`, `number`,
    `string`, `table`, and `function`. Let’s try some before we go into the details:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What happens here is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Interactively, type `a` to check the value of the global variable `a`. Since
    it’s not defined yet, its value is `nil`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the type of variable `a` with `type(a)`. The value is `nil` in this case
    because it is not defined.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `true` to `a`. Use `=` for assignment; the same as in C++.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, its type is `boolean`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `6` to `a`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, its type is `number`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `"bonjour"` to `a`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, its type is `string`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every line executed there is also a Lua statement. Unlike a C++ statement, you
    do not need to put a semicolon at the end of it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn more about some of the types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Nil
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nil` type has only one value to represent a non-value: `nil`. Its meaning
    is similar to that of **nullptr** (or **NULL**) in C++.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boolean` type has two values. They are *true* and *false*. It does what
    **bool** does in C++.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `number` type covers C++’s **int**, **float**, and **double**, and their
    variants (such as **long**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will also learn about Lua arithmetic operators and relational operators,
    as these are mostly used on numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An arithmetic operator is an operator that performs arithmetic operations on
    numbers. Lua supports *six* arithmetic operators:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: Addition'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Subtraction'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Multiplication'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: Division'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`: Modulus'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//`: Floor Division'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C++ has seven arithmetic operators: +, -, *, /, %, ++ and --. Lua’s arithmetic
    operators are similar to their C++ counterparts, except for the following differences:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: There is no ++ or -- operator.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'C++ does not have the `//` operator, which returns the integer part of the
    result after division. C++ can achieve the same implicitly with normal division
    because C++ is strongly-typed. This we can see in the following example:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that Lua is a dynamically-typed language. This means 5 / 3 does not produce
    1 as C++ would do.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relational operators
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A relational operator is an operator that tests some kind of relation between
    two values. Lua supports *six* relational operators:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`<`: Less than'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: Greater than'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=`: Less than or equal to'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=`: Greater than or equal to'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`==`: Equal to'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~=`: Not equal to'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `~=` operator tests the negation of equality. This is the same as the `!=`
    operator in C++. The other ones are the same as they are in C++.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are always a constant in Lua. You cannot change one character in a string
    and make it represent another string. You create a new string for that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We can delimit literal strings with double or single quotes. The rest is quite
    similar to C++ strings, as shown in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have two operators on strings that cannot be found in C++. To concatenate
    two strings, you can use the `..` operator. To check the length of the string,
    you can use the `#` operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Like the C++ escape sequence, use `\` to escape special characters, as you can
    see in the line break in the preceding output. If you do not want to insert the
    newline escape sequence, `\n`, you can use a long string instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Long strings
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use `[[` and `]]` to delimit multiple-line strings, for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This defines a string that is equal to the single-line definition `"Hello\nC++\n"`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Long strings can make strings more readable. You can define **XML** or **JSON**
    strings easily in Lua source code with long strings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'If your long string contains `[[` or `]]` in its content, you can add some
    equal signs between the opening brackets, for example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How many equal signs you add is up to you. However, one is usually enough.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加多少个等号取决于你。然而，通常一个就足够了。
- en: Tables
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表
- en: Lua tables are like **C++ std::map** containers but are more flexible. A table
    is the only way to construct complex data structures in Lua.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 表类似于 **C++ std::map** 容器，但更灵活。表是 Lua 中构建复杂数据结构的唯一方式。
- en: 'Let’s try a Lua table with some actions. In a Lua interpreter, type the following
    statements one by one and observe the outputs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个带有一些操作的 Lua 表。在一个 Lua 解释器中，逐个输入以下语句并观察输出：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This creates a table with the `{}` constructor and assigns a value of `100`
    to the `'x'` string key. Another way to construct this table is `a = {x = 100}`.
    To initialize a table with more keys, use `a = {x = 100, y =` `200}`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{}` 构造函数创建一个表，并将值 `100` 赋给字符串键 `'x'`。另一种构建此表的方法是 `a = {x = 100}`。要使用更多键初始化表，请使用
    `a = {x = 100, y = 200}`。
- en: '`a.x` is an alternative syntax for `a[''x'']`. Which one you use is a style
    preference. But usually, the dot syntax implies that the table is used as a record
    or in an object-oriented way.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.x` 是 `a[''x'']` 的另一种语法。你使用哪种取决于你的风格偏好。但通常，点语法意味着表被用作记录或面向对象的方式。'
- en: 'Except for `nil`, you can use all Lua types as table keys. You can also use
    different types as values in the same table. You have complete control, as seen
    next:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `nil` 之外，你可以使用所有 Lua 类型作为表键。你还可以在同一个表中使用不同类型的值。你拥有完全的控制权，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example explains four points related to the table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例解释了与表相关的四个要点：
- en: It first creates a table in the form of an array. Note that it is indexed starting
    from 1, not 0\. When you give a value-only entry to the table constructor, it
    will be treated as part of the array. Do you recall that `#` is the length operator?
    It can tell the length of the table when it is used to represent a sequence or
    an array.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它首先以数组的形式创建一个表。请注意，它是从 1 开始索引的，而不是从 0 开始。当你向表构造函数提供一个仅包含值的条目时，它将被视为数组的一部分。你还记得
    `#` 是长度运算符吗？当它用于表示序列或数组时，它可以告诉表的长度。
- en: Then it adds another entry using another table, `a`, as the key and the `"a
    table"` string as the value. This is perfectly fine.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它使用另一个表 `a` 作为键和 `"a table"` 字符串作为值添加另一个条目。这是完全可以的。
- en: Note that `b.a` is `nil` because `b.a` means `b['a']` with the `'a'` string
    key, not `b[a]`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`b.a` 是 `nil`，因为 `b.a` 表示使用 `'a'` 字符串键的 `b['a']`，而不是 `b[a]`。
- en: 'Finally, we try to check the length of the table again. We have added 3 entries
    in the table, but it outputs a length of 2\. Coming from C++, this may surprise
    you: Lua does not provide a built-in way to check table length. The length operator
    only provides convenience when a table is an array. You are able to use a table
    as an array and a map at the same time, but you would need to take full responsibility.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们再次尝试检查表长度。我们在表中添加了 3 个条目，但它输出长度为 2。来自 C++ 的你可能感到惊讶：Lua 不提供检查表长度的内置方式。长度运算符仅在表表示序列或数组时提供便利。你能够同时将表用作数组和映射，但你需要承担全部责任。
- en: Later in this chapter, when we learn about the `for` control structure, we will
    find out more about table traversal. Now we will learn about Lua functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，当我们学习 `for` 控制结构时，我们将了解更多关于表遍历的内容。现在我们将学习 Lua 函数。
- en: Functions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Lua functions serve a similar purpose as C++ functions. But unlike in C++, they
    are also a first-class citizen as one of the basic data types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 函数与 C++ 函数具有类似的作用。但与 C++ 不同，它们也是基本数据类型之一的一等公民。
- en: 'We can define a function by doing the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式定义一个函数：
- en: Start with the `function` keyword.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `function` 关键字开始。
- en: Follow it with a function name and a pair of parentheses, inside which you can
    define function parameters if needed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后面跟着一个函数名和一对括号，其中可以定义所需的函数参数。
- en: Implement the function body.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数体。
- en: End the function definition with the `end` keyword.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `end` 关键字结束函数定义。
- en: 'For example, we can define a function as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个函数如下：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will print out `"``Hello C++"`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `"Hello C++"`。
- en: 'To define a function to use with the Lua interpreter, you have two choice:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个用于 Lua 解释器的函数，你有两种选择：
- en: In an interactive interpreter, just start to type the function. When you end
    each line, the interpreter will know, and you can continue to type the next line
    of the function definition.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交互式解释器中，只需开始输入函数。当你结束每一行时，解释器会知道，你可以继续输入函数定义的下一行。
- en: Alternatively, you can define your functions in another file that can be later
    imported into the interpreter. This is easier to work on. We will use this way
    from now on. Try to put your functions in this section in a file named `1-functions.lua`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以在另一个文件中定义你的函数，该文件可以在以后导入到解释器中。这样做更容易工作。从现在开始，我们将使用这种方法。尽量将你的函数放在名为 `1-functions.lua`
    的文件中的这个部分。
- en: 'To invoke a function, use its name and a pair of parentheses. This is the same
    as how you invoke a C++ function, for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，使用其名称和一对括号。这和调用 C++ 函数的方式一样，例如：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`dofile()` is the Lua library method to load another Lua script. Here, we load
    the file where we have defined our Lua functions. If you have changed the script
    file, you can execute it again to load the latest script.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`dofile()` 是 Lua 库中用于加载另一个 Lua 脚本的方法。在这里，我们加载定义了 Lua 函数的文件。如果你已经更改了脚本文件，你可以再次执行它来加载最新的脚本。'
- en: Next, we will learn about function parameters and function return values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习关于函数参数和函数返回值的内容。
- en: Function parameters
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数
- en: Function parameters, also called arguments, are values provided to the function
    when the function is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数，也称为参数，是在函数被调用时提供给函数的值。
- en: 'You can define function parameters by providing parameter declarations inside
    the parentheses after the function name. This is the same as in C++, but you do
    not need to provide parameter types, for example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在函数名后面的括号内提供参数声明来定义函数参数。这和在 C++ 中一样，但你不需要提供参数类型，例如：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When calling the function, you can pass in fewer or more parameters than defined.
    For example, you can call the `bag` function we just defined:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，你可以传递比定义的更多或更少的参数。例如，你可以调用我们刚刚定义的 `bag` 函数：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see what happens when the number of parameters provided is different
    from the number defined:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到当提供的参数数量与定义的数量不同时会发生什么：
- en: When not enough parameters are passed, the remaining ones will have a `nil`
    value.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递的参数不足时，剩余的参数将具有 `nil` 值。
- en: When more parameters are passed, the additional ones will be discarded.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递的参数多于定义的参数时，额外的参数将被丢弃。
- en: You cannot define a default value for function parameters because Lua does not
    support it at the language level. But you can check in your function, and if a
    parameter is `nil`, assign it a default value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能为函数参数定义默认值，因为 Lua 在语言级别不支持它。但你可以检查你的函数，如果参数是 `nil`，则分配给它默认值。
- en: Function results
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数结果
- en: 'You can use the `return` keyword to return function results. It is possible
    to return multiple values. Let us define two functions that return one and two
    values, respectively:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `return` 关键字来返回函数结果。可以返回多个值。让我们定义两个函数，分别返回一个和两个值：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first function returns the `square` for the given parameter. The second
    function returns the `sin` and `cos` of the given parameter. Let us give our two
    functions a try:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数返回给定参数的 `square`。第二个函数返回给定参数的 `sin` 和 `cos`。让我们尝试一下我们的两个函数：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see from the output that the functions return one and two values, respectively.
    In this example, `math.pi`, `math.sin`, and `math.cos` are from the Lua `math`
    library, which is loaded by default in the interactive interpreter. Have you wondered
    how to make a basic library for our `sincos` function?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从输出中看到，函数分别返回一个和两个值。在这个例子中，`math.pi`、`math.sin` 和 `math.cos` 来自 Lua 的 `math`
    库，该库默认在交互式解释器中加载。你有没有想过如何为我们的 `sincos` 函数创建一个基本库？
- en: Putting a function in a table
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数放入表中
- en: 'From a holistic point of view, the Lua `math` library – and any other library
    – is just tables holding functions and constant values. You can define your own:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体的角度来看，Lua 的 `math` 库——以及任何其他库——只是包含函数和常量值的表。你可以定义自己的：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created a table here named `mathx` and assigned our `sincos` function to
    the `"``sincos"` key.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个名为 `mathx` 的表，并将我们的 `sincos` 函数分配给 `"``sincos"` 键。
- en: Now you know how to create your own Lua library. To finish our introduction
    to the Lua types, let us see why we should use local variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何创建自己的 Lua 库。为了完成我们对 Lua 类型的介绍，让我们看看为什么我们应该使用局部变量。
- en: Local variables and scopes
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量和作用域
- en: So far, we have been using global variables because we just reference one when
    we need to, right? Yes, it is convenient. But the downside is that they will never
    go out of scope and can be accessed by all functions, related or not. Coming from
    a C++ background, you will not agree to this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `if` branch, within a `for` loop, or within a function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables are good for preventing pollution of the global environment.
    Try to define two functions to test this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the first function, a local variable is not used, so a global variable named
    `abc_leaked` will be created. In the second function, a local variable – `abc_local`
    – is used, which will be unknown outside its function scope. Let us see the effects:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From the outputs, we can verify the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: First, we try the first function that does not use a local variable. Before
    calling the function, we verify that there is no global variable named `abc_leaked`.
    After calling the function, a global variable – `abc_leaked` – is created.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we try the second function that uses a local variable. No global variable
    is created in this case.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should always use local variables when you can. Next, let us familiarize
    ourselves with Lua’s control structures.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Lua control structures are quite similar to the C++ control structures.
    Try to compare them with their C++ counterparts as you learn about them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: For the code shown in this section, you can put them in another Lua script file
    named `2-controls.lua`, and import it with `dofile` in the Lua interpreter. You
    can put each example in a separate function so that you can test the code with
    different parameters. By now, you should be comfortable using the Lua interpreter,
    so we will not show how to do it in the rest of this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We will first explore how to do conditional branching in Lua, and then we will
    venture into loops.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: if then else
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Lua `if` control structure is similar to the C++ one. However, you do not
    need the parentheses around the test condition, and you do not use the curly brackets.
    Instead, you will need the `then` keyword and the `end` keyword to delimit the
    code branches, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `else` branch is optional if you have no operation for that. If you have
    only one statement in each branch, you can also choose to write everything in
    one line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The Lua language design emphasizes simplicity, so the `if` control structure
    is the only conditional branching control. What if you want to implement something
    that resembles a C++ **switch** control structure?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Simulating switch
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no switch control structure in Lua. To simulate it, you can use `elseif`.
    The following code does that:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This behaves the same as a C++ `if..else if` control structure. The `if` and
    `elseif` conditions will be checked one by one until one condition is met and
    the name of the day of the week is returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: while
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Lua `do` keyword and the `end` keyword. The following example prints the
    days of the week:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We declare a table named `days` and use it as an array. When the `i` index reaches
    `8`, the loop will end because `days[8]` is `nil` and tests as `false`. Coming
    from C++, you may wonder why we can access the eighth element of a seven-element
    array. In Lua, there is no index out of bound issue when a table is accessed this
    way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: You can use `break` to end the loop immediately. This works for the `repeat`
    loop and the `for` loop as well, which we will explain next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: repeat
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lua `do..while` control structure does, but the ending condition is treated
    differently. Lua uses the `until` condition to end the loop instead of C++’s `while`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us implement the same code shown for the `while` control structure but
    with `repeat` this time:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`#days` returns the length of the `day` array. The code block within `repeat..until`
    will loop until `i` reaches this length.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that for a Lua array, the index starts from 1.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the same code with `do..while` in C++, do the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The C++ implementation looks very similar to the Lua version, except for the
    ending condition as pointed out earlier: `i < days.size()`. We are checking for
    less than, not equal to.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: for, numerical
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The numerical **for** loops through a list of numbers. It takes this form:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`var` is treated as a local variable scoped to the `for` block.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp1` is the start value.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp2` is the end value.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp3` is the step and is optional. When not provided, the default step is
    1.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand this better, let us see an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`i` is the local variable and has an initial value of `1`. The loop will end
    when `i` becomes greater than `#days`. A step of `4` is also provided. So, after
    each iteration, the effect is `i = i + 4`. Once you run this code, you will find
    out that only Monday and Friday are printed.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'And, maybe to your surprise, the float type will work as well:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As can be verified by the output, the `for` loop prints from `1.0` and increases
    the value by `1.5` every time, as long as the value is not greater than `4.0`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: for, generic
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generic `for` loop traverses all values returned by an `iterator function`.
    This form of `for` loops is very convenient for traversing tables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: When we talked about numerical `for` loops, we saw how they can traverse index-based
    tables. However, a table in Lua can be more than an array. The most common iterators
    on tables are `pairs` and `ipairs`. They return the key and value pairs for the
    table. `pairs` return pairs in an undefined order, as in most hash map implementations.
    `ipairs` returns pairs in a sorted order.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Even for an index-based table, if you want to traverse everything, the generic
    `for` loop can also be more convenient:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This loops through the whole array without referring to the array length. The
    `pairs` iterator returns the key and value pair, one by one, for each loop iteration
    until all elements in the table are enumerated. After this, the loop ends.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about six out of the eight data types in Lua
    and the four control structures. We have also learned about local variables and
    why you should use them. This knowledge will prepare you for the rest of the book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Lua 的八种数据类型中的六种和四种控制结构。我们还学习了局部变量以及为什么你应该使用它们。这些知识将为你阅读本书的其余部分做好准备。
- en: By now, you should be able to read and understand most of the Lua code out there.
    Some details and topics were intentionally not included in this chapter. You can
    study more about them when you encounter them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够阅读和理解大多数 Lua 代码。一些细节和主题故意没有包含在本章中。当你遇到它们时，你可以了解更多关于它们的信息。
- en: In the next chapter, we will learn how to call Lua code from C++.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何从 C++ 调用 Lua 代码。
- en: Exercises
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Locate the standard string manipulation library in the Lua reference manual.
    Learn about `string.gmatch`, `string.gsub`, and pattern matching. What pattern
    represents all non-space characters?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lua 参考手册中定位标准字符串操作库。了解 `string.gmatch`、`string.gsub` 和模式匹配。什么模式代表所有非空格字符？
- en: Using `string.gmatch` and a generic `for` loop, reverse the sentence “C++ loves
    Lua.” The output should be “Lua loves C++.”
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `string.gmatch` 和一个通用的 `for` 循环，反转句子 “C++ loves Lua.” 输出应该是 “Lua loves C++。”
- en: Can you use `string.gsub` and achieve the same with one line of code?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能使用 `string.gsub` 并用一行代码实现相同的功能吗？
- en: References
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The official Lua reference manual: [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Lua 参考手册：[https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)
- en: Part 2 – Calling Lua from C++
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 从 C++ 调用 Lua
- en: Now that you are familiar with setting up C++ projects with Lua, you will start
    to learn how to call Lua code from C++.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了使用 Lua 设置 C++ 项目，你将开始学习如何从 C++ 调用 Lua 代码。
- en: You will start to implement a general C++ utility class to load and execute
    Lua code. First, you will learn how to load Lua scripts and call a Lua function.
    Then, you will explore how to pass arguments to Lua functions and handle return
    values. Finally, you will dig deeper to master working with Lua tables.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始实现一个通用的 C++ 工具类来加载和执行 Lua 代码。首先，你将学习如何加载 Lua 脚本和调用 Lua 函数。然后，你将探索如何向 Lua
    函数传递参数和处理返回值。最后，你将深入了解如何与 Lua 表一起工作。
- en: 'This part comprises the following chapters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '*Chapter 3*, *How to Call Lua from C++*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 3 章*，*如何从 C++ 调用 Lua*'
- en: '*Chapter 4*, *Mapping Lua Types to C++*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 4 章*，*将 Lua 类型映射到 C++*'
- en: '*Chapter 5*, *Working with Lua Tables*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 5 章*，*与 Lua 表一起工作*'
