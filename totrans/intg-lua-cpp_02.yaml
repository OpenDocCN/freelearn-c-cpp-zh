- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lua Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of the Lua programming language. You
    do not need to be a Lua expert or even write any Lua code if you only work on
    the C++ side. However, understanding the basics will make you more efficient when
    integrating Lua into C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already know Lua programming, you can skip this chapter. If you have
    not used Lua for a while, you can use this chapter to recap. If you want to learn
    more about Lua programming, you can get the official Lua book: *Programming in
    Lua*. If you do not know Lua programming, this chapter is for you. Coming from
    C++, you can read any Lua code with the brief explanations on Lua code in this
    book. You can believe in yourself and research online when you need to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk about the following language features:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use the interactive Lua interpreter to follow the code examples in
    this chapter. We have built it from the Lua source code in *Chapter 1*. You can
    also use a Lua interpreter from another channel, for example, the one installed
    by your operating system’s package manager. Before continuing, make sure you have
    access to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you see code examples in this chapter, like the following one, you should
    try the example in an interactive Lua shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line is what the Lua interpreter outputs when it starts. Use `os.exit()`
    to quit the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter within the book’s GitHub repository:
    [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Variables and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you may well know that C++ is a statically-typed language, Lua is a dynamically-typed
    language. In C++, when you declare a variable, you give it a clear type. In Lua,
    each value carries its own type, and you do not need to explicitly specify a type.
    Also, you do not need to define a global variable before referencing it. Although
    you are encouraged to declare it – or better yet, use local variables. We will
    learn about local variables later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Lua, there are eight basic types: **nil**, **boolean**, **number**, **string**,
    **userdata**, **function**, **thread**, and **table**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about six of these in this chapter: `nil`, `boolean`, `number`,
    `string`, `table`, and `function`. Let’s try some before we go into the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Interactively, type `a` to check the value of the global variable `a`. Since
    it’s not defined yet, its value is `nil`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the type of variable `a` with `type(a)`. The value is `nil` in this case
    because it is not defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `true` to `a`. Use `=` for assignment; the same as in C++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, its type is `boolean`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `6` to `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, its type is `number`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `"bonjour"` to `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, its type is `string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every line executed there is also a Lua statement. Unlike a C++ statement, you
    do not need to put a semicolon at the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn more about some of the types.
  prefs: []
  type: TYPE_NORMAL
- en: Nil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nil` type has only one value to represent a non-value: `nil`. Its meaning
    is similar to that of **nullptr** (or **NULL**) in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boolean` type has two values. They are *true* and *false*. It does what
    **bool** does in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `number` type covers C++’s **int**, **float**, and **double**, and their
    variants (such as **long**).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will also learn about Lua arithmetic operators and relational operators,
    as these are mostly used on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An arithmetic operator is an operator that performs arithmetic operations on
    numbers. Lua supports *six* arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: Addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Multiplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: Division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`: Modulus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//`: Floor Division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C++ has seven arithmetic operators: +, -, *, /, %, ++ and --. Lua’s arithmetic
    operators are similar to their C++ counterparts, except for the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no ++ or -- operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'C++ does not have the `//` operator, which returns the integer part of the
    result after division. C++ can achieve the same implicitly with normal division
    because C++ is strongly-typed. This we can see in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that Lua is a dynamically-typed language. This means 5 / 3 does not produce
    1 as C++ would do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A relational operator is an operator that tests some kind of relation between
    two values. Lua supports *six* relational operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<`: Less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: Greater than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=`: Less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=`: Greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`==`: Equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~=`: Not equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `~=` operator tests the negation of equality. This is the same as the `!=`
    operator in C++. The other ones are the same as they are in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are always a constant in Lua. You cannot change one character in a string
    and make it represent another string. You create a new string for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can delimit literal strings with double or single quotes. The rest is quite
    similar to C++ strings, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have two operators on strings that cannot be found in C++. To concatenate
    two strings, you can use the `..` operator. To check the length of the string,
    you can use the `#` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Like the C++ escape sequence, use `\` to escape special characters, as you can
    see in the line break in the preceding output. If you do not want to insert the
    newline escape sequence, `\n`, you can use a long string instead.
  prefs: []
  type: TYPE_NORMAL
- en: Long strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use `[[` and `]]` to delimit multiple-line strings, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This defines a string that is equal to the single-line definition `"Hello\nC++\n"`.
  prefs: []
  type: TYPE_NORMAL
- en: Long strings can make strings more readable. You can define **XML** or **JSON**
    strings easily in Lua source code with long strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your long string contains `[[` or `]]` in its content, you can add some
    equal signs between the opening brackets, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How many equal signs you add is up to you. However, one is usually enough.
  prefs: []
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lua tables are like **C++ std::map** containers but are more flexible. A table
    is the only way to construct complex data structures in Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a Lua table with some actions. In a Lua interpreter, type the following
    statements one by one and observe the outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This creates a table with the `{}` constructor and assigns a value of `100`
    to the `'x'` string key. Another way to construct this table is `a = {x = 100}`.
    To initialize a table with more keys, use `a = {x = 100, y =` `200}`.
  prefs: []
  type: TYPE_NORMAL
- en: '`a.x` is an alternative syntax for `a[''x'']`. Which one you use is a style
    preference. But usually, the dot syntax implies that the table is used as a record
    or in an object-oriented way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Except for `nil`, you can use all Lua types as table keys. You can also use
    different types as values in the same table. You have complete control, as seen
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example explains four points related to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: It first creates a table in the form of an array. Note that it is indexed starting
    from 1, not 0\. When you give a value-only entry to the table constructor, it
    will be treated as part of the array. Do you recall that `#` is the length operator?
    It can tell the length of the table when it is used to represent a sequence or
    an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it adds another entry using another table, `a`, as the key and the `"a
    table"` string as the value. This is perfectly fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that `b.a` is `nil` because `b.a` means `b['a']` with the `'a'` string
    key, not `b[a]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we try to check the length of the table again. We have added 3 entries
    in the table, but it outputs a length of 2\. Coming from C++, this may surprise
    you: Lua does not provide a built-in way to check table length. The length operator
    only provides convenience when a table is an array. You are able to use a table
    as an array and a map at the same time, but you would need to take full responsibility.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later in this chapter, when we learn about the `for` control structure, we will
    find out more about table traversal. Now we will learn about Lua functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lua functions serve a similar purpose as C++ functions. But unlike in C++, they
    are also a first-class citizen as one of the basic data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a function by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the `function` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow it with a function name and a pair of parentheses, inside which you can
    define function parameters if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the function body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End the function definition with the `end` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, we can define a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will print out `"``Hello C++"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a function to use with the Lua interpreter, you have two choice:'
  prefs: []
  type: TYPE_NORMAL
- en: In an interactive interpreter, just start to type the function. When you end
    each line, the interpreter will know, and you can continue to type the next line
    of the function definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can define your functions in another file that can be later
    imported into the interpreter. This is easier to work on. We will use this way
    from now on. Try to put your functions in this section in a file named `1-functions.lua`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To invoke a function, use its name and a pair of parentheses. This is the same
    as how you invoke a C++ function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`dofile()` is the Lua library method to load another Lua script. Here, we load
    the file where we have defined our Lua functions. If you have changed the script
    file, you can execute it again to load the latest script.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about function parameters and function return values.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function parameters, also called arguments, are values provided to the function
    when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define function parameters by providing parameter declarations inside
    the parentheses after the function name. This is the same as in C++, but you do
    not need to provide parameter types, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling the function, you can pass in fewer or more parameters than defined.
    For example, you can call the `bag` function we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see what happens when the number of parameters provided is different
    from the number defined:'
  prefs: []
  type: TYPE_NORMAL
- en: When not enough parameters are passed, the remaining ones will have a `nil`
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When more parameters are passed, the additional ones will be discarded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot define a default value for function parameters because Lua does not
    support it at the language level. But you can check in your function, and if a
    parameter is `nil`, assign it a default value.
  prefs: []
  type: TYPE_NORMAL
- en: Function results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `return` keyword to return function results. It is possible
    to return multiple values. Let us define two functions that return one and two
    values, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function returns the `square` for the given parameter. The second
    function returns the `sin` and `cos` of the given parameter. Let us give our two
    functions a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output that the functions return one and two values, respectively.
    In this example, `math.pi`, `math.sin`, and `math.cos` are from the Lua `math`
    library, which is loaded by default in the interactive interpreter. Have you wondered
    how to make a basic library for our `sincos` function?
  prefs: []
  type: TYPE_NORMAL
- en: Putting a function in a table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From a holistic point of view, the Lua `math` library – and any other library
    – is just tables holding functions and constant values. You can define your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We created a table here named `mathx` and assigned our `sincos` function to
    the `"``sincos"` key.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to create your own Lua library. To finish our introduction
    to the Lua types, let us see why we should use local variables.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables and scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been using global variables because we just reference one when
    we need to, right? Yes, it is convenient. But the downside is that they will never
    go out of scope and can be accessed by all functions, related or not. Coming from
    a C++ background, you will not agree to this.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `if` branch, within a `for` loop, or within a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables are good for preventing pollution of the global environment.
    Try to define two functions to test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first function, a local variable is not used, so a global variable named
    `abc_leaked` will be created. In the second function, a local variable – `abc_local`
    – is used, which will be unknown outside its function scope. Let us see the effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From the outputs, we can verify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we try the first function that does not use a local variable. Before
    calling the function, we verify that there is no global variable named `abc_leaked`.
    After calling the function, a global variable – `abc_leaked` – is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we try the second function that uses a local variable. No global variable
    is created in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should always use local variables when you can. Next, let us familiarize
    ourselves with Lua’s control structures.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Lua control structures are quite similar to the C++ control structures.
    Try to compare them with their C++ counterparts as you learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: For the code shown in this section, you can put them in another Lua script file
    named `2-controls.lua`, and import it with `dofile` in the Lua interpreter. You
    can put each example in a separate function so that you can test the code with
    different parameters. By now, you should be comfortable using the Lua interpreter,
    so we will not show how to do it in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will first explore how to do conditional branching in Lua, and then we will
    venture into loops.
  prefs: []
  type: TYPE_NORMAL
- en: if then else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Lua `if` control structure is similar to the C++ one. However, you do not
    need the parentheses around the test condition, and you do not use the curly brackets.
    Instead, you will need the `then` keyword and the `end` keyword to delimit the
    code branches, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `else` branch is optional if you have no operation for that. If you have
    only one statement in each branch, you can also choose to write everything in
    one line.
  prefs: []
  type: TYPE_NORMAL
- en: The Lua language design emphasizes simplicity, so the `if` control structure
    is the only conditional branching control. What if you want to implement something
    that resembles a C++ **switch** control structure?
  prefs: []
  type: TYPE_NORMAL
- en: Simulating switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no switch control structure in Lua. To simulate it, you can use `elseif`.
    The following code does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This behaves the same as a C++ `if..else if` control structure. The `if` and
    `elseif` conditions will be checked one by one until one condition is met and
    the name of the day of the week is returned.
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Lua `do` keyword and the `end` keyword. The following example prints the
    days of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We declare a table named `days` and use it as an array. When the `i` index reaches
    `8`, the loop will end because `days[8]` is `nil` and tests as `false`. Coming
    from C++, you may wonder why we can access the eighth element of a seven-element
    array. In Lua, there is no index out of bound issue when a table is accessed this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `break` to end the loop immediately. This works for the `repeat`
    loop and the `for` loop as well, which we will explain next.
  prefs: []
  type: TYPE_NORMAL
- en: repeat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lua `do..while` control structure does, but the ending condition is treated
    differently. Lua uses the `until` condition to end the loop instead of C++’s `while`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us implement the same code shown for the `while` control structure but
    with `repeat` this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`#days` returns the length of the `day` array. The code block within `repeat..until`
    will loop until `i` reaches this length.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that for a Lua array, the index starts from 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the same code with `do..while` in C++, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ implementation looks very similar to the Lua version, except for the
    ending condition as pointed out earlier: `i < days.size()`. We are checking for
    less than, not equal to.'
  prefs: []
  type: TYPE_NORMAL
- en: for, numerical
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The numerical **for** loops through a list of numbers. It takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`var` is treated as a local variable scoped to the `for` block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp1` is the start value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp2` is the end value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp3` is the step and is optional. When not provided, the default step is
    1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand this better, let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`i` is the local variable and has an initial value of `1`. The loop will end
    when `i` becomes greater than `#days`. A step of `4` is also provided. So, after
    each iteration, the effect is `i = i + 4`. Once you run this code, you will find
    out that only Monday and Friday are printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, maybe to your surprise, the float type will work as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As can be verified by the output, the `for` loop prints from `1.0` and increases
    the value by `1.5` every time, as long as the value is not greater than `4.0`.
  prefs: []
  type: TYPE_NORMAL
- en: for, generic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generic `for` loop traverses all values returned by an `iterator function`.
    This form of `for` loops is very convenient for traversing tables.
  prefs: []
  type: TYPE_NORMAL
- en: When we talked about numerical `for` loops, we saw how they can traverse index-based
    tables. However, a table in Lua can be more than an array. The most common iterators
    on tables are `pairs` and `ipairs`. They return the key and value pairs for the
    table. `pairs` return pairs in an undefined order, as in most hash map implementations.
    `ipairs` returns pairs in a sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even for an index-based table, if you want to traverse everything, the generic
    `for` loop can also be more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This loops through the whole array without referring to the array length. The
    `pairs` iterator returns the key and value pair, one by one, for each loop iteration
    until all elements in the table are enumerated. After this, the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about six out of the eight data types in Lua
    and the four control structures. We have also learned about local variables and
    why you should use them. This knowledge will prepare you for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be able to read and understand most of the Lua code out there.
    Some details and topics were intentionally not included in this chapter. You can
    study more about them when you encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to call Lua code from C++.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locate the standard string manipulation library in the Lua reference manual.
    Learn about `string.gmatch`, `string.gsub`, and pattern matching. What pattern
    represents all non-space characters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `string.gmatch` and a generic `for` loop, reverse the sentence “C++ loves
    Lua.” The output should be “Lua loves C++.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use `string.gsub` and achieve the same with one line of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Lua reference manual: [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)'
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Calling Lua from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are familiar with setting up C++ projects with Lua, you will start
    to learn how to call Lua code from C++.
  prefs: []
  type: TYPE_NORMAL
- en: You will start to implement a general C++ utility class to load and execute
    Lua code. First, you will learn how to load Lua scripts and call a Lua function.
    Then, you will explore how to pass arguments to Lua functions and handle return
    values. Finally, you will dig deeper to master working with Lua tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 3*, *How to Call Lua from C++*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Mapping Lua Types to C++*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Working with Lua Tables*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
