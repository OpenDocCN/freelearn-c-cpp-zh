<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-229">
    <a id="_idTextAnchor228">
    </a>
    
     11
    
   </h1>
   <h1 id="_idParaDest-230">
    <a id="_idTextAnchor229">
    </a>
    
     Logging and Debugging Asynchronous Software
    
   </h1>
   <p>
    
     There is no way to ensure that a software product is free from bugs, so from time to time, bugs can appear.
    
    
     This is when logging and debugging
    
    
     
      are indispensable.
     
    
   </p>
   <p>
    
     Logging and debugging are essential for identifying and diagnosing issues in software systems.
    
    
     They provide visibility into the runtime behavior of code, helping developers trace errors, monitor performance, and understand the flow of execution.
    
    
     By using logging and debugging effectively, developers can detect bugs, resolve unexpected behavior, and improve overall system stability
    
    
     
      and maintainability.
     
    
   </p>
   <p>
    
     While writing this chapter, we assume you are already familiar with using a debugger to debug C++ programs and know some basic debugger commands and terminology, such as breakpoints, watchers, frames, or stack traces.
    
    
     To brush up on that knowledge, you can refer to the references provided in the
    
    <em class="italic">
     
      Further reading
     
    </em>
    
     section at the end of
    
    
     
      the chapter.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      How to use logging to
     
     
      
       spot bugs
      
     
    </li>
    <li>
     
      How to debug
     
     
      
       asynchronous software
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-231">
    <a id="_idTextAnchor230">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, we will need to install third-party libraries to
    
    
     
      compile examples.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      spdlog
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      {fmt}
     
    </strong>
    
     libraries need to be installed to compile the example in the logging section.
    
    
     Please check their documentation (
    
    <strong class="source-inline">
     
      spdlog
     
    </strong>
    
     ’s documentation is available at
    
    <a href="https://github.com/gabime/spdlog">
     
      https://github.com/gabime/spdlog
     
    </a>
    
     and
    
    <strong class="source-inline">
     
      {fmt}
     
    </strong>
    
     ’s documentation is available at
    
    <a href="https://github.com/fmtlib/fmt">
     
      https://github.com/fmtlib/fmt
     
    </a>
    
     ) and follow the installation steps suitable for
    
    
     
      your platform.
     
    
   </p>
   <p>
    
     Some examples need a compiler supporting C++20.
    
    
     Therefore, check the technical requirements section in
    
    <a href="B22219_03.xhtml#_idTextAnchor051">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     , which has some guidance on how to install GCC 13 and Clang
    
    
     
      8 compilers.
     
    
   </p>
   <p>
    
     You can find all the complete code in the following
    
    
     
      GitHub repository:
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
   </p>
   <p>
    
     The examples for this chapter are located under the
    
    <strong class="source-inline">
     
      Chapter_11
     
    </strong>
    
     folder.
    
    
     All source code files can be compiled using CMake
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ cmake . &amp;&amp; cmake —build .</pre>
   <p>
    
     Executable binaries will be generated under the
    
    
     <strong class="source-inline">
      
       bin
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-232">
    <a id="_idTextAnchor231">
    </a>
    
     How to use logging to spot bugs
    
   </h1>
   <p>
    
     Let’s start with a
    
    <a id="_idIndexMarker807">
    </a>
    
     trivial but useful method for understanding what a software program does while executing –
    
    
     
      logging.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Logging
     
    </strong>
    
     is the
    
    <a id="_idIndexMarker808">
    </a>
    
     process of keeping a log of events that occur in a program, storing information by using messages to record how a program executes, tracking its flow, and helping with identifying issues
    
    
     
      and bugs.
     
    
   </p>
   <p>
    
     Most Unix-based logging systems use the standard
    
    <a id="_idIndexMarker809">
    </a>
    
     protocol,
    
    <strong class="bold">
     
      syslog
     
    </strong>
    
     , created by Eric Altman back in 1980 as part of the Sendmail project.
    
    
     This standard protocol defines the boundaries between the software generating the log messages, the system storing them, and the software reporting and analyzing these
    
    
     
      log events.
     
    
   </p>
   <p>
    
     Each log message includes a facility code and a severity level.
    
    
     The facility code identifies the type of system that originated a specific log message (user-level, kernel, system, network, etc.), and the severity level describes the condition of the system, indicating the urgency of dealing with a specific issue, the severity levels being emergency, alert, critical, error, warning, notice, info,
    
    
     
      and debug.
     
    
   </p>
   <p>
    
     Most logging systems or loggers provide various destinations or sinks for log messages: console, files that can later be opened and analyzed, remote syslog servers, or relays, among
    
    
     
      other destinations.
     
    
   </p>
   <p>
    
     Logging is useful where debuggers are not, as we will see later, especially in distributed, multithreaded, real-time, scientific, or event-centric applications, where inspecting data or following the program flow using the debugger can become a
    
    
     
      tedious task.
     
    
   </p>
   <p>
    
     Logging libraries usually also provide a thread-safe singleton class that allows multithreading and asynchronous writing to log files, helps with log rotation, avoids large log files by creating new ones on the fly without losing log events, and time stamping, for better tracking when a log
    
    
     
      event happens.
     
    
   </p>
   <p>
    
     Instead of implementing our own multithreaded logging system, a better approach is to use some well-tested
    
    <a id="_idIndexMarker810">
    </a>
    
     and documented
    
    
     
      production-ready libraries.
     
    
   </p>
   <h2 id="_idParaDest-233">
    <a id="_idTextAnchor232">
    </a>
    
     How to select a third-party library
    
   </h2>
   <p>
    
     When selecting a
    
    <a id="_idIndexMarker811">
    </a>
    
     logging library (or any other library), we
    
    <a id="_idIndexMarker812">
    </a>
    
     need to investigate the following points before integrating it into our software to avoid
    
    
     
      future issues:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Support
      
     </strong>
     
      : Is the library updated and upgraded regularly?
     
     
      Is there a community or active ecosystem around the library that can help with any questions that can arise?
     
     
      Is the community happy using
     
     
      
       the library?
      
     
    </li>
    <li>
     <strong class="bold">
      
       Quality
      
     </strong>
     
      : Is there a public bugs report system?
     
     
      Are bug reports dealt with promptly, providing solutions and fixing bugs in the library?
     
     
      Does it support recent compiler versions and support latest
     
     
      
       C++ features?
      
     
    </li>
    <li>
     <strong class="bold">
      
       Security
      
     </strong>
     
      : Does the library, or any of its dependent libraries, have any
     
     
      
       vulnerabilities reported?
      
     
    </li>
    <li>
     <strong class="bold">
      
       License
      
     </strong>
     
      : Is the library license aligned with our development and product needs?
     
     
      Is the
     
     
      
       cost affordable?
      
     
    </li>
   </ul>
   <p>
    
     For complex systems, it may be worth considering centralized systems to collect and generate logging reports or
    
    <a id="_idIndexMarker813">
    </a>
    
     dashboards, such
    
    <a id="_idIndexMarker814">
    </a>
    
     as
    
    <strong class="bold">
     
      Sentry
     
    </strong>
    
     (
    
    <a href="https://sentry.io">
     
      https://sentry.io
     
    </a>
    
     ) or
    
    <strong class="bold">
     
      Logstash
     
    </strong>
    
     (
    
    <a href="https://www.elastic.co/logstash">
     
      https://www.elastic.co/logstash
     
    </a>
    
     ), that can collect, parse, and
    
    <a id="_idIndexMarker815">
    </a>
    
     transform
    
    <a id="_idIndexMarker816">
    </a>
    
     logs, and can be integrated with other tools, such
    
    <a id="_idIndexMarker817">
    </a>
    
     as
    
    <strong class="bold">
     
      Graylog
     
    </strong>
    
     (https://graylog.org),
    
    <strong class="bold">
     
      Grafana
     
    </strong>
    
     (https://grafana.com), or
    
    
     <strong class="bold">
      
       Kibana
      
     </strong>
    
    
     
      (
     
    
    
     
      https://www.elastic.co/kibana
     
    
    
     
      ).
     
    
   </p>
   <p>
    
     The next section describes some interesting
    
    
     
      logging libraries.
     
    
   </p>
   <h2 id="_idParaDest-234">
    <a id="_idTextAnchor233">
    </a>
    
     Some relevant logging libraries
    
   </h2>
   <p>
    
     There are many
    
    <a id="_idIndexMarker818">
    </a>
    
     logging libraries in the market, each covering some specific software requirements.
    
    
     Depending on the program constraints and needs, one of the following libraries might be more suitable
    
    
     
      than others.
     
    
   </p>
   <p>
    
     In
    
    <a href="B22219_09.xhtml#_idTextAnchor184">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     , we
    
    <a id="_idIndexMarker819">
    </a>
    
     explored
    
    <strong class="bold">
     
      Boost.Asio
     
    </strong>
    
     .
    
    
     Boost also provides another library,
    
    <strong class="bold">
     
      Boost.Log
     
    </strong>
    
     (
    
    <a href="https://github.com/boostorg/log">
     
      https://github.com/boostorg/log
     
    </a>
    
     ), a powerful
    
    <a id="_idIndexMarker820">
    </a>
    
     and configurable
    
    
     
      logging library.
     
    
   </p>
   <p>
    
     Google also provides many open source libraries, including
    
    <strong class="bold">
     
      glog
     
    </strong>
    
     , the Google
    
    <a id="_idIndexMarker821">
    </a>
    
     logging library (
    
    <a href="https://github.com/google/glog">
     
      https://github.com/google/glog
     
    </a>
    
     ), which is a C++14 library that provides C++-style streams APIs and
    
    
     
      helper macros.
     
    
   </p>
   <p>
    
     If the developer is familiar with Java, an excellent choice could be
    
    <a id="_idIndexMarker822">
    </a>
    
     Apache
    
    <strong class="bold">
     
      Log4cxx
     
    </strong>
    
     (
    
    <a href="https://logging.apache.org/log4cxx">
     
      https://logging.apache.org/log4cxx
     
    </a>
    
     ), based
    
    <a id="_idIndexMarker823">
    </a>
    
     on
    
    <strong class="bold">
     
      Log4j
     
    </strong>
    
     (
    
    <a href="https://logging.apache.org/log4j">
     
      https://logging.apache.org/log4j
     
    </a>
    
     ), a versatile, industrial-grade, Java
    
    
     
      logging framework.
     
    
   </p>
   <p>
    
     Other logging libraries worth considering are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       spdlog
      
     </strong>
     
      (
     
     <a href="https://github.com/gabime/spdlog">
      
       https://github.com/gabime/spdlog
      
     </a>
     
      ) is an interesting logging library that we can use with the
     
     <strong class="source-inline">
      
       {fmt}
      
     </strong>
     
      library.
     
     
      Also, the program can start logging messages and queuing them since startup, even before the log output file name
     
     
      
       is specified.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Quill
      
     </strong>
     
      (https://github.com/odygrd/quill) is
     
     <a id="_idIndexMarker824">
     </a>
     
      an asynchronous low-latency C++
     
     
      
       logging library.
      
     
    </li>
    <li>
     <strong class="bold">
      
       NanoLog
      
     </strong>
     
      (https://github.com/PlatformLab/NanoLog) is
     
     <a id="_idIndexMarker825">
     </a>
     
      a nanosecond scale logging system with
     
     
      <strong class="source-inline">
       
        printf
       
      </strong>
     
     
      
       -like APIs.
      
     
    </li>
    <li>
     <strong class="bold">
      
       lwlog
      
     </strong>
     
      (https://github.com/ChristianPanov/lwlog) is an
     
     <a id="_idIndexMarker826">
     </a>
     
      amazingly fast asynchronous C++17
     
     
      
       logging library.
      
     
    </li>
    <li>
     <strong class="bold">
      
       XTR
      
     </strong>
     
      (https://github.com/choll/xtr) is a fast
     
     <a id="_idIndexMarker827">
     </a>
     
      and convenient C++ logging library for low-latency and
     
     
      
       real-time environments.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Reckless
      
     </strong>
     
      (https://github.com/mattiasflodin/reckless) is a
     
     <a id="_idIndexMarker828">
     </a>
     
      low-latency and high-throughput
     
     
      
       logging library.
      
     
    </li>
    <li>
     <strong class="bold">
      
       uberlog
      
     </strong>
     
      (https://github.com/IMQS/uberlog) is a cross-platform and multi-process C++
     
     
      
       logging system.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Easylogging++
      
     </strong>
     
      (https://github.com/abumq/easyloggingpp) is a single-header C++ logging library with the ability to write our own sinks and
     
     
      
       track performance.
      
     
    </li>
    <li>
     <strong class="bold">
      
       tracetool
      
     </strong>
     
      (https://github.com/froglogic/tracetool) is a logging and tracing
     
     
      
       shared
      
     
     
      <a id="_idIndexMarker829">
      </a>
     
     
      
       library.
      
     
    </li>
   </ul>
   <p>
    
     As a guideline, depending on the system to develop, we might choose one of the
    
    
     
      following libraries:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       For low-latency or real-time systems
      
     </strong>
     
      : Quill, XTR,
     
     
      
       or Reckless
      
     
    </li>
    <li>
     <strong class="bold">
      
       For high performance at nanosecond scale
      
     </strong>
     
      <strong class="bold">
       
        logging
       
      </strong>
     
     
      
       : NanoLog
      
     
    </li>
    <li>
     <strong class="bold">
      
       For asynchronous logging
      
     </strong>
     
      : Quill
     
     
      
       or
      
     
     
      <strong class="source-inline">
       
        lwlog
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       For cross-platform, multi-process
      
     </strong>
     
      <strong class="bold">
       
        applications
       
      </strong>
     
     
      
       :
      
     
     
      <strong class="source-inline">
       
        uberlog
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       For simple and flexible logging
      
     </strong>
     
      : Easylogging++
     
     
      
       or glog
      
     
    </li>
    <li>
     <strong class="bold">
      
       For familiarity with Java
      
     </strong>
     
      <strong class="bold">
       
        logging
       
      </strong>
     
     
      
       : Log4cxx
      
     
    </li>
   </ul>
   <p>
    
     All libraries have advantages but also disadvantages that need to be investigated prior to selecting a library
    
    <a id="_idIndexMarker830">
    </a>
    
     to include in your system.
    
    
     The following
    
    <a id="_idIndexMarker831">
    </a>
    
     table summarizes
    
    
     
      these points:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-4">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Library
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Advantages
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Disadvantages
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           spdlog
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Easy integration,
        
        
         
          performance-focused, customizable
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Lacks some advanced features for extreme
        
        
         
          low-latency needs
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Quill
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         High performance in
        
        
         
          low-latency systems
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         More complex setup compared to simpler,
        
        
         
          synchronous loggers
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          NanoLog
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Best in class for speed, optimized
        
        
         
          for performance
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Limited in features; suited for specialized
        
        
         
          use cases
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           lwlog
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Lightweight, good for
        
        
         
          quick integration
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Less mature and feature-rich
        
        
         
          than alternatives
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          XTR
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Very efficient,
        
        
         
          user-friendly interface
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         More suited for specific
        
        
         
          real-time applications
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Reckless
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Highly optimized for throughput and
        
        
         
          low latency
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Limited flexibility compared to more
        
        
         
          general-purpose loggers
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           uberlog
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Great for multi-process and
        
        
         
          distributed systems
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Not as fast as specialized
        
        
         
          low-latency loggers
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Easylogging++
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Easy to use, customizable
        
        
         
          output sinks
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Less performance-optimized than some
        
        
         
          other libraries
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           tracetool
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Combines logging and tracing in
        
        
         
          one library
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Not focused on low-latency
        
        
         
          or high-throughput
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Boost.Log
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Versatile, integrates well with
        
        
         
          Boost libraries
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Higher complexity; can be overkill for simple
        
        
         
          logging needs
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          glog
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Simple to use, good for projects requiring
        
        
         
          easy APIs
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Not as feature-rich for
        
        
         
          advanced customization
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Log4cxx
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Robust, time-tested,
        
        
         
          industrial-strength logging
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         More complex to set up, especially for
        
        
         
          smaller projects
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 11.1: Advantages and disadvantages of various libraries
    
   </p>
   <p>
    
     Please visit
    
    <a id="_idIndexMarker832">
    </a>
    
     the logging
    
    <a id="_idIndexMarker833">
    </a>
    
     libraries’ websites to understand better what features they provide and compare performance
    
    
     
      between them.
     
    
   </p>
   <p>
    
     As
    
    <strong class="source-inline">
     
      spdlog
     
    </strong>
    
     is the most forked and starred C++ logging library repository in GitHub, in the next section, we will implement an example of using this library to catch a
    
    
     
      race condition.
     
    
   </p>
   <h2 id="_idParaDest-235">
    <a id="_idTextAnchor234">
    </a>
    
     Logging a deadlock – an example
    
   </h2>
   <p>
    
     Before implementing this example, we need to install the
    
    <strong class="source-inline">
     
      spdlog
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      {fmt}
     
    </strong>
    
     libraries.
    
    <strong class="source-inline">
     
      {fmt}
     
    </strong>
    
     (https://github.com/fmtlib/fmt) is an open source formatting library providing a fast
    
    <a id="_idIndexMarker834">
    </a>
    
     and safe
    
    <a id="_idIndexMarker835">
    </a>
    
     alternative to
    
    
     
      C++ IOStreams.
     
    
   </p>
   <p>
    
     Please check their documentation and follow the installation steps depending on
    
    
     
      your platform.
     
    
   </p>
   <p>
    
     Let’s implement an example where a deadlock is happening.
    
    
     As we learned in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     , a deadlock can happen when two or more threads need to acquire more than one mutex to perform their work.
    
    
     If mutexes are not acquired in the same order, a thread can acquire a mutex and wait forever for another mutex acquired by
    
    
     
      another thread.
     
    
   </p>
   <p>
    
     In this example, two threads need to acquire two mutexes,
    
    <strong class="source-inline">
     
      mtx1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      mtx2
     
    </strong>
    
     , to increase the value of the
    
    <strong class="source-inline">
     
      counter1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      counter2
     
    </strong>
    
     counters and swap their values.
    
    
     As the mutexes are acquired in different order by the threads, a deadlock
    
    
     
      can happen.
     
    
   </p>
   <p>
    
     Let’s start by including the
    
    
     
      required libraries:
     
    
   </p>
   <pre class="source-code">
#include &lt;fmt/core.h&gt;
#include &lt;spdlog/sinks/basic_file_sink.h&gt;
#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;
#include &lt;spdlog/spdlog.h&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, we define the counters
    
    
     
      and mutexes:
     
    
   </p>
   <pre class="source-code">
uint32_t counter1{};
std::mutex mtx1;
uint32_t counter2{};
std::mutex mtx2;</pre>
   <p>
    
     Before spawning the threads, let’s set
    
    <a id="_idIndexMarker836">
    </a>
    
     up a
    
    <strong class="bold">
     
      multi-sink logger
     
    </strong>
    
     , a logger that can write log messages into the console and a log file simultaneously.
    
    
     We will also set up its log level to debug, making the logger publish all log messages with a severity level greater than debug, and the
    
    <a id="_idIndexMarker837">
    </a>
    
     format for each log line consisting of
    
    <a id="_idIndexMarker838">
    </a>
    
     the timestamp, the thread identifier, the log level, and the
    
    
     
      log message:
     
    
   </p>
   <pre class="source-code">
auto console_sink = std::make_shared&lt;
         spdlog::sinks::stdout_color_sink_mt&gt;();
console_sink-&gt;set_level(spdlog::level::debug);
auto file_sink = std::make_shared&lt;
         spdlog::sinks::basic_file_sink_mt&gt;("logging.log",
                                            true);
file_sink-&gt;set_level(spdlog::level::info);
spdlog::logger logger("multi_sink",
         {console_sink, file_sink});
logger.set_pattern(
         "%Y-%m-%d %H:%M:%S.%f - Thread %t [%l] : %v");
logger.set_level(spdlog::level::debug);</pre>
   <p>
    
     We also declare an
    
    <strong class="source-inline">
     
      increase_and_swap
     
    </strong>
    
     lambda function that increases the values of both counters and
    
    
     
      swaps them:
     
    
   </p>
   <pre class="source-code">
auto increase_and_swap = [&amp;]() {
    logger.info("Incrementing both counters...");
    counter1++;
    counter2++;
    logger.info("Swapping counters...");
    std::swap(counter1, counter2);
};</pre>
   <p>
    
     Two worker lambda functions,
    
    <strong class="source-inline">
     
      worker1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     , acquire both mutexes and call
    
    <strong class="source-inline">
     
      increase_and_swap()
     
    </strong>
    
     before exiting.
    
    
     As lock guard (
    
    <strong class="source-inline">
     
      std::lock_guard
     
    </strong>
    
     ) objects are used, the
    
    <a id="_idIndexMarker839">
    </a>
    
     mutexes are released when
    
    <a id="_idIndexMarker840">
    </a>
    
     leaving the worker lambda functions during
    
    
     
      their destruction:
     
    
   </p>
   <pre class="source-code">
auto worker1 = [&amp;]() {
    logger.debug("Entering worker1");
    logger.info("Locking mtx1...");
    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);
    logger.info("Mutex mtx1 locked");
    std::this_thread::sleep_for(100ms);
    logger.info("Locking mtx2...");
    std::lock_guard&lt;std::mutex&gt; lock2(mtx2);
    logger.info("Mutex mtx2 locked");
    increase_and_swap();
    logger.debug("Leaving worker1");
};
auto worker2 = [&amp;]() {
    logger.debug("Entering worker2");
    logger.info("Locking mtx2...");
    std::lock_guard&lt;std::mutex&gt; lock2(mtx2);
    logger.info("Mutex mtx2 locked");
    std::this_thread::sleep_for(100ms);
    logger.info("Locking mtx1...");
    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);
    logger.info("Mutex mtx1 locked");
    increase_and_swap();
    logger.debug("Leaving worker2");
};
logger.debug("Starting main function...");
std::thread t1(worker1);
std::thread t2(worker2);
t1.join();
t2.join();</pre>
   <p>
    
     Both worker lambda functions are similar but with a small difference:
    
    <strong class="source-inline">
     
      worker1
     
    </strong>
    
     acquires
    
    <strong class="source-inline">
     
      mutex1
     
    </strong>
    
     and then
    
    <strong class="source-inline">
     
      mutex2
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     follows the opposite order, first acquiring
    
    <strong class="source-inline">
     
      mutex2
     
    </strong>
    
     and then
    
    <strong class="source-inline">
     
      mutex1
     
    </strong>
    
     .
    
    
     There is a sleep period between both mutexes’ acquisition to let the other thread acquire its mutex, therefore, provoking a deadlock as
    
    <strong class="source-inline">
     
      worker1
     
    </strong>
    
     will acquire
    
    <strong class="source-inline">
     
      mutex1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     will
    
    
     
      acquire
     
    
    
     <strong class="source-inline">
      
       mutex2
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Then, after sleeping,
    
    <strong class="source-inline">
     
      worker1
     
    </strong>
    
     will try to acquire
    
    <strong class="source-inline">
     
      mutex2
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     will try the same with
    
    <strong class="source-inline">
     
      mutex1
     
    </strong>
    
     , but none of them will succeed, blocking forever in
    
    
     
      a deadlock.
     
    
   </p>
   <p>
    
     The following is the
    
    <a id="_idIndexMarker841">
    </a>
    
     output
    
    <a id="_idIndexMarker842">
    </a>
    
     when running
    
    
     
      this code:
     
    
   </p>
   <pre class="console">
2024-09-04 23:39:54.484005 - Thread 38984 [debug] : Starting main function...
2024-09-04 23:39:54.484106 - Thread 38985 [debug] : Entering worker1
2024-09-04 23:39:54.484116 - Thread 38985 [info] : Locking mtx1...
2024-09-04 23:39:54.484136 - Thread 38986 [debug] : Entering worker2
2024-09-04 23:39:54.484151 - Thread 38986 [info] : Locking mtx2...
2024-09-04 23:39:54.484160 - Thread 38986 [info] : Mutex mtx2 locked
2024-09-04 23:39:54.484146 - Thread 38985 [info] : Mutex mtx1 locked
2024-09-04 23:39:54.584250 - Thread 38986 [info] : Locking mtx1...
2024-09-04 23:39:54.584255 - Thread 38985 [info] : Locking mtx2...</pre>
   <p>
    
     The first symptom to note when inspecting the logs is that the program never finishes and therefore probably
    
    
     
      is deadlocked.
     
    
   </p>
   <p>
    
     From the logger output, we can see that
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     (thread
    
    <strong class="source-inline">
     
      38985
     
    </strong>
    
     ) is running
    
    <strong class="source-inline">
     
      worker1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     (thread
    
    <strong class="source-inline">
     
      38986
     
    </strong>
    
     ) is running
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     .
    
    
     As soon as
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     enters
    
    <strong class="source-inline">
     
      worker1
     
    </strong>
    
     , it acquires
    
    <strong class="source-inline">
     
      mtx1
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      mtx2
     
    </strong>
    
     mutex is acquired by
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     though, as soon as
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     starts.
    
    
     Then, both threads wait for 100 ms and try to acquire the other mutex, but none succeed, and the program
    
    
     
      remains blocked.
     
    
   </p>
   <p>
    
     Logging is indispensable in production systems but imposes some performance penalty if abused, and most of the time requires human intervention to investigate an issue.
    
    
     As a compromise between log verbosity and performance penalty, one might choose to implement different logging levels and log only major events during normal operation, while still retaining the ability to provide extremely detailed logs if opted for, when the situation needs it.
    
    
     A more automated way to detect errors in code early in the development cycle is by using testing and code sanitizers, which we will learn about in the
    
    
     
      next chapter.
     
    
   </p>
   <p>
    
     Not all bugs can be
    
    <a id="_idIndexMarker843">
    </a>
    
     detected, so usually using a debugger is
    
    <a id="_idIndexMarker844">
    </a>
    
     the way to track down and fix bugs in software.
    
    
     Let’s learn next how to debug multithreading and
    
    
     
      asynchronous code.
     
    
   </p>
   <h1 id="_idParaDest-236">
    <a id="_idTextAnchor235">
    </a>
    
     How to debug asynchronous software
    
   </h1>
   <p>
    <strong class="bold">
     
      Debugging
     
    </strong>
    
     is the
    
    <a id="_idIndexMarker845">
    </a>
    
     process of finding and fixing errors in
    
    <a id="_idIndexMarker846">
    </a>
    
     
      computer programs.
     
    
   </p>
   <p>
    
     In this section, we will explore several techniques to debug multithreading and asynchronous software.
    
    
     You must have some previous knowledge of how to use debuggers, such as
    
    <strong class="bold">
     
      GDB
     
    </strong>
    
     (the GNU project debugger) or
    
    <strong class="bold">
     
      LLDB
     
    </strong>
    
     (the LLVM low-level debugger), and the terminology of the debugging process, such as breakpoints, watchers, backtraces, frames, and
    
    
     
      crash reports.
     
    
   </p>
   <p>
    
     Both GDB and LLDB are excellent debuggers with most of their commands being the same and only a few ones that differ.
    
    
     LLDB might be preferred if the program is being debugged on macOS or for large code bases.
    
    
     On the other hand, GDB has an established legacy, being familiar to many developers, and supporting a broader range of architectures and platforms.
    
    
     In this section, we will use GDB 15.1 just because it is part of the GNU framework and was designed to work alongside the
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     compiler, but most commands shown later can also be used with LLDB when debugging programs compiled
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       clang++
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     As some debugger features that deal with multithreading and asynchronous code are still in development, always update the debuggers to the latest versions to include up-to-date features
    
    
     
      and fixes.
     
    
   </p>
   <h2 id="_idParaDest-237">
    <a id="_idTextAnchor236">
    </a>
    
     Some useful GDB commands
    
   </h2>
   <p>
    
     Let’s start with some
    
    <a id="_idIndexMarker847">
    </a>
    
     GDB commands that
    
    <a id="_idIndexMarker848">
    </a>
    
     are useful when debugging any kind of program and acquire a foundation for the
    
    
     
      next sections.
     
    
   </p>
   <p>
    
     When debugging a program, we can start the debugger and pass the program as an argument.
    
    
     Extra arguments that the program might need can be passed with the
    
    <strong class="source-inline">
     
      --
     
    </strong>
    
     <strong class="source-inline">
      
       args
      
     </strong>
    
    
     
      option:
     
    
   </p>
   <pre class="console">
$ gdb &lt;program&gt; --args &lt;args&gt;</pre>
   <p>
    
     Or, we can attach the debugger to a running program by
    
    <a id="_idIndexMarker849">
    </a>
    
     using its
    
    <strong class="bold">
     
      process
     
    </strong>
    
     <strong class="bold">
      
       identifier
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       PID
      
     </strong>
    
    
     
      ):
     
    
   </p>
   <pre class="console">
$ gdb –p &lt;PID&gt;</pre>
   <p>
    
     Once inside the debugger, we can run the program (with the
    
    <strong class="source-inline">
     
      run
     
    </strong>
    
     command) or start it (with the
    
    <strong class="source-inline">
     
      start
     
    </strong>
    
     command).
    
    
     Running means that the program executes until reaching a breakpoint or finishing.
    
    <strong class="source-inline">
     
      start
     
    </strong>
    
     just places a temporary breakpoint at the beginning of the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function and runs the program, stopping the execution at the beginning of
    
    
     
      the program.
     
    
   </p>
   <p>
    
     If, for instance, we want to debug a program that has already crashed, we can use the core dump file that the crash generated, which might be stored in a specific location in the system (usually
    
    <strong class="source-inline">
     
      /var/lib/apport/coredump/
     
    </strong>
    
     on Linux systems, but please check for the exact location in your system by visiting the official documentation).
    
    
     Also, note that typically, core dumps are disabled by default, requiring the
    
    <strong class="source-inline">
     
      ulimit -c unlimited
     
    </strong>
    
     command to be run prior to, and in the same shell as, the program crashing.
    
    
     The
    
    <strong class="source-inline">
     
      unlimited
     
    </strong>
    
     argument can be changed to some arbitrary limit if we are dealing with an exceptionally large program or the system is short on
    
    
     
      disk space.
     
    
   </p>
   <p>
    
     After the
    
    <strong class="source-inline">
     
      coredump
     
    </strong>
    
     file is generated, just copy it to the location where the program binary is located and use the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ gdb &lt;program&gt; &lt;coredump&gt;</pre>
   <p>
    
     Note that all binaries must have debugging symbols, thus compiled with the
    
    <strong class="source-inline">
     
      –g
     
    </strong>
    
     option.
    
    
     In production systems, release binaries usually have symbols stripped and stored in separate files.
    
    
     There are GDB commands to include those symbols and command-line tools to inspect them, but this topic is beyond the scope of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     Once the debugger starts, we can use GDB commands to navigate through the code or check variables.
    
    
     Some useful commands are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       info args
      
     </strong>
     
      : This shows information about arguments used to call the
     
     
      
       current function.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       info locals
      
     </strong>
     
      : This shows local variables in the
     
     
      
       current scope.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       whatis
      
     </strong>
     
      : This shows the type of the given variable
     
     
      
       or expression.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       return
      
     </strong>
     
      : This returns from the current function without executing the rest of the instructions.
     
     
      A return value can
     
     
      
       be specified.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       backtrace
      
     </strong>
     
      : This lists all stack frames in the current
     
     
      
       call stack.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       frame
      
     </strong>
     
      : This lets you change to a specific
     
     
      
       stack frame.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       up
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       down
      
     </strong>
     
      : This moves across the call stack, toward the caller (
     
     <strong class="source-inline">
      
       up
      
     </strong>
     
      ) or the callee (
     
     <strong class="source-inline">
      
       down
      
     </strong>
     
      ) of the
     
     
      
       current function.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       print
      
     </strong>
     
      : This evaluates and displays the value of an expression, being that expression a variable name, a class member, a pointer to a memory region, or directly a memory address.
     
     
      We can also define pretty printers to display our
     
     
      
       own classes.
      
     
    </li>
   </ul>
   <p>
    
     Let’s finish this section
    
    <a id="_idIndexMarker850">
    </a>
    
     with one of the most basic
    
    <a id="_idIndexMarker851">
    </a>
    
     but also used techniques for debugging programs.
    
    
     This technique is called
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     .
    
    
     Every developer has used
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     or alternative commands to print the content of variables along the code path to show their contents in strategic code locations.
    
    
     In GDB, the
    
    <strong class="source-inline">
     
      dprintf
     
    </strong>
    
     command helps to set
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     -style breakpoints that print information when those breakpoints are hit but without stopping the program execution.
    
    
     This way, we can use print statements when debugging a program without the need for code modifications, recompilation, and
    
    
     
      program restarts.
     
    
   </p>
   <p>
    
     Its syntax is
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ dprintf &lt;location&gt;, &lt;format&gt;, &lt;args&gt;</pre>
   <p>
    
     For example, if we want to set a
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     statement at line 25 to print the content of the
    
    <strong class="source-inline">
     
      x
     
    </strong>
    
     variable but only if its value is greater than
    
    <strong class="source-inline">
     
      5
     
    </strong>
    
     , this is
    
    
     
      the command:
     
    
   </p>
   <pre class="console">
$ dprintf 25, "x = %d\n", x if x &gt; 5</pre>
   <p>
    
     Now that we have some
    
    <a id="_idIndexMarker852">
    </a>
    
     foundations, let’s
    
    <a id="_idIndexMarker853">
    </a>
    
     start by debugging a
    
    
     
      multithreaded program.
     
    
   </p>
   <h2 id="_idParaDest-238">
    <a id="_idTextAnchor237">
    </a>
    
     Debugging multithreaded programs
    
   </h2>
   <p>
    
     The example shown
    
    <a id="_idIndexMarker854">
    </a>
    
     here will never
    
    <a id="_idIndexMarker855">
    </a>
    
     finish as a deadlock will happen as two mutexes are locked in a different order by different threads, as already explained earlier in this chapter when
    
    
     
      introducing logging:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
int main() {
    std::mutex mtx1, mtx2;
    std::thread t1([&amp;]() {
        std::lock_guard lock1(mtx1);
        std::this_thread::sleep_for(100ms);
        std::lock_guard lock2(mtx2);
    });
    std::thread t2([&amp;]() {
        std::lock_guard lock2(mtx2);
        std::this_thread::sleep_for(100ms);
        std::lock_guard lock1(mtx1);
    });
    t1.join();
    t2.join();
    return 0;
}</pre>
   <p>
    
     First, let’s compile this example using
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     and add debug symbols (the
    
    <strong class="source-inline">
     
      –g
     
    </strong>
    
     option) and disallow code optimization (the
    
    <strong class="source-inline">
     
      –O0
     
    </strong>
    
     option), preventing the compiler from restructuring the binary code and making it more difficult for the debugger to find and show relevant information by using the
    
    <strong class="source-inline">
     
      --
     
    </strong>
    
     <strong class="source-inline">
      
       fno-omit-frame-pointer
      
     </strong>
    
    
     
      option.
     
    
   </p>
   <p>
    
     The following command compiles the
    
    <strong class="source-inline">
     
      test.cpp
     
    </strong>
    
     source file and generates the
    
    <strong class="source-inline">
     
      test
     
    </strong>
    
     binary.
    
    
     We can also use
    
    <strong class="source-inline">
     
      clang++
     
    </strong>
    
     with the
    
    
     
      same options:
     
    
   </p>
   <pre class="console">
$ g++ -o test –g -O0 --fno-omit-frame-pointer test.cpp</pre>
   <p>
    
     If we run the resulting program, this will
    
    
     
      never finish:
     
    
   </p>
   <pre class="console">
$ ./test</pre>
   <p>
    
     To debug a program
    
    <a id="_idIndexMarker856">
    </a>
    
     that is running, let’s first
    
    <a id="_idIndexMarker857">
    </a>
    
     retrieve its PID by using the
    
    <strong class="source-inline">
     
      ps
     
    </strong>
    
     
      Unix command:
     
    
   </p>
   <pre class="console">
$ ps aux | grep test</pre>
   <p>
    
     Then, attach the debugger by providing
    
    <strong class="source-inline">
     
      pid
     
    </strong>
    
     and start debugging
    
    
     
      the program:
     
    
   </p>
   <pre class="console">
$ gdb –p &lt;pid&gt;</pre>
   <p>
    
     Say the debugger starts with the
    
    
     
      following message:
     
    
   </p>
   <pre class="console">
ptrace: Operation not permitted.</pre>
   <p>
    
     Then, just run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ sudo sysctl -w kernel.yama.ptrace_scope=0</pre>
   <p>
    
     Once GDB starts properly, you will be able to type commands into
    
    
     
      its prompt.
     
    
   </p>
   <p>
    
     The first command we can execute is the next one to check what threads
    
    
     
      are running:
     
    
   </p>
   <pre class="console">
(gdb) info threads
  Id   Target Id                                Frame
* 1    Thread 0x79d1f3883740 (LWP 14428) "test" 0x000079d1f3298d61 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=14429, futex_word=0x79d1f3000990)
    at ./nptl/futex-internal.c:57
  2    Thread 0x79d1f26006c0 (LWP 14430) "test" futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146
  3    Thread 0x79d1f30006c0 (LWP 14429) "test" futex_wait (private=0, expected=2, futex_word=0x7fff5e406b30) at ../sysdeps/nptl/futex-internal.h:146</pre>
   <p>
    
     The output shows that the
    
    <strong class="source-inline">
     
      0x79d1f3883740
     
    </strong>
    
     thread with GDB identifier
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     is the current one.
    
    
     If there are many threads and we are only interested in a specific subset, let’s say threads 1 and 3, we can show information only for those threads by using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
(gdb) info thread 1 3</pre>
   <p>
    
     Running a GDB
    
    <a id="_idIndexMarker858">
    </a>
    
     command will affect
    
    <a id="_idIndexMarker859">
    </a>
    
     the current thread.
    
    
     For example, running the
    
    <strong class="source-inline">
     
      bt
     
    </strong>
    
     command will show the backtrace for thread 1 (
    
    
     
      output simplified):
     
    
   </p>
   <pre class="console">
(gdb) bt
#0  0x000079d1f3298d61 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=14429, futex_word=0x79d1f3000990) at ./nptl/futex-internal.c:57
#5  0x000061cbaf1174fd in main () at 11x18-debug_deadlock.cpp:22</pre>
   <p>
    
     To switch to another thread, for example, thread 2, we can use the
    
    
     <strong class="source-inline">
      
       thread
      
     </strong>
    
    
     
      command:
     
    
   </p>
   <pre class="console">
(gdb) thread 2
[Switching to thread 2 (Thread 0x79d1f26006c0 (LWP 14430))]</pre>
   <p>
    
     Now, the
    
    <strong class="source-inline">
     
      bt
     
    </strong>
    
     command will show the backtrace for thread 2 (
    
    
     
      output simplified):
     
    
   </p>
   <pre class="console">
(gdb) bt
#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146
#2  0x000079d1f32a00f1 in lll_mutex_lock_optimized (mutex=0x7fff5e406b00) at ./nptl/pthread_mutex_lock.c:48
#7  0x000061cbaf1173fa in operator() (__closure=0x61cbafd64418) at 11x18-debug_deadlock.cpp:19</pre>
   <p>
    
     To execute a command in different threads, just use the
    
    <strong class="source-inline">
     
      thread apply
     
    </strong>
    
     command, in this case, executing the
    
    <strong class="source-inline">
     
      bt
     
    </strong>
    
     command on threads 1
    
    
     
      and 3:
     
    
   </p>
   <pre class="console">
(gdb) thread apply 1 3 bt</pre>
   <p>
    
     To execute a command in all threads, just use
    
    <strong class="source-inline">
     
      thread apply
     
    </strong>
    
     <strong class="source-inline">
      
       all &lt;command&gt;
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Note that when a breakpoint is reached in a multithreaded program, all threads of execution stop running, allowing the examination of the overall state of the program.
    
    
     When the execution is restarted by commands such as
    
    <strong class="source-inline">
     
      continue
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      step
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      next
     
    </strong>
    
     , all threads resume.
    
    
     The current thread will move one statement forward, but that is not guaranteed for other threads, which could move forward several statements or even stop in the middle of
    
    
     
      a statement.
     
    
   </p>
   <p>
    
     When the execution stops, the debugger will jump and show the context of the execution in the current thread.
    
    
     To avoid the debugger jumping between threads by locking the scheduler, we can use the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
(gdb) set scheduler-locking &lt;on/off&gt;</pre>
   <p>
    
     We can also use the following command to check the scheduler
    
    
     
      locking status:
     
    
   </p>
   <pre class="console">
(gdb) show scheduler-locking</pre>
   <p>
    
     Now that we
    
    <a id="_idIndexMarker860">
    </a>
    
     have learned some new
    
    <a id="_idIndexMarker861">
    </a>
    
     commands for multithreading debugging, let’s check what is happening with the application we attached to
    
    
     
      the debugger.
     
    
   </p>
   <p>
    
     If we retrieve the backtraces in threads 2 and 3, we can see the following (output simplified only showing the
    
    
     
      relevant parts):
     
    
   </p>
   <pre class="console">
(gdb) thread apply all bt
Thread 3 (Thread 0x79d1f30006c0 (LWP 14429) "test"):
#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b30) at ../sysdeps/nptl/futex-internal.h:146
#5  0x000061cbaf117e20 in std::mutex::lock (this=0x7fff5e406b30) at /usr/include/c++/14/bits/std_mutex.h:113
#7  0x000061cbaf117334 in operator() (__closure=0x61cbafd642b8) at 11x18-debug_deadlock.cpp:13
Thread 2 (Thread 0x79d1f26006c0 (LWP 14430) "test"):
#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146
#5  0x000061cbaf117e20 in std::mutex::lock (this=0x7fff5e406b00) at /usr/include/c++/14/bits/std_mutex.h:113
#7  0x000061cbaf1173fa in operator() (__closure=0x61cbafd64418) at 11x18-debug_deadlock.cpp:19</pre>
   <p>
    
     Note that, after running
    
    <strong class="source-inline">
     
      std::mutex::lock()
     
    </strong>
    
     , both threads are waiting at line 13 for thread 3 and at 19 for thread 2, which matches with
    
    <strong class="source-inline">
     
      std::lock_guard
     
    </strong>
    <strong class="source-inline">
     
      lock2
     
    </strong>
    
     in
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::lock_guard
     
    </strong>
    <strong class="source-inline">
     
      lock1
     
    </strong>
    
     in
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     <strong class="source-inline">
      
       t2
      
     </strong>
    
    
     
      , respectively.
     
    
   </p>
   <p>
    
     Therefore, we
    
    <a id="_idIndexMarker862">
    </a>
    
     detected a deadlock
    
    <a id="_idIndexMarker863">
    </a>
    
     happening in those threads at these
    
    
     
      code locations.
     
    
   </p>
   <p>
    
     Let’s now learn more about debugging multithreaded software by catching a
    
    
     
      race condition.
     
    
   </p>
   <h2 id="_idParaDest-239">
    <a id="_idTextAnchor238">
    </a>
    
     Debugging race conditions
    
   </h2>
   <p>
    
     Race conditions
    
    <a id="_idIndexMarker864">
    </a>
    
     are
    
    <a id="_idIndexMarker865">
    </a>
    
     one of the most difficult bugs to detect and debug because they usually occur sporadically and with different effects each time, and sometimes some expensive computation happens before the program reaches the point
    
    
     
      of failure.
     
    
   </p>
   <p>
    
     This erratic behavior is not only caused by race conditions.
    
    
     Other issues related to incorrect memory allocation can cause similar symptoms, so it’s not possible to classify a bug as a race condition until there is some investigation and we reach a
    
    
     
      root-cause diagnosis.
     
    
   </p>
   <p>
    
     One way of debugging race conditions is to use watchpoints to manually inspect if a variable changes its value without any statement executed in the current thread modifying it, or placing breakpoints in strategic locations triggered by specific threads when reached, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="console">
(gdb) break &lt;linespec&gt; thread &lt;id&gt; if &lt;condition&gt;</pre>
   <p>
    
     For example, see
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
(gdb) break test.cpp:11 thread 2</pre>
   <p>
    
     Or, even using assertions and checking if the current value of any variable accessed by different threads has
    
    <a id="_idIndexMarker866">
    </a>
    
     the expected value.
    
    
     This
    
    <a id="_idIndexMarker867">
    </a>
    
     approach is followed in the
    
    
     
      next example:
     
    
   </p>
   <pre class="source-code">
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
static int g_value = 0;
static std::mutex g_mutex;
void func1() {
    const std::lock_guard&lt;std::mutex&gt; lock(g_mutex);
    for (int i = 0; i &lt; 10; ++i) {
        int old_value = g_value;
        int incr = (rand() % 10);
        g_value += incr;
        assert(g_value == old_value + incr);
        std::this_thread::sleep_for(10ms);
    }
}
void func2() {
    for (int i = 0; i &lt; 10; ++i) {
        int old_value = g_value;
        int incr = (rand() % 10);
        g_value += (rand() % 10);
        assert(g_value == old_value + incr);
        std::this_thread::sleep_for(10ms);
    }
}
int main() {
    std::thread t1(func1);
    std::thread t2(func2);
    t1.join();
    t2.join();
    return 0;
}</pre>
   <p>
    
     Here, two threads,
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     , are running functions that increase the
    
    <strong class="source-inline">
     
      g_value
     
    </strong>
    
     global variable by a random value.
    
    
     Each time it is increased,
    
    <strong class="source-inline">
     
      g_value
     
    </strong>
    
     is compared with the expected value, and if they are not equal, the assert instruction will stop
    
    
     
      the program.
     
    
   </p>
   <p>
    
     Compile this program and run the debugger
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ g++ -o test -g -O0 test
$ gdb ./test</pre>
   <p>
    
     After the debugger starts, run the program by using the
    
    <strong class="source-inline">
     
      run
     
    </strong>
    
     command.
    
    
     The program will run and, at some point, abort by receiving the
    
    <strong class="source-inline">
     
      SIGABRT
     
    </strong>
    
     signal, showing that the assertion was
    
    
     
      not met.
     
    
   </p>
   <pre class="console">
test: test.cpp:29: void func2(): Assertion `g_value == old_value + incr' failed.
Thread 3 "test" received signal SIGABRT, Aborted.</pre>
   <p>
    
     With the program stopped, we can use the
    
    <strong class="source-inline">
     
      backtrace
     
    </strong>
    
     commands to check the backtrace at that point and change the source code at that point of failure to a specific
    
    <strong class="source-inline">
     
      frame
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       list
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This example is quite simple, so it’s clear through checking the assertion output that something is going wrong with the
    
    <strong class="source-inline">
     
      g_value
     
    </strong>
    
     variable, and this is most probably a
    
    
     
      race condition.
     
    
   </p>
   <p>
    
     But with a more elaborate program, this process of manually debugging issues is quite arduous, so let’s focus
    
    <a id="_idIndexMarker868">
    </a>
    
     on another technique
    
    <a id="_idIndexMarker869">
    </a>
    
     called reverse debugging that can help
    
    
     
      with that.
     
    
   </p>
   <h2 id="_idParaDest-240">
    <a id="_idTextAnchor239">
    </a>
    
     Reverse debugging
    
   </h2>
   <p>
    <strong class="bold">
     
      Reverse debugging
     
    </strong>
    
     , also
    
    <a id="_idIndexMarker870">
    </a>
    
     known as
    
    <strong class="bold">
     
      time travel debugging
     
    </strong>
    
     , allows
    
    <a id="_idIndexMarker871">
    </a>
    
     a debugger
    
    <a id="_idIndexMarker872">
    </a>
    
     to stop a program after failure and go back into the history of the execution of a program to investigate the reason for the failure.
    
    
     This functionality is achieved by logging (recording) the execution of each machine instruction of the program being debugged together with each change in values of memory and registers, and afterward, using these records to replay and rewind the program
    
    
     
      at will.
     
    
   </p>
   <p>
    
     On Linux, we can use GDB (since version 7.0),
    
    <strong class="bold">
     
      rr
     
    </strong>
    
     (originally developed by Mozilla,
    
    <a href="https://rr-project.org">
     
      https://rr-project.org
     
    </a>
    
     ), or
    
    <strong class="bold">
     
      Undo’s time travel debugger
     
    </strong>
    
     (
    
    <strong class="bold">
     
      UDB
     
    </strong>
    
     ) (
    
    <a href="https://docs.undo.io">
     
      https://docs.undo.io
     
    </a>
    
     ).
    
    
     On Windows, we
    
    <a id="_idIndexMarker873">
    </a>
    
     can
    
    <a id="_idIndexMarker874">
    </a>
    
     use
    
    <strong class="bold">
     
      Time Travel
     
    </strong>
    
     <strong class="bold">
      
       Debugging
      
     </strong>
    
    
     
      (
     
    
    <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview">
     
      
       https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Reverse debugging is only supported by a limited number of GDB targets, such as remote target Simics,
    
    <strong class="bold">
     
      system integration and design
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SID
     
    </strong>
    
     ) simulators, or the
    
    <strong class="source-inline">
     
      process record and replay
     
    </strong>
    
     target for native Linux (only for
    
    <strong class="source-inline">
     
      i386
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      amd64
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      moxie-elf
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      arm
     
    </strong>
    
     ).
    
    
     At the time of authoring this book, Clang’s reverse debugging feature is still
    
    
     
      under development.
     
    
   </p>
   <p>
    
     Therefore, due to these limitations, we decided to do a small showcase by using
    
    <strong class="source-inline">
     
      rr
     
    </strong>
    
     .
    
    
     Please follow the instructions on the project website to build and install the
    
    <strong class="source-inline">
     
      rr
     
    </strong>
    
     debugging
    
    
     
      tool:
     
    
    <a href="https://github.com/rr-debugger/rr/wiki/Building-And-Installing">
     
      
       https://github.com/rr-debugger/rr/wiki/Building-And-Installing
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Once installed, to
    
    <a id="_idIndexMarker875">
    </a>
    
     record and replay a program, use the
    
    
     
      following commands:
     
    
   </p>
   <pre class="console">
$ rr record &lt;program&gt; --args &lt;args&gt;
$ rr replay</pre>
   <p>
    
     For example, if we have a program called
    
    <strong class="source-inline">
     
      test
     
    </strong>
    
     , the command sequence will be
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ rr record test
rr: Saving execution to trace directory `/home/user/.local/share/rr/test-1'.</pre>
   <p>
    
     Say the following
    
    <a id="_idIndexMarker876">
    </a>
    
     fatal error is
    
    
     
      shown instead:
     
    
   </p>
   <pre class="console">
[FATAL src/PerfCounters.cc:349:start_counter()] rr needs /proc/sys/kernel/perf_event_paranoid &lt;= 3, but it is 4.
Change it to &lt;= 3.
Consider putting 'kernel.perf_event_paranoid = 3' in /etc/sysctl.d/10-rr.conf.</pre>
   <p>
    
     Then, use the following command to adjust the kernel
    
    
     
      variable,
     
    
    
     <strong class="source-inline">
      
       kernel.perf_event_paranoid
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
$ sudo sysctl kernel.perf_event_paranoid=1</pre>
   <p>
    
     Once a record is available, use the
    
    <strong class="source-inline">
     
      replay
     
    </strong>
    
     command to start debugging
    
    
     
      the program:
     
    
   </p>
   <pre class="console">
$ rr replay</pre>
   <p>
    
     Or, if the program crashed and you want just to start debugging at the end of the recording, use the
    
    <strong class="source-inline">
     
      –
     
    </strong>
    
     <strong class="source-inline">
      
       e
      
     </strong>
    
    
     
      option:
     
    
   </p>
   <pre class="console">
$ rr replay -e</pre>
   <p>
    
     At this point,
    
    <strong class="source-inline">
     
      rr
     
    </strong>
    
     will use the GDB debugger to start the program and load its debug symbols.
    
    
     Then, you can use any of the following commands to
    
    
     
      reverse debugging:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       reverse-continue
      
     </strong>
     
      : Start executing the program in reverse.
     
     
      Execution will stop when a breakpoint is reached or due to a
     
     
      
       synchronous exception.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       reverse-next
      
     </strong>
     
      : Run backward to the beginning of the previous line executed in the current
     
     
      
       stack frame.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       reverse-nexti
      
     </strong>
     
      : This executes a single instruction in reverse, jumping those moving to inner
     
     
      
       stack frames.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       reverse-step
      
     </strong>
     
      : Run the program backward until the control reaches the start of a new
     
     
      
       source line.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       reverse-stepi
      
     </strong>
     
      : Execute in reverse one
     
     
      
       machine instruction.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       reverse-finish
      
     </strong>
     
      : This executes until the current function invocation, that is, the beginning of the
     
     
      
       current function.
      
     
    </li>
   </ul>
   <p>
    
     We can also reverse
    
    <a id="_idIndexMarker877">
    </a>
    
     the direction of debugging and use regular commands for forward debugging (such as
    
    <strong class="source-inline">
     
      next
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      step
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      continue
     
    </strong>
    
     , and so on) in the opposite direction by using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
(rr) set exec-direction reverse</pre>
   <p>
    
     To set the execution direction back to forward, use the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
(rr) set exec-direction forward</pre>
   <p>
    
     As an exercise, install the
    
    <strong class="source-inline">
     
      rr
     
    </strong>
    
     debugger and try to debug the previous example using
    
    
     
      reverse debugging.
     
    
   </p>
   <p>
    
     Let’s now move on
    
    <a id="_idIndexMarker878">
    </a>
    
     to how to debug coroutines, a challenging
    
    <a id="_idIndexMarker879">
    </a>
    
     task due to their
    
    
     
      asynchronous nature.
     
    
   </p>
   <h2 id="_idParaDest-241">
    <a id="_idTextAnchor240">
    </a>
    
     Debugging coroutines
    
   </h2>
   <p>
    
     As we have seen
    
    <a id="_idIndexMarker880">
    </a>
    
     so far, asynchronous
    
    <a id="_idIndexMarker881">
    </a>
    
     code can be debugged as synchronous code, by using breakpoints in strategic places with specific conditions, using watchpoints to inspect variables, and stepping into or over to walk through the code.
    
    
     Also, using techniques described earlier to select specific threads and locking the scheduler helps to avoid unnecessary distractions
    
    
     
      when debugging.
     
    
   </p>
   <p>
    
     As we have already learned, there are complexities in asynchronous code, such as what thread will be used when the asynchronous code is executed, which makes it more difficult to debug.
    
    
     For C++ coroutines, debugging is even harder to master due to their
    
    
     
      suspend/resume nature.
     
    
   </p>
   <p>
    
     Clang compiles programs using coroutines in two steps: Semantic analysis is performed by Clang, and coroutine frames are constructed and
    
    <a id="_idIndexMarker882">
    </a>
    
     optimized in the
    
    <strong class="bold">
     
      LLVM
     
    </strong>
    
     middle-end.
    
    
     As debug information is generated in the Clang frontend, there will be insufficient debug information as coroutine frames are generated later in the compilation process.
    
    
     GCC follows a
    
    
     
      similar approach.
     
    
   </p>
   <p>
    
     Also, if the execution breaks inside a coroutine, the current frame will only have one variable,
    
    <strong class="source-inline">
     
      frame_ptr
     
    </strong>
    
     .
    
    
     In a coroutine, there are no pointer or function parameters.
    
    
     Coroutines store their state in the heap before suspending, and only using the stack during execution.
    
    <strong class="source-inline">
     
      frame_ptr
     
    </strong>
    
     is used to access all necessary information for the coroutine to
    
    
     
      run properly.
     
    
   </p>
   <p>
    
     Let’s debug the
    
    <strong class="bold">
     
      Boost.Asio
     
    </strong>
    
     coroutine
    
    <a id="_idIndexMarker883">
    </a>
    
     example implemented in
    
    <a href="B22219_09.xhtml#_idTextAnchor184">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     .
    
    
     Here, we only show the relevant instructions.
    
    
     Please visit the
    
    <em class="italic">
     
      Coroutines
     
    </em>
    
     section in
    
    <a href="B22219_09.xhtml#_idTextAnchor184">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     to check the complete
    
    
     
      source code:
     
    
   </p>
   <pre class="source-code">
boost::asio::awaitable&lt;void&gt; echo(tcp::socket socket) {
    char data[1024];
    while (true) {
        std::cout &lt;&lt; "Reading data from socket...\n";//L12
        std::size_t bytes_read = co_await
            socket.async_read_some(
                boost::asio::buffer(data),
                             boost::asio::use_awaitable);
        /* .... */
        co_await boost::asio::async_write(socket,
                boost::asio::buffer(data, bytes_read),
                boost::asio::use_awaitable);
    }
}
boost::asio::awaitable&lt;void&gt;
listener(boost::asio::io_context&amp; io_context,
         unsigned short port) {
    tcp::acceptor acceptor(io_context,
                           tcp::endpoint(tcp::v4(), port));
    while (true) {
        std::cout &lt;&lt; "Accepting connections...\n";  // L45
        tcp::socket socket = co_await
            acceptor.async_accept(
                boost::asio::use_awaitable);
        boost::asio::co_spawn(io_context,
            echo(std::move(socket)),
            boost::asio::detached);
    }
}
/* main function */</pre>
   <p>
    
     As we are using Boost, let’s
    
    <a id="_idIndexMarker884">
    </a>
    
     include the
    
    <strong class="bold">
     
      Boost.System
     
    </strong>
    
     library to add more symbols for debugging when compiling the
    
    
     
      source code:
     
    
   </p>
   <pre class="console">
$ g++ --std=c++20 -ggdb -O0 --fno-omit-frame-pointer -lboost_system  test.cpp -o test</pre>
   <p>
    
     Then, we start the debugger with the generated program and set breakpoints in lines 12 and 45, which are the locations of the first instruction inside the while loops on
    
    
     
      each coroutine:
     
    
   </p>
   <pre class="console">
$ gdb –q ./test
(gdb) b 12
(gdb) b 45</pre>
   <p>
    
     We also enable the GDB
    
    <a id="_idIndexMarker885">
    </a>
    
     built-in pretty printers to show readable output for Standard Template
    
    
     
      Library containers:
     
    
   </p>
   <pre class="console">
(gdb) set print pretty on</pre>
   <p>
    
     If now we run the program (the
    
    <strong class="source-inline">
     
      run
     
    </strong>
    
     command), it will reach the breakpoint at line 42 inside the coroutine listener before accepting connections.
    
    
     Using the
    
    <strong class="source-inline">
     
      info locals
     
    </strong>
    
     command, we can check the
    
    
     
      local variables.
     
    
   </p>
   <p>
    
     Coroutines create a state machine with several internal fields, such as promise objects, with attached thread, address of caller object, pending exceptions, and so on.
    
    
     Also, they store
    
    <strong class="source-inline">
     
      resume
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      destroy
     
    </strong>
    
     callbacks.
    
    
     These structures are compiler-dependent, tied to the compiler’s implementation, and accessible via
    
    <strong class="source-inline">
     
      frame_ptr
     
    </strong>
    
     if we are
    
    
     
      using Clang.
     
    
   </p>
   <p>
    
     If we continue running the program (with the
    
    <strong class="source-inline">
     
      continue
     
    </strong>
    
     command), the server will be waiting for a client to connect.
    
    
     To exit the waiting status, we use
    
    <strong class="source-inline">
     
      telnet
     
    </strong>
    
     , as shown in
    
    <a href="B22219_09.xhtml#_idTextAnchor184">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     , to connect a client to the server.
    
    
     At that point, the execution will be stopped because the breakpoint at line 12 inside the
    
    <strong class="source-inline">
     
      echo()
     
    </strong>
    
     coroutine is reached, and
    
    <strong class="source-inline">
     
      info locals
     
    </strong>
    
     show the variables used by each
    
    
     <strong class="source-inline">
      
       echo
      
     </strong>
    
    
     
      connection.
     
    
   </p>
   <p>
    
     Using the
    
    <strong class="source-inline">
     
      backtrace
     
    </strong>
    
     command will show a call stack that might have some complexities due to the coroutines’
    
    
     
      suspend nature.
     
    
   </p>
   <p>
    
     In pure C++ routines, described in
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     , there are two expressions where setting breakpoints could
    
    
     
      be interesting:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      : The execution is suspended until the awaited operation is complete.
     
     
      Breakpoints can be set at the point where the coroutine is resumed by inspecting the underlying
     
     <strong class="source-inline">
      
       await_suspend
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       await_resume
      
     </strong>
     
      , or custom
     
     
      
       awaitable code.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       co_yield
      
     </strong>
     
      : Suspends execution and yields a value.
     
     
      During debugging, step into the
     
     <strong class="source-inline">
      
       co_yield
      
     </strong>
     
      to observe how control flows between coroutines and their
     
     
      
       calling functions.
      
     
    </li>
   </ul>
   <p>
    
     As coroutines are quite new in the C++ world and compilers are continuously evolving, we hope that soon debugging coroutines will be
    
    
     
      more straightforward.
     
    
   </p>
   <p>
    
     Once we have found and debugged some bugs and can reproduce scenarios that lead to those specific bugs, it would be convenient to design some tests that cover those cases to avoid future changes
    
    <a id="_idIndexMarker886">
    </a>
    
     in code that could lead to similar problems or incidents.
    
    
     Let’s learn how to test multithreaded and asynchronous code in the
    
    
     
      next chapter.
     
    
   </p>
   <h1 id="_idParaDest-242">
    <a id="_idTextAnchor241">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned how to use logging and debug
    
    
     
      asynchronous programs.
     
    
   </p>
   <p>
    
     We started by using logging to spot issues in running software, showing its usefulness in detecting deadlocks by using the
    
    <strong class="source-inline">
     
      spdlog
     
    </strong>
    
     logging library.
    
    
     Many other libraries were also discussed, describing their relevant features that might be suitable to
    
    
     
      specific scenarios.
     
    
   </p>
   <p>
    
     However, not all bugs can be spotted by using logs, and some may only be detected later in the software development life cycle when some issues happen in production, even when dealing with program crashes and incidents.
    
    
     Debuggers are useful tools to inspect running or crashed programs, understand their code path, and find bugs.
    
    
     Several examples and debugger commands were introduced to deal with generic code, but also and especially with multithreaded and asynchronous software, race conditions, and coroutines.
    
    
     Also, the
    
    <strong class="source-inline">
     
      rr
     
    </strong>
    
     debugger was introduced, showing the potential of including reverse debugging in our
    
    
     
      developer toolbox.
     
    
   </p>
   <p>
    
     In the next chapter, we will learn about using sanitizers and testing techniques to performance and optimization techniques that can be used to improve asynchronous programs’ runtime and
    
    
     
      resource usage.
     
    
   </p>
   <h1 id="_idParaDest-243">
    <a id="_idTextAnchor242">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     
      <em class="italic">
       
        Logging
       
      </em>
     
     
      
       :
      
     
     
      
       https://en.wikipedia.org/wiki/Logging_(computing)
      
     
    </li>
    <li>
     
      <em class="italic">
       
        Syslog
       
      </em>
     
     
      
       :
      
     
     
      
       https://en.wikipedia.org/wiki/Syslog
      
     
    </li>
    <li>
     <em class="italic">
      
       Google Logging
      
     </em>
     
      <em class="italic">
       
        Library
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/google/glog
      
     
    </li>
    <li>
     <em class="italic">
      
       Apache
      
     </em>
     
      <em class="italic">
       
        Log4cxx
       
      </em>
     
     
      
       :
      
     
     
      
       https://logging.apache.org/log4cxx
      
     
    </li>
    <li>
     
      <em class="italic">
       
        spdlog
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/gabime/spdlog
      
     
    </li>
    <li>
     
      <em class="italic">
       
        Quill
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/odygrd/quill
      
     
    </li>
    <li>
     
      <em class="italic">
       
        xtr
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/choll/xtr
      
     
    </li>
    <li>
     
      <em class="italic">
       
        lwlog
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/ChristianPanov/lwlog
      
     
    </li>
    <li>
     
      <em class="italic">
       
        uberlog
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/IMQS/uberlog
      
     
    </li>
    <li>
     
      <em class="italic">
       
        Easylogging++
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/abumq/easyloggingpp
      
     
    </li>
    <li>
     
      <em class="italic">
       
        NanoLog
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/PlatformLab/NanoLog
      
     
    </li>
    <li>
     <em class="italic">
      
       Reckless Logging
      
     </em>
     
      <em class="italic">
       
        Library
       
      </em>
     
     
      
       :
      
     
     
      
       https://github.com/mattiasflodin/reckless
      
     
    </li>
    <li>
     
      <em class="italic">
       
        tracetool
       
      </em>
     
     
      
       :
      
     
     <a href="https://github.com/froglogic/tracetool">
      
       
        https://github.com/froglogic/tracetool
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Logback
      
     </em>
     
      <em class="italic">
       
        Project
       
      </em>
     
     
      
       :
      
     
     <a href="https://logback.qos.ch">
      
       
        https://logback.qos.ch
       
      
     </a>
    </li>
    <li>
     
      <em class="italic">
       
        Sentry
       
      </em>
     
     
      
       :
      
     
     <a href="https://sentry.io">
      
       
        https://sentry.io
       
      
     </a>
    </li>
    <li>
     
      <em class="italic">
       
        Graylog
       
      </em>
     
     
      
       :
      
     
     <a href="https://graylog.org">
      
       
        https://graylog.org
       
      
     </a>
    </li>
    <li>
     
      <em class="italic">
       
        Logstash
       
      </em>
     
     
      
       :
      
     
     <a href="https://www.elastic.co/logstash">
      
       
        https://www.elastic.co/logstash
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Debugging with
      
     </em>
     
      <em class="italic">
       
        GDB
       
      </em>
     
     
      
       :
      
     
     <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html">
      
       
        https://sourceware.org/gdb/current/onlinedocs/gdb.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       LLDB
      
     </em>
     
      <em class="italic">
       
        tutorial
       
      </em>
     
     
      
       :
      
     
     <a href="https://lldb.llvm.org/use/tutorial.html">
      
       
        https://lldb.llvm.org/use/tutorial.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Clang Compiler User’s
      
     </em>
     
      <em class="italic">
       
        Manual
       
      </em>
     
     
      
       :
      
     
     <a href="https://clang.llvm.org/docs/UsersManual.html">
      
       
        https://clang.llvm.org/docs/UsersManual.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       GDB
      
     </em>
     
      :
     
     <em class="italic">
      
       Running programs
      
     </em>
     
      <em class="italic">
       
        backward
       
      </em>
     
     
      
       :
      
     
     <a href="https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution">
      
       
        https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Reverse Debugging with
      
     </em>
     
      <em class="italic">
       
        GDB
       
      </em>
     
     
      
       :
      
     
     <a href="https://sourceware.org/gdb/wiki/ReverseDebug">
      
       
        https://sourceware.org/gdb/wiki/ReverseDebug
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Debugging C++
      
     </em>
     
      <em class="italic">
       
        Coroutines
       
      </em>
     
     
      
       :
      
     
     <a href="https://clang.llvm.org/docs/DebuggingCoroutines.html">
      
       
        https://clang.llvm.org/docs/DebuggingCoroutines.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       SID Simulator User’s
      
     </em>
     
      <em class="italic">
       
        Guide
       
      </em>
     
     
      
       :
      
     
     <a href="https://sourceware.org/sid/sid-guide/book1.html">
      
       
        https://sourceware.org/sid/sid-guide/book1.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Intel Simics Simulator for Intel FPGAs: User
      
     </em>
     
      <em class="italic">
       
        Guide
       
      </em>
     
     
      
       :
      
     
     <a href="https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html">
      
       
        https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       IBM Support
      
     </em>
     
      :
     
     <em class="italic">
      
       How do I enable core
      
     </em>
     
      <em class="italic">
       
        dumps
       
      </em>
     
     
      
       :
      
     
     <a href="https://www.ibm.com/support/pages/how-do-i-enable-core-dumps">
      
       
        https://www.ibm.com/support/pages/how-do-i-enable-core-dumps
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Core Dumps – How to enable
      
     </em>
     
      <em class="italic">
       
        them?
       
      </em>
     
     
      
       :
      
     
     <a href="mailto:https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711">
      
       
        https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711
       
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>