<html><head></head><body>
  <div id="_idContainer065">
   <h1 class="chapter-number" id="_idParaDest-229">
    <a id="_idTextAnchor228">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     11
    </span>
   </h1>
   <h1 id="_idParaDest-230">
    <a id="_idTextAnchor229">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Logging and Debugging Asynchronous Software
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     There is no way to ensure that a software product is free from bugs, so from time to time, bugs can appear.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     This is when logging and debugging
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      are indispensable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Logging and debugging are essential for identifying and diagnosing issues in software systems.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     They provide visibility into the runtime behavior of code, helping developers trace errors, monitor performance, and understand the flow of execution.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     By using logging and debugging effectively, developers can detect bugs, resolve unexpected behavior, and improve overall system stability
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      and maintainability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     While writing this chapter, we assume you are already familiar with using a debugger to debug C++ programs and know some basic debugger commands and terminology, such as breakpoints, watchers, frames, or stack traces.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     To brush up on that knowledge, you can refer to the references provided in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.8.1">
      Further reading
     </span>
    </em>
    <span class="koboSpan" id="kobo.9.1">
     section at the end of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      the chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      How to use logging to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       spot bugs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      How to debug
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       asynchronous software
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-231">
    <a id="_idTextAnchor230">
    </a>
    <span class="koboSpan" id="kobo.17.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     For this chapter, we will need to install third-party libraries to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      compile examples.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.21.1">
      spdlog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.22.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.23.1">
      {fmt}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     libraries need to be installed to compile the example in the logging section.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     Please check their documentation (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.25.1">
      spdlog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.26.1">
     ’s documentation is available at
    </span>
    <a href="https://github.com/gabime/spdlog">
     <span class="koboSpan" id="kobo.27.1">
      https://github.com/gabime/spdlog
     </span>
    </a>
    <span class="koboSpan" id="kobo.28.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.29.1">
      {fmt}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.30.1">
     ’s documentation is available at
    </span>
    <a href="https://github.com/fmtlib/fmt">
     <span class="koboSpan" id="kobo.31.1">
      https://github.com/fmtlib/fmt
     </span>
    </a>
    <span class="koboSpan" id="kobo.32.1">
     ) and follow the installation steps suitable for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      your platform.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     Some examples need a compiler supporting C++20.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     Therefore, check the technical requirements section in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.35.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.36.1">
     , which has some guidance on how to install GCC 13 and Clang
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      8 compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     You can find all the complete code in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.40.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     The examples for this chapter are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.42.1">
      Chapter_11
     </span>
    </strong>
    <span class="koboSpan" id="kobo.43.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     All source code files can be compiled using CMake
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.45.1">
$ cmake . </span><span class="koboSpan" id="kobo.45.2">&amp;&amp; cmake —build .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.46.1">
     Executable binaries will be generated under the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.47.1">
       bin
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-232">
    <a id="_idTextAnchor231">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     How to use logging to spot bugs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     Let’s start with a
    </span>
    <a id="_idIndexMarker807">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     trivial but useful method for understanding what a software program does while executing –
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      logging.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.53.1">
      Logging
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     is the
    </span>
    <a id="_idIndexMarker808">
    </a>
    <span class="koboSpan" id="kobo.55.1">
     process of keeping a log of events that occur in a program, storing information by using messages to record how a program executes, tracking its flow, and helping with identifying issues
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      and bugs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.57.1">
     Most Unix-based logging systems use the standard
    </span>
    <a id="_idIndexMarker809">
    </a>
    <span class="koboSpan" id="kobo.58.1">
     protocol,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.59.1">
      syslog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     , created by Eric Altman back in 1980 as part of the Sendmail project.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     This standard protocol defines the boundaries between the software generating the log messages, the system storing them, and the software reporting and analyzing these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      log events.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Each log message includes a facility code and a severity level.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     The facility code identifies the type of system that originated a specific log message (user-level, kernel, system, network, etc.), and the severity level describes the condition of the system, indicating the urgency of dealing with a specific issue, the severity levels being emergency, alert, critical, error, warning, notice, info,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      and debug.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     Most logging systems or loggers provide various destinations or sinks for log messages: console, files that can later be opened and analyzed, remote syslog servers, or relays, among
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      other destinations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.66.1">
     Logging is useful where debuggers are not, as we will see later, especially in distributed, multithreaded, real-time, scientific, or event-centric applications, where inspecting data or following the program flow using the debugger can become a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      tedious task.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     Logging libraries usually also provide a thread-safe singleton class that allows multithreading and asynchronous writing to log files, helps with log rotation, avoids large log files by creating new ones on the fly without losing log events, and time stamping, for better tracking when a log
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      event happens.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     Instead of implementing our own multithreaded logging system, a better approach is to use some well-tested
    </span>
    <a id="_idIndexMarker810">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     and documented
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      production-ready libraries.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-233">
    <a id="_idTextAnchor232">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     How to select a third-party library
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     When selecting a
    </span>
    <a id="_idIndexMarker811">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     logging library (or any other library), we
    </span>
    <a id="_idIndexMarker812">
    </a>
    <span class="koboSpan" id="kobo.76.1">
     need to investigate the following points before integrating it into our software to avoid
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.77.1">
      future issues:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.78.1">
       Support
      </span>
     </strong>
     <span class="koboSpan" id="kobo.79.1">
      : Is the library updated and upgraded regularly?
     </span>
     <span class="koboSpan" id="kobo.79.2">
      Is there a community or active ecosystem around the library that can help with any questions that can arise?
     </span>
     <span class="koboSpan" id="kobo.79.3">
      Is the community happy using
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.80.1">
       the library?
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.81.1">
       Quality
      </span>
     </strong>
     <span class="koboSpan" id="kobo.82.1">
      : Is there a public bugs report system?
     </span>
     <span class="koboSpan" id="kobo.82.2">
      Are bug reports dealt with promptly, providing solutions and fixing bugs in the library?
     </span>
     <span class="koboSpan" id="kobo.82.3">
      Does it support recent compiler versions and support latest
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.83.1">
       C++ features?
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.84.1">
       Security
      </span>
     </strong>
     <span class="koboSpan" id="kobo.85.1">
      : Does the library, or any of its dependent libraries, have any
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.86.1">
       vulnerabilities reported?
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.87.1">
       License
      </span>
     </strong>
     <span class="koboSpan" id="kobo.88.1">
      : Is the library license aligned with our development and product needs?
     </span>
     <span class="koboSpan" id="kobo.88.2">
      Is the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.89.1">
       cost affordable?
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.90.1">
     For complex systems, it may be worth considering centralized systems to collect and generate logging reports or
    </span>
    <a id="_idIndexMarker813">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     dashboards, such
    </span>
    <a id="_idIndexMarker814">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.93.1">
      Sentry
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     (
    </span>
    <a href="https://sentry.io">
     <span class="koboSpan" id="kobo.95.1">
      https://sentry.io
     </span>
    </a>
    <span class="koboSpan" id="kobo.96.1">
     ) or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.97.1">
      Logstash
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     (
    </span>
    <a href="https://www.elastic.co/logstash">
     <span class="koboSpan" id="kobo.99.1">
      https://www.elastic.co/logstash
     </span>
    </a>
    <span class="koboSpan" id="kobo.100.1">
     ), that can collect, parse, and
    </span>
    <a id="_idIndexMarker815">
    </a>
    <span class="koboSpan" id="kobo.101.1">
     transform
    </span>
    <a id="_idIndexMarker816">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     logs, and can be integrated with other tools, such
    </span>
    <a id="_idIndexMarker817">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.104.1">
      Graylog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.105.1">
     (https://graylog.org),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.106.1">
      Grafana
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     (https://grafana.com), or
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.108.1">
       Kibana
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      https://www.elastic.co/kibana
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     The next section describes some interesting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      logging libraries.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-234">
    <a id="_idTextAnchor233">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     Some relevant logging libraries
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     There are many
    </span>
    <a id="_idIndexMarker818">
    </a>
    <span class="koboSpan" id="kobo.116.1">
     logging libraries in the market, each covering some specific software requirements.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     Depending on the program constraints and needs, one of the following libraries might be more suitable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      than others.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     In
    </span>
    <a href="B22219_09.xhtml#_idTextAnchor184">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.119.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.120.1">
     , we
    </span>
    <a id="_idIndexMarker819">
    </a>
    <span class="koboSpan" id="kobo.121.1">
     explored
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.122.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     .
    </span>
    <span class="koboSpan" id="kobo.123.2">
     Boost also provides another library,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.124.1">
      Boost.Log
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     (
    </span>
    <a href="https://github.com/boostorg/log">
     <span class="koboSpan" id="kobo.126.1">
      https://github.com/boostorg/log
     </span>
    </a>
    <span class="koboSpan" id="kobo.127.1">
     ), a powerful
    </span>
    <a id="_idIndexMarker820">
    </a>
    <span class="koboSpan" id="kobo.128.1">
     and configurable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      logging library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     Google also provides many open source libraries, including
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.131.1">
      glog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     , the Google
    </span>
    <a id="_idIndexMarker821">
    </a>
    <span class="koboSpan" id="kobo.133.1">
     logging library (
    </span>
    <a href="https://github.com/google/glog">
     <span class="koboSpan" id="kobo.134.1">
      https://github.com/google/glog
     </span>
    </a>
    <span class="koboSpan" id="kobo.135.1">
     ), which is a C++14 library that provides C++-style streams APIs and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.136.1">
      helper macros.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.137.1">
     If the developer is familiar with Java, an excellent choice could be
    </span>
    <a id="_idIndexMarker822">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     Apache
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.139.1">
      Log4cxx
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     (
    </span>
    <a href="https://logging.apache.org/log4cxx">
     <span class="koboSpan" id="kobo.141.1">
      https://logging.apache.org/log4cxx
     </span>
    </a>
    <span class="koboSpan" id="kobo.142.1">
     ), based
    </span>
    <a id="_idIndexMarker823">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     on
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.144.1">
      Log4j
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     (
    </span>
    <a href="https://logging.apache.org/log4j">
     <span class="koboSpan" id="kobo.146.1">
      https://logging.apache.org/log4j
     </span>
    </a>
    <span class="koboSpan" id="kobo.147.1">
     ), a versatile, industrial-grade, Java
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      logging framework.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     Other logging libraries worth considering are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.150.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.151.1">
       spdlog
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      (
     </span>
     <a href="https://github.com/gabime/spdlog">
      <span class="koboSpan" id="kobo.153.1">
       https://github.com/gabime/spdlog
      </span>
     </a>
     <span class="koboSpan" id="kobo.154.1">
      ) is an interesting logging library that we can use with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.155.1">
       {fmt}
      </span>
     </strong>
     <span class="koboSpan" id="kobo.156.1">
      library.
     </span>
     <span class="koboSpan" id="kobo.156.2">
      Also, the program can start logging messages and queuing them since startup, even before the log output file name
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.157.1">
       is specified.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.158.1">
       Quill
      </span>
     </strong>
     <span class="koboSpan" id="kobo.159.1">
      (https://github.com/odygrd/quill) is
     </span>
     <a id="_idIndexMarker824">
     </a>
     <span class="koboSpan" id="kobo.160.1">
      an asynchronous low-latency C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.161.1">
       logging library.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.162.1">
       NanoLog
      </span>
     </strong>
     <span class="koboSpan" id="kobo.163.1">
      (https://github.com/PlatformLab/NanoLog) is
     </span>
     <a id="_idIndexMarker825">
     </a>
     <span class="koboSpan" id="kobo.164.1">
      a nanosecond scale logging system with
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.165.1">
        printf
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.166.1">
       -like APIs.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.167.1">
       lwlog
      </span>
     </strong>
     <span class="koboSpan" id="kobo.168.1">
      (https://github.com/ChristianPanov/lwlog) is an
     </span>
     <a id="_idIndexMarker826">
     </a>
     <span class="koboSpan" id="kobo.169.1">
      amazingly fast asynchronous C++17
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.170.1">
       logging library.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.171.1">
       XTR
      </span>
     </strong>
     <span class="koboSpan" id="kobo.172.1">
      (https://github.com/choll/xtr) is a fast
     </span>
     <a id="_idIndexMarker827">
     </a>
     <span class="koboSpan" id="kobo.173.1">
      and convenient C++ logging library for low-latency and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.174.1">
       real-time environments.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.175.1">
       Reckless
      </span>
     </strong>
     <span class="koboSpan" id="kobo.176.1">
      (https://github.com/mattiasflodin/reckless) is a
     </span>
     <a id="_idIndexMarker828">
     </a>
     <span class="koboSpan" id="kobo.177.1">
      low-latency and high-throughput
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.178.1">
       logging library.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.179.1">
       uberlog
      </span>
     </strong>
     <span class="koboSpan" id="kobo.180.1">
      (https://github.com/IMQS/uberlog) is a cross-platform and multi-process C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.181.1">
       logging system.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.182.1">
       Easylogging++
      </span>
     </strong>
     <span class="koboSpan" id="kobo.183.1">
      (https://github.com/abumq/easyloggingpp) is a single-header C++ logging library with the ability to write our own sinks and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.184.1">
       track performance.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.185.1">
       tracetool
      </span>
     </strong>
     <span class="koboSpan" id="kobo.186.1">
      (https://github.com/froglogic/tracetool) is a logging and tracing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.187.1">
       shared
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker829">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.188.1">
       library.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     As a guideline, depending on the system to develop, we might choose one of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      following libraries:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.191.1">
       For low-latency or real-time systems
      </span>
     </strong>
     <span class="koboSpan" id="kobo.192.1">
      : Quill, XTR,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.193.1">
       or Reckless
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.194.1">
       For high performance at nanosecond scale
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.195.1">
        logging
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.196.1">
       : NanoLog
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.197.1">
       For asynchronous logging
      </span>
     </strong>
     <span class="koboSpan" id="kobo.198.1">
      : Quill
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.199.1">
       or
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.200.1">
        lwlog
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.201.1">
       For cross-platform, multi-process
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.202.1">
        applications
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.203.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.204.1">
        uberlog
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.205.1">
       For simple and flexible logging
      </span>
     </strong>
     <span class="koboSpan" id="kobo.206.1">
      : Easylogging++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.207.1">
       or glog
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.208.1">
       For familiarity with Java
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.209.1">
        logging
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.210.1">
       : Log4cxx
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     All libraries have advantages but also disadvantages that need to be investigated prior to selecting a library
    </span>
    <a id="_idIndexMarker830">
    </a>
    <span class="koboSpan" id="kobo.212.1">
     to include in your system.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     The following
    </span>
    <a id="_idIndexMarker831">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     table summarizes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      these points:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-4">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.215.1">
           Library
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.216.1">
           Advantages
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.217.1">
           Disadvantages
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.218.1">
           spdlog
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.219.1">
         Easy integration,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.220.1">
          performance-focused, customizable
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.221.1">
         Lacks some advanced features for extreme
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.222.1">
          low-latency needs
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.223.1">
          Quill
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.224.1">
         High performance in
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.225.1">
          low-latency systems
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.226.1">
         More complex setup compared to simpler,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.227.1">
          synchronous loggers
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.228.1">
          NanoLog
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.229.1">
         Best in class for speed, optimized
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.230.1">
          for performance
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.231.1">
         Limited in features; suited for specialized
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.232.1">
          use cases
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.233.1">
           lwlog
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.234.1">
         Lightweight, good for
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.235.1">
          quick integration
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.236.1">
         Less mature and feature-rich
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.237.1">
          than alternatives
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.238.1">
          XTR
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.239.1">
         Very efficient,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.240.1">
          user-friendly interface
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.241.1">
         More suited for specific
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.242.1">
          real-time applications
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.243.1">
          Reckless
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.244.1">
         Highly optimized for throughput and
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.245.1">
          low latency
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.246.1">
         Limited flexibility compared to more
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.247.1">
          general-purpose loggers
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.248.1">
           uberlog
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.249.1">
         Great for multi-process and
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.250.1">
          distributed systems
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.251.1">
         Not as fast as specialized
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.252.1">
          low-latency loggers
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.253.1">
          Easylogging++
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.254.1">
         Easy to use, customizable
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.255.1">
          output sinks
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.256.1">
         Less performance-optimized than some
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.257.1">
          other libraries
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.258.1">
           tracetool
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.259.1">
         Combines logging and tracing in
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.260.1">
          one library
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.261.1">
         Not focused on low-latency
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.262.1">
          or high-throughput
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.263.1">
          Boost.Log
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.264.1">
         Versatile, integrates well with
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.265.1">
          Boost libraries
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.266.1">
         Higher complexity; can be overkill for simple
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.267.1">
          logging needs
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.268.1">
          glog
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.269.1">
         Simple to use, good for projects requiring
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.270.1">
          easy APIs
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.271.1">
         Not as feature-rich for
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.272.1">
          advanced customization
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.273.1">
          Log4cxx
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.274.1">
         Robust, time-tested,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.275.1">
          industrial-strength logging
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.276.1">
         More complex to set up, especially for
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.277.1">
          smaller projects
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.278.1">
     Table 11.1: Advantages and disadvantages of various libraries
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.279.1">
     Please visit
    </span>
    <a id="_idIndexMarker832">
    </a>
    <span class="koboSpan" id="kobo.280.1">
     the logging
    </span>
    <a id="_idIndexMarker833">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     libraries’ websites to understand better what features they provide and compare performance
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      between them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     As
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      spdlog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     is the most forked and starred C++ logging library repository in GitHub, in the next section, we will implement an example of using this library to catch a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      race condition.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-235">
    <a id="_idTextAnchor234">
    </a>
    <span class="koboSpan" id="kobo.287.1">
     Logging a deadlock – an example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.288.1">
     Before implementing this example, we need to install the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      spdlog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      {fmt}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     libraries.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.293.1">
      {fmt}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.294.1">
     (https://github.com/fmtlib/fmt) is an open source formatting library providing a fast
    </span>
    <a id="_idIndexMarker834">
    </a>
    <span class="koboSpan" id="kobo.295.1">
     and safe
    </span>
    <a id="_idIndexMarker835">
    </a>
    <span class="koboSpan" id="kobo.296.1">
     alternative to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.297.1">
      C++ IOStreams.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.298.1">
     Please check their documentation and follow the installation steps depending on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      your platform.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     Let’s implement an example where a deadlock is happening.
    </span>
    <span class="koboSpan" id="kobo.300.2">
     As we learned in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.301.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.302.1">
     , a deadlock can happen when two or more threads need to acquire more than one mutex to perform their work.
    </span>
    <span class="koboSpan" id="kobo.302.2">
     If mutexes are not acquired in the same order, a thread can acquire a mutex and wait forever for another mutex acquired by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      another thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     In this example, two threads need to acquire two mutexes,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      mtx1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.307.1">
      mtx2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     , to increase the value of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      counter1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      counter2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     counters and swap their values.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     As the mutexes are acquired in different order by the threads, a deadlock
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      can happen.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     Let’s start by including the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      required libraries:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.316.1">
#include &lt;fmt/core.h&gt;
#include &lt;spdlog/sinks/basic_file_sink.h&gt;
#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;
#include &lt;spdlog/spdlog.h&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     function, we define the counters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      and mutexes:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.321.1">
uint32_t counter1{};
std::mutex mtx1;
uint32_t counter2{};
std::mutex mtx2;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     Before spawning the threads, let’s set
    </span>
    <a id="_idIndexMarker836">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     up a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.324.1">
      multi-sink logger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     , a logger that can write log messages into the console and a log file simultaneously.
    </span>
    <span class="koboSpan" id="kobo.325.2">
     We will also set up its log level to debug, making the logger publish all log messages with a severity level greater than debug, and the
    </span>
    <a id="_idIndexMarker837">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     format for each log line consisting of
    </span>
    <a id="_idIndexMarker838">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     the timestamp, the thread identifier, the log level, and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.328.1">
      log message:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.329.1">
auto console_sink = std::make_shared&lt;
         spdlog::sinks::stdout_color_sink_mt&gt;();
console_sink-&gt;set_level(spdlog::level::debug);
auto file_sink = std::make_shared&lt;
         spdlog::sinks::basic_file_sink_mt&gt;("logging.log",
                                            true);
file_sink-&gt;set_level(spdlog::level::info);
spdlog::logger logger("multi_sink",
         {console_sink, file_sink});
logger.set_pattern(
         "%Y-%m-%d %H:%M:%S.%f - Thread %t [%l] : %v");
logger.set_level(spdlog::level::debug);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.330.1">
     We also declare an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      increase_and_swap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     lambda function that increases the values of both counters and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      swaps them:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.334.1">
auto increase_and_swap = [&amp;]() {
    logger.info("Incrementing both counters...");
    counter1++;
    counter2++;
    logger.info("Swapping counters...");
    std::swap(counter1, counter2);
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     Two worker lambda functions,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.338.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     , acquire both mutexes and call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      increase_and_swap()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     before exiting.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     As lock guard (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.342.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.343.1">
     ) objects are used, the
    </span>
    <a id="_idIndexMarker839">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     mutexes are released when
    </span>
    <a id="_idIndexMarker840">
    </a>
    <span class="koboSpan" id="kobo.345.1">
     leaving the worker lambda functions during
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      their destruction:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.347.1">
auto worker1 = [&amp;]() {
    logger.debug("Entering worker1");
    logger.info("Locking mtx1...");
    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);
    logger.info("Mutex mtx1 locked");
    std::this_thread::sleep_for(100ms);
    logger.info("Locking mtx2...");
    std::lock_guard&lt;std::mutex&gt; lock2(mtx2);
    logger.info("Mutex mtx2 locked");
    increase_and_swap();
    logger.debug("Leaving worker1");
};
auto worker2 = [&amp;]() {
    logger.debug("Entering worker2");
    logger.info("Locking mtx2...");
    std::lock_guard&lt;std::mutex&gt; lock2(mtx2);
    logger.info("Mutex mtx2 locked");
    std::this_thread::sleep_for(100ms);
    logger.info("Locking mtx1...");
    std::lock_guard&lt;std::mutex&gt; lock1(mtx1);
    logger.info("Mutex mtx1 locked");
    increase_and_swap();
    logger.debug("Leaving worker2");
};
logger.debug("Starting main function...");
std::thread t1(worker1);
std::thread t2(worker2);
t1.join();
t2.join();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Both worker lambda functions are similar but with a small difference:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     acquires
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.351.1">
      mutex1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     and then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.353.1">
      mutex2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.354.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.355.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     follows the opposite order, first acquiring
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      mutex2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     and then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.359.1">
      mutex1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     .
    </span>
    <span class="koboSpan" id="kobo.360.2">
     There is a sleep period between both mutexes’ acquisition to let the other thread acquire its mutex, therefore, provoking a deadlock as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     will acquire
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      mutex1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.365.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      acquire
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.368.1">
       mutex2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.369.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     Then, after sleeping,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     will try to acquire
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.373.1">
      mutex2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.374.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.375.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.376.1">
     will try the same with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      mutex1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     , but none of them will succeed, blocking forever in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.379.1">
      a deadlock.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.380.1">
     The following is the
    </span>
    <a id="_idIndexMarker841">
    </a>
    <span class="koboSpan" id="kobo.381.1">
     output
    </span>
    <a id="_idIndexMarker842">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     when running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.383.1">
      this code:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.384.1">
2024-09-04 23:39:54.484005 - Thread 38984 [debug] : Starting main function...
</span><span class="koboSpan" id="kobo.384.2">2024-09-04 23:39:54.484106 - Thread 38985 [debug] : Entering worker1
2024-09-04 23:39:54.484116 - Thread 38985 [info] : Locking mtx1...
</span><span class="koboSpan" id="kobo.384.3">2024-09-04 23:39:54.484136 - Thread 38986 [debug] : Entering worker2
2024-09-04 23:39:54.484151 - Thread 38986 [info] : Locking mtx2...
</span><span class="koboSpan" id="kobo.384.4">2024-09-04 23:39:54.484160 - Thread 38986 [info] : Mutex mtx2 locked
2024-09-04 23:39:54.484146 - Thread 38985 [info] : Mutex mtx1 locked
2024-09-04 23:39:54.584250 - Thread 38986 [info] : Locking mtx1...
</span><span class="koboSpan" id="kobo.384.5">2024-09-04 23:39:54.584255 - Thread 38985 [info] : Locking mtx2...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     The first symptom to note when inspecting the logs is that the program never finishes and therefore probably
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.386.1">
      is deadlocked.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.387.1">
     From the logger output, we can see that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.388.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     (thread
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      38985
     </span>
    </strong>
    <span class="koboSpan" id="kobo.391.1">
     ) is running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.394.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.395.1">
     (thread
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.396.1">
      38986
     </span>
    </strong>
    <span class="koboSpan" id="kobo.397.1">
     ) is running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     .
    </span>
    <span class="koboSpan" id="kobo.399.2">
     As soon as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.400.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.401.1">
     enters
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.402.1">
      worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.403.1">
     , it acquires
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.404.1">
      mtx1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.405.1">
     .
    </span>
    <span class="koboSpan" id="kobo.405.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.406.1">
      mtx2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.407.1">
     mutex is acquired by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     though, as soon as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.410.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.411.1">
     starts.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     Then, both threads wait for 100 ms and try to acquire the other mutex, but none succeed, and the program
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      remains blocked.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     Logging is indispensable in production systems but imposes some performance penalty if abused, and most of the time requires human intervention to investigate an issue.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     As a compromise between log verbosity and performance penalty, one might choose to implement different logging levels and log only major events during normal operation, while still retaining the ability to provide extremely detailed logs if opted for, when the situation needs it.
    </span>
    <span class="koboSpan" id="kobo.413.3">
     A more automated way to detect errors in code early in the development cycle is by using testing and code sanitizers, which we will learn about in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      next chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     Not all bugs can be
    </span>
    <a id="_idIndexMarker843">
    </a>
    <span class="koboSpan" id="kobo.416.1">
     detected, so usually using a debugger is
    </span>
    <a id="_idIndexMarker844">
    </a>
    <span class="koboSpan" id="kobo.417.1">
     the way to track down and fix bugs in software.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     Let’s learn next how to debug multithreading and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.418.1">
      asynchronous code.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-236">
    <a id="_idTextAnchor235">
    </a>
    <span class="koboSpan" id="kobo.419.1">
     How to debug asynchronous software
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.420.1">
      Debugging
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     is the
    </span>
    <a id="_idIndexMarker845">
    </a>
    <span class="koboSpan" id="kobo.422.1">
     process of finding and fixing errors in
    </span>
    <a id="_idIndexMarker846">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.423.1">
      computer programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     In this section, we will explore several techniques to debug multithreading and asynchronous software.
    </span>
    <span class="koboSpan" id="kobo.424.2">
     You must have some previous knowledge of how to use debuggers, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.425.1">
      GDB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     (the GNU project debugger) or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.427.1">
      LLDB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.428.1">
     (the LLVM low-level debugger), and the terminology of the debugging process, such as breakpoints, watchers, backtraces, frames, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      crash reports.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.430.1">
     Both GDB and LLDB are excellent debuggers with most of their commands being the same and only a few ones that differ.
    </span>
    <span class="koboSpan" id="kobo.430.2">
     LLDB might be preferred if the program is being debugged on macOS or for large code bases.
    </span>
    <span class="koboSpan" id="kobo.430.3">
     On the other hand, GDB has an established legacy, being familiar to many developers, and supporting a broader range of architectures and platforms.
    </span>
    <span class="koboSpan" id="kobo.430.4">
     In this section, we will use GDB 15.1 just because it is part of the GNU framework and was designed to work alongside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     compiler, but most commands shown later can also be used with LLDB when debugging programs compiled
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.434.1">
       clang++
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.436.1">
     As some debugger features that deal with multithreading and asynchronous code are still in development, always update the debuggers to the latest versions to include up-to-date features
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.437.1">
      and fixes.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-237">
    <a id="_idTextAnchor236">
    </a>
    <span class="koboSpan" id="kobo.438.1">
     Some useful GDB commands
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.439.1">
     Let’s start with some
    </span>
    <a id="_idIndexMarker847">
    </a>
    <span class="koboSpan" id="kobo.440.1">
     GDB commands that
    </span>
    <a id="_idIndexMarker848">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     are useful when debugging any kind of program and acquire a foundation for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.442.1">
      next sections.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.443.1">
     When debugging a program, we can start the debugger and pass the program as an argument.
    </span>
    <span class="koboSpan" id="kobo.443.2">
     Extra arguments that the program might need can be passed with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.444.1">
      --
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.445.1">
       args
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      option:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.447.1">
$ gdb &lt;program&gt; --args &lt;args&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.448.1">
     Or, we can attach the debugger to a running program by
    </span>
    <a id="_idIndexMarker849">
    </a>
    <span class="koboSpan" id="kobo.449.1">
     using its
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.450.1">
      process
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.451.1">
       identifier
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.452.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.453.1">
       PID
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.454.1">
      ):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.455.1">
$ gdb –p &lt;PID&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     Once inside the debugger, we can run the program (with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.457.1">
      run
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     command) or start it (with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.459.1">
      start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.460.1">
     command).
    </span>
    <span class="koboSpan" id="kobo.460.2">
     Running means that the program executes until reaching a breakpoint or finishing.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.461.1">
      start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.462.1">
     just places a temporary breakpoint at the beginning of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.463.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.464.1">
     function and runs the program, stopping the execution at the beginning of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.466.1">
     If, for instance, we want to debug a program that has already crashed, we can use the core dump file that the crash generated, which might be stored in a specific location in the system (usually
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      /var/lib/apport/coredump/
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     on Linux systems, but please check for the exact location in your system by visiting the official documentation).
    </span>
    <span class="koboSpan" id="kobo.468.2">
     Also, note that typically, core dumps are disabled by default, requiring the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      ulimit -c unlimited
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     command to be run prior to, and in the same shell as, the program crashing.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      unlimited
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     argument can be changed to some arbitrary limit if we are dealing with an exceptionally large program or the system is short on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      disk space.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.474.1">
     After the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      coredump
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     file is generated, just copy it to the location where the program binary is located and use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.478.1">
$ gdb &lt;program&gt; &lt;coredump&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.479.1">
     Note that all binaries must have debugging symbols, thus compiled with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.480.1">
      –g
     </span>
    </strong>
    <span class="koboSpan" id="kobo.481.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     In production systems, release binaries usually have symbols stripped and stored in separate files.
    </span>
    <span class="koboSpan" id="kobo.481.3">
     There are GDB commands to include those symbols and command-line tools to inspect them, but this topic is beyond the scope of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      this book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     Once the debugger starts, we can use GDB commands to navigate through the code or check variables.
    </span>
    <span class="koboSpan" id="kobo.483.2">
     Some useful commands are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.484.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.485.1">
       info args
      </span>
     </strong>
     <span class="koboSpan" id="kobo.486.1">
      : This shows information about arguments used to call the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.487.1">
       current function.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.488.1">
       info locals
      </span>
     </strong>
     <span class="koboSpan" id="kobo.489.1">
      : This shows local variables in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.490.1">
       current scope.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.491.1">
       whatis
      </span>
     </strong>
     <span class="koboSpan" id="kobo.492.1">
      : This shows the type of the given variable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.493.1">
       or expression.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.494.1">
       return
      </span>
     </strong>
     <span class="koboSpan" id="kobo.495.1">
      : This returns from the current function without executing the rest of the instructions.
     </span>
     <span class="koboSpan" id="kobo.495.2">
      A return value can
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.496.1">
       be specified.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.497.1">
       backtrace
      </span>
     </strong>
     <span class="koboSpan" id="kobo.498.1">
      : This lists all stack frames in the current
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.499.1">
       call stack.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.500.1">
       frame
      </span>
     </strong>
     <span class="koboSpan" id="kobo.501.1">
      : This lets you change to a specific
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.502.1">
       stack frame.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.503.1">
       up
      </span>
     </strong>
     <span class="koboSpan" id="kobo.504.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.505.1">
       down
      </span>
     </strong>
     <span class="koboSpan" id="kobo.506.1">
      : This moves across the call stack, toward the caller (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.507.1">
       up
      </span>
     </strong>
     <span class="koboSpan" id="kobo.508.1">
      ) or the callee (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.509.1">
       down
      </span>
     </strong>
     <span class="koboSpan" id="kobo.510.1">
      ) of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.511.1">
       current function.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.512.1">
       print
      </span>
     </strong>
     <span class="koboSpan" id="kobo.513.1">
      : This evaluates and displays the value of an expression, being that expression a variable name, a class member, a pointer to a memory region, or directly a memory address.
     </span>
     <span class="koboSpan" id="kobo.513.2">
      We can also define pretty printers to display our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.514.1">
       own classes.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.515.1">
     Let’s finish this section
    </span>
    <a id="_idIndexMarker850">
    </a>
    <span class="koboSpan" id="kobo.516.1">
     with one of the most basic
    </span>
    <a id="_idIndexMarker851">
    </a>
    <span class="koboSpan" id="kobo.517.1">
     but also used techniques for debugging programs.
    </span>
    <span class="koboSpan" id="kobo.517.2">
     This technique is called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.518.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     .
    </span>
    <span class="koboSpan" id="kobo.519.2">
     Every developer has used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.520.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     or alternative commands to print the content of variables along the code path to show their contents in strategic code locations.
    </span>
    <span class="koboSpan" id="kobo.521.2">
     In GDB, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.522.1">
      dprintf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     command helps to set
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.524.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.525.1">
     -style breakpoints that print information when those breakpoints are hit but without stopping the program execution.
    </span>
    <span class="koboSpan" id="kobo.525.2">
     This way, we can use print statements when debugging a program without the need for code modifications, recompilation, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.526.1">
      program restarts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.527.1">
     Its syntax is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.528.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.529.1">
$ dprintf &lt;location&gt;, &lt;format&gt;, &lt;args&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.530.1">
     For example, if we want to set a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.531.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.532.1">
     statement at line 25 to print the content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.533.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.534.1">
     variable but only if its value is greater than
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.535.1">
      5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.536.1">
     , this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.537.1">
      the command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.538.1">
$ dprintf 25, "x = %d\n", x if x &gt; 5</span></pre>
   <p>
    <span class="koboSpan" id="kobo.539.1">
     Now that we have some
    </span>
    <a id="_idIndexMarker852">
    </a>
    <span class="koboSpan" id="kobo.540.1">
     foundations, let’s
    </span>
    <a id="_idIndexMarker853">
    </a>
    <span class="koboSpan" id="kobo.541.1">
     start by debugging a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      multithreaded program.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-238">
    <a id="_idTextAnchor237">
    </a>
    <span class="koboSpan" id="kobo.543.1">
     Debugging multithreaded programs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.544.1">
     The example shown
    </span>
    <a id="_idIndexMarker854">
    </a>
    <span class="koboSpan" id="kobo.545.1">
     here will never
    </span>
    <a id="_idIndexMarker855">
    </a>
    <span class="koboSpan" id="kobo.546.1">
     finish as a deadlock will happen as two mutexes are locked in a different order by different threads, as already explained earlier in this chapter when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.547.1">
      introducing logging:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.548.1">
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
int main() {
    std::mutex mtx1, mtx2;
    std::thread t1([&amp;]() {
        std::lock_guard lock1(mtx1);
        std::this_thread::sleep_for(100ms);
        std::lock_guard lock2(mtx2);
    });
    std::thread t2([&amp;]() {
        std::lock_guard lock2(mtx2);
        std::this_thread::sleep_for(100ms);
        std::lock_guard lock1(mtx1);
    });
    t1.join();
    t2.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.549.1">
     First, let’s compile this example using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.550.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.551.1">
     and add debug symbols (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.552.1">
      –g
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     option) and disallow code optimization (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      –O0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     option), preventing the compiler from restructuring the binary code and making it more difficult for the debugger to find and show relevant information by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.556.1">
      --
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.557.1">
       fno-omit-frame-pointer
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.558.1">
      option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.559.1">
     The following command compiles the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.560.1">
      test.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.561.1">
     source file and generates the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.562.1">
      test
     </span>
    </strong>
    <span class="koboSpan" id="kobo.563.1">
     binary.
    </span>
    <span class="koboSpan" id="kobo.563.2">
     We can also use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.564.1">
      clang++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.565.1">
     with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.566.1">
      same options:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.567.1">
$ g++ -o test –g -O0 --fno-omit-frame-pointer test.cpp</span></pre>
   <p>
    <span class="koboSpan" id="kobo.568.1">
     If we run the resulting program, this will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.569.1">
      never finish:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.570.1">
$ ./test</span></pre>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     To debug a program
    </span>
    <a id="_idIndexMarker856">
    </a>
    <span class="koboSpan" id="kobo.572.1">
     that is running, let’s first
    </span>
    <a id="_idIndexMarker857">
    </a>
    <span class="koboSpan" id="kobo.573.1">
     retrieve its PID by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.574.1">
      ps
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.575.1">
      Unix command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.576.1">
$ ps aux | grep test</span></pre>
   <p>
    <span class="koboSpan" id="kobo.577.1">
     Then, attach the debugger by providing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.578.1">
      pid
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     and start debugging
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.580.1">
      the program:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.581.1">
$ gdb –p &lt;pid&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.582.1">
     Say the debugger starts with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.583.1">
      following message:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.584.1">
ptrace: Operation not permitted.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.585.1">
     Then, just run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.586.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.587.1">
$ sudo sysctl -w kernel.yama.ptrace_scope=0</span></pre>
   <p>
    <span class="koboSpan" id="kobo.588.1">
     Once GDB starts properly, you will be able to type commands into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.589.1">
      its prompt.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.590.1">
     The first command we can execute is the next one to check what threads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.591.1">
      are running:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.592.1">
(gdb) info threads
  Id   Target Id                                Frame
* 1    Thread 0x79d1f3883740 (LWP 14428) "test" 0x000079d1f3298d61 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=14429, futex_word=0x79d1f3000990)
    at ./nptl/futex-internal.c:57
  2    Thread 0x79d1f26006c0 (LWP 14430) "test" futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146
  3    Thread 0x79d1f30006c0 (LWP 14429) "test" futex_wait (private=0, expected=2, futex_word=0x7fff5e406b30) at ../sysdeps/nptl/futex-internal.h:146</span></pre>
   <p>
    <span class="koboSpan" id="kobo.593.1">
     The output shows that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.594.1">
      0x79d1f3883740
     </span>
    </strong>
    <span class="koboSpan" id="kobo.595.1">
     thread with GDB identifier
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.596.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.597.1">
     is the current one.
    </span>
    <span class="koboSpan" id="kobo.597.2">
     If there are many threads and we are only interested in a specific subset, let’s say threads 1 and 3, we can show information only for those threads by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.598.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.599.1">
(gdb) info thread 1 3</span></pre>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     Running a GDB
    </span>
    <a id="_idIndexMarker858">
    </a>
    <span class="koboSpan" id="kobo.601.1">
     command will affect
    </span>
    <a id="_idIndexMarker859">
    </a>
    <span class="koboSpan" id="kobo.602.1">
     the current thread.
    </span>
    <span class="koboSpan" id="kobo.602.2">
     For example, running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.603.1">
      bt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.604.1">
     command will show the backtrace for thread 1 (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.605.1">
      output simplified):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.606.1">
(gdb) bt
#0  0x000079d1f3298d61 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=14429, futex_word=0x79d1f3000990) at ./nptl/futex-internal.c:57
#5  0x000061cbaf1174fd in main () at 11x18-debug_deadlock.cpp:22</span></pre>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     To switch to another thread, for example, thread 2, we can use the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.608.1">
       thread
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.609.1">
      command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.610.1">
(gdb) thread 2
[Switching to thread 2 (Thread 0x79d1f26006c0 (LWP 14430))]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.611.1">
     Now, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.612.1">
      bt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.613.1">
     command will show the backtrace for thread 2 (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.614.1">
      output simplified):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.615.1">
(gdb) bt
#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146
#2  0x000079d1f32a00f1 in lll_mutex_lock_optimized (mutex=0x7fff5e406b00) at ./nptl/pthread_mutex_lock.c:48
#7  0x000061cbaf1173fa in operator() (__closure=0x61cbafd64418) at 11x18-debug_deadlock.cpp:19</span></pre>
   <p>
    <span class="koboSpan" id="kobo.616.1">
     To execute a command in different threads, just use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      thread apply
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     command, in this case, executing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      bt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     command on threads 1
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.621.1">
      and 3:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.622.1">
(gdb) thread apply 1 3 bt</span></pre>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     To execute a command in all threads, just use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.624.1">
      thread apply
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.625.1">
       all &lt;command&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.626.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.627.1">
     Note that when a breakpoint is reached in a multithreaded program, all threads of execution stop running, allowing the examination of the overall state of the program.
    </span>
    <span class="koboSpan" id="kobo.627.2">
     When the execution is restarted by commands such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.628.1">
      continue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.629.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.630.1">
      step
     </span>
    </strong>
    <span class="koboSpan" id="kobo.631.1">
     , or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      next
     </span>
    </strong>
    <span class="koboSpan" id="kobo.633.1">
     , all threads resume.
    </span>
    <span class="koboSpan" id="kobo.633.2">
     The current thread will move one statement forward, but that is not guaranteed for other threads, which could move forward several statements or even stop in the middle of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      a statement.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.635.1">
     When the execution stops, the debugger will jump and show the context of the execution in the current thread.
    </span>
    <span class="koboSpan" id="kobo.635.2">
     To avoid the debugger jumping between threads by locking the scheduler, we can use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.636.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.637.1">
(gdb) set scheduler-locking &lt;on/off&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.638.1">
     We can also use the following command to check the scheduler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.639.1">
      locking status:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.640.1">
(gdb) show scheduler-locking</span></pre>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     Now that we
    </span>
    <a id="_idIndexMarker860">
    </a>
    <span class="koboSpan" id="kobo.642.1">
     have learned some new
    </span>
    <a id="_idIndexMarker861">
    </a>
    <span class="koboSpan" id="kobo.643.1">
     commands for multithreading debugging, let’s check what is happening with the application we attached to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      the debugger.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.645.1">
     If we retrieve the backtraces in threads 2 and 3, we can see the following (output simplified only showing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.646.1">
      relevant parts):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.647.1">
(gdb) thread apply all bt
Thread 3 (Thread 0x79d1f30006c0 (LWP 14429) "test"):
#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b30) at ../sysdeps/nptl/futex-internal.h:146
#5  0x000061cbaf117e20 in std::mutex::lock (this=0x7fff5e406b30) at /usr/include/c++/14/bits/std_mutex.h:113
#7  0x000061cbaf117334 in operator() (__closure=0x61cbafd642b8) at 11x18-debug_deadlock.cpp:13
Thread 2 (Thread 0x79d1f26006c0 (LWP 14430) "test"):
#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146
#5  0x000061cbaf117e20 in std::mutex::lock (this=0x7fff5e406b00) at /usr/include/c++/14/bits/std_mutex.h:113
#7  0x000061cbaf1173fa in operator() (__closure=0x61cbafd64418) at 11x18-debug_deadlock.cpp:19</span></pre>
   <p>
    <span class="koboSpan" id="kobo.648.1">
     Note that, after running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.649.1">
      std::mutex::lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.650.1">
     , both threads are waiting at line 13 for thread 3 and at 19 for thread 2, which matches with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.651.1">
      std::lock_guard
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.652.1">
      lock2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.653.1">
     in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      std::thread
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.655.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.656.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.657.1">
      std::lock_guard
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.658.1">
      lock1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.659.1">
     in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.660.1">
      std::thread
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.661.1">
       t2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.662.1">
      , respectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.663.1">
     Therefore, we
    </span>
    <a id="_idIndexMarker862">
    </a>
    <span class="koboSpan" id="kobo.664.1">
     detected a deadlock
    </span>
    <a id="_idIndexMarker863">
    </a>
    <span class="koboSpan" id="kobo.665.1">
     happening in those threads at these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.666.1">
      code locations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.667.1">
     Let’s now learn more about debugging multithreaded software by catching a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.668.1">
      race condition.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-239">
    <a id="_idTextAnchor238">
    </a>
    <span class="koboSpan" id="kobo.669.1">
     Debugging race conditions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.670.1">
     Race conditions
    </span>
    <a id="_idIndexMarker864">
    </a>
    <span class="koboSpan" id="kobo.671.1">
     are
    </span>
    <a id="_idIndexMarker865">
    </a>
    <span class="koboSpan" id="kobo.672.1">
     one of the most difficult bugs to detect and debug because they usually occur sporadically and with different effects each time, and sometimes some expensive computation happens before the program reaches the point
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.673.1">
      of failure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.674.1">
     This erratic behavior is not only caused by race conditions.
    </span>
    <span class="koboSpan" id="kobo.674.2">
     Other issues related to incorrect memory allocation can cause similar symptoms, so it’s not possible to classify a bug as a race condition until there is some investigation and we reach a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.675.1">
      root-cause diagnosis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.676.1">
     One way of debugging race conditions is to use watchpoints to manually inspect if a variable changes its value without any statement executed in the current thread modifying it, or placing breakpoints in strategic locations triggered by specific threads when reached, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.677.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.678.1">
(gdb) break &lt;linespec&gt; thread &lt;id&gt; if &lt;condition&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.679.1">
     For example, see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.680.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.681.1">
(gdb) break test.cpp:11 thread 2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.682.1">
     Or, even using assertions and checking if the current value of any variable accessed by different threads has
    </span>
    <a id="_idIndexMarker866">
    </a>
    <span class="koboSpan" id="kobo.683.1">
     the expected value.
    </span>
    <span class="koboSpan" id="kobo.683.2">
     This
    </span>
    <a id="_idIndexMarker867">
    </a>
    <span class="koboSpan" id="kobo.684.1">
     approach is followed in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      next example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.686.1">
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
static int g_value = 0;
static std::mutex g_mutex;
void func1() {
    const std::lock_guard&lt;std::mutex&gt; lock(g_mutex);
    for (int i = 0; i &lt; 10; ++i) {
        int old_value = g_value;
        int incr = (rand() % 10);
        g_value += incr;
        assert(g_value == old_value + incr);
        std::this_thread::sleep_for(10ms);
    }
}
void func2() {
    for (int i = 0; i &lt; 10; ++i) {
        int old_value = g_value;
        int incr = (rand() % 10);
        g_value += (rand() % 10);
        assert(g_value == old_value + incr);
        std::this_thread::sleep_for(10ms);
    }
}
int main() {
    std::thread t1(func1);
    std::thread t2(func2);
    t1.join();
    t2.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.687.1">
     Here, two threads,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.688.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.689.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.690.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.691.1">
     , are running functions that increase the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.692.1">
      g_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.693.1">
     global variable by a random value.
    </span>
    <span class="koboSpan" id="kobo.693.2">
     Each time it is increased,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.694.1">
      g_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.695.1">
     is compared with the expected value, and if they are not equal, the assert instruction will stop
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.696.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.697.1">
     Compile this program and run the debugger
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.698.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.699.1">
$ g++ -o test -g -O0 test
$ gdb ./test</span></pre>
   <p>
    <span class="koboSpan" id="kobo.700.1">
     After the debugger starts, run the program by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.701.1">
      run
     </span>
    </strong>
    <span class="koboSpan" id="kobo.702.1">
     command.
    </span>
    <span class="koboSpan" id="kobo.702.2">
     The program will run and, at some point, abort by receiving the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.703.1">
      SIGABRT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.704.1">
     signal, showing that the assertion was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.705.1">
      not met.
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.706.1">
test: test.cpp:29: void func2(): Assertion `g_value == old_value + incr' failed.
</span><span class="koboSpan" id="kobo.706.2">Thread 3 "test" received signal SIGABRT, Aborted.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.707.1">
     With the program stopped, we can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.708.1">
      backtrace
     </span>
    </strong>
    <span class="koboSpan" id="kobo.709.1">
     commands to check the backtrace at that point and change the source code at that point of failure to a specific
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.710.1">
      frame
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.711.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.712.1">
       list
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.713.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.714.1">
     This example is quite simple, so it’s clear through checking the assertion output that something is going wrong with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      g_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     variable, and this is most probably a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.717.1">
      race condition.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.718.1">
     But with a more elaborate program, this process of manually debugging issues is quite arduous, so let’s focus
    </span>
    <a id="_idIndexMarker868">
    </a>
    <span class="koboSpan" id="kobo.719.1">
     on another technique
    </span>
    <a id="_idIndexMarker869">
    </a>
    <span class="koboSpan" id="kobo.720.1">
     called reverse debugging that can help
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.721.1">
      with that.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-240">
    <a id="_idTextAnchor239">
    </a>
    <span class="koboSpan" id="kobo.722.1">
     Reverse debugging
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.723.1">
      Reverse debugging
     </span>
    </strong>
    <span class="koboSpan" id="kobo.724.1">
     , also
    </span>
    <a id="_idIndexMarker870">
    </a>
    <span class="koboSpan" id="kobo.725.1">
     known as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.726.1">
      time travel debugging
     </span>
    </strong>
    <span class="koboSpan" id="kobo.727.1">
     , allows
    </span>
    <a id="_idIndexMarker871">
    </a>
    <span class="koboSpan" id="kobo.728.1">
     a debugger
    </span>
    <a id="_idIndexMarker872">
    </a>
    <span class="koboSpan" id="kobo.729.1">
     to stop a program after failure and go back into the history of the execution of a program to investigate the reason for the failure.
    </span>
    <span class="koboSpan" id="kobo.729.2">
     This functionality is achieved by logging (recording) the execution of each machine instruction of the program being debugged together with each change in values of memory and registers, and afterward, using these records to replay and rewind the program
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.730.1">
      at will.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.731.1">
     On Linux, we can use GDB (since version 7.0),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.732.1">
      rr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.733.1">
     (originally developed by Mozilla,
    </span>
    <a href="https://rr-project.org">
     <span class="koboSpan" id="kobo.734.1">
      https://rr-project.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.735.1">
     ), or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.736.1">
      Undo’s time travel debugger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.737.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.738.1">
      UDB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     ) (
    </span>
    <a href="https://docs.undo.io">
     <span class="koboSpan" id="kobo.740.1">
      https://docs.undo.io
     </span>
    </a>
    <span class="koboSpan" id="kobo.741.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.741.2">
     On Windows, we
    </span>
    <a id="_idIndexMarker873">
    </a>
    <span class="koboSpan" id="kobo.742.1">
     can
    </span>
    <a id="_idIndexMarker874">
    </a>
    <span class="koboSpan" id="kobo.743.1">
     use
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.744.1">
      Time Travel
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.745.1">
       Debugging
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.746.1">
      (
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.747.1">
       https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.748.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.749.1">
     Reverse debugging is only supported by a limited number of GDB targets, such as remote target Simics,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.750.1">
      system integration and design
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.752.1">
      SID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.753.1">
     ) simulators, or the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.754.1">
      process record and replay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.755.1">
     target for native Linux (only for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      i386
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.758.1">
      amd64
     </span>
    </strong>
    <span class="koboSpan" id="kobo.759.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.760.1">
      moxie-elf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.762.1">
      arm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.763.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.763.2">
     At the time of authoring this book, Clang’s reverse debugging feature is still
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.764.1">
      under development.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.765.1">
     Therefore, due to these limitations, we decided to do a small showcase by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      rr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     .
    </span>
    <span class="koboSpan" id="kobo.767.2">
     Please follow the instructions on the project website to build and install the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      rr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     debugging
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.770.1">
      tool:
     </span>
    </span>
    <a href="https://github.com/rr-debugger/rr/wiki/Building-And-Installing">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.771.1">
       https://github.com/rr-debugger/rr/wiki/Building-And-Installing
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.772.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.773.1">
     Once installed, to
    </span>
    <a id="_idIndexMarker875">
    </a>
    <span class="koboSpan" id="kobo.774.1">
     record and replay a program, use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.775.1">
      following commands:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.776.1">
$ rr record &lt;program&gt; --args &lt;args&gt;
$ rr replay</span></pre>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     For example, if we have a program called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      test
     </span>
    </strong>
    <span class="koboSpan" id="kobo.779.1">
     , the command sequence will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.780.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.781.1">
$ rr record test
rr: Saving execution to trace directory `/home/user/.local/share/rr/test-1'.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.782.1">
     Say the following
    </span>
    <a id="_idIndexMarker876">
    </a>
    <span class="koboSpan" id="kobo.783.1">
     fatal error is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.784.1">
      shown instead:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.785.1">
[FATAL src/PerfCounters.cc:349:start_counter()] rr needs /proc/sys/kernel/perf_event_paranoid &lt;= 3, but it is 4.
</span><span class="koboSpan" id="kobo.785.2">Change it to &lt;= 3.
</span><span class="koboSpan" id="kobo.785.3">Consider putting 'kernel.perf_event_paranoid = 3' in /etc/sysctl.d/10-rr.conf.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.786.1">
     Then, use the following command to adjust the kernel
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.787.1">
      variable,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.788.1">
       kernel.perf_event_paranoid
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.789.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.790.1">
$ sudo sysctl kernel.perf_event_paranoid=1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.791.1">
     Once a record is available, use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.792.1">
      replay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.793.1">
     command to start debugging
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.794.1">
      the program:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.795.1">
$ rr replay</span></pre>
   <p>
    <span class="koboSpan" id="kobo.796.1">
     Or, if the program crashed and you want just to start debugging at the end of the recording, use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      –
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.798.1">
       e
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.799.1">
      option:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.800.1">
$ rr replay -e</span></pre>
   <p>
    <span class="koboSpan" id="kobo.801.1">
     At this point,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.802.1">
      rr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.803.1">
     will use the GDB debugger to start the program and load its debug symbols.
    </span>
    <span class="koboSpan" id="kobo.803.2">
     Then, you can use any of the following commands to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      reverse debugging:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.805.1">
       reverse-continue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.806.1">
      : Start executing the program in reverse.
     </span>
     <span class="koboSpan" id="kobo.806.2">
      Execution will stop when a breakpoint is reached or due to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.807.1">
       synchronous exception.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.808.1">
       reverse-next
      </span>
     </strong>
     <span class="koboSpan" id="kobo.809.1">
      : Run backward to the beginning of the previous line executed in the current
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.810.1">
       stack frame.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.811.1">
       reverse-nexti
      </span>
     </strong>
     <span class="koboSpan" id="kobo.812.1">
      : This executes a single instruction in reverse, jumping those moving to inner
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.813.1">
       stack frames.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.814.1">
       reverse-step
      </span>
     </strong>
     <span class="koboSpan" id="kobo.815.1">
      : Run the program backward until the control reaches the start of a new
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.816.1">
       source line.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.817.1">
       reverse-stepi
      </span>
     </strong>
     <span class="koboSpan" id="kobo.818.1">
      : Execute in reverse one
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.819.1">
       machine instruction.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.820.1">
       reverse-finish
      </span>
     </strong>
     <span class="koboSpan" id="kobo.821.1">
      : This executes until the current function invocation, that is, the beginning of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.822.1">
       current function.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.823.1">
     We can also reverse
    </span>
    <a id="_idIndexMarker877">
    </a>
    <span class="koboSpan" id="kobo.824.1">
     the direction of debugging and use regular commands for forward debugging (such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.825.1">
      next
     </span>
    </strong>
    <span class="koboSpan" id="kobo.826.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.827.1">
      step
     </span>
    </strong>
    <span class="koboSpan" id="kobo.828.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.829.1">
      continue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.830.1">
     , and so on) in the opposite direction by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.831.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.832.1">
(rr) set exec-direction reverse</span></pre>
   <p>
    <span class="koboSpan" id="kobo.833.1">
     To set the execution direction back to forward, use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.834.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.835.1">
(rr) set exec-direction forward</span></pre>
   <p>
    <span class="koboSpan" id="kobo.836.1">
     As an exercise, install the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.837.1">
      rr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.838.1">
     debugger and try to debug the previous example using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.839.1">
      reverse debugging.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.840.1">
     Let’s now move on
    </span>
    <a id="_idIndexMarker878">
    </a>
    <span class="koboSpan" id="kobo.841.1">
     to how to debug coroutines, a challenging
    </span>
    <a id="_idIndexMarker879">
    </a>
    <span class="koboSpan" id="kobo.842.1">
     task due to their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.843.1">
      asynchronous nature.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-241">
    <a id="_idTextAnchor240">
    </a>
    <span class="koboSpan" id="kobo.844.1">
     Debugging coroutines
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.845.1">
     As we have seen
    </span>
    <a id="_idIndexMarker880">
    </a>
    <span class="koboSpan" id="kobo.846.1">
     so far, asynchronous
    </span>
    <a id="_idIndexMarker881">
    </a>
    <span class="koboSpan" id="kobo.847.1">
     code can be debugged as synchronous code, by using breakpoints in strategic places with specific conditions, using watchpoints to inspect variables, and stepping into or over to walk through the code.
    </span>
    <span class="koboSpan" id="kobo.847.2">
     Also, using techniques described earlier to select specific threads and locking the scheduler helps to avoid unnecessary distractions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.848.1">
      when debugging.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.849.1">
     As we have already learned, there are complexities in asynchronous code, such as what thread will be used when the asynchronous code is executed, which makes it more difficult to debug.
    </span>
    <span class="koboSpan" id="kobo.849.2">
     For C++ coroutines, debugging is even harder to master due to their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.850.1">
      suspend/resume nature.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.851.1">
     Clang compiles programs using coroutines in two steps: Semantic analysis is performed by Clang, and coroutine frames are constructed and
    </span>
    <a id="_idIndexMarker882">
    </a>
    <span class="koboSpan" id="kobo.852.1">
     optimized in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.853.1">
      LLVM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.854.1">
     middle-end.
    </span>
    <span class="koboSpan" id="kobo.854.2">
     As debug information is generated in the Clang frontend, there will be insufficient debug information as coroutine frames are generated later in the compilation process.
    </span>
    <span class="koboSpan" id="kobo.854.3">
     GCC follows a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.855.1">
      similar approach.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.856.1">
     Also, if the execution breaks inside a coroutine, the current frame will only have one variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.857.1">
      frame_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.858.1">
     .
    </span>
    <span class="koboSpan" id="kobo.858.2">
     In a coroutine, there are no pointer or function parameters.
    </span>
    <span class="koboSpan" id="kobo.858.3">
     Coroutines store their state in the heap before suspending, and only using the stack during execution.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      frame_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     is used to access all necessary information for the coroutine to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.861.1">
      run properly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.862.1">
     Let’s debug the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.863.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     coroutine
    </span>
    <a id="_idIndexMarker883">
    </a>
    <span class="koboSpan" id="kobo.865.1">
     example implemented in
    </span>
    <a href="B22219_09.xhtml#_idTextAnchor184">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.866.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.867.1">
     .
    </span>
    <span class="koboSpan" id="kobo.867.2">
     Here, we only show the relevant instructions.
    </span>
    <span class="koboSpan" id="kobo.867.3">
     Please visit the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.868.1">
      Coroutines
     </span>
    </em>
    <span class="koboSpan" id="kobo.869.1">
     section in
    </span>
    <a href="B22219_09.xhtml#_idTextAnchor184">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.870.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.871.1">
     to check the complete
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.872.1">
      source code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.873.1">
boost::asio::awaitable&lt;void&gt; echo(tcp::socket socket) {
    char data[1024];
    while (true) {
        std::cout &lt;&lt; "Reading data from socket...\n";//L12
        std::size_t bytes_read = co_await
            socket.async_read_some(
                boost::asio::buffer(data),
                             boost::asio::use_awaitable);
        /* .... </span><span class="koboSpan" id="kobo.873.2">*/
        co_await boost::asio::async_write(socket,
                boost::asio::buffer(data, bytes_read),
                boost::asio::use_awaitable);
    }
}
boost::asio::awaitable&lt;void&gt;
listener(boost::asio::io_context&amp; io_context,
         unsigned short port) {
    tcp::acceptor acceptor(io_context,
                           tcp::endpoint(tcp::v4(), port));
    while (true) {
        std::cout &lt;&lt; "Accepting connections...\n";  // L45
        tcp::socket socket = co_await
            acceptor.async_accept(
                boost::asio::use_awaitable);
        boost::asio::co_spawn(io_context,
            echo(std::move(socket)),
            boost::asio::detached);
    }
}
/* main function */</span></pre>
   <p>
    <span class="koboSpan" id="kobo.874.1">
     As we are using Boost, let’s
    </span>
    <a id="_idIndexMarker884">
    </a>
    <span class="koboSpan" id="kobo.875.1">
     include the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.876.1">
      Boost.System
     </span>
    </strong>
    <span class="koboSpan" id="kobo.877.1">
     library to add more symbols for debugging when compiling the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.878.1">
      source code:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.879.1">
$ g++ --std=c++20 -ggdb -O0 --fno-omit-frame-pointer -lboost_system  test.cpp -o test</span></pre>
   <p>
    <span class="koboSpan" id="kobo.880.1">
     Then, we start the debugger with the generated program and set breakpoints in lines 12 and 45, which are the locations of the first instruction inside the while loops on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.881.1">
      each coroutine:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.882.1">
$ gdb –q ./test
(gdb) b 12
(gdb) b 45</span></pre>
   <p>
    <span class="koboSpan" id="kobo.883.1">
     We also enable the GDB
    </span>
    <a id="_idIndexMarker885">
    </a>
    <span class="koboSpan" id="kobo.884.1">
     built-in pretty printers to show readable output for Standard Template
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.885.1">
      Library containers:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.886.1">
(gdb) set print pretty on</span></pre>
   <p>
    <span class="koboSpan" id="kobo.887.1">
     If now we run the program (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.888.1">
      run
     </span>
    </strong>
    <span class="koboSpan" id="kobo.889.1">
     command), it will reach the breakpoint at line 42 inside the coroutine listener before accepting connections.
    </span>
    <span class="koboSpan" id="kobo.889.2">
     Using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      info locals
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     command, we can check the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.892.1">
      local variables.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.893.1">
     Coroutines create a state machine with several internal fields, such as promise objects, with attached thread, address of caller object, pending exceptions, and so on.
    </span>
    <span class="koboSpan" id="kobo.893.2">
     Also, they store
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.894.1">
      resume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.895.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      destroy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     callbacks.
    </span>
    <span class="koboSpan" id="kobo.897.2">
     These structures are compiler-dependent, tied to the compiler’s implementation, and accessible via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      frame_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     if we are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.900.1">
      using Clang.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.901.1">
     If we continue running the program (with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.902.1">
      continue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.903.1">
     command), the server will be waiting for a client to connect.
    </span>
    <span class="koboSpan" id="kobo.903.2">
     To exit the waiting status, we use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.904.1">
      telnet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.905.1">
     , as shown in
    </span>
    <a href="B22219_09.xhtml#_idTextAnchor184">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.906.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.907.1">
     , to connect a client to the server.
    </span>
    <span class="koboSpan" id="kobo.907.2">
     At that point, the execution will be stopped because the breakpoint at line 12 inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.908.1">
      echo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.909.1">
     coroutine is reached, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.910.1">
      info locals
     </span>
    </strong>
    <span class="koboSpan" id="kobo.911.1">
     show the variables used by each
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.912.1">
       echo
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.913.1">
      connection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.914.1">
     Using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.915.1">
      backtrace
     </span>
    </strong>
    <span class="koboSpan" id="kobo.916.1">
     command will show a call stack that might have some complexities due to the coroutines’
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.917.1">
      suspend nature.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.918.1">
     In pure C++ routines, described in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.919.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.920.1">
     , there are two expressions where setting breakpoints could
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.921.1">
      be interesting:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.922.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.923.1">
      : The execution is suspended until the awaited operation is complete.
     </span>
     <span class="koboSpan" id="kobo.923.2">
      Breakpoints can be set at the point where the coroutine is resumed by inspecting the underlying
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.924.1">
       await_suspend
      </span>
     </strong>
     <span class="koboSpan" id="kobo.925.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.926.1">
       await_resume
      </span>
     </strong>
     <span class="koboSpan" id="kobo.927.1">
      , or custom
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.928.1">
       awaitable code.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.929.1">
       co_yield
      </span>
     </strong>
     <span class="koboSpan" id="kobo.930.1">
      : Suspends execution and yields a value.
     </span>
     <span class="koboSpan" id="kobo.930.2">
      During debugging, step into the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.931.1">
       co_yield
      </span>
     </strong>
     <span class="koboSpan" id="kobo.932.1">
      to observe how control flows between coroutines and their
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.933.1">
       calling functions.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.934.1">
     As coroutines are quite new in the C++ world and compilers are continuously evolving, we hope that soon debugging coroutines will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.935.1">
      more straightforward.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.936.1">
     Once we have found and debugged some bugs and can reproduce scenarios that lead to those specific bugs, it would be convenient to design some tests that cover those cases to avoid future changes
    </span>
    <a id="_idIndexMarker886">
    </a>
    <span class="koboSpan" id="kobo.937.1">
     in code that could lead to similar problems or incidents.
    </span>
    <span class="koboSpan" id="kobo.937.2">
     Let’s learn how to test multithreaded and asynchronous code in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.938.1">
      next chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-242">
    <a id="_idTextAnchor241">
    </a>
    <span class="koboSpan" id="kobo.939.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.940.1">
     In this chapter, we learned how to use logging and debug
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.941.1">
      asynchronous programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.942.1">
     We started by using logging to spot issues in running software, showing its usefulness in detecting deadlocks by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.943.1">
      spdlog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     logging library.
    </span>
    <span class="koboSpan" id="kobo.944.2">
     Many other libraries were also discussed, describing their relevant features that might be suitable to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.945.1">
      specific scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.946.1">
     However, not all bugs can be spotted by using logs, and some may only be detected later in the software development life cycle when some issues happen in production, even when dealing with program crashes and incidents.
    </span>
    <span class="koboSpan" id="kobo.946.2">
     Debuggers are useful tools to inspect running or crashed programs, understand their code path, and find bugs.
    </span>
    <span class="koboSpan" id="kobo.946.3">
     Several examples and debugger commands were introduced to deal with generic code, but also and especially with multithreaded and asynchronous software, race conditions, and coroutines.
    </span>
    <span class="koboSpan" id="kobo.946.4">
     Also, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.947.1">
      rr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.948.1">
     debugger was introduced, showing the potential of including reverse debugging in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.949.1">
      developer toolbox.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.950.1">
     In the next chapter, we will learn about using sanitizers and testing techniques to performance and optimization techniques that can be used to improve asynchronous programs’ runtime and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.951.1">
      resource usage.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-243">
    <a id="_idTextAnchor242">
    </a>
    <span class="koboSpan" id="kobo.952.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.953.1">
        Logging
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.954.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.955.1">
       https://en.wikipedia.org/wiki/Logging_(computing)
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.956.1">
        Syslog
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.957.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.958.1">
       https://en.wikipedia.org/wiki/Syslog
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.959.1">
       Google Logging
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.960.1">
        Library
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.961.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.962.1">
       https://github.com/google/glog
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.963.1">
       Apache
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.964.1">
        Log4cxx
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.965.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.966.1">
       https://logging.apache.org/log4cxx
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.967.1">
        spdlog
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.968.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.969.1">
       https://github.com/gabime/spdlog
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.970.1">
        Quill
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.971.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.972.1">
       https://github.com/odygrd/quill
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.973.1">
        xtr
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.974.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.975.1">
       https://github.com/choll/xtr
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.976.1">
        lwlog
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.977.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.978.1">
       https://github.com/ChristianPanov/lwlog
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.979.1">
        uberlog
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.980.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.981.1">
       https://github.com/IMQS/uberlog
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.982.1">
        Easylogging++
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.983.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.984.1">
       https://github.com/abumq/easyloggingpp
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.985.1">
        NanoLog
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.986.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.987.1">
       https://github.com/PlatformLab/NanoLog
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.988.1">
       Reckless Logging
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.989.1">
        Library
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.990.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.991.1">
       https://github.com/mattiasflodin/reckless
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.992.1">
        tracetool
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.993.1">
       :
      </span>
     </span>
     <a href="https://github.com/froglogic/tracetool">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.994.1">
        https://github.com/froglogic/tracetool
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.995.1">
       Logback
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.996.1">
        Project
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.997.1">
       :
      </span>
     </span>
     <a href="https://logback.qos.ch">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.998.1">
        https://logback.qos.ch
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.999.1">
        Sentry
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1000.1">
       :
      </span>
     </span>
     <a href="https://sentry.io">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1001.1">
        https://sentry.io
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1002.1">
        Graylog
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1003.1">
       :
      </span>
     </span>
     <a href="https://graylog.org">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1004.1">
        https://graylog.org
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1005.1">
        Logstash
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1006.1">
       :
      </span>
     </span>
     <a href="https://www.elastic.co/logstash">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1007.1">
        https://www.elastic.co/logstash
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1008.1">
       Debugging with
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1009.1">
        GDB
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1010.1">
       :
      </span>
     </span>
     <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1011.1">
        https://sourceware.org/gdb/current/onlinedocs/gdb.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1012.1">
       LLDB
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1013.1">
        tutorial
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1014.1">
       :
      </span>
     </span>
     <a href="https://lldb.llvm.org/use/tutorial.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1015.1">
        https://lldb.llvm.org/use/tutorial.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1016.1">
       Clang Compiler User’s
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1017.1">
        Manual
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1018.1">
       :
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/UsersManual.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1019.1">
        https://clang.llvm.org/docs/UsersManual.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1020.1">
       GDB
      </span>
     </em>
     <span class="koboSpan" id="kobo.1021.1">
      :
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1022.1">
       Running programs
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1023.1">
        backward
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1024.1">
       :
      </span>
     </span>
     <a href="https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1025.1">
        https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1026.1">
       Reverse Debugging with
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1027.1">
        GDB
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1028.1">
       :
      </span>
     </span>
     <a href="https://sourceware.org/gdb/wiki/ReverseDebug">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1029.1">
        https://sourceware.org/gdb/wiki/ReverseDebug
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1030.1">
       Debugging C++
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1031.1">
        Coroutines
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1032.1">
       :
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/DebuggingCoroutines.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1033.1">
        https://clang.llvm.org/docs/DebuggingCoroutines.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1034.1">
       SID Simulator User’s
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1035.1">
        Guide
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1036.1">
       :
      </span>
     </span>
     <a href="https://sourceware.org/sid/sid-guide/book1.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1037.1">
        https://sourceware.org/sid/sid-guide/book1.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1038.1">
       Intel Simics Simulator for Intel FPGAs: User
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1039.1">
        Guide
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1040.1">
       :
      </span>
     </span>
     <a href="https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1041.1">
        https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1042.1">
       IBM Support
      </span>
     </em>
     <span class="koboSpan" id="kobo.1043.1">
      :
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1044.1">
       How do I enable core
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1045.1">
        dumps
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1046.1">
       :
      </span>
     </span>
     <a href="https://www.ibm.com/support/pages/how-do-i-enable-core-dumps">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1047.1">
        https://www.ibm.com/support/pages/how-do-i-enable-core-dumps
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1048.1">
       Core Dumps – How to enable
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1049.1">
        them?
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1050.1">
       :
      </span>
     </span>
     <a href="mailto:https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1051.1">
        https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711
       </span>
      </span>
     </a>
    </li>
   </ul>
  </div>
 </body></html>