<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-71">
    <a id="_idTextAnchor070">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor071">
    </a>
    
     C++ Is Not Memory-Safe
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      If you still write C++ like
     
    </em>
    
     <em class="italic">
      
       it’s 2000
      
     </em>
    
   </p>
   <p>
    
     C++ has its issues in terms of safety, and memory can be a part of it.
    
    
     Two types of memory issues exist: spatial and temporal.
    
    
     Spatial issues refer to accessing memory outside of the bounds, while temporal issues refer to accessing memory in an uncertain or freed state.
    
    
     Modern C++ attempts to avoid many of the pitfalls by avoiding the usage of naked pointers and through the use of
    
    <strong class="source-inline">
     
      std::span
     
    </strong>
    
     or concepts.
    
    
     There’s still work to do, though; we will show in this chapter that the current C++ mechanisms are still incomplete and look at safety profiles as a possible
    
    
     
      future improvement.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Memory safety
     
     
      
       is important
      
     
    </li>
    <li>
     
      The memory safety problems of
     
     
      
       older C++
      
     
    </li>
    <li>
     
      Modern C++ to
     
     
      
       the rescue
      
     
    </li>
    <li>
     
      The limits of
     
     
      
       modern C++
      
     
    </li>
    <li>
     
      There’s still more
     
     
      
       to do
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor072">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code for this chapter is available on GitHub at
    
    <a href="https://github.com/PacktPublishing/Debunking-CPP-Myths">
     
      https://github.com/PacktPublishing/Debunking-CPP-Myths
     
    </a>
    
     , in the
    
    <strong class="source-inline">
     
      ch6
     
    </strong>
    
     folder.
    
    
     The doctest (
    
    <a href="https://github.com/doctest/doctest">
     
      https://github.com/doctest/doctest
     
    </a>
    
     ) is used for the test functions and it is included in
    
    
     
      the code.
     
    
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor073">
    </a>
    
     Memory safety is important
    
   </h1>
   <p>
    
     Most
    
    <a id="_idIndexMarker253">
    </a>
    
     of us living in the modern world expect things to work.
    
    
     We expect to have electricity, clean water, and sanitation to the point that they have faded into the background.
    
    
     We don’t notice or consider the work required to keep the flow of electricity going; it’s
    
    
     
      just expected.
     
    
   </p>
   <p>
    
     Software is the newcomer on this stage.
    
    
     I imagine people don’t realize how involved software is in almost everything people do, from payments to entertainment, from life-saving emergency services to going from one place
    
    
     
      to another.
     
    
   </p>
   <p>
    
     Yet of all the omnipresent services in the modern world, software is the one that, for all its benefits, can really make your life difficult.
    
    
     Consider all the people whose identities have been leaked and sometimes stolen, whose money has been estranged, and who have been denied or got delayed medical attention because of hospitals affected by ransomware.
    
    
     Software is everywhere, and software must
    
    
     
      do better.
     
    
   </p>
   <p>
    
     Yet we, the programmers, seem oblivious to these issues.
    
    
     Software is complicated, we tell ourselves.
    
    
     Users get scammed all the time due to their own fault.
    
    
     There’s no program without bugs.
    
    
     And yes, this is correct.
    
    
     Software is increasingly complex, with more people working on very small pieces.
    
    
     Users are not as careful as they should be.
    
    
     To make things worse, technology keeps changing so that a code base that worked perfectly 6 months ago might not
    
    
     
      work anymore.
     
    
   </p>
   <p>
    
     But this does not remove our responsibility in the process.
    
    
     Air travel companies could say the same things: planes are complex machines; of course, they might develop defects and occasionally fall from the sky.
    
    
     Passengers don’t read or listen to emergency instructions; let’s blame them.
    
    
     Instead, the system around air travel is such that the risk of flying has continuously decreased over the years, becoming the safest way
    
    
     
      to travel.
     
    
   </p>
   <p>
    
     Because we, the programmers, were oblivious to these issues, very few of us were expecting a technical recommendation regarding the languages we should use coming from the White House.
    
    
     Published on February 26, 2024, the technical report notes that the software industry has a history of ignoring common root causes of security issues, and that for the sake of national security, applications should be written in memory-safe languages.
    
    
     The list of memory-safe languages includes Java, C#, Python, and Rust and excludes C and C++.
    
    
     You can read more about this at the following
    
    
     
      link:
     
    
    <a href="https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/">
     
      
       https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker254">
    </a>
    
     reaction to this report was a mix of surprise, amusement, and consternation.
    
    
     Yet the importance of the report was reestablished a few months later, on July 19, 2024, when about half of the world was affected by a memory issue in the CrowdStrike suite of products that caused a kernel panic in Windows systems around the world.
    
    
     The incident grounded planes, stopped emergency systems from functioning, took payment systems offline, and wreaked havoc on the lives of millions of people.
    
    
     I believe this may be the first time when a lot of people realized how important software has become, which means they might start paying attention to politicians who talk
    
    
     
      about it.
     
    
   </p>
   <p>
    
     So, yes, memory safety is important.
    
    
     Memory management mistakes lead in the best case to a minor inconvenience of restarting a piece of software, but in the worst case to hackers exploiting vulnerabilities or to whole systems needing manual intervention.
    
    
     As with everything in software, the need for memory safety is contextual; a life-critical application needs a different type of attention in comparison to a single-player game.
    
    
     I would argue, though, that attention to this issue matters no matter what software you’re building.
    
    
     I believe programmers have a responsibility to write code that not only works as it should but also shields its users as much as possible from peril and perhaps even delights them sometimes.
    
    
     We, the programmers, need to remember that the code we write is used by people, and people matter.
    
    
     And while this is not the only problem we have, dealing with memory safety head-on is a good way
    
    
     
      to advance.
     
    
   </p>
   <h1 id="_idParaDest-75">
    <a id="_idTextAnchor074">
    </a>
    
     The memory safety problems of older C++
    
   </h1>
   <p>
    
     Before
    
    <a id="_idIndexMarker255">
    </a>
    
     we move on to discuss the memory safety issues in older and modern C++, let’s attempt to define it.
    
    
     Citing from the White House report: “
    
    <em class="italic">
     
      Memory safety vulnerabilities are a class of vulnerability affecting how memory can be accessed, written, allocated, or deallocated in unintended ways (...) There are two broad categories of memory safety vulnerabilities: spatial and temporal.
     
     
      Spatial memory safety issues result from memory accesses performed outside of the “correct” bounds established for variables and objects in memory.
     
     
      Temporal memory safety issues arise when memory is accessed outside of time or state, such as accessing object data after the object is freed or when memory accesses are
     
    </em>
    
     <em class="italic">
      
       unexpectedly interleaved.
      
     </em>
    
    
     
      ”
     
    
   </p>
   <p>
    <em class="italic">
     
      To view the source of the citing, you can go through page 7 of the document at the following
     
    </em>
    
     <em class="italic">
      
       link:
      
     </em>
    
    
    
    <a href="https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf">
     
      
       https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Any C++ programmer
    
    <a id="_idIndexMarker256">
    </a>
    
     should be familiar with both types of issues.
    
    
     The spatial memory issues were most common with naked arrays in C++.
    
    
     Try, for example, executing this program that creates an array, adds some values to it, and then attempts to write and read elements beyond its
    
    
     
      allocated memory:
     
    
   </p>
   <pre class="source-code">
int doSomeWork(int value1, int value2, int value3, int value4) {
int array[3];
array[0] = value1;
array[1] = value2;
array[3] = value3;
array[4] = value4;
return array[0] + array[1] + array[3] + array[4];
}</pre>
   <p>
    
     The surprising thing about the preceding code is that it’s undefined behavior.
    
    
     That is, your compiler might react to the attempt to read or write after the bounds of the array in different ways, from ignoring it to a compilation error.
    
    
     Moreover, depending on the OS and the context, the code might work and overwrite unspecified blocks
    
    
     
      of memory.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     For attackers, this type of code is gold.
    
    
     Why?
    
    
     Well, there’s a small chance that this process will at some point be placed in RAM next to a process that does something valuable.
    
    
     If an attacker can send the right values into this function and catch the process at exactly the right moment, they might be able to overwrite the code that checks for authentication into your banking application, install a keylogger, or add malware to your system.
    
    
     Sure, such an attack is not guaranteed to succeed, but hackers have a lot of time since these things are automated anyway.
    
    
     It only needs to
    
    
     
      succeed once.
     
    
   </p>
   <p>
    
     I’ve tested this code on my computer, running Ubuntu Linux and compiling with
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     compiler happily compiles the program without a warning, even when turning on all warnings.
    
    
     Meanwhile,
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     gives a warning at compile time that the array is accessed after its bounds.
    
    
     When I try to run the program, I get the message
    
    <strong class="source-inline">
     
      "*** stack smashing detected ***: terminated"
     
    </strong>
    
     .
    
    
     So, I have some protection at runtime, but the code still runs with unknown possible
    
    
     
      side effects.
     
    
   </p>
   <p>
    
     Note, however, that
    
    <a id="_idIndexMarker257">
    </a>
    
     this is a very simple example.
    
    
     If I were to create an array somewhere in the code, pass it around to various functions, and compute the indexes based on some complicated formula, my bet is that no compiler would figure it out.
    
    
     We are left, therefore, with our tests and the
    
    
     
      OS protections.
     
    
   </p>
   <p>
    <em class="italic">
     
      Is this type of problem the language’s fault?
     
    </em>
    
     Few people may know this, but it’s possible to write this type of code in programming languages that are on the memory-safe list.
    
    
     C#, for example, has the notion of unsafe code and has pointers.
    
    
     You can mark a part of code unsafe, create pointers to access data, and use pointer arithmetic, with some limitations.
    
    
     The difference is that you need to work a lot to make this happen, and it still doesn’t have the same effects as in C++.
    
    
     Moreover, the piece of code that juggles with memory in similar ways is very visible in C# because it needs to be part of an unsafe block.
    
    <strong class="bold">
     
      The problem with C++ is not as much that it is possible to do these things; it’s that it’s very easy to do them
     
    </strong>
    
     <strong class="bold">
      
       by default.
      
     </strong>
    
   </p>
   <p>
    
     Since we’re talking about pointers, let’s see how to misuse them.
    
    
     The following code uses a
    
    <strong class="source-inline">
     
      void*
     
    </strong>
    
     instance to access the memory beyond the allocated value of an
    
    <strong class="source-inline">
     
      int*
     
    </strong>
    
     type, through some casts and
    
    
     
      pointer arithmetic:
     
    
   </p>
   <pre class="source-code">
int pointerBounds() {
    int *aPointerToInt;
    void *aPointerToVoid;
    aPointerToVoid = new int();
    aPointerToInt = (int*)aPointerToVoid;
    *aPointerToInt = 234;
    aPointerToInt = (int*)((char*)aPointerToVoid + sizeof(int));
    *aPointerToInt = 2423;
    int value = *aPointerToInt;
    delete aPointerToVoid;
    return value;
}
TEST_CASE("try pointer bounds"){
int result = pointerBounds();
CHECK_EQ(2423, result);
}</pre>
   <p>
    
     Once again, we hit some
    
    <a id="_idIndexMarker258">
    </a>
    
     undefined behavior: assigning a value to a pointer that results from pointer arithmetic is left to the compiler to decide.
    
    
     This time, both
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     give me warnings, but only about deleting a void pointer.
    
    
     None of the two have any problems with the fact that I try to write and read beyond the allocated region.
    
    
     Even more interestingly, the tests run perfectly fine, the result of the function is the expected one, and everyone is happy!
    
    
     Not even the OS is complaining about this nonsense – hopefully, because I haven’t exceeded the process’s
    
    
     
      allocated memory.
     
    
   </p>
   <p>
    
     
      Hopefully.
     
    
   </p>
   <p>
    
     We have looked until now at examples of spatial memory safety issues, and things don’t look good.
    
    
     What about
    
    
     
      temporal ones?
     
    
   </p>
   <p>
    
     Anyone who’s used pointers has had to deal with the need to remember to do two things after they are no longer needed: free the allocated memory and reset them to
    
    <strong class="source-inline">
     
      NULL
     
    </strong>
    
     .
    
    
     Both things are important because forgetting one of them leads to temporal memory safety issues: a dangling pointer that still has access to an area of memory that has been released, or a memory leak when the pointer has not been freed and maybe the pointer was reset so that the memory area is no
    
    
     
      longer accessible.
     
    
   </p>
   <p>
    
     Take as an example the following function that initializes a pointer to
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     with a value, frees the memory, and then returns the value stored in
    
    
     
      the memory:
     
    
   </p>
   <pre class="console">
int danglingPointer() {
    int *aPointerToInt = new int(234);
    delete aPointerToInt;
    return *aPointerToInt;
}
TEST_CASE("Try dangling pointer"){
int result = danglingPointer();
CHECK_EQ(234, result);
}</pre>
   <p>
    
     Once again, the program compiles fine.
    
    
     There’s no warning in
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     .
    
    
     It also runs, but the test fails because the value stored in the memory at that address is not the
    
    
     
      expected one:
     
    
   </p>
   <pre class="console">
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
  values: CHECK_EQ( 234, 721392248 )</pre>
   <p>
    
     The value stored at that address changes at each subsequent call, giving me other results such as
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
  values: CHECK_EQ( 234, 1757279720 )
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
  values: CHECK_EQ( 234, -1936531037 )</pre>
   <p>
    
     It’s unexpectedly easy to
    
    <a id="_idIndexMarker259">
    </a>
    
     use this value in a computation later in the code and return a weird value.
    
    
     It’s also a way to find out what’s in a memory area if you know a little bit about the computation performed and can pass
    
    
     
      repeated inputs.
     
    
   </p>
   <p>
    
     Temporal memory safety issues are worse since it’s harder to keep track of the lifetime of a pointer in the labyrinth of a large code base than to ensure that we aren’t reading past its bounds.
    
    
     So, yes – unfortunately, memory issues can be a big problem
    
    
     
      in C++.
     
    
   </p>
   <p>
    
     You’ll have noticed, however, that all the previous examples have been in the old C++ style.
    
    
     We used naked arrays, naked pointers, and pointer arithmetic.
    
    
     These are all constructs that you should use very sparingly in modern C++, for these exact reasons.
    
    
     I can’t say never use them, because there are specific situations when we need naked pointers and naked arrays, but nowadays, they tend to be limited to memory optimization or low-level programming.
    
    
     Even in these situations, you can usually introduce a clear
    
    <a id="_idIndexMarker260">
    </a>
    
     boundary between the unsafe and the
    
    
     
      modern C++.
     
    
   </p>
   <p>
    
     So, does modern C++ solve all
    
    
     
      these issues?
     
    
   </p>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor075">
    </a>
    
     Modern C++ to the rescue
    
   </h1>
   <p>
    
     Let’s revisit the preceding examples but
    
    <a id="_idIndexMarker261">
    </a>
    
     replace the naked arrays and naked pointers with their STL
    
    <a id="_idIndexMarker262">
    </a>
    
     equivalents, as recommended in
    
    
     
      modern C++.
     
    
   </p>
   <p>
    
     First, the array bounds example.
    
    
     We simply replace the naked array with a
    
    <strong class="source-inline">
     
      vector&lt;int&gt;
     
    </strong>
    
     instance and we get the
    
    
     
      following function:
     
    
   </p>
   <pre class="source-code">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values;
values[0] = value1;
values[1] = value2;
values[3] = value3;
values[4] = value4;
return values[0] + values[1] + values[3] + values[4];
}
TEST_CASE("try vector bounds"){
int result = doSomeWork(1, 234, 543, 23423);
CHECK_EQ(1 + 234 + 543 + 23423, result);
}</pre>
   <p>
    
     Unfortunately, the
    
    <a id="_idIndexMarker263">
    </a>
    
     result of running this example is not great.
    
    
     Neither
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     nor
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     complains, and we get the following result when running
    
    
     
      the test:
     
    
   </p>
   <pre class="source-code">
TEST CASE:  try vector bounds
test.cpp:5: FATAL ERROR: test case CRASHED: SIGSEGV - Segmentation violation signal</pre>
   <p>
    
     Is
    
    <strong class="source-inline">
     
      std::vector&lt;&gt;
     
    </strong>
    
     unsafe?
    
    
     Well, we still need to pay attention to the space allocated for it.
    
    
     We have a few options: initialize it properly, use the methods provided to append to the collection, or ask to reserve memory for a specific number of items.
    
    
     The first two are what I would typically use since they are less likely to lead to issues.
    
    
     But even the third option results in a
    
    
     
      passing test:
     
    
   </p>
   <pre class="source-code">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values;
<strong class="bold">values.reserve(5);</strong>
values[0] = value1;
values[1] = value2;
values[3] = value3;
values[4] = value4;
return values[0] + values[1] + values[3] + values[4];
}</pre>
   <p>
    
     A pleasant surprise is the behavior of
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     , at least on
    
    <strong class="source-inline">
     
      g++
     
    </strong>
    
     , after reserve.
    
    
     I tried to access
    
    <strong class="source-inline">
     
      values[2]
     
    </strong>
    
     , not set in this example, and I got the value 0.
    
    
     This is much better than accessing the value previously stored in that memory block, and I imagine it’s a feature of the default allocator used by
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     .
    
    
     This difference is due to the undefined behavior of
    
    <strong class="source-inline">
     
      operator[]
     
    </strong>
    
     , and it is avoidable by using the
    
    <strong class="source-inline">
     
      vector::at()
     
    </strong>
    
     method.
    
    
     Still, we had to do some work.
    
    
     So, we can still write code that leads to memory issues, even with the modern STL.
    
    
     Of course, if we quit monkeying around and use one of the easy methods, this problem disappears completely.
    
    
     If we use the initializer syntax, the vector is created based on the data passed in without us having to do any
    
    
     
      more counting:
     
    
   </p>
   <pre class="source-code">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values{value1, value2, 0, value3, value4};
return values[0] + values[1] + values[3] + values[4];
}</pre>
   <p>
    
     Of course, this syntax makes
    
    <a id="_idIndexMarker264">
    </a>
    
     us add all the elements to the vector rather than some of them, thus preventing an off-by-1 error.
    
    
     The alternative is adding the elements one
    
    
     
      by one:
     
    
   </p>
   <pre class="console">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values;
values.push_back(value1);
values.push_back(value2);
values.push_back(0);
values.push_back(value3);
values.push_back(value4);
return values[0] + values[1] + values[3] + values[4];
}</pre>
   <p>
    
     As expected, this version works perfectly as well.
    
    
     The moral: use the boring constructs, and you’ll get the expected behavior 99% of the time.
    
    
     This is a good mantra for coding in any programming language, but even more so
    
    
     
      in C++.
     
    
   </p>
   <p>
    
     Let’s look now again at the example that uses pointer arithmetic and
    
    <strong class="source-inline">
     
      void*
     
    </strong>
    
     to access memory outside of the bounds.
    
    
     This is how
    
    
     
      it looks:
     
    
   </p>
   <pre class="console">
int pointerBounds() {
int *aPointerToInt;
void *aPointerToVoid;
aPointerToVoid = new int();
aPointerToInt = (int*)aPointerToVoid;
*aPointerToInt = 234;
aPointerToInt = (int*)((char*)aPointerToVoid + sizeof(int));
*aPointerToInt = 2423;
int value = *aPointerToInt;
delete aPointerToVoid;
return value;
}</pre>
   <p>
    
     I’ve done my best to
    
    <a id="_idIndexMarker265">
    </a>
    
     convert this code to use
    
    <strong class="source-inline">
     
      std::unique_ptr
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      std::shared_ptr
     
    </strong>
    
     , and I believe it’s possible but it’s extremely convoluted.
    
    
     The first problem is dealing with all the pointer conversions we are using.
    
    
     There’s no easy way to convert
    
    <strong class="source-inline">
     
      std::unique_ptr&lt;int&gt;
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      std::unique_ptr&lt;char&gt;
     
    </strong>
    
     ; the only way is to convert the value and get a new
    
    
     <strong class="source-inline">
      
       unique_ptr&lt;&gt;
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <p>
    
     The second problem is that
    
    <strong class="source-inline">
     
      void*
     
    </strong>
    
     doesn’t have a direct translation into
    
    <strong class="source-inline">
     
      std::shared_ptr&lt;void&gt;
     
    </strong>
    
     ; you can use it but only by allocating the memory manually and passing a custom
    
    <strong class="source-inline">
     
      deleter
     
    </strong>
    
     function.
    
    
     So, while it’s possible to write something resembling this code with the modern STL, it takes so much work that programmers will stick to the safe methods unless they have very
    
    
     
      specific needs.
     
    
   </p>
   <p>
    
     We encounter the same situation with the dangling
    
    
     
      pointer example:
     
    
   </p>
   <pre class="console">
int danglingPointer() {
    int *aPointerToInt = new int(234);
    delete aPointerToInt;
    return *aPointerToInt;
}</pre>
   <p>
    
     There’s no straightforward way to delete the smart pointer and then return the value.
    
    
     We could reallocate using a call to
    
    <strong class="source-inline">
     
      unique_ptr::reset
     
    </strong>
    
     , but that would use pointers again.
    
    
     The simplest translation into pure smart pointers looks
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
int danglingPointer() {
    unique_ptr&lt;int&gt; aPointerToInt = make_unique&lt;int&gt;(234);
    return *aPointerToInt;
}</pre>
   <p>
    
     Only this works exactly as it should: the value is returned correctly, and the memory is released.
    
    
     No dangling pointer
    
    
     
      by default!
     
    
   </p>
   <p>
    
     We could make
    
    <a id="_idIndexMarker266">
    </a>
    
     it a dangling pointer if we allocate it manually and pass in a deleter that does nothing to
    
    <strong class="source-inline">
     
      std::unique_ptr&lt;&gt;
     
    </strong>
    
     .
    
    
     There’s no reason to do this in most situations, therefore I would expect most programmers to avoid this issue altogether.
    
    
     Add in the option to use
    
    <strong class="source-inline">
     
      std::shared_ptr&lt;&gt;
     
    </strong>
    
     in case you need multiple owners of the memory block, and your most common situations are
    
    
     
      sorted out.
     
    
   </p>
   <p>
    
     We can conclude from all this that modern C++ is much safer, reducing a lot of the potential issues by default.
    
    
     But it still has its limits, which is what we will focus
    
    
     
      on next.
     
    
   </p>
   <h1 id="_idParaDest-77">
    <a id="_idTextAnchor076">
    </a>
    
     The limits of modern C++
    
   </h1>
   <p>
    
     Let’s assume for a
    
    <a id="_idIndexMarker267">
    </a>
    
     moment that we use only STL collections, we avoid pointers, and when we really need them, we use the smart pointers implemented in the standard library, and we write our types with memory safety in mind.
    
    
     Are
    
    
     
      we done?
     
    
   </p>
   <p>
    
     Herb Sutter, one of the well-known members of the C++ standardization committee, has looked at this issue and at the more general issue of avoiding security issues in C++, in a blog post titled
    
    <em class="italic">
     
      C++ safety, in context
     
    </em>
    
     (
    
    <a href="https://herbsutter.com/2024/03/11/safety-in-context/">
     
      https://herbsutter.com/2024/03/11/safety-in-context/
     
    </a>
    
     ) published on March 11, 2024.
    
    
     His conclusion is that it’s too easy to write C++ code that by default has security and safety vulnerabilities.
    
    
     The article identifies four areas that need more attention: types, bounds, initialization, and lifetime.
    
    
     Then, he states that there are already some mechanisms in place in C++ 20:
    
    <strong class="source-inline">
     
      span
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      string_view
     
    </strong>
    
     concepts, and bound-aware ranges.
    
    
     What is missing from the language, as the article discusses next, is safety rules that are enabled by default but that programmers can turn off
    
    
     
      if needed.
     
    
   </p>
   <p>
    
     Let’s unpack all this information and give
    
    
     
      some examples.
     
    
   </p>
   <p>
    
     First on the list, the
    
    <a id="_idIndexMarker268">
    </a>
    
     new
    
    <strong class="source-inline">
     
      std::span
     
    </strong>
    
     introduced in C++20.
    
    
     It represents a contiguous sequence of objects, extracted from a naked array,
    
    <strong class="source-inline">
     
      std::array
     
    </strong>
    
     , a pointer with a size,
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     .
    
    
     Its big advantage is that it automatically deduces the size of the sequence, thus removing the common instance of off-by-1 errors.
    
    
     Thus, we now have a safe way to pass a subset of a collection into a function without the fear of messing up the sequence length.
    
    
     Also, it allows us to completely forbid pointer arithmetic and use
    
    
     <strong class="source-inline">
      
       std::span
      
     </strong>
    
    
     
      instead.
     
    
   </p>
   <p>
    
     Second,
    
    <strong class="source-inline">
     
      string_view
     
    </strong>
    
     .
    
    
     A
    
    <strong class="source-inline">
     
      std::string_view
     
    </strong>
    
     instance allows us to have a read-only view on a string, thus eliminating another source of potential safety issues, with strings being modified where they shouldn’t or with operations on strings that are prone to
    
    
     
      being unsafe.
     
    
   </p>
   <p>
    
     Third, concepts.
    
    
     Concepts allow C++ programmers to define constraints upon generic functions and classes, thus enhancing the safety of the types.
    
    
     For example, one could request that the value passed in a generic function has a type that has both an addition and a subtraction method.
    
    
     Concepts are still under development, with improvements coming in C++ 26, but they already help solve a lot of potential
    
    
     
      safety issues.
     
    
   </p>
   <p>
    
     Fourth, bound-aware ranges.
    
    
     The
    
    <strong class="source-inline">
     
      ranges
     
    </strong>
    
     library allows C++ programmers to write efficient functional programming-inspired operations that work on collections, thus eliminating another source of potential misuse.
    
    
     Ranges know their bounds and shield the developers from passing in every function the begin and
    
    
     
      end iterators.
     
    
   </p>
   <p>
    
     These improvements, if used, have gone a long way from C++ 98.
    
    
     Still, things are missing.
    
    
     Remember the code that accessed an index in
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     that did not reserve any memory and got a bad memory error at runtime?
    
    
     Let’s take
    
    
     
      a look:
     
    
   </p>
   <pre class="source-code">
int doSomeWork(int value1, int value2, int value3, int value4) {
    vector&lt;int&gt; values;
    values[0] = value1;
    values[1] = value2;
    values[3] = value3;
    values[4] = value4;
    return values[0] + values[1] + values[3] + values[4];
}</pre>
   <p>
    
     The problem with this code is that we can happily access indexes beyond the allocated vector size while skipping the initialization for index 2.
    
    
     A possible solution to this issue would be
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Enable a
     
     <strong class="source-inline">
      
       safemode
      
     </strong>
     
      
       compiler flag
      
     
    </li>
    <li>
     
      The compiler generates a range check upon every index access that verifies that
     
     <strong class="source-inline">
      
       0 &lt;= index &lt;
      
     </strong>
     
      <strong class="source-inline">
       
        collection.size()
       
      </strong>
     
    </li>
    <li>
     
      We get no error at runtime because nothing happens when we try to call
     
     
      
       this code
      
     
    </li>
   </ul>
   <p>
    
     Such a compile option
    
    <a id="_idIndexMarker269">
    </a>
    
     could be enabled on existing code with no change and prevent unknown issues.
    
    
     Sure, some programmers will have an issue with this because of the potential for reducing performance.
    
    
     That’s precisely why such an option should be either turned on by a compiler flag, or, even better, turned on by default with the option to turn it off by a
    
    
     
      compiler flag.
     
    
   </p>
   <p>
    
     This shows that there’s still more to do to make C++
    
    
     
      memory safe.
     
    
   </p>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor077">
    </a>
    
     There’s still more to do
    
   </h1>
   <p>
    
     The standardization committee is currently working on a proposal called
    
    <strong class="bold">
     
      safety profiles
     
    </strong>
    
     , which allows a
    
    <a id="_idIndexMarker270">
    </a>
    
     combined approach formed of compile enhancements, static analysis, and profiler tools to eliminate most of these safety issues.
    
    
     It is unclear when it will be done, and I for one don’t envy their task.
    
    
     There are millions if not billions of lines of C++ code used today, and any proposal needs to have a minimal impact on the existing code, other than pointing out potential security issues.
    
    
     It must also affect performance as little as possible, given how important it is for many
    
    
     
      existing applications.
     
    
   </p>
   <p>
    
     On the other hand, the urgency is clear.
    
    
     C++ has issues with memory safety, and it might end up on a blacklist for US government projects, and likely for other governments as well.
    
    
     Only time will tell when the issue is resolved and how it impacts the usage of
    
    
     
      the language.
     
    
   </p>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor078">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We have seen in this chapter how it’s too easy to write unsafe code by default in C++.
    
    
     Despite the improvements introduced by subsequent standards, by the STL collections and smart pointers, it’s still likely that programmers will make mistakes with a potentially huge cost.
    
    
     Sure, there are ways to catch these mistakes: automated developer tests, exploratory tests, penetration testing, and so on.
    
    
     But the defaults of the language matter, and C++’s defaults are
    
    
     
      still unsafe.
     
    
   </p>
   <p>
    
     After examining these issues, my only option is to conclude that C++ is still memory-unsafe by default and that writing memory-safe code requires continuous attention and the appropriate tools.
    
    
     The safety profiles that will hopefully arrive soon in the standard will most likely alleviate many of the issues, but there’s still an unfathomable quantity of C++ code in the world that was written like it’s still 2000.
    
    
     So, a
    
    
     
      mixed bag.
     
    
   </p>
   <p>
    
     In the next chapter, we will examine the state of parallelism and concurrency
    
    
     
      in C++.
     
    
   </p>
  </div>
 </body></html>