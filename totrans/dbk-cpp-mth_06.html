<html><head></head><body>
  <div id="_idContainer030">
   <h1 class="chapter-number" id="_idParaDest-71">
    <a id="_idTextAnchor070">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     6
    </span>
   </h1>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor071">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     C++ Is Not Memory-Safe
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      If you still write C++ like
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       it’s 2000
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     C++ has its issues in terms of safety, and memory can be a part of it.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Two types of memory issues exist: spatial and temporal.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     Spatial issues refer to accessing memory outside of the bounds, while temporal issues refer to accessing memory in an uncertain or freed state.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     Modern C++ attempts to avoid many of the pitfalls by avoiding the usage of naked pointers and through the use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.6.1">
      std::span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     or concepts.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     There’s still work to do, though; we will show in this chapter that the current C++ mechanisms are still incomplete and look at safety profiles as a possible
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      future improvement.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Memory safety
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       is important
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      The memory safety problems of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       older C++
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Modern C++ to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       the rescue
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      The limits of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       modern C++
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      There’s still more
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       to do
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor072">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     The code for this chapter is available on GitHub at
    </span>
    <a href="https://github.com/PacktPublishing/Debunking-CPP-Myths">
     <span class="koboSpan" id="kobo.23.1">
      https://github.com/PacktPublishing/Debunking-CPP-Myths
     </span>
    </a>
    <span class="koboSpan" id="kobo.24.1">
     , in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.25.1">
      ch6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.26.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     The doctest (
    </span>
    <a href="https://github.com/doctest/doctest">
     <span class="koboSpan" id="kobo.27.1">
      https://github.com/doctest/doctest
     </span>
    </a>
    <span class="koboSpan" id="kobo.28.1">
     ) is used for the test functions and it is included in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      the code.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor073">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     Memory safety is important
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     Most
    </span>
    <a id="_idIndexMarker253">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     of us living in the modern world expect things to work.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     We expect to have electricity, clean water, and sanitation to the point that they have faded into the background.
    </span>
    <span class="koboSpan" id="kobo.32.3">
     We don’t notice or consider the work required to keep the flow of electricity going; it’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      just expected.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     Software is the newcomer on this stage.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     I imagine people don’t realize how involved software is in almost everything people do, from payments to entertainment, from life-saving emergency services to going from one place
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      to another.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     Yet of all the omnipresent services in the modern world, software is the one that, for all its benefits, can really make your life difficult.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     Consider all the people whose identities have been leaked and sometimes stolen, whose money has been estranged, and who have been denied or got delayed medical attention because of hospitals affected by ransomware.
    </span>
    <span class="koboSpan" id="kobo.36.3">
     Software is everywhere, and software must
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      do better.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     Yet we, the programmers, seem oblivious to these issues.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     Software is complicated, we tell ourselves.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     Users get scammed all the time due to their own fault.
    </span>
    <span class="koboSpan" id="kobo.38.4">
     There’s no program without bugs.
    </span>
    <span class="koboSpan" id="kobo.38.5">
     And yes, this is correct.
    </span>
    <span class="koboSpan" id="kobo.38.6">
     Software is increasingly complex, with more people working on very small pieces.
    </span>
    <span class="koboSpan" id="kobo.38.7">
     Users are not as careful as they should be.
    </span>
    <span class="koboSpan" id="kobo.38.8">
     To make things worse, technology keeps changing so that a code base that worked perfectly 6 months ago might not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      work anymore.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     But this does not remove our responsibility in the process.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     Air travel companies could say the same things: planes are complex machines; of course, they might develop defects and occasionally fall from the sky.
    </span>
    <span class="koboSpan" id="kobo.40.3">
     Passengers don’t read or listen to emergency instructions; let’s blame them.
    </span>
    <span class="koboSpan" id="kobo.40.4">
     Instead, the system around air travel is such that the risk of flying has continuously decreased over the years, becoming the safest way
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      to travel.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     Because we, the programmers, were oblivious to these issues, very few of us were expecting a technical recommendation regarding the languages we should use coming from the White House.
    </span>
    <span class="koboSpan" id="kobo.42.2">
     Published on February 26, 2024, the technical report notes that the software industry has a history of ignoring common root causes of security issues, and that for the sake of national security, applications should be written in memory-safe languages.
    </span>
    <span class="koboSpan" id="kobo.42.3">
     The list of memory-safe languages includes Java, C#, Python, and Rust and excludes C and C++.
    </span>
    <span class="koboSpan" id="kobo.42.4">
     You can read more about this at the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      link:
     </span>
    </span>
    <a href="https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.44.1">
       https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.46.1">
     The
    </span>
    <a id="_idIndexMarker254">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     reaction to this report was a mix of surprise, amusement, and consternation.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     Yet the importance of the report was reestablished a few months later, on July 19, 2024, when about half of the world was affected by a memory issue in the CrowdStrike suite of products that caused a kernel panic in Windows systems around the world.
    </span>
    <span class="koboSpan" id="kobo.47.3">
     The incident grounded planes, stopped emergency systems from functioning, took payment systems offline, and wreaked havoc on the lives of millions of people.
    </span>
    <span class="koboSpan" id="kobo.47.4">
     I believe this may be the first time when a lot of people realized how important software has become, which means they might start paying attention to politicians who talk
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      about it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     So, yes, memory safety is important.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     Memory management mistakes lead in the best case to a minor inconvenience of restarting a piece of software, but in the worst case to hackers exploiting vulnerabilities or to whole systems needing manual intervention.
    </span>
    <span class="koboSpan" id="kobo.49.3">
     As with everything in software, the need for memory safety is contextual; a life-critical application needs a different type of attention in comparison to a single-player game.
    </span>
    <span class="koboSpan" id="kobo.49.4">
     I would argue, though, that attention to this issue matters no matter what software you’re building.
    </span>
    <span class="koboSpan" id="kobo.49.5">
     I believe programmers have a responsibility to write code that not only works as it should but also shields its users as much as possible from peril and perhaps even delights them sometimes.
    </span>
    <span class="koboSpan" id="kobo.49.6">
     We, the programmers, need to remember that the code we write is used by people, and people matter.
    </span>
    <span class="koboSpan" id="kobo.49.7">
     And while this is not the only problem we have, dealing with memory safety head-on is a good way
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      to advance.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-75">
    <a id="_idTextAnchor074">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     The memory safety problems of older C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     Before
    </span>
    <a id="_idIndexMarker255">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     we move on to discuss the memory safety issues in older and modern C++, let’s attempt to define it.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     Citing from the White House report: “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.54.1">
      Memory safety vulnerabilities are a class of vulnerability affecting how memory can be accessed, written, allocated, or deallocated in unintended ways (...) There are two broad categories of memory safety vulnerabilities: spatial and temporal.
     </span>
     <span class="koboSpan" id="kobo.54.2">
      Spatial memory safety issues result from memory accesses performed outside of the “correct” bounds established for variables and objects in memory.
     </span>
     <span class="koboSpan" id="kobo.54.3">
      Temporal memory safety issues arise when memory is accessed outside of time or state, such as accessing object data after the object is freed or when memory accesses are
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.55.1">
       unexpectedly interleaved.
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      ”
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.57.1">
      To view the source of the citing, you can go through page 7 of the document at the following
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.58.1">
       link:
      </span>
     </em>
    </span>
    <span class="No-Break">
    </span>
    <a href="https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.59.1">
       https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.60.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.61.1">
     Any C++ programmer
    </span>
    <a id="_idIndexMarker256">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     should be familiar with both types of issues.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     The spatial memory issues were most common with naked arrays in C++.
    </span>
    <span class="koboSpan" id="kobo.62.3">
     Try, for example, executing this program that creates an array, adds some values to it, and then attempts to write and read elements beyond its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      allocated memory:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.64.1">
int doSomeWork(int value1, int value2, int value3, int value4) {
int array[3];
array[0] = value1;
array[1] = value2;
array[3] = value3;
array[4] = value4;
return array[0] + array[1] + array[3] + array[4];
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     The surprising thing about the preceding code is that it’s undefined behavior.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     That is, your compiler might react to the attempt to read or write after the bounds of the array in different ways, from ignoring it to a compilation error.
    </span>
    <span class="koboSpan" id="kobo.65.3">
     Moreover, depending on the OS and the context, the code might work and overwrite unspecified blocks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      of memory.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.67.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.68.1">
     For attackers, this type of code is gold.
    </span>
    <span class="koboSpan" id="kobo.68.2">
     Why?
    </span>
    <span class="koboSpan" id="kobo.68.3">
     Well, there’s a small chance that this process will at some point be placed in RAM next to a process that does something valuable.
    </span>
    <span class="koboSpan" id="kobo.68.4">
     If an attacker can send the right values into this function and catch the process at exactly the right moment, they might be able to overwrite the code that checks for authentication into your banking application, install a keylogger, or add malware to your system.
    </span>
    <span class="koboSpan" id="kobo.68.5">
     Sure, such an attack is not guaranteed to succeed, but hackers have a lot of time since these things are automated anyway.
    </span>
    <span class="koboSpan" id="kobo.68.6">
     It only needs to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      succeed once.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     I’ve tested this code on my computer, running Ubuntu Linux and compiling with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.73.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.74.1">
     .
    </span>
    <span class="koboSpan" id="kobo.74.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.75.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.76.1">
     compiler happily compiles the program without a warning, even when turning on all warnings.
    </span>
    <span class="koboSpan" id="kobo.76.2">
     Meanwhile,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.77.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     gives a warning at compile time that the array is accessed after its bounds.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     When I try to run the program, I get the message
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.79.1">
      "*** stack smashing detected ***: terminated"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     .
    </span>
    <span class="koboSpan" id="kobo.80.2">
     So, I have some protection at runtime, but the code still runs with unknown possible
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      side effects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     Note, however, that
    </span>
    <a id="_idIndexMarker257">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     this is a very simple example.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     If I were to create an array somewhere in the code, pass it around to various functions, and compute the indexes based on some complicated formula, my bet is that no compiler would figure it out.
    </span>
    <span class="koboSpan" id="kobo.83.3">
     We are left, therefore, with our tests and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.84.1">
      OS protections.
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.85.1">
      Is this type of problem the language’s fault?
     </span>
    </em>
    <span class="koboSpan" id="kobo.86.1">
     Few people may know this, but it’s possible to write this type of code in programming languages that are on the memory-safe list.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     C#, for example, has the notion of unsafe code and has pointers.
    </span>
    <span class="koboSpan" id="kobo.86.3">
     You can mark a part of code unsafe, create pointers to access data, and use pointer arithmetic, with some limitations.
    </span>
    <span class="koboSpan" id="kobo.86.4">
     The difference is that you need to work a lot to make this happen, and it still doesn’t have the same effects as in C++.
    </span>
    <span class="koboSpan" id="kobo.86.5">
     Moreover, the piece of code that juggles with memory in similar ways is very visible in C# because it needs to be part of an unsafe block.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.87.1">
      The problem with C++ is not as much that it is possible to do these things; it’s that it’s very easy to do them
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.88.1">
       by default.
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     Since we’re talking about pointers, let’s see how to misuse them.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     The following code uses a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.90.1">
      void*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.91.1">
     instance to access the memory beyond the allocated value of an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.92.1">
      int*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.93.1">
     type, through some casts and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      pointer arithmetic:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.95.1">
int pointerBounds() {
    int *aPointerToInt;
    void *aPointerToVoid;
    aPointerToVoid = new int();
    aPointerToInt = (int*)aPointerToVoid;
    *aPointerToInt = 234;
    aPointerToInt = (int*)((char*)aPointerToVoid + sizeof(int));
    *aPointerToInt = 2423;
    int value = *aPointerToInt;
    delete aPointerToVoid;
    return value;
}
TEST_CASE("try pointer bounds"){
int result = pointerBounds();
CHECK_EQ(2423, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.96.1">
     Once again, we hit some
    </span>
    <a id="_idIndexMarker258">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     undefined behavior: assigning a value to a pointer that results from pointer arithmetic is left to the compiler to decide.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     This time, both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.98.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.100.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     give me warnings, but only about deleting a void pointer.
    </span>
    <span class="koboSpan" id="kobo.101.2">
     None of the two have any problems with the fact that I try to write and read beyond the allocated region.
    </span>
    <span class="koboSpan" id="kobo.101.3">
     Even more interestingly, the tests run perfectly fine, the result of the function is the expected one, and everyone is happy!
    </span>
    <span class="koboSpan" id="kobo.101.4">
     Not even the OS is complaining about this nonsense – hopefully, because I haven’t exceeded the process’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.102.1">
      allocated memory.
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      Hopefully.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.104.1">
     We have looked until now at examples of spatial memory safety issues, and things don’t look good.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     What about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      temporal ones?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     Anyone who’s used pointers has had to deal with the need to remember to do two things after they are no longer needed: free the allocated memory and reset them to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.107.1">
      NULL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     .
    </span>
    <span class="koboSpan" id="kobo.108.2">
     Both things are important because forgetting one of them leads to temporal memory safety issues: a dangling pointer that still has access to an area of memory that has been released, or a memory leak when the pointer has not been freed and maybe the pointer was reset so that the memory area is no
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      longer accessible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     Take as an example the following function that initializes a pointer to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     with a value, frees the memory, and then returns the value stored in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      the memory:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.114.1">
int danglingPointer() {
    int *aPointerToInt = new int(234);
    delete aPointerToInt;
    return *aPointerToInt;
}
TEST_CASE("Try dangling pointer"){
int result = danglingPointer();
CHECK_EQ(234, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     Once again, the program compiles fine.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     There’s no warning in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.116.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.117.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     .
    </span>
    <span class="koboSpan" id="kobo.119.2">
     It also runs, but the test fails because the value stored in the memory at that address is not the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      expected one:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.121.1">
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
</span><span class="koboSpan" id="kobo.121.2">  values: CHECK_EQ( 234, 721392248 )</span></pre>
   <p>
    <span class="koboSpan" id="kobo.122.1">
     The value stored at that address changes at each subsequent call, giving me other results such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.124.1">
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
</span><span class="koboSpan" id="kobo.124.2">  values: CHECK_EQ( 234, 1757279720 )
test.cpp:8: ERROR: CHECK_EQ( 234, result ) is NOT correct!
</span><span class="koboSpan" id="kobo.124.3">  values: CHECK_EQ( 234, -1936531037 )</span></pre>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     It’s unexpectedly easy to
    </span>
    <a id="_idIndexMarker259">
    </a>
    <span class="koboSpan" id="kobo.126.1">
     use this value in a computation later in the code and return a weird value.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     It’s also a way to find out what’s in a memory area if you know a little bit about the computation performed and can pass
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.127.1">
      repeated inputs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     Temporal memory safety issues are worse since it’s harder to keep track of the lifetime of a pointer in the labyrinth of a large code base than to ensure that we aren’t reading past its bounds.
    </span>
    <span class="koboSpan" id="kobo.128.2">
     So, yes – unfortunately, memory issues can be a big problem
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      in C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     You’ll have noticed, however, that all the previous examples have been in the old C++ style.
    </span>
    <span class="koboSpan" id="kobo.130.2">
     We used naked arrays, naked pointers, and pointer arithmetic.
    </span>
    <span class="koboSpan" id="kobo.130.3">
     These are all constructs that you should use very sparingly in modern C++, for these exact reasons.
    </span>
    <span class="koboSpan" id="kobo.130.4">
     I can’t say never use them, because there are specific situations when we need naked pointers and naked arrays, but nowadays, they tend to be limited to memory optimization or low-level programming.
    </span>
    <span class="koboSpan" id="kobo.130.5">
     Even in these situations, you can usually introduce a clear
    </span>
    <a id="_idIndexMarker260">
    </a>
    <span class="koboSpan" id="kobo.131.1">
     boundary between the unsafe and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.132.1">
      modern C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     So, does modern C++ solve all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      these issues?
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor075">
    </a>
    <span class="koboSpan" id="kobo.135.1">
     Modern C++ to the rescue
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Let’s revisit the preceding examples but
    </span>
    <a id="_idIndexMarker261">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     replace the naked arrays and naked pointers with their STL
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     equivalents, as recommended in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.139.1">
      modern C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     First, the array bounds example.
    </span>
    <span class="koboSpan" id="kobo.140.2">
     We simply replace the naked array with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      vector&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     instance and we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      following function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.144.1">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values;
values[0] = value1;
values[1] = value2;
values[3] = value3;
values[4] = value4;
return values[0] + values[1] + values[3] + values[4];
}
TEST_CASE("try vector bounds"){
int result = doSomeWork(1, 234, 543, 23423);
CHECK_EQ(1 + 234 + 543 + 23423, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     Unfortunately, the
    </span>
    <a id="_idIndexMarker263">
    </a>
    <span class="koboSpan" id="kobo.146.1">
     result of running this example is not great.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     Neither
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     nor
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.149.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     complains, and we get the following result when running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.151.1">
      the test:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.152.1">
TEST CASE:  try vector bounds
test.cpp:5: FATAL ERROR: test case CRASHED: SIGSEGV - Segmentation violation signal</span></pre>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     Is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      std::vector&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     unsafe?
    </span>
    <span class="koboSpan" id="kobo.155.2">
     Well, we still need to pay attention to the space allocated for it.
    </span>
    <span class="koboSpan" id="kobo.155.3">
     We have a few options: initialize it properly, use the methods provided to append to the collection, or ask to reserve memory for a specific number of items.
    </span>
    <span class="koboSpan" id="kobo.155.4">
     The first two are what I would typically use since they are less likely to lead to issues.
    </span>
    <span class="koboSpan" id="kobo.155.5">
     But even the third option results in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      passing test:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.157.1">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values;
</span><strong class="bold"><span class="koboSpan" id="kobo.158.1">values.reserve(5);</span></strong><span class="koboSpan" id="kobo.159.1">
values[0] = value1;
values[1] = value2;
values[3] = value3;
values[4] = value4;
return values[0] + values[1] + values[3] + values[4];
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.160.1">
     A pleasant surprise is the behavior of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.161.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.162.1">
     , at least on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      g++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     , after reserve.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     I tried to access
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      values[2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     , not set in this example, and I got the value 0.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     This is much better than accessing the value previously stored in that memory block, and I imagine it’s a feature of the default allocator used by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     .
    </span>
    <span class="koboSpan" id="kobo.168.2">
     This difference is due to the undefined behavior of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.169.1">
      operator[]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     , and it is avoidable by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      vector::at()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     Still, we had to do some work.
    </span>
    <span class="koboSpan" id="kobo.172.3">
     So, we can still write code that leads to memory issues, even with the modern STL.
    </span>
    <span class="koboSpan" id="kobo.172.4">
     Of course, if we quit monkeying around and use one of the easy methods, this problem disappears completely.
    </span>
    <span class="koboSpan" id="kobo.172.5">
     If we use the initializer syntax, the vector is created based on the data passed in without us having to do any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.173.1">
      more counting:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.174.1">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values{value1, value2, 0, value3, value4};
return values[0] + values[1] + values[3] + values[4];
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.175.1">
     Of course, this syntax makes
    </span>
    <a id="_idIndexMarker264">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     us add all the elements to the vector rather than some of them, thus preventing an off-by-1 error.
    </span>
    <span class="koboSpan" id="kobo.176.2">
     The alternative is adding the elements one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      by one:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.178.1">
int doSomeWork(int value1, int value2, int value3, int value4) {
vector&lt;int&gt; values;
values.push_back(value1);
values.push_back(value2);
values.push_back(0);
values.push_back(value3);
values.push_back(value4);
return values[0] + values[1] + values[3] + values[4];
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     As expected, this version works perfectly as well.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     The moral: use the boring constructs, and you’ll get the expected behavior 99% of the time.
    </span>
    <span class="koboSpan" id="kobo.179.3">
     This is a good mantra for coding in any programming language, but even more so
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      in C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.181.1">
     Let’s look now again at the example that uses pointer arithmetic and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.182.1">
      void*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     to access memory outside of the bounds.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     This is how
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      it looks:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.185.1">
int pointerBounds() {
int *aPointerToInt;
void *aPointerToVoid;
aPointerToVoid = new int();
aPointerToInt = (int*)aPointerToVoid;
*aPointerToInt = 234;
aPointerToInt = (int*)((char*)aPointerToVoid + sizeof(int));
*aPointerToInt = 2423;
int value = *aPointerToInt;
delete aPointerToVoid;
return value;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     I’ve done my best to
    </span>
    <a id="_idIndexMarker265">
    </a>
    <span class="koboSpan" id="kobo.187.1">
     convert this code to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.188.1">
      std::unique_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.189.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      std::shared_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     , and I believe it’s possible but it’s extremely convoluted.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     The first problem is dealing with all the pointer conversions we are using.
    </span>
    <span class="koboSpan" id="kobo.191.3">
     There’s no easy way to convert
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      std::unique_ptr&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      std::unique_ptr&lt;char&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     ; the only way is to convert the value and get a new
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.196.1">
       unique_ptr&lt;&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      instance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     The second problem is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      void*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     doesn’t have a direct translation into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.201.1">
      std::shared_ptr&lt;void&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     ; you can use it but only by allocating the memory manually and passing a custom
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      deleter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.204.2">
     So, while it’s possible to write something resembling this code with the modern STL, it takes so much work that programmers will stick to the safe methods unless they have very
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      specific needs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.206.1">
     We encounter the same situation with the dangling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      pointer example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.208.1">
int danglingPointer() {
    int *aPointerToInt = new int(234);
    delete aPointerToInt;
    return *aPointerToInt;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.209.1">
     There’s no straightforward way to delete the smart pointer and then return the value.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     We could reallocate using a call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      unique_ptr::reset
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     , but that would use pointers again.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     The simplest translation into pure smart pointers looks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.213.1">
int danglingPointer() {
    unique_ptr&lt;int&gt; aPointerToInt = make_unique&lt;int&gt;(234);
    return *aPointerToInt;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     Only this works exactly as it should: the value is returned correctly, and the memory is released.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     No dangling pointer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      by default!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     We could make
    </span>
    <a id="_idIndexMarker266">
    </a>
    <span class="koboSpan" id="kobo.217.1">
     it a dangling pointer if we allocate it manually and pass in a deleter that does nothing to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      std::unique_ptr&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     .
    </span>
    <span class="koboSpan" id="kobo.219.2">
     There’s no reason to do this in most situations, therefore I would expect most programmers to avoid this issue altogether.
    </span>
    <span class="koboSpan" id="kobo.219.3">
     Add in the option to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.220.1">
      std::shared_ptr&lt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.221.1">
     in case you need multiple owners of the memory block, and your most common situations are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      sorted out.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.223.1">
     We can conclude from all this that modern C++ is much safer, reducing a lot of the potential issues by default.
    </span>
    <span class="koboSpan" id="kobo.223.2">
     But it still has its limits, which is what we will focus
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      on next.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-77">
    <a id="_idTextAnchor076">
    </a>
    <span class="koboSpan" id="kobo.225.1">
     The limits of modern C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.226.1">
     Let’s assume for a
    </span>
    <a id="_idIndexMarker267">
    </a>
    <span class="koboSpan" id="kobo.227.1">
     moment that we use only STL collections, we avoid pointers, and when we really need them, we use the smart pointers implemented in the standard library, and we write our types with memory safety in mind.
    </span>
    <span class="koboSpan" id="kobo.227.2">
     Are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.228.1">
      we done?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.229.1">
     Herb Sutter, one of the well-known members of the C++ standardization committee, has looked at this issue and at the more general issue of avoiding security issues in C++, in a blog post titled
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.230.1">
      C++ safety, in context
     </span>
    </em>
    <span class="koboSpan" id="kobo.231.1">
     (
    </span>
    <a href="https://herbsutter.com/2024/03/11/safety-in-context/">
     <span class="koboSpan" id="kobo.232.1">
      https://herbsutter.com/2024/03/11/safety-in-context/
     </span>
    </a>
    <span class="koboSpan" id="kobo.233.1">
     ) published on March 11, 2024.
    </span>
    <span class="koboSpan" id="kobo.233.2">
     His conclusion is that it’s too easy to write C++ code that by default has security and safety vulnerabilities.
    </span>
    <span class="koboSpan" id="kobo.233.3">
     The article identifies four areas that need more attention: types, bounds, initialization, and lifetime.
    </span>
    <span class="koboSpan" id="kobo.233.4">
     Then, he states that there are already some mechanisms in place in C++ 20:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.236.1">
      string_view
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     concepts, and bound-aware ranges.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     What is missing from the language, as the article discusses next, is safety rules that are enabled by default but that programmers can turn off
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.238.1">
      if needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     Let’s unpack all this information and give
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      some examples.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     First on the list, the
    </span>
    <a id="_idIndexMarker268">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.243.1">
      std::span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     introduced in C++20.
    </span>
    <span class="koboSpan" id="kobo.244.2">
     It represents a contiguous sequence of objects, extracted from a naked array,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.245.1">
      std::array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.246.1">
     , a pointer with a size,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.247.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.248.1">
     , or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     .
    </span>
    <span class="koboSpan" id="kobo.250.2">
     Its big advantage is that it automatically deduces the size of the sequence, thus removing the common instance of off-by-1 errors.
    </span>
    <span class="koboSpan" id="kobo.250.3">
     Thus, we now have a safe way to pass a subset of a collection into a function without the fear of messing up the sequence length.
    </span>
    <span class="koboSpan" id="kobo.250.4">
     Also, it allows us to completely forbid pointer arithmetic and use
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.251.1">
       std::span
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      instead.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     Second,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.254.1">
      string_view
     </span>
    </strong>
    <span class="koboSpan" id="kobo.255.1">
     .
    </span>
    <span class="koboSpan" id="kobo.255.2">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.256.1">
      std::string_view
     </span>
    </strong>
    <span class="koboSpan" id="kobo.257.1">
     instance allows us to have a read-only view on a string, thus eliminating another source of potential safety issues, with strings being modified where they shouldn’t or with operations on strings that are prone to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      being unsafe.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     Third, concepts.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     Concepts allow C++ programmers to define constraints upon generic functions and classes, thus enhancing the safety of the types.
    </span>
    <span class="koboSpan" id="kobo.259.3">
     For example, one could request that the value passed in a generic function has a type that has both an addition and a subtraction method.
    </span>
    <span class="koboSpan" id="kobo.259.4">
     Concepts are still under development, with improvements coming in C++ 26, but they already help solve a lot of potential
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      safety issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     Fourth, bound-aware ranges.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      ranges
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     library allows C++ programmers to write efficient functional programming-inspired operations that work on collections, thus eliminating another source of potential misuse.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     Ranges know their bounds and shield the developers from passing in every function the begin and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      end iterators.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     These improvements, if used, have gone a long way from C++ 98.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     Still, things are missing.
    </span>
    <span class="koboSpan" id="kobo.265.3">
     Remember the code that accessed an index in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     that did not reserve any memory and got a bad memory error at runtime?
    </span>
    <span class="koboSpan" id="kobo.267.2">
     Let’s take
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      a look:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.269.1">
int doSomeWork(int value1, int value2, int value3, int value4) {
    vector&lt;int&gt; values;
    values[0] = value1;
    values[1] = value2;
    values[3] = value3;
    values[4] = value4;
    return values[0] + values[1] + values[3] + values[4];
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     The problem with this code is that we can happily access indexes beyond the allocated vector size while skipping the initialization for index 2.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     A possible solution to this issue would be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.272.1">
      Enable a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.273.1">
       safemode
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.274.1">
       compiler flag
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.275.1">
      The compiler generates a range check upon every index access that verifies that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.276.1">
       0 &lt;= index &lt;
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.277.1">
        collection.size()
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.278.1">
      We get no error at runtime because nothing happens when we try to call
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.279.1">
       this code
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     Such a compile option
    </span>
    <a id="_idIndexMarker269">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     could be enabled on existing code with no change and prevent unknown issues.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     Sure, some programmers will have an issue with this because of the potential for reducing performance.
    </span>
    <span class="koboSpan" id="kobo.281.3">
     That’s precisely why such an option should be either turned on by a compiler flag, or, even better, turned on by default with the option to turn it off by a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      compiler flag.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     This shows that there’s still more to do to make C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      memory safe.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor077">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     There’s still more to do
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     The standardization committee is currently working on a proposal called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.287.1">
      safety profiles
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     , which allows a
    </span>
    <a id="_idIndexMarker270">
    </a>
    <span class="koboSpan" id="kobo.289.1">
     combined approach formed of compile enhancements, static analysis, and profiler tools to eliminate most of these safety issues.
    </span>
    <span class="koboSpan" id="kobo.289.2">
     It is unclear when it will be done, and I for one don’t envy their task.
    </span>
    <span class="koboSpan" id="kobo.289.3">
     There are millions if not billions of lines of C++ code used today, and any proposal needs to have a minimal impact on the existing code, other than pointing out potential security issues.
    </span>
    <span class="koboSpan" id="kobo.289.4">
     It must also affect performance as little as possible, given how important it is for many
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      existing applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     On the other hand, the urgency is clear.
    </span>
    <span class="koboSpan" id="kobo.291.2">
     C++ has issues with memory safety, and it might end up on a blacklist for US government projects, and likely for other governments as well.
    </span>
    <span class="koboSpan" id="kobo.291.3">
     Only time will tell when the issue is resolved and how it impacts the usage of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      the language.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor078">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     We have seen in this chapter how it’s too easy to write unsafe code by default in C++.
    </span>
    <span class="koboSpan" id="kobo.294.2">
     Despite the improvements introduced by subsequent standards, by the STL collections and smart pointers, it’s still likely that programmers will make mistakes with a potentially huge cost.
    </span>
    <span class="koboSpan" id="kobo.294.3">
     Sure, there are ways to catch these mistakes: automated developer tests, exploratory tests, penetration testing, and so on.
    </span>
    <span class="koboSpan" id="kobo.294.4">
     But the defaults of the language matter, and C++’s defaults are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      still unsafe.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     After examining these issues, my only option is to conclude that C++ is still memory-unsafe by default and that writing memory-safe code requires continuous attention and the appropriate tools.
    </span>
    <span class="koboSpan" id="kobo.296.2">
     The safety profiles that will hopefully arrive soon in the standard will most likely alleviate many of the issues, but there’s still an unfathomable quantity of C++ code in the world that was written like it’s still 2000.
    </span>
    <span class="koboSpan" id="kobo.296.3">
     So, a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.297.1">
      mixed bag.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.298.1">
     In the next chapter, we will examine the state of parallelism and concurrency
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      in C++.
     </span>
    </span>
   </p>
  </div>
 </body></html>