- en: Chapter 4.  Conquering the Desktop UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 拿下桌面 UI
- en: In the previous chapter, we built the brain of our gallery using Qt models.
    It is now time to build a desktop application using this engine. This software
    will use all the features offered by the `gallery-core` library, leading to a
    completely usable gallery on your computer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 Qt 模型构建了我们画廊的大脑。现在是时候使用这个引擎构建桌面应用程序了。此软件将使用 `gallery-core` 库提供的所有功能，在你的计算机上实现一个完全可用的画廊。
- en: The first task will be to link your project-shared library to this new application.
    Then you will learn how to create custom widgets, when to use Qt views, and how
    to synchronize them with the model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是将你的项目共享库链接到这个新应用。然后你将学习如何创建自定义小部件，何时使用 Qt 视图，以及如何与模型同步它们。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Linking the application to a project library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序链接到项目库
- en: Qt model/view
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 模型/视图
- en: Qt resource file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 资源文件
- en: Promoting custom widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推广自定义小部件
- en: Creating a GUI linked to a core shared library
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建与核心共享库链接的 GUI
- en: The `gallery-core` shared library is now ready. Let's see how to create the
    desktop GUI project. We will create a Qt Widgets application sub-project called `gallery-desktop`.
    Only the first steps differ from a classic Qt Widgets application. Right-click
    on the main project, and select **ch04-gallery-desktop** | **New subproject**
    | **Application** | **Qt Widgets Application** | **Choose**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`gallery-core` 共享库现在已准备就绪。让我们看看如何创建桌面 GUI 项目。我们将创建一个名为 `gallery-desktop` 的
    Qt Widgets 应用程序子项目。与经典的 Qt Widgets 应用程序相比，只有第一步不同。在主项目上右键单击，选择 **ch04-gallery-desktop**
    | **New subproject** | **Application** | **Qt Widgets Application** | **Choose**。'
- en: 'You will get a nice multi-projects hierarchy like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得一个像这样的多项目层次结构：
- en: '![Creating a GUI linked to a core shared library](img/image00369.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![创建与核心共享库链接的 GUI](img/image00369.jpeg)'
- en: 'It is now time to link this `gallery-desktop` application to the `gallery-core`.
    You can edit the file `gallery-desktop.pro` yourself or use the Qt Creator wizard
    like this: right-click on the project and select **gallery-desktop** | **Add library**
    | **Internal library** | **gallery-core** | **Next** | **Finish**. Here is the
    updated `gallery-desktop.pro`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将此 `gallery-desktop` 应用程序链接到 `gallery-core`。你可以自己编辑 `gallery-desktop.pro`
    文件，或者像这样使用 Qt Creator 向导：在项目上右键单击，选择 **gallery-desktop** | **Add library** | **Internal
    library** | **gallery-core** | **Next** | **Finish**。以下是更新的 `gallery-desktop.pro`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `LIBS` variable specifies the libraries to link in this project. The syntax
    is very simple: you can provide library paths with the `-L` prefix and library
    names with the `-l` prefix.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIBS` 变量指定了在此项目中要链接的库。语法非常简单：你可以使用 `-L` 前缀提供库路径，使用 `-l` 前缀提供库名称。'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, compiling a Qt project on Windows will create a `debug` and `release`
    sub-directory. That is why a different `LIBS` edition is created depending on
    the platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Windows 上编译 Qt 项目将创建一个 `debug` 和 `release` 子目录。这就是为什么根据平台创建不同的 `LIBS`
    版本。
- en: Now that the application is linked to the library `gallery-core` and knows where
    to find it, we must indicate where the library header files are located. That
    is why we must add the `gallery-core` source path to `INCLUDEPATH` and `DEPENDPATH`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已链接到 `gallery-core` 库并且知道其位置，我们必须指出库头文件的位置。这就是为什么我们必须将 `gallery-core`
    源路径添加到 `INCLUDEPATH` 和 `DEPENDPATH`。
- en: 'To complete all those tasks successfully, qmake offers some useful variables:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成所有这些任务，qmake 提供了一些有用的变量：
- en: '`$$OUT_PWD`: The absolute path to the output directory'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$$OUT_PWD`：输出目录的绝对路径'
- en: '`$$PWD`: The absolute path of the current `.pro` file'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$$PWD`：当前 `.pro` 文件的绝对路径'
- en: 'To ensure that `qmake` will compile the shared library before the desktop application,
    we must update the `ch04-gallery-desktop.pro` file according the following snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `qmake` 在编译桌面应用程序之前编译共享库，我们必须根据以下片段更新 `ch04-gallery-desktop.pro` 文件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `depends` attribute explicitly indicates that `gallery-core` must be built
    before `gallery-desktop`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`depends` 属性明确指出必须在 `gallery-desktop` 之前构建 `gallery-core`。'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to always use the `depends` attribute instead of relying on `CONFIG += ordered,`
    which only specifies a simple list order. The `depends` attribute helps qmake
    process your projects in parallel, if it can be done.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量始终使用 `depends` 属性，而不是依赖于 `CONFIG += ordered`，后者仅指定一个简单的列表顺序。`depends` 属性有助于
    qmake 在可能的情况下并行处理你的项目。
- en: 'Instead of rushing into coding blindly, we will take some time to think about
    the UI architecture. We have a lot of features to implement from the `gallery-core`
    library. We should split these features into independent QWidgets. The final application
    will look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在盲目编码之前，我们将花些时间思考UI架构。我们从`gallery-core`库中有许多功能要实现。我们应该将这些功能拆分为独立的QWidgets。最终的应用程序将看起来像这样：
- en: '![Creating a GUI linked to a core shared library](img/image00370.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建与核心共享库链接的GUI](img/image00370.jpeg)'
- en: Our future gallery desktop is here!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未来的画廊桌面就在这里！
- en: 'The exapanded view of a photo will look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 照片的扩展视图将看起来像这样：
- en: '![Creating a GUI linked to a core shared library](img/image00371.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![创建与核心共享库链接的GUI](img/image00371.jpeg)'
- en: Double-click on a thumbnail to display it in full size.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 双击缩略图以全尺寸显示。
- en: 'To sum up the main UI components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结主要的UI组件：
- en: '`AlbumListWidget`: This component lists all existing albums'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlbumListWidget`：此组件列出所有现有专辑'
- en: '`AlbumWidget`: This component shows the selected album and its thumbnails'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlbumWidget`：此组件显示所选专辑及其缩略图'
- en: '`PictureWidget`: This component displays the picture in full size'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PictureWidget`：此组件以全尺寸显示图片'
- en: 'This is how we will organize it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们组织的方式：
- en: '![Creating a GUI linked to a core shared library](img/image00372.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建与核心共享库链接的GUI](img/image00372.jpeg)'
- en: 'Each widget has a defined role and will handle specific features:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小部件都有一个定义的角色，并将处理特定功能：
- en: '| **Class name** | **Features** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **类名** | **功能** |'
- en: '| `MainWindow` | Handles the switch between the gallery and the current picture
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `MainWindow` | 处理画廊和当前图片之间的切换 |'
- en: '| `GalleryWidget` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `GalleryWidget` |'
- en: Displays existing albums
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示现有专辑
- en: Album selection
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑选择
- en: Album creation
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑创建
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `AlbumListWidget` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `AlbumListWidget` |'
- en: Displays existing albums
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示现有专辑
- en: Album selection
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑选择
- en: Album creation
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑创建
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `AlbumWidget` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `AlbumWidget` |'
- en: Displays existing pictures as thumbnails
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示现有图片作为缩略图
- en: Adds pictures in the album
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在专辑中添加图片
- en: Album rename
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑重命名
- en: Album deletion
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑删除
- en: Picture selection
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片选择
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `PictureWidget` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `PictureWidget` |'
- en: Displays the selected picture
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所选图片
- en: Picture selection
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片选择
- en: Picture deletion
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片删除
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In the core shared library, we used smart pointers with standard containers
    (`vector`). Generally, in GUI projects, we tend to only use Qt containers and
    their powerful parent-child ownership system. This approach seems more appropriate
    to us. That is why we will rely on Qt containers for the GUI (and won't use smart
    pointers) in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心共享库中，我们使用了标准容器（`vector`）的智能指针。通常，在GUI项目中，我们倾向于只使用Qt容器及其强大的父子所有权系统。我们认为这种方法更合适。这就是为什么我们将依赖于Qt容器来构建GUI（并且不会使用智能指针）在本章中。
- en: We can now safely begin to create our widgets; all of them are created from
    **Qt Designer Form Class**. If you have a memory lapse, you can check the *Custom
    QWidget* section in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1.  Get Your
    Qt Feet Wet"), *Get Your Qt Feet Wet*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安全地开始创建我们的小部件；它们都是从**Qt Designer表单类**创建的。如果您有记忆缺失，您可以在[第1章](part0014.xhtml#aid-DB7S1
    "第1章。初识Qt")的*Get Your Qt Feet Wet*部分中查看*自定义QWidget*。
- en: Listing your albums with AlbumListWidget
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AlbumListWidget列出您的专辑
- en: This widget must offer a way to create a new album and display existing ones.
    Selecting an album must also trigger an event that will be used by other widgets
    to display the proper data. The `AlbumListWidget` component is the simplest widget
    in this project using the Qt View mechanism. Take the time to fully understand `AlbumListWidget`
    before jumping to the next widget.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件必须提供创建新专辑和显示现有专辑的方法。选择专辑还必须触发一个事件，该事件将被其他小部件用于显示正确数据。`AlbumListWidget`组件是本项目使用Qt视图机制的最简单小部件。在跳转到下一个小部件之前，花时间彻底理解`AlbumListWidget`。
- en: 'The following screenshot shows the **Form Editor** view of the file, `AlbumListWidget.ui`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了文件的**表单编辑器**视图，`AlbumListWidget.ui`：
- en: '![Listing your albums with AlbumListWidget](img/image00373.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用AlbumListWidget列出您的专辑](img/image00373.jpeg)'
- en: 'The layout is very simple. The components are described as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 布局非常简单。组件描述如下：
- en: The `AlbumListWidget` component uses a vertical layout to display the **Create**
    button above the list
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlbumListWidget`组件使用垂直布局来显示列表上方的**创建**按钮'
- en: The `frame` component contains an attractive button
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame`组件包含一个吸引人的按钮'
- en: The `createAlbumButton` component handles album creation
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createAlbumButton`组件处理专辑创建'
- en: The `albumList` component displays the album list
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`albumList`组件显示专辑列表'
- en: 'You should have recognized most of the types used here. Let us take the time
    to talk about the really new one: `QListView`. As we already saw in the previous
    chapter, Qt provides a Model/View architecture. This system relies on specific
    interfaces that you must implement to provide generic data access via your model
    classes. That is what we did in the project `gallery-core` with the `AlbumModel`
    and `PictureModel` classes.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经识别出这里使用的多数类型。让我们花点时间来谈谈真正的新类型：`QListView`。正如我们在上一章中看到的，Qt提供了一个模型/视图架构。这个系统依赖于特定的接口，你必须实现这些接口以通过你的模型类提供通用的数据访问。这就是我们在`gallery-core`项目中使用`AlbumModel`和`PictureModel`类所做的事情。
- en: It is now time to deal with the view part. The view is in charge of the presentation
    of the data. It will also handle user interactions like selection, drag and drop,
    or item editing. Fortunately, to achieve these tasks, the view is helped by other
    Qt classes such as `QItemSelectionModel`, `QModelIndex,` or `QStyledItemDelegate`,
    which we will soon use in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是处理视图部分的时候了。视图负责数据的展示。它还将处理用户交互，如选择、拖放或项目编辑。幸运的是，为了完成这些任务，视图得到了其他Qt类（如`QItemSelectionModel`、`QModelIndex`或`QStyledItemDelegate`）的帮助，我们将在本章中很快使用这些类。
- en: 'We can now enjoy one of the ready-to-use views offered by Qt:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以享受Qt提供的现成视图之一：
- en: '`QListView`: This view displays items from a model as a simple list'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QListView`: 这个视图以简单列表的形式显示模型中的项目'
- en: '`QTableView`: This view displays items from a model as a two-dimensional table'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTableView`: 这个视图以二维表格的形式显示模型中的项目'
- en: '`QTreeView`: This view displays items from a hierarchy of lists'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTreeView`: 这个视图以列表层次结构的形式显示项目'
- en: Here, the choice is rather obvious because we want to display a list of album
    names. But in a more complex situation, a rule of thumb for choosing the proper
    view is to look for the model type; here we want to add a view for `AlbumModel`
    of type `QAbstractListModel` so the `QListView` class seems correct.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，选择相当明显，因为我们想显示一系列专辑名称。但在更复杂的情况下，选择适当视图的一个经验法则是查找模型类型；这里我们想为类型为`QAbstractListModel`的`AlbumModel`添加一个视图，所以`QListView`类看起来是正确的。
- en: 'As you can see in the preceding screenshot, the  `createAlbumButton` object
    has an icon. You can add one to a `QPushButton` class by selecting the widget **property:
    icon** | **Choose resource**. You can now choose a picture from the `resource.qrc`
    file.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`createAlbumButton`对象有一个图标。你可以通过选择小部件**属性：图标** | **选择资源**来向`QPushButton`类添加一个图标。你现在可以从`resource.qrc`文件中选择一张图片。
- en: 'A **Qt resource** file is a collection of files for embedding binary files
    in your application. You can store any types of file but we commonly use it to
    store pictures, sounds, or translation files. To create a resource file, right-click
    on the project name and then follow **Add New** | **Qt** | **Qt Resource File**.
    Qt Creator will create a default file, `resource.qrc`, and add this line in your
    file `gallery-desktop.pro`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt资源**文件是嵌入二进制文件到你的应用程序中的文件集合。你可以存储任何类型的文件，但我们通常用它来存储图片、声音或翻译文件。要创建资源文件，右键单击项目名称，然后选择**添加新**
    | **Qt** | **Qt资源文件**。Qt Creator将创建一个默认文件，`resource.qrc`，并在你的文件`gallery-desktop.pro`中添加这一行：'
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The resource file can be mainly displayed in two ways: **Resource Editor**
    and **Plain Text Editor**. You can choose an editor with by right-clicking on
    the resource file and selecting **Open With**.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件可以主要以两种方式显示：**资源编辑器**和**纯文本编辑器**。你可以通过右键单击资源文件并选择**打开方式**来选择一个编辑器。
- en: 'The **Resource Editor** is a visual editor that helps you to easily add and
    remove files in your resource file, as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源编辑器**是一个可视化编辑器，它可以帮助你轻松地在资源文件中添加和删除文件，如下一个截图所示：'
- en: '![Listing your albums with AlbumListWidget](img/image00374.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用AlbumListWidget列出你的专辑](img/image00374.jpeg)'
- en: 'The **Plain Text Editor** will display this XML-based file `resource.qrc` like
    this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯文本编辑器**将像这样显示基于XML的文件`resource.qrc`：'
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the build time, `qmake` and `rcc` (Qt Resource Compiler) embed your resources
    into the application binary.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时，`qmake`和`rcc`（Qt资源编译器）将你的资源嵌入到应用程序的二进制文件中。
- en: 'Now that the form part is clear, we can analyze the `AlbumListWidget.h` file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单部分已经清晰，我们可以分析`AlbumListWidget.h`文件：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `setModel()` and `setSelectionModel()`functions are the most important
    lines in this snippet. This widget require two things to work correctly:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`setModel()`和`setSelectionModel()`函数是这个片段中最重要的一行。这个小部件需要两个东西才能正确工作：'
- en: '`AlbumModel`: This is the model class that provides access to data. We already
    created this class in the `gallery-core` project.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlbumModel`: 这是一个提供数据访问的模型类。我们已经在`gallery-core`项目中创建了此类。'
- en: '`QItemSelectionModel`: This is a Qt class that handles the selection in a view.
    By default, views use their own selection model. Sharing the same selection model
    with different views or widgets will help us to synchronize album selection easily.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QItemSelectionModel`: 这是一个Qt类，用于处理视图中的选择。默认情况下，视图使用它们自己的选择模型。与不同的视图或小部件共享相同的选择模型将帮助我们轻松同步专辑选择。'
- en: 'This is the main part of `AlbumListWidget.cpp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`AlbumListWidget.cpp`的主要部分：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The two setters will mainly be used to set the model and the selection model
    of the `albumList`. Our `QListView` class will then automatically request the
    model (`AlbumModel`) to get the row count and the `Qt::DisplayRole` (the album's
    name) for each one of them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设置器将主要用于设置`albumList`的模型和选择模型。我们的`QListView`类将随后自动请求模型（`AlbumModel`）获取每个对象的行数和`Qt::DisplayRole`（专辑的名称）。
- en: 'Let''s now see the last part of the `AlbumListWidget.cpp` file that handles
    the album creation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下处理专辑创建的`AlbumListWidget.cpp`文件的最后一部分：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We already worked with the `QInputDialog` class in [Chapter 1](part0014.xhtml#aid-DB7S1
    "Chapter 1.  Get Your Qt Feet Wet"), *Get Your Qt Feet Wet*. This time we are
    using it to ask the user to enter an album's name. Then we create an `Album` class
    with the requested name. This object is just a "data holder;" `addAlbum()` will
    use it to create and store the real object with a unique ID.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](part0014.xhtml#aid-DB7S1 "第1章。初识Qt")，*初识Qt*中使用了`QInputDialog`类。这次我们用它来询问用户输入专辑名称。然后我们创建一个具有请求名称的`Album`类。这个对象只是一个“数据持有者”；`addAlbum()`将使用它来创建和存储具有唯一ID的真实对象。
- en: The function `addAlbum()` returns us the `QModelIndex` value corresponding to
    the created album. From here, we can request the list view to select this new
    album.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAlbum()`函数返回与我们创建的专辑相对应的`QModelIndex`值。从这里，我们可以请求列表视图选择这个新专辑。'
- en: Creating a ThumbnailProxyModel
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`ThumbnailProxyModel`
- en: 'The future `AlbumWidget` view will display a grid of thumbnails with the pictures
    attached to the selected `Album`. In [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3. 
    Dividing Your Project and Ruling Your Code"), *Dividing Your Project and Ruling
    Your Code*, we designed the `gallery-core` library to be agnostic of how a picture
    should be displayed: a `Picture` class contains only a `mUrl` field.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的`AlbumWidget`视图将显示与所选`Album`相关联的图片缩略图网格。在[第3章](part0034.xhtml#aid-10DJ42
    "第3章。划分你的项目和统治你的代码")，*划分你的项目和统治你的代码*中，我们设计了`gallery-core`库，使其对图片的显示方式保持无知：`Picture`类只包含一个`mUrl`字段。
- en: In other words, the generation of the thumbnails has to be done in `gallery-desktop`
    rather than `gallery-core`. We already have the `PictureModel` class that is responsible
    for retrieving the `Picture` information, so it would be great to be able to extend
    its behavior with the thumbnail data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，缩略图的生成必须在`gallery-desktop`而不是`gallery-core`中进行。我们已经有负责检索`Picture`信息的`PictureModel`类，因此能够扩展其行为以包含缩略图数据将非常棒。
- en: This is possible in Qt with the use of the `QAbstractProxyModel` class and its
    subclasses. The goal of this class is to process data from a base `QAbstractItemModel`
    (sorting, filtering, adding data, and so on) and present it to the view by proxying
    the original model. To take a database analogy, you can view it as a projection
    over a table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，使用`QAbstractProxyModel`类及其子类可以实现这一点。这个类的主要目的是处理来自基础`QAbstractItemModel`的数据（排序、过滤、添加数据等），并通过代理原始模型将其呈现给视图。用数据库的类比，你可以将其视为对表的投影。
- en: 'The `QAbstractProxyModel` class has two subclasses:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAbstractProxyModel`类有两个子类：'
- en: The `QIdentityProxyModel` subclass proxies its source model without any modification
    (all the indexes match). This class is suitable if you want to transform the `data()`
    function.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QIdentityProxyModel`子类在不进行任何修改的情况下代理其源模型（所有索引匹配）。如果你想要转换`data()`函数，这个类是合适的。'
- en: The `QSortFilterProxyModel` subclass proxies its source model with the ability
    to sort and filter the passing data.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSortFilterProxyModel`子类能够代理其源模型，并具有排序和过滤传递数据的权限。'
- en: 'The former, `QIdentityProxyModel,` fits our requirements. The only thing we
    need to do is to extend the `data()` function with the thumbnail generation content.
    Create a new class named `ThumbnailProxyModel`. Here is the `ThumbnailProxyModel.h`
    file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前者`QIdentityProxyModel`符合我们的要求。我们唯一需要做的是扩展`data()`函数以包含缩略图生成内容。创建一个名为`ThumbnailProxyModel`的新类。以下是`ThumbnailProxyModel.h`文件：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This class extends `QIdentityProxyModel` and overrides a couple of functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此类扩展`QIdentityProxyModel`并重写了一些函数：
- en: The `data()` function to provide the thumbnail data to the client of `ThumbnailProxyModel`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data()`函数用于向`ThumbnailProxyModel`的客户端提供缩略图数据'
- en: The `setSourceModel()` function to register to signals emitted by `sourceModel`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSourceModel()`函数用于注册`sourceModel`发出的信号'
- en: 'The remaining custom functions have the following goals:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的自定义函数有以下目标：
- en: The `pictureModel()` is a helper function that casts the `sourceModel` to a `PictureModel*`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pictureModel()`是一个辅助函数，将`sourceModel`转换为`PictureModel*`'
- en: The `generateThumbnails()` function takes care of generating the `QPixmap` thumbnails
    for a given set of pictures
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generateThumbnails()`函数负责为给定的一组图片生成`QPixmap`缩略图'
- en: The `reloadThumbnails()` is a helper function that clears the stored thumbnails
    before calling `generateThumbnails()`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reloadThumbnails()`是一个辅助函数，在调用`generateThumbnails()`之前清除存储的缩略图'
- en: As you might have guessed, the `mThumbnails` class stores the `QPixmap*` thumbnails
    using the `filepath` for the key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`mThumbnails`类使用`filepath`作为键存储`QPixmap*`缩略图。
- en: 'We now switch to the `ThumbnailProxyModel.cpp` file and build it from the ground
    up. Let''s focus on `generateThumbnails()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在切换到`ThumbnailProxyModel.cpp`文件，并从头开始构建它。让我们关注`generateThumbnails()`：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function generates the thumbnails for a given range indicated by the parameters
    (`startIndex` and `count`). For each picture, we retrieve the `filepath` from
    the original model, using `model->data()`, and we generate a downsized `QPixmap`
    that is inserted in the `mThumbnails` QHash. Note that we arbitrarily set the
    thumbnail size using `const THUMBNAIL_SIZE`. The picture is scaled down to this
    size and respects the aspect ratio of the original picture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据参数（`startIndex`和`count`）指定的范围生成缩略图。对于每张图片，我们使用`model->data()`从原始模型中检索`filepath`，并生成一个插入到`mThumbnails`
    QHash中的缩小版的`QPixmap`。请注意，我们使用`const THUMBNAIL_SIZE`任意设置缩略图大小。图片被缩小到这个大小，并保持原始图片的宽高比。
- en: 'Each time that an album is loaded, we should clear the content of the `mThumbnails`
    class and load the new pictures. This work is done by the `reloadThumbnails()`
    function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每次加载相册时，我们应该清除`mThumbnails`类的内容并加载新的图片。这项工作由`reloadThumbnails()`函数完成：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this function, we simply clear the content of `mThumbnails` and call the `generateThumbnails()`
    function with parameters indicating that all the thumbnails should be generated.
    Let''s see when these two functions will be used, in `setSourceModel()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们简单地清除`mThumbnails`的内容，并使用表示应生成所有缩略图的参数调用`generateThumbnails()`函数。让我们看看这两个函数将在何时被使用，在`setSourceModel()`中：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the `setSourceModel()` function is called, the `ThumbnailProxyModel` class
    is configured to know which base model should be proxied. In this function, we
    register lambdas to two signals emitted by the original model:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`setSourceModel()`函数时，`ThumbnailProxyModel`类被配置为知道应该代理哪个基本模型。在此函数中，我们注册了lambda到原始模型发出的两个信号：
- en: The `modelReset` signal is triggered when pictures should be loaded for a given
    album. In this case, we have to completely reload the thumbnails.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要为特定相册加载图片时，会触发`modelReset`信号。在这种情况下，我们必须完全重新加载缩略图。
- en: The `rowsInserted` signal is triggered each time new pictures are added. At
    this point, `generateThumbnails` should be called to update `mThumbnails` with
    these newcomers.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowsInserted`信号在添加新图片时触发。此时，应调用`generateThumbnails`以更新`mThumbnails`并包含这些新来者。'
- en: 'Finally, we have to cover the `data()` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须覆盖`data()`函数：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For any role that is not `Qt::DecorationRole`, the parent class `data()` is
    called. In our case, this triggers the `data()` function from the original model, `PictureModel`.
    After that, when `data()` must return a thumbnail, the `filepath` of the picture
    referenced by the `index` is retrieved and used to return the `QPixmap` object
    of `mThumbnails`. Luckily for us, `QPixmap` can be implicitly cast to `QVariant`,
    so we do not have anything special to do here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何不是`Qt::DecorationRole`的角色，都会调用父类`data()`。在我们的案例中，这触发了原始模型`PictureModel`的`data()`函数。在那之后，当`data()`必须返回缩略图时，会检索由`index`引用的图片的`filepath`并用于返回`mThumbnails`的`QPixmap`对象。幸运的是，`QPixmap`可以隐式转换为`QVariant`，所以我们在这里不需要做任何特别的事情。
- en: 'The last function to cover in the `ThumbnailProxyModel` class is the `pictureModel()`
    function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ThumbnailProxyModel`类中要覆盖的最后一个函数是`pictureModel()`函数：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Classes that will interact with `ThumbnailProxyModel` will need to call some
    functions that are specific to `PictureModel` to create or delete pictures. This
    function is a helper to centralize the cast of the `sourceModel` to `PictureModel*`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将与`ThumbnailProxyModel`交互的类需要调用一些特定于`PictureModel`的函数来创建或删除图片。此函数是一个辅助函数，用于集中将`sourceModel`转换为`PictureModel*`。
- en: As a side note, we could have tried to generate thumbnails on-the-fly to avoid
    a possible initial bottleneck during the album loading (and the call to `generateThumbnails()`).
    However, `data()` is a `const` function, meaning that it cannot modify the `ThumbnailProxyModel`
    instance. This rules out any way of generating a thumbnail in the `data()` function
    and storing it in `mThumbnails`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们本可以尝试动态生成缩略图以避免在专辑加载（以及调用`generateThumbnails()`）过程中可能出现的初始瓶颈。然而，`data()`是一个`const`函数，这意味着它不能修改`ThumbnailProxyModel`实例。这排除了在`data()`函数中生成缩略图并将其存储在`mThumbnails`中的任何方法。
- en: As you can see, `QIdentityProxyModel`, and more generally `QAbstractProxyModel`,
    are valuable tools to add behavior to an existing model without breaking it. In
    our case, this is enforced by design in so far as the `PictureModel` class is
    defined in `gallery-core` rather than `gallery-desktop`. Modifying `PictureModel`
    implies modifying `gallery-core` and potentially breaking its behavior for other
    users of the library. This approach lets us keep things cleanly separated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`QIdentityProxyModel`以及更一般的`QAbstractProxyModel`是向现有模型添加行为而不破坏它的宝贵工具。在我们的案例中，这是通过设计强制执行的，因为`PictureModel`类是在`gallery-core`中定义的，而不是在`gallery-desktop`中。修改`PictureModel`意味着修改`gallery-core`并可能破坏库的其他用户的其行为。这种方法让我们可以保持事物的清晰分离。
- en: Displaying the selected album with AlbumWidget
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AlbumWidget显示所选专辑
- en: This widget will display the data of the selected album from `AlbumListWidget`.
    Some buttons will allow us to interact with this album.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件将显示从`AlbumListWidget`选择的专辑的数据。一些按钮将允许我们与此专辑交互。
- en: 'Here is the layout of the `AlbumWidget.ui` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`AlbumWidget.ui`文件的布局：
- en: '![Displaying the selected album with AlbumWidget](img/image00375.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用AlbumWidget显示所选专辑](img/image00375.jpeg)'
- en: 'The top frame, `albumInfoFrame`, with a horizontal layout, contains:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部框架`albumInfoFrame`采用水平布局，包含：
- en: '`albumName`: This object displays the album''s name (**Lorem ipsum** in the
    designer)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`albumName`：此对象显示专辑的名称（在设计师中为**Lorem ipsum**）'
- en: '`addPicturesButton`: This object allows the user to add pictures selecting
    files'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addPicturesButton`：此对象允许用户通过选择文件添加图片'
- en: '`editButton`: This object is used to rename the album'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`editButton`：此对象用于重命名专辑'
- en: '`deleteButton`: This object is used to delete the album'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteButton`：此对象用于删除专辑'
- en: The bottom element, `thumbnailListView,` is a `QListView`. This list view represents
    items from `PictureModel`. By default, `QListView` is able to display a picture
    next to text requesting `Qt::DisplayRole` and `Qt::DecorationRole` from the model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 底部元素`thumbnailListView`是一个`QListView`。此列表视图表示来自`PictureModel`的项目。默认情况下，`QListView`能够从模型请求`Qt::DisplayRole`和`Qt::DecorationRole`来显示图片。
- en: 'Take a look at the header `AlbumWidget.h` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看头文件`AlbumWidget.h`：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As this widget needs to deal with `Album` and `Picture` data, this class has `AlbumModel`
    and `ThumbnailProxyModel` setters. We also want to know and share the model selection
    with other widgets and views (that is, `AlbumListWidget`). That is why we also
    have `Album` and `Picture` model selection setters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此小部件需要处理`Album`和`Picture`数据，因此此类具有`AlbumModel`和`ThumbnailProxyModel`设置器。我们还希望知道并与其他小部件和视图（即`AlbumListWidget`）共享模型选择。这就是为什么我们还有`Album`和`Picture`模型选择设置器的原因。
- en: The signal `pictureActivated()` will be triggered when the user double-clicks
    on a thumbnail. We will see later how `MainWindow` will connect to this signal
    to display the picture at full size.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击缩略图时，将触发 `pictureActivated()` 信号。我们将在稍后看到 `MainWindow` 如何连接到该信号以显示全尺寸的图片。
- en: The private slots, `deleteAlbum()`, `editAlbum()`, and `addPictures()`, will
    be called when the user clicks on one of these buttons.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击这些按钮之一时，将调用私有槽 `deleteAlbum()`、`editAlbum()` 和 `addPictures()`。
- en: Finally, the `loadAlbum()` function will be called to update the UI for a specific
    album. The `clearUi()`function will be useful to clear all information displayed
    by this widget UI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将调用 `loadAlbum()` 函数来更新特定相册的 UI。`clearUi()` 函数将用于清除此小部件 UI 显示的所有信息。
- en: 'Take a look at the beginning of the implementation in the `AlbumWidget.cpp`
    file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `AlbumWidget.cpp` 文件实现的开始部分：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The constructor configures `thumbnailListView`, our `QListView` that will display
    thumbnails of the current selected album. We set here various parameters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数配置 `thumbnailListView`，这是我们用于显示当前选中相册缩略图的 `QListView`。我们在此设置各种参数：
- en: '`setSpacing()`: In this parameter, by default items are glued to each other.
    You can add spacing between them.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSpacing()`：在此参数中，默认情况下项目是粘合在一起的。您可以在它们之间添加间距。'
- en: '`setResizeMode()`: This parameter dynamically lays out items when the view
    is resized. By default, items keep their original placement even if the view is
    resized.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setResizeMode()`：此参数在视图大小调整时动态布局项目。默认情况下，即使视图大小调整，项目也会保持其原始位置。'
- en: '`setFlow()`: This parameter specifies the list direction. Here we want to display
    items from left to right. By default, the direction is `TopToBottom`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFlow()`：此参数指定列表方向。在这里，我们希望从左到右显示项目。默认方向是 `TopToBottom`。'
- en: '`setWrapping()`: This parameter allows an item to wrap when there is not enough
    space to display it in the visible area. By default, wrapping is not allowed and
    scrollbars will be displayed.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setWrapping()`：此参数允许当没有足够的空间在可见区域显示项目时，项目可以换行。默认情况下，不允许换行，将显示滚动条。'
- en: The end of the constructor performs all the signal connections related to the
    UI. The first one is a good example of signal relaying, explained in [Chapter
    1](part0014.xhtml#aid-DB7S1 "Chapter 1.  Get Your Qt Feet Wet"), *Get Your Qt
    Feet Wet*. We connect the `QListView::doubleClicked` signal to our class signal, `AlbumWidget::pictureActivated`.
    Other connections are common; we want to call a specific slot when the user clicks
    on a button. As always in the **Qt Designer Form Class**, the destructor will
    delete the member variable `ui`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的末尾执行所有与 UI 相关的信号连接。第一个是一个很好的信号中继示例，在 [第 1 章](part0014.xhtml#aid-DB7S1 "第
    1 章。初识 Qt") 中解释，*初识 Qt*。我们将 `QListView::doubleClicked` 信号连接到我们的类信号 `AlbumWidget::pictureActivated`。其他连接是常见的；我们希望在用户点击按钮时调用特定的槽。像往常一样，在
    **Qt Designer Form Class** 中，析构函数将删除成员变量 `ui`。
- en: 'Let''s see the `AlbumModel` setter implementation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `AlbumModel` 设置器的实现：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the selected album's data changed, we need to update the UI with the `loadAlbum()`
    function. A test is performed to ensure that the updated album is the currently
    selected one. Notice that the `QAbstractItemModel::dataChanged()` function has
    three parameters but the lambda slot syntax allows us to omit unused parameters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所选相册的数据已更改，我们需要使用 `loadAlbum()` 函数更新 UI。进行测试以确保更新的相册是当前选中的相册。请注意，`QAbstractItemModel::dataChanged()`
    函数有三个参数，但 lambda 插槽语法允许我们省略未使用的参数。
- en: Our `AlbumWidget` component must update its UI according to the currently selected
    album. As we share the same selection model, each time the user selects an album
    from `AlbumListWidget`, the signal `QItemSelectionModel::selectionChanged` is
    triggered. In this case, we update the UI by calling the `loadAlbum()` function.
    As we do not support album multi-selection, we can restrict the process to the
    first selected element. If the selection is empty, we simply clear the UI.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `AlbumWidget` 组件必须根据当前选中的相册更新其 UI。由于我们共享相同的选择模型，每次用户从 `AlbumListWidget`
    中选择一个相册时，都会触发 `QItemSelectionModel::selectionChanged` 信号。在这种情况下，我们通过调用 `loadAlbum()`
    函数来更新 UI。由于我们不支持相册多选，我们可以将过程限制在第一个选定的元素上。如果选择为空，我们只需清除 UI。
- en: 'It is now the turn of the `PictureModel` setter implementation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，轮到 `PictureModel` 设置器的实现：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is very simple here. We set the model and the selection model of `thumbnailListView`,
    our `QListView` that will display the selected album's thumbnails. We also keep
    the picture model to manipulate the data later on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里非常简单。我们设置了`thumbnailListView`的模型和选择模型，我们的`QListView`将显示所选相册的缩略图。我们还保留了图片模型以供以后操作数据。
- en: 'We can now cover the features one by one. Let''s start with album deletion:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以逐个介绍功能。让我们从相册删除开始：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The most important task in the `deleteAlbum()` function is to retrieve the current
    row index from `mAlbumSelectionModel`. Then, we can request `mAlbumModel` to delete
    this row. The rest of the function will only try to automatically select the previous
    or the next album. Once again, as we shared the same selection model, `AlbumListWidget`
    will automatically update its album selection.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`deleteAlbum()`函数中，最重要的任务是检索`mAlbumSelectionModel`中的当前行索引。然后，我们可以请求`mAlbumModel`删除此行。函数的其余部分将仅尝试自动选择上一个或下一个相册。再次强调，因为我们共享相同的选择模型，`AlbumListWidget`将自动更新其相册选择。
- en: 'The following snippet shows the album rename feature:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了相册重命名功能：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, again the `QInputDialog` class will help us to implement a feature. You
    should be confident with its behavior now. This function performs three steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`QInputDialog`类将帮助我们实现一个功能。现在你应该对其行为有信心。此函数执行三个步骤：
- en: Retrieve the current name from album model.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相册模型中检索当前名称。
- en: Generate a great input dialog.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个出色的输入对话框。
- en: Request the album model to update the name
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求相册模型更新名称
- en: As you can see, the generic functions `data()` and `setData()` from the models
    are very powerful when combined with `ItemDataRole`. As already explained, we
    do not directly update our UI; this will be automatically performed because `setData()`
    emits a signal, `dataChanged()`, which `AlbumWidget` handles.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当与`ItemDataRole`结合使用时，模型中的通用函数`data()`和`setData()`非常强大。正如已经解释的，我们不会直接更新我们的UI；这将被自动执行，因为`setData()`会发出一个信号`dataChanged()`，该信号由`AlbumWidget`处理。
- en: 'The last feature allows us to add some new picture files in the current album:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个功能允许我们在当前相册中添加一些新的图片文件：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `QFileDialog` class is used here to help the user select several picture
    files. For each filename, we create a `Picture` data holder, like we have already
    seen in this chapter for album creation. Then we can request `mPictureModel` to
    add this picture in the current album. Note that, because `mPictureModel` is a `ThumbnailProxyModel`
    class, we have to retrieve the real `PictureModel` using the helper function, `pictureModel()`.
    As the function `addPicture()` returns us the corresponding `QModelIndex`, we
    finally select the most recently added picture in `thumbnailListView`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFileDialog`类用于帮助用户选择多个图片文件。对于每个文件名，我们创建一个`Picture`数据持有者，就像我们在本章创建相册时已经看到的那样。然后我们可以请求`mPictureModel`将此图片添加到当前相册中。请注意，因为`mPictureModel`是一个`ThumbnailProxyModel`类，我们必须使用辅助函数`pictureModel()`检索实际的`PictureModel`。由于`addPicture()`函数返回相应的`QModelIndex`，我们最终选择`thumbnailListView`中最新的图片。'
- en: 'Let''s complete `AlbumWidget.cpp`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成`AlbumWidget.cpp`：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `clearUi()`function clears the album's name and hides the buttons, while
    the `loadAlbum()` function retrieves the `Qt::DisplayRole` (the album's name)
    and displays the buttons.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearUi()`函数清除相册的名称并隐藏按钮，而`loadAlbum()`函数检索`Qt::DisplayRole`（相册的名称）并显示按钮。'
- en: Enhancing thumbnails with PictureDelegate
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PictureDelegate增强缩略图
- en: 'By default, a `QListView` class will request `Qt::DisplayRole` and `Qt::DecorationRole`
    to display text and a picture for each item. Thus, we already have a visual result,
    for free, that looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`QListView`类将请求`Qt::DisplayRole`和`Qt::DecorationRole`以显示每个项目的文本和图片。因此，我们已经有了一个免费的可视结果，看起来像这样：
- en: '![Enhancing thumbnails with PictureDelegate](img/image00376.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![使用PictureDelegate增强缩略图](img/image00376.jpeg)'
- en: 'However, our **Gallery** application deserves better thumbnail rendering. Hopefully,
    we can easily customize it using the view''s delegate concept. A `QListView` class
    provides a default item rendering. We can do our own item rendering by creating
    a class that inherits `QStyledItemDelegate`. The aim is to paint your dream thumbnails
    with a name banner like the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的**画廊**应用程序值得更好的缩略图渲染。希望我们可以通过使用视图的代理概念轻松地自定义它。`QListView`类提供了一个默认的项目渲染。我们可以通过创建一个继承自`QStyledItemDelegate`的类来自定义项目渲染。目标是绘制像以下截图所示的带有名称横幅的梦幻缩略图：
- en: '![Enhancing thumbnails with PictureDelegate](img/image00377.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用PictureDelegate增强缩略图](img/image00377.jpeg)'
- en: 'Let''s take a look at `PictureDelegate.h`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`PictureDelegate.h`：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That is right, we only have to override two functions. The most important function,
    `paint()`, will allow us to paint the item like we want. The `sizeHint()` function
    will be used to specify the item size.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，我们只需要重写两个函数。最重要的函数是`paint()`，它将允许我们按照我们想要的方式绘制项目。`sizeHint()`函数将用于指定项目大小。
- en: 'We can now see the painter work in `PictureDelegate.cpp`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`PictureDelegate.cpp`中看到画家的工作：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each time `QListView` needs to display an item, this delegate''s `paint()`
    function will be called. The paint system can be seen as layers that you paint
    one on top of each other. The `QPainter` class allows us to paint anything we
    want: circles, pies, rectangles, text, and so on. The item area can be retrieved
    with `option.rect()`. Here are the steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每次当`QListView`需要显示一个项目时，此代理的`paint()`函数将被调用。绘图系统可以看作是层，你可以在每一层上绘制。`QPainter`类允许我们绘制任何我们想要的东西：圆形、饼图、矩形、文本等等。项目区域可以通过`option.rect()`检索。以下是步骤：
- en: It is easy to break the `painter` state passed in the parameter list, thus we
    must save the painter state with `painter->save()` before doing anything, to be
    able to restore it when we have finished our drawing.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很容易破坏参数列表中传递的`painter`状态，因此我们必须在开始绘制之前使用`painter->save()`保存画家状态，以便在完成我们的绘制后能够恢复它。
- en: Retrieve the item thumbnail and draw it with the `QPainter::drawPixmap()` function.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索项目缩略图并使用`QPainter::drawPixmap()`函数绘制它。
- en: Paint a translucent gray banner on top of the thumbnail with the `QPainter::fillRect()`
    function.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QPainter::fillRect()`函数在缩略图上方绘制一个半透明的灰色横幅。
- en: Retrieve the item display name and draw it on the banner using the `QPainter::drawText()`
    function.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QPainter::drawText()`函数检索项目显示名称并在横幅上绘制它。
- en: If the item is selected, we paint a translucent rectangle on the top using the
    highlight color from the item.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果项目被选中，我们将使用项目的突出颜色在顶部绘制一个半透明的矩形。
- en: We restore the painter state to its original state.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将画家状态恢复到其原始状态。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to draw a more complex item, check the `QPainter` official documentation
    at [doc.qt.io/qt-5/qpainter.html](http://doc.qt.io/qt-5/qpainter.html).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要绘制更复杂的项目，请查看[doc.qt.io/qt-5/qpainter.html](http://doc.qt.io/qt-5/qpainter.html)的`QPainter`官方文档。
- en: 'This is the `sizeHint()` function''s implementation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`sizeHint()`函数的实现：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This one is easier. We want the item's size to be equal to the thumbnail size.
    As we kept the aspect ratio of the thumbnail during its creation in `Picture::setFilePath()`,
    thumbnails can have a different width and height. Hence, we basically retrieve
    the thumbnail and return its size.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较简单。我们希望项目的大小与缩略图大小相等。因为我们保持了缩略图在创建时的宽高比，所以缩略图可以有不同的大小。因此，我们基本上检索缩略图并返回其大小。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you create an item delegate, avoid directly inheriting the `QItemDelegate`
    class and instead inherit `QStyledItemDelegate`. This last one supports Qt style
    sheets, allowing you to easily customize the rendering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个项目代理时，避免直接继承`QItemDelegate`类，而是继承`QStyledItemDelegate`。后者支持Qt样式表，允许你轻松自定义渲染。
- en: 'Now that `PictureDelegate` is ready, we can configure our `thumbnailListView`
    to use it, updating the `AlbumWidget.cpp` file like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`PictureDelegate`已经准备好了，我们可以配置我们的`thumbnailListView`使用它，并更新`AlbumWidget.cpp`文件如下：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Qt tip**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt提示**'
- en: An item delegate can also manage the editing process with the `QStyledItemDelegate::createEditor()` function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 项目代理也可以使用`QStyledItemDelegate::createEditor()`函数管理编辑过程。
- en: Displaying a picture with PictureWidget
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PictureWidget显示图片
- en: This widget will be called to display a picture at its full size. We also add
    some buttons to go to the previous/next picture or delete the current one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件将被调用来显示图片的全尺寸。我们还添加了一些按钮来跳转到上一张/下一张图片或删除当前图片。
- en: 'Let''s start to analyze the `PictureWidget.ui` form, here is the design view:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始分析`PictureWidget.ui`表单，以下是设计视图：
- en: '![Displaying a picture with PictureWidget](img/image00378.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![使用PictureWidget显示图片](img/image00378.jpeg)'
- en: 'Here are the details:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是详细内容：
- en: '`backButton`: This object requests to display the gallery'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backButton`: 此对象请求显示图库'
- en: '`deleteButton`: This object removes the picture from the album'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteButton`: 此对象从相册中删除图片'
- en: '`nameLabel`: This object displays the picture name'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameLabel`: 此对象显示图片名称'
- en: '`nextButton`: This object selects the next picture in the album'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextButton`: 此对象选择相册中的下一张图片'
- en: '`previousButton`: This object selects the previous picture in the album'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previousButton`: 此对象选择相册中的上一张图片'
- en: '`pictureLabel`: This object displays the picture'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pictureLabel`: 此对象显示图片'
- en: 'We can now take a look at the header `PictureWidget.h`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看头文件 `PictureWidget.h`：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: No surprises here, we have the `ThumbnailProxyModel*` and `QItemSelectionModel*`
    setters in the `PictureWidget` class. The signal `backToGallery()` is triggered
    when the user clicks on the `backButton` object. It will be handled by `MainWindow`
    to display again the gallery. We override `resizeEvent()` to ensure that we always
    use all the visible area to display the picture. The `deletePicture()`slot will
    process the deletion when the user clicks on the corresponding button. The `loadPicture()`function
    will be called to update the UI with the specified picture. Finally, `updatePicturePixmap()`
    is a helper function to display the picture according to the current widget size.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜，我们在 `PictureWidget` 类中有 `ThumbnailProxyModel*` 和 `QItemSelectionModel*`
    设置器。当用户点击 `backButton` 对象时，会触发 `backToGallery()` 信号。它将由 `MainWindow` 处理，再次显示图库。我们重写
    `resizeEvent()` 来确保我们始终使用所有可见区域来显示图片。`deletePicture()` 插槽将在用户点击相应的按钮时处理删除操作。`loadPicture()`
    函数将被调用来更新 UI 并显示指定的图片。最后，`updatePicturePixmap()` 是一个辅助函数，用于根据当前小部件大小显示图片。
- en: This widget is really similar to the others. As a result, we will not put the
    full implementation code of `PictureWidget.cpp` here. You can check the full source
    code example if needed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件与其他小部件非常相似。因此，我们不会在这里放置 `PictureWidget.cpp` 的完整实现代码。如果需要，你可以检查完整的源代码示例。
- en: 'Let''s see how this widget is able to always display the picture at its full
    size in `PictureWidget.cpp`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个小部件如何在 `PictureWidget.cpp` 中始终以全尺寸显示图片：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, every time the widget is resized, we call `updatePicturePixmap()`. The `mPixmap`
    variable is the full-size picture from `PictureModel`. This function will scale
    the picture to the `pictureLabel` size, keeping the aspect ratio. You can freely
    resize the window and enjoy your picture with the biggest possible size.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次小部件被调整大小时，我们都会调用 `updatePicturePixmap()`。`mPixmap` 变量是从 `PictureModel`
    获取的全尺寸图片。此函数将图片缩放到 `pictureLabel` 的大小，并保持宽高比。你可以自由调整窗口大小，并享受最大可能的图片尺寸。
- en: Composing your Gallery app
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合你的图库应用
- en: Alright, we completed `AlbumListWidget`, `AlbumWidget,` and `PictureWidget`.
    If you remember correctly, `AlbumListWidget` and `AlbumWidget` are contained in
    a widget called `GalleryWidget`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经完成了 `AlbumListWidget`、`AlbumWidget` 和 `PictureWidget`。如果你记得正确的话，`AlbumListWidget`
    和 `AlbumWidget` 包含在一个名为 `GalleryWidget` 的小部件中。
- en: 'Let''s take a look at the `GalleryWidget.ui` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `GalleryWidget.ui` 文件：
- en: '![Composing your Gallery app](img/image00379.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![组合你的图库应用](img/image00379.jpeg)'
- en: 'This widget does not contain any standard Qt widgets but only our created widgets.
    Qt provides two ways to use your own widgets in the Qt designer:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件不包含任何标准 Qt 小部件，而只包含我们创建的小部件。Qt 提供两种方式在 Qt 设计器中使用您自己的小部件：
- en: '**Promoting widgets**: This is the fastest and easiest way'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升小部件**：这是最快、最简单的方法'
- en: '**Creating widget plugin for Qt designer**: This is more powerful but more
    complex'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为 Qt 设计器创建小部件插件**：这更强大，但更复杂'
- en: 'In this chapter, we will use the first way, which consists of placing a generic
    `QWidget` as a placeholder and then promoting it to our custom widget class. You
    can follow these steps to add the `albumListWidget` and the `albumWidget` objects
    to the `GalleryWidget.ui` file from the Qt designer:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用第一种方法，该方法包括放置一个通用的 `QWidget` 作为占位符，然后将其提升到我们的自定义小部件类。你可以按照以下步骤将 `albumListWidget`
    和 `albumWidget` 对象添加到 `GalleryWidget.ui` 文件中，从 Qt 设计器开始：
- en: Drag and drop a **Widget** from **Containers** to your form.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**容器**拖放一个**小部件**到你的表单中。
- en: Set the **objectName** (for example, `albumListWidget`) from the **Property
    Editor**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**属性编辑器**设置**objectName**（例如，`albumListWidget`）。
- en: Select **Promote to...** from the widget contextual menu.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从小部件上下文菜单中选择**提升到...**
- en: Set the promoted class name (for example, `AlbumWidget`).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置提升的类名（例如，`AlbumWidget`）。
- en: Check that header file is correct (for example, `AlbumWidget.h`).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认该头文件正确（例如，`AlbumWidget.h`）。
- en: Click on the **Add** button and then click on **Promote**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮，然后点击**提升**。
- en: If you fail your widget promotion, you can always reverse it with **Demote to
    QWidget** from the contextual menu.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你未能提升你的小部件，你总是可以从上下文菜单中选择**降级到 QWidget**来撤销操作。
- en: There is nothing really exciting in the header and implementation of `GalleryWidget`.
    We only provide setters for the model and model selection of `Album` and `Picture`
    to forward them to `albumListWidget` and `albumWidget`. This class also relays
    the signal `pictureActivated` from `albumWidget`. Please check the full source
    code if needed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GalleryWidget`的头文件和实现中并没有什么真正令人兴奋的内容。我们只为`Album`和`Picture`的模型和模型选择提供了设置器，将它们转发到`albumListWidget`和`albumWidget`。这个类还转发了从`albumWidget`发出的`pictureActivated`信号。如有需要，请检查完整的源代码。
- en: 'This is the final part of this chapter. We will now analyze `MainWindow`. Nothing
    is done in `MainWindow.ui` because everything is handled in the code. This is `MainWindow.h`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一部分。现在我们将分析`MainWindow`。在`MainWindow.ui`中没有做任何事情，因为所有的事情都在代码中处理。这是`MainWindow.h`：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The two slots, `displayGallery()` and `displayPicture(),` will be used to switch
    the display between the gallery (album list with the album and thumbnail) and
    the picture ( full-size). The `QStackedWidget` class can contain various widgets
    but display only one at a time.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个槽`displayGallery()`和`displayPicture()`将用于在画廊（带有专辑和缩略图的专辑列表）和图片（全尺寸）之间切换显示。`QStackedWidget`类可以包含各种窗口，但一次只能显示一个。
- en: 'Let''s take a look to the beginning of the constructor in the `MainWindow.cpp`
    file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`MainWindow.cpp`文件中构造函数的开始部分：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we initialize the UI by calling `ui->setupUi()`. Then we create `AlbumModel`
    and its `QItemSelectionModel`. Finally, we call the setters of `GalleryWidget`
    that will dispatch them to the `AlbumListWidget` and `AlbumWidget` objects.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`ui->setupUi()`初始化UI。然后我们创建`AlbumModel`及其`QItemSelectionModel`。最后，我们调用`GalleryWidget`的设置器，它们将分发到`AlbumListWidget`和`AlbumWidget`对象。
- en: 'Continuing our analysis of this constructor:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 继续分析这个构造函数：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The behavior with `Picture` is close to the previous one with `Album`. But we
    also share `ThumbnailProxyModel`, which is initialized from `PictureModel`, and
    its `QItemSelectionModel` with `PictureWidget`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Picture`的行为与之前的`Album`相似。但我们还共享`ThumbnailProxyModel`，它从`PictureModel`初始化，并且与`PictureWidget`的`QItemSelectionModel`。'
- en: 'The constructor now performs the signal/slot connections:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数现在执行信号/槽连接：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do you remember the `pictureActivated()` function? This signal is emitted when
    you double-click on a thumbnail in `albumWidget`. We can now connect it to our `displayPicture`
    slot, which will switch the display with the picture at its full size. Do not
    forget to also connect the `backToGallery` signal emitted when the user clicks
    on the `backButton` from `PictureWidget`. It will switch again to display the
    gallery.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得`pictureActivated()`函数吗？当你双击`albumWidget`中的缩略图时，这个信号会被发出。现在我们可以将它连接到我们的`displayPicture`槽，这将切换显示并显示全尺寸的图片。不要忘记连接从`PictureWidget`发出的`backToGallery`信号，当用户点击`backButton`时，它将再次切换以显示画廊。
- en: 'The last part of the constructor is easy:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的最后部分很简单：
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We add our two widgets, `mGalleryWidget` and `mPictureWidget,` to the `mStackedWidget`
    class. When the application starts, we want to display the gallery, so we call
    our own slot `displayGallery()`. Finally, we define `mStackedWidget` as the main
    window's central widget.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的两个窗口`mGalleryWidget`和`mPictureWidget`添加到`mStackedWidget`类中。当应用程序启动时，我们希望显示画廊，因此我们调用自己的槽`displayGallery()`。最后，我们将`mStackedWidget`定义为主窗口的中心窗口。
- en: 'To finish this chapter, let''s see what happens in these two magic slots that
    allows to switch the display when the user requests it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，让我们看看这两个魔法槽中发生了什么，允许在用户请求时切换显示：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That seems ridiculously easy. We just request `mStackedWidget` to select the
    corresponding widget. As `PictureWidget` shares the same selection model with
    other views, we can even ignore the `index` variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来简单得荒谬。我们只需请求`mStackedWidget`选择相应的窗口。由于`PictureWidget`与其他视图共享相同的选择模型，我们甚至可以忽略`index`变量。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The real separation between data and representation is not always an easy task.
    Dividing the core and the GUI in two different projects is a good practice. It
    will force you to design separated layers in your application. At first sight,
    the Qt model/view system can appear complex. But this chapter taught you how powerful
    it can be and how easy it is to use. Thanks to the Qt framework, the persistence
    of data in a database can be done without headaches.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和表示之间的真正分离并不总是件容易的事。将核心和GUI分成两个不同的项目是一种良好的实践。这将迫使你在应用程序中设计分离的层。乍一看，Qt模型/视图系统可能显得复杂。但这一章教你它有多么强大，以及使用它是多么简单。多亏了Qt框架，数据库中数据的持久化可以轻松完成，无需头疼。
- en: This chapter built on top of the foundations laid with the `gallery-core` library.
    In the next chapter, we will reuse the same core library and create a mobile UI
    with Qt Quick in QML.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在`gallery-core`库所奠定的基础之上。在下一章中，我们将重用相同的核心库，并在QML中使用Qt Quick创建一个移动UI。
