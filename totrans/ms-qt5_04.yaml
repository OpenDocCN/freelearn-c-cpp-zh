- en: Chapter 4.  Conquering the Desktop UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built the brain of our gallery using Qt models.
    It is now time to build a desktop application using this engine. This software
    will use all the features offered by the `gallery-core` library, leading to a
    completely usable gallery on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: The first task will be to link your project-shared library to this new application.
    Then you will learn how to create custom widgets, when to use Qt views, and how
    to synchronize them with the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Linking the application to a project library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt model/view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt resource file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promoting custom widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GUI linked to a core shared library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `gallery-core` shared library is now ready. Let's see how to create the
    desktop GUI project. We will create a Qt Widgets application sub-project called `gallery-desktop`.
    Only the first steps differ from a classic Qt Widgets application. Right-click
    on the main project, and select **ch04-gallery-desktop** | **New subproject**
    | **Application** | **Qt Widgets Application** | **Choose**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get a nice multi-projects hierarchy like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a GUI linked to a core shared library](img/image00369.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is now time to link this `gallery-desktop` application to the `gallery-core`.
    You can edit the file `gallery-desktop.pro` yourself or use the Qt Creator wizard
    like this: right-click on the project and select **gallery-desktop** | **Add library**
    | **Internal library** | **gallery-core** | **Next** | **Finish**. Here is the
    updated `gallery-desktop.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LIBS` variable specifies the libraries to link in this project. The syntax
    is very simple: you can provide library paths with the `-L` prefix and library
    names with the `-l` prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, compiling a Qt project on Windows will create a `debug` and `release`
    sub-directory. That is why a different `LIBS` edition is created depending on
    the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the application is linked to the library `gallery-core` and knows where
    to find it, we must indicate where the library header files are located. That
    is why we must add the `gallery-core` source path to `INCLUDEPATH` and `DEPENDPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete all those tasks successfully, qmake offers some useful variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$$OUT_PWD`: The absolute path to the output directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$$PWD`: The absolute path of the current `.pro` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure that `qmake` will compile the shared library before the desktop application,
    we must update the `ch04-gallery-desktop.pro` file according the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `depends` attribute explicitly indicates that `gallery-core` must be built
    before `gallery-desktop`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to always use the `depends` attribute instead of relying on `CONFIG += ordered,`
    which only specifies a simple list order. The `depends` attribute helps qmake
    process your projects in parallel, if it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of rushing into coding blindly, we will take some time to think about
    the UI architecture. We have a lot of features to implement from the `gallery-core`
    library. We should split these features into independent QWidgets. The final application
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a GUI linked to a core shared library](img/image00370.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our future gallery desktop is here!
  prefs: []
  type: TYPE_NORMAL
- en: 'The exapanded view of a photo will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a GUI linked to a core shared library](img/image00371.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Double-click on a thumbnail to display it in full size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up the main UI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AlbumListWidget`: This component lists all existing albums'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlbumWidget`: This component shows the selected album and its thumbnails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PictureWidget`: This component displays the picture in full size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how we will organize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a GUI linked to a core shared library](img/image00372.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each widget has a defined role and will handle specific features:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class name** | **Features** |'
  prefs: []
  type: TYPE_TB
- en: '| `MainWindow` | Handles the switch between the gallery and the current picture
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GalleryWidget` |'
  prefs: []
  type: TYPE_TB
- en: Displays existing albums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Album selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Album creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `AlbumListWidget` |'
  prefs: []
  type: TYPE_TB
- en: Displays existing albums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Album selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Album creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `AlbumWidget` |'
  prefs: []
  type: TYPE_TB
- en: Displays existing pictures as thumbnails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds pictures in the album
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Album rename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Album deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `PictureWidget` |'
  prefs: []
  type: TYPE_TB
- en: Displays the selected picture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In the core shared library, we used smart pointers with standard containers
    (`vector`). Generally, in GUI projects, we tend to only use Qt containers and
    their powerful parent-child ownership system. This approach seems more appropriate
    to us. That is why we will rely on Qt containers for the GUI (and won't use smart
    pointers) in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can now safely begin to create our widgets; all of them are created from
    **Qt Designer Form Class**. If you have a memory lapse, you can check the *Custom
    QWidget* section in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1.  Get Your
    Qt Feet Wet"), *Get Your Qt Feet Wet*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing your albums with AlbumListWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This widget must offer a way to create a new album and display existing ones.
    Selecting an album must also trigger an event that will be used by other widgets
    to display the proper data. The `AlbumListWidget` component is the simplest widget
    in this project using the Qt View mechanism. Take the time to fully understand `AlbumListWidget`
    before jumping to the next widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Form Editor** view of the file, `AlbumListWidget.ui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing your albums with AlbumListWidget](img/image00373.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The layout is very simple. The components are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AlbumListWidget` component uses a vertical layout to display the **Create**
    button above the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `frame` component contains an attractive button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createAlbumButton` component handles album creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `albumList` component displays the album list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should have recognized most of the types used here. Let us take the time
    to talk about the really new one: `QListView`. As we already saw in the previous
    chapter, Qt provides a Model/View architecture. This system relies on specific
    interfaces that you must implement to provide generic data access via your model
    classes. That is what we did in the project `gallery-core` with the `AlbumModel`
    and `PictureModel` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to deal with the view part. The view is in charge of the presentation
    of the data. It will also handle user interactions like selection, drag and drop,
    or item editing. Fortunately, to achieve these tasks, the view is helped by other
    Qt classes such as `QItemSelectionModel`, `QModelIndex,` or `QStyledItemDelegate`,
    which we will soon use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now enjoy one of the ready-to-use views offered by Qt:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QListView`: This view displays items from a model as a simple list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTableView`: This view displays items from a model as a two-dimensional table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTreeView`: This view displays items from a hierarchy of lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the choice is rather obvious because we want to display a list of album
    names. But in a more complex situation, a rule of thumb for choosing the proper
    view is to look for the model type; here we want to add a view for `AlbumModel`
    of type `QAbstractListModel` so the `QListView` class seems correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, the  `createAlbumButton` object
    has an icon. You can add one to a `QPushButton` class by selecting the widget **property:
    icon** | **Choose resource**. You can now choose a picture from the `resource.qrc`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Qt resource** file is a collection of files for embedding binary files
    in your application. You can store any types of file but we commonly use it to
    store pictures, sounds, or translation files. To create a resource file, right-click
    on the project name and then follow **Add New** | **Qt** | **Qt Resource File**.
    Qt Creator will create a default file, `resource.qrc`, and add this line in your
    file `gallery-desktop.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The resource file can be mainly displayed in two ways: **Resource Editor**
    and **Plain Text Editor**. You can choose an editor with by right-clicking on
    the resource file and selecting **Open With**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Resource Editor** is a visual editor that helps you to easily add and
    remove files in your resource file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing your albums with AlbumListWidget](img/image00374.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Plain Text Editor** will display this XML-based file `resource.qrc` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the build time, `qmake` and `rcc` (Qt Resource Compiler) embed your resources
    into the application binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the form part is clear, we can analyze the `AlbumListWidget.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setModel()` and `setSelectionModel()`functions are the most important
    lines in this snippet. This widget require two things to work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AlbumModel`: This is the model class that provides access to data. We already
    created this class in the `gallery-core` project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QItemSelectionModel`: This is a Qt class that handles the selection in a view.
    By default, views use their own selection model. Sharing the same selection model
    with different views or widgets will help us to synchronize album selection easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the main part of `AlbumListWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The two setters will mainly be used to set the model and the selection model
    of the `albumList`. Our `QListView` class will then automatically request the
    model (`AlbumModel`) to get the row count and the `Qt::DisplayRole` (the album's
    name) for each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the last part of the `AlbumListWidget.cpp` file that handles
    the album creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We already worked with the `QInputDialog` class in [Chapter 1](part0014.xhtml#aid-DB7S1
    "Chapter 1.  Get Your Qt Feet Wet"), *Get Your Qt Feet Wet*. This time we are
    using it to ask the user to enter an album's name. Then we create an `Album` class
    with the requested name. This object is just a "data holder;" `addAlbum()` will
    use it to create and store the real object with a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: The function `addAlbum()` returns us the `QModelIndex` value corresponding to
    the created album. From here, we can request the list view to select this new
    album.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ThumbnailProxyModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The future `AlbumWidget` view will display a grid of thumbnails with the pictures
    attached to the selected `Album`. In [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3. 
    Dividing Your Project and Ruling Your Code"), *Dividing Your Project and Ruling
    Your Code*, we designed the `gallery-core` library to be agnostic of how a picture
    should be displayed: a `Picture` class contains only a `mUrl` field.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the generation of the thumbnails has to be done in `gallery-desktop`
    rather than `gallery-core`. We already have the `PictureModel` class that is responsible
    for retrieving the `Picture` information, so it would be great to be able to extend
    its behavior with the thumbnail data.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible in Qt with the use of the `QAbstractProxyModel` class and its
    subclasses. The goal of this class is to process data from a base `QAbstractItemModel`
    (sorting, filtering, adding data, and so on) and present it to the view by proxying
    the original model. To take a database analogy, you can view it as a projection
    over a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QAbstractProxyModel` class has two subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QIdentityProxyModel` subclass proxies its source model without any modification
    (all the indexes match). This class is suitable if you want to transform the `data()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QSortFilterProxyModel` subclass proxies its source model with the ability
    to sort and filter the passing data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The former, `QIdentityProxyModel,` fits our requirements. The only thing we
    need to do is to extend the `data()` function with the thumbnail generation content.
    Create a new class named `ThumbnailProxyModel`. Here is the `ThumbnailProxyModel.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This class extends `QIdentityProxyModel` and overrides a couple of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `data()` function to provide the thumbnail data to the client of `ThumbnailProxyModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setSourceModel()` function to register to signals emitted by `sourceModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining custom functions have the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pictureModel()` is a helper function that casts the `sourceModel` to a `PictureModel*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `generateThumbnails()` function takes care of generating the `QPixmap` thumbnails
    for a given set of pictures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reloadThumbnails()` is a helper function that clears the stored thumbnails
    before calling `generateThumbnails()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might have guessed, the `mThumbnails` class stores the `QPixmap*` thumbnails
    using the `filepath` for the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now switch to the `ThumbnailProxyModel.cpp` file and build it from the ground
    up. Let''s focus on `generateThumbnails()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function generates the thumbnails for a given range indicated by the parameters
    (`startIndex` and `count`). For each picture, we retrieve the `filepath` from
    the original model, using `model->data()`, and we generate a downsized `QPixmap`
    that is inserted in the `mThumbnails` QHash. Note that we arbitrarily set the
    thumbnail size using `const THUMBNAIL_SIZE`. The picture is scaled down to this
    size and respects the aspect ratio of the original picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time that an album is loaded, we should clear the content of the `mThumbnails`
    class and load the new pictures. This work is done by the `reloadThumbnails()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we simply clear the content of `mThumbnails` and call the `generateThumbnails()`
    function with parameters indicating that all the thumbnails should be generated.
    Let''s see when these two functions will be used, in `setSourceModel()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `setSourceModel()` function is called, the `ThumbnailProxyModel` class
    is configured to know which base model should be proxied. In this function, we
    register lambdas to two signals emitted by the original model:'
  prefs: []
  type: TYPE_NORMAL
- en: The `modelReset` signal is triggered when pictures should be loaded for a given
    album. In this case, we have to completely reload the thumbnails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rowsInserted` signal is triggered each time new pictures are added. At
    this point, `generateThumbnails` should be called to update `mThumbnails` with
    these newcomers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have to cover the `data()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For any role that is not `Qt::DecorationRole`, the parent class `data()` is
    called. In our case, this triggers the `data()` function from the original model, `PictureModel`.
    After that, when `data()` must return a thumbnail, the `filepath` of the picture
    referenced by the `index` is retrieved and used to return the `QPixmap` object
    of `mThumbnails`. Luckily for us, `QPixmap` can be implicitly cast to `QVariant`,
    so we do not have anything special to do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function to cover in the `ThumbnailProxyModel` class is the `pictureModel()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Classes that will interact with `ThumbnailProxyModel` will need to call some
    functions that are specific to `PictureModel` to create or delete pictures. This
    function is a helper to centralize the cast of the `sourceModel` to `PictureModel*`.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, we could have tried to generate thumbnails on-the-fly to avoid
    a possible initial bottleneck during the album loading (and the call to `generateThumbnails()`).
    However, `data()` is a `const` function, meaning that it cannot modify the `ThumbnailProxyModel`
    instance. This rules out any way of generating a thumbnail in the `data()` function
    and storing it in `mThumbnails`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `QIdentityProxyModel`, and more generally `QAbstractProxyModel`,
    are valuable tools to add behavior to an existing model without breaking it. In
    our case, this is enforced by design in so far as the `PictureModel` class is
    defined in `gallery-core` rather than `gallery-desktop`. Modifying `PictureModel`
    implies modifying `gallery-core` and potentially breaking its behavior for other
    users of the library. This approach lets us keep things cleanly separated.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the selected album with AlbumWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This widget will display the data of the selected album from `AlbumListWidget`.
    Some buttons will allow us to interact with this album.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the layout of the `AlbumWidget.ui` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the selected album with AlbumWidget](img/image00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The top frame, `albumInfoFrame`, with a horizontal layout, contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`albumName`: This object displays the album''s name (**Lorem ipsum** in the
    designer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addPicturesButton`: This object allows the user to add pictures selecting
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`editButton`: This object is used to rename the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteButton`: This object is used to delete the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom element, `thumbnailListView,` is a `QListView`. This list view represents
    items from `PictureModel`. By default, `QListView` is able to display a picture
    next to text requesting `Qt::DisplayRole` and `Qt::DecorationRole` from the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the header `AlbumWidget.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As this widget needs to deal with `Album` and `Picture` data, this class has `AlbumModel`
    and `ThumbnailProxyModel` setters. We also want to know and share the model selection
    with other widgets and views (that is, `AlbumListWidget`). That is why we also
    have `Album` and `Picture` model selection setters.
  prefs: []
  type: TYPE_NORMAL
- en: The signal `pictureActivated()` will be triggered when the user double-clicks
    on a thumbnail. We will see later how `MainWindow` will connect to this signal
    to display the picture at full size.
  prefs: []
  type: TYPE_NORMAL
- en: The private slots, `deleteAlbum()`, `editAlbum()`, and `addPictures()`, will
    be called when the user clicks on one of these buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `loadAlbum()` function will be called to update the UI for a specific
    album. The `clearUi()`function will be useful to clear all information displayed
    by this widget UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the beginning of the implementation in the `AlbumWidget.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor configures `thumbnailListView`, our `QListView` that will display
    thumbnails of the current selected album. We set here various parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setSpacing()`: In this parameter, by default items are glued to each other.
    You can add spacing between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setResizeMode()`: This parameter dynamically lays out items when the view
    is resized. By default, items keep their original placement even if the view is
    resized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFlow()`: This parameter specifies the list direction. Here we want to display
    items from left to right. By default, the direction is `TopToBottom`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setWrapping()`: This parameter allows an item to wrap when there is not enough
    space to display it in the visible area. By default, wrapping is not allowed and
    scrollbars will be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end of the constructor performs all the signal connections related to the
    UI. The first one is a good example of signal relaying, explained in [Chapter
    1](part0014.xhtml#aid-DB7S1 "Chapter 1.  Get Your Qt Feet Wet"), *Get Your Qt
    Feet Wet*. We connect the `QListView::doubleClicked` signal to our class signal, `AlbumWidget::pictureActivated`.
    Other connections are common; we want to call a specific slot when the user clicks
    on a button. As always in the **Qt Designer Form Class**, the destructor will
    delete the member variable `ui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `AlbumModel` setter implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the selected album's data changed, we need to update the UI with the `loadAlbum()`
    function. A test is performed to ensure that the updated album is the currently
    selected one. Notice that the `QAbstractItemModel::dataChanged()` function has
    three parameters but the lambda slot syntax allows us to omit unused parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Our `AlbumWidget` component must update its UI according to the currently selected
    album. As we share the same selection model, each time the user selects an album
    from `AlbumListWidget`, the signal `QItemSelectionModel::selectionChanged` is
    triggered. In this case, we update the UI by calling the `loadAlbum()` function.
    As we do not support album multi-selection, we can restrict the process to the
    first selected element. If the selection is empty, we simply clear the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now the turn of the `PictureModel` setter implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is very simple here. We set the model and the selection model of `thumbnailListView`,
    our `QListView` that will display the selected album's thumbnails. We also keep
    the picture model to manipulate the data later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now cover the features one by one. Let''s start with album deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The most important task in the `deleteAlbum()` function is to retrieve the current
    row index from `mAlbumSelectionModel`. Then, we can request `mAlbumModel` to delete
    this row. The rest of the function will only try to automatically select the previous
    or the next album. Once again, as we shared the same selection model, `AlbumListWidget`
    will automatically update its album selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the album rename feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, again the `QInputDialog` class will help us to implement a feature. You
    should be confident with its behavior now. This function performs three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the current name from album model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a great input dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request the album model to update the name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the generic functions `data()` and `setData()` from the models
    are very powerful when combined with `ItemDataRole`. As already explained, we
    do not directly update our UI; this will be automatically performed because `setData()`
    emits a signal, `dataChanged()`, which `AlbumWidget` handles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last feature allows us to add some new picture files in the current album:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `QFileDialog` class is used here to help the user select several picture
    files. For each filename, we create a `Picture` data holder, like we have already
    seen in this chapter for album creation. Then we can request `mPictureModel` to
    add this picture in the current album. Note that, because `mPictureModel` is a `ThumbnailProxyModel`
    class, we have to retrieve the real `PictureModel` using the helper function, `pictureModel()`.
    As the function `addPicture()` returns us the corresponding `QModelIndex`, we
    finally select the most recently added picture in `thumbnailListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete `AlbumWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `clearUi()`function clears the album's name and hides the buttons, while
    the `loadAlbum()` function retrieves the `Qt::DisplayRole` (the album's name)
    and displays the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing thumbnails with PictureDelegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, a `QListView` class will request `Qt::DisplayRole` and `Qt::DecorationRole`
    to display text and a picture for each item. Thus, we already have a visual result,
    for free, that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing thumbnails with PictureDelegate](img/image00376.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, our **Gallery** application deserves better thumbnail rendering. Hopefully,
    we can easily customize it using the view''s delegate concept. A `QListView` class
    provides a default item rendering. We can do our own item rendering by creating
    a class that inherits `QStyledItemDelegate`. The aim is to paint your dream thumbnails
    with a name banner like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing thumbnails with PictureDelegate](img/image00377.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at `PictureDelegate.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That is right, we only have to override two functions. The most important function,
    `paint()`, will allow us to paint the item like we want. The `sizeHint()` function
    will be used to specify the item size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now see the painter work in `PictureDelegate.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time `QListView` needs to display an item, this delegate''s `paint()`
    function will be called. The paint system can be seen as layers that you paint
    one on top of each other. The `QPainter` class allows us to paint anything we
    want: circles, pies, rectangles, text, and so on. The item area can be retrieved
    with `option.rect()`. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to break the `painter` state passed in the parameter list, thus we
    must save the painter state with `painter->save()` before doing anything, to be
    able to restore it when we have finished our drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the item thumbnail and draw it with the `QPainter::drawPixmap()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paint a translucent gray banner on top of the thumbnail with the `QPainter::fillRect()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the item display name and draw it on the banner using the `QPainter::drawText()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the item is selected, we paint a translucent rectangle on the top using the
    highlight color from the item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We restore the painter state to its original state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to draw a more complex item, check the `QPainter` official documentation
    at [doc.qt.io/qt-5/qpainter.html](http://doc.qt.io/qt-5/qpainter.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `sizeHint()` function''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This one is easier. We want the item's size to be equal to the thumbnail size.
    As we kept the aspect ratio of the thumbnail during its creation in `Picture::setFilePath()`,
    thumbnails can have a different width and height. Hence, we basically retrieve
    the thumbnail and return its size.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create an item delegate, avoid directly inheriting the `QItemDelegate`
    class and instead inherit `QStyledItemDelegate`. This last one supports Qt style
    sheets, allowing you to easily customize the rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `PictureDelegate` is ready, we can configure our `thumbnailListView`
    to use it, updating the `AlbumWidget.cpp` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Qt tip**'
  prefs: []
  type: TYPE_NORMAL
- en: An item delegate can also manage the editing process with the `QStyledItemDelegate::createEditor()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a picture with PictureWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This widget will be called to display a picture at its full size. We also add
    some buttons to go to the previous/next picture or delete the current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start to analyze the `PictureWidget.ui` form, here is the design view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a picture with PictureWidget](img/image00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`backButton`: This object requests to display the gallery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteButton`: This object removes the picture from the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nameLabel`: This object displays the picture name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextButton`: This object selects the next picture in the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previousButton`: This object selects the previous picture in the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pictureLabel`: This object displays the picture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now take a look at the header `PictureWidget.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here, we have the `ThumbnailProxyModel*` and `QItemSelectionModel*`
    setters in the `PictureWidget` class. The signal `backToGallery()` is triggered
    when the user clicks on the `backButton` object. It will be handled by `MainWindow`
    to display again the gallery. We override `resizeEvent()` to ensure that we always
    use all the visible area to display the picture. The `deletePicture()`slot will
    process the deletion when the user clicks on the corresponding button. The `loadPicture()`function
    will be called to update the UI with the specified picture. Finally, `updatePicturePixmap()`
    is a helper function to display the picture according to the current widget size.
  prefs: []
  type: TYPE_NORMAL
- en: This widget is really similar to the others. As a result, we will not put the
    full implementation code of `PictureWidget.cpp` here. You can check the full source
    code example if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this widget is able to always display the picture at its full
    size in `PictureWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, every time the widget is resized, we call `updatePicturePixmap()`. The `mPixmap`
    variable is the full-size picture from `PictureModel`. This function will scale
    the picture to the `pictureLabel` size, keeping the aspect ratio. You can freely
    resize the window and enjoy your picture with the biggest possible size.
  prefs: []
  type: TYPE_NORMAL
- en: Composing your Gallery app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, we completed `AlbumListWidget`, `AlbumWidget,` and `PictureWidget`.
    If you remember correctly, `AlbumListWidget` and `AlbumWidget` are contained in
    a widget called `GalleryWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `GalleryWidget.ui` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing your Gallery app](img/image00379.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This widget does not contain any standard Qt widgets but only our created widgets.
    Qt provides two ways to use your own widgets in the Qt designer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Promoting widgets**: This is the fastest and easiest way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating widget plugin for Qt designer**: This is more powerful but more
    complex'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the first way, which consists of placing a generic
    `QWidget` as a placeholder and then promoting it to our custom widget class. You
    can follow these steps to add the `albumListWidget` and the `albumWidget` objects
    to the `GalleryWidget.ui` file from the Qt designer:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop a **Widget** from **Containers** to your form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **objectName** (for example, `albumListWidget`) from the **Property
    Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Promote to...** from the widget contextual menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the promoted class name (for example, `AlbumWidget`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that header file is correct (for example, `AlbumWidget.h`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button and then click on **Promote**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you fail your widget promotion, you can always reverse it with **Demote to
    QWidget** from the contextual menu.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing really exciting in the header and implementation of `GalleryWidget`.
    We only provide setters for the model and model selection of `Album` and `Picture`
    to forward them to `albumListWidget` and `albumWidget`. This class also relays
    the signal `pictureActivated` from `albumWidget`. Please check the full source
    code if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final part of this chapter. We will now analyze `MainWindow`. Nothing
    is done in `MainWindow.ui` because everything is handled in the code. This is `MainWindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The two slots, `displayGallery()` and `displayPicture(),` will be used to switch
    the display between the gallery (album list with the album and thumbnail) and
    the picture ( full-size). The `QStackedWidget` class can contain various widgets
    but display only one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look to the beginning of the constructor in the `MainWindow.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialize the UI by calling `ui->setupUi()`. Then we create `AlbumModel`
    and its `QItemSelectionModel`. Finally, we call the setters of `GalleryWidget`
    that will dispatch them to the `AlbumListWidget` and `AlbumWidget` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing our analysis of this constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The behavior with `Picture` is close to the previous one with `Album`. But we
    also share `ThumbnailProxyModel`, which is initialized from `PictureModel`, and
    its `QItemSelectionModel` with `PictureWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor now performs the signal/slot connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Do you remember the `pictureActivated()` function? This signal is emitted when
    you double-click on a thumbnail in `albumWidget`. We can now connect it to our `displayPicture`
    slot, which will switch the display with the picture at its full size. Do not
    forget to also connect the `backToGallery` signal emitted when the user clicks
    on the `backButton` from `PictureWidget`. It will switch again to display the
    gallery.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the constructor is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We add our two widgets, `mGalleryWidget` and `mPictureWidget,` to the `mStackedWidget`
    class. When the application starts, we want to display the gallery, so we call
    our own slot `displayGallery()`. Finally, we define `mStackedWidget` as the main
    window's central widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this chapter, let''s see what happens in these two magic slots that
    allows to switch the display when the user requests it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That seems ridiculously easy. We just request `mStackedWidget` to select the
    corresponding widget. As `PictureWidget` shares the same selection model with
    other views, we can even ignore the `index` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real separation between data and representation is not always an easy task.
    Dividing the core and the GUI in two different projects is a good practice. It
    will force you to design separated layers in your application. At first sight,
    the Qt model/view system can appear complex. But this chapter taught you how powerful
    it can be and how easy it is to use. Thanks to the Qt framework, the persistence
    of data in a database can be done without headaches.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter built on top of the foundations laid with the `gallery-core` library.
    In the next chapter, we will reuse the same core library and create a mobile UI
    with Qt Quick in QML.
  prefs: []
  type: TYPE_NORMAL
