- en: Developing Embedded Systems with Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt开发嵌入式系统
- en: Qt (pronounced *cute*) is an advanced C++-based framework that covers a wide
    range of APIs, allowing you to implement networking, graphical user interfaces,
    parsing of data formats, the playing back and recording of audio, and much more.
    This chapter primarily covers the graphical aspect of Qt, and how to create advanced
    GUIs for embedded devices to provide an attractive and functional UI to users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Qt（发音为*cute*）是一个基于C++的高级框架，涵盖了广泛的API，允许你实现网络、图形用户界面、数据格式解析、音频播放和录制等。本章主要涵盖Qt的图形方面，以及如何为嵌入式设备创建高级GUI，为用户提供吸引力和功能性的用户界面。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Creating advanced GUIs with Qt for embedded systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt为嵌入式系统创建高级GUI
- en: Using Qt's 3D designer to create an infotainment UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt的3D设计器创建信息娱乐UI
- en: Extending an existing embedded system with a GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GUI扩展现有的嵌入式系统
- en: The power of the right framework
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确框架的力量
- en: A **framework** is essentially a collection of code aimed at easing the development
    of software for a specific application. It provides the developer with a range
    of classes—or the language equivalent—to allow you to implement the application
    logic without having to worry about interfacing with the underlying hardware,
    or using the OS's APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架**本质上是一组代码的集合，旨在简化特定应用软件的开发。它为开发者提供了一系列类或语言等效物，允许你实现应用逻辑，而无需担心与底层硬件接口，或使用操作系统的API。'
- en: In previous chapters, we used a number of frameworks to make our development
    efforts easier, from the No date Framework ([Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml),
    *Resource-Restricted Embedded Systems*) and CMSIS to Arduino for **microcontrollers**
    (**MCUs**), and from the low-level POCO framework for cross-platform development
    to the higher-level Qt framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了多个框架来简化我们的开发工作，从No date框架（第4章，*资源受限的嵌入式系统*）和CMSIS到Arduino的**微控制器**（**MCUs**），以及从低级POCO框架用于跨平台开发到高级Qt框架。
- en: Each of these frameworks has a specific type of system that they are intended
    for. For No date, CMSIS, and Arduino, the target is MCUs, ranging from 8-bit AVR
    MCUs to 32-bit ARM MCUs. These target the bare-metal systems, without any intermediate
    **operating system** (**OS**) or similar. Above those in terms of complexity,
    we find **real-time OS frameworks** (**RTOS**), which include a full OS in the
    framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些框架都针对特定类型的系统。对于No date、CMSIS和Arduino，目标是微控制器（MCUs），范围从8位AVR微控制器到32位ARM微控制器。这些针对裸机系统，没有任何中间**操作系统**（**OS**）或类似的东西。在复杂性方面更高，我们发现**实时操作系统框架**（**RTOS**），其中框架包含一个完整的操作系统。
- en: Frameworks such as POCO and Qt target OSes in general, from desktop and server
    platforms to SoC platforms. Here they function primarily as an abstraction layer
    between the OS-specific APIs, while providing additional functionality alongside
    this abstraction. This allows you to quickly build up a full-featured application,
    without having to spend much time on each feature.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如POCO和Qt之类的框架针对通用操作系统，从桌面和服务器平台到SoC平台。在这里，它们主要作为操作系统特定API之间的抽象层，同时提供额外的功能。这允许你快速构建一个功能齐全的应用程序，而无需在每个功能上花费太多时间。
- en: This is particularly important for networking functionality, where you do not
    want to write a TCP sockets-based server from scratch, but ideally just want to
    instantiate a ready-made class and use it. In the case of Qt, it also provides
    graphical user interface-related APIs to make the development of cross-platform
    GUIs easier. Other frameworks that also provide this kind of functionality include
    GTK+ and WxWidgets. In this chapter, however, we'll just be looking at developing
    with Qt.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于网络功能尤其重要，你不想从头开始编写基于TCP套接字的服务器，而理想的情况是只是实例化一个现成的类并使用它。在Qt的情况下，它还提供了与图形用户界面相关的API，以简化跨平台GUI的开发。其他也提供此类功能的框架包括GTK+和WxWidgets。然而，在本章中，我们只关注使用Qt进行开发。
- en: In [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml), *Example - Linux-Based
    Infotainment System*, we got a good look at how to develop with the Qt framework.
    There, we mostly ignored the **graphical user interface** (**GUI**) part, even
    though this is probably the most interesting part of Qt relative to other OS-based
    frameworks. Being able to use the same GUI across multiple OSes can be incredibly
    useful and convenient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](4416b2de-d86a-4001-863d-b167635a0e10.xhtml)，“基于 Linux 的信息娱乐系统示例”中，我们很好地了解了如何使用
    Qt 框架进行开发。在那里，我们主要忽略了 **图形用户界面**（**GUI**）部分，尽管这可能是 Qt 相对于其他基于操作系统的框架中最有趣的部分。能够在多个操作系统上使用相同的
    GUI 可以非常实用和方便。
- en: This is mostly the case for desktop-based applications, where the GUI is a crucial
    part of the application, and thus not having to spend the time and trouble of
    porting it between OSes is a major time saver. For embedded platforms, this is
    also true, though here you have the option of integrating even deeper into the
    system than on a desktop system, as we will see in a moment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这在基于桌面的应用程序中通常是这种情况，其中 GUI 是应用程序的关键部分，因此不需要花费时间和精力在不同操作系统之间移植它，这是一个巨大的时间节省。对于嵌入式平台来说，这也是正确的，尽管在这里你有选择比桌面系统更深入地集成到系统中的选项，正如我们稍后将看到的。
- en: We'll also look at the various types of Qt applications that you can develop,
    starting with a simple **command-line interface** (**CLI**) application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看你可以开发的多种类型的 Qt 应用程序，从简单的 **命令行界面**（**CLI**）应用程序开始。
- en: Qt for command-line use
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行使用的 Qt
- en: 'Even though the graphical user interface is a big selling point of the Qt framework,
    it is also possible to use it to develop command-line-only applications. For this,
    we just use the `QCoreApplication` class to create an input and an event loop
    handler, as in this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图形用户界面是 Qt 框架的一个大卖点，但也可以使用它来开发仅使用命令行的应用程序。为此，我们只需使用 `QCoreApplication` 类来创建一个输入和事件循环处理程序，就像这个例子一样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, our code is implemented in a class called `Core`. In the main function,
    we create a `QCoreApplication` instance, which receives the command-line parameters.
    We then instantiate an instance of our class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的代码在一个名为 `Core` 的类中实现。在主函数中，我们创建一个 `QCoreApplication` 实例，它接收命令行参数。然后我们实例化我们类的一个实例。
- en: We connect a signal from our class to the `QCoreApplication` instance, so that
    if we signal that we have finished, it will trigger a slot on the latter to clean
    up and terminate the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们类中的一个信号连接到 `QCoreApplication` 实例，这样如果我们发出完成信号，它将触发后者的槽来清理并终止应用程序。
- en: After this, we call the method on our class to start its functionality and finally
    start the event loop by calling `exec()` on the `QCoreApplication` instance. At
    this point, we can use signals.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用我们类中的方法来启动其功能，并通过在 `QCoreApplication` 实例上调用 `exec()` 来最终启动事件循环。在这个时候，我们可以使用信号。
- en: 'Note here that it is also possible to use Qt4-style connection syntax, instead
    of the earlier Qt5-style:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里也可以使用 Qt4 风格的连接语法，而不是早期的 Qt5 风格：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functionally, this makes no difference, and using either is fine for most situations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 功能上，这没有区别，使用任何一种在大多数情况下都是可以的。
- en: 'Our class appears as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的结构如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every class in a Qt-based application that wants to make use of the signal-slot
    architecture of Qt is required to derive from the `QObject` class, and to include
    the `Q_OBJECT` macro within the class declaration. This is needed for Qt's `qmake
    preprocessor` tool to know which classes to process before the application code
    is compiled by the toolchain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Qt 的应用程序中，任何想要使用 Qt 的信号-槽架构的类都必须从 `QObject` 类派生，并在类声明中包含 `Q_OBJECT` 宏。这是为了让
    Qt 的 `qmake 预处理器` 工具知道在应用程序代码由工具链编译之前需要处理哪些类。
- en: 'Here is the implementation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现方式：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of note is the fact that we can let the constructor of any QObject-derived class
    know what the encapsulating parent class is, allowing said parent to own these
    child classes and invoke their destructor when it itself is destroyed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们可以让任何 `QObject` 派生类的构造函数知道封装的父类是什么，这样父类就可以拥有这些子类，并在它自身被销毁时调用它们的析构函数。
- en: GUI-based Qt applications
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 GUI 的 Qt 应用程序
- en: 'Returning to the Qt-based example project from [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml),
    *Example - Linux-Based Infotainment System*, we can now compare its main function
    to the preceding command-line-only version to see what changes once we add a GUI
    to the project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第8章的基于Qt的示例项目[第8章](4416b2de-d86a-4001-863d-b167635a0e10.xhtml)，*示例 - 基于 Linux
    的信息娱乐系统*，我们现在可以将其主函数与之前的仅命令行版本进行比较，以查看添加GUI到项目后发生了什么变化：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The most obvious change here is that we use `QApplication` instead of `QCoreApplication`.
    The other big change is that we do not use a completely custom class, but one
    that derives from `QMainWindow`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最明显的变化是我们使用`QApplication`而不是`QCoreApplication`。另一个重大变化是我们没有使用一个完全自定义的类，而是使用一个从`QMainWindow`派生的类：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we can see that the `MainWindow` class indeed derives from `QMainWindow`,
    which also gives it its `show()` method. Of note is the `MainWindow` instance
    being declared in the UI namespace. This is connected to the auto-generated code
    that is created when we run the qmake tool on the UI file, as we will see in a
    moment. Next is the constructor:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到`MainWindow`类确实是从`QMainWindow`派生的，这也给了它自己的`show()`方法。值得注意的是，`MainWindow`实例是在UI命名空间中声明的。这与我们在UI文件上运行qmake工具时创建的自动生成的代码相连接，我们将在下一刻看到。接下来是构造函数：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing of note here is how we inflate the GUI from the UI description
    file. This file is usually created by visually laying out the GUI with the Qt
    Designer tool, which is part of the Qt Creator IDE. This UI file contains a description
    of each widget's properties, along with the layout applied to them, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的第一件事是我们如何从UI描述文件中扩展GUI。这个文件通常是通过Qt Designer工具可视地布局GUI创建的，Qt Designer是Qt
    Creator IDE的一部分。这个UI文件包含了每个小部件的属性描述，以及应用到的布局等。
- en: 'It''s also possible to programmatically create these widgets and add them to
    layouts, of course. This gets quite tedious for larger layouts, however. Generally,
    you create a single UI file for the main window, and an additional one for each
    sub window and dialog. These can then be inflated into a window or dialog in a
    similar fashion:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以通过编程创建这些小部件并将它们添加到布局中。然而，对于更大的布局来说，这会变得相当繁琐。通常，你为主窗口创建一个单独的UI文件，并为每个子窗口和对话框创建一个额外的文件。然后，它们可以以类似的方式膨胀成窗口或对话框：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Menu actions in the GUI are connected to internal slots by specifying the specific
    signal on the menu action (`QAction` instance). We can see here that they are
    in the `ui` object, which is found in the auto-generated source code for the UI
    file, as we mentioned earlier:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GUI中的菜单操作通过指定菜单操作（`QAction`实例）上的特定信号与内部槽连接。我们可以看到它们位于`ui`对象中，这个对象位于UI文件的自动生成的源代码中，正如我们之前提到的：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Button widgets in the GUI are connected in a similar manner, though they of
    course emit a different signal on account of them being a different type of widget:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: GUI中的按钮小部件以类似的方式连接，尽管由于它们是不同类型的小部件，因此发出不同的信号：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re free to do anything we would do in any other constructor, including
    setting defaults and creating instances of classes we will need later on:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何其他构造函数中做任何我们想做的事情，包括设置默认值和创建我们稍后需要的类的实例：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One crucial thing to remember here is that this class runs on the UI thread,
    meaning that we should not do anything intensive in here. That''s why we move
    such class instances off to their own thread, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的一个关键点是这个类在UI线程上运行，这意味着我们不应该在这里做任何密集的操作。这就是为什么我们将这样的类实例移动到它们自己的线程中，如下所示：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the constructor, we delete the UI and all associated elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们删除UI及其所有相关元素。
- en: Embedded Qt
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内嵌Qt
- en: A major target of the Qt framework next to desktop systems are **embedded systems**,
    specifically **Embedded Linux**, where there are a few different ways to use Q.
    The main point of embedded Qt is to optimize the software stock by allowing you
    to boot straight into a Qt-optimized environment, and by allowing for a variety
    of ways to render to the display.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了桌面系统之外，Qt框架的主要目标之一是**嵌入式系统**，特别是**嵌入式Linux**，在这里有几种不同的方式来使用Q。嵌入式Qt的主要目的是通过允许你直接进入Qt优化的环境，以及允许以多种方式渲染到显示来优化软件库存。
- en: 'Qt for Embedded Linux supports the following platform plugins for rendering:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Qt for Embedded Linux支持以下平台插件进行渲染：
- en: '| **Plugin** | **Description** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **插件** | **描述** |'
- en: '| EGLFS | Provides an interface to OpenGL ES or similar 3D rendering API. Usually,
    the default configuration for Embedded Linux. More details about EGL can be found
    at the following address: [https://www.khronos.org/egl](https://www.khronos.org/egl).
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| EGLFS | 提供了访问 OpenGL ES 或类似 3D 渲染 API 的接口。通常，嵌入式 Linux 的默认配置。有关 EGL 的更多详细信息，请参阅以下地址：[https://www.khronos.org/egl](https://www.khronos.org/egl)。|'
- en: '| LinuxFB | Writes directly to the framebuffer via Linux''s fbdev subsystem.
    Only software-rendered content is supported. As a result, on some setups the display
    performance is likely to be limited. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| LinuxFB | 通过 Linux 的 fbdev 子系统直接写入帧缓冲区。仅支持软件渲染的内容。因此，在某些配置中，显示性能可能会受限。|'
- en: '| DirectFB | Directly writes to the graphic card''s framebuffer using the DirectFB
    library. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| DirectFB | 使用 DirectFB 库直接将图形卡帧缓冲区写入。|'
- en: '| Wayland | Uses the Wayland windowing system. This allows for multiple concurrent
    windows, but is of course more demanding on the hardware. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Wayland | 使用 Wayland 窗口系统。这允许有多个并发窗口，但当然对硬件的要求更高。|'
- en: In addition to this, Qt for Embedded Linux comes with a variety of APIs for
    handling touch and pen input, and so on. To optimize the system for a Qt-based
    application, any unrelated services, processes, and libraries are generally removed,
    resulting in a system that boots within a matter of seconds into the embedded
    application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Qt for Embedded Linux 还提供了一系列 API 来处理触摸和笔输入等。为了优化基于 Qt 的应用程序的系统，通常会将任何无关的服务、进程和库移除，从而使得系统能够在几秒钟内启动到嵌入式应用程序。
- en: Custom GUIs with stylesheets
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式表的定制 GUI
- en: The standard widget-based GUIs that desktop systems tend to use do not lend
    themselves that readily to customization. As a result, you are generally faced
    with having to either override the painting function in a `QWidget` instance and
    handle every single pixel of the widget drawing, or to use stylesheet-based customization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面系统倾向于使用的标准基于小部件的 GUI 并不适合定制。因此，您通常必须要么在 `QWidget` 实例中覆盖绘制函数并处理小部件绘制的每个像素，要么使用基于样式表的定制。
- en: Qt stylesheets allow you to tweak the look and feel of individual widgets, even
    dynamically. They are essentially written using **Cascading Style Sheet** (**CSS**)
    syntax as used with HTML pages. They allow you to change elements of a widget,
    such as the borders, rounding corners, or the thickness and color of the elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 样式表允许您调整单个小部件的外观和感觉，甚至可以动态调整。它们本质上使用与 HTML 页面相同的 **Cascading Style Sheet**（**CSS**）语法编写。它们允许您更改小部件的元素，例如边框、圆角或元素的厚度和颜色。
- en: QML
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML
- en: '**Qt Modeling Language** (**QML**) is a user interface markup language. It
    is strongly based on JavaScript and even uses inline JavaScript. It can be used
    to create dynamic and completely custom user interfaces, and is usually used together
    with the Qt Quick module.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt 模型语言**（**QML**）是一种用户界面标记语言。它基于 JavaScript，甚至使用内联 JavaScript。它可以用来创建动态和完全定制的用户界面，通常与
    Qt Quick 模块一起使用。'
- en: Later in this chapter, we will take an in-depth look at how a dynamic GUI is
    created.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将深入探讨如何创建动态 GUI。
- en: 3D designer
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 设计器
- en: With Qt 5, the Qt 3D module was introduced, which streamlined access to the
    OpenGL rendering API. This new module was used as the foundation for the Qt 3D
    Designer editor and the accompanying runtime. It can be used to create highly
    dynamic GUIs, featuring a combination of 2D and 3D elements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 5 中，引入了 Qt 3D 模块，该模块简化了对 OpenGL 渲染 API 的访问。这个新模块被用作 Qt 3D Designer 编辑器和相关运行时的基础。它可以用来创建高度动态的
    GUI，结合了 2D 和 3D 元素。
- en: It is quite similar to hand-crafted QML-based GUIs, but provides a more streamlined
    workflow, ease of adding animations, and previewing the project. It's similar
    to the Qt Designer Studio, which focuses more on 2D GUIs, but this one is not
    available for free, instead requiring you to purchase a license.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它与手工制作的基于 QML 的 GUI 非常相似，但提供了更流畅的工作流程，易于添加动画，并预览项目。它与专注于 2D GUI 的 Qt Designer
    Studio 类似，但这个版本不是免费的，而是需要您购买许可证。
- en: An example of adding a GUI to the infotainment system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 GUI 添加到信息娱乐系统的示例
- en: In this example, we will be using C++, Qt, and QML to create a graphical user
    interface that is capable of showing the current track that is playing, performing
    an audio visualization, indicating the playback progress, and allowing you to
    toggle different input modes using onscreen buttons.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用 C++、Qt 和 QML 来创建一个图形用户界面，该界面能够显示正在播放的当前曲目，执行音频可视化，指示播放进度，并允许您使用屏幕上的按钮切换不同的输入模式。
- en: 'This example is based on the *Audio Visualizer* example from the Qt documentation.
    This can be found in the Qt installation folder (if examples got installed), as
    well as on the Qt site: [https://doc.qt.io/qt-5/qt3d-audio-visualizer-qml-example.html.](https://doc.qt.io/qt-5/qt3d-audio-visualizer-qml-example.html.)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本例基于 Qt 文档中的 *音频可视化器* 示例。这个示例可以在 Qt 安装文件夹中找到（如果安装了示例），也可以在 Qt 网站上找到：[https://doc.qt.io/qt-5/qt3d-audio-visualizer-qml-example.html.](https://doc.qt.io/qt-5/qt3d-audio-visualizer-qml-example.html.)
- en: The main difference between this code and the official example is that the `QMediaPlayer`
    media player was moved into the C++ code, along with a number of other functions.
    Instead, a number of signals and slots between the QML UI and C++ backend are
    used in the new `QmlInterface` class for button presses, updating the UI, and
    interaction with the media player.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与官方示例相比，本代码的主要区别是将 `QMediaPlayer` 媒体播放器移动到了 C++ 代码中，以及许多其他函数。相反，在新的 `QmlInterface`
    类中，使用了一系列信号和槽在 QML UI 和 C++ 后端之间，用于按钮点击、更新 UI 和与媒体播放器的交互。
- en: A GUI such as this could be wired into the existing infotainment project code
    to control its functionality, using the GUI in addition to the voice-driven interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 GUI 可以集成到现有的信息娱乐项目代码中，以控制其功能，除了语音驱动界面外，还可以使用 GUI。
- en: 'The GUI we''re putting together in this example looks like this in action:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们构建的 GUI 在实际操作中的样子如下：
- en: '![](img/abcd27b7-3f26-455b-8fa1-3e70263869cf.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abcd27b7-3f26-455b-8fa1-3e70263869cf.png)'
- en: Main
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主类
- en: 'The main source file appears as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 主要源文件如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our custom class is added to the QML viewer (`QQuickView`) as a context class.
    This serves as the proxy between the QML UI and our C++ code, as we will see in
    a moment. The viewer itself uses an OpenGL surface to render the UI on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义类被添加到 QML 查看器 (`QQuickView`) 中作为上下文类。这充当了 QML UI 和我们的 C++ 代码之间的代理，正如我们稍后将会看到的。查看器本身使用
    OpenGL 表面来渲染 UI。
- en: QmlInterface
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QmlInterface
- en: 'The header of our custom class features a number of additions to make properties
    and methods visible to the QML code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义类的头部添加了一些功能，使得属性和方法在 QML 代码中可见：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Q_PROPERTY` tag tells the qmake parser that this class contains a property
    (variable) that should be made visible to the QML code, with the parameters specifying
    the name of the variable, the methods used for reading and writing the variable
    (if desired), and finally the signal that is emitted whenever the property has
    changed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_PROPERTY` 标签告诉 qmake 解析器，此类包含一个属性（变量），该变量应使 QML 代码可见，参数指定了变量的名称、用于读取和写入变量的方法（如果需要），以及每当属性发生变化时发出的信号。'
- en: 'This allows for an automatic update feature to be set up to keep this property
    synchronized between the C++ code and the QML side:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许设置自动更新功能，以保持 C++ 代码和 QML 端之间的属性同步：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similarly, the `Q_INVOKABLE` tag ensures that these methods are made visible
    to the QML side and can be called from there.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Q_INVOKABLE` 标签确保这些方法对 QML 端可见，并且可以从那里调用。
- en: 'Here is the implementation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其实施方法：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constructor got changed considerably from the original example project,
    with the media player instance being created here, along with its connections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与原始示例项目相比发生了很大变化，媒体播放器实例在这里创建，以及其连接。
- en: 'We load the same music file here as was used with the original project. When
    integrating the code into the infotainment project or a similar project, you would
    make this dynamic. Similarly, the file that we are also loading here to get the
    amplitude for the music file with the visualization would likely be omitted in
    a full integration, instead opting to generate the amplitude values dynamically:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里加载与原始项目相同的音乐文件。当将代码集成到信息娱乐项目或类似项目时，这将变得动态。同样，我们在这里加载的文件以获取音乐文件的振幅用于可视化，在完整集成中可能会被省略，而是选择动态生成振幅值：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This was the only method that previously existed in the QML context class.
    It''s used to detect whether the code runs on a mobile device with a touch screen:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前在 QML 上下文类中存在的唯一方法。它用于检测代码是否在带触摸屏的移动设备上运行：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We got a number of control methods that connect to the buttons in the UI to
    allow for control of the media player instance:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一些控制方法，它们连接到UI中的按钮，以便控制媒体播放器实例：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This slot method is used to detect when the media player has reached the end
    of the active track, so that the UI can be signaled that it should update to indicate
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个槽方法用于检测媒体播放器是否到达了活动音轨的末尾，以便UI可以发出信号，表明它应该更新以指示这一点：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These two slot methods are connected to the media player instance. The duration
    slot is required because the length (duration) of a newly loaded track will not
    be immediately available. Instead, it's an asynchronously updated property.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种槽方法与媒体播放器实例相关联。由于新加载的音轨的长度（持续时间）不会立即可用，因此需要持续时间槽。它是一个异步更新的属性。
- en: As a result, we have to wait until the media player has finished with this and
    emits the signal that it has completed this process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须等待媒体播放器完成这个过程并发出它已完成此过程的信号。
- en: Next, to allow us to update the time remaining on the current track, we also
    get constant updates on the current position from the media player so that we
    can update the UI with the new value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了允许我们更新当前音轨剩余时间，我们还从媒体播放器那里获取当前位置的持续更新，以便我们可以用新值更新UI。
- en: Both the duration and position properties are updated in the UI using the linkage
    method we saw in the description of the header file for this class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中使用我们之前在类头文件描述中看到的链接方法来更新持续时间属性和位置属性。
- en: 'Finally, we emit a `start()` signal, which is linked into a slot in the QML
    code that will start the visualization process, as we will see later on in the
    QML code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发出一个`start()`信号，该信号链接到QML代码中的槽，该槽将启动可视化过程，正如我们稍后将在QML代码中看到的：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The duration property is also used by the visualization code. Here, we allow
    it to be obtained directly. Similarly, we make the position property available
    as well with a direct call:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间属性也被可视化代码使用。在这里，我们允许它直接获取。同样，我们也通过直接调用使位置属性可用：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This method was ported from the JavaScript code in the original project, performing
    the same task of determining the audio level based on the amplitude data we read
    in previously from the file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是从原始项目中的JavaScript代码移植过来的，执行与之前从文件中读取的振幅数据相同的任务，以确定音频级别：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similarly, this method was also ported from the original project's JavaScript
    code, since we moved the code that relies on it into the C++ code. It takes in
    the millisecond count for the track duration or position and converts it into
    a string containing the minutes and seconds, matching the original value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，此方法也移植自原始项目的JavaScript代码，因为我们将其依赖的代码移到了C++代码中。它接受音轨持续时间或位置的毫秒计数，并将其转换为包含分钟和秒的字符串，与原始值匹配。
- en: QML
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML
- en: Moving on, we are done with the C++ side of things and can now look at the QML
    UI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们已经完成了C++侧的工作，现在可以查看QML UI。
- en: 'First, here is the main QML file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是主要的QML文件：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The QML file consists out of a hierarchy of elements. Here, we define the top
    element, giving it its dimensions and name:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: QML文件由元素层次结构组成。在这里，我们定义了顶层元素，给它指定了尺寸和名称：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A number of states for the UI are defined, along with the changes that should
    be triggered if the state should change to it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了UI的多个状态，以及如果状态应该更改为这些状态时应触发的更改：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are the connections that link the signals from the C++ side to a local
    handler. We target our custom class as the source of these signals, then define
    the handler for each signal we wish to handle by prefixing it and adding the code
    that should be executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是将C++侧的信号链接到本地处理程序的联系。我们将我们的自定义类作为这些信号的来源，然后定义我们希望处理的每个信号的处理器，通过在其前缀中添加代码来实现。
- en: 'Here, we see that the start signal is linked to a handler that triggers the
    function in the visualization module that starts that module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到启动信号连接到了一个处理程序，该处理程序触发可视化模块中的函数以启动该模块：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This `Image` element defines the background image, which we load from the resources
    that were added to the executable when the project was built:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Image`元素定义了背景图像，我们是从在项目构建时添加到可执行文件中的资源中加载的：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The 3D scene that will be filled with the visualizer''s content is defined:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了将被可视化内容填充的3D场景：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These two text elements are linked with the property in our custom C++ class,
    as we saw earlier. These values will be kept updated with the value in the C++
    class instance as it changes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，这两个文本元素与我们的自定义 C++ 类中的属性相链接。这些值将随着 C++ 类实例的变化而保持更新：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The rest of the source serves to set up the individual buttons for controlling
    the playback, with play, stop, and pause buttons, which get swapped over as needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码的其余部分用于设置控制播放的各个按钮，包括播放、停止和暂停按钮，根据需要交换：
- en: 'Next, we will look at the amplitude bar file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看振幅条文件：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A number of properties are defined before we dive into the animation state
    change handler:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究动画状态更改处理程序之前，定义了多个属性：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Every time the audio playback is stopped, paused, or started, the animation
    has to be updated to match this state change:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每次音频播放停止、暂停或开始时，动画都必须更新以匹配这种状态变化：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This defines the look of the amplitude bars, using Phong shading:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了振幅条的外观，使用 Phong 着色：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As the amplitude bars move across the screen, they change relative to the camera,
    so we need to keep calculating the new angle and display height.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着振幅条在屏幕上移动，它们相对于相机发生变化，因此我们需要不断计算新的角度和显示高度：
- en: 'In this section, we also replaced the original call to the audio level method
    with a call to the new method in our C++ class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还用我们 C++ 类中的新方法替换了原始的音频级别方法调用：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rest of the file contains a few more animation transforms.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 文件其余部分包含一些额外的动画转换：
- en: 'Finally, here is the visualization module:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是可视化模块：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This section got changed from interacting with the local media player instance
    to the new one in the C++ code. Beyond that, we left it unchanged. This is the
    main handler for when anything changes in the scene due to user interaction, or
    a track starting or ending:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分在 C++ 代码中从与本地媒体播放器实例的交互更改为新的实例。除此之外，我们保持不变。这是处理场景中由于用户交互或曲目开始或结束而发生变化的主要处理程序：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A number of property changes and transitions are defined for the track title
    object:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为曲目标题对象定义了多个属性更改和过渡：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This function is what starts the entire visualization sequence. It uses the
    track duration, as obtained via our C++ class instance, to determine the dimensions
    of the progress bar for the track playback animation before starting the visualization
    animation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数启动整个可视化序列。它使用通过我们的 C++ 类实例获得的曲目持续时间来确定曲目播放动画进度条的大小，然后再开始可视化动画：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A camera is defined for the 3D scene:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为 3D 场景定义了一个相机：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A renderer and light for the scene are created:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 场景渲染器和灯光被创建：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A mesh is created for the amplitude bars:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为振幅条创建了一个网格：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The number of bars, along with other properties, is defined:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了条的数量以及其他属性：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This plane contains the title object whenever there''s no track playing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有曲目播放时，此平面包含标题对象：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This plane contains the song title whenever a track is active:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当曲目处于活动状态时，此平面包含歌曲标题：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To transform the planes between playing and non-playing transitions, this transform
    is used:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在播放和非播放过渡之间转换平面，使用此转换：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A circle mesh that provides a reflection effect is added:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个提供反射效果的圆形网格：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, this mesh creates the progress bar, which moves from the left to the
    right to indicate playback progress.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个网格创建了进度条，它从左到右移动以指示播放进度：
- en: The entire project is compiled by running qmake followed by make, or by opening
    the project in Qt Creator and building it from there. When run, it will automatically
    start playing the included song and show the amplitude visualization, while being
    controllable via the buttons in the UI.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目通过运行 qmake 后跟 make，或者通过在 Qt Creator 中打开项目并从那里构建来编译。运行时，它将自动播放包含的歌曲并显示振幅可视化，同时可以通过
    UI 中的按钮进行控制：
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the myriad ways in which the Qt framework can
    be used to develop for embedded systems. We briefly looked at how it compares
    with other frameworks and how Qt is optimized for these embedded platforms, before
    working through an example of a QML-based GUI that could be added to the infotainment
    system we previously created.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Qt 框架为嵌入式系统开发的各种方法。我们简要地看了看它与其他框架的比较以及 Qt 如何针对这些嵌入式平台进行优化，然后通过一个基于
    QML 的 GUI 示例来展示，该 GUI 可以添加到我们之前创建的信息娱乐系统中：
- en: You should now be able to create basic Qt applications, both purely command
    line-based and with a GUI. You should also have a clear idea of which options
    Qt offers to develop GUIs with.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够创建基本的 Qt 应用程序，无论是纯命令行还是带有 GUI 的。你也应该对 Qt 提供的用于开发 GUI 的选项有一个清晰的认识。
- en: In the next chapter, we will be taking a look at the next evolution of embedded
    platforms, using **field-programmable gate arrays** (**FPGAs**) to add custom,
    hardware-based functionality to speed up embedded platforms.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨嵌入式平台的下一个发展阶段，使用**现场可编程门阵列**（**FPGA**）来添加自定义的、基于硬件的功能，以加快嵌入式平台的速度。
