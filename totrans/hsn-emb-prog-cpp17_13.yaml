- en: Developing Embedded Systems with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt (pronounced *cute*) is an advanced C++-based framework that covers a wide
    range of APIs, allowing you to implement networking, graphical user interfaces,
    parsing of data formats, the playing back and recording of audio, and much more.
    This chapter primarily covers the graphical aspect of Qt, and how to create advanced
    GUIs for embedded devices to provide an attractive and functional UI to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating advanced GUIs with Qt for embedded systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Qt's 3D designer to create an infotainment UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending an existing embedded system with a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of the right framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **framework** is essentially a collection of code aimed at easing the development
    of software for a specific application. It provides the developer with a range
    of classes—or the language equivalent—to allow you to implement the application
    logic without having to worry about interfacing with the underlying hardware,
    or using the OS's APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we used a number of frameworks to make our development
    efforts easier, from the No date Framework ([Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml),
    *Resource-Restricted Embedded Systems*) and CMSIS to Arduino for **microcontrollers**
    (**MCUs**), and from the low-level POCO framework for cross-platform development
    to the higher-level Qt framework.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these frameworks has a specific type of system that they are intended
    for. For No date, CMSIS, and Arduino, the target is MCUs, ranging from 8-bit AVR
    MCUs to 32-bit ARM MCUs. These target the bare-metal systems, without any intermediate
    **operating system** (**OS**) or similar. Above those in terms of complexity,
    we find **real-time OS frameworks** (**RTOS**), which include a full OS in the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as POCO and Qt target OSes in general, from desktop and server
    platforms to SoC platforms. Here they function primarily as an abstraction layer
    between the OS-specific APIs, while providing additional functionality alongside
    this abstraction. This allows you to quickly build up a full-featured application,
    without having to spend much time on each feature.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly important for networking functionality, where you do not
    want to write a TCP sockets-based server from scratch, but ideally just want to
    instantiate a ready-made class and use it. In the case of Qt, it also provides
    graphical user interface-related APIs to make the development of cross-platform
    GUIs easier. Other frameworks that also provide this kind of functionality include
    GTK+ and WxWidgets. In this chapter, however, we'll just be looking at developing
    with Qt.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml), *Example - Linux-Based
    Infotainment System*, we got a good look at how to develop with the Qt framework.
    There, we mostly ignored the **graphical user interface** (**GUI**) part, even
    though this is probably the most interesting part of Qt relative to other OS-based
    frameworks. Being able to use the same GUI across multiple OSes can be incredibly
    useful and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: This is mostly the case for desktop-based applications, where the GUI is a crucial
    part of the application, and thus not having to spend the time and trouble of
    porting it between OSes is a major time saver. For embedded platforms, this is
    also true, though here you have the option of integrating even deeper into the
    system than on a desktop system, as we will see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the various types of Qt applications that you can develop,
    starting with a simple **command-line interface** (**CLI**) application.
  prefs: []
  type: TYPE_NORMAL
- en: Qt for command-line use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though the graphical user interface is a big selling point of the Qt framework,
    it is also possible to use it to develop command-line-only applications. For this,
    we just use the `QCoreApplication` class to create an input and an event loop
    handler, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, our code is implemented in a class called `Core`. In the main function,
    we create a `QCoreApplication` instance, which receives the command-line parameters.
    We then instantiate an instance of our class.
  prefs: []
  type: TYPE_NORMAL
- en: We connect a signal from our class to the `QCoreApplication` instance, so that
    if we signal that we have finished, it will trigger a slot on the latter to clean
    up and terminate the application.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we call the method on our class to start its functionality and finally
    start the event loop by calling `exec()` on the `QCoreApplication` instance. At
    this point, we can use signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note here that it is also possible to use Qt4-style connection syntax, instead
    of the earlier Qt5-style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Functionally, this makes no difference, and using either is fine for most situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Every class in a Qt-based application that wants to make use of the signal-slot
    architecture of Qt is required to derive from the `QObject` class, and to include
    the `Q_OBJECT` macro within the class declaration. This is needed for Qt's `qmake
    preprocessor` tool to know which classes to process before the application code
    is compiled by the toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of note is the fact that we can let the constructor of any QObject-derived class
    know what the encapsulating parent class is, allowing said parent to own these
    child classes and invoke their destructor when it itself is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: GUI-based Qt applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Returning to the Qt-based example project from [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml),
    *Example - Linux-Based Infotainment System*, we can now compare its main function
    to the preceding command-line-only version to see what changes once we add a GUI
    to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The most obvious change here is that we use `QApplication` instead of `QCoreApplication`.
    The other big change is that we do not use a completely custom class, but one
    that derives from `QMainWindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `MainWindow` class indeed derives from `QMainWindow`,
    which also gives it its `show()` method. Of note is the `MainWindow` instance
    being declared in the UI namespace. This is connected to the auto-generated code
    that is created when we run the qmake tool on the UI file, as we will see in a
    moment. Next is the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first thing of note here is how we inflate the GUI from the UI description
    file. This file is usually created by visually laying out the GUI with the Qt
    Designer tool, which is part of the Qt Creator IDE. This UI file contains a description
    of each widget's properties, along with the layout applied to them, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to programmatically create these widgets and add them to
    layouts, of course. This gets quite tedious for larger layouts, however. Generally,
    you create a single UI file for the main window, and an additional one for each
    sub window and dialog. These can then be inflated into a window or dialog in a
    similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Menu actions in the GUI are connected to internal slots by specifying the specific
    signal on the menu action (`QAction` instance). We can see here that they are
    in the `ui` object, which is found in the auto-generated source code for the UI
    file, as we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Button widgets in the GUI are connected in a similar manner, though they of
    course emit a different signal on account of them being a different type of widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re free to do anything we would do in any other constructor, including
    setting defaults and creating instances of classes we will need later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One crucial thing to remember here is that this class runs on the UI thread,
    meaning that we should not do anything intensive in here. That''s why we move
    such class instances off to their own thread, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we delete the UI and all associated elements.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major target of the Qt framework next to desktop systems are **embedded systems**,
    specifically **Embedded Linux**, where there are a few different ways to use Q.
    The main point of embedded Qt is to optimize the software stock by allowing you
    to boot straight into a Qt-optimized environment, and by allowing for a variety
    of ways to render to the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt for Embedded Linux supports the following platform plugins for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plugin** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| EGLFS | Provides an interface to OpenGL ES or similar 3D rendering API. Usually,
    the default configuration for Embedded Linux. More details about EGL can be found
    at the following address: [https://www.khronos.org/egl](https://www.khronos.org/egl).
    |'
  prefs: []
  type: TYPE_TB
- en: '| LinuxFB | Writes directly to the framebuffer via Linux''s fbdev subsystem.
    Only software-rendered content is supported. As a result, on some setups the display
    performance is likely to be limited. |'
  prefs: []
  type: TYPE_TB
- en: '| DirectFB | Directly writes to the graphic card''s framebuffer using the DirectFB
    library. |'
  prefs: []
  type: TYPE_TB
- en: '| Wayland | Uses the Wayland windowing system. This allows for multiple concurrent
    windows, but is of course more demanding on the hardware. |'
  prefs: []
  type: TYPE_TB
- en: In addition to this, Qt for Embedded Linux comes with a variety of APIs for
    handling touch and pen input, and so on. To optimize the system for a Qt-based
    application, any unrelated services, processes, and libraries are generally removed,
    resulting in a system that boots within a matter of seconds into the embedded
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Custom GUIs with stylesheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard widget-based GUIs that desktop systems tend to use do not lend
    themselves that readily to customization. As a result, you are generally faced
    with having to either override the painting function in a `QWidget` instance and
    handle every single pixel of the widget drawing, or to use stylesheet-based customization.
  prefs: []
  type: TYPE_NORMAL
- en: Qt stylesheets allow you to tweak the look and feel of individual widgets, even
    dynamically. They are essentially written using **Cascading Style Sheet** (**CSS**)
    syntax as used with HTML pages. They allow you to change elements of a widget,
    such as the borders, rounding corners, or the thickness and color of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qt Modeling Language** (**QML**) is a user interface markup language. It
    is strongly based on JavaScript and even uses inline JavaScript. It can be used
    to create dynamic and completely custom user interfaces, and is usually used together
    with the Qt Quick module.'
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will take an in-depth look at how a dynamic GUI is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 3D designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Qt 5, the Qt 3D module was introduced, which streamlined access to the
    OpenGL rendering API. This new module was used as the foundation for the Qt 3D
    Designer editor and the accompanying runtime. It can be used to create highly
    dynamic GUIs, featuring a combination of 2D and 3D elements.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite similar to hand-crafted QML-based GUIs, but provides a more streamlined
    workflow, ease of adding animations, and previewing the project. It's similar
    to the Qt Designer Studio, which focuses more on 2D GUIs, but this one is not
    available for free, instead requiring you to purchase a license.
  prefs: []
  type: TYPE_NORMAL
- en: An example of adding a GUI to the infotainment system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will be using C++, Qt, and QML to create a graphical user
    interface that is capable of showing the current track that is playing, performing
    an audio visualization, indicating the playback progress, and allowing you to
    toggle different input modes using onscreen buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is based on the *Audio Visualizer* example from the Qt documentation.
    This can be found in the Qt installation folder (if examples got installed), as
    well as on the Qt site: [https://doc.qt.io/qt-5/qt3d-audio-visualizer-qml-example.html.](https://doc.qt.io/qt-5/qt3d-audio-visualizer-qml-example.html.)'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between this code and the official example is that the `QMediaPlayer`
    media player was moved into the C++ code, along with a number of other functions.
    Instead, a number of signals and slots between the QML UI and C++ backend are
    used in the new `QmlInterface` class for button presses, updating the UI, and
    interaction with the media player.
  prefs: []
  type: TYPE_NORMAL
- en: A GUI such as this could be wired into the existing infotainment project code
    to control its functionality, using the GUI in addition to the voice-driven interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI we''re putting together in this example looks like this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abcd27b7-3f26-455b-8fa1-3e70263869cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main source file appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our custom class is added to the QML viewer (`QQuickView`) as a context class.
    This serves as the proxy between the QML UI and our C++ code, as we will see in
    a moment. The viewer itself uses an OpenGL surface to render the UI on.
  prefs: []
  type: TYPE_NORMAL
- en: QmlInterface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The header of our custom class features a number of additions to make properties
    and methods visible to the QML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Q_PROPERTY` tag tells the qmake parser that this class contains a property
    (variable) that should be made visible to the QML code, with the parameters specifying
    the name of the variable, the methods used for reading and writing the variable
    (if desired), and finally the signal that is emitted whenever the property has
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows for an automatic update feature to be set up to keep this property
    synchronized between the C++ code and the QML side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `Q_INVOKABLE` tag ensures that these methods are made visible
    to the QML side and can be called from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The constructor got changed considerably from the original example project,
    with the media player instance being created here, along with its connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We load the same music file here as was used with the original project. When
    integrating the code into the infotainment project or a similar project, you would
    make this dynamic. Similarly, the file that we are also loading here to get the
    amplitude for the music file with the visualization would likely be omitted in
    a full integration, instead opting to generate the amplitude values dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This was the only method that previously existed in the QML context class.
    It''s used to detect whether the code runs on a mobile device with a touch screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We got a number of control methods that connect to the buttons in the UI to
    allow for control of the media player instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This slot method is used to detect when the media player has reached the end
    of the active track, so that the UI can be signaled that it should update to indicate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These two slot methods are connected to the media player instance. The duration
    slot is required because the length (duration) of a newly loaded track will not
    be immediately available. Instead, it's an asynchronously updated property.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we have to wait until the media player has finished with this and
    emits the signal that it has completed this process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to allow us to update the time remaining on the current track, we also
    get constant updates on the current position from the media player so that we
    can update the UI with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Both the duration and position properties are updated in the UI using the linkage
    method we saw in the description of the header file for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we emit a `start()` signal, which is linked into a slot in the QML
    code that will start the visualization process, as we will see later on in the
    QML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The duration property is also used by the visualization code. Here, we allow
    it to be obtained directly. Similarly, we make the position property available
    as well with a direct call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This method was ported from the JavaScript code in the original project, performing
    the same task of determining the audio level based on the amplitude data we read
    in previously from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, this method was also ported from the original project's JavaScript
    code, since we moved the code that relies on it into the C++ code. It takes in
    the millisecond count for the track duration or position and converts it into
    a string containing the minutes and seconds, matching the original value.
  prefs: []
  type: TYPE_NORMAL
- en: QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving on, we are done with the C++ side of things and can now look at the QML
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is the main QML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The QML file consists out of a hierarchy of elements. Here, we define the top
    element, giving it its dimensions and name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of states for the UI are defined, along with the changes that should
    be triggered if the state should change to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These are the connections that link the signals from the C++ side to a local
    handler. We target our custom class as the source of these signals, then define
    the handler for each signal we wish to handle by prefixing it and adding the code
    that should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that the start signal is linked to a handler that triggers the
    function in the visualization module that starts that module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Image` element defines the background image, which we load from the resources
    that were added to the executable when the project was built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The 3D scene that will be filled with the visualizer''s content is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These two text elements are linked with the property in our custom C++ class,
    as we saw earlier. These values will be kept updated with the value in the C++
    class instance as it changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the source serves to set up the individual buttons for controlling
    the playback, with play, stop, and pause buttons, which get swapped over as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at the amplitude bar file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of properties are defined before we dive into the animation state
    change handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the audio playback is stopped, paused, or started, the animation
    has to be updated to match this state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines the look of the amplitude bars, using Phong shading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As the amplitude bars move across the screen, they change relative to the camera,
    so we need to keep calculating the new angle and display height.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we also replaced the original call to the audio level method
    with a call to the new method in our C++ class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the file contains a few more animation transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the visualization module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This section got changed from interacting with the local media player instance
    to the new one in the C++ code. Beyond that, we left it unchanged. This is the
    main handler for when anything changes in the scene due to user interaction, or
    a track starting or ending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of property changes and transitions are defined for the track title
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is what starts the entire visualization sequence. It uses the
    track duration, as obtained via our C++ class instance, to determine the dimensions
    of the progress bar for the track playback animation before starting the visualization
    animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A camera is defined for the 3D scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A renderer and light for the scene are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A mesh is created for the amplitude bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of bars, along with other properties, is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This plane contains the title object whenever there''s no track playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This plane contains the song title whenever a track is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To transform the planes between playing and non-playing transitions, this transform
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A circle mesh that provides a reflection effect is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, this mesh creates the progress bar, which moves from the left to the
    right to indicate playback progress.
  prefs: []
  type: TYPE_NORMAL
- en: The entire project is compiled by running qmake followed by make, or by opening
    the project in Qt Creator and building it from there. When run, it will automatically
    start playing the included song and show the amplitude visualization, while being
    controllable via the buttons in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the myriad ways in which the Qt framework can
    be used to develop for embedded systems. We briefly looked at how it compares
    with other frameworks and how Qt is optimized for these embedded platforms, before
    working through an example of a QML-based GUI that could be added to the infotainment
    system we previously created.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to create basic Qt applications, both purely command
    line-based and with a GUI. You should also have a clear idea of which options
    Qt offers to develop GUIs with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a look at the next evolution of embedded
    platforms, using **field-programmable gate arrays** (**FPGAs**) to add custom,
    hardware-based functionality to speed up embedded platforms.
  prefs: []
  type: TYPE_NORMAL
