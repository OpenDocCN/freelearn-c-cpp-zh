- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Improving Resources Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进资源管理
- en: In this chapter, we are going to improve resource management to make it easier
    to deal with materials that might have a varying number of textures. This technique
    is usually referred to as bindless, even though it’s not entirely accurate. We
    are still going to bind a list of resources; however, we can access them by using
    an index rather than having to specify exactly which resources are going to be
    used during a particular draw.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进资源管理，使其更容易处理可能具有不同数量纹理的材料。这种技术通常被称为无绑定，尽管这并不完全准确。我们仍然会绑定一个资源列表；然而，我们可以通过使用索引来访问它们，而不是在特定绘制过程中必须指定确切要使用哪些资源。
- en: The second improvement we are going to make is automating the generation of
    pipeline layouts. Large projects have hundreds or thousands of shaders, compiled
    with many different variations depending on the combinations of materials used
    by a particular application. If developers had to manually update their pipeline
    layout definitions every time a change is made, very few applications would make
    it to market. The implementation presented in this chapter relies on the information
    provided by the SPIR-V binary format.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的第二个改进是自动生成管线布局。大型项目有成百上千个着色器，根据特定应用程序使用的材料组合编译出许多不同的变体。如果开发者每次更改都要手动更新他们的管线布局定义，那么很少会有应用程序能够上市。本章中提出的实现依赖于SPIR-V二进制格式提供的信息。
- en: Finally, we are going to add pipeline caching to our GPU device implementation.
    This solution improves the creation time of pipeline objects after the first run,
    and can significantly improve an application’s loading times.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向我们的GPU设备实现中添加管线缓存。此解决方案提高了首次运行后管线对象的创建时间，并且可以显著提高应用程序的加载时间。
- en: 'In summary, in this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主要主题：
- en: Unlocking and implementing bindless resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁并实现无绑定资源
- en: Automating pipeline layout generation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化管线布局生成
- en: Improving load times with a pipeline cache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管线缓存改进加载时间
- en: By the end of this chapter, you will understand how to enable and use bindless
    resources in Vulkan. You will also be able to parse SPIR-V binary data to automatically
    generate pipeline layouts. Finally, you will be able to speed up the loading time
    of your application by using pipeline caching.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何在Vulkan中启用和使用无绑定资源。你还将能够解析SPIR-V二进制数据来自动生成管线布局。最后，你将能够通过使用管线缓存来加快应用程序的加载时间。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter2](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter2).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter2](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter2).
- en: Unlocking and implementing bindless rendering
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁并实现无绑定渲染
- en: In the previous chapter, we had to manually bind the textures for each material.
    This also meant that if we wanted to support different types of materials requiring
    a different number of textures, we would have needed separate shaders and pipelines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们必须手动绑定每个材料的纹理。这也意味着，如果我们想支持需要不同数量纹理的不同类型的材料，我们就需要单独的着色器和管线。
- en: Vulkan provides a mechanism to bind an array of textures that can be used across
    multiple shaders. Each texture can then be accessed through an index. In the following
    sections, we are going to highlight the changes we have made to the GPU device
    implementation to enable this feature and describe how to use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan提供了一种机制，可以绑定一个可用于多个着色器的纹理数组。然后，每个纹理都可以通过索引访问。在以下章节中，我们将突出显示我们对GPU设备实现所做的更改，以启用此功能，并描述如何使用它。
- en: In the following sections, we will first check that the extensions required
    to enable bindless resources are available on a given GPU. Then we will show the
    changes required to the descriptor pool creation and descriptor set update to
    make use of bindless resources. The last step will be to update our shaders to
    use indices in our texture array for rendering.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们首先将检查启用无绑定资源所需的扩展是否在给定的GPU上可用。然后，我们将展示对描述符池创建和描述符集更新的更改，以利用无绑定资源。最后一步将是更新我们的着色器，以便在纹理数组中使用索引进行渲染。
- en: Checking for support
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查支持
- en: Most desktop GPUs, even if relatively old, should support the `VK_EXT_descriptor_indexing`
    extension, provided you have up-to-date drivers. It’s still good practice to verify
    that the extension is available and, for a production implementation, provide
    an alternative code path that uses the standard binding model if the extension
    is not available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数桌面GPU，即使相对较旧，只要您有最新的驱动程序，都应该支持`VK_EXT_descriptor_indexing`扩展。仍然是一个好习惯来验证扩展是否可用，并且在生产实现中，如果扩展不可用，提供使用标准绑定模型的替代代码路径。
- en: To verify that your device supports this extension, you can use the following
    code, or you can run the `vulkaninfo` application provided by the Vulkan SDK.
    See [*Chapter 1*](B18395_01.xhtml#_idTextAnchor016), *Introducing the Raptor Engine
    and Hydra*, for how to install the SDK.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的设备是否支持此扩展，您可以使用以下代码，或者您可以使用Vulkan SDK提供的`vulkaninfo`应用程序。参见[*第一章*](B18395_01.xhtml#_idTextAnchor016)，*介绍Raptor引擎和Hydra*，了解如何安装SDK。
- en: 'The first step then is to query the physical device to determine whether the
    GPU supports this extension. The following code section accomplishes this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是查询物理设备以确定GPU是否支持此扩展。以下代码段完成了这项任务：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have to populate the `VkPhysicalDeviceDescriptorIndexingFeatures` structure
    and chain it to the `VkPhysicalDeviceFeatures2` structure. The driver will then
    populate the `indexing_features` variable members when calling `vkGetPhysicalDeviceFeatures2`.
    To check that the descriptor indexing extension is supported, we verify that the
    `descriptorBindingPartiallyBound` and `runtimeDescriptorArray` values are `true`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须填充`VkPhysicalDeviceDescriptorIndexingFeatures`结构并将其链接到`VkPhysicalDeviceFeatures2`结构。驱动程序在调用`vkGetPhysicalDeviceFeatures2`时将填充`indexing_features`变量成员。为了验证描述符索引扩展是否受支持，我们检查`descriptorBindingPartiallyBound`和`runtimeDescriptorArray`的值是否为`true`。
- en: 'Once we have confirmed that the extension is supported, we can enable it when
    creating the device:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认扩展受支持，我们可以在创建设备时启用它：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to chain the `indexing_features` variable to the `physical_features2`
    variable used when creating our device. The rest of the code is unchanged from
    [*Chapter 1*](B18395_01.xhtml#_idTextAnchor016), *Introducing the Raptor Engine*
    *and Hydra*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`indexing_features`变量链接到创建设备时使用的`physical_features2`变量。其余的代码与[*第一章*](B18395_01.xhtml#_idTextAnchor016)中的代码相同，*介绍Raptor引擎*和*Hydra*。
- en: Creating the descriptor pool
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建描述符池
- en: 'The next step is to create a descriptor pool from which we can allocate descriptor
    sets that support updating the content of a texture after it is bound:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从中可以分配支持在绑定后更新纹理内容的描述符集的描述符池：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main difference with the code from [*Chapter 1*](B18395_01.xhtml#_idTextAnchor016),
    *Introducing the Raptor Engine and Hydra*, is the addition of the `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT`
    flag. This flag is needed to allow the creation of descriptor sets that can be
    updated after they have been bound.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与[*第一章*](B18395_01.xhtml#_idTextAnchor016)中的代码相比，主要区别是添加了`VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT`标志。此标志是允许创建在绑定后可以更新的描述符集所必需的。
- en: 'Next, we have to define the descriptor set layout bindings:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义描述符集布局绑定：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that `descriptorCount` no longer has a value of `1` but has to accommodate
    the maximum number of textures we can use. We can now use this data to create
    a descriptor set layout:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`descriptorCount`不再具有`1`的值，而必须容纳我们可以使用的最大纹理数量。现在我们可以使用这些数据来创建描述符集布局：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code is very similar to the version seen in the previous chapter; however,
    we have added the `bindless_flags` values to enable partial updates to the descriptor
    set. We also have to chain a `VkDescriptorSetLayoutBindingFlagsCreateInfoEXT`
    structure to the `layout_info` variable. Finally, we can create the descriptor
    set we are going to use for the lifetime of the application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一章中看到的版本非常相似；然而，我们添加了`bindless_flags`值以启用描述符集的部分更新。我们还需要将`VkDescriptorSetLayoutBindingFlagsCreateInfoEXT`结构链接到`layout_info`变量。最后，我们可以创建将在应用程序生命周期内使用的描述符集：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We simply populate the `VkDescriptorSetAllocateInfo` structure with the values
    we have defined so far and call `vkAllocateDescriptorSets`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需用我们之前定义的值填充`VkDescriptorSetAllocateInfo`结构并调用`vkAllocateDescriptorSets`。
- en: Updating the descriptor set
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新描述符集
- en: 'We have done most of the heavy lifting at this point. When we call `GpuDevice::create_texture`,
    the newly created resource gets added to the `texture_to_update_bindless` array:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了大部分繁重的工作。当我们调用 `GpuDevice::create_texture` 时，新创建的资源会被添加到 `texture_to_update_bindless`
    数组中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s also possible to associate a specific sampler to a given texture. For
    instance, when we load a texture for a given material, we add the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将特定的采样器关联到给定的纹理上。例如，当我们为某个材质加载纹理时，我们添加以下代码：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This links the diffuse texture with its sampler. This information will be used
    in the next code section to determine whether we use a default sampler or the
    one we have just assigned to the texture.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将散布的纹理与其采样器关联起来。这个信息将在下一节代码中用来确定我们是否使用默认采样器或刚刚分配给纹理的采样器。
- en: 'Before the next frame is processed, we update the descriptor set we have created
    in the previous section with any new textures that have been uploaded:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理下一帧之前，我们使用上一节创建的描述符集更新任何已上传的新纹理：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code is quite similar to the previous version. We have highlighted
    the main differences: the sampler selection, as we mentioned in the previous paragraph,
    and the use of a dummy texture if a slot is empty. We still have to assign a texture
    to each slot, hence the use of a dummy texture if one is not specified. This is
    also useful for spotting any missing textures in your scene.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与上一个版本非常相似。我们已突出显示主要差异：采样器选择，正如我们上段所述，以及如果槽位为空时使用虚拟纹理。我们仍然需要为每个槽位分配一个纹理，因此如果未指定，则使用虚拟纹理。这也有助于在场景中查找任何缺失的纹理。
- en: If you prefer to have a tightly packed array of textures, another option is
    to enable the `VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT` flag and
    chain a `VkDescriptorSetVariableDescriptorCountAllocateInfoEXT` structure when
    creating the descriptor set. We already have some preliminary code to enable this
    feature, and we encourage you to complete the implementation!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢紧密打包的纹理数组，另一个选项是启用 `VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT`
    标志，并在创建描述符集时链式连接一个 `VkDescriptorSetVariableDescriptorCountAllocateInfoEXT` 结构。我们已经有了一些启用此功能的初步代码，并鼓励你完成实现！
- en: Update to shader code
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新着色器代码
- en: The final piece of the puzzle to use bindless rendering is in the shader code,
    as it needs to be written in a different way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定无关渲染的最后一部分是在着色器代码中，因为它需要以不同的方式编写。
- en: The steps are similar for all shaders making use of bindless resources, and
    it would be beneficial to have them defined in a common header. Unfortunately,
    this is not fully supported by the **OpenGL Shading Language**, or **GLSL**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有使用绑定无关资源的着色器，步骤都是相似的，并且将它们定义在公共头文件中将是有益的。不幸的是，这并不完全由 **OpenGL着色语言** 或 **GLSL**
    支持。
- en: We recommend automating this step as it can be easily added when compiling the
    shader in the engine code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议自动化这一步骤，因为它可以在编译引擎代码中的着色器时轻松添加。
- en: 'The first thing to do is to enable the nonuniform qualifier in the GLSL code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在GLSL代码中启用非均匀限定符：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will enable the extension in the current shader, not globally; thus, it
    must be written in every shader.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前着色器中启用扩展，而不是全局；因此，它必须在每个着色器中编写。
- en: 'The following code is the declaration of the proper bindless textures, with
    a catch:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是正确绑定无关纹理的声明，但有一个限制：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a known trick to alias the texture declarations to the same binding
    point. This allows us to have just one global bindless texture array, but all
    kinds of textures (one-dimensional, two-dimensional, three-dimensional, and their
    array counterparts) are supported in one go!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个已知的技巧，可以将纹理声明别名到相同的绑定点。这允许我们拥有一个全局的绑定无关纹理数组，但一次支持所有类型的纹理（一维、二维、三维及其数组对应物）！
- en: This simplifies the usage of bindless textures across the engine and the shaders.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了在引擎和着色器中绑定无关纹理的使用。
- en: 'Finally, to read the texture, the code in the shader has to be modified as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了读取纹理，着色器中的代码需要按以下方式修改：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s go in the following order:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下顺序进行：
- en: First of all, we need the integer index coming from a constant. In this case,
    `texture_index` will contain the same number as the texture position in the bindless
    array.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要来自常量的整数索引。在这种情况下，`texture_index` 将包含与绑定无关数组中纹理位置相同的数字。
- en: Second, and this is the crucial change, we need to wrap the index with the `nonuniformEXT`
    qualifier ([https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_nonuniform_qualifier.txt](https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_nonuniform_qualifier.txt));
    this will basically synchronize the programs between the different executions
    to properly read the texture index, in case the index is different across different
    threads of the same shader invocation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二点，这是一个关键的变化，我们需要用`nonuniformEXT`限定符（[https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_nonuniform_qualifier.txt](https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_nonuniform_qualifier.txt)）包装索引；这基本上会在不同的执行之间同步程序，以确保正确读取纹理索引，以防索引在不同线程的同一着色器调用中不同。
- en: This might sound complicated at first but think about it as a multithreading
    issue that needs synchronization to make sure the proper texture index is read
    in each thread and, as a result, the correct texture is used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始听起来很复杂，但把它看作是一个需要同步的多线程问题，以确保每个线程都能正确读取适当的纹理索引，从而使用正确的纹理。
- en: Lastly, using the synchronized index we read from the `global_textures` array,
    we finally have the texture sample we wanted!
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用我们从`global_textures`数组中读取的同步索引，我们终于得到了我们想要的纹理样本！
- en: We have now added bindless textures support to the Raptor Engine! We started
    by checking whether the GPU supports this feature. Then we detailed the changes
    we made to the creation of the descriptor pool and descriptor set.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将无绑定纹理支持添加到Raptor引擎中！我们首先检查GPU是否支持此功能。然后我们详细说明了我们对描述符池和描述符集创建所做的更改。
- en: Finally, we have shown how the descriptor set is updated as new textures are
    uploaded to the GPU and the necessary shader modifications to make use of bindless
    textures. All the rendering from now on will use this feature; thus, this concept
    will become familiar.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了如何随着新纹理上传到GPU，更新描述符集，以及必要的着色器修改以使用无绑定纹理。从现在开始的所有渲染都将使用这个功能；因此，这个概念将变得熟悉。
- en: Next, we are going to improve our engine capabilities by adding automatic pipeline
    generation by parsing shaders’ binary data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过解析着色器的二进制数据来添加自动管线生成，以提升我们的引擎功能。
- en: Automating pipeline layout generation
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化管线布局生成
- en: In this section, we are going to take advantage of the data provided by the
    SPIR-V binary format to extract the information needed to create a pipeline layout.
    SPIR-V is the **intermediate representation** (**IR**) that shader sources are
    compiled to before being passed to the GPU.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用SPIR-V二进制格式提供的数据来提取创建管线布局所需的信息。SPIR-V是着色器源代码在传递给GPU之前编译成的**中间表示**（**IR**）。
- en: Compared to standard GLSL shader sources, which are plain text, SPIR-V is a
    binary format. This means it’s a more compact format to use when distributing
    an application. More importantly, developers don’t have to worry about their shaders
    getting compiled into a different set of high-level instructions depending on
    the GPU and driver their code is running on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的GLSL着色器源代码（纯文本）相比，SPIR-V是一种二进制格式。这意味着它是一个在分发应用程序时更紧凑的格式。更重要的是，开发者不必担心他们的着色器根据其代码运行的GPU和驱动程序被编译成不同的一组高级指令。
- en: However, a SPIR-V binary does not contain the final instructions that will be
    executed by the GPU. Every GPU will take a SPIR-V blob and do a final compilation
    into GPU instructions. This step is still required because different GPUs and
    driver versions can produce different assemblies for the same SPIR-V binary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SPIR-V二进制文件不包含GPU将要执行的最终指令。每个GPU都会将SPIR-V数据块进行最终编译成GPU指令。这一步仍然是必需的，因为不同的GPU和驱动程序版本可以为相同的SPIR-V二进制文件生成不同的汇编代码。
- en: Having SPIR-V as an intermediate step is still a great improvement. Shader code
    validation and parsing are done offline, and developers can compile their shaders
    together with their application code. This allows us to spot any syntax mistakes
    before trying to run the shader code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将SPIR-V作为中间步骤仍然是一个巨大的改进。着色器代码的验证和解析是在离线完成的，开发者可以将他们的着色器与他们的应用程序代码一起编译。这允许我们在尝试运行着色器代码之前发现任何语法错误。
- en: Another benefit of having an intermediate representation is being able to compile
    shaders written in different languages to SPIR-V so that they can be used with
    Vulkan. It’s possible, for instance, to compile a shader written in HLSL into
    SPIR-V and reuse it in a Vulkan renderer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有中间表示形式的另一个好处是能够将不同语言编写的着色器编译为SPIR-V，以便它们可以与Vulkan一起使用。例如，可以将用HLSL编写的着色器编译为SPIR-V，并在Vulkan渲染器中重用它。
- en: Before this option was available, developers either had to port the code manually
    or had to rely on tools that rewrote the shader from one language to another.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此选项可用之前，开发者要么必须手动移植代码，要么必须依赖将着色器从一种语言重写到另一种语言的工具。
- en: By now, you should be convinced of the advantages the introduction of SPIR-V
    has brought to developers and the Vulkan API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经相信SPIR-V的引入为开发者和Vulkan API带来了优势。
- en: In the following sections, we are going to use one of our shaders to show you
    how to compile it to SPIR-V and explain how to use the information in the binary
    data to automatically generate a pipeline layout.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用我们的一个着色器来向您展示如何将其编译为SPIR-V，并解释如何使用二进制数据中的信息自动生成管线布局。
- en: Compiling GLSL to SPIR-V
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将GLSL编译为SPIR-V
- en: We are going to use the vertex shader code that we developed in [*Chapter 1*](B18395_01.xhtml#_idTextAnchor016),
    *Introducing the Raptor Engine and Hydra*. Previously, we stored the shader code
    string in the `main.cpp` file and we didn’t compile it to SPIR-V before passing
    it to the Vulkan API to create a pipeline.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[*第1章*](B18395_01.xhtml#_idTextAnchor016)，*介绍Raptor引擎和Hydra*中开发的顶点着色器代码。之前，我们将着色器代码字符串存储在`main.cpp`文件中，并且在将其传递给Vulkan
    API以创建管线之前，我们没有将其编译为SPIR-V。
- en: 'Starting from this chapter, we are storing all shader code in the `shaders`
    folder of each chapter. For [*Chapter 2*](B18395_02.xhtml#_idTextAnchor030), *Improving
    Resources Management*, you will find two files: `main.vert` for the vertex shader
    and `main.frag` for the fragment shader. Here is the content of `main.vert`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将把所有着色器代码存储在每个章节的`shaders`文件夹中。对于[*第2章*](B18395_02.xhtml#_idTextAnchor030)，*改进资源管理*，您将找到两个文件：`main.vert`用于顶点着色器，`main.frag`用于片段着色器。以下是`main.vert`的内容：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is quite standard for a vertex shader. We have four streams of data
    for position, tangent, normal, and texture coordinates. We have also defined a
    `LocalConstants` uniform buffer that stores the data common for all vertices.
    Finally, we have defined the `out` variables that are going to be passed to the
    fragment shader.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对于一个顶点着色器来说相当标准。我们有四个数据流，用于位置、切线、法线和纹理坐标。我们还定义了一个`LocalConstants`统一缓冲区，用于存储所有顶点的公共数据。最后，我们定义了将传递给片段着色器的`out`变量。
- en: The Vulkan SDK provides the tools to compile GLSL to SPIR-V and to disassemble
    the generated SPIR-V into human-readable form. This can be useful to debug a shader
    that is not behaving as expected.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan SDK提供了将GLSL编译为SPIR-V以及将生成的SPIR-V反汇编成人类可读形式的工具。这可以用于调试表现不佳的着色器。
- en: 'To compile our vertex shader, we run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译我们的顶点着色器，我们运行以下命令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will produce a `main.vert.spv` file that contains the binary data. To
    view the contents of this file in a human-readable format, we run the following
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个包含二进制数据的`main.vert.spv`文件。要查看此文件的内容以人类可读格式，我们运行以下命令：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will print the disassembled SPIR-V on the Terminal. We are now
    going to examine the relevant sections of the output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在终端上打印出反汇编的SPIR-V。我们现在将检查输出的相关部分。
- en: Understanding the SPIR-V output
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SPIR-V输出
- en: 'Starting from the top of the output, the following is the first set of information
    we are provided with:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的顶部开始，以下是我们提供的第一组信息：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This preamble defines the version of GLSL that was used to write the shader.
    The `OpEntryPoint` directive references the main function and lists the inputs
    and outputs for the shader. The convention is for variables to be prefixed by
    `%`, and it’s possible to forward declare a variable that is defined later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前缀定义了编写着色器所使用的GLSL版本。`OpEntryPoint`指令引用了主函数，并列出了着色器的输入和输出。惯例是变量以`%`为前缀，并且可以提前声明稍后定义的变量。
- en: 'The next section defines the output variables that are available in this shader:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分定义了在此着色器中可用的输出变量：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These are variables that are automatically injected by the compiler and are
    defined by the GLSL specification. We can see we have a `gl_PerVertex` structure,
    which in turn has four members: `gl_Position`, `gl_PointSize`, `gl_ClipDistance,`
    and `gl_CullDistance`. There is also an unnamed variable defined as `%_`. We’re
    going to discover soon what it refers to.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是由编译器自动注入的变量，由 GLSL 规范定义。我们可以看到一个 `gl_PerVertex` 结构体，它反过来有四个成员：`gl_Position`，`gl_PointSize`，`gl_ClipDistance`
    和 `gl_CullDistance`。还有一个未命名的变量定义为 `%_`。我们很快就会发现它指的是什么。
- en: 'We now move on to the structures we have defined:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续到我们定义的结构体：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we have the entries for our `LocalConstants` uniform buffer, its members,
    and their position within the struct. We see again an unnamed `%__0` variable.
    We’ll get to it shortly. SPIR-V allows you to define member decorations to provide
    additional information that is useful to determine the data layout and location
    within the struct:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的 `LocalConstants` 统一缓冲区的条目，其成员以及它们在结构体中的位置。我们再次看到了一个未命名的 `%__0` 变量。我们很快就会了解它。SPIR-V
    允许你定义成员装饰来提供有助于确定数据布局和结构体内位置的信息：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From these entries, we can start to have some insights as to the type of each
    member of the struct. For instance, we can identify the first three entries as
    being matrices. The last one only has an offset.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些条目中，我们可以开始对结构体中每个成员的类型有所了解。例如，我们可以识别前三个条目为矩阵。最后一个条目只有一个偏移量。
- en: The offset value is the most relevant value for our purposes as it allows us
    to know where exactly each member starts. This is crucial when transferring data
    from the CPU to the GPU, as the alignment rules for each member could be different.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，偏移量值是最相关的值，因为它允许我们知道每个成员的确切起始位置。当从 CPU 向 GPU 转移数据时，这一点至关重要，因为每个成员的对齐规则可能不同。
- en: 'The next two lines define the descriptor set and binding for our struct:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行定义了我们的结构体的描述符集和绑定：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, these decorations refer to the unnamed `%__0` variable. We
    have now reached the section where the variable types are defined:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些装饰项引用了未命名的 `%__0` 变量。我们现在已经到达了定义变量类型的部分：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For each variable, we have its type and, depending on the type, additional information
    that is relevant to it. For instance, the `%float` variable is of type 32-bit
    `float`; the `%v4float` variable is of type `vector`, and it contains 4 `%``float`
    values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个变量，我们都有其类型，并且根据类型，还有与之相关的附加信息。例如，`%float` 变量是 32 位 `float` 类型；`%v4float`
    变量是 `vector` 类型，并且包含 4 个 `%float` 值。
- en: This corresponds to `vec4` in GLSL. We then have a constant definition for an
    unsigned value of `1` and a fixed-sized array of the `float` type and length of
    `1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于 GLSL 中的 `vec4`。然后我们有一个无符号值 `1` 的常量定义和一个长度为 `1` 的固定大小的 `float` 类型的数组。
- en: The definition of the `%gl_PerVertex` variable follows. It is of the `struct`
    type and, as we have seen previously, it has four members. Their types are `vec4`
    for `gl_Position`, `float` for `gl_PointSize`, and `float[1]` for `gl_ClipDistance`
    and `gl_CullDistance`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`%gl_PerVertex` 变量的定义如下。它是 `struct` 类型，并且，正如我们之前看到的，它有四个成员。它们的类型是 `vec4` 用于
    `gl_Position`，`float` 用于 `gl_PointSize`，以及 `float[1]` 用于 `gl_ClipDistance` 和 `gl_CullDistance`。'
- en: 'The SPIR-V specs require that each variable that can be read or written to
    is referred to by a pointer. And that’s exactly what we see with `%_ptr_Output_gl_PerVertex`:
    it’s a pointer to the `gl_PerVertex` struct. Finally, we can see the type for
    the unnamed `%_` variable is a pointer to the `gl_PerVertex` struct.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SPIR-V 规范要求每个可读或可写的变量都通过指针来引用。这正是我们看到的 `%_ptr_Output_gl_PerVertex`：它是指向 `gl_PerVertex`
    结构体的指针。最后，我们可以看到未命名的 `%_` 变量的类型是指向 `gl_PerVertex` 结构体的指针。
- en: 'Finally, we have the type definitions for our own uniform data:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们自己的统一数据的类型定义：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As before, we can see that `%LocalConstants` is a struct with five members,
    three of the `mat4` type and two of the `vec4` type. We then have the type definition
    of the pointer to our uniform struct and finally, the `%__0` variable of this
    type. Notice that this variable has the `Uniform` attribute. This means it is
    read-only and we will make use of this information later to determine the type
    of descriptor to add to the pipeline layout.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以看到 `%LocalConstants` 是一个具有五个成员的结构体，其中三个是 `mat4` 类型，两个是 `vec4` 类型。然后我们有我们统一结构体的指针类型定义，最后是此类型的
    `%__0` 变量。请注意，此变量具有 `Uniform` 属性。这意味着它是只读的，我们将在以后利用这个信息来确定要添加到管道布局中的描述符类型。
- en: The rest of the disassembly contains the input and output variable definitions.
    Their definition follows the same structure as the variables we have seen so far,
    so we are not going to analyze them all here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的其余部分包含输入和输出变量定义。它们的定义结构与迄今为止我们所看到的变量相同，因此我们在这里不会分析它们。
- en: The disassembly also contains the instructions for the body of the shader. While
    it is interesting to see how the GLSL code is translated into SPIR-V instructions,
    this detail is not relevant to the pipeline creation, and we are not going to
    cover it here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解析还包含着着色器主体的指令。虽然看到 GLSL 代码如何被转换成 SPIR-V 指令很有趣，但这与管道创建无关，我们在这里不会涉及这个细节。
- en: Next, we are going to show how we can leverage all of this data to automate
    pipeline creation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何利用所有这些数据来自动化管道创建。
- en: From SPIR-V to pipeline layout
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 SPIR-V 到管道布局
- en: Khronos already provides functionality to parse SPIR-V data to create a pipeline
    layout. You can find the implementation at [https://github.com/KhronosGroup/SPIRV-Reflect](https://github.com/KhronosGroup/SPIRV-Reflect).
    For this book, we decided to write a simplified version of the parser that we
    believe is easier to follow as we are interested only in a small subset of entries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos 已经提供了解析 SPIR-V 数据以创建管道布局的功能。您可以在 [https://github.com/KhronosGroup/SPIRV-Reflect](https://github.com/KhronosGroup/SPIRV-Reflect)
    找到其实施。对于这本书，我们决定编写一个简化的解析器版本，我们认为它更容易跟随，因为我们只对一小部分条目感兴趣。
- en: 'You can find the implementation in `source\chapter2\graphics\spirv_parser.cpp`.
    Let’s see how to use this API and how it works under the hood:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `source\chapter2\graphics\spirv_parser.cpp` 中找到实现。让我们看看如何使用这个 API 以及它在底层是如何工作的：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we assume that the binary data for the vertex and fragment shader has
    already been read into the `spv_vert_data` and `spv_frag_data` variables. We have
    to define an empty `spirv::ParseResult` structure that will contain the result
    of the parsing. Its definition is quite simple:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设顶点和片段着色器的二进制数据已经读取到 `spv_vert_data` 和 `spv_frag_data` 变量中。我们必须定义一个空的
    `spirv::ParseResult` 结构，它将包含解析的结果。其定义相当简单：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It contains the number of sets that we identified from the binary data and the
    list of entries for each set.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了我们从二进制数据中识别出的集合数量以及每个集合的条目列表。
- en: 'The first step of the parsing is to make sure that we are reading valid SPIR-V
    data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的第一步是确保我们正在读取有效的 SPIR-V 数据：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We first compute the number of 32-bit words that are included in the binary.
    Then we verify that the first four bytes match the magic number that identifies
    a SPIR-V binary. Finally, we retrieve the number of IDs that are defined in the
    binary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算二进制中包含的 32 位单词数量。然后我们验证前四个字节是否匹配标识 SPIR-V 二进制的魔数。最后，我们检索二进制中定义的 ID 数量。
- en: 'Next, we loop over all the words in the binary to retrieve the information
    we need. Each ID definition starts with the `Op` type and the number of words
    that it is composed of:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历二进制中的所有单词以检索所需的信息。每个 ID 定义都以 `Op` 类型及其组成的单词数量开始：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Op` type is stored in the bottom 16 bits of the word, and the word count
    is in the top 16 bits. Next, we parse the data for the `Op` types we are interested
    in. We are not going to cover all `Op` types in this section, as the structure
    is the same for all types. We suggest you refer to the SPIR-V specification (linked
    in the *Further reading* section) for more details on each `Op` type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Op` 类型存储在单词的最低 16 位中，单词计数在最高 16 位中。接下来，我们解析我们感兴趣的 `Op` 类型的数据。在本节中，我们不会涵盖所有
    `Op` 类型，因为所有类型的结构都是相同的。我们建议您参考 SPIR-V 规范（在 *进一步阅读* 部分链接），以获取每个 `Op` 类型的更多详细信息。'
- en: 'We start with the type of shader we are currently parsing:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从当前正在解析的着色器类型开始：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We extract the execution model, translate it into a `VkShaderStageFlags` value,
    and store it in the `stage` variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取执行模型，将其转换为 `VkShaderStageFlags` 值，并将其存储在 `stage` 变量中。
- en: 'Next, we parse the descriptor set index and binding:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们解析描述符集索引和绑定：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we retrieve the index of the ID. As we mentioned previously, variables
    can be forward declared, and we might have to update the values for the same ID
    multiple times. Next, we retrieve the value of the decoration. We are only interested
    in the descriptor set index (`SpvDecorationDescriptorSet`) and binding (`SpvDecorationBinding`)
    and we store their values in the entry for this ID.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索ID的索引。如前所述，变量可以是前向声明的，我们可能需要多次更新相同ID的值。接下来，我们检索装饰的值。我们只对描述符集索引（`SpvDecorationDescriptorSet`）和绑定（`SpvDecorationBinding`）感兴趣，并将它们的值存储在这个ID的条目中。
- en: 'We follow with an example of a variable type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着用一个变量类型的例子来说明：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we saw in the disassembly, a vector is defined by its entry type and count.
    We store them in the `type_index` and `count` members of the ID struct. Here,
    we also see how an ID can refer to another one if needed. The `type_index` member
    stores the index to another entry in the `ids` array and can be used later to
    retrieve additional type information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在反汇编中看到的，一个向量由其条目类型和计数定义。我们将其存储在ID结构体的`type_index`和`count`成员中。在这里，我们还可以看到如果需要，ID可以引用另一个ID。`type_index`成员存储对`ids`数组中另一个条目的索引，并且可以在以后用于检索额外的类型信息。
- en: 'Next, we have a sampler definition:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个样本定义：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We only need to store the `Op` type for this entry. Finally, we have the entry
    for a variable type:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要存储这个条目的`Op`类型。最后，我们有变量类型的条目：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The relevant information for this entry is `type_index`, which will always refer
    to an entry of `pointer` type and the storage class. The storage class tells us
    which entries are variables that we are interested in and which ones we can skip.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目的相关信息是`type_index`，它将始终引用一个`pointer`类型的条目和存储类。存储类告诉我们哪些是我们感兴趣的变量条目，哪些可以跳过。
- en: 'And that is exactly what the next part of the code is doing. Once we finish
    parsing all IDs, we loop over each ID entry and identify the ones we are interested
    in. We first identify all variables:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是代码的下一部分所做的事情。一旦我们解析完所有ID，我们就遍历每个ID条目并识别我们感兴趣的条目。我们首先识别所有变量：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we use the variable storage class to determine whether it is a uniform
    variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用变量存储类来确定它是否是一个统一变量：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are only interested in the `Uniform` and `UniformConstant` variables. We
    then retrieve the `uniform` type. Remember, there is a double indirection to retrieve
    the actual type of a variable: first, we get the `pointer` type, and from the
    `pointer` type, we get to the real type of the variable. We have highlighted the
    code that does this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对`Uniform`和`UniformConstant`变量感兴趣。然后我们检索`uniform`类型。记住，检索变量实际类型存在双重间接引用：首先，我们获取`pointer`类型，然后从`pointer`类型获取变量的实际类型。我们已突出显示执行此操作的代码：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After retrieving the type, we get the `DescriptorSetLayoutCreation` entry for
    the set this variable is part of. We then create a new `binding` entry and store
    the `binding` value. We always assume a count of `1` for each resource.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索类型后，我们获取这个变量所属集合的`DescriptorSetLayoutCreation`条目。然后我们创建一个新的`binding`条目并存储`binding`值。我们总是假设每个资源有一个`1`的计数。
- en: 'In this last step, we determine the resource type for this binding and add
    its entry to the set layout:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后步骤中，我们确定这个绑定的资源类型，并将其条目添加到集合布局中：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the `Op` type to determine the type of resource we have found. So far,
    we are only interested in `Struct` for uniform buffers and `SampledImage` for
    textures. We are going to add support for more types when needed for the remainder
    of the book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Op`类型来确定我们找到的资源类型。到目前为止，我们只对统一缓冲区的`Struct`和纹理的`SampledImage`感兴趣。在本书的剩余部分，如果需要，我们将添加对更多类型的支持。
- en: While it’s possible to distinguish between uniform buffers and storage buffers,
    the binary data cannot determine whether a buffer is dynamic or not. In our implementation,
    the application code needs to specify this detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在统一缓冲区和存储缓冲区之间进行区分，但二进制数据无法确定缓冲区是动态的还是静态的。在我们的实现中，应用程序代码需要指定这个细节。
- en: An alternative would be to use a naming convention (prefixing dynamic buffers
    with `dyn_`, for instance) so that dynamic buffers can be automatically identified.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用命名约定（例如，在动态缓冲区前加上`dyn_`），以便可以自动识别动态缓冲区。
- en: This concludes our introduction to the SPIR-V binary format. It might take a
    couple of readings to fully understand how it works, but don’t worry, it certainly
    took us a few iterations to fully understand it!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对SPIR-V二进制格式的介绍。可能需要阅读几遍才能完全理解它是如何工作的，但不用担心，我们确实花了一些迭代时间才能完全理解它！
- en: Knowing how to parse SPIR-V data is an important tool to automate other aspects
    of graphics development. It can be used, for instance, to automate the generation
    of C++ headers to keep CPU and GPU structs in sync. We encourage you to expand
    our implementation to add support for the features you might need!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何解析SPIR-V数据是自动化图形开发其他方面的重要工具。例如，它可以用来自动化生成C++头文件，以保持CPU和GPU结构同步。我们鼓励你扩展我们的实现，以添加你可能需要的功能支持！
- en: In this section, we have explained how to compile a shader source into SPIR-V.
    We have shown how the SPIR-V binary format is organized and how to parse this
    data to help us automatically create a pipeline layout.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了如何将着色器源编译成SPIR-V。我们展示了SPIR-V二进制格式的组织方式以及如何解析这些数据以帮助我们自动创建管道布局。
- en: In the next and final section of this chapter, we are going to add pipeline
    caching to our GPU device implementation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节和最后一节中，我们将向我们的GPU设备实现中添加管道缓存。
- en: Improving load times with a pipeline cache
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道缓存提高加载时间
- en: Each time we create a graphics pipeline and, to a lesser extent, a compute pipeline,
    the driver has to analyze and compile the shaders we have provided. It also has
    to inspect the state we have defined in the creation structure and translate it
    into instructions to program the different units of the GPU. This process is quite
    expensive, and it’s one of the reasons why, in Vulkan we have to define most of
    the pipeline state upfront.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个图形管道，以及在较小程度上创建一个计算管道时，驱动程序都必须分析并编译我们提供的着色器。它还必须检查我们在创建结构中定义的状态，并将其转换为编程GPU不同单元的指令。这个过程相当昂贵，这也是为什么在Vulkan中我们必须提前定义大部分管道状态的原因之一。
- en: In this section, we are going to add pipeline caching to our GPU device implementation
    to improve loading times. If your application has to create thousands of pipelines,
    it can incur a significant startup time or, for a game, long loading times between
    levels.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的GPU设备实现中添加管道缓存以提高加载时间。如果你的应用程序需要创建成千上万的管道，它可能会产生显著的启动时间，或者对于游戏来说，在关卡之间的加载时间可能会很长。
- en: 'The technique described in this section will help to reduce the time spent
    creating pipelines. The first change you will notice is that the `GpuDevice::create_pipeline`
    method accepts a new optional parameter that defines the path of a pipeline cache
    file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的技术将有助于减少创建管道所需的时间。你首先会注意到`GpuDevice::create_pipeline`方法接受一个新可选参数，该参数定义了管道缓存文件的路径：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then need to define the `VkPipelineCache` structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要定义`VkPipelineCache`结构：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next step is to check whether the pipeline cache file already exists. If
    it does, we load the file data and add it to the pipeline cache creation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查管道缓存文件是否已经存在。如果存在，我们加载文件数据并将其添加到管道缓存创建中：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the file doesn’t exist, we don’t have to make any further changes to the
    creation structure. We can now call `vkCreatePipelineCache`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们不需要对创建结构做任何进一步的修改。现在我们可以调用`vkCreatePipelineCache`：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will return a handle to a `VkPipelineCache` object that we are going to
    use when creating the pipeline object:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个指向`VkPipelineCache`对象的句柄，我们将在创建管道对象时使用它：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can do the same for compute pipelines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对计算管道做同样的操作：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we have loaded a pipeline cache file, the driver will use the data to accelerate
    the pipeline creation. If, on the other hand, this is the first time we are creating
    the given pipeline, we can now query and store the pipeline cache data for later
    reuse:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已加载管道缓存文件，驱动程序将使用这些数据来加速管道创建。另一方面，如果我们是第一次创建给定的管道，我们现在可以查询并存储管道缓存数据以供以后重用：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We first call `vkGetPipelineCacheData` with `nullptr` for the data member to
    retrieve the cache data size. We then allocate the memory that is needed to store
    the cache data and call `vkGetPipelineCacheData` again, this time with a pointer
    to the memory where the cache data will be stored. Finally, we write this data
    to the file specified when `GpuDevice::create_pipeline` was called.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`nullptr`调用`vkGetPipelineCacheData`来获取数据成员的缓存数据大小。然后，我们分配存储缓存数据的内存，并再次调用`vkGetPipelineCacheData`，这次使用一个指向将要存储缓存数据的内存的指针。最后，我们将这些数据写入在调用`GpuDevice::create_pipeline`时指定的文件中。
- en: 'We are now done with the pipeline cache data structure, and it can be destroyed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了管道缓存数据结构，可以销毁它：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Before we conclude, we want to mention a shortcoming of pipeline caching. The
    data in the cache is controlled by each vendor driver implementation. When a new
    driver version is released, the data format of the cache might change and become
    incompatible with the data previously stored in the cache file. Having a cache
    file, in this case, might provide no benefit as the driver cannot make use of
    it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，我们想提到管道缓存的一个缺点。缓存中的数据由每个供应商的驱动程序实现控制。当发布新的驱动程序版本时，缓存的数据格式可能会改变，变得与之前存储在缓存文件中的数据不兼容。在这种情况下，拥有缓存文件可能不会带来任何好处，因为驱动程序无法使用它。
- en: 'For this reason, each driver has to prefix the cache data with the following
    header:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个驱动程序都必须在缓存数据前加上以下头部信息：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we load the cache data from disk, we can compare the values in the header
    against the values returned by the driver and GPU we are running on:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从磁盘加载缓存数据时，我们可以将头部中的值与驱动程序和GPU返回的值进行比较：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the values in the header match the ones of the device we are running on,
    we use the cache data as before. If they don’t, we act as if the cache didn’t
    exist and store a new version after the pipeline has been created.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果头部的值与我们正在运行的设备上的值匹配，我们就像以前一样使用缓存数据。如果不匹配，我们将像缓存不存在一样操作，并在管道创建后存储一个新的版本。
- en: In this section, we have demonstrated how to leverage pipeline caching to speed
    up pipeline creation at runtime. We have highlighted the changes made to our GPU
    device implementation to make use of this feature and how it has been used in
    this chapter’s code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何利用管道缓存来在运行时加快管道创建速度。我们强调了我们对GPU设备实现所做的更改，以利用此功能，以及它在本章代码中的应用。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved our GPU device implementation to make it easier
    to manage a large number of textures with bindless resources. We explained which
    extensions are needed and detailed which changes are required when creating a
    descriptor set layout to allow the use of bindless resources. We then showed the
    changes needed when creating a descriptor set to update the array of textures
    in use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们改进了我们的GPU设备实现，使其更容易管理大量使用无绑定资源的纹理。我们解释了需要哪些扩展，并详细说明了在创建描述符集布局以允许使用无绑定资源时需要哪些更改。然后，我们展示了在创建描述符集以更新正在使用的纹理数组时所需的更改。
- en: We then added automatic pipeline layout generation by parsing the SPIR-V binaries
    generated by the `glslang` compiler for our shaders. We provided an overview of
    the SPIR-V binary data format and explained how to parse it to extract the resources
    bound to a shader, and how to use this information to create a pipeline layout.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过解析`glslang`编译器为我们着色器生成的SPIR-V二进制文件，添加了自动管道布局生成。我们提供了SPIR-V二进制数据格式的概述，并解释了如何解析它以提取绑定到着色器的资源，以及如何使用这些信息来创建管道布局。
- en: Finally, we enhanced our pipeline creation API by adding pipeline caching to
    improve the load times of our applications after the first run. We presented the
    Vulkan APIs that are needed to either generate or load the pipeline cache data.
    We also explained some of the limitations of pipeline caching and how to deal
    with them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过添加管道缓存来增强我们的管道创建API，以改善应用程序首次运行后的加载时间。我们介绍了生成或加载管道缓存数据所需的Vulkan API。我们还解释了管道缓存的局限性以及如何处理它们。
- en: All the techniques presented in this chapter have the common goal of making
    it easier to deal with large projects and reduce manual code changes to a minimum
    when making changes to our shaders or materials.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提出的所有技术都有一个共同的目标，那就是使处理大型项目更容易，并在修改我们的着色器或材质时将手动代码更改减少到最低。
- en: We will continue to scale our engine in the next chapter by adding multithreading
    to record multiple command buffers or to submit multiple workloads in parallel
    to the GPU.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章通过添加多线程来记录多个命令缓冲区或并行提交多个工作负载到GPU，继续扩展我们的引擎。
- en: Further reading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We have covered only a small subset of the SPIR-V specification. If you would
    like to expand our parser implementation for your needs, we highly recommend consulting
    the official specification: [https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.xhtml](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.xhtml).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只涵盖了SPIR-V规范的一小部分。如果您想根据您的需求扩展我们的解析器实现，我们强烈建议您查阅官方规范：[https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.xhtml](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.xhtml)。
- en: 'We wrote a custom SPIR-V parser for this chapter, primarily for educational
    purposes. For your own project, we recommend using the existing reflection library
    from Khronos: [https://github.com/KhronosGroup/SPIRV-Reflect](https://github.com/KhronosGroup/SPIRV-Reflect).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这一章节编写了一个定制的 SPIR-V 解析器，主要是为了教育目的。对于您自己的项目，我们建议使用 Khronos 提供的现有反射库：[https://github.com/KhronosGroup/SPIRV-Reflect](https://github.com/KhronosGroup/SPIRV-Reflect)。
- en: It provides the functionality described in this chapter to deduce the pipeline
    layout for a shader binary and many other features.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了本章所述的功能，用于推断着色器二进制的管道布局以及许多其他特性。
