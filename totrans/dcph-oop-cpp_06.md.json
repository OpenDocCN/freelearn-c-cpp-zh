["```cpp\n    class Person  // base class\n    {\n    private:\n        string name;\n        string title;\n    public:\n        // constructors, destructor, \n        // public access functions, public interface etc.\n        const string &GetTitle() const { return title; }\n    };\n    class Student: public Person  // derived class\n    {\n    private:\n        float gpa;\n    public:\n        // constructors, destructor specific to Student,\n        // public access functions, public interface, etc.\n        float GetGpa() const { return gpa; }\n    }; \n    ```", "```cpp\n    int main()\n    {   \n        // Let's assume the applicable constructors exist\n        Person p1(\"Cyrus Bond\", \"Mr.\");\n        Student *s1 = new Student(\"Anne Lin\", \"Ms.\", 4.0);\n        cout << p1.GetTitle() << \" \" << s1->GetTitle();\n        cout << s1->GetGpa() << endl;\n        delete s1; // remember to relinquish alloc. memory\n        return 0;\n    }\n    ```", "```cpp\n    class GradStudent final: public Person // derived class\n    {\n       // class definition\n    };\n    ```", "```cpp\n    class Person\n    {\n    private:\n        string name;\n        string title;\n    public:\n        Person() = default;  // various constructors\n        Person(const string &, const string &); \n        Person(const Person &);\n        // Assume the public interface, access fns. exist\n    };\n    class Student: public Person\n    {\n    private:\n        float gpa = 0.0;  // use in-class initializer\n    public:\n        Student() = default;\n        Student(const string &, const string &, float);\n        // Assume the public interface, access fns. exist\n    };\n    ```", "```cpp\n    // Base class constructors\n    // Note: default constructor is included by = default\n    // specification in Person constructor prototype\n    Person::Person(const string &n, const string &t): \n                   name(n), title(t)\n    {    \n    }\n    Person::Person(const Person &p): \n                   name(p.name), title(p.title)\n    {   \n    }\n    // Derived class constructors\n    // Note: default constructor is included by = default\n    // specification in Student constructor prototype and\n    // gpa is set with value of in-class initializer (0.0)\n\n    Student::Student(const char *n, const char *t, \n                     float g): Person(n, t), gpa(g)\n    {                    \n    }                 \n\n    Student::Student(const Student &s): Person(s),\n                                        gpa(s.gpa)\n    {                                  \n    }\n    ```", "```cpp\n#include <iostream>\n#include <iomanip>\nusing std::cout;  // preferred to: using namespace std;\nusing std::endl;\nusing std::setprecision;\nusing std::string;\nusing std::to_string;\nclass Person\n{\nprivate: \n   // data members   \n   string firstName; // str mbrs are default constructed,\n   string lastName;  // so don't need in-class initializers\n   char middleInitial = '\\0';  // in-class initialization\n   string title;  // Mr., Ms., Mrs., Miss, Dr., etc.\nprotected: // make avail. to derived classes in their scope\n   void ModifyTitle(const string &); \npublic:\n   Person() = default;   // default constructor\n   Person(const string &, const string &, char, \n          const string &);  \n   // We get default copy constructor and destructor even\n   // without the below protypes; hence, commented out\n   // Person(const Person &) = default;  // def. copy ctor\n   // ~Person() = default;  // use default destructor\n   // inline function definitions\n   const string &GetFirstName() const { return firstName; }  \n   const string &GetLastName() const { return lastName; }    \n   const string &GetTitle() const { return title; } \n   char GetMiddleInitial() const { return middleInitial; }\n};\n```", "```cpp\n// Default constructor included with = default in prototype\n// With in-class initialization, it is often not necessary\n// to write the default constructor yourself.\n// alternate constructor\nPerson::Person(const string &fn, const string &ln, char mi,\n               const string &t): firstName(fn),\n               lastName(ln), middleInitial(mi), title(t)\n{\n   // dynamically allocate memory for any ptr data members\n}\n// We are using default copy constructor; let's see what\n// it would look like if we prototyped/defined it ourselves\n// (so we may better understand an upcoming discussion with\n// the upcoming derived class copy constructor). Also,\n// this is what the system-supplied version may look like.\n// Person::Person(const Person &p): firstName(p.firstName),\n//    lastName(p.lastName), middleInitial(p.middleInitial),\n//    title(p.title)\n// {\n        // deep copy any pointer data members here\n// }\n// Using default destructor – no need to write it ourselves\nvoid Person::ModifyTitle(const string &newTitle)\n{\n   title = newTitle;\n}\n```", "```cpp\nclass Student: public Person\n{\nprivate: \n   // data members\n   float gpa = 0.0;   // in-class initialization\n   string currentCourse;  \n   const string studentId;  // studentId is not modifiable\n   static int numStudents; // static data mbr. init. occurs\npublic:                  // outside of the class definition\n   // member function prototypes\n   Student();   // we will provide default constructor\n   Student(const string &, const string &, char, \n           const string &, float, const string &, \n           const string &); \n   Student(const Student &);  // copy constructor\n   ~Student();  // we will provide destructor\n   void Print() const;\n   void EarnPhD();  // public interface to inherited \n                    // protected member\n   // inline function definitions\n   float GetGpa() const { return gpa; }\n   const string &GetCurrentCourse() const \n       { return currentCourse; }\n   const string &GetStudentId() const { return studentId; }\n   // prototype only, see inline function definition below\n   void SetCurrentCourse(const string &);\n   static int GetNumberStudents(); // static mbr function\n};\n// definition for static data mbr. (implemented as extern)\nint Student::numStudents = 0;  // notice initial value of 0\ninline void Student::SetCurrentCourse(const string &c)\n{\n   currentCourse = c;\n}\n// Definition for static member function (it's also inline)\ninline int Student::GetNumberStudents()\n{\n    return numStudents;\n}\n```", "```cpp\n// Default constructor uses in-class init. for gpa, while\n// currentCourse (string mbr object) is default constructed\nStudent::Student(): studentId(to_string(numStudents + 100) \n                              + \"Id\")\n{\n   // Since studentId is const, we need to initialize it \n   // during construction using member init list (above)\n   // Also, remember to dynamically allocate memory for any \n   // pointer data mbrs. here (not needed in this example)\n   numStudents++;   // increment static counter\n}\n// alternate constructor\nStudent::Student(const string &fn, const string &ln, \n                 char mi, const string &t, float avg, \n                 const string &course, const string &id):\n            Person(fn, ln, mi, t),\n            gpa(avg), currentCourse(course), studentId(id)\n{\n   // Remember to dynamically allocate memory for any \n   // pointer data members (none in this example) \n   numStudents++;   // increment static counter\n}\n// copy constructor \nStudent::Student(const Student &s): Person(s), gpa(s.gpa),\n                 currentCourse(s.currentCourse),\n                 studentId(s.studentId)\n{\n   // deep copy any ptr data mbrs (none in this example)\n   numStudents++;   // increment static counter\n}\n\n// destructor definition\nStudent::~Student()\n{\n   // Remember to release memory for any dynamically \n   // allocated data members (none in this example)\n   numStudents--;  // decrement static counter\n}\nvoid Student::Print() const\n{\n   // Private members of Person are not directly accessible\n   // within the scope of Student, so we use access fns. \n   cout << GetTitle() << \" \" << GetFirstName() << \" \";\n   cout << GetMiddleInitial() << \". \" << GetLastName();\n   cout << \" with id: \" << studentId << \" gpa: \";\n   cout << setprecision(2) << gpa;\n   cout << \" course: \" << currentCourse << endl;\n}\nvoid Student::EarnPhD()\n{\n   // Protected members defined by the base class are\n   // accessible within the scope of the derived class.\n   // EarnPhd() provides a public interface to this\n   // functionality for derived class instances. \n   ModifyTitle(\"Dr.\");  \n}\n```", "```cpp\nint main()\n{\n    Student s1(\"Jo\", \"Li\", 'U', \"Ms.\", 3.8, \n               \"C++\", \"178PSU\"); \n    // Public members of Person and Student are accessible\n    // outside the scope of their respective classes....\n    s1.Print();\n    s1.SetCurrentCourse(\"Doctoral Thesis\");\n    s1.EarnPhD();\n    s1.Print();\n    cout << \"Total number of students: \" << \n             Student::GetNumberStudents() << endl;\n    return 0;\n}\n```", "```cpp\nMs. Jo U. Li with id: 178PSU gpa: 3.9 course: C++\nDr. Jo U. Li with id: 178PSU gpa: 3.9 course: Doctoral Thesis\nTotal number of students: 1\n```", "```cpp\n    class Student: public Person\n    {\n        // usual class definition\n    };\n    ```", "```cpp\n#include <iostream>\nusing std::cout;    // preferred to: using namespace std;\nusing std::endl;\nusing Item = int;  \nclass LinkListElement  // a 'node' or element of a LinkList\n{\nprivate:\n    void *data = nullptr;   // in-class initialization\n    LinkListElement *next = nullptr;\npublic:\n    LinkListElement() = default;\n    LinkListElement(Item *i) : data(i), next(nullptr) { }\n    ~LinkListElement()\n       { delete static_cast<Item *>(data); \n         next = nullptr; }\n    void *GetData() const { return data; }\n    LinkListElement *GetNext() const { return next; }\n    void SetNext(LinkListElement *e) { next = e; }\n};\nclass LinkList   // an encapsulated LinkList\n{\nprivate:\n    LinkListElement *head = nullptr;  // in-class init.\n    LinkListElement *tail = nullptr;\n    LinkListElement *current = nullptr;\npublic:\n    LinkList() = default; // required to keep default\n                          // interface\n    LinkList(LinkListElement *);\n   ~LinkList();\n    void InsertAtFront(Item *);\n    LinkListElement *RemoveAtFront();\n    void DeleteAtFront();\n    int IsEmpty() const { return head == nullptr; } \n    void Print() const;  \n};\n```", "```cpp\n// default constructor – not necessary to write it \n// ourselves with in-class initialization above \nLinkList::LinkList(LinkListElement *element)\n{\n    head = tail = current = element;\n}\nvoid LinkList::InsertAtFront(Item *theItem)\n{\n    LinkListElement *newHead = new\n                               LinkListElement(theItem);\n    newHead->SetNext(head);  // newHead->next = head;\n    head = newHead;\n}\nLinkListElement *LinkList::RemoveAtFront()\n{\n    LinkListElement *remove = head;\n    head = head->GetNext();  // head = head->next;\n    current = head;    // reset current for usage elsewhere\n    return remove;\n}\n\nvoid LinkList::DeleteAtFront()\n{\n    LinkListElement *deallocate;\n    deallocate = RemoveAtFront();\n    delete deallocate;  // destructor will both delete data \n}                       // and will set next to nullptr\n\nvoid LinkList::Print() const\n{\n    if (!head)\n       cout << \"<EMPTY>\";\n    LinkListElement *traverse = head;\n    while (traverse)\n    {\n        Item output = *(static_cast<Item *>\n                        (traverse->GetData()));\n        cout << output << \" \";\n        traverse = traverse->GetNext();\n    }\n    cout << endl;\n}\nLinkList::~LinkList()\n{\n    while (!IsEmpty())\n        DeleteAtFront();\n}\n```", "```cpp\nint main()\n{\n    // Create a few items, to be data for LinkListElements\n    Item *item1 = new Item;\n    *item1 = 100;\n    Item *item2 = new Item(200);\n    // create an element for the Linked List\n    LinkListElement *element1 = new LinkListElement(item1);\n    // create a linked list and initialize with one element\n    LinkList list1(element1);\n    // Add some new items to the list and print\n    list1.InsertAtFront(item2);   \n    list1.InsertAtFront(new Item(50)); // add nameless item\n    cout << \"List 1: \";\n    list1.Print();         // print out contents of list\n    // delete elements from list, one by one\n    while (!(list1.IsEmpty()))\n    {\n        list1.DeleteAtFront();\n        cout << \"List 1 after removing an item: \";\n        list1.Print();\n    }\n    // create a second linked list, add some items, print\n    LinkList list2;\n    list2.InsertAtFront(new Item (3000));\n    list2.InsertAtFront(new Item (600));\n    list2.InsertAtFront(new Item (475));\n    cout << \"List 2: \";\n    list2.Print();\n    // delete elements from list, one by one\n    while (!(list2.IsEmpty()))\n    {\n        list2.DeleteAtFront();\n        cout << \"List 2 after removing an item: \";\n        list2.Print();\n    }\n    return 0;\n}\n```", "```cpp\nList 1: 50 200 100\nList 1 after removing an item: 200 100\nList 1 after removing an item: 100\nList 1 after removing an item: <EMPTY>\nList 2: 475 600 3000\nList 2 after removing an item: 600 3000\nList 2 after removing an item: 3000\nList 2 after removing an item: <EMPTY>\n```", "```cpp\nclass Stack: private LinkList\n{\nprivate:\n    // no new data members are necessary\npublic:  \n    // Constructor / destructor prototypes shown below are\n    // not needed; we get both without these prototypes! \n    // Commented to remind what's automatically provided\n    // Stack() = default; // will call :LinkList() def ctor\n    // ~Stack() = default; \n    // the public interface for Stack \n    void Push(Item *i) { InsertAtFront(i); }\n    Item *Pop(); \n    // It is necessary to redefine these operations because\n    // LinkList is a private base class of Stack\n    int IsEmpty() const { return LinkList::IsEmpty(); }  \n    void Print() { LinkList::Print(); }\n};\nItem *Stack::Pop()\n{\n    LinkListElement *top;\n    top = RemoveAtFront();\n    // copy top's data\n    Item *item = new Item(*(static_cast<Item *>\n                            (top->GetData())));\n    delete top;\n    return item;\n}\nint main()\n{\n    Stack stack1;    // create a Stack\n    // Add some items to the stack, using public interface \n    stack1.Push(new Item (3000)); \n    stack1.Push(new Item (600));\n    stack1.Push(new Item (475));\n    cout << \"Stack 1: \";\n    stack1.Print();\n    // Pop elements from stack, one by one\n    while (!(stack1.IsEmpty()))\n    {\n        stack1.Pop();\n        cout << \"Stack 1 after popping an item: \";\n        stack1.Print();\n    }\n    return 0;\n} \n```", "```cpp\nStack 1: 475 600 3000\nStack 1 after popping an item: 600 3000\nStack 1 after popping an item: 3000\nStack 1 after popping an item: <EMPTY>\n```", "```cpp\n// class LinkListElement is as shown previously\n// The enhanced class definition of LinkList is:\nclass LinkList\n{\nprivate:\n    LinkListElement *head = nullptr;\n    LinkListElement *tail = nullptr;\n    LinkListElement *current = nullptr;\npublic:\n    LinkList() = default;\n    LinkList(LinkListElement *);\n    ~LinkList();\n    void InsertAtFront(Item *);  \n    LinkListElement *RemoveAtFront();\n    void DeleteAtFront();\n    // Notice additional member functions added\n    void InsertBeforeItem(Item *, Item *); \n    LinkListElement *RemoveSpecificItem(Item *);\n    void DeleteSpecificItem(Item *);\n    void InsertAtEnd(Item *);\n    LinkListElement *RemoveAtEnd();\n    void DeleteAtEnd();\n    int IsEmpty() const { return head == nullptr; } \n    void Print() const;  \n};\n// Assume we have the implementation for the methods here…\n```", "```cpp\nclass Queue: protected LinkList\n{\nprivate:\n    // no new data members are necessary\npublic: \n    // Constructor prototype shown below is not needed; \n    // we get default w/o prototype (since no other ctor)\n    // Commented to remind what's automatically provided\n    // Queue() = default;  // calls :LinkList() def. ctor\n    // Destructor prototype is needed (per virtual keyword)\n    virtual ~Queue() = default; // we'll see virtual Chp. 7\n    // public interface of Queue\n    void Enqueue(Item *i) { InsertAtEnd(i); }\n    Item *Dequeue(); \n    // redefine these methods, LinkList is prot. base class\n    int IsEmpty() const { return LinkList::IsEmpty(); }\n    void Print() { LinkList::Print(); }\n};\nItem *Queue::Dequeue()\n{\n    LinkListElement *front;\n    front = RemoveAtFront();\n    // make copy of front's data\n    Item *item = new Item(*(static_cast<Item *>\n                            (front->GetData())));\n    delete front; \n    return item;\n}\nclass PriorityQueue: public Queue\n{\nprivate:\n    // no new data members are necessary\npublic:\n    // Constructor prototype shown below is not needed; \n    // we get default w/o protoype (since no other ctor)\n    // Commented to remind what's automatically provided\n    // PriorityQueue() = default; // calls :Queue() \n                                  // default constructor\n    // destructor proto. is not needed for overriden dtor\n    // ~PriorityQueue() override = default; // see Chp 7\n    void PriorityEnqueue(Item *i1, Item *i2) \n    {  InsertBeforeItem(i1, i2); } // accessible in this \n};                                 // scope\n```", "```cpp\nint main()\n{\n    Queue q1;   // Queue instance\n    q1.Enqueue(new Item(50));\n    q1.Enqueue(new Item(67));\n    q1.Enqueue(new Item(80));\n    q1.Print();\n    while (!(q1.IsEmpty()))\n    {\n        q1.Dequeue();\n        q1.Print();\n    }\n    PriorityQueue q2;   // PriorityQueue instance\n    Item *item = new Item(167); // save a handle to item\n    q2.Enqueue(new Item(67));   // first item added\n    q2.Enqueue(item);           // second item\n    q2.Enqueue(new Item(180));  // third item\n    // add new item before an existing item\n    q2.PriorityEnqueue(new Item(100), item); // 4th item\n    q2.Print();\n    while (!(q2.IsEmpty()))\n    {\n       q2.Dequeue();\n       q2.Print();\n    }\n    return 0;\n}\n```", "```cpp\n50 67 80\n67 80\n80\n<EMPTY>\n67 100 167 180\n100 167 180\n167 180\n180\n<EMPTY>\n```"]