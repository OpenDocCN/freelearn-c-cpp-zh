- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Type-Safety with Strong Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is a statically typed language, meaning that every expression is assigned
    a type at a compile time, either by a developer (in most cases), or deduced by
    a compiler when using the keyword auto. Still, this doesn’t make it a type-safe
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Both C++ and C allow functions with a variable number of arguments (`va_arg`),
    or variadic functions and type casting, and support implicit type conversion.
    These low-level capabilities that are associated with the performance of C++ and
    C are often the source of bugs in programs. In this chapter, we will cover good
    practices used to increase type-safety in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type-safety** is an important aspect of a program in safety-critical systems.
    That’s why safety coding standards provided by organizations such as MISRA and
    AUTOSAR restrain the usage of features that violate type-safety. In this chapter,
    we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler for x86 architecture. This will allow you to see standard
    output (stdio) results and better observe the code’s behavior. As we are using
    a lot of modern C++ features, make sure to select the C++23 standard, by adding
    `-std=c++23` in the compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. Most of the examples can
    also be run in the Renode simulator on Arm Cortex-M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09)).
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you make a call to a function that expects an integer parameter, but you
    pass a float as an argument, the compiler will happily compile the program. Similarly,
    if you pass an array of integers to a function that expects a pointer to an integer,
    the program will also compile. These scenarios have become so normalized in both
    C and C++ that they are often taken for granted without considering what’s happening
    during the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: In both described scenarios, the compiler is performing implicit conversions.
    It converts the float to an integer in the first scenario and passes a pointer
    to the first element of the array in the second scenario, a process known as **array-to-pointer
    decay**.
  prefs: []
  type: TYPE_NORMAL
- en: While implicit conversions make the code less verbose and easier to write, they
    also open the door to a range of type-safety-related issues. Converting a float
    to an integer leads to precision loss, and assuming that an array always behaves
    like a pointer can lead to misinterpretations of the array’s bounds, potentially
    causing buffer overflows or other memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit conversion is performed in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is called with an argument of a type different than the parameter.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a value specified in a return statement is of a different type than specified
    by a function declaration. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In expressions with binary operators provided with operands of different arithmetic
    types. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a `switch` statement to an integral type. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In an `if` statement, types can be converted to a `bool` type. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are different types of implicit conversion that are handled by a compiler,
    and some of the most important are:'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric promotions and conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array to pointer conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function to pointer conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss the above implicit conversions with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric promotions and conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic types can be promoted or converted to other arithmetic types. Type
    promotion will not change the value or lose precision. `std::uint8_t` can be promoted
    to `int`, or `float` can be promoted to `double`. If a type that is being converted
    can fit entirely to the destination type, without loss of precision, it is being
    promoted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operators do not accept types smaller than `int`. Arithmetic types
    can be promoted when passed as operands to arithmetic operators. There are specific
    rules for promotions of integral and floating-point types based on their type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean promotion: `bool` is promoted to `int` with value `0` if set to `false`,
    and `1` if `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other integral types, including bitfields, are converted to the smallest type
    from the following list that can represent all the values of the converted type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned long`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long long`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned long long`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `float` can be promoted to `double`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand integer promotion rules, we will go over the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we added `uint8_t` and `uint16_t`. According to the promotion
    rules, both types will be promoted to `int`, as they can be fully represented
    by `int`. The result of the adding is stored in the variable `res1`, which is
    declared as `auto`, meaning that the compiler will deduce its type. We expect
    it to be an `int` and we verify that using `static_assert` and `std::is_same_v`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, both types were promoted to the same type. If we had different
    types after promotion, then they would be converted to a common type under the
    rules of **usual arithmetic conversion**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the usual arithmetic conversion is to yield types to a common type,
    which is also the type of the result. There are a couple of rules to usual arithmetic
    conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If both types are signed or unsigned integers, then the common type is the
    type of greater integer conversion rank. The ranks are listed below in decreasing
    order (the ranks of unsigned integers correspond to those of matching signed):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long long`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signed char`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If one of the types is a signed integer and the other one is unsigned then
    the following rules apply:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the integer conversion rank of the unsigned type is greater than or equal
    to the signed type, then the common type is that of the unsigned type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if the signed type can represent all the values of the unsigned type,
    the common type is that of the signed type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the common type is an unsigned integer of the type of the signed
    integer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If one of the types is a floating type and the other is an integer, the integer
    is converted to that floating type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If both types are the floating type but of different floating-point conversion
    ranks, the type with the lower conversion rank is converted to the other one.
    The floating-point conversion rank is listed below in decreasing order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long double`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go through the following example to better understand the rules of usual
    arithmetic conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we have a `bitfield` of 31 bits with an underlying type
    of `long long`. We first add `b.a` and variable c of type `int`. If we are on
    a platform where the size of the `int` is 4 bytes, the bitfield will be promoted
    to the `int`, even though the underlying type `long long` has a size of 8 bytes.
    The promoted bitfield will be added to int `c`, so the result of this operation
    will also be int, which we verify by checking the type of res1 using `std::is_same_v`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the example, we subtract the bitfield from `long` `e`.
    In this case, the bitfield is first promoted to `int`; then, according to the
    rules of usual arithmetic conversion, it is converted to `long`, meaning that
    the resulting type will also be `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the above example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the program builds successfully is enough to confirm the usual
    arithmetic conversion results, as we used `static_assert` to verify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us take a look at an example whose result may be surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run this example, the expression within the `if` clause will evaluate
    to true. As per the rules of usual arithmetic conversion, the signed `int` a will
    be converted to the `unsigned int`, meaning that the expression `a + b` will indeed
    be greater than `0`. Mixing unsigned and signed types in arithmetic expressions
    can lead to undesired behavior and potential bugs due to implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `–Wconversion` and `-Wsign-conversion` compiler flags with GCC to
    make it raise a warning when implicit conversion may change a value and sign.
    Still, mixing signed and unsigned types in arithmetic expressions should be avoided
    as it can result in wrong results.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss array-to-pointer conversion and its implications.
  prefs: []
  type: TYPE_NORMAL
- en: Array-to-pointer conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array can be implicitly converted to a pointer. The resulting pointer points
    to the first element of the array. Many C and C++ functions that work on arrays
    of data are designed with pointer and size parameters. These interfaces are based
    on contract design. The contract is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A caller will pass a pointer that points to the first element of the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A caller will pass the size of the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a simple contract, but there is no way to enforce it. Let’s take a
    look at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, we have the `print_ints` function with `arr`, a pointer
    to an `int`, and `len`, a `std::size_t` parameter. In the `main` function, we
    call the `print_ints` function by passing `array_ints`, an array of 3 integers,
    and `3` as arguments. The array `array_ints` will be implicitly converted to a
    pointer that points to its first element. There are a couple of potential issues
    with the `print_ints` function:'
  prefs: []
  type: TYPE_NORMAL
- en: It expects that the pointer we pass to it is valid. It doesn’t verify that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It expects that the argument it receives for the `len` parameter is the actual
    size of the array it operates on. A caller could pass a size that may cause out-of-bounds
    access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it operates directly on a pointer, there is always a chance of out-of-bound
    access if pointer arithmetic is used in the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To eliminate these potential issues, in C++, instead of using a pointer to
    work on an array of data, we can use the class template `std::span`. It is a wrapper
    for a contiguous sequence of objects, with the first element of the sequence at
    position zero. It can be constructed from a C-style array, it has the `size` method,
    and we can use range-based `for` loops on it. Let’s write the previous example
    using the `std::span` instead of the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we can see that the function `print_ints` looks much simpler
    now. It accepts `std::span` of integers and it uses a range-based for loop to
    iterate over the elements. On the call site, we now just pass `arr`, an array
    of 3 integers. It is implicitly converted to `std::span`.
  prefs: []
  type: TYPE_NORMAL
- en: The class template `std::span` also has the `size` method, operator `[]`, and
    `begin` and `end` iterators, meaning we can use it in standard library algorithms.
    We can also construct a subspan from `span`. It can be constructed from C-style
    arrays, but also from containers such as `std::array` and `std::vector`. It is
    a great solution to potential issues of interfaces that usually rely on pointer
    and size parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Function-to-pointer conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function can be implicitly converted to a pointer to that function. The following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we assign the function `print_hello` to a function pointer
    `fptr`. In C++, we don’t need to use the address-off operator with a function
    name to assign it to a function pointer. Also, we don’t need to dereference a
    function pointer when making a call to a function through it. Still, `print_hello`
    and `fptr` are two different types and we confirm this using the `static_assert`
    and `is_same` type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions in C++ make writing the code easier. They can sometimes
    lead to undesired behavior and potential issues with our program. To mitigate
    these concerns, we can explicitly convert types when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover explicit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ supports C-style cast explicit conversion, but also functional-style cast
    and the following casting operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reinterpret_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go through casting operators, starting with `const_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: const_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`const_cast` is used to cast away constness to work with non-const-correct
    functions. We will go through the following example to better understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we used `const_cast` in two different scenarios. We first
    used it to cast away constness from `const int num` to be able to pass it to the
    `print_num` function. The `print_num` function has a single parameter – a non-const
    reference to an `int`. As we know that this function is not trying to modify the
    object that the reference is bound to, we decided to cast away constness so we
    can pass a reference to a const int to it without the compiler generating an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we used `const_cast` to cast away constness from the `num` to be able
    to assign it to non-const reference `num_ref`. If you run this example in Compiler
    Explorer, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The program returned `42`, that is, the value of `num` is `42` even though we
    tried to set it to `16` through `num_ref`. This is due to the fact that modifying
    the const variable through a non-const reference or a pointer is undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast` is used mostly to interface with non-const correct functions.
    Still, this is dangerous and should be avoided as we can’t guarantee that the
    function we are passing a const-cast-away pointer or a reference will not try
    to modify the object that the pointer is pointing to or the reference it is bound
    to. Next, we will cover `static_cast`.'
  prefs: []
  type: TYPE_NORMAL
- en: static_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most used cast operator in C++ is `static_cast`, and it is used in the
    following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: To upcast and downcast a pointer of base class to derived class and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To discard a value expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert between types with well-known conversion paths such as int to float,
    `enum` to an `int`, int to an `enum`, and similar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will go through several usages of `static_cast` using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the above example, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we used `static_cast` to convert an `unsigned int` to
    a signed `int`, which helps mitigate the issue of comparing integers with mixed
    signs introduced by implicit conversion. Still, we would need to make sure that
    the conversion is safe as `static_cast` doesn’t do any runtime checks.
  prefs: []
  type: TYPE_NORMAL
- en: Using `static_cast` to cast the variable `c` to void is a technique used to
    suppress compiler warnings about unused variables. It indicates that we are aware
    of the variable, but we intentionally do not use it.
  prefs: []
  type: TYPE_NORMAL
- en: In the other part of the above example, we can see that an address to an object
    of the `Derived` class can be implicitly converted to a pointer of the `Base`
    class. If we call a function `hi` on the pointer of the Base class which is pointing
    to an object of the Derived class, we will actually make a call to a `hi` function
    defined in the `Base` class. Then we used `static_cast` to downcast `Base` pointer
    to a `Derived` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Down-casting using `static_cast` can be dangerous as `static_cast` doesn’t
    do any runtime checks to make sure that the pointer is actually pointing to the
    converting type. An object of the `Derived` class is also an object of the `Base`
    class, but the reverse is not true – `Base` is not `Derived`. The following example
    demonstrates why this is dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we are trying to access member `x` of the `Derived` class on
    an object of the base class. As we used `static_cast`, the compiler will not complain
    and this will result in undefined behavior, as the base class doesn’t have member
    `x`. One of the possible outputs of this program is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To avoid this problem, we can use `dynamic_cast`, which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: dynamic_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dynamic_cast` performs runtime checks of types and sets the result to `nullptr`
    in case the `Base` pointer doesn’t actually point to an object of the `Derived`
    class. We will go through an example to better understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we have a function `process` with a pointer to Base as
    a parameter. The function uses `dynamic_cast` to downcast the `Base` pointer to
    a `Derived` pointer. In the **if statement with initializer**, we initialize `ptr`
    with the result of `dynamic_cast<Derived*>` on a `Base` pointer. In the condition
    of the `if` statement, we check if `ptr` is different from `nullptr`, and if it
    is we can safely use it as a pointer to an object of the `Derived` class. Next,
    we will cover `reinterpret_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: reinterpret_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`reinterpret_cast` is used to convert between types by reinterpreting the underlying
    bits. It can be used in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: To convert a pointer to an integer large enough to hold all of its values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert a value of an integer to a pointer. A pointer converted to an integer
    and back to its original type is guaranteed to have the original value and can
    be dereferenced safely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert pointers between different types, such as between `T1` and `T2`.
    The resulting pointer to `T2` can be dereferenced safely only if the resulting
    pointer is `char`, `unsigned char`, `std::byte`, or `T1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert a function pointer `F1` to a pointer to a different function `F2`.
    Converting `F2` back to `F1` will result in the pointer to `F1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand `reinterpret_cast`, we will go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example in Renode will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The above example demonstrates the usage of `reinterpret_cast`. We first initialized
    a pointer to an int using the address of a float using `reinterpret_cast<int*>(&f)`.
    This is equivalent to using `static_cast` as `static_cast<int*>(static_cast<void*>(&f))`.
    We print the value of the dereference integer pointer, and it is `1078523331`.
    This is an actual bit pattern contained in the `float` variable `f`. It is an
    IEEE-754 floating point representation of `3.14`.
  prefs: []
  type: TYPE_NORMAL
- en: However, dereferencing the integer pointer initialized by an address of a float
    is not a defined behavior according to the C++ standard. This is called **type
    punning** – treating an object of one type as if it were another type. Using `reinterpet_cast`
    for type punning is common, as it proved to yield expected results on most platforms
    despite the undefined behavior. There are alternatives that we will discuss after
    going through this example.
  prefs: []
  type: TYPE_NORMAL
- en: If we cast the pointer to the integer back to a pointer to a float, it is safe
    to dereference the resulting pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we converted the pointer to float to an integer to print the address it
    contains. We used `std::uintptr_t`, an integer type that is capable of holding
    a pointer to `void`. Following this, we initialized `fun_void_ptr` – a pointer
    to a function that returns `void` with function `fun`, which returns `int`. We
    made a call on the `fun_void_ptr` pointer, which printed the expected output,
    but it is still undefined. Converting `fun_void_ptr` to a pointer that matches
    the signature of function `fun` – `fun_int_ptr` – will make calling fun through
    the resulting pointer safe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go through type punning in C++ and the alternatives to using `reinterpret_cast`
    for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Type punning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `reinterpret_cast` for type punning is a common practice even though it
    introduces undefined behavior. Aliasing rules determine how we can access an object
    in C++, and to put it simply, we can access an object through a pointer and const
    qualified version of that pointer, a struct or union that contains the object,
    and through a `char`, `unsigned char`, and `std::byte`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through the following example to better understand type punning
    in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the above example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example in Renode will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we used `reinterpret_cast` to treat an integer `i` as
    an array of `chars`. By checking the value pointed by the first element of the
    mentioned array, we can determine if we are on a big or little-endian system.
    As per the aliasing rules, this is a valid approach, but treating an array of
    `chars` as some other type would be undefined behavior. We did that in the function
    void `process_data` where we reinterpreted an array of `chars` as an array of
    `my_struct` objects. The output of the program is as we would expect it, even
    though we introduced undefined behavior. To mitigate this issue, we can use `std::memcpy`.
  prefs: []
  type: TYPE_NORMAL
- en: Type punning – the correct way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `std::memcpy` is the only (as of C++23) available option for type punning
    in C++. In the above example, we demonstrate this in the `process_data_memcpy`
    function. There is usually a concern of bytes being copied, using additional memory
    and runtime overhead, but the fact is that the call to `memcpy` is usually optimized
    away by a compiler. You can verify this by running the above example in Compiler
    Explorer and by experimenting with different optimization levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++20 introduces `std::bit_cast`, which can also be used for type punning,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The above example and the program output demonstrate the usage of `std::bit_cast`
    for type punning. The `std::bit_cast` will return an object. We specify the type
    that we are converting to as the template argument. This will also be the return
    type of the `std::bit_cast`. The size of the converting type and the type we are
    converting to must be the same. This means `std::bit_cast` is not an option for
    interpreting arrays of one type as arrays of another type, and for that we still
    need to use `std::memcpy`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how we can use strong types in C++ to increase type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Strong types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about type-safety, we should also discuss the safety of interfaces
    that use commonly available types such as integers and floats to represent physical
    units such as time, length, and volume. Let us take a look at the following function
    from a vendor’s SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a well-documented function. Still, it takes a lot of effort to understand
    all the parameters that it accepts and the exact units of each. Most of the parameters
    represent time but in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: '`LE_Scan_Interval`, `LE_Scan_Window`, `Conn_Interval_Min`, `Conn_Interval_Max`,
    `Supervision_Timeout`, `Minimum_CE_Length`, and `Maximum_CE_Length` are all time-related
    parameters, but they represent different units. They are either multiples of 0.625,
    1.25, or 10 ms. The vendor of the above function also provided the following macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of a call to the above function using the provided macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The macros help a bit with readability, but the problem of passing bad values
    to this function still remains. It is fairly easy to make a mistake, swap the
    `CONN_L` and `CONN_P` macros, and introduce a hard-to-find bug to the program.
    Instead of `uint16_t`, we could define and use types `conn_l` and `conn_p`. If
    we wrap the function with these amendments, we will have the following wrapper
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, we are using `conn_l` and `conn_p` types instead of `uint16_t`,
    and we will define these types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above strong types `conn_l` and `conn_p`, we can call the wrapper
    function as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By using the keyword explicit in front of constructors of types `conn_l` and
    `conn_p`, we make sure that the compiler doesn’t perform implicit conversion from
    integer types. This makes it impossible to pass an integer or a float that can
    be used to construct `conn_l` and `conn_p` to the `aci_gap_create_connection_wrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the entire example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the example successfully means that we passed all the correct arguments
    to `aci_gap_create_connection_wrapper`. As an exercise, try passing integer values
    instead of `conn_l` and `conn_p` arguments to see how they prevent the compiler
    from doing implicit conversions. After that, try removing the `explicit` keyword
    from the `conn_l` and `conn_p` constructors to see what will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further improve the example by introducing a strong-type `time` that
    will represent the time duration, and make it a private member of types `conn_l`
    and `conn_p`. The code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, we created a strong-type time and used it as a private
    member in types `conn_l` and `conn_p`. We also created a user-defined literal
    with `operator""_ms` to make the following function call possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we are using the user-defined literal `operator""_ms`
    to create objects of strong-type time that are used to instantiate conn_l and
    conn_p objects.
  prefs: []
  type: TYPE_NORMAL
- en: The above changes to the original interface improve code readability and compile-time
    error detection. Using strong types, we make it a lot harder to pass wrong values
    to the function, increasing the type-safety of our codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type safety is an important aspect of any programming language used in critical
    applications. Understanding potential issues of implicit conversion is important
    to mitigate type-safety concerns. Type punning is another area that deserves special
    attention in C++, and we learned how to address it properly. We also learned how
    to use strong types to mitigate issues of passing wrong values to parameters with
    the same types.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover lambdas in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
