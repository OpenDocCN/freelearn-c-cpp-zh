- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Type-Safety with Strong Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is a statically typed language, meaning that every expression is assigned
    a type at a compile time, either by a developer (in most cases), or deduced by
    a compiler when using the keyword auto. Still, this doesn’t make it a type-safe
    language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Both C++ and C allow functions with a variable number of arguments (`va_arg`),
    or variadic functions and type casting, and support implicit type conversion.
    These low-level capabilities that are associated with the performance of C++ and
    C are often the source of bugs in programs. In this chapter, we will cover good
    practices used to increase type-safety in C++.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Type-safety** is an important aspect of a program in safety-critical systems.
    That’s why safety coding standards provided by organizations such as MISRA and
    AUTOSAR restrain the usage of features that violate type-safety. In this chapter,
    we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit conversions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler for x86 architecture. This will allow you to see standard
    output (stdio) results and better observe the code’s behavior. As we are using
    a lot of modern C++ features, make sure to select the C++23 standard, by adding
    `-std=c++23` in the compiler options box.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. Most of the examples can
    also be run in the Renode simulator on Arm Cortex-M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversion
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you make a call to a function that expects an integer parameter, but you
    pass a float as an argument, the compiler will happily compile the program. Similarly,
    if you pass an array of integers to a function that expects a pointer to an integer,
    the program will also compile. These scenarios have become so normalized in both
    C and C++ that they are often taken for granted without considering what’s happening
    during the compilation process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In both described scenarios, the compiler is performing implicit conversions.
    It converts the float to an integer in the first scenario and passes a pointer
    to the first element of the array in the second scenario, a process known as **array-to-pointer
    decay**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: While implicit conversions make the code less verbose and easier to write, they
    also open the door to a range of type-safety-related issues. Converting a float
    to an integer leads to precision loss, and assuming that an array always behaves
    like a pointer can lead to misinterpretations of the array’s bounds, potentially
    causing buffer overflows or other memory issues.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit conversion is performed in the following cases:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换在以下情况下执行：
- en: 'When a function is called with an argument of a type different than the parameter.
    For example:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数以与参数类型不同的类型调用时。例如：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When a value specified in a return statement is of a different type than specified
    by a function declaration. For example:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当返回语句中指定的值类型与函数声明中指定的类型不同时。例如：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In expressions with binary operators provided with operands of different arithmetic
    types. For example:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有不同算术类型操作数的二元运算符表达式中。例如：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a `switch` statement to an integral type. For example:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将整数类型作为`switch`语句的目标时。例如：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In an `if` statement, types can be converted to a `bool` type. For example:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`if`语句中，类型可以被转换为`bool`类型。例如：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are different types of implicit conversion that are handled by a compiler,
    and some of the most important are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器处理不同类型的隐式转换，其中一些最重要的转换包括：
- en: Numeric promotions and conversions
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字提升和转换
- en: Array to pointer conversion
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组到指针转换
- en: Function to pointer conversion
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数到指针转换
- en: Next, we will discuss the above implicit conversions with examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过示例讨论上述隐式转换。
- en: Numeric promotions and conversions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字提升和转换
- en: Arithmetic types can be promoted or converted to other arithmetic types. Type
    promotion will not change the value or lose precision. `std::uint8_t` can be promoted
    to `int`, or `float` can be promoted to `double`. If a type that is being converted
    can fit entirely to the destination type, without loss of precision, it is being
    promoted.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 算术类型可以被提升或转换为其他算术类型。类型提升不会改变值或丢失精度。`std::uint8_t`可以被提升为`int`，或者`float`可以被提升为`double`。如果一个类型可以被完全转换为目标类型，而不丢失精度，那么它正在进行提升。
- en: 'Arithmetic operators do not accept types smaller than `int`. Arithmetic types
    can be promoted when passed as operands to arithmetic operators. There are specific
    rules for promotions of integral and floating-point types based on their type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符不接受小于`int`的类型。当作为算术运算符的操作数传递时，算术类型可以被提升。根据它们的类型，整数和浮点数的提升有一些特定的规则：
- en: 'Boolean promotion: `bool` is promoted to `int` with value `0` if set to `false`,
    and `1` if `true`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔提升：如果`bool`类型设置为`false`，则提升为`int`类型，值为`0`；如果设置为`true`，则提升为`int`类型，值为`1`。
- en: 'Other integral types, including bitfields, are converted to the smallest type
    from the following list that can represent all the values of the converted type:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他整型类型，包括位域，将被转换为以下列表中最小的类型，该类型可以表示转换类型的所有值：
- en: '`int`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`unsigned int`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int`'
- en: '`long`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`unsigned long`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long`'
- en: '`long long`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long long`'
- en: '`unsigned long long`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long long`'
- en: A `float` can be promoted to `double`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`类型可以被提升为`double`类型。'
- en: 'To better understand integer promotion rules, we will go over the next example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解整数提升规则，我们将通过下一个例子进行说明：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above example, we added `uint8_t` and `uint16_t`. According to the promotion
    rules, both types will be promoted to `int`, as they can be fully represented
    by `int`. The result of the adding is stored in the variable `res1`, which is
    declared as `auto`, meaning that the compiler will deduce its type. We expect
    it to be an `int` and we verify that using `static_assert` and `std::is_same_v`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，我们添加了`uint8_t`和`uint16_t`。根据提升规则，这两种类型都将提升为`int`，因为它们可以被`int`完全表示。加法的结果存储在变量`res1`中，该变量被声明为`auto`，这意味着编译器将推导其类型。我们期望它是一个`int`，我们使用`static_assert`和`std::is_same_v`来验证这一点。
- en: In this example, both types were promoted to the same type. If we had different
    types after promotion, then they would be converted to a common type under the
    rules of **usual arithmetic conversion**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两种类型都被提升到了相同的类型。如果我们提升后有不同的类型，那么它们将根据**常规算术转换规则**转换为一种公共类型。
- en: 'The goal of the usual arithmetic conversion is to yield types to a common type,
    which is also the type of the result. There are a couple of rules to usual arithmetic
    conversion:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 常规算术转换的目标是将类型转换为一种公共类型，这同时也是结果类型。常规算术转换有一些规则：
- en: 'If both types are signed or unsigned integers, then the common type is the
    type of greater integer conversion rank. The ranks are listed below in decreasing
    order (the ranks of unsigned integers correspond to those of matching signed):'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两种类型都是有符号或无符号整数，那么公共类型是具有更高整数转换等级的类型。等级按降序排列如下（无符号整数的等级对应于匹配的有符号整数的等级）：
- en: '`long long`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long long`'
- en: '`long`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`int`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`short`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`signed char`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signed char`'
- en: 'If one of the types is a signed integer and the other one is unsigned then
    the following rules apply:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其中一个类型是有符号整数，另一个是无符号整数，则适用以下规则：
- en: If the integer conversion rank of the unsigned type is greater than or equal
    to the signed type, then the common type is that of the unsigned type.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无符号类型的整数转换等级大于或等于有符号类型，则公共类型是无符号类型。
- en: Otherwise, if the signed type can represent all the values of the unsigned type,
    the common type is that of the signed type.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果有符号类型可以表示无符号类型的所有值，则公共类型是有符号类型。
- en: Otherwise, the common type is an unsigned integer of the type of the signed
    integer.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，公共类型是有符号整数的无符号整数类型。
- en: If one of the types is a floating type and the other is an integer, the integer
    is converted to that floating type.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其中一个类型是浮点类型，另一个是整数，则整数转换为该浮点类型。
- en: 'If both types are the floating type but of different floating-point conversion
    ranks, the type with the lower conversion rank is converted to the other one.
    The floating-point conversion rank is listed below in decreasing order:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两种类型都是浮点类型但浮点转换等级不同，则将转换等级较低的类型转换为另一个类型。浮点转换等级按降序排列如下：
- en: '`long double`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double`'
- en: '`double`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`float`'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: 'Let’s go through the following example to better understand the rules of usual
    arithmetic conversion:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来更好地理解常规算术转换的规则：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the above example, we have a `bitfield` of 31 bits with an underlying type
    of `long long`. We first add `b.a` and variable c of type `int`. If we are on
    a platform where the size of the `int` is 4 bytes, the bitfield will be promoted
    to the `int`, even though the underlying type `long long` has a size of 8 bytes.
    The promoted bitfield will be added to int `c`, so the result of this operation
    will also be int, which we verify by checking the type of res1 using `std::is_same_v`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们有一个 31 位的 `bitfield`，其底层类型为 `long long`。我们首先将 `b.a` 和类型为 `int` 的变量
    c 相加。如果我们在一个 `int` 的大小为 4 字节的平台上，位字段将被提升为 `int`，尽管底层类型 `long long` 的大小为 8 字节。提升后的位字段将加到
    `int` 类型的 `c` 上，因此这个操作的最终结果也将是 `int`，我们可以通过使用 `std::is_same_v` 检查 res1 的类型来验证这一点。
- en: In the second part of the example, we subtract the bitfield from `long` `e`.
    In this case, the bitfield is first promoted to `int`; then, according to the
    rules of usual arithmetic conversion, it is converted to `long`, meaning that
    the resulting type will also be `long`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的第二部分，我们从 `long` 类型的 `e` 中减去位字段。在这种情况下，位字段首先提升为 `int`；然后，根据常规算术转换的规则，它被转换为
    `long`，这意味着结果类型也将是 `long`。
- en: 'You can run the above example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的 GitHub 仓库运行上述示例。它位于 `Chapter09/type_safety` 目录下，你可以使用以下命令构建和运行它：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fact that the program builds successfully is enough to confirm the usual
    arithmetic conversion results, as we used `static_assert` to verify it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 程序成功构建的事实就足以确认常规算术转换的结果，因为我们使用了 `static_assert` 来验证它。
- en: 'Now, let us take a look at an example whose result may be surprising:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个可能令人惊讶的结果的示例：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run this example, the expression within the `if` clause will evaluate
    to true. As per the rules of usual arithmetic conversion, the signed `int` a will
    be converted to the `unsigned int`, meaning that the expression `a + b` will indeed
    be greater than `0`. Mixing unsigned and signed types in arithmetic expressions
    can lead to undesired behavior and potential bugs due to implicit conversions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，`if` 子句中的表达式将评估为真。根据常规算术转换的规则，有符号的 `int` a 将被转换为 `unsigned int`，这意味着表达式
    `a + b` 确实大于 `0`。在算术表达式中混合无符号和有符号类型可能会由于隐式转换而导致不期望的行为和潜在的错误。
- en: We can use `–Wconversion` and `-Wsign-conversion` compiler flags with GCC to
    make it raise a warning when implicit conversion may change a value and sign.
    Still, mixing signed and unsigned types in arithmetic expressions should be avoided
    as it can result in wrong results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 GCC 的编译器标志 `–Wconversion` 和 `-Wsign-conversion` 来使其在隐式转换可能改变值和符号时发出警告。然而，在算术表达式中混合有符号和无符号类型应该避免，因为这可能导致错误的结果。
- en: Next, we will discuss array-to-pointer conversion and its implications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论数组到指针转换及其影响。
- en: Array-to-pointer conversion
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组到指针转换
- en: 'An array can be implicitly converted to a pointer. The resulting pointer points
    to the first element of the array. Many C and C++ functions that work on arrays
    of data are designed with pointer and size parameters. These interfaces are based
    on contract design. The contract is the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组可以被隐式转换为指针。生成的指针指向数组的第一个元素。许多在数据数组上工作的C和C++函数都是设计有指针和大小参数的。这些接口基于合同设计。合同如下：
- en: A caller will pass a pointer that points to the first element of the array
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者将传递一个指向数组第一个元素的指针
- en: A caller will pass the size of the array
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者将传递数组的大小
- en: 'This is a simple contract, but there is no way to enforce it. Let’s take a
    look at the following simple example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的约定，但没有办法强制执行。让我们看看以下简单的例子：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the above example, we have the `print_ints` function with `arr`, a pointer
    to an `int`, and `len`, a `std::size_t` parameter. In the `main` function, we
    call the `print_ints` function by passing `array_ints`, an array of 3 integers,
    and `3` as arguments. The array `array_ints` will be implicitly converted to a
    pointer that points to its first element. There are a couple of potential issues
    with the `print_ints` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们有`print_ints`函数，它有一个指向`int`的指针`arr`和`len`，一个`std::size_t`参数。在`main`函数中，我们通过传递`array_ints`，一个包含3个整数的数组，以及`3`作为参数来调用`print_ints`函数。数组`array_ints`将被隐式转换为指向其第一个元素的指针。`print_ints`函数有几个潜在问题：
- en: It expects that the pointer we pass to it is valid. It doesn’t verify that.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它期望我们传递给它的指针是有效的。它不会验证这一点。
- en: It expects that the argument it receives for the `len` parameter is the actual
    size of the array it operates on. A caller could pass a size that may cause out-of-bounds
    access.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它期望它接收的`len`参数是它操作的数组的实际大小。调用者可能传递一个可能导致越界访问的大小。
- en: As it operates directly on a pointer, there is always a chance of out-of-bound
    access if pointer arithmetic is used in the function.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它直接操作指针，如果在函数中使用指针算术，总有可能发生越界访问。
- en: 'To eliminate these potential issues, in C++, instead of using a pointer to
    work on an array of data, we can use the class template `std::span`. It is a wrapper
    for a contiguous sequence of objects, with the first element of the sequence at
    position zero. It can be constructed from a C-style array, it has the `size` method,
    and we can use range-based `for` loops on it. Let’s write the previous example
    using the `std::span` instead of the pointer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这些潜在问题，在C++中，我们不是使用指向数据数组的指针来工作，而是可以使用类模板`std::span`。它是一个连续对象序列的包装器，序列的第一个元素位于位置零。它可以由C风格数组构造，它有`size`方法，我们可以在它上面使用基于范围的`for`循环。让我们用`std::span`而不是指针重写之前的例子：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the above example, we can see that the function `print_ints` looks much simpler
    now. It accepts `std::span` of integers and it uses a range-based for loop to
    iterate over the elements. On the call site, we now just pass `arr`, an array
    of 3 integers. It is implicitly converted to `std::span`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以看到函数`print_ints`现在看起来简单多了。它接受整数的`std::span`，并使用基于范围的for循环遍历元素。在调用位置，我们现在只需传递`arr`，一个包含3个整数的数组。它会被隐式转换为`std::span`。
- en: The class template `std::span` also has the `size` method, operator `[]`, and
    `begin` and `end` iterators, meaning we can use it in standard library algorithms.
    We can also construct a subspan from `span`. It can be constructed from C-style
    arrays, but also from containers such as `std::array` and `std::vector`. It is
    a great solution to potential issues of interfaces that usually rely on pointer
    and size parameters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板`std::span`也有`size`方法、操作符`[]`以及`begin`和`end`迭代器，这意味着我们可以将其用于标准库算法。我们还可以从`span`构造子span。它可以由C风格数组构造，也可以由容器如`std::array`和`std::vector`构造。它是解决通常依赖于指针和大小参数的接口潜在问题的绝佳解决方案。
- en: Function-to-pointer conversion
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数到指针的转换
- en: 'A function can be implicitly converted to a pointer to that function. The following
    example demonstrates this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以被隐式转换为该函数的指针。以下示例演示了这一点：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the example above, we assign the function `print_hello` to a function pointer
    `fptr`. In C++, we don’t need to use the address-off operator with a function
    name to assign it to a function pointer. Also, we don’t need to dereference a
    function pointer when making a call to a function through it. Still, `print_hello`
    and `fptr` are two different types and we confirm this using the `static_assert`
    and `is_same` type traits.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们将函数 `print_hello` 赋值给函数指针 `fptr`。在 C++ 中，我们不需要使用地址运算符与函数名一起使用来将其赋值给函数指针。同样，我们不需要取消引用函数指针来通过它调用函数。尽管如此，`print_hello`
    和 `fptr` 是两种不同的类型，我们使用 `static_assert` 和 `is_same` 类型特性来确认这一点。
- en: Implicit conversions in C++ make writing the code easier. They can sometimes
    lead to undesired behavior and potential issues with our program. To mitigate
    these concerns, we can explicitly convert types when needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的隐式转换使编写代码更加容易。有时它们可能导致不期望的行为和程序中的潜在问题。为了减轻这些担忧，我们可以在需要时显式转换类型。
- en: Next, we will cover explicit conversion.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍显式转换。
- en: Explicit conversion
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式转换
- en: 'C++ supports C-style cast explicit conversion, but also functional-style cast
    and the following casting operators:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 支持使用 C 风格的类型转换显式转换，也支持函数式类型转换和以下类型转换运算符：
- en: '`const_cast`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_cast`'
- en: '`static_cast`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_cast`'
- en: '`dynamic_cast`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic_cast`'
- en: '`reinterpret_cast`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast`'
- en: We will go through casting operators, starting with `const_cast`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍类型转换运算符，从 `const_cast` 开始。
- en: const_cast
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: const_cast
- en: '`const_cast` is used to cast away constness to work with non-const-correct
    functions. We will go through the following example to better understand it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_cast` 用于移除 const 属性以与非 const 正确函数一起工作。我们将通过以下示例来更好地理解它：'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above example, we used `const_cast` in two different scenarios. We first
    used it to cast away constness from `const int num` to be able to pass it to the
    `print_num` function. The `print_num` function has a single parameter – a non-const
    reference to an `int`. As we know that this function is not trying to modify the
    object that the reference is bound to, we decided to cast away constness so we
    can pass a reference to a const int to it without the compiler generating an error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用了 `const_cast` 在两种不同的场景中。我们首先使用它来从 `const int num` 中移除 const 属性，以便将其传递给
    `print_num` 函数。`print_num` 函数有一个单个参数 – 一个对 `int` 的非 const 引用。正如我们所知，这个函数不会尝试修改引用所绑定到的对象，因此我们决定移除
    const 属性，这样我们就可以将 const int 的引用传递给它，而不会导致编译器生成错误。
- en: 'Then, we used `const_cast` to cast away constness from the `num` to be able
    to assign it to non-const reference `num_ref`. If you run this example in Compiler
    Explorer, you will see the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了 `const_cast` 来从 `num` 中移除 const 属性，以便将其赋值给非 const 引用 `num_ref`。如果你在
    Compiler Explorer 中运行此示例，你将看到以下输出：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The program returned `42`, that is, the value of `num` is `42` even though we
    tried to set it to `16` through `num_ref`. This is due to the fact that modifying
    the const variable through a non-const reference or a pointer is undefined behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 程序返回了 `42`，也就是说，`num` 的值是 `42`，尽管我们试图通过 `num_ref` 将其设置为 `16`。这是因为通过非 const 引用或指针修改
    const 变量是未定义的行为。
- en: '`const_cast` is used mostly to interface with non-const correct functions.
    Still, this is dangerous and should be avoided as we can’t guarantee that the
    function we are passing a const-cast-away pointer or a reference will not try
    to modify the object that the pointer is pointing to or the reference it is bound
    to. Next, we will cover `static_cast`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_cast` 主要用于与非 const 正确函数接口。尽管如此，这很危险，应该避免使用，因为我们无法保证我们传递给 const-cast-away
    指针或引用的函数不会尝试修改指针所指向的对象或引用所绑定到的对象。接下来，我们将介绍 `static_cast`。'
- en: static_cast
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: static_cast
- en: 'The most used cast operator in C++ is `static_cast`, and it is used in the
    following scenarios:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，最常用的类型转换运算符是 `static_cast`，它用于以下场景：
- en: To upcast and downcast a pointer of base class to derived class and vice versa
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基类指针向上转换为派生类指针，或将派生类指针向下转换为基类指针
- en: To discard a value expression
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要丢弃一个值表达式
- en: To convert between types with well-known conversion paths such as int to float,
    `enum` to an `int`, int to an `enum`, and similar
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已知转换路径的类型之间进行转换，例如 int 到 float，`enum` 到 int，int 到 `enum` 等
- en: 'We will go through several usages of `static_cast` using the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下示例来介绍 `static_cast` 的几种用法：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we run the above example, we will get the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上面的示例，我们将得到以下输出：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the above example, we used `static_cast` to convert an `unsigned int` to
    a signed `int`, which helps mitigate the issue of comparing integers with mixed
    signs introduced by implicit conversion. Still, we would need to make sure that
    the conversion is safe as `static_cast` doesn’t do any runtime checks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用 `static_cast` 将 `unsigned int` 转换为有符号的 `int`，这有助于缓解由隐式转换引入的混合符号整数比较问题。然而，我们仍需要确保转换是安全的，因为
    `static_cast` 不会进行任何运行时检查。
- en: Using `static_cast` to cast the variable `c` to void is a technique used to
    suppress compiler warnings about unused variables. It indicates that we are aware
    of the variable, but we intentionally do not use it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `static_cast` 将变量 `c` 转换为 `void` 是一种用于抑制编译器关于未使用变量警告的技术。这表明我们了解该变量，但我们故意不使用它。
- en: In the other part of the above example, we can see that an address to an object
    of the `Derived` class can be implicitly converted to a pointer of the `Base`
    class. If we call a function `hi` on the pointer of the Base class which is pointing
    to an object of the Derived class, we will actually make a call to a `hi` function
    defined in the `Base` class. Then we used `static_cast` to downcast `Base` pointer
    to a `Derived` pointer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例的另一部分中，我们可以看到 `Derived` 类对象的地址可以隐式转换为 `Base` 类指针。如果我们在一个指向 `Derived` 类对象的
    `Base` 类指针上调用函数 `hi`，我们实际上会调用在 `Base` 类中定义的 `hi` 函数。然后我们使用 `static_cast` 将 `Base`
    指针向下转型为 `Derived` 指针。
- en: 'Down-casting using `static_cast` can be dangerous as `static_cast` doesn’t
    do any runtime checks to make sure that the pointer is actually pointing to the
    converting type. An object of the `Derived` class is also an object of the `Base`
    class, but the reverse is not true – `Base` is not `Derived`. The following example
    demonstrates why this is dangerous:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `static_cast` 进行向下转型可能很危险，因为 `static_cast` 不会进行任何运行时检查以确保指针实际上指向转换的类型。`Derived`
    类的对象也是 `Base` 类的对象，但反之则不成立——`Base` 不是 `Derived`。以下示例演示了为什么这很危险：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this code, we are trying to access member `x` of the `Derived` class on
    an object of the base class. As we used `static_cast`, the compiler will not complain
    and this will result in undefined behavior, as the base class doesn’t have member
    `x`. One of the possible outputs of this program is shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们试图在基类对象上访问 `Derived` 类的成员 `x`。由于我们使用了 `static_cast`，编译器将不会报错，这将导致未定义行为，因为基类没有成员
    `x`。该程序的可能输出如下所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To avoid this problem, we can use `dynamic_cast`, which we will cover next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们可以使用 `dynamic_cast`，我们将在下一节中介绍。
- en: dynamic_cast
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dynamic_cast
- en: '`dynamic_cast` performs runtime checks of types and sets the result to `nullptr`
    in case the `Base` pointer doesn’t actually point to an object of the `Derived`
    class. We will go through an example to better understand it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic_cast` 执行类型的运行时检查，并在 `Base` 指针实际上不指向 `Derived` 类对象的情况下将结果设置为 `nullptr`。我们将通过一个示例来更好地理解它：'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the above example, we have a function `process` with a pointer to Base as
    a parameter. The function uses `dynamic_cast` to downcast the `Base` pointer to
    a `Derived` pointer. In the **if statement with initializer**, we initialize `ptr`
    with the result of `dynamic_cast<Derived*>` on a `Base` pointer. In the condition
    of the `if` statement, we check if `ptr` is different from `nullptr`, and if it
    is we can safely use it as a pointer to an object of the `Derived` class. Next,
    we will cover `reinterpret_cast`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们有一个带有 `Base` 类指针参数的 `process` 函数。该函数使用 `dynamic_cast` 将 `Base` 指针向下转型为
    `Derived` 指针。在带有初始化器的 **if 语句** 中，我们使用 `dynamic_cast<Derived*>` 对 `Base` 指针的结果初始化
    `ptr`。在 `if` 语句的条件中，我们检查 `ptr` 是否与 `nullptr` 不同，如果是，则可以安全地将其用作指向 `Derived` 类对象的指针。接下来，我们将介绍
    `reinterpret_cast`。
- en: reinterpret_cast
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reinterpret_cast
- en: '`reinterpret_cast` is used to convert between types by reinterpreting the underlying
    bits. It can be used in the following situations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast` 用于通过重新解释底层位来在类型之间进行转换。它可以在以下情况下使用：'
- en: To convert a pointer to an integer large enough to hold all of its values.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指针转换为足够大的整数，以容纳其所有值。
- en: To convert a value of an integer to a pointer. A pointer converted to an integer
    and back to its original type is guaranteed to have the original value and can
    be dereferenced safely.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整数值转换为指针。将指针转换为整数再转换回其原始类型保证具有原始值，并且可以安全地解引用。
- en: To convert pointers between different types, such as between `T1` and `T2`.
    The resulting pointer to `T2` can be dereferenced safely only if the resulting
    pointer is `char`, `unsigned char`, `std::byte`, or `T1`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在不同类型之间转换指针，例如在 `T1` 和 `T2` 之间。只有当结果指针是 `char`、`unsigned char`、`std::byte`
    或 `T1` 时，指向 `T2` 的结果指针才能安全地解引用。
- en: To convert a function pointer `F1` to a pointer to a different function `F2`.
    Converting `F2` back to `F1` will result in the pointer to `F1`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将函数指针 `F1` 转换为指向不同函数 `F2` 的指针。将 `F2` 转换回 `F1` 将导致指向 `F1` 的指针。
- en: 'To better understand `reinterpret_cast`, we will go through the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 `reinterpret_cast`，我们将通过以下示例：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can run the above example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的 GitHub 仓库运行上述示例。它位于 `Chapter09/type_safety` 目录下，您可以使用以下命令构建和运行它：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the example in Renode will provide the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Renode 中运行示例将提供以下输出：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The above example demonstrates the usage of `reinterpret_cast`. We first initialized
    a pointer to an int using the address of a float using `reinterpret_cast<int*>(&f)`.
    This is equivalent to using `static_cast` as `static_cast<int*>(static_cast<void*>(&f))`.
    We print the value of the dereference integer pointer, and it is `1078523331`.
    This is an actual bit pattern contained in the `float` variable `f`. It is an
    IEEE-754 floating point representation of `3.14`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了 `reinterpret_cast` 的用法。我们首先使用 `reinterpret_cast<int*>(&f)` 通过浮点地址初始化了一个指向整数的指针，这相当于使用
    `static_cast`，即 `static_cast<int*>(static_cast<void*>(&f))`。我们打印了解引用整型指针的值，它是
    `1078523331`。这是 `float` 变量 `f` 中包含的实际位模式。它是 `3.14` 的 IEEE-754 浮点表示。
- en: However, dereferencing the integer pointer initialized by an address of a float
    is not a defined behavior according to the C++ standard. This is called **type
    punning** – treating an object of one type as if it were another type. Using `reinterpet_cast`
    for type punning is common, as it proved to yield expected results on most platforms
    despite the undefined behavior. There are alternatives that we will discuss after
    going through this example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据 C++ 标准，使用浮点地址初始化的整型指针的解引用不是定义良好的行为。这被称为**类型欺骗**——将一个类型的对象当作另一个类型处理。使用
    `reinterpret_cast` 进行类型欺骗是常见的，尽管它引入了未定义的行为，但在大多数平台上它确实产生了预期的结果。在通过这个示例之后，我们将讨论替代方案。
- en: If we cast the pointer to the integer back to a pointer to a float, it is safe
    to dereference the resulting pointer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将指向整数的指针转换回指向浮点数的指针，则可以安全地解引用结果指针。
- en: Next, we converted the pointer to float to an integer to print the address it
    contains. We used `std::uintptr_t`, an integer type that is capable of holding
    a pointer to `void`. Following this, we initialized `fun_void_ptr` – a pointer
    to a function that returns `void` with function `fun`, which returns `int`. We
    made a call on the `fun_void_ptr` pointer, which printed the expected output,
    but it is still undefined. Converting `fun_void_ptr` to a pointer that matches
    the signature of function `fun` – `fun_int_ptr` – will make calling fun through
    the resulting pointer safe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指针转换为浮点整数以打印它包含的地址。我们使用了 `std::uintptr_t`，这是一种能够容纳指向 `void` 的指针的整型。在此之后，我们初始化了
    `fun_void_ptr` —— 一个指向返回 `void` 的函数的指针，该函数名为 `fun`，它返回 `int`。我们对 `fun_void_ptr`
    指针进行了调用，它打印了预期的输出，但仍然是未定义的。将 `fun_void_ptr` 转换为与函数 `fun` 签名匹配的指针——`fun_int_ptr`——将使通过结果指针调用
    `fun` 变得安全。
- en: Next, we will go through type punning in C++ and the alternatives to using `reinterpret_cast`
    for this task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过 C++ 中的类型欺骗和替代方案来使用 `reinterpret_cast`。
- en: Type punning
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型欺骗
- en: Using `reinterpret_cast` for type punning is a common practice even though it
    introduces undefined behavior. Aliasing rules determine how we can access an object
    in C++, and to put it simply, we can access an object through a pointer and const
    qualified version of that pointer, a struct or union that contains the object,
    and through a `char`, `unsigned char`, and `std::byte`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 `reinterpret_cast` 进行类型欺骗是常见的做法，尽管它引入了未定义的行为。别名规则决定了我们在 C++ 中如何访问一个对象，简单来说，我们可以通过一个指针及其
    const 版本、包含该对象的 struct 或 union 以及通过 `char`、`unsigned char` 和 `std::byte` 来访问一个对象。
- en: 'We will go through the following example to better understand type punning
    in C++:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下示例来更好地理解 C++ 中的类型欺骗：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can run the above example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的 GitHub 仓库运行上述示例。它位于 `Chapter09/type_safety` 目录下，您可以使用以下命令构建和运行它：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the example in Renode will provide the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Renode 中运行示例将提供以下输出：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the example above, we used `reinterpret_cast` to treat an integer `i` as
    an array of `chars`. By checking the value pointed by the first element of the
    mentioned array, we can determine if we are on a big or little-endian system.
    As per the aliasing rules, this is a valid approach, but treating an array of
    `chars` as some other type would be undefined behavior. We did that in the function
    void `process_data` where we reinterpreted an array of `chars` as an array of
    `my_struct` objects. The output of the program is as we would expect it, even
    though we introduced undefined behavior. To mitigate this issue, we can use `std::memcpy`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用了 `reinterpret_cast` 将整数 `i` 作为 `chars` 数组来处理。通过检查所提及数组第一个元素的值，我们可以确定我们是在大端还是小端系统上。根据别名规则，这是一种有效的方法，但将
    `chars` 数组作为其他类型处理将是未定义的行为。我们在 `void process_data` 函数中这样做，在该函数中我们将 `chars` 数组重新解释为
    `my_struct` 对象的数组。程序输出正如我们所预期的那样，尽管我们引入了未定义的行为。为了减轻这个问题，我们可以使用 `std::memcpy`。
- en: Type punning – the correct way
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换 - 正确的方法
- en: Using `std::memcpy` is the only (as of C++23) available option for type punning
    in C++. In the above example, we demonstrate this in the `process_data_memcpy`
    function. There is usually a concern of bytes being copied, using additional memory
    and runtime overhead, but the fact is that the call to `memcpy` is usually optimized
    away by a compiler. You can verify this by running the above example in Compiler
    Explorer and by experimenting with different optimization levels.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::memcpy` 是 C++ 中类型转换的唯一（截至 C++23）可用选项。在上面的示例中，我们在 `process_data_memcpy`
    函数中展示了这一点。通常会有关于字节复制的担忧，使用额外的内存和运行时开销，但事实是 `memcpy` 的调用通常会被编译器优化掉。您可以通过在 Compiler
    Explorer 中运行上述示例并尝试不同的优化级别来验证这一点。
- en: 'C++20 introduces `std::bit_cast`, which can also be used for type punning,
    as in the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了 `std::bit_cast`，它也可以用于类型转换，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the above program is:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序输出如下：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The above example and the program output demonstrate the usage of `std::bit_cast`
    for type punning. The `std::bit_cast` will return an object. We specify the type
    that we are converting to as the template argument. This will also be the return
    type of the `std::bit_cast`. The size of the converting type and the type we are
    converting to must be the same. This means `std::bit_cast` is not an option for
    interpreting arrays of one type as arrays of another type, and for that we still
    need to use `std::memcpy`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例和程序输出展示了 `std::bit_cast` 用于类型转换的用法。`std::bit_cast` 将返回一个对象。我们指定要转换到的类型作为模板参数。这将是
    `std::bit_cast` 的返回类型。转换类型的尺寸和我们转换到的类型必须相同。这意味着 `std::bit_cast` 不是一个将一种类型的数组解释为另一种类型数组的选项，为此我们仍然需要使用
    `std::memcpy`。
- en: Next, we will see how we can use strong types in C++ to increase type safety.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用 C++ 中的强类型来提高类型安全性。
- en: Strong types
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型
- en: 'When we talk about type-safety, we should also discuss the safety of interfaces
    that use commonly available types such as integers and floats to represent physical
    units such as time, length, and volume. Let us take a look at the following function
    from a vendor’s SDK:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论类型安全性时，我们也应该讨论使用常用类型（如整数和浮点数）来表示物理单位（如时间、长度和体积）的接口的安全性。让我们看看以下来自供应商 SDK
    的函数：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a well-documented function. Still, it takes a lot of effort to understand
    all the parameters that it accepts and the exact units of each. Most of the parameters
    represent time but in a different way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个文档良好的函数。尽管如此，理解它接受的参数及其确切单位仍然需要大量的努力。大多数参数代表时间，但以不同的方式表示。
- en: '`LE_Scan_Interval`, `LE_Scan_Window`, `Conn_Interval_Min`, `Conn_Interval_Max`,
    `Supervision_Timeout`, `Minimum_CE_Length`, and `Maximum_CE_Length` are all time-related
    parameters, but they represent different units. They are either multiples of 0.625,
    1.25, or 10 ms. The vendor of the above function also provided the following macros:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`LE_Scan_Interval`、`LE_Scan_Window`、`Conn_Interval_Min`、`Conn_Interval_Max`、`Supervision_Timeout`、`Minimum_CE_Length`
    和 `Maximum_CE_Length` 都是时间相关的参数，但它们代表不同的单位。它们是 0.625、1.25 或 10 毫秒的倍数。上述函数的供应商还提供了以下宏：'
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is an example of a call to the above function using the provided macros:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用提供的宏调用上述函数的示例：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The macros help a bit with readability, but the problem of passing bad values
    to this function still remains. It is fairly easy to make a mistake, swap the
    `CONN_L` and `CONN_P` macros, and introduce a hard-to-find bug to the program.
    Instead of `uint16_t`, we could define and use types `conn_l` and `conn_p`. If
    we wrap the function with these amendments, we will have the following wrapper
    function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 宏定义有助于提高可读性，但向此函数传递错误值的问题仍然存在。很容易出错，交换`CONN_L`和`CONN_P`宏，从而在程序中引入难以发现的错误。我们本可以用`uint16_t`，但可以定义并使用类型`conn_l`和`conn_p`。如果我们用这些修正来包装函数，我们将得到以下包装函数：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the above example, we are using `conn_l` and `conn_p` types instead of `uint16_t`,
    and we will define these types as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用`conn_l`和`conn_p`类型而不是`uint16_t`，我们将如下定义这些类型：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the above strong types `conn_l` and `conn_p`, we can call the wrapper
    function as shown below:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述强类型`conn_l`和`conn_p`，我们可以像下面这样调用包装函数：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By using the keyword explicit in front of constructors of types `conn_l` and
    `conn_p`, we make sure that the compiler doesn’t perform implicit conversion from
    integer types. This makes it impossible to pass an integer or a float that can
    be used to construct `conn_l` and `conn_p` to the `aci_gap_create_connection_wrapper`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`conn_l`和`conn_p`类型的构造函数前使用关键字`explicit`，我们确保编译器不会从整数类型进行隐式转换。这使得无法传递可以用来构造`conn_l`和`conn_p`的整数或浮点数到`aci_gap_create_connection_wrapper`。
- en: 'You can run the entire example from the book’s GitHub repo. It is placed under
    `Chapter09/type_safety` and you can build and run it using the following commands:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从书的GitHub仓库运行整个示例。它位于`Chapter09/type_safety`下，您可以使用以下命令构建和运行它：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Compiling the example successfully means that we passed all the correct arguments
    to `aci_gap_create_connection_wrapper`. As an exercise, try passing integer values
    instead of `conn_l` and `conn_p` arguments to see how they prevent the compiler
    from doing implicit conversions. After that, try removing the `explicit` keyword
    from the `conn_l` and `conn_p` constructors to see what will happen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 成功编译示例意味着我们向`aci_gap_create_connection_wrapper`传递了所有正确的参数。作为一个练习，尝试用整数值而不是`conn_l`和`conn_p`参数来传递，看看它们如何阻止编译器进行隐式转换。之后，尝试从`conn_l`和`conn_p`构造函数中移除`explicit`关键字，看看会发生什么。
- en: 'We can further improve the example by introducing a strong-type `time` that
    will represent the time duration, and make it a private member of types `conn_l`
    and `conn_p`. The code would look as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引入一个表示时间持续时间的强类型`time`来进一步改进示例，并将其作为`conn_l`和`conn_p`类型的私有成员。代码将如下所示：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the above example, we created a strong-type time and used it as a private
    member in types `conn_l` and `conn_p`. We also created a user-defined literal
    with `operator""_ms` to make the following function call possible:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们创建了一个强类型时间，并将其用作`conn_l`和`conn_p`类型的私有成员。我们还使用`operator""_ms`创建了一个用户定义字面量，以使以下函数调用成为可能：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the above example, we are using the user-defined literal `operator""_ms`
    to create objects of strong-type time that are used to instantiate conn_l and
    conn_p objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用用户定义字面量`operator""_ms`来创建强类型时间的对象，这些对象用于实例化`conn_l`和`conn_p`对象。
- en: The above changes to the original interface improve code readability and compile-time
    error detection. Using strong types, we make it a lot harder to pass wrong values
    to the function, increasing the type-safety of our codebase.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以上对原始接口的更改提高了代码的可读性和编译时错误检测。使用强类型，我们使向函数传递错误值变得更加困难，从而增加了代码库的类型安全性。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Type safety is an important aspect of any programming language used in critical
    applications. Understanding potential issues of implicit conversion is important
    to mitigate type-safety concerns. Type punning is another area that deserves special
    attention in C++, and we learned how to address it properly. We also learned how
    to use strong types to mitigate issues of passing wrong values to parameters with
    the same types.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全性是任何用于关键应用的编程语言的重要方面。理解隐式转换的潜在问题对于减轻类型安全性问题至关重要。类型欺骗是C++中另一个值得特别注意的领域，我们学习了如何正确处理它。我们还学习了如何使用强类型来减轻向具有相同类型的参数传递错误值的问题。
- en: Next, we will cover lambdas in C++.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍C++中的lambda表达式。
- en: Join our community on Discord
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_code_Discord.png)'
