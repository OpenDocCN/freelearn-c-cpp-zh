["```cpp\nUCLASS()\nclass MASTERING_API AMasteringIconCamera : public ACameraActor\n{\n        GENERATED_BODY()\n\npublic:\n        virtual void BeginPlay() override;\n\nprotected:\n\n        virtual void TakeShot();\n        virtual void SpawnAndPlaceNextActor();\n        virtual FVector ComputeActorLocation();\n        virtual void OnFinishedLoadingAssets();\n\n        UPROPERTY(Transient)\n        TArray<FSoftObjectPath> WeaponBlueprintSoftRefs;\n        UPROPERTY(Transient)\n        TArray<class UBlueprint*> WeaponBlueprints;\n\n        UPROPERTY(Transient)\n        class UBlueprint* CurrentWeaponBlueprint = nullptr;\n        UPROPERTY(Transient)\n        class AMasteringWeaponPickup* CurrentWeaponPickup = nullptr;\n        UPROPERTY(Transient)\n        class UCameraComponent* CameraComp;\n        UPROPERTY(Transient)\n        bool bInitialied = false;\n\n        UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        FString WeaponsPath = \"FirstPersonCPP/Blueprints/Weapons\";\n\n        UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        float ShotDelay = 0.4f;\n        UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        int ScreenshotResolutionX = 256;\n        UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        int ScreenshotResolutionY = 256;\n\n        int CurrentWeaponIndex = 0;\n};\n```", "```cpp\nvoid AMasteringIconCamera::BeginPlay()\n{\n        if (bInitialied)\n        {\n                return; // BeginPlay will get called multiple times at \n                level start\n        }\n\n        bInitialied = true;\n\n        CameraComp = GetCameraComponent();\n\n        UWorld* World = GetWorld();\n        check(World != nullptr);\n        APlayerController* Player = World->GetFirstPlayerController();\n\n        Player->SetCinematicMode(true, true, true, true, true);\n\n        Player->SetViewTarget(this);\n\n        FString contentPath = FString(\"/Game/\") + WeaponsPath;\n\n        static UObjectLibrary* ObjectLibrary = nullptr;\n        ObjectLibrary = UObjectLibrary::CreateLibrary(AMasteringWeaponPickup::StaticClass(), false, GIsEditor);\n        ObjectLibrary->AddToRoot();\n        ObjectLibrary->bHasBlueprintClasses = true;\n\n        ObjectLibrary->LoadBlueprintAssetDataFromPath(contentPath);\n\n        TArray<FAssetData> AssetDatas;\n        ObjectLibrary->GetAssetDataList(AssetDatas);\n\n        for (auto itr : AssetDatas)\n        {\n                FSoftObjectPath assetPath(itr.ObjectPath.ToString());\n                WeaponBlueprintSoftRefs.Add(assetPath);\n        }\n\n        // Here we stream in the assets found that are weapon pick-ups and when done, will call the OnFinished function\n        FStreamableManager& Streamable = UAssetManager::GetStreamableManager();\n        Streamable.RequestAsyncLoad(WeaponBlueprintSoftRefs, FStreamableDelegate::CreateUObject(this, &AMasteringIconCamera::OnFinishedLoadingAssets));\n}\n```", "```cpp\nvoid AMasteringIconCamera::OnFinishedLoadingAssets()\n{\n        UWorld* World = GetWorld();\n\n        for (auto itr = WeaponBlueprintSoftRefs.CreateIterator(); itr; \n        ++itr)\n        {\n                UBlueprint *BPObj = CastChecked<UBlueprint>((*itr).ResolveObject());\n                WeaponBlueprints.Add(BPObj);\n        }\n\n        SpawnAndPlaceNextActor(); // this spawns our first pickup and increments CurrentWeaponIndex to 1\n\n        static FTimerHandle ScreenShotTimer;\n        World->GetTimerManager().SetTimer(ScreenShotTimer, [=] {\n                        if (CurrentWeaponIndex == 0) // only way we come in at index 0 is if we're done\n                        {\n                                World->GetTimerManager().ClearTimer(ScreenShotTimer);\n                                                                if (APlayerController* Player = UGameplayStatics::GetPlayerController(World, 0))\n                                {\n                                        Player->ConsoleCommand(TEXT(\"Exit\"), true);\n                                        return;\n                                }\n                        }\n\n                        TakeShot();\n                },\n                ShotDelay, true, ShotDelay);\n}\n```", "```cpp\nvoid AMasteringIconCamera::TakeShot()\n{\n        UWorld* World = GetWorld();\n\n        check(CurrentWeaponPickup != nullptr);\n\n        UMeshComponent* Mesh = Cast<UMeshComponent>(CurrentWeaponPickup->GetComponentByClass(UMeshComponent::StaticClass()));\n        check(Mesh != nullptr);\n\n        Mesh->bForceMipStreaming = true;\n\n        Mesh->SetRenderCustomDepth(true);\n\n        GScreenshotResolutionX = ScreenshotResolutionX;\n        GScreenshotResolutionY = ScreenshotResolutionY;\n\n        GetHighResScreenshotConfig().SetHDRCapture(true);\n        GetHighResScreenshotConfig().bMaskEnabled = true;\n        World->GetGameViewport()->Viewport->TakeHighResScreenShot();\n\n        // this timer is here to wait just one frame (hence the tiny time) and then destroy the current actor\n        // and spawn the next one: if you destroy the actor the same frame as the screenshot it may not appear\n        FTimerHandle SpawnNextTimer;\n        World->GetTimerManager().SetTimer(SpawnNextTimer, [this] {\n                if (CurrentWeaponIndex >= WeaponBlueprints.Num())\n                {\n                        CurrentWeaponIndex = 0; // we have finished, this will break our timer loop on its next trigger\n                }\n                else\n                {\n                        SpawnAndPlaceNextActor();\n                }\n        },\n        0.001f, false);\n}\n```", "```cpp\nvoid AMasteringIconCamera::SpawnAndPlaceNextActor()\n{\n        if (CurrentWeaponPickup != nullptr)\n                CurrentWeaponPickup->Destroy();\n\n        CurrentWeaponBlueprint = WeaponBlueprints[CurrentWeaponIndex];\n        check(CurrentWeaponBlueprint != nullptr); // anything not a blueprint should never find its way into our list\n\n        UWorld* World = GetWorld();\n\n        FRotator Rot(0.0f);\n        FVector Trans(0.0f);\n\n        FTransform Transform(Rot, Trans);\n        FActorSpawnParameters ActorSpawnParams;\n        ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n        CurrentWeaponPickup = World->SpawnActor<AMasteringWeaponPickup>(CurrentWeaponBlueprint->GeneratedClass, Transform, ActorSpawnParams);\n        CurrentWeaponPickup->RotationSpeed = 0.0f; // the ones we use for screenshots we don't want spinning!\n        check(CurrentWeaponPickup != nullptr);\n\n        FVector Pos = ComputeActorLocation();\n        CurrentWeaponPickup->SetActorLocation(Pos);\n\n        CurrentWeaponIndex++;\n}\n```", "```cpp\nFVector AMasteringIconCamera::ComputeActorLocation()\n{\n        check(CurrentWeaponPickup != nullptr);\n        UMeshComponent* Mesh = Cast<UMeshComponent>(CurrentWeaponPickup->GetComponentByClass(UMeshComponent::StaticClass()));\n\n        FVector InPos;\n        FVector BoxExtent;\n        CurrentWeaponPickup->GetActorBounds(false, InPos, BoxExtent);\n\n        // uncomment these to view the actor bounding generated for our pick-ups\n        /*FVector CurrentPosition = CurrentWeaponPickup->GetActorLocation();\n  FColor fcRandom(FMath::RandRange(64, 255), FMath::RandRange(64, 255), FMath::RandRange(64, 255));\n  DrawDebugLine(World, CurrentPosition, CurrentPosition + InPos, fcRandom, false, 20.0f);\n  DrawDebugBox(World, CurrentPosition + InPos, 0.5f * BoxExtent, FQuat(ForceInitToZero), fcRandom, false, 20.0f);*/\n\n        // uncomment these to view the mesh bounding imported with the \nassets\n        /*FBoxSphereBounds bsMesh = Mesh->Bounds;\n  DrawDebugLine(World, CurrentPosition, bsMesh.Origin, fcRandom, false, 20.0f);\n  DrawDebugBox(World, bsMesh.Origin, 0.5f * bsMesh.BoxExtent, FQuat(ForceInitToZero), fcRandom, false, 20.0f);*/\n\n        const float fX = BoxExtent.X;\n        const float fY = BoxExtent.Y;\n        const float fZ = BoxExtent.Z;\n\n        if (fX > fY)\n        {\n                FRotator YawRot(0.0f, 90.0f, 0.0f);\n                CurrentWeaponPickup->SetActorRotation(YawRot);\n        }\n\n        const float fLongestBoxSide = FMath::Max(fX, FMath::Max(fY, \n        fZ));\n\n        // FOV is the whole frustum FOV, to make a right triangle down its middle, we use half this angle\n        const float FOVhalf = 0.5f * CameraComp->FieldOfView;\n        const float FOVradians = FOVhalf * PI / 180.0f;\n\n        const float FOVtan = FMath::Tan(FOVradians);\n\n        float XDistance = fLongestBoxSide / FOVtan;\n\n        FVector Positioning(XDistance, 0.0f, 0.0f);\n\n        return CurrentWeaponPickup->GetActorLocation() + Positioning - InPos;\n}\n```", "```cpp\nUCLASS()\nclass MASTERING_API UMasteringInventoryDisplay : public UUserWidget\n{\n        GENERATED_BODY()\n\npublic:\n        virtual void Init(class UMasteringInventory* Inventory);\n\n        UFUNCTION(BlueprintImplementableEvent, Category = Inventory)\n        void WeaponSelected(FWeaponProperties Weapon);\n\n        UFUNCTION(BlueprintImplementableEvent, Category = Inventory)\n        void WeaponAdded(FWeaponProperties Weapon);\n\n        UFUNCTION(BlueprintImplementableEvent, Category = Inventory)\n        void WeaponRemoved(FWeaponProperties Weapon);\n};\n```", "```cpp\nvoid UMasteringInventoryDisplay::Init(class UMasteringInventory* Inventory)\n{\n        Inventory->OnSelectedWeaponChanged.AddUObject(this, &UMasteringInventoryDisplay::WeaponSelected);\n        Inventory->OnWeaponAdded.AddUObject(this, &UMasteringInventoryDisplay::WeaponAdded);\n        Inventory->OnWeaponRemoved.AddUObject(this, &UMasteringInventoryDisplay::WeaponRemoved);\n}\n```", "```cpp\nDECLARE_EVENT_OneParam(UMasteringInventory, FSelectedWeaponChanged, FWeaponProperties);\nFSelectedWeaponChanged OnSelectedWeaponChanged;\n\nDECLARE_EVENT_OneParam(UMasteringInventory, FWeaponAdded, FWeaponProperties);\nFSelectedWeaponChanged OnWeaponAdded;\n\nDECLARE_EVENT_OneParam(UMasteringInventory, FWeaponRemoved, FWeaponProperties);\nFSelectedWeaponChanged OnWeaponRemoved;\n```", "```cpp\nvoid UMasteringInventory::SelectWeapon(FWeaponProperties Weapon)\n{\n        OnSelectedWeaponChanged.Broadcast(Weapon);\n\n        MyOwner->EquipWeapon(Weapon.WeaponClass);\n        CurrentWeapon = Weapon.WeaponClass;\n}\n```", "```cpp\n+ PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"HeadMountedDisplay\", \"UMG\" });\n```", "```cpp\nUCLASS()\nclass MASTERING_API UMainMenuWidget : public UUserWidget\n{\n        GENERATED_BODY()\n\npublic:\n        UFUNCTION(BlueprintCallable)\n        void LoadGame(FName SaveFile);\n\n        UFUNCTION(BlueprintCallable)\n        void SaveGame();\n\n        UFUNCTION(BlueprintCallable)\n        void Open();\n\n        UFUNCTION(BlueprintCallable)\n        void Close();\n};\n```", "```cpp\nAMasteringHUD* HUD = Cast<AMasteringHUD>(CastChecked<APlayerController>(GetController())->GetHUD());\n\nvoid AMasteringHUD::ToggleMainMenu()\n{\n        if (MainMenu != nullptr)\n        {\n                if (MainMenu->GetVisibility() == ESlateVisibility::Visible)\n                        MainMenu->Close();\n                else\n                        MainMenu->Open();\n        }\n}\n```", "```cpp\nvoid UMainMenuWidget::Open()\n{\n        checkSlow(GetVisibility() == ESlateVisibility::Hidden); // only want to open from closed\n        SetVisibility(ESlateVisibility::Visible);\n\n        UWorld* World = GetWorld();\n        if (World != nullptr)\n        {\n                APlayerController* playerController = World->GetFirstPlayerController();\n                if (playerController)\n                {\n                        playerController->bShowMouseCursor = true;\n                        FInputModeUIOnly InputMode;\n                        playerController->SetInputMode(InputMode);\n                        UGameplayStatics::SetGamePaused(this, true);\n                }\n        }\n}\n```", "```cpp\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Serialization/ObjectAndNameAsStringProxyArchive.h\"\n#include \"Inventory/MasteringInventory.h\"\n#include \"SavedActorInterface.generated.h\"\n\n/**\n * \n */\nUSTRUCT()\nstruct FActorSavedData\n{\n        GENERATED_USTRUCT_BODY()\n\n        FString MyClass;\n        FTransform MyTransform;\n        FVector MyVelocity;\n        FName MyName;\n        TArray<uint8> MyData;\n\n        friend FArchive& operator<<(FArchive& Ar, FActorSavedData& SavedData)\n        {\n                Ar << SavedData.MyClass;\n                Ar << SavedData.MyTransform;\n                Ar << SavedData.MyVelocity;\n                Ar << SavedData.MyName;\n                Ar << SavedData.MyData;\n                return Ar;\n        }\n};\n\nUSTRUCT()\nstruct FInventoryItemData\n{\n        GENERATED_USTRUCT_BODY()\n\n        FString WeaponClass;\n        int WeaponPower;\n        int Ammo;\n        FString TextureClass;\n\n        friend FArchive& operator<<(FArchive& Ar, FInventoryItemData& InvItemData)\n        {\n                Ar << InvItemData.WeaponClass;\n                Ar << InvItemData.WeaponPower;\n                Ar << InvItemData.Ammo;\n                Ar << InvItemData.TextureClass;\n                return Ar;\n        }\n};\n\nUSTRUCT()\nstruct FInventorySaveData\n{\n        GENERATED_USTRUCT_BODY()\n\n        FString CurrentWeapon;\n        int CurrentWeaponPower = -1;\n        TArray<FInventoryItemData> WeaponsArray;\n\n        friend FArchive& operator<<(FArchive& Ar, FInventorySaveData& InvData)\n        {\n                Ar << InvData.CurrentWeapon;\n                Ar << InvData.CurrentWeaponPower;\n                Ar << InvData.WeaponsArray;\n                return Ar;\n        }\n};\n\nUSTRUCT()\nstruct FGameSavedData\n{\n        GENERATED_USTRUCT_BODY()\n\n        FDateTime Timestamp;\n        FName MapName;\n        FInventorySaveData InventoryData;\n        TArray<FActorSavedData> SavedActors;\n\n        friend FArchive& operator<<(FArchive& Ar, FGameSavedData& GameData)\n        {\n                Ar << GameData.MapName;\n                Ar << GameData.Timestamp;\n                Ar << GameData.InventoryData;\n                Ar << GameData.SavedActors;\n                return Ar;\n        }\n};\n\nstruct FSaveGameArchive : public FObjectAndNameAsStringProxyArchive\n{\n        FSaveGameArchive(FArchive& InInnerArchive)\n                : FObjectAndNameAsStringProxyArchive(InInnerArchive, true)\n        {\n                ArIsSaveGame = true;\n        }\n};\n\nUINTERFACE(BlueprintType)\nclass USavedActorInterface : public UInterface\n{\n        GENERATED_UINTERFACE_BODY()\n};\n\nclass ISavedActorInterface\n{\n        GENERATED_IINTERFACE_BODY()\n\npublic:\n        UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = \"Load-Save\")\n        void ActorLoaded();\n};\n```", "```cpp\nUCLASS()\nclass MASTERING_API UMainMenuWidget : public UUserWidget\n{\n        GENERATED_BODY()\n\npublic:\n        UFUNCTION(BlueprintCallable)\n        void LoadGame(FString SaveFile);\n\n        UFUNCTION(BlueprintCallable)\n        void SaveGame();\n\n        UFUNCTION(BlueprintCallable)\n        void Open();\n\n        UFUNCTION(BlueprintCallable)\n        void Close();\n\n        UFUNCTION(BlueprintCallable)\n        void PopulateSaveFiles();\n\n        void OnGameLoadedFixup(UWorld* World);\n        static TArray<uint8> BinaryData;\n\nprotected:\n        UPROPERTY(BlueprintReadOnly)\n        TArray<FString> SaveFileNames;\n};\n```", "```cpp\nvoid UMainMenuWidget::SaveGame()\n{\n        FGameSavedData SaveGameData;\n\n        SaveGameData.Timestamp = FDateTime::Now();\n\n        UWorld *World = GetWorld();\n        checkSlow(World != nullptr);\n\n        FString mapName = World->GetMapName();\n\n        mapName.Split(\"_\", nullptr, &mapName, ESearchCase::IgnoreCase, ESearchDir::FromEnd);\n\n        SaveGameData.MapName = *mapName;\n\n        TArray<AActor*> Actors;\n        UGameplayStatics::GetAllActorsWithInterface(GetWorld(), USavedActorInterface::StaticClass(), Actors);\n\n        TArray<FActorSavedData> SavedActors;\n        for (auto Actor : Actors)\n        {\n                FActorSavedData ActorRecord;\n                ActorRecord.MyName = FName(*Actor->GetName());\n                ActorRecord.MyClass = Actor->GetClass()->GetPathName();\n                ActorRecord.MyTransform = Actor->GetTransform();\n                ActorRecord.MyVelocity = Actor->GetVelocity();\n\n                FMemoryWriter MemoryWriter(ActorRecord.MyData, true);\n                FSaveGameArchive Ar(MemoryWriter);\n                AMasteringCharacter* Mast = Cast<AMasteringCharacter>(Actor);\n\n                Actor->Serialize(Ar);\n\n                if (Mast != nullptr)\n                {\n                        UMasteringInventory* Inv = Mast->GetInventory();\n                        SaveGameData.InventoryData.CurrentWeapon = Inv->GetCurrentWeapon()->GetPathName();\n                        SaveGameData.InventoryData.CurrentWeaponPower = Inv->GetCurrentWeaponPower();\n                        for (FWeaponProperties weapon : Inv->GetWeaponsArray())\n                        {\n                                FInventoryItemData data;\n                                data.WeaponClass = weapon.WeaponClass->GetPathName();\n                                data.WeaponPower = weapon.WeaponPower;\n                                data.Ammo = weapon.Ammo;\n                                data.TextureClass = weapon.InventoryIcon->GetPathName();\n\n                                SaveGameData.InventoryData.WeaponsArray.Add(data);\n                        }\n                }\n\n                SavedActors.Add(ActorRecord);\n        }\n\n        FBufferArchive BinaryData;\n\n        SaveGameData.SavedActors = SavedActors;\n\n        BinaryData << SaveGameData;\n\n        FString outPath = FPaths::ProjectSavedDir() + SaveGameData.Timestamp.ToString() + TEXT(\".sav\");\n\n        FFileHelper::SaveArrayToFile(BinaryData, *outPath);\n\n        BinaryData.FlushCache();\n        BinaryData.Empty();\n\n        APlayerController* playerController = World->GetFirstPlayerController();\n        if (playerController)\n        {\n                playerController->bShowMouseCursor = false;\n                FInputModeGameOnly InputMode;\n                playerController->SetInputMode(InputMode);\n                UGameplayStatics::SetGamePaused(this, false);\n        }\n\n        Close();\n}\n```", "```cpp\nvoid UMainMenuWidget::PopulateSaveFiles()\n{\n        FString dir = FPaths::ProjectSavedDir();\n        FString fileExt = TEXT(\"sav\");\n\n        IFileManager::Get().FindFiles(SaveFileNames, *dir, *fileExt);\n}\n```"]