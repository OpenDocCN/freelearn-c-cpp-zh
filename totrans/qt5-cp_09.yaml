- en: Chapter 9. Deploying Applications on Other Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 部署到其他设备上的应用程序
- en: 'After development, it''s time to distribute your application. We''ll use an
    example application, `Internationalization`, from the previous chapter to demonstrate
    how to spread your Qt application to Windows, Linux, and Android. The following
    topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发完成后，是时候分发你的应用程序了。我们将使用上一章中的示例应用程序`Internationalization`来演示如何将Qt应用程序推广到Windows、Linux和Android。本章将涵盖以下主题：
- en: Releasing Qt applications on Windows
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上发布Qt应用程序
- en: Creating an installer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建安装程序
- en: Packaging Qt applications on Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上打包Qt应用程序
- en: Deploying Qt applications on Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上部署Qt应用程序
- en: Releasing Qt applications on Windows
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上发布Qt应用程序
- en: After the development stage, you can build your application using `release`
    as the build configuration. In the `release` configuration, your compiler will
    optimize the code and won't produce debug symbols, which in turn reduces the size.
    Please ensure that the project is in the `release` configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段之后，你可以使用`release`作为构建配置来构建你的应用程序。在`release`配置中，编译器会对代码进行优化，并且不会产生调试符号，这反过来又减少了大小。请确保项目处于`release`配置。
- en: Before we jump into the packaging procedure, I'd like to talk about the difference
    between static and dynamic linking. You have probably been using dynamic linking
    of Qt libraries throughout this book. This can be confirmed if you download the
    **Community Edition** from the Qt website.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入包装过程之前，我想谈谈静态链接和动态链接之间的区别。你可能在这本书的整个过程中一直在使用Qt库的动态链接。如果你从Qt网站上下载**社区版**，这可以得到证实。
- en: So, what does dynamic linking mean? Well, it means that when an executable file
    gets executed, the operating system will load and link the necessary shared libraries
    at runtime. In other words, you'll see a lot of `.dll` files on Windows and `.so`
    files on the Unix platforms. This technique allows developers to update these
    shared libraries and the executable separately, which means that you don't need
    to rebuild the executable file if you change shared libraries, so long as their
    ABIs are compatible. Although this method is more flexible, developers are warned
    to take care to avoid **DLL Hell**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，动态链接是什么意思呢？嗯，这意味着当可执行文件执行时，操作系统将在运行时加载和链接必要的共享库。换句话说，你将在Windows上看到很多`.dll`文件，在Unix平台上看到很多`.so`文件。这种技术允许开发者分别更新这些共享库和可执行文件，这意味着如果你更改共享库，只要它们的ABIs兼容，你不需要重新构建可执行文件。尽管这种方法更灵活，但开发者被警告要小心避免**DLL地狱**。
- en: The most commonly used solution to DLL Hell on Windows is to choose static linking
    instead. By contrast, static linking will resolve all the function calls and variables
    at compile time and copy them into the target to produce a standalone executable.
    The advantages are obvious. Firstly, you don't need to ship all necessary and
    shared libraries. There won't be DLL Hell in this situation. On Windows, static
    libraries may get `.lib` or `.a` as extensions depending on the compiler you use,
    whereas they usually get `.a` on the Unix platforms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上解决DLL地狱最常用的解决方案是选择静态链接。相比之下，静态链接将在编译时解析所有函数调用和变量，并将它们复制到目标中，以生成独立的可执行文件。优势是显而易见的。首先，你不需要分发所有必要的共享库。在这种情况下不会出现DLL地狱。在Windows上，根据你使用的编译器，静态库可能具有`.lib`或`.a`扩展名，而在Unix平台上通常具有`.a`扩展名。
- en: 'To make a clear comparison, a table is made for you to see the differences
    between the dynamic and static linking:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行清晰的比较，为你制作了一个表格，以查看动态链接和静态链接之间的差异：
- en: '|   | Dynamic Linking | Static Linking |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|   | 动态链接 | 静态链接 |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Library types** | Shared libraries | Static libraries |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | 共享库 | 静态库 |'
- en: '| **Executable size** | Considerably smaller | Greater than dynamically linked
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **可执行文件大小** | 相对较小 | 大于动态链接 |'
- en: '| **Library updates** | Only libraries themselves | Executable file needs to
    be rebuilt |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **库更新** | 只有库本身 | 可执行文件需要重新构建 |'
- en: '| **Incompatible libraries** | Need to take care to avoid this | Won''t happen
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **不兼容的库** | 需要小心避免这种情况 | 不会发生 |'
- en: However, if the shared libraries shipped with dynamically linked executable
    files are counted as part of the package, the dynamic style package will be larger
    than the statically linked standalone executable files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果与动态链接的可执行文件一起分发的共享库被视为包的一部分，那么动态链接风格的包将比静态链接的独立可执行文件大。
- en: Now, back to the topic! Since there is no standard Qt runtime library installer
    for Windows, the best routine is to produce a statically linked target because
    the package to be released will be smaller, and the executable is immune to DLL
    Hell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到主题！由于Windows没有标准的Qt运行时库安装程序，最好的做法是生成一个静态链接的目标，因为要发布的包会更小，并且可执行文件不会受到DLL地狱的影响。
- en: However, as mentioned previously, the Qt libraries you downloaded can only be
    used for dynamic linking applications because they are shared libraries. It is
    viable to compile Qt as static libraries. However, before you proceed, you need
    to know the licenses of Qt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如前所述，你下载的Qt库只能用于动态链接应用程序，因为它们是共享库。将Qt编译为静态库是可行的。但在你继续之前，你需要了解Qt的许可证。
- en: Currently, in addition to the Qt Open Source License, there is also the Qt Commercial
    License. For open source licenses, most of the Qt libraries are licensed under
    **The GNU Lesser General Public License** (**LPGL**). In this case, if you build
    your application statically linked with the Qt libraries, your application is
    subject to provide users the source code of your application under LGPL. Your
    application may stay proprietary and closed source if it's dynamically linked
    with the Qt libraries. In other words, if you want to link an application statically
    and keep it proprietary, you have to purchase the Qt commercial license. For details
    about Qt licensing, refer to [http://www.qt.io/licensing/](http://www.qt.io/licensing/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，除了Qt开源许可证外，还有Qt商业许可证。对于开源许可证，大多数Qt库都根据**GNU Lesser General Public License**（LPGL）授权。在这种情况下，如果你使用Qt库静态链接构建应用程序，你的应用程序必须根据LPGL向用户提供应用程序的源代码。如果你的应用程序与Qt库动态链接，则可以保持专有和闭源。换句话说，如果你想静态链接应用程序并保持其专有性，你必须购买Qt商业许可证。有关Qt许可的详细信息，请参阅[http://www.qt.io/licensing/](http://www.qt.io/licensing/)。
- en: If you decide to use static linking, you might have to compile the Qt libraries
    statically before building your application. In this case, the executable target
    is the only thing that needs to be packaged and released. Don't forget the QM
    files if your application has multi-language support, as mentioned previously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用静态链接，你可能需要在构建应用程序之前将Qt库静态编译。在这种情况下，可执行目标是需要打包和发布的唯一东西。如果你的应用程序具有多语言支持，不要忘记之前提到的QM文件。
- en: 'On the other hand, if you want to go the dynamic way, it''d need some extra
    effort. Firstly, there are some core DLLs that have to exist and the list is different
    depending on the compiler. The following table includes both MSVC and MinGW/GCC
    scenarios:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你想走动态方式，则需要额外努力。首先，有一些核心DLL必须存在，而且根据编译器的不同，列表也不同。以下表格包括MSVC和MinGW/GCC场景：
- en: '| MSVC 2013 | MinGW/GCC |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| MSVC 2013 | MinGW/GCC |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `msvcp120.dll` | `libgcc_s_dw2-1.dll` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `msvcp120.dll` | `libgcc_s_dw2-1.dll` |'
- en: '| `msvcr120.dll` | `libstdc++-6.dll` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `msvcr120.dll` | `libstdc++-6.dll` |'
- en: '|   | `libwinpthread-1.dll` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   | `libwinpthread-1.dll` |'
- en: There are common DLLs that need to be included, such as `icudt53.dll`, `icuin53.dll`,
    and `icuuc53.dll`. You can find these files in the Qt libraries directory. Take
    MinGW/GCC as an example; they're located in `QT_DIR\5.4\mingw491_32\bin` where
    `QT_DIR` is the Qt installation path, such as `D:\Qt`. Note that the later versions
    of Qt may have slightly different filenames.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要包含一些常见的DLL，例如`icudt53.dll`、`icuin53.dll`和`icuuc53.dll`。你可以在Qt库目录中找到这些文件。以MinGW/GCC为例；它们位于`QT_DIR\5.4\mingw491_32\bin`，其中`QT_DIR`是Qt安装路径，例如`D:\Qt`。请注意，Qt的后续版本可能具有略微不同的文件名。
- en: Besides, there is no need to ship `msvcp120.dll` and `msvcr120.dll` if the target
    users have installed **Visual C++ Redistributable Packages** for Visual Studio
    2013, which can be downloaded from [http://www.microsoft.com/en-ie/download/details.aspx?id=40784](http://www.microsoft.com/en-ie/download/details.aspx?id=40784).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果目标用户已经安装了Visual Studio 2013的**Visual C++ Redistributable Packages**，则不需要分发`msvcp120.dll`和`msvcr120.dll`，这些可以从[http://www.microsoft.com/en-ie/download/details.aspx?id=40784](http://www.microsoft.com/en-ie/download/details.aspx?id=40784)下载。
- en: 'After this, you may want to check other DLLs you''ll need by looking into the
    project file. Take the `Internationalization` project as an example. Its project
    file, `Internationalization.pro`, gives us a clue. There are two lines related
    to the QT configuration, shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你可能想通过查看项目文件来检查你需要的其他DLL。以`Internationalization`项目为例。其项目文件`Internationalization.pro`为我们提供了线索。有两行与QT配置相关，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `QT` variable includes the `core gui` widgets. In fact, all the Qt applications
    will include `core` at least, while others are dependent. In this case, we have
    to ship `Qt5Core.dll`, `Qt5Gui.dll`, and `Qt5Widgets.dll` along with the executable
    target.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`QT`变量包括`core gui`小部件。实际上，所有Qt应用程序至少都会包含`core`，而其他则是依赖的。在这种情况下，我们必须将`Qt5Core.dll`、`Qt5Gui.dll`和`Qt5Widgets.dll`与可执行目标一起分发。'
- en: 'Now, build the `Internationalization` project with MinGW/GCC. The executable
    target, `Internationalization.exe`, should be located inside the `release` folder
    of the build directory, which can be read from the **Projects** mode. Next, we
    create a new folder named `package` and copy the executable file there. Then,
    we copy the needed DLLs to `package` as well. Now, this folder should have all
    the necessary DLLs as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用MinGW/GCC构建`Internationalization`项目。可执行目标`Internationalization.exe`应位于构建目录的`release`文件夹中，这可以在**项目**模式下读取。接下来，我们创建一个名为`package`的新文件夹，并将可执行文件复制到那里。然后，我们将所需的DLL文件也复制到`package`中。现在，这个文件夹应该包含所有必要的DLL文件，如下所示：
- en: '![Releasing Qt applications on Windows](img/4615OS_09_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![在Windows上发布Qt应用程序](img/4615OS_09_01.jpg)'
- en: 'In most cases, if a required library is missing, the application won''t run
    while the operating system will prompt the missing library name. For instance,
    if `Qt5Widgets.dll` is missing, the following system error dialog will show up
    when you try to run `Internationalizationi.exe`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果缺少所需的库，应用程序将无法运行，操作系统将提示缺少的库名称。例如，如果缺少`Qt5Widgets.dll`，当您尝试运行`Internationalizationi.exe`时，将显示以下系统错误对话框：
- en: '![Releasing Qt applications on Windows](img/4615OS_09_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![在Windows上发布Qt应用程序](img/4615OS_09_02.jpg)'
- en: Basically, the routine is to copy the missing libraries to the same folder that
    the application is in. Besides, you can use some tools such as `Dependency Walker`
    to get the library dependencies.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，常规操作是将缺失的库复制到应用程序所在的同一文件夹中。此外，您还可以使用一些工具，例如`Dependency Walker`来获取库依赖项。
- en: Please don't use DLLs from the `Qt Editor` folder. This version is often different
    from Qt Libraries you've used. In addition to these libraries, you may have to
    include all the resources that your application is going to use. For example,
    the QM files used for translation, that is, to copy the `Internationalization_de.qm`
    file in order to load the German translation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要使用`Qt编辑器`文件夹中的DLL文件。这个版本通常与您使用的Qt库不同。除了这些库之外，您可能还需要包含应用程序将要使用到的所有资源。例如，用于翻译的QM文件，即复制`Internationalization_de.qm`文件以加载德语翻译。
- en: 'The file list is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件列表如下：
- en: '`icudt53.dll`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icudt53.dll`'
- en: '`icuin53.dll`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icuin53.dll`'
- en: '`icuuc53.dll`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icuuc53.dll`'
- en: '`Internationalization.exe`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Internationalization.exe`'
- en: '`Internationalization_de.qm`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Internationalization_de.qm`'
- en: '`libgcc_s_dw2-1.dll`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libgcc_s_dw2-1.dll`'
- en: '`libstdc++-6.dll`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libstdc++-6.dll`'
- en: '`libwinpthread-1.dll`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libwinpthread-1.dll`'
- en: '`Qt5Core.dll`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt5Core.dll`'
- en: '`Qt5Gui.dll`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt5Gui.dll`'
- en: '`Qt5Widgets.dll`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt5Widgets.dll`'
- en: Don't forget, this is the case for MinGW/GCC in Qt 5.4.0, while different versions
    and compilers might have a slightly different list, as we discussed before.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，这是Qt 5.4.0中MinGW/GCC的情况，而不同版本和编译器可能会有略微不同的列表，正如我们之前讨论的那样。
- en: After this first-time preparation, to some extent this list is fixed. You only
    need to change the executable target and the QM file if it's changed. An easy
    way to do this is to compress all of them in `tarball`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次首次准备之后，在某种程度上这个列表是固定的。您只需要更改可执行目标，如果QM文件有变化，也需要更改。一种简单的方法是将它们全部压缩成`tarball`。
- en: Creating an installer
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装程序
- en: Although it's quick to use an archive file to distribute your application, it
    seems more professional if you provide users with an installer. Qt offers **Qt
    Installer Framework** whose latest open source version, 1.5.0 for now, can be
    obtained from [http://download.qt.io/official_releases/qt-installer-framework/1.5.0/](http://download.qt.io/official_releases/qt-installer-framework/1.5.0/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用存档文件分发您的应用程序很快捷，但如果您提供安装程序，看起来会更专业。Qt提供了**Qt安装框架**，目前最新的开源版本是1.5.0，可以从[http://download.qt.io/official_releases/qt-installer-framework/1.5.0/](http://download.qt.io/official_releases/qt-installer-framework/1.5.0/)获取。
- en: For the sake of convenience, let's create a folder named `dist` under the Qt
    Installer Framework installation path, `D:\Qt\QtIFW-1.5.0`. This folder is used
    to store all the application projects that need to be packaged.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，让我们在Qt安装框架的安装路径`D:\Qt\QtIFW-1.5.0`下创建一个名为`dist`的文件夹。这个文件夹用于存储所有需要打包的应用程序项目。
- en: Then, create a folder named `internationalization` under `dist`. Inside `internationalization`,
    create two folders, `config` and `packages`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`dist`下创建一个名为`internationalization`的文件夹。在`internationalization`中，创建两个文件夹，`config`和`packages`。
- en: 'The name of the directory inside the `packages` directory acts as a domain-like,
    or say Java-style, identifier. In this example, we have two packages, one is the
    application while the other one is a translation. Therefore, it adds to the two
    folders in the packages directory, `com.demo.internationalization`, and `com.demo.internationalization.translation`,
    respectively. There will be `meta` and `data` directories present inside each
    of them, so the overall directory structure is sketched as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`packages`目录内目录的名称充当类似域名或Java风格的标识符。在这个例子中，我们有两个包，一个是应用程序，另一个是翻译。因此，它们分别添加到`packages`目录下的两个文件夹中，`com.demo.internationalization`和`com.demo.internationalization.translation`。每个文件夹内都将存在`meta`和`data`目录，所以整体目录结构如下所示：'
- en: '![Creating an installer](img/4615OS_09_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![创建安装程序](img/4615OS_09_03.jpg)'
- en: Let's edit the global configuration file, `config.xml`, which is first inside
    the `config` directory. You need to create one file named `config.xml`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑全局配置文件，`config.xml`，它首先位于`config`目录中。您需要创建一个名为`config.xml`的文件。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always remember not to use the Windows built-in Notepad to edit this file, or
    in fact any file. You may either use Qt Creator or other advanced editors, such
    as Notepad++, to edit it. This is simply because Notepad lacks of a lot of features
    as a code editor.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住不要使用Windows内置的记事本编辑此文件，或者实际上任何文件。您可以使用Qt Creator或其他高级编辑器，如Notepad++来编辑它。这仅仅是因为记事本作为一个代码编辑器缺少很多功能。
- en: 'In this example, the `config.xml` file''s content is pasted here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`config.xml`文件的内容粘贴在这里：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a minimum `config.xml` file, the elements `<Name>` and `<Version>` must
    exist in `<Installer>`. All other elements are optional, but you should specify
    them if there is a need. Meanwhile, `<TargetDir>` and `<AdminTargetDir>` may be
    a bit confusing. They both specify the default installation path, where `<AdminTargetDir>`
    is to specify the installation path when it gained administrative rights. The
    other elements are pretty much self-explanatory. There are other elements that
    you can set to customize the installer. For more details, refer to [http://doc.qt.io/qtinstallerframework/ifw-globalconfig.html](http://doc.qt.io/qtinstallerframework/ifw-globalconfig.html).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个最小的`config.xml`文件，`<Installer>`中必须存在`<Name>`和`<Version>`元素。所有其他元素都是可选的，但如果需要，您应该指定它们。同时，`<TargetDir>`和`<AdminTargetDir>`可能有点令人困惑。它们都指定默认的安装路径，其中`<AdminTargetDir>`用于指定获得管理员权限时的安装路径。其他元素基本上是自我解释的。您还可以设置其他元素来自定义安装程序。有关更多详细信息，请参阅[http://doc.qt.io/qtinstallerframework/ifw-globalconfig.html](http://doc.qt.io/qtinstallerframework/ifw-globalconfig.html)。
- en: 'Let''s navigate into the `meta` folder inside `com.demo.internationalization`.
    This directory contains the files that specify the settings for deployment and
    installation. All the files in this directory, except for licenses, won''t be
    extracted by the installer, and neither will they be installed. There must be
    at least a package information file, such as `package.xml`. The following example,
    `package.xml`, in `com.demo.internationalization/meta` is shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到`com.demo.internationalization`内的`meta`文件夹。此目录包含指定部署和安装设置的文件。此目录中的所有文件（除许可证外）都不会被安装程序提取，也不会被安装。必须至少有一个包信息文件，例如`package.xml`。以下位于`com.demo.internationalization/meta`的`package.xml`示例如下：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `<Default>` element specifies whether this package should be selected by
    default. At the same time, we set `<ForcedInstallation>` to `true`, indicating
    that the end users can''t deselect this package. While the `<Licenses>` element
    can have multiple children `<License>`, in this case we only have one. We have
    to provide the `license.txt` file, whose content is just a single line demonstration,
    as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Default>`元素指定此包是否应默认选中。同时，我们将`<ForcedInstallation>`设置为`true`，表示最终用户不能取消选择此包。而`<Licenses>`元素可以有多个子元素`<License>`，在这种情况下我们只有一个。我们必须提供`license.txt`文件，其内容仅是一行演示，如下所示：'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following `package.xml` file, which is located in `com.demo.internationalization.translation/meta`,
    has fewer lines:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`com.demo.internationalization.translation/meta`的以下`package.xml`文件行数较少：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The difference between `<DisplayName>` and `<Description>` is demonstrated
    by the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`<DisplayName>`和`<Description>`之间的区别通过以下截图演示：'
- en: '![Creating an installer](img/4615OS_09_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建安装程序](img/4615OS_09_04.jpg)'
- en: The `<Description>` element is the text that displays on the right-hand side
    when the package gets selected. It's also the text that pops up as the tooltip
    when the mouse hovers over the entry. You can also see the relationship between
    these two packages. As the name `com.demo.internationalization.translation` suggests,
    it is a subpackage of `com.demo.internationalization`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Description>`元素是在包被选中时在右侧显示的文本。它也是当鼠标悬停在条目上时弹出的文本提示。您还可以看到这两个包之间的关系。正如名称`com.demo.internationalization.translation`所暗示的，它是一个`com.demo.internationalization`的子包。'
- en: The licenses will be displayed after this step and are shown in the following
    screenshot. If you set multiple licenses, the dialog will have a panel to view
    those licenses separately, similar to the one you see when you install Qt itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤之后将显示许可证，如下面的截图所示。如果您设置了多个许可证，对话框将有一个面板来分别查看这些许可证，类似于您在安装Qt本身时看到的。
- en: '![Creating an installer](img/4615OS_09_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![创建安装程序](img/4615OS_09_05.jpg)'
- en: For more settings in the `package.xml` file, refer to [http://doc.qt.io/qtinstallerframework/ifw-component-description.html#package-information-file-syntax](http://doc.qt.io/qtinstallerframework/ifw-component-description.html#package-information-file-syntax).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`package.xml`文件中的更多设置，请参阅[http://doc.qt.io/qtinstallerframework/ifw-component-description.html#package-information-file-syntax](http://doc.qt.io/qtinstallerframework/ifw-component-description.html#package-information-file-syntax)。
- en: By contrast, the `data` directories store all the files that need to be installed.
    In this example, we keep all files prepared previously in the `data` folder of
    `com.demo.internationalization`, except for the QM file. The QM file, `Internationalization_de.qm`,
    is kept in the `data` folder inside `com.demo.internationalization.translation`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`data`目录存储了所有需要安装的文件。在这个例子中，我们将之前准备的所有文件保存在`com.demo.internationalization`的`data`文件夹中，除了QM文件。QM文件`Internationalization_de.qm`保存在`com.demo.internationalization.translation`内部的`data`文件夹中。
- en: 'After all the initial preparation, we come to the final step to generate the
    installer application of this project. Depending on your operating system, open
    **Command Prompt** or **Terminal**, changing the current directory to `dist/internationalization`.
    In this case, it''s `D:\Qt\QtIFW-1.5.0\dist\internationalization`. Then, execute
    the following command to generate the `internationalization_installer.exe` installer
    file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有初始准备后，我们来到生成此项目安装程序的最终步骤。根据您的操作系统，打开**命令提示符**或**终端**，将当前目录更改为`dist/internationalization`。在这种情况下，它是`D:\Qt\QtIFW-1.5.0\dist\internationalization`。然后，执行以下命令以生成`internationalization_installer.exe`安装程序文件：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Unix platforms, including Linux and Mac OS X, you''ll have to use a slash
    (/) instead of anti-slash (\), and drop the `.exe` suffix, which makes the command
    slightly different, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix平台（包括Linux和Mac OS X）上，您必须使用斜杠（/）而不是反斜杠（\），并删除`.exe`后缀，这使得命令略有不同，如下所示：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You need to wait for a while because the `binarycreator` tool will package files
    in the `data` directories into the `7zip` archives, which is a time consuming
    process. After this, you should expect to see `internationalization_installer.exe`
    (or without `.exe`) in the current directory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要等待一段时间，因为`binarycreator`工具会将`data`目录中的文件打包成`7zip`存档，这是一个耗时的过程。之后，您应该会在当前目录中看到`internationalization_installer.exe`（或没有`.exe`后缀）。
- en: The installer is much more convenient, especially for a big application project
    that has several optional packages. Besides, it'll register and let the end users
    uninstall through **Control Panel**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序更加方便，尤其是对于包含多个可选包的大型应用程序项目。此外，它会在**控制面板**中注册并允许最终用户卸载。
- en: Packaging Qt applications on Linux
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上打包Qt应用程序
- en: 'Things are more complicated on Linux than on Windows. There are two popular
    package formats: **RPM Package Manager** (**RPM**) and **Debian Binary Package**
    (**DEB**). RPM was originally developed for **Red Hat Linux** and it''s the baseline
    package format of **Linux Standard Base**. It''s mainly used on **Fedora**, **OpenSUSE**,
    **Red Hat Enterprise Linux**, and its derivatives; while the latter is famous
    for being used in **Debian** and its well-known and popular derivative, **Ubuntu**.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上比在Windows上更复杂。有两种流行的包格式：**RPM包管理器**（**RPM**）和**Debian二进制包**（**DEB**）。RPM最初是为**Red
    Hat Linux**开发的，它是**Linux标准基**的基本包格式。它主要用于**Fedora**、**OpenSUSE**、**Red Hat Enterprise
    Linux**及其衍生版本；而后者因在**Debian**及其知名且流行的衍生版**Ubuntu**中使用而闻名。
- en: In addition to these formats, there are other Linux distributions using different
    package formats, such as **Arch Linux** and **Gentoo**. It will take extra time
    to package your applications for different Linux distributions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些格式，还有其他 Linux 发行版使用不同的软件包格式，例如 **Arch Linux** 和 **Gentoo**。为不同的 Linux 发行版打包你的应用程序将需要额外的时间。
- en: However, it won't be too time consuming, especially for open-source applications.
    If your application is open source, you can refer to the documentation to write
    a formatted script to compile and package your application. For details on creating
    an RPM package, refer to [https://fedoraproject.org/wiki/How_to_create_an_RPM_package](https://fedoraproject.org/wiki/How_to_create_an_RPM_package),
    whereas for DEB packaging, refer to [https://www.debian.org/doc/manuals/maint-guide/index.en.html](https://www.debian.org/doc/manuals/maint-guide/index.en.html).
    There is an example later that demonstrates how to package DEB.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会太耗费时间，尤其是对于开源应用程序。如果你的应用程序是开源的，你可以参考文档来编写一个格式化的脚本，用于编译和打包你的应用程序。有关创建 RPM
    软件包的详细信息，请参阅[https://fedoraproject.org/wiki/How_to_create_an_RPM_package](https://fedoraproject.org/wiki/How_to_create_an_RPM_package)，而对于
    DEB 打包，请参阅[https://www.debian.org/doc/manuals/maint-guide/index.en.html](https://www.debian.org/doc/manuals/maint-guide/index.en.html)。稍后会有一个示例演示如何打包
    DEB。
- en: Although it's feasible to pack proprietary applications, such as the RPM and
    DEB packages, they won't get into the official repository. In this case, you may
    want to set up a repository on your server or just release the packages via a
    file host.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打包专有应用程序，如 RPM 和 DEB 软件包是可行的，但它们不会进入官方仓库。在这种情况下，你可能会想在你的服务器上设置一个仓库，或者只是通过文件托管发布这些软件包。
- en: Alternatively, you can archive your applications, similar to what we do on Windows,
    and write a shell script for installation and uninstallation. In this way, you
    can use one tarball or Qt Installer Framework to cook an installer for various
    distributions. But, don't ever forget to address the dependencies appropriately.
    The incompatible shared library issue is even worse on Linux, because almost all
    the libraries and applications are linked dynamically. The worst part is the incompatibility
    between different distributions, since they may use different library versions.
    Therefore, either take care of these pitfalls, or go the static linking way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将你的应用程序存档，类似于我们在 Windows 上所做的那样，并为安装和卸载编写一个 shell 脚本。这样，你可以使用一个 tarball
    或 Qt 安装器框架为各种发行版制作安装程序。但是，永远不要忘记适当地处理依赖关系。在 Linux 上，不兼容的共享库问题更为严重，因为几乎所有的库和应用程序都是动态链接的。最糟糕的是不同发行版之间的不兼容性，因为它们可能使用不同的库版本。因此，要么注意这些陷阱，要么选择静态链接的方式。
- en: As we mentioned previously, statically linked software must be open source unless
    you have purchased the Qt commercial license. This dilemma makes the statically
    linked open source application pointless. This is not only because dynamic linking
    is the standard way, but also because statically linked Qt applications won't
    be able to use the system theme and can't benefit from system upgrades, which
    is not okay when security updates are involved. Anyway, you can compile your application
    using static linking if your application is proprietary and you get a commercial
    license. In this case, just like static linking on Windows, you only need to release
    the target executable files with the necessary resources, such as icons and translations.
    It's noteworthy that even if you build statically linked Qt applications, it's
    still impossible to run them on any Linux distributions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，除非你购买了 Qt 商业许可证，否则静态链接的软件必须是开源的。这种困境使得静态链接的开源应用程序变得毫无意义。这不仅是因为动态链接是标准方式，而且因为静态链接的
    Qt 应用程序将无法使用系统主题，也无法从系统升级中受益，这在涉及安全更新时是不合适的。无论如何，如果你的应用程序是专有的并且你获得了商业许可证，你可以使用静态链接来编译你的应用程序。在这种情况下，就像
    Windows 上的静态链接一样，你只需要发布带有必要资源的目标可执行文件，例如图标和翻译。值得注意的是，即使你构建了静态链接的 Qt 应用程序，也无法在任何
    Linux 发行版上运行它们。
- en: Therefore, the recommended way is to install several mainstream Linux distributions
    on virtual machines, and then use these virtual machines to package your dynamically
    linked application as their own package formats. The binary package doesn't contain
    source code, and it's also a common practice to strip the symbols from the binary
    package. In this way, your source code for proprietary software won't be leaked
    through these packages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，推荐的方式是在虚拟机上安装几个主流的 Linux 发行版，然后使用这些虚拟机来打包你的动态链接应用程序，并使用它们自己的软件包格式。二进制软件包不包含源代码，并且从二进制软件包中剥离符号也是常见的做法。这样，你的专有软件的源代码就不会通过这些软件包泄露。
- en: We still use `Internationalization` as an example here. Let's see how to create
    a DEB package. The following operations were tested on the latest **Debian Wheezy**;
    later versions or different Linux distributions might be slightly different.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们仍然以 `Internationalization` 为例。让我们看看如何创建一个 DEB 软件包。以下操作是在最新的 **Debian Wheezy**
    上测试过的；后续版本或不同的 Linux 发行版可能会有所不同。
- en: 'Before we package the application, we have to edit the project file, `Internationalization.pro`,
    to make it installable as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打包应用程序之前，我们必须编辑项目文件 `Internationalization.pro`，使其可安装，如下所示：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is a concept in `qmake` called **install set**. Each install set has
    three members: `path`, `files`, and `extra`. The `path` member defines the destination
    location, while `files` tells `qmake` what files should be copied. You can specify
    some commands that need to be executed before other instructions in `extra`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `qmake` 中有一个称为 **安装集** 的概念。每个安装集有三个成员：`path`、`files` 和 `extra`。`path` 成员定义了目标位置，而
    `files` 告诉 `qmake` 应该复制哪些文件。你可以在 `extra` 中指定一些在执行其他指令之前需要执行的命令。
- en: '`TARGET` is a bit special. Firstly, it''s the target executable (or library),
    while on the other hand, it also implies `target.files`. Therefore, we only need
    to specify the path of `target`. We also use the same path for `qmfile`, which
    includes the QM file. Don''t forget to use a double dollar sign, `$$`, to use
    a variable. Lastly, we set the `INSTALLS` variable, which defines what is to be
    installed when `make install` is called. The `unix` brackets are used to limit
    the lines only read by `qmake` on the Unix platforms.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`TARGET` 是一个有点特殊的概念。首先，它是目标可执行文件（或库），另一方面，它也暗示了 `target.files`。因此，我们只需要指定 `target`
    的路径。我们同样使用相同的路径为 `qmfile`，它包括 QM 文件。不要忘记使用双美元符号 `$$` 来使用变量。最后，我们设置了 `INSTALLS`
    变量，它定义了在调用 `make install` 时要安装的内容。`unix` 括号用于限制仅在 Unix 平台上由 `qmake` 读取的行。'
- en: 'Now, we can get into the DEB packaging part by performing the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行以下步骤进入 DEB 打包的部分：
- en: Change your working directory (current directory) to the root of the project,
    that is, `~/Internationalization`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的工作目录（当前目录）更改为项目的根目录，即 `~/Internationalization`。
- en: Create a new folder named `debian`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `debian` 的新文件夹。
- en: 'Create the four required files in the `debian` folder: `control`, `copyright`,
    `changelog`, and `rules`, respectively. Then, create an optional `compat` file
    in the `debian` folder as well.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `debian` 文件夹中创建四个必需的文件：`control`、`copyright`、`changelog` 和 `rules`，分别。然后，在
    `debian` 文件夹中还可以创建一个可选的 `compat` 文件。
- en: 'The `control` file defines the most basic yet most critical things. This file
    is all about the source package and the binary package(s). The `control` file
    of our example is pasted here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`control` 文件定义了最基本同时也是最关键的内容。这个文件全部关于源软件包和二进制软件包。我们示例中的 `control` 文件如下所示：'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first paragraph is to control information for a source, whereas each of
    the following sets describe a binary package that the source tree builds. In other
    words, one source package may build several binary packages. In this case, we
    build only one binary package whose name is the same as `Source` and `internationalization`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段是用于控制源信息，而接下来的每一部分描述的是源树构建的各个二进制软件包。换句话说，一个源软件包可以构建多个二进制软件包。在这种情况下，我们只构建一个二进制软件包，其名称与
    `Source` 和 `internationalization` 相同。
- en: In the `Source` paragraph, `Source` and `Maintainer` are mandatory while `Section`,
    `Priority`, and `Standards-Version` are recommended. `Source` identifies the source
    package name, which can't include uppercase letters. Meanwhile, `Maintainer` contains
    the maintainer package's name and the e-mail address in the RFC822 format. The
    `Section` field specifies an application area in which the package has been classified.
    `Priority` is a self-explanatory field, indicating how important this package
    is. Lastly, `Standards-Version` describes the most recent version of the standards
    with which the package complies. In most cases, you should use the latest standard
    version, 3.9.6 for now. There are other fields that may be useful but optional.
    For more details, refer to [https://www.debian.org/doc/debian-policy/ch-controlfields.html](https://www.debian.org/doc/debian-policy/ch-controlfields.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source`段落中，`Source`和`Maintainer`是必填项，而`Section`、`Priority`和`Standards-Version`是推荐填写的。`Source`用于标识源包名，其中不能包含大写字母。同时，`Maintainer`包含维护者包的名称和按照RFC822格式的电子邮件地址。`Section`字段指定了包被分类的应用领域。`Priority`是一个解释性的字段，表示这个包的重要性。最后，`Standards-Version`描述了与包兼容的最新标准版本。在大多数情况下，你应该使用最新的标准版本，目前是3.9.6。还有一些可能有用但不是必须的字段。更多详情，请参考[https://www.debian.org/doc/debian-policy/ch-controlfields.html](https://www.debian.org/doc/debian-policy/ch-controlfields.html)。
- en: You can specify certain packages needed for building in `Build-Depends`, similar
    to `qt5-qmake` and `qtbase5-dev` in our example. They're only defined for building
    processes and won't be included in the dependencies of binary packages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Build-Depends`中指定构建所需的某些包，类似于我们示例中的`qt5-qmake`和`qtbase5-dev`。它们仅用于构建过程，不会包含在二进制包的依赖项中。
- en: The binary paragraphs are similar to the source except that there is no `Maintainer`,
    but `Architecture` and `Description` are mandatory now. For binary packages, `Architecture`
    can be any particular architecture or simply `any` or `all`. Specifying `any`
    indicates that the source package isn't dependent on any particular architecture
    and hence can be built on any architecture. In contrast to this, `all` means that
    the source package will produce only architecture-independent packages, such as
    documentations and scripts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制段落与源代码类似，只是没有`Maintainer`，但现在`Architecture`和`Description`是必填项。对于二进制包，`Architecture`可以是任何特定的架构，也可以简单地是`any`或`all`。指定`any`表示源包不依赖于任何特定的架构，因此可以在任何架构上构建。相比之下，`all`表示源包将只产生架构无关的包，例如文档和脚本。
- en: In `Depends` of the binary paragraph, we put `${shlibs:Depends}, ${misc:Depends}`
    instead of particular packages. The `${shlibs:Depends}` line can be used to let
    `dpkg-shlibdeps` generate shared library dependencies automatically. On the other
    hand, according to `debhepler`, you're encouraged to put `${misc:Depends}` in
    the field to supplement `${shlibs:Depends}`. In this way, we don't need to specify
    the dependencies manually, which is a relief for packagers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制段落的`Depends`中，我们使用`${shlibs:Depends}, ${misc:Depends}`代替特定的包。`${shlibs:Depends}`行可以用来让`dpkg-shlibdeps`自动生成共享库依赖。另一方面，根据`debhepler`的建议，你被鼓励在字段中放置`${misc:Depends}`以补充`${shlibs:Depends}`。这样，我们就不需要手动指定依赖项，这对打包者来说是一种缓解。
- en: 'The second required file, `copyright`, is to describe the licenses of the source
    as well as the DEB packages. In the `copyright` file, the format field is required
    while the others are optional. For more details about the formats of copyright,
    refer to [https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/](https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/).
    The `copyright` file in this example is shown as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个必需的文件是`copyright`，用于描述源代码以及DEB包的许可证。在`copyright`文件中，格式字段是必需的，而其他字段是可选的。有关版权格式的更多详情，请参考[https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/](https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/)。本例中的`copyright`文件如下所示：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first paragraph is called **Header paragraph**, which is needed once and
    only once. The `Format` line is the only mandatory field in this paragraph, and
    in most cases, this line is the same. The syntax of the `Upstream-Contact` field
    is the same as `Maintainer` in the `control` file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段被称为**标题段落**，它只需要填写一次。在这个段落中，`Format`行是唯一必填的字段，在大多数情况下，这一行是相同的。`Upstream-Contact`字段的语法与`control`文件中的`Maintainer`相同。
- en: The second paragraph in this file is **Files paragraph**, which is mandatory
    and repeatable. In these paragraphs, `File`, `Copyright`, and `License` are required.
    We use an asterisk sign (`*`) indicating that this paragraph applies to all files.
    The `Copyright` field may contain the original statement copied from files or
    a shortened text. The `License` field in a `Files` paragraph describes the licensing
    terms for the files defined by `File`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的第二段是**文件段落**，这是强制性的且可重复的。在这些段落中，`File`、`Copyright`和`License`是必需的。我们使用一个星号（`*`）表示这个段落适用于所有文件。`Copyright`字段可能包含从文件中复制来的原始声明或简短文本。`Files`段落中的`License`字段描述了由`File`定义的文件的许可条款。
- en: Following the Files paragraph, the **Stand-alone license paragraph** is optional
    and repeatable. We have to provide the full license text if the license is not
    provided by Debian. Generally speaking, only commonly-seen open-source licenses
    are provided. The first line must be a single license short name, which is then
    followed by a license text. For a license text, there must be a two space indentation
    in each line's head.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件段落之后，**独立许可段落**是可选的且可重复的。如果Debian没有提供许可，我们必须提供完整的许可文本。一般来说，只有常见的开源许可才提供。第一行必须是一个单独的许可简称，然后是许可文本。对于许可文本，每行的开头必须有两个空格缩进。
- en: 'Don''t be misled by the `changelog` filename. This file also has a special
    format and is used by `dpkg` to obtain the version number, revision, distribution,
    and urgency of your package. It''s a good practice to document all the changes
    you have made in this file. However, you can just list the most important ones
    if you have a version control system. The `changelog` file in our example has
    the following contents:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被`changelog`文件名误导。这个文件也有一个特殊的格式，并且被`dpkg`用来获取你的软件包的版本号、修订、发行版和紧急程度。记录在这个文件中你所做的所有更改是一个好的做法。然而，如果你有一个版本控制系统，你只需列出最重要的更改即可。我们示例中的`changelog`文件包含以下内容：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line is the package name, version, distribution, and urgency. The
    name must match the source package name. In this example, `internationalization`
    is the name, `1.0.0-1` is the version, `unstable` stands for the distribution,
    and `urgency` is `low`. Then, use an empty line to separate the first line and
    log entries. In the log entries, all the changes that you want to document should
    be listed. For each entry, there are two spaces and an asterisk sign (`*`) in
    the header. The last part of a paragraph is a maintainer line that begins with
    a space. For more details about this file and its format, refer to [https://www.debian.org/doc/debian-policy/ch-source.html#s-dpkgchangelog](https://www.debian.org/doc/debian-policy/ch-source.html#s-dpkgchangelog).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是软件包名称、版本、发行版和紧急程度。名称必须与源软件包名称匹配。在这个例子中，`internationalization`是名称，`1.0.0-1`是版本，`unstable`代表发行版，`urgency`是`low`。然后，使用一个空行来分隔第一行和日志条目。在日志条目中，你应该列出所有想要记录的更改。对于每个条目，标题部分有两个空格和一个星号（`*`）。段落结尾的部分是一个维护者行，以空格开头。有关此文件及其格式的更多详细信息，请参阅[https://www.debian.org/doc/debian-policy/ch-source.html#s-dpkgchangelog](https://www.debian.org/doc/debian-policy/ch-source.html#s-dpkgchangelog)。
- en: 'Now, we need to take a look at what `dpkg-buildpackage` will do to create the
    package. This process is controlled by the `rules` file; the example is pasted
    here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要看看`dpkg-buildpackage`将如何创建软件包。这个过程由`rules`文件控制；示例内容如下：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This file, similar to `Makefile`, consists of several rules. Also, each rule
    begins with its target declaration, while the recipes are the following lines
    beginning with the TAB code (not four spaces). We explicitly set Qt 5 as the Qt
    version, which can avoid some issues when Qt 5 coexists with Qt 4\. The percentage
    sign (`%`) is a special target and means any targets, which just calls the `dh`
    program with the target name, while `dh` is just a wrapper script, which runs
    appropriate programs depending on its argument, the real target.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件，类似于`Makefile`，由几个规则组成。同时，每个规则都以目标声明开始，而配方则是以下以TAB代码（不是四个空格）开始的行。我们明确地将Qt
    5设置为Qt版本，这可以避免Qt 5与Qt 4共存时的一些问题。百分号（`%`）是一个特殊的目标，表示任何目标，它只是调用带有目标名称的`dh`程序，而`dh`只是一个包装脚本，根据其参数运行适当的程序，真正的目标是。
- en: The rest of the lines are customizations for the `dh` command. For instance,
    `dh_auto_configure` will call `./configure` by default. In our case, we use `qmake`
    to generate `Makefile` instead of a configure script. Therefore, we override `dh_auto_configure`
    by adding the `override_dh_auto_configure` target with `qmake` as the recipe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的行是对`dh`命令的定制。例如，`dh_auto_configure`默认会调用`./configure`。在我们的例子中，我们使用`qmake`来生成`Makefile`而不是配置脚本。因此，我们通过添加带有`qmake`作为脚本的`override_dh_auto_configure`目标来覆盖`dh_auto_configure`。
- en: 'Although the `compat` file is optional, you''ll get bombarded with warnings
    if you don''t specify it. Currently, you should set its content to `9`, which
    can be done by the following single-line command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`compat`文件是可选的，但如果你不指定它，你会收到大量的警告。目前，你应该将其内容设置为`9`，可以通过以下单行命令完成：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can generate the binary DEB package now. The `-uc` argument stands for uncheck
    while `-us` stands for unsign. If you have a PKG key, you may need to sign the
    package so that users can trust the packages you've released. We don't need source
    packages, so the last argument, `-b`, indicates that only the binary packages
    will be built.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成二进制DEB包了。`-uc`参数表示不检查，而`-us`表示不签名。如果你有一个PKG密钥，你可能需要签名包，以便用户可以信任你发布的包。我们不需要源包，所以最后一个参数`-b`表示只构建二进制包。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The automatically detected dependencies can be viewed in the `debian/` file,
    `internationalization.substvars`. This file''s contents are pasted here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`debian/`文件中的`internationalization.substvars`中查看自动检测到的依赖项。此文件的内容如下：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we discussed earlier, the dependencies are generated by `shlibs` and `misc`.
    The biggest advantage is that these generated version numbers tend to be the smallest,
    which means the maximum backwards compatibility. As you can see, our `Internationalization`
    example can run on Qt 5.0.2.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，依赖项是由`shlibs`和`misc`生成的。最大的优点是这些生成的版本号往往是最小的，这意味着最大的向后兼容性。正如你所看到的，我们的`Internationalization`示例可以在Qt
    5.0.2上运行。
- en: If everything goes well, you'd expect a DEB file in an upper-level directory.
    However, you can only build the current architecture's binary package, `amd64`.
    If you want to build for `i386` natively, you need to install a 32-bit x86 Debian.
    For cross-compilation, refer to [https://wiki.debian.org/CrossBuildPackagingGuidelines](https://wiki.debian.org/CrossBuildPackagingGuidelines)
    and [https://wiki.ubuntu.com/CrossBuilding](https://wiki.ubuntu.com/CrossBuilding).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你会在上级目录中期望看到一个DEB文件。然而，你只能构建当前架构的二进制包`amd64`。如果你想为`i386`原生构建，你需要安装32位x86
    Debian。对于交叉编译，请参阅[https://wiki.debian.org/CrossBuildPackagingGuidelines](https://wiki.debian.org/CrossBuildPackagingGuidelines)和[https://wiki.ubuntu.com/CrossBuilding](https://wiki.ubuntu.com/CrossBuilding)。
- en: 'Installing a local DEB file is easily done with the following single-line command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下单行命令可以轻松安装本地DEB文件：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After installation, we can run our application by running `/opt/internationalization_demo/Internationalization`.
    It should run as expected and behave exactly the same as on Windows, as shown
    in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以通过运行`/opt/internationalization_demo/Internationalization`来运行我们的应用程序。它应该按预期运行，并且行为与Windows上完全相同，如下面的截图所示：
- en: '![Packaging Qt applications on Linux](img/4615OS_09_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![在Linux上打包Qt应用程序](img/4615OS_09_06.jpg)'
- en: Deploying Qt applications on Android
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上部署Qt应用程序
- en: 'The `internationalization` application requires a QM file to be loaded correctly.
    On Windows and Linux, we choose to install them alongside the target executable.
    However, this is not always a good approach, especially on Android. The path is
    more complicated than the desktop operating systems. Besides, we''re building
    a Qt application instead of the Java application. Localization is definitely different
    from a plain Java application, as stated in the Android documentation. Hence,
    we''re going to bundle all the resources into the `qrc` file, which will be built
    into the binary target:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`internationalization`应用程序需要一个QM文件才能正确加载。在Windows和Linux上，我们选择将它们与目标可执行文件一起安装。然而，这并不总是一个好的方法，尤其是在Android上。路径比桌面操作系统更复杂。此外，我们正在构建Qt应用程序而不是Java应用程序。本地化与纯Java应用程序肯定不同，正如Android文档中所述。因此，我们将所有资源打包到`qrc`文件中，该文件将被构建到二进制目标中：'
- en: Add a new file to project by right-clicking on the project, and then select
    **Add New…**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目上右键单击并选择**添加新文件…**来向项目中添加新文件。
- en: Navigate to **Qt** | **Qt Resource File** in the **New File** dialog.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建文件**对话框中导航到**Qt** | **Qt资源文件**。
- en: Name it `res` and click on **OK**; Qt Creator will redirect you to edit `res.qrc`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `res` 并点击**确定**；Qt Creator 将带您编辑 `res.qrc`。
- en: Navigate to **Add** | **Add Prefix** and change **Prefix** to `/`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**添加** | **添加前缀**，并将**前缀**更改为`/`。
- en: Navigate to **Add** | **Add Files** and select the .`Internationalization_de.qm`
    file in the dialog.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**添加** | **添加文件**，并在对话框中选择 `.Internationalization_de.qm` 文件。
- en: 'Now, we need to edit `mainwindow.cpp` to make it load the translation file
    from `Resources`. We only need to change the constructor of `MainWindow` where
    we load the translation, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编辑 `mainwindow.cpp` 以使其从 `Resources` 加载翻译文件。我们只需要更改 `MainWindow` 构造函数中加载翻译的部分，如下所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is to specify the directory for the `QTranslator::load` function.
    As we mentioned in the previous chapter, `:/` indicates that it's a `qrc` path.
    Don't add a `qrc` prefix unless it's a `QUrl` object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是为了指定 `QTranslator::load` 函数的目录。正如我们在上一章中提到的，`:/` 表示这是一个 `qrc` 路径。除非它是一个
    `QUrl` 对象，否则不要添加 `qrc` 前缀。
- en: 'We can remove the `qmfile` install set from the project file now, because we''ve
    already bundled the QM file. In other words, after this change, you don''t need
    to ship the QM file on Windows or Linux anymore. Edit the project file, `Internationalization.pro`,
    as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从项目文件中移除 `qmfile` 安装集，因为我们已经打包了 QM 文件。换句话说，在此更改之后，您不再需要在 Windows 或 Linux
    上发送 QM 文件。编辑项目文件，`Internationalization.pro`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, switch to **Projects** mode and add the **Android** kit. Don''t forget
    to switch the build to `release`. In **Projects** mode, you can modify how Qt
    Creator should build the Android APK package. There is an entry in **Build Steps**
    called **Build Android APK**, as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换到**项目**模式并添加**Android**工具包。别忘了将构建切换到`发布`。在**项目**模式下，您可以修改 Qt Creator 应如何构建
    Android APK 包。在**构建步骤**中有一个名为**构建 Android APK**的条目，如下面的截图所示：
- en: '![Deploying Qt applications on Android](img/4615OS_09_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![在 Android 上部署 Qt 应用程序](img/4615OS_09_07.jpg)'
- en: 'Here, you can specify the Android API level and your certificate. By default,
    **Qt Deployment** is set to **Bundle Qt libraries in APK**, which creates a redistributable
    APK file. Let''s click on the **Create Templates** button to generate a manifest
    file, `AndroidManifest.xml`. Normally, you just click on the **Finish** button
    on the pop-up dialog, and then Qt Creator will redirect you back to the **Edit**
    mode with `AndroidManifest.xml` open in the editing area, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以指定 Android API 级别和您的证书。默认情况下，**Qt 部署**设置为**将 Qt 库打包到 APK 中**，这会创建一个可重新分发的
    APK 文件。让我们点击**创建模板**按钮来生成一个清单文件，`AndroidManifest.xml`。通常，您只需在弹出对话框中点击**完成**按钮，然后
    Qt Creator 将带您回到**编辑**模式，在编辑区域打开 `AndroidManifest.xml`，如图所示：
- en: '![Deploying Qt applications on Android](img/4615OS_09_08.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![在 Android 上部署 Qt 应用程序](img/4615OS_09_08.jpg)'
- en: 'Let''s make a few changes to this manifest file by performing the following
    steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤对清单文件进行一些修改：
- en: Change **Package name** to `com.demo.internationalization`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**包名**更改为`com.demo.internationalization`。
- en: 'Change **Minimum required SDK** to `API 14: Android 4.0, 4.0.1, 4.0.2`.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将**最小所需 SDK**更改为`API 14: Android 4.0, 4.0.1, 4.0.2`。'
- en: 'Change **Target SDK** to `API 19: Android 4.4`.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将**目标 SDK**更改为`API 19: Android 4.4`。'
- en: Save the changes.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改。
- en: Different API levels have an impact on compatibility and the UI; you have to
    decide the levels carefully. In this case, we require at least Android 4.0 to
    run this application, which we're going to it for Android 4.4\. Generally speaking,
    the higher the API level, the better the overall performance is. The `Internationalization.pro`
    project file is automatically changed as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 API 级别会影响兼容性和 UI；您必须仔细决定级别。在这种情况下，我们需要至少 Android 4.0 来运行此应用程序，我们将针对 Android
    4.4 进行此操作。一般来说，API 级别越高，整体性能越好。`Internationalization.pro` 项目文件也会自动更改。
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, build a `release` build. The APK file is created in `android-build/bin`
    inside the project build directory. The APK filename is `QtApp-release.apk` or
    `QtApp-debug.apk` if you don't set your certificate. If you're going to submit
    your application to Google Play or any other Android markets, you have to set
    your certificate and upload `QtApp-release.apk` instead of `QtApp-debug.apk`.
    Meanwhile, `QtApp-debug.apk` can be used on your own devices to test the functionality
    of your application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建一个`发布版`。APK文件位于项目构建目录中的`android-build/bin`目录内。APK文件名为`QtApp-release.apk`，如果您没有设置您的证书，则为`QtApp-debug.apk`。如果您打算将您的应用程序提交到Google
    Play或任何其他Android市场，您必须设置您的证书并上传`QtApp-release.apk`而不是`QtApp-debug.apk`。同时，`QtApp-debug.apk`可用于您自己的设备上测试应用程序的功能。
- en: 'The screenshot of `Internationalization` running on HTC One is shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是HTC One上运行`国际化`功能的截图：
- en: '![Deploying Qt applications on Android](img/4615OS_09_09.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![在Android上部署Qt应用程序](img/4615OS_09_09.jpg)'
- en: As you can see, the German translation is loaded as expected, while the pop-up
    dialog has a native look and feel.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，德语翻译已按预期加载，而弹出对话框具有本地化的外观和感觉。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we compared the advantages and disadvantages of static and
    dynamic linking. Later on, we used an example application, showing you how to
    create an installer on Windows and how to package it as a DEB package on Debian
    Linux. Last but not least, we also learned how to create a redistributable APK
    file for Android. The slogan, *code less, create more, deploy everywhere* is now
    fulfilled.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们比较了静态链接和动态链接的优缺点。稍后，我们通过一个示例应用程序，向您展示了如何在Windows上创建安装程序，以及如何在Debian Linux上将其打包为DEB包。最后但同样重要的是，我们还学习了如何为Android创建可重新分发的APK文件。口号“代码更少，创造更多，部署到任何地方”现在得到了实现。
- en: In the next chapter, which is also the last chapter of this book, in addition
    to how to debug applications, we're also going to look at some common issues and
    solutions to them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也是本书的最后一章，除了如何调试应用程序外，我们还将探讨一些常见问题和解决方案。
