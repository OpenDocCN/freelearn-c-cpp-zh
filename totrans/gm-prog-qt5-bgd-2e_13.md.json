["```cpp\nimport QtQuick 2.9\n\nItem {\n    id: root\n    width: 600; height: width\n    Rectangle {\n        id: rect\n        color: \"red\"\n        width: 50; height: width\n    }\n    NumberAnimation {\n        target: rect\n        property: \"x\"\n        from: 0; to: 550\n        duration: 3000\n        running: true\n    }\n} \n```", "```cpp\nimport QtQuick 2.9\n\nImage {\n    id: root\n    property int dayLength: 60000 // 1 minute\n    source: \"images/sky.png\"\n\n    Item {\n        id: sun\n        x: 140\n        y: root.height - 170\n        Rectangle {\n            id: sunVisual\n            width: 40\n            height: width\n            radius: width / 2\n            color: \"yellow\"\n            anchors.centerIn: parent\n        }\n    }\n    Image {\n        source: \"images/trees.png\"\n        x: -200\n        anchors.bottom: parent.bottom\n    }\n    Image {\n        source: \"images/grass.png\"\n        anchors.bottom: parent.bottom\n    }\n} \n```", "```cpp\nNumberAnimation {\n    target: sun\n    property: \"x\"\n    from: 0\n    to: root.width\n    duration: dayLength\n    running: true\n} \n```", "```cpp\nNumberAnimation {\n    id: sunGoesUpAnim\n    // ...\n    onStopped: sunGoesDownAnimTimer.start()\n}\nTimer {\n    id: sunGoesDownAnimTimer\n    interval: dayLength / 3\n    onTriggered: sunGoesDownAnim.start()\n} \n```", "```cpp\nParallelAnimation {\n    id: parallelAnimationGroup\n    running: true\n\n    NumberAnimation {\n        target: obj1; property: \"prop1\"\n        from: 0; to: 100\n        duration: 1500\n    }\n    NumberAnimation {\n        target: obj2; property: \"prop2\"\n        from: 150; to: 0\n        duration: 1500\n    }\n} \n```", "```cpp\nSequentialAnimation {\n    id: sequentialAnimationGroup\n    running: true\n\n    ParallelAnimation {\n        id: parallelAnimationGroup\n\n        NumberAnimation {\n            id: animation1\n            target: obj2; property: \"prop2\"\n            from: 150; to: 0\n            duration: 1000\n        }\n        NumberAnimation {\n            id: animation2\n            target: obj1; property: \"prop1\"\n            from: 0; to: 100\n            duration: 2000\n        }\n    }\n    PropertyAnimation {\n        id: animation3\n        target: obj1; property: \"prop1\"\n        from: 100; to: 300\n        duration: 1500\n    }\n} \n```", "```cpp\nSequentialAnimation {\n    running: true\n    NumberAnimation {\n        target: sun\n        property: \"y\"\n        from: root.height + sunVisual.height\n        to: root.height - 270\n        duration: dayLength / 3\n    }\n    PauseAnimation { duration: dayLength / 3 }\n    NumberAnimation {\n        target: sun\n        property: \"y\"\n        from: root.height - 270\n        to: root.height + sunVisual.height\n        duration: dayLength / 3\n    }\n} \n```", "```cpp\nNumberAnimation {\n    target: obj\n    property: prop\n    from: startValue\n    to: endValue\n    easing.type: Easing.InOutBounce\n    running: true\n} \n```", "```cpp\nSequentialAnimation {\n    running: true\n    NumberAnimation {\n        target: sun\n        property: \"y\"\n        from: root.height + sunVisual.height\n        to: root.height - 270\n        duration: dayLength / 2\n        easing.type: Easing.OutCubic\n    }\n    NumberAnimation {\n        target: sun\n        property: \"y\"\n        to: root.height + sunVisual.height\n        duration: dayLength / 2\n        easing.type: Easing.InCubic\n    } \n}\n```", "```cpp\nNumberAnimation on rotation {\n    from: 0\n    to: 360\n    duration: 500\n} \n```", "```cpp\nRectangle {\n    id: sunVisual\n    // ...\n    SequentialAnimation on color {\n        ColorAnimation {\n            from: \"red\"\n            to: \"yellow\"\n            duration: 0.2 * dayLength / 2\n        }\n        PauseAnimation { \n            duration: 2 * 0.8 * dayLength / 2 \n        }\n        ColorAnimation {\n            to: \"red\"\n            duration: 0.2 * dayLength / 2\n        }\n        running: true\n    }\n} \n```", "```cpp\nSequentialAnimation on scale {\n    NumberAnimation {\n      from: 1.6; to: 0.8\n      duration: dayLength / 2\n      easing.type: Easing.OutCubic\n    }\n    NumberAnimation {\n      from: 0.8; to: 1.6\n      duration: dayLength / 2\n      easing.type: Easing.InCubic\n    }\n}\n```", "```cpp\nSequentialAnimation {\n    ParallelAnimation {\n        NumberAnimation {\n            target: sun\n            property: \"y\"\n            from: root.height + sunVisual.height\n            to: root.height - 270\n            duration: dayLength / 2\n            easing.type: Easing.OutCubic\n        }\n        NumberAnimation {\n            target: sun\n            property: \"scale\"\n            from: 1.6; to: 0.8\n            duration: dayLength / 2\n            easing.type: Easing.OutCubic\n        } \n        // ... \n    }\n}\n```", "```cpp\nItem { \n    id: sunRays \n    property int count: 10 \n    width: sunVisual.width \n    height: width \n    anchors.centerIn: parent \n    z: -1 \n    Repeater { \n        model: sunRays.count \n        Rectangle { \n            color: \"red\" \n            rotation: index * 360 / sunRays.count \n            anchors.fill: parent \n        }\n    }\n} \n```", "```cpp\nimport QtQuick 2.9\n\nItem {\n    width: 600; height: width\n    Item {\n        id: empty\n        x: parent.width / 2; y: parent.height / 2\n        Rectangle {\n            id: rect\n            width: 100; height: width\n            color: \"red\"\n            anchors.centerIn: parent\n        }\n    }\n    MouseArea {\n        anchors.fill: parent\n        onClicked: { \n            empty.x = mouse.x;\n            empty.y = mouse.y;\n        }\n    }\n} \n```", "```cpp\nItem {\n    id: empty\n    x: parent.width / 2; y: parent.height / 2\n    Rectangle {\n        id: rect\n        width: 100; height: width\n        color: \"red\"\n        anchors.centerIn: parent\n    }\n Behavior on x { \n NumberAnimation { } \n }\n Behavior on y { \n NumberAnimation { } \n }\n} \n```", "```cpp\nBehavior on x {\n    SequentialAnimation {\n        PropertyAction {\n            target: rect\n            property: \"color\"\n            value: \"yellow\"\n        }\n        ParallelAnimation {\n            NumberAnimation { \n                easing.type: Easing.InOutQuad\n                duration: 1000\n            } \n            SequentialAnimation {\n                NumberAnimation {\n                    target: rect\n                    property: \"scale\"\n                    from: 1.0; to: 1.5\n                    duration: 500\n                }\n                NumberAnimation {\n                    target: rect\n                    property: \"scale\"\n                    from: 1.5; to: 1.0\n                    duration: 500\n                }\n            }\n        }\n        PropertyAction { \n            target: rect\n            property: \"color\"\n            value: \"red\" \n        }\n    }\n} \n```", "```cpp\nBehavior on rotation {\n    SmoothedAnimation { \n        velocity: 50 \n    }\n} \n```", "```cpp\nItem {\n    id: lamp\n    property bool lampOn: false\n    width: 200\n    height: 200\n    Rectangle {\n        id: lightsource\n        anchors.fill: parent\n        color: \"transparent\"\n    }\n} \n```", "```cpp\nItem {\n    id: lamp\n    property bool lampOn: false\n    // ...\n    states: State {\n name: \"on\"\n PropertyChanges {\n target: lightsource\n color: \"yellow\"\n }\n }\n} \n```", "```cpp\nonLampOnChanged: state = lampOn ? \"on\" : \"\" \n```", "```cpp\nState {\n    name: \"on\"\n    when: lamp.lampOn\n    PropertyChanges {\n        target: lightsource\n        color: \"yellow\"\n    }\n} \n```", "```cpp\nstates: [\n    State {\n        name: \"on\"\n        when: lamp.lampOn\n        PropertyChanges { /*...*/ }\n\n    },\n    State {\n        name: \"off\"\n        when: !lamp.lampOn\n    }\n] \n```", "```cpp\nItem {\n    id: lamp\n    property bool lampOn: false\n    Rectangle {\n        id: lightsource\n        anchors.fill: parent\n        color: \"yellow\"\n        opacity: 0\n    }\n    MouseArea {\n        anchors.fill: parent\n        onPressed: {\n            lamp.lampOn = !lamp.lampOn;\n        }\n    }\n    states: State {\n        name: \"on\"\n        when: lamp.lampOn\n        PropertyChanges {\n            target: lightsource\n            opacity: 1\n        }\n    }\n    transitions: Transition {\n        NumberAnimation {\n            duration: 500\n            property: \"opacity\"\n        }\n    }\n} \n```", "```cpp\nTransition {\n    SequentialAnimation {\n        NumberAnimation { \n            target: lightsource\n            property: \"opacity\"            \n            duration: 500 \n        }\n        ScriptAction { \n            script: {\n                console.log(\"Transition has ended\");\n            }\n        }\n    }\n} \n```", "```cpp\nvoid Scene::keyEvent(QKeyEvent *event) {\n    switch(event->key()) {\n    case Qt::Key_Right: \n        player->goRight(); break;\n    case Qt::Key_Left:  \n        player->goLeft();  break;\n    case Qt::Key_Space: \n        player->jump();    break;\n    // ...\n    }\n} \n```", "```cpp\nItem {\n    id: player\n    y: parent.height\n    focus: true\n\n    Keys.onRightPressed: x = Math.min(x + 20, parent.width)\n    Keys.onLeftPressed: x = Math.max(0, x - 20)\n    Keys.onUpPressed: jump()\n\n    function jump() { \n        jumpAnim.start();\n    }\n\n    Image {\n        source: \"images/elephant.png\"\n        anchors.bottom: parent.bottom\n        anchors.horizontalCenter: parent.horizontalCenter\n    }\n    Behavior on x { \n        NumberAnimation { duration: 100 } \n    }\n    SequentialAnimation on y {\n        id: jumpAnim\n        running: false\n        NumberAnimation { \n            to: player.parent.height - 50\n            easing.type: Easing.OutQuad \n        } \n        NumberAnimation { \n            to: player.parent.height\n            easing.type: Easing.InQuad \n        } \n    }\n} \n```", "```cpp\nPlayer {\n    id: player\n    x: 40\n} \n```", "```cpp\nItem {\n    id: player\n    //...\n    QtObject {\n        id: flags\n        readonly property int speed: 100\n        property int horizontal: 0\n    }\n    Keys.onRightPressed: { \n        recalculateDurations(); \n        flags.horizontal = 1; \n    }\n    Keys.onLeftPressed: {\n        if(flags.horizontal != 0) {\n            return;\n        }\n        recalculateDurations();\n        flags.horizontal = -1;\n    }\n    Keys.onUpPressed: jump()\n    Keys.onReleased: {\n        if(event.isAutoRepeat) return;\n        if(event.key === Qt.Key_Right) {\n            flags.horizontal = 0;\n        }\n        if(event.key === Qt.Key_Left && flags.horizontal < 0) {\n            flags.horizontal = 0;\n        }\n    }\n\n    function recalculateDurations() {\n        xAnimRight.duration = (xAnimRight.to - x) * 1000 / flags.speed;\n        xAnimLeft.duration = (x - xAnimLeft.to) * 1000 / flags.speed;\n    }\n    NumberAnimation on x {\n        id: xAnimRight\n        running: flags.horizontal > 0\n        to: parent.width\n    }\n    NumberAnimation on x {\n        id: xAnimLeft\n        running: flags.horizontal < 0\n        to: 0\n    } \n}\n```", "```cpp\nItem {\n    id: coin\n\n    Rectangle {\n        id: coinVisual\n        color: \"yellow\"\n        border.color: Qt.darker(color)\n        border.width: 2\n        width: 30; height: width\n        radius: width / 2\n        anchors.centerIn: parent\n\n        transform: Rotation {\n            origin.x: coinVisual.width / 2\n            origin.y: coinVisual.height / 2\n            axis { x: 0; y: 1; z: 0 }            \n            NumberAnimation on angle {\n                from: 0; to: 360\n                loops: Animation.Infinite\n                running: true\n                duration: 1000\n            }\n        }\n        Text {\n            color: coinVisual.border.color\n            anchors.centerIn: parent\n            text: \"1\"\n        }\n    }\n} \n```", "```cpp\nComponent {\n    id: coinGenerator\n    Coin {}\n}\n\nTimer {\n    id: coinTimer\n    interval: 1000\n    repeat: true\n    running: true\n\n    onTriggered: {\n        var cx = Math.floor(Math.random() * root.width);\n        var cy = Math.floor(Math.random() * root.height / 3)\n               + root.height / 2;\n        coinGenerator.createObject(root, { x: cx, y: cy });\n    }\n} \n```", "```cpp\nImage {\n    id: elephantImage\n    property int currentFrame: 1\n    property int frameCount: 7\n    source: \"images/walking_\" + currentFrame + \".png\"\n    mirror: player.facingLeft\n\n    anchors.bottom: parent.bottom\n    anchors.horizontalCenter: parent.horizontalCenter\n    NumberAnimation on currentFrame {\n        from: 1\n        to: frameCount\n        loops: Animation.Infinite\n        duration: elephantImage.frameCount * 40\n        running: player.walking\n    }\n} \n```", "```cpp\nproperty bool walking: flags.horizontal !== 0\nproperty bool facingLeft: flags.horizontal < 0 \n```", "```cpp\nAnimatedSprite {\n    id: sprite\n    source: \"images/sprite.png\"\n    frameX: 560\n    frameY: 0\n    frameWidth: 80\n    frameHeight: 52\n    frameCount: 7\n    frameRate: 10\n    interpolate: true\n    width: frameWidth\n    height: frameHeight\n\n    running: player.walking\n    anchors.bottom: parent.bottom\n    anchors.horizontalCenter: parent.horizontalCenter\n\n    transform: Scale {\n        origin.x: sprite.width / 2\n        xScale: player.facingLeft ? -1 : 1\n    }\n} \n```", "```cpp\nSpriteSequence {\n    id: sprite\n    width: 80\n    height: 52\n    interpolate: false\n    anchors.bottom: parent.bottom\n    anchors.horizontalCenter: parent.horizontalCenter\n    running: true\n\n    Sprite {\n        name: \"still\"\n        source: \"images/sprite.png\"\n        frameCount: 1\n        frameWidth: 80; frameHeight: 52\n        frameDuration: 100\n        to: { \"still\": 1, \"walking\": 0, \"jumping\": 0 }\n    }\n    Sprite {\n        name: \"walking\"\n        source: \"images/sprite.png\"\n        frameX: 560; frameY: 0\n        frameCount: 7\n        frameWidth: 80; frameHeight: 52\n        frameRate: 20\n        to: { \"walking\": 1, \"still\": 0, \"jumping\": 0 }\n    }\n    Sprite {\n        name: \"jumping\"\n        source: \"images/sprite.png\"\n        frameX: 480; frameY: 52\n        frameCount: 11\n        frameWidth: 80; frameHeight: 70\n        frameDuration: 50\n        to: { \"still\" : 0, \"walking\": 0, \"jumping\": 1 }\n    }\n\n    transform: Scale {\n        origin.x: sprite.width / 2\n        xScale: player.facingLeft ? -1 : 1\n    }\n}\n```", "```cpp\nSequentialAnimation {\n    id: jumpAnim\n    running: false\n ScriptAction { \n script: {\n sprite.goalSprite = \"jumping\";\n }\n }\n    NumberAnimation {\n        target: player; property: \"y\"\n        to: player.parent.height - 50\n        easing.type: Easing.OutQuad\n    }\n    NumberAnimation {\n        target: player; property: \"y\"\n        to: player.parent.height\n        easing.type: Easing.InQuad\n    }\n ScriptAction {\n script: { \n sprite.goalSprite = \"\";\n sprite.jumpTo(\"still\"); \n }\n }\n} \n```", "```cpp\nimport QtQuick 2.9\n\nItem {\n    id: root\n    property int currentPos\n    x: -currentPos * (root.width - root.parent.width) / width\n} \n```", "```cpp\nimport QtQuick 2.9\n\nItem {\n    property real factor: 0\n    x: factor > 0 ? -parent.currentPos / factor - parent.x : 0\n} \n```", "```cpp\nRectangle {\n    id: view\n\n    width: 600\n    height: 380\n\n    ParallaxScene {\n        id: scene\n        width: 1500; height: 380\n        anchors.bottom: parent.bottom\n        currentPos: player.x\n\n        ParallaxLayer {\n            factor: 7.5\n            width: sky.width; height: sky.height\n            anchors.bottom: parent.bottom\n            Image { id: sky; source: \"images/sky.png\" }\n            Item {\n                 id: sun\n                 //...\n            }\n        }\n        ParallaxLayer {\n            factor: 2.5\n            width: trees.width; height: trees.height\n            anchors.bottom: parent.bottom\n            Image { id: trees; source: \"images/trees.png\" }\n        }\n        ParallaxLayer {\n            factor: 0\n            width: grass.width; height: grass.height\n            anchors.bottom: parent.bottom\n            Image { id: grass; source: \"images/grass.png\" }\n        }\n\n        Item {\n            id: player\n            // ...\n        }\n        Component {\n            id: coinGenerator\n            Coin {}\n        }\n        Timer {\n            id: coinTimer\n            //...\n            onTriggered: {\n                var cx = Math.floor(Math.random() * scene.width);\n                var cy = Math.floor(Math.random() * scene.height / 3) +\n                    scene.height / 2;\n                coinGenerator.createObject(scene, { x: cx, y: cy});\n            }\n        }\n    }\n}\n```", "```cpp\n.pragma library\n\nfunction boundingBox(object1) {\n    var cR = object1.childrenRect;\n    var mapped = object1.mapToItem(\n         object1.parent, cR.x, cR.y, cR.width, cR.height);\n    return Qt.rect(mapped.x, mapped.y, mapped.width, mapped.height);\n}\n\nfunction intersect(object1, object2) {\n    var r1 = boundingBox(object1);\n    var r2 = boundingBox(object2);\n    return (r1.x <= r2.x+r2.width && // r1.left <= r2.right\n            r2.x <= r1.x+r1.width && // r2.left <= r1.right\n            r1.y <= r2.y+r2.height && // r1.top <= r2.bottom\n            r2.y <= r1.y+r1.height); // r2.top <= r1.bottom\n} \n```", "```cpp\n.import \"collisions.js\" as Collisions\n\nvar coins = []\n\ncoins.collisionsWith = function(player) {\n    var collisions = [];\n    for(var index = 0; index < coins.length; ++index) {\n        var obj = this[index];\n        if(Collisions.intersect(player, obj)) {\n            collisions.push(obj);\n        }\n    }\n    return collisions;\n};\ncoins.remove = function(obj) {\n    var arr = Array.isArray(obj) ? obj : [ obj ];\n    var L = arr.length;\n    var idx, needle;\n    while(L && this.length) {\n        needle = arr[--L];\n        idx = this.indexOf(needle);\n        if(idx !== -1) { \n             this.splice(idx, 1);\n        }\n    }\n    return this;\n};\n```", "```cpp\nimport \"coins.js\" as Coins\n```", "```cpp\nfunction checkCollisions() {\n    var result = Coins.coins.collisionsWith(player);\n    if(result.length === 0) return;\n    result.forEach(function(coin) { coin.hit() });\n    Coins.coins.remove(result) // prevent the coin from being hit again\n}\n```", "```cpp\nTimer {\n    id: coinTimer\n    //...\n    onTriggered: {\n        var cx = Math.floor(Math.random() * scene.width);\n        var cy = scene.height - 60 - Math.floor(Math.random() * 60);\n        var coin = coinGenerator.createObject(scene, { x: cx, y: cy});\n        Coins.coins.push(coin);\n    }\n}\n```", "```cpp\nonXChanged: { \n    checkCollisions();\n}\nonYChanged: { \n    checkCollisions();\n} \n```", "```cpp\nSequentialAnimation {\n    id: hitAnim\n    running: false\n    NumberAnimation {\n        target: coin\n        property: \"opacity\"\n        from: 1; to: 0\n        duration: 250\n    }\n    ScriptAction {\n        script: coin.destroy()\n    }\n}\n\nfunction hit() {\n    hitAnim.start();\n} \n```"]