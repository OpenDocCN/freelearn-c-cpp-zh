- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Adding Instrumentation and Measuring Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加性能测量工具和测量性能
- en: 'In this chapter, we will add a system to measure the performance of the C++
    components we have built so far in this book. We will measure the latencies in
    the trading exchange system we built in *Part 2* and the latencies in the client’s
    trading system built in the previous section. Finally, we will measure and analyze
    the performance of the end-to-end system by running the different algorithms we
    built in the previous section. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加一个系统来测量本书中构建的C++组件的性能。我们将测量我们在*第2部分*中构建的交易交易所系统的延迟以及在前一节中构建的客户端交易系统的延迟。最后，我们将通过运行前一节中构建的不同算法来测量和分析端到端系统的性能。在本章中，我们将涵盖以下主题：
- en: Adding an instrumentation system to measure system performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个用于测量系统性能的仪器系统
- en: Measuring latencies in the exchange
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量交易所的延迟
- en: Measuring latencies in the trading engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量交易引擎的延迟
- en: Running the entire ecosystem with the new instrumentation system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的仪器系统运行整个生态系统
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in the book’s GitHub repository at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter11` directory in the repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在GitHub仓库[https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)中找到。本章的源代码位于仓库中的`Chapter11`目录。
- en: This chapter relies on a lot of the previous chapters since we will be measuring
    the performance of all the different components and subcomponents in the electronic
    trading ecosystem. So, we expect you to be familiar with the code base we have
    built so far, specifically, the *Building the C++ Matching Engine*, *Communicating
    with Market Participants*, *Processing Market Data and Sending Orders to the Exchange
    in C++*, *Building the C++ Trading Algorithm Building Blocks*, and finally, *Building
    the C++ Market Making and Liquidity Taking* *Algorithms* chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章依赖于许多前面的章节，因为我们将会测量电子交易生态系统中所有不同组件和子组件的性能。因此，我们期望您熟悉我们迄今为止构建的代码库，特别是*构建C++匹配引擎*、*与市场参与者通信*、*在C++中处理市场数据和向交易所发送订单*、*构建C++交易算法构建块*以及最终*构建C++市场做市和流动性获取算法*章节。
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown next. We present the details of this environment since
    all the C++ code presented in this book is not necessarily portable and might
    require some minor changes to work in your environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码开发环境的规格如下所示。我们提供此环境的详细信息，因为本书中展示的所有C++代码可能并不一定可移植，可能需要在您的环境中进行一些小的修改才能运行：
- en: 'OS – `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '操作系统 – `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue
    Apr 18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
- en: GCC – `g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC – `g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`
- en: CMake – `cmake` `version 3.23.2`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake – `cmake` `版本 3.23.2`
- en: Ninja – `1.10.2`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ninja – `1.10.2`
- en: Adding an instrumentation system to measure system performance
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个用于测量系统性能的仪器系统
- en: The first task we need to tackle is to add a few utility methods that will serve
    as the base of our performance measurement system. These are meant to be used
    to measure the latencies of internal components and subcomponents for processes
    running on the same server. These are also meant to be used to measure latencies
    between the different components, which are unlikely to be on the same server
    in practice, such as the trading exchange and the trading clients, which are on
    different servers. Note, however, that in this book, we run the trading exchange
    and the trading clients on the same server for simplicity. Now, let us start by
    adding these utilities in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的首要任务是添加一些实用方法，这些方法将作为我们性能测量系统的基石。这些方法旨在用于测量在同一服务器上运行的进程的内部组件和子组件的延迟。这些方法也旨在用于测量不同组件之间的延迟，实际上这些组件可能不在同一服务器上，例如交易交易所和交易客户端，它们位于不同的服务器上。然而，请注意，在本书中，为了简化，我们在同一服务器上运行交易交易所和交易客户端。现在，让我们从下一节开始添加这些工具。
- en: Adding utilities for performance measurement using RDTSC
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RDTSC添加性能测量工具
- en: 'The first performance measurement utility we add does not directly measure
    the time itself but, instead, measures how many CPU clock cycles elapse between
    two spots in our code base. This is achieved by reading the value of the `rdtsc`,
    to fetch and return this value, which returns this in the form of two 32-bit values
    that we will convert into a single 64-bit value. We can use these `rdtsc` values
    as is to measure/compare performance if we do not really care about converting
    them into time units. The other option is to convert this `rdtsc` value into time
    units, which is achieved by dividing this value by the system’s clock frequency,
    which is specified as the number of CPU clock cycles per second. For instance,
    on my system, the CPU clock frequency comes out to be around 2.6 GHz, as shown
    here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一个性能测量工具并不直接测量时间本身，而是测量代码库中两个位置之间经过的 CPU 时钟周期数。这是通过读取 `rdtsc` 的值来实现的，以获取并返回这个值，它以两个
    32 位值的格式返回这个值，我们将这些值转换成一个单一的 64 位值。如果我们不关心将它们转换为时间单位，我们可以直接使用这些 `rdtsc` 值来测量/比较性能。另一种选择是将这个
    `rdtsc` 值转换为时间单位，这是通过将这个值除以系统的时钟频率来实现的，该频率指定为每秒的 CPU 时钟周期数。例如，在我的系统中，CPU 时钟频率大约为
    2.6 GHz，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What this means is that if we measure the `rdtsc` value before and after the
    execution of a code block and the difference between the two values is 26 clock
    cycles, on my system, that translates to approximately 26 / 2.6 = a 10-nanosecond
    execution time. We will talk about this more in the last subsection of this section,
    *Understanding some issues with measurement systems in practice*. So, without
    any more delay, let us look at the code for this measurement implementation. All
    the code for this section can be found in the `Chapter11/common/perf_utils.h`
    source file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们测量代码块执行前后 `rdtsc` 值，并且这两个值之间的差是 26 个时钟周期，在我的系统中，这相当于大约 26 / 2.6 = 10
    纳秒的执行时间。我们将在本节最后的小节中进一步讨论这个问题，*理解实践中测量系统的一些问题*。因此，不再拖延，让我们看看这个测量实现的代码。本节的所有代码都可以在
    `Chapter11/common/perf_utils.h` 源文件中找到。
- en: 'First, we implement an `rdtsc()` C++ method, which internally calls the `rdtsc`
    assembly instruction and provides it with two variables, `lo` and `hi`, to read
    the lower and higher 32-bits that make up the final `rdtsc` value. The `__asm__`
    instruction tells the compiler that what follows it is an assembly instruction.
    The `__volatile__` instruction exists to prevent the compiler from optimizing
    the instructions so that it is executed as is to make sure we read the TSC register
    every time this is called. We save the output into the `lo` and `hi` variables
    and, finally, using a bit shift operation, create a 64-bit value from them and
    return it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现了一个 `rdtsc()` C++ 方法，该方法内部调用 `rdtsc` 汇编指令，并为其提供两个变量 `lo` 和 `hi`，以读取构成最终
    `rdtsc` 值的低位和高位 32 位。`__asm__` 指令告诉编译器其后的内容是一个汇编指令。`__volatile__` 指令存在是为了防止编译器优化指令，以确保每次调用时都执行原样指令，从而确保我们每次都读取
    TSC 寄存器。我们将输出保存到 `lo` 和 `hi` 变量中，最后，通过位移操作，从它们中创建一个 64 位值并返回：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will define a simple preprocessor macro, `START_MEASURE`, which accepts
    an argument called `TAG`, and all it does is create a variable with that name
    and saves the value of the `rdtsc()` method we just built in it. In other words,
    this macro simply creates a variable with the name provided and saves the `rdtsc()`
    value in it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个简单的预处理器宏 `START_MEASURE`，它接受一个名为 `TAG` 的参数，它所做的只是创建一个具有该名称的变量，并将我们刚刚构建的
    `rdtsc()` 方法的值保存在其中。换句话说，这个宏只是创建一个具有提供的名称的变量，并将 `rdtsc()` 值保存在其中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define another complimentary macro called `END_MEASURE`, which accepts an
    argument called `TAG` as well as an argument called `LOGGER`, which it expects
    to be of our `Common::Logger` type. It takes another measurement using the `rdtsc()`
    method we built previously and uses the `LOGGER` object to log the difference
    between the two. The only reason this code block is enclosed in a `do {} while(false)`
    loop (without a terminating semi-colon) is to make sure that the compiler catches
    missing semi-colons when this method is invoked. In other words, `END_MEASURE(example,
    logger_);` is a valid use but `END_MEASURE(example, logger_)` (missing semi-colon)
    causes a compilation error to maintain symmetry with `START_MEASURE`. This is
    not strictly necessary, just a preference on our part:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义另一个互补的宏`END_MEASURE`，它接受一个名为`TAG`的参数以及一个名为`LOGGER`的参数，它期望`LOGGER`是`Common::Logger`类型。它使用我们之前构建的`rdtsc()`方法进行另一个测量，并使用`LOGGER`对象记录两个之间的差异。这个代码块被包含在`do
    {} while(false)`循环中（没有终止的分号），是为了确保编译器在调用此方法时捕获缺少的分号。换句话说，`END_MEASURE(example,
    logger_);`是一个有效的用法，但`END_MEASURE(example, logger_)`（缺少分号）会导致编译错误，以保持与`START_MEASURE`的对称性。这并不是严格必要的，只是我们的一种偏好：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we will define a similar macro called `TTT_MEASURE` that takes similar
    arguments (i.e., `TAG` and `LOGGER`), This macro simply logs the current time
    in nanoseconds, which it obtains by calling our `Common::getCurrentNanos()` method
    that we saw before:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义一个名为`TTT_MEASURE`的类似宏，它接受类似的参数（即，`TAG`和`LOGGER`），这个宏简单地记录当前时间（以纳秒为单位），它是通过调用我们之前看到的`Common::getCurrentNanos()`方法来获取的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will use these macros throughout this chapter, but before we do that, we
    need to make some minor changes to the time utilities we built before and have
    seen many uses of already.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用这些宏，但在我们这样做之前，我们需要对我们之前构建并已经看到许多用途的时间工具做一些小的修改。
- en: Updating our previous time utilities
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们之前的时间工具
- en: 'In this section, we will make a minor change to the time utility `Common::getCurrentTimeStr()`
    method to make the output more informative and granular. The goal here is to change
    our previous output, which looked like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对时间工具`Common::getCurrentTimeStr()`方法进行一些小的修改，以使输出更具有信息性和粒度。这里的目的是改变我们之前的输出，它看起来像这样：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want to change it to this format, which drops the date and year from the
    output and changes the time output from just having seconds to having seconds
    and nanoseconds to add granularity:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将其更改为这种格式，该格式从输出中删除日期和年份，并将时间输出从只有秒更改为有秒和纳秒以增加粒度：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will help us inspect, order, and analyze events that happen in the same
    second even more closely. These changes can be found in the `Chapter11/common/time_utils.h`
    source file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们更仔细地检查、排序和分析在同一秒内发生的事件。这些更改可以在`Chapter11/common/time_utils.h`源文件中找到。
- en: 'Note that the other change is the inclusion of the `perf_utils.h` header file
    containing the measurement methods we built in the previous section:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，另一个更改是包含包含我们在上一节中构建的测量方法的`perf_utils.h`头文件：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We saw this before in the *Building the C++ Building Blocks for Low-Latency
    Applications* chapter in the *Designing utility methods for time* section. We
    call `std::chrono::system_clock::now()` to extract the current `time_point` value
    and save it in the `clock` variable. We also extract and save the `time_t` object
    from it into the `time` variable using the `std::chrono::system_clock::to_time_t()`
    method, as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*设计时间工具*部分的*为低延迟应用构建C++构建块*章节中看到了这一点。我们调用`std::chrono::system_clock::now()`来提取当前的`time_point`值并将其保存到`clock`变量中。我们还使用`std::chrono::system_clock::to_time_t()`方法从它中提取并保存`time_t`对象到`time`变量中，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We use a combination of `sprintf()`, `ctime()`, and the previously seen `std::chrono::duration_cast<std::chrono::nanoseconds>(clock.time_since_epoch()).count()`
    method to extract and format the current time in the `HH:MM:SS.nnnnnnnnn` format.
    Finally, we assign it to the `time_str` object of the `std::string` type, which
    is passed to this method, as well as return it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sprintf()`、`ctime()`和之前看到的`std::chrono::duration_cast<std::chrono::nanoseconds>(clock.time_since_epoch()).count()`方法组合来提取和格式化当前时间，格式为`HH:MM:SS.nnnnnnnnn`。最后，我们将它赋值给`std::string`类型的`time_str`对象，该对象作为参数传递给此方法，并返回它：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we move on to using these new methods, we will discuss a few more points
    regarding measuring performance in practice.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用这些新方法之前，我们将讨论一些关于实践中测量性能的更多要点。
- en: Understanding some issues with measurement systems in practice
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解实践中测量系统的一些问题
- en: In this section, we will discuss a few important considerations when it comes
    to measuring performance in practice. This is important to understand because
    performance measurement is not always as easy as it seems and it requires you
    to understand some nuances.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在实践中进行性能测量时的一些重要考虑因素。这一点很重要，因为性能测量并不总是像看起来那么简单，它需要你理解一些细微差别。
- en: Adding overhead due to instrumentation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由于仪器而增加的开销
- en: The first key point we want to make about measuring performance in practice
    is that it is important to consider that the measurement system itself is not
    zero-latency. What this means is that adding instrumentation into the path of
    the critical code base adds some extra latency. It is important to make sure that
    the instrumentation system/routine itself is extremely low-latency relative to
    the latency of the system it’s measuring. A hypothetical example is that if we
    are measuring something that takes a few microseconds, we need to make sure that
    the measurement routines take a few nanoseconds to not add too much overhead.
    One of the reasons we have the option of using `rdtsc()` to measure performance
    is that it is significantly faster than calling something such as `std::chrono::system_clock::now()`
    or `clock_gettime()`. That gives us the option of using `rdtsc()` if we are measuring
    a code block that has extremely low latency to add minimal overhead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于实践性能测量的第一个关键点是，重要的是要考虑测量系统本身并不是零延迟。这意味着将仪器添加到关键代码路径中会增加一些额外的延迟。确保仪器系统/例程本身相对于它所测量的系统延迟非常低是非常重要的。一个假设的例子是，如果我们正在测量需要几微秒的事情，我们需要确保测量例程只需要几纳秒，以避免增加过多的开销。我们能够选择使用`rdtsc()`来测量性能的一个原因是因为它比调用诸如`std::chrono::system_clock::now()`或`clock_gettime()`这样的方法要快得多。这给了我们在测量具有极低延迟的代码块时使用`rdtsc()`的选择，以添加最小的开销。
- en: Understanding the limitations and reliability of RDTSC
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解RDTSC的限制和可靠性
- en: The second key point is regarding `rdtsc()`, which is not always very portable
    and can have reliability concerns depending on the platform. Another consideration
    with `rdtsc()` when converting it into time units is that CPU clock frequency
    can vary from core to core on a system, and using a static CPU clock frequency
    for the conversion is not always accurate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键点是关于`rdtsc()`，它并不总是非常便携，并且根据平台可能会有可靠性问题。当将`rdtsc()`转换为时间单位时，另一个考虑因素是系统中的CPU时钟频率可能从核心到核心有所不同，使用静态CPU时钟频率进行转换并不总是准确的。
- en: Setting up the correct measurement environment
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置正确的测量环境
- en: 'The third point regarding measuring performance on trading servers is that
    a lot of tuning needs to be done to facilitate accurate measurements. This involves
    techniques such as disabling interrupts, making sure unnecessary processes are
    not running, making sure the NUMA setup is correct, tweaking CPU power settings,
    setting up CPU isolation, pinning threads to specific cores, and so on. Discussing
    all these considerations when it comes to electronic trading is beyond the scope
    of this book, nor is it the focus of this book. We just wanted to mention that
    there are additional considerations when it comes to performance measurement.
    We refer interested readers to the book *Developing High-Frequency Trading Systems:
    Learn how to implement high-frequency trading from scratch with C++ or Java basics*,
    which discusses **High-Frequency electronic Trading** (**HFT**) specific considerations.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在交易服务器上测量性能的第三个要点是，需要进行大量的调整以方便准确测量。这包括禁用中断、确保不必要的进程没有运行、确保NUMA设置正确、调整CPU电源设置、设置CPU隔离、将线程固定到特定核心等技术。在电子交易方面讨论所有这些考虑因素超出了本书的范围，也不是本书的重点。我们只想提到，在性能测量方面还有其他考虑因素。我们建议感兴趣的读者参考书籍《开发高频交易系统：从C++或Java基础知识开始，学习如何从头实现高频交易》，该书讨论了**高频电子交易**（**HFT**）的具体考虑因素。
- en: Now we can move on to using the performance measurement system we built in this
    section in our electronic trading ecosystem, starting with the exchange in the
    next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用本节中构建的性能测量系统，在我们的电子交易生态系统中，从下一节中的交易所开始。
- en: Measuring latencies at the exchange
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在交易所测量延迟
- en: First, we will add instrumentation to the components on the electronic trading
    exchange side – the market data publisher, the matching engine, and the order
    server. Our approach to measuring performance will comprise two forms; let us
    understand those first before we look at the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向电子交易交易所侧的组件添加仪器——市场数据发布者、撮合引擎和订单服务器。我们的性能测量方法将包括两种形式；在我们查看代码之前，让我们先了解这些。
- en: Understanding how to measure internally
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解如何测量内部组件
- en: 'The first approach is to measure the latency of internal components – for example,
    how long does a call to the `Exchange::MatchingEngine::processClientRequest()`
    method take or how long does a call to the `Exchange::MEOrderBook::add()` method
    take? For these cases, we will use a pair of `START_MEASURE()` and `END_MEASURE()`
    macros, which, in turn, use the `rdtsc()` method to measure the performance of
    each such call. There is nothing here that prevents us from using the `TTT_MEASURE()`
    macro in place of `rdtsc()` or as a supplement. But we will use `rdtsc()` for
    these, for the sake of providing examples of how to use the two different instrumentation
    systems. Additionally, we use the rationale that a call to a function such as
    the one we mentioned previously should be very quick and it might be better to
    use the lower overhead `rdtsc()` methods for that. The complete list of internal
    measurements we will take is listed next, but interested readers should use similar
    techniques to add even more points of measurement as they see fit. We will see
    the code for how to measure these familiar methods shortly, but for now, the methods
    we will measure on the exchange side are the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是测量内部组件的延迟——例如，调用`Exchange::MatchingEngine::processClientRequest()`方法需要多长时间，或者调用`Exchange::MEOrderBook::add()`方法需要多长时间？对于这些情况，我们将使用一对`START_MEASURE()`和`END_MEASURE()`宏，它们反过来使用`rdtsc()`方法来测量此类调用的性能。这里没有任何阻止我们使用`TTT_MEASURE()`宏代替`rdtsc()`或作为补充的地方。但我们将使用`rdtsc()`来测量这些，为了提供如何使用两种不同仪器系统的示例。此外，我们使用这样的理由：对像我们之前提到的那种函数的调用应该非常快，可能最好使用开销较低的`rdtsc()`方法。我们将采取的完整内部测量列表将在下面列出，但感兴趣的读者应使用类似的技术根据需要添加更多测量点。我们将在稍后看到如何测量这些熟悉方法的代码，但现在，我们将测量在交易所侧的方法如下：
- en: '`Common::McastSocket::send()`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Common::McastSocket::send()`'
- en: '`Exchange::MEOrderBook::add()`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::add()`'
- en: '`Exchange::MEOrderBook::cancel()`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::cancel()`'
- en: '`Exchange::MatchingEngine::processClientRequest()`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MatchingEngine::processClientRequest()`'
- en: '`Exchange::MEOrderBook::removeOrder()`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::removeOrder()`'
- en: '`Exchange::MEOrderBook::match()`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::match()`'
- en: '`Exchange::MEOrderBook::match()`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::match()`'
- en: '`Exchange::MEOrderBook::checkForMatch()`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::checkForMatch()`'
- en: '`Exchange::MEOrderBook::addOrder()`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::addOrder()`'
- en: '`Exchange::MEOrderBook::removeOrder()`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::MEOrderBook::removeOrder()`'
- en: '`Common::TCPSocket::send()`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Common::TCPSocket::send()`'
- en: '`Exchange::FIFOSequencer::addClientRequest()`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::FIFOSequencer::addClientRequest()`'
- en: '`Exchange::FIFOSequencer::sequenceAndPublish()`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange::FIFOSequencer::sequenceAndPublish()`'
- en: Next, let us take a few steps back and understand which high-level spots/hops
    we will timestamp in the electronic trading exchange.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们退后几步，了解在电子交易交易所我们将对哪些高级位置/跳数进行时间戳记录。
- en: Understanding key hops at the exchange
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解在交易所的关键跳数
- en: In addition to measuring the functioning of internal components, exchanges can
    record performance data, especially timestamps, to track how events (client requests)
    propagate through the different components and subcomponents. We mean tracking
    and, often, publishing metrics such as when an order reached the order server,
    when it reached the matching engine, when the response to that request left the
    order server, when market updates corresponding to that request left the market
    data publisher, and so on. By recording these metrics, exchanges can understand
    and investigate their performance under different market/load conditions, track
    per-participant performance, and so on. By publishing these metrics to the market
    participants, the participants can understand and investigate their own performance
    and consider ways to improve them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测量内部组件的功能外，交易所可以记录性能数据，特别是时戳，以追踪事件（客户端请求）如何通过不同的组件和子组件传播。我们指的是追踪，通常还包括发布指标，例如订单何时到达订单服务器，何时到达撮合引擎，响应请求何时离开订单服务器，对应请求的市场更新何时离开市场数据发布者，等等。通过记录这些指标，交易所可以了解和调查其在不同市场/负载条件下的性能，跟踪每个参与者的性能，等等。通过将这些指标发布给市场参与者，参与者可以了解和调查自己的性能，并考虑改进的方法。
- en: 'In our electronic trading exchange, we will take timestamps of the following
    events:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电子交易交易所中，我们将记录以下事件的时戳：
- en: '`T1_OrderServer_TCP_read` – the time when a client request is first read at
    the TCP socket in `OrderServer`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T1_OrderServer_TCP_read` – 客户请求首次在`OrderServer`中的TCP套接字中被读取的时间'
- en: '`T2_OrderServer_LFQueue_write` – the time when a client request is written
    to `LFQueue` that connects to `MatchingEngine`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T2_OrderServer_LFQueue_write` – 客户请求被写入连接到`MatchingEngine`的`LFQueue`的时间'
- en: '`T3_MatchingEngine_LFQueue_read` – the time when `MatchingEngine` reads a client
    request from `LFQueue`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T3_MatchingEngine_LFQueue_read` – `MatchingEngine`从`LFQueue`读取客户端请求的时间'
- en: '`T4_MatchingEngine_LFQueue_write` – the time when the market update is written
    to the `LFQueue` connected to `MarketDataPublisher`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T4_MatchingEngine_LFQueue_write` – 市场更新被写入连接到`MarketDataPublisher`的`LFQueue`的时间'
- en: '`T4t_MatchingEngine_LFQueue_write` – the time when the client response is written
    to the `LFQueue` connected to `OrderServer`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T4t_MatchingEngine_LFQueue_write` – 客户端响应被写入连接到`OrderServer`的`LFQueue`的时间'
- en: '`T5_MarketDataPublisher_LFQueue_read` – the time when the market update is
    read from `LFQueue`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T5_MarketDataPublisher_LFQueue_read` – 从`LFQueue`读取市场更新的时间'
- en: '`T5t_OrderServer_LFQueue_read` – the time when the client response is read
    from `LFQueue`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T5t_OrderServer_LFQueue_read` – 从`LFQueue`读取客户端响应的时间'
- en: '`T6_MarketDataPublisher_UDP_write` – the time when the market update is written
    to the UDP socket in `MarketDataPublisher`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T6_MarketDataPublisher_UDP_write` – 市场更新被写入`MarketDataPublisher`中的UDP套接字的时间'
- en: '`T6t_OrderServer_TCP_write` – the time when the client response is written
    to the TCP socket in `OrderServer`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T6t_OrderServer_TCP_write` – 客户端响应被写入`OrderServer`中的TCP套接字的时间'
- en: 'The exact locations of these timestamps are shown in the following figure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些时戳的确切位置在以下图中显示：
- en: '![Figure 11.1 – The topology of the electronic trading exchange with the key
    hops to timestamp](img/B19434_11_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 带有时戳关键跳转的电子交易交易所拓扑结构](img/B19434_11_01.jpg)'
- en: Figure 11.1 – The topology of the electronic trading exchange with the key hops
    to timestamp
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 带有时戳关键跳转的电子交易交易所拓扑结构
- en: Now, starting in the next section, we can start looking at the code changes
    we need to add to these two forms of measurement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从下一节开始，我们可以开始查看我们需要添加到这两种测量形式的代码更改。
- en: Measuring the latencies inside the market data publisher
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量市场数据发布者内部的延迟
- en: First, we will add performance measurement and timestamping code to the market
    data publisher. For the sake of brevity, we will only show the code blocks where
    we make these changes instead of including the source code for the entire source
    file or full code blocks in the case of large code blocks. All the changes, as
    well as the full, updated source code for the market data publisher-related changes,
    are in the `Chapter11/exchange/market_data/market_data_publisher.cpp` source file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向市场数据发布者添加性能测量和时戳代码。为了简洁起见，我们只展示我们进行这些更改的代码块，而不是包括整个源文件或大型代码块中的源代码。所有更改以及与市场数据发布者相关的完整、更新后的源代码都在`Chapter11/exchange/market_data/market_data_publisher.cpp`源文件中。
- en: 'First, in the `MarketDataPublisher::run()` method, we will add a timestamp
    using the `TTT_MEASURE` macro and the `T5_MarketDataPublisher_LFQueue_read` tag
    right after reading from `outgoing_md_updates_` `LFQueue`, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`MarketDataPublisher::run()`方法中，我们将在从`outgoing_md_updates_` `LFQueue`读取后立即使用带有`T5_MarketDataPublisher_LFQueue_read`标记的`TTT_MEASURE`宏添加时间戳，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will measure the time taken to call `MCastSocket::send()` on `incremental_socket_`
    using the `START_MEASURE` and `END_MEASURE` macros and the `Exchange_McastSocket_send`
    tag:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`START_MEASURE`和`END_MEASURE`宏以及`Exchange_McastSocket_send`标记来测量在`incremental_socket_`上调用`MCastSocket::send()`所需的时间：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will take another timestamp using the `TTT_MEASURE` macro and the
    `T6_MarketDataPublisher_UDP_write` tag right after the socket write is finished:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在套接字写入完成后，我们将使用带有`T6_MarketDataPublisher_UDP_write`标记的`TTT_MEASURE`宏再次获取时间戳：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let us look at the changes in the `OrderServer` component for performance
    measurement and timestamping.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`OrderServer`组件在性能测量和时间戳方面的更改。
- en: Measuring the latencies inside the order server
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量订单服务器内部的延迟
- en: All the changes for performance measurement and timestamping, as well as the
    full source code for `OrderServer`, are in the `Chapter11/exchange/order_server/order_server.h`
    source file. As before, we will only show minimal code blocks where the changes
    are made for the sake of brevity and to avoid repetition.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于性能测量和时间戳的更改，以及`OrderServer`的完整源代码，都在`Chapter11/exchange/order_server/order_server.h`源文件中。和之前一样，我们将只展示更改所做的最小代码块，以节省篇幅并避免重复。
- en: 'First, we will make changes to the `OrderServer::run()` method, right after
    reading an entry from `outgoing_responses_` `LFQueue`. We use the `TTT_MEASURE`
    macro with the `T5t_OrderServer_LFQueue_read` tag, as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将修改`OrderServer::run()`方法，在从`outgoing_responses_` `LFQueue`读取条目后立即进行。我们使用带有`T5t_OrderServer_LFQueue_read`标记的`TTT_MEASURE`宏，如下所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will measure the call to the `TCPSocket::send()` method using the
    `START_MEASURE` and `END_MEASURE` macros and the `Exchange_TCPSocket_send` tag.
    Note that we measure the call to send out the full client response message, which,
    in our implementation, results in two calls to the `TCPSocket::send()` methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用带有`START_MEASURE`和`END_MEASURE`宏以及`Exchange_TCPSocket_send`标记来测量对`TCPSocket::send()`方法的调用。请注意，我们测量的是发送完整客户端响应消息的调用，在我们的实现中，这会导致对`TCPSocket::send()`方法的两次调用：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, after the TCP socket send operations finish, we take another timestamp
    using the `TTT_MEASURE` method and the `T6t_OrderServer_TCP_write` tag:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在TCP套接字发送操作完成后，我们将使用带有`T6t_OrderServer_TCP_write`标记的`TTT_MEASURE`方法再次获取时间戳：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next set of changes is in the `OrderServer::recvCallback()` method. Right
    as soon as we enter the method, we take a timestamp with the `TTT_MEASURE` macro
    with the `T1_OrderServer_TCP_read` tag:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更改集在`OrderServer::recvCallback()`方法中。当我们刚进入该方法时，我们使用带有`T1_OrderServer_TCP_read`标记的`TTT_MEASURE`宏获取时间戳：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, at the end of this method, we measure the call to `FIFOSequencer::addClientRequest()`,
    using the `START_MEASURE` and `END_MEASURE` macros with the `Exchange_FIFOSequencer_addClientRequest`
    tag:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本方法结束时，我们将使用带有`Exchange_FIFOSequencer_addClientRequest`标记的`START_MEASURE`和`END_MEASURE`宏来测量对`FIFOSequencer::addClientRequest()`的调用：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, for `OrderServer`, we need to update the `OrderServer::recvFinishedCallback()`
    method. We measure the call to the `FIFOSequencer::sequenceAndPublish()` method
    using the `START_MEASURE` and `END_MEASURE` macros with the `Exchange_FIFOSequencer_sequenceAndPublish`
    tag:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`OrderServer`，我们需要更新`OrderServer::recvFinishedCallback()`方法。我们使用带有`Exchange_FIFOSequencer_sequenceAndPublish`标记的`START_MEASURE`和`END_MEASURE`宏来测量对`FIFOSequencer::sequenceAndPublish()`方法的调用：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the next subsection, we will add instrumentation to the `FIFOSequencer` subcomponent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将向`FIFOSequencer`子组件添加仪器。
- en: Measuring the latencies inside FIFOSequencer
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量FIFOSequencer内部的延迟
- en: 'All the instrumentation changes, as well as the full, updated source for the
    `FIFOSequencer` subcomponent, can be found in the `Chapter11/exchange/order_server/fifo_sequencer.h`
    source file. The only changes we will make are in the `FIFOSequencer::sequenceAndPublish()`
    method. Here, all we do is add a timestamp after we write a client request to
    `incoming_requests_` `LFQueue`, which we do by using the `TTT_MEASURE` macro and
    using the `T2_OrderServer_LFQueue_write` tag value, as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有仪器更改以及`FIFOSequencer`子组件的完整、更新后的源代码都可以在`Chapter11/exchange/order_server/fifo_sequencer.h`源文件中找到。我们将做出的唯一更改是在`FIFOSequencer::sequenceAndPublish()`方法中。在这里，我们只是在将客户端请求写入`incoming_requests_`
    `LFQueue`后添加时间戳，我们通过使用`TTT_MEASURE`宏和`T2_OrderServer_LFQueue_write`标签值来完成此操作，如下所示：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we move on to the task of adding instrumentation and timestamps to the
    core matching engine component as well as its subcomponents.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续对核心匹配引擎组件及其子组件添加仪器和时间戳的任务。
- en: Measuring the latencies inside the matching engine and order book
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量匹配引擎和订单簿内部的延迟
- en: First, we will update `MatchingEngine`; all the changes and the full, updated
    source for `MatchingEngine` can be found in the `Chapter11/exchange/matcher/matching_engine.h`
    source file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新`MatchingEngine`；所有更改以及`MatchingEngine`的完整、更新后的源代码都可以在`Chapter11/exchange/matcher/matching_engine.h`源文件中找到。
- en: 'In the `MatchingEngine::processClientRequest()` method, we will measure the
    time it takes for the `MEOrderBook::add()` and `MEOrderBook::cancel()` methods.
    First, we show the changes for the `MEOrderBook::add()` method using the `START_MEASURE`
    and `END_MEASURE` macros and the `Exchange_MEOrderBook_add` tag:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MatchingEngine::processClientRequest()`方法中，我们将测量`MEOrderBook::add()`和`MEOrderBook::cancel()`方法所需的时间。首先，我们使用`START_MEASURE`和`END_MEASURE`宏以及`Exchange_MEOrderBook_add`标签来展示`MEOrderBook::add()`方法的更改，如下所示：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we have the changes for `MEOrderBook::cancel()` using the `START_MEASURE`
    and `END_MEASURE` macros and the `Exchange_MEOrderBook_cancel` tag, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们展示了使用`START_MEASURE`和`END_MEASURE`宏以及`Exchange_MEOrderBook_cancel`标签对`MEOrderBook::cancel()`方法的更改，如下所示：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next method we need to update is `MatchingEngine::sendClientResponse()`.
    We will use the `TTT_MEASURE` macro with the `T4t_MatchingEngine_LFQueue_write`
    tag right after we write the client response to `outgoing_ogw_responses_` `LFQueue`,
    as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的下一个方法是`MatchingEngine::sendClientResponse()`。我们将在将客户端响应写入`outgoing_ogw_responses_`
    `LFQueue`后立即使用`TTT_MEASURE`宏和`T4t_MatchingEngine_LFQueue_write`标签，如下所示：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also need to update the `MatchingEngine::sendMarketUpdate()` method by adding
    a timestamp after writing the market update to `outgoing_md_updates_` `LFQueue`
    using the `TTT_MEASURE` macro and the `T4_MatchingEngine_LFQueue_write` tag:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过使用`TTT_MEASURE`宏和`T4_MatchingEngine_LFQueue_write`标签，在将市场更新写入`outgoing_md_updates_`
    `LFQueue`后添加时间戳来更新`MatchingEngine::sendMarketUpdate()`方法：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final method we need to update in `MatchingEngine` is the `run()` method
    itself. We take a timestamp right after reading from `incoming_requests_` `LFQueue`,
    using the `TTT_MEASURE` macro and the `T3_MatchingEngine_LFQueue_read` tag, as
    shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`MatchingEngine`中更新的最后一个方法是`run()`方法本身。我们在从`incoming_requests_` `LFQueue`读取后立即获取时间戳，使用`TTT_MEASURE`宏和`T3_MatchingEngine_LFQueue_read`标签，如下所示：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And we measure the call to the `MatchingEngine::processClientRequest()` method
    with the `START_MEASURE` and `END_MEASURE` macros with the `Exchange_MatchingEngine_processClientRequest`
    tag:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`START_MEASURE`和`END_MEASURE`宏以及`Exchange_MatchingEngine_processClientRequest`标签来测量对`MatchingEngine::processClientRequest()`方法的调用，如下所示：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The final component on the exchange side that we need to update is the `MEOrderBook`
    subcomponent in `MatchingEngine`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在交易所侧更新的最后一个组件是`MatchingEngine`中的`MEOrderBook`子组件。
- en: Measuring the latencies inside MEOrderBook
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量MEOrderBook内部的延迟
- en: We will discuss the instrumentation changes to the `MEOrderBook` component in
    this subsection, which can be found in the `Chapter11/exchange/matcher/me_order_book.cpp`
    source file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本小节中讨论对`MEOrderBook`组件的仪器更改，这些更改可以在`Chapter11/exchange/matcher/me_order_book.cpp`源文件中找到。
- en: 'The first method we will update is `MEOrderBook::match()`. We want to measure
    the call to `MEOrderBook::removeOrder()` with the `START_MEASURE` and `END_MEASURE`
    macros and the `Exchange_MEOrderBook_removeOrder` tag, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新的第一个方法是`MEOrderBook::match()`。我们希望使用`START_MEASURE`和`END_MEASURE`宏以及`Exchange_MEOrderBook_removeOrder`标签来测量对`MEOrderBook::removeOrder()`的调用，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to update the `MEOrderBook::checkForMatch()` method to measure
    the calls to `MEOrderBook::match()`. We use the `START_MEASURE` and `END_MEASURE`
    macros with the `Exchange_MEOrderBook_match` tag for the two branches of execution,
    as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`MEOrderBook::checkForMatch()`方法来测量对`MEOrderBook::match()`的调用。我们使用带有`Exchange_MEOrderBook_match`标记的`START_MEASURE`和`END_MEASURE`宏来对执行的两个分支进行测量，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will add additional instrumentation within the `MEOrderBook::add()` method
    to measure a few different calls. The first one is the call to `MEOrderBook::checkForMatch()`,
    for which we will use the `Exchange_MEOrderBook_checkForMatch` tag:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`MEOrderBook::add()`方法中添加额外的仪表化来测量几个不同的调用。第一个是调用`MEOrderBook::checkForMatch()`，我们将使用`Exchange_MEOrderBook_checkForMatch`标记：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next one is the call to `MEOrderBook::addOrder()`, for which we will use
    the `Exchange_MEOrderBook_addOrder` tag:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个是调用`MEOrderBook::addOrder()`，我们将使用`Exchange_MEOrderBook_addOrder`标记：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last `MEOrderBook` method we need to add more granular instrumentation
    to is the `cancel()` method. In this method, we want to measure the call to the
    `MEOrderBook::removeOrder()` method, as shown next, with the `START_MEASURE` and
    `END_MEASURE` macros and the `Exchange_MEOrderBook_removeOrder` tag:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加更多细粒度仪表化的最后一个`MEOrderBook`方法是`cancel()`方法。在这个方法中，我们想要测量对`MEOrderBook::removeOrder()`方法的调用，如下所示，使用`START_MEASURE`和`END_MEASURE`宏以及`Exchange_MEOrderBook_removeOrder`标记：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This concludes all the measurements we wanted to add on the side of the electronic
    exchange, and in the next section, we will add similar instrumentation on the
    other side: that is, the trading client system.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们希望在电子交易所一侧添加的所有测量，在下一节中，我们将添加另一侧的类似仪表化：即交易客户端系统。
- en: Measuring latencies in the trading engine
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量交易引擎中的延迟
- en: In this section, we will focus on adding performance measurement and timestamps
    to the trading client’s system – the market data consumer, the order gateway,
    and the trade engine and its subcomponents. Here too, we will measure the performance
    of internal components as well as add timestamps to help with a higher-level analysis
    of incoming and outgoing events latencies.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于向交易客户端系统添加性能测量和时间戳——包括市场数据消费者、订单网关、交易引擎及其子组件。在这里，我们也将测量内部组件的性能，并添加时间戳以帮助进行更高层次的分析，包括事件传入和传出的延迟。
- en: Understanding how to measure internally
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解如何进行内部测量
- en: 'The motivation and approach toward measuring the performance of internal components
    for the trading clients’ systems are identical to those on the exchange side.
    The complete list of internal measurements we will take is listed next, but interested
    readers should use similar techniques to add even more points of measurement as
    they see fit. We will see the code for how to measure these familiar methods shortly,
    but for now, the methods we will measure on the client’s side are the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测量交易客户端系统内部组件性能的动机和方法与交易所方面的方法相同。我们将采取的完整内部测量列表如下，但感兴趣的读者应使用类似的技术根据需要添加更多测量点。我们很快将看到如何测量这些熟悉方法的代码，但到目前为止，我们将测量客户端侧的方法如下：
- en: '`Trading::MarketDataConsumer::recvCallback()`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::MarketDataConsumer::recvCallback()`'
- en: '`Common::TCPSocket::send()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Common::TCPSocket::send()`'
- en: '`Trading::OrderGateway::recvCallback()`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderGateway::recvCallback()`'
- en: '`Trading::OrderManager::moveOrders()`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::moveOrders()`'
- en: '`Trading::OrderManager::onOrderUpdate()`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::onOrderUpdate()`'
- en: '`Trading::OrderManager::moveOrders()`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::moveOrders()`'
- en: '`Trading::OrderManager::onOrderUpdate()`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::onOrderUpdate()`'
- en: '`Trading::MarketOrderBook::addOrder()`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::MarketOrderBook::addOrder()`'
- en: '`Trading::MarketOrderBook::removeOrder()`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::MarketOrderBook::removeOrder()`'
- en: '`Trading::MarketOrderBook::updateBBO()`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::MarketOrderBook::updateBBO()`'
- en: '`Trading::OrderManager::cancelOrder()`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::cancelOrder()`'
- en: '`Trading::RiskManager::checkPreTradeRisk()`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::RiskManager::checkPreTradeRisk()`'
- en: '`Trading::OrderManager::newOrder()`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::newOrder()`'
- en: '`Trading::OrderManager::moveOrder()`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::moveOrder()`'
- en: '`Trading::OrderManager::moveOrder()`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::OrderManager::moveOrder()`'
- en: '`Trading::PositionKeeper::updateBBO()`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::PositionKeeper::updateBBO()`'
- en: '`Trading::FeatureEngine::onOrderBookUpdate()`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::FeatureEngine::onOrderBookUpdate()`'
- en: '`Trading::TradeEngine::algoOnOrderBookUpdate()`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::TradeEngine::algoOnOrderBookUpdate()`'
- en: '`Trading::FeatureEngine::onTradeUpdate()`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::FeatureEngine::onTradeUpdate()`'
- en: '`Trading::TradeEngine::algoOnTradeUpdate()`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::TradeEngine::algoOnTradeUpdate()`'
- en: '`Trading::PositionKeeper::addFill()`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::PositionKeeper::addFill()`'
- en: '`Trading::TradeEngine::algoOnOrderUpdate()`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trading::TradeEngine::algoOnOrderUpdate()`'
- en: As we did with the electronic trading exchange, we will understand the key hops
    that we will timestamp in the trading client’s system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在电子交易交易所中所做的那样，我们将理解在交易客户端系统中我们将要时间戳的关键跳转。
- en: Understanding key hops in the trading client’s system
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解交易客户端系统中的关键跳转
- en: Market participants also have similar reasons for timestamping the flow of events
    through each of the components and subcomponents. By recording and analyzing the
    timings of these events, participants can seek to improve their systems as well
    as analyze how to increase profitability.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 市场参与者也有类似的原因对每个组件和子组件的事件流进行时间戳记录。通过记录和分析这些事件的时序，参与者可以寻求改进他们的系统，以及分析如何增加盈利能力。
- en: 'In our electronic trading client’s system, we will take timestamps of the following
    events:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电子交易客户端系统中，我们将记录以下事件的时戳：
- en: '`T7_MarketDataConsumer_UDP_read` – the time when a market data update is read
    from the UDP socket in `MarketDataConsumer`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T7_MarketDataConsumer_UDP_read` – 从`MarketDataConsumer`中的UDP套接字读取市场数据更新的时间'
- en: '`T7t_OrderGateway_TCP_read` – the time when a client response is read from
    the TCP socket in `OrderGateway`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T7t_OrderGateway_TCP_read` – 从`OrderGateway`中的TCP套接字读取客户端响应的时间'
- en: '`T8_MarketDataConsumer_LFQueue_write` – the time when a market data update
    is written to the `LFQueue` connected to `TradeEngine`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T8_MarketDataConsumer_LFQueue_write` – 将市场数据更新写入连接到`TradeEngine`的`LFQueue`的时间'
- en: '`T8t_OrderGateway_LFQueue_write` – the time when a client response is written
    to the `LFQueue` connected to `TradeEngine`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T8t_OrderGateway_LFQueue_write` – 客户端响应写入连接到`TradeEngine`的`LFQueue`的时间'
- en: '`T9_TradeEngine_LFQueue_read` – the time when a market data update is read
    from the `LFQueue` from `MarketDataConsumer`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T9_TradeEngine_LFQueue_read` – 从`MarketDataConsumer`的`LFQueue`读取市场数据更新的时间'
- en: '`T9t_TradeEngine_LFQueue_read` – the time when a client response is read from
    the `LFQueue` from `OrderGateway`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T9t_TradeEngine_LFQueue_read` – 从`OrderGateway`读取客户端响应的时间'
- en: '`T10_TradeEngine_LFQueue_write` – the time when a client request is written
    to the `LFQueue` connected to `OrderGateway`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T10_TradeEngine_LFQueue_write` – 客户端请求写入连接到`OrderGateway`的`LFQueue`的时间'
- en: '`T11_OrderGateway_LFQueue_read` – the time when `OrderGateway` reads a client
    request from the `LFQueue` from `TradeEngine`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T11_OrderGateway_LFQueue_read` – `OrderGateway`从`TradeEngine`的`LFQueue`读取客户端请求的时间'
- en: '`T12_OrderGateway_TCP_write` – the time when `OrderGateway` writes a client
    request to the TCP socket'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T12_OrderGateway_TCP_write` – `OrderGateway`将客户端请求写入TCP套接字的时间'
- en: 'The exact locations of these timestamps are shown in the following figure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些时戳的确切位置在以下图中显示：
- en: '![Figure 11.2 – The topology of the electronic trading client’s system with
    the key hops to timestamp](img/B19434_11_02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 电子交易客户端系统的拓扑结构以及要时间戳的关键跳转](img/B19434_11_02.jpg)'
- en: Figure 11.2 – The topology of the electronic trading client’s system with the
    key hops to timestamp
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 电子交易客户端系统的拓扑结构以及要时间戳的关键跳转
- en: Now, starting in the next section, we can start looking at the code changes
    we need to add to these two forms of measurement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从下一节开始，我们可以开始查看我们需要添加到这两种测量形式的代码更改。
- en: Measuring the latencies inside the market data consumer
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量市场数据消费者内部的延迟
- en: We will start with the `MarketDataConsumer` component and, as we discussed before,
    we will only show the changes to the code here and omit repeating the full source
    code. The changes, as well as the full source code, are in the `Chapter11/trading/market_data/market_data_consumer.cpp`
    source file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`MarketDataConsumer`组件开始，正如我们之前讨论的那样，我们在这里只展示代码的更改，并省略重复完整的源代码。这些更改以及完整的源代码都位于`Chapter11/trading/market_data/market_data_consumer.cpp`源文件中。
- en: 'The first timestamp we take is as soon as we enter `MarketDataConsumer::recvCallback()`,
    where we use the `TTT_MEASURE` macro with the `T7_MarketDataConsumer_UDP_read`
    tag:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取的时戳是在进入`MarketDataConsumer::recvCallback()`时，我们使用`TTT_MEASURE`宏和`T7_MarketDataConsumer_UDP_read`标记：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will also enclose the entire method using the `START_MEASURE` and `END_MEASURE`
    macros with the `Trading_MarketDataConsumer_recvCallback` tag to measure the latency
    of the entire method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用带有`Trading_MarketDataConsumer_recvCallback`标记的`START_MEASURE`和`END_MEASURE`宏将整个方法包围起来，以测量整个方法的延迟：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will add a timestamp right after writing the decoded market update to `incoming_md_updates_`
    `LFQueue`, using the `TTT_MEASURE` macro and the `T8_MarketDataConsumer_LFQueue_write`
    tag:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在将解码后的市场更新写入`incoming_md_updates_` `LFQueue`之后立即添加时间戳，使用`TTT_MEASURE`宏和`T8_MarketDataConsumer_LFQueue_write`标记：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the next section, we move on to adding performance measurement to the `OrderGateway`
    component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续为 `OrderGateway` 组件添加性能测量。
- en: Measuring the latencies inside the order gateway
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量订单网关内部的延迟
- en: We will update the `OrderGateway` component in this subsection; all the changes
    and the updated full source code are available in the `Chapter11/trading/order_gw/order_gateway.cpp`
    source file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将更新 `OrderGateway` 组件；所有更改和更新的完整源代码可在 `Chapter11/trading/order_gw/order_gateway.cpp`
    源文件中找到。
- en: 'The first method we will update is the `OrderGateway::run()` method, and the
    first timestamp we take is when we read a client request from `outgoing_requests_`
    `LFQueue`. We accomplish this by using the `TTT_MEASURE` macro and the `T11_OrderGateway_LFQueue_read`
    tag:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先更新的是 `OrderGateway::run()` 方法，我们记录的第一个时间戳是在从 `outgoing_requests_` `LFQueue`
    读取客户端请求时。我们通过使用 `TTT_MEASURE` 宏和 `T11_OrderGateway_LFQueue_read` 标签来完成这项工作：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next thing we will measure is the time it takes to execute the `Common::TCPSocket::send()`
    method, which we accomplish, as shown next, using the `Trading_TCPSocket_send`
    tag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要测量的将是执行 `Common::TCPSocket::send()` 方法所需的时间，正如以下所示，我们使用 `Trading_TCPSocket_send`
    标签来完成这项工作：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we also timestamp right after `TCPSocket::send()` finishes using the
    `TTT_MEASURE` macro and the `T12_OrderGateway_TCP_write` tag:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也在 `TCPSocket::send()` 完成后立即使用 `TTT_MEASURE` 宏和 `T12_OrderGateway_TCP_write`
    标签进行时间戳记录：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next method we will update in the `OrderGateway` component is the `recvCallback()`
    method. As soon as we enter the `recvCallback()` method, we take a timestamp using
    the `TTT_MEASURE` macro and the `T7t_OrderGateway_TCP_read` tag:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OrderGateway` 组件中，我们将更新的下一个方法是 `recvCallback()` 方法。一旦进入 `recvCallback()`
    方法，我们就使用 `TTT_MEASURE` 宏和 `T7t_OrderGateway_TCP_read` 标签来记录一个时间戳：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As with `MarketDataConsumer::recvCallback()`, we will enclose the entire `OrderGateway::recvCallback()`
    method using the `START_MEASURE` and `END_MEASURE` macros and the `Trading_OrderGateway_recvCallback`
    tag:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `MarketDataConsumer::recvCallback()` 类似，我们将使用 `START_MEASURE` 和 `END_MEASURE`
    宏以及 `Trading_OrderGateway_recvCallback` 标签将整个 `OrderGateway::recvCallback()` 方法括起来：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also take a timestamp right after writing the client response to `incoming_responses_`
    `LFQueue` using the `TTT_MEASURE` macro and the `T8t_OrderGateway_LFQueue_write`
    tag:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在将客户端响应写入 `incoming_responses_` `LFQueue` 后立即使用 `TTT_MEASURE` 宏和 `T8t_OrderGateway_LFQueue_write`
    标签记录一个时间戳：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next and final subsection of this section, we will add the instrumentation
    code to the trade engine and all the subcomponents in the trade engine.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的下一和最后的小节中，我们将向交易引擎及其所有子组件添加仪表代码。
- en: Measuring the latencies inside the trading engine
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量交易引擎内部的延迟
- en: First, we will start by updating the `TradeEngine` class itself, and the changes
    and the full updated source code for this can be found in the `Chapter11/trading/strategy/trade_engine.cpp`
    source file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从更新 `TradeEngine` 类本身开始，这个更改及其完整的更新源代码可以在 `Chapter11/trading/strategy/trade_engine.cpp`
    源文件中找到。
- en: 'The `TradeEngine::sendClientRequest()` method is first on our list, and here,
    we take a timestamp after writing the client request to `outgoing_ogw_requests_`
    `LFQueue` with the `T10_TradeEngine_LFQueue_write` tag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个方法是 `TradeEngine::sendClientRequest()` 方法，在这里，我们在将客户端请求写入 `outgoing_ogw_requests_`
    `LFQueue` 后使用 `T10_TradeEngine_LFQueue_write` 标签记录一个时间戳：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next method on our list is the `TradeEngine::run()` method, where the first
    task is to take a timestamp right after reading a client response from `incoming_ogw_responses_`
    `LFQueue`, with the `TTT_MEASURE` macro and the `T9t_TradeEngine_LFQueue_read`
    tag:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个方法是 `TradeEngine::run()` 方法，其中第一个任务是读取来自 `incoming_ogw_responses_`
    `LFQueue` 的客户端响应后立即记录一个时间戳，使用 `TTT_MEASURE` 宏和 `T9t_TradeEngine_LFQueue_read`
    标签：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will also take a timestamp measurement right after reading a market update
    from `incoming_md_updates_` `LFQueue` with the `T9_TradeEngine_LFQueue_read` tag:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 `T9_TradeEngine_LFQueue_read` 标签在从 `incoming_md_updates_` `LFQueue` 读取市场更新后立即进行时间戳测量：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next method we need to update is the `TradeEngine::onOrderBookUpdate()`
    method, where the first thing we will do is measure the call to `PositionKeeper::updateBBO()`,
    using the `START_MEASURE` and `END_MEASURE` macros and the `Trading_PositionKeeper_updateBBO`
    tag:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要更新的下一个方法是 `TradeEngine::onOrderBookUpdate()` 方法，我们将首先使用 `START_MEASURE`
    和 `END_MEASURE` 宏以及 `Trading_PositionKeeper_updateBBO` 标签来测量对 `PositionKeeper::updateBBO()`
    的调用：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also need to measure the call to the `FeatureEngine::onOrderBookUpdate()`
    method, for which we use the `Trading_FeatureEngine_onOrderBookUpdate` tag:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测量对 `FeatureEngine::onOrderBookUpdate()` 方法的调用，我们使用 `Trading_FeatureEngine_onOrderBookUpdate`
    标签：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also need to measure the call to `TradeEngine::algoOnOrderBookUpdate_` `std::function`,
    which calls `onOrderBookUpdate()` in either the `MarketMaker` or `LiquidityTaker`
    algorithm instance. We use the `START_MEASURE` and `END_MEASURE` macros and use
    the `Trading_TradeEngine_algoOnOrderBookUpdate_` tag:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测量对 `TradeEngine::algoOnOrderBookUpdate_` `std::function` 的调用，该调用在 `MarketMaker`
    或 `LiquidityTaker` 算法实例中调用 `onOrderBookUpdate()`。我们使用 `START_MEASURE` 和 `END_MEASURE`
    宏以及 `Trading_TradeEngine_algoOnOrderBookUpdate_` 标签：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next method is the `TradeEngine::onTradeUpdate()` method. Here, the first
    call we measure is the call to `FeatureEngine::onTradeUpdate()`, to which we assign
    the `Trading_FeatureEngine_onTradeUpdate` tag:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `TradeEngine::onTradeUpdate()` 方法。在这里，我们首先测量的调用是 `FeatureEngine::onTradeUpdate()`，我们将其分配给
    `Trading_FeatureEngine_onTradeUpdate` 标签：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The other call we will measure is the call using the `TradeEngine::algoOnTradeUpdate_`
    standard function, which will forward it to the `MarketMaker` or `LiquidityTaker`
    instance. We use the `START_MEASURE` and `END_MEASURE` macros using the tag of
    `Trading_TradeEngine_algoOnTradeUpdate_`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测量的另一个调用是使用 `TradeEngine::algoOnTradeUpdate_` 标准函数的调用，它将将其转发到 `MarketMaker`
    或 `LiquidityTaker` 实例。我们使用 `START_MEASURE` 和 `END_MEASURE` 宏以及 `Trading_TradeEngine_algoOnTradeUpdate_`
    标签：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The final method we have left to add instrumentation to is `TradeEngine::onOrderUpdate()`.
    Here, the first function call that we measure will be the call to `PositionKeeper::addFill()`
    using the `Trading_PositionKeeper_addFill` tag:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要添加探针的方法是 `TradeEngine::onOrderUpdate()`。在这里，我们首先测量的函数调用将是使用 `Trading_PositionKeeper_addFill`
    标签对 `PositionKeeper::addFill()` 的调用：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we add the `START_MEASURE` and `END_MEASURE` macros with the `Trading_TradeEngine_algoOnOrderUpdate_`
    tag around the invocation of the `algoOnOrderUpdate_` `std::function` object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `algoOnOrderUpdate_` `std::function` 对象的调用周围添加 `START_MEASURE` 和 `END_MEASURE`
    宏以及 `Trading_TradeEngine_algoOnOrderUpdate_` 标签：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will add some internal measurement code to each of the subcomponents that
    work with each other inside `TradeEngine`, starting with the `OrderManager` component
    next.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `TradeEngine` 内部相互协作的每个子组件中添加一些内部测量代码，首先从 `OrderManager` 组件开始。
- en: Measuring the latencies inside OrderManager
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 OrderManager 内部测量延迟
- en: The changes to add performance measurement in `OrderManager` are the focus of
    this subsection, and all the code can be found in the `Chapter11/trading/strategy/order_manager.h`
    source file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们关注的重点是向 `OrderManager` 中添加性能测量的更改，所有代码都可以在 `Chapter11/trading/strategy/order_manager.h`
    源文件中找到。
- en: 'First, we will add measurements to the `OrderManager::moveOrder()` method.
    The first thing we will measure is the call to the `OrderManager::cancelOrder()`
    method using the `Trading_OrderManager_cancelOrder` tag:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 `OrderManager::moveOrder()` 方法添加测量。我们将首先测量使用 `Trading_OrderManager_cancelOrder`
    标签对 `OrderManager::cancelOrder()` 方法的调用：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will also measure the call to the `RiskManager` component, specifically
    the `checkPreTradeRisk()` call. We will use the `START_MEASURE` and `END_MEASURE`
    macros with the `Trading_RiskManager_checkPreTradeRisk` tag around the risk check,
    as shown next:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测量对 `RiskManager` 组件的调用，特别是对 `checkPreTradeRisk()` 调用的测量。我们将在风险检查周围使用 `START_MEASURE`
    和 `END_MEASURE` 宏以及 `Trading_RiskManager_checkPreTradeRisk` 标签，如下所示：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Another thing to measure is the call to `OrderManager::newOrder()` if the risk
    check succeeds, and we will assign the measurement the `Trading_OrderManager_newOrder`
    tag, as shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要测量的指标是当风险检查成功时对 `OrderManager::newOrder()` 的调用，我们将为这个测量分配 `Trading_OrderManager_newOrder`
    标签，如下所示：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The other method in `OrderManager` to which we will add measurements is the
    `moveOrders()` method, and there we will enclose the calls to `OrderManager::moveOrder()`
    with `START_MEASURE` and `END_MEASURE` and the `Trading_OrderManager_moveOrder`
    tag:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `OrderManager` 中添加测量的另一个方法是 `moveOrders()` 方法，在那里我们将使用 `START_MEASURE`
    和 `END_MEASURE` 以及 `Trading_OrderManager_moveOrder` 标签包围对 `OrderManager::moveOrder()`
    的调用：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The next subcomponent in the `TradeEngine` class that we need to update is `MarketOrderBook`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的下一个 `TradeEngine` 类的子组件是 `MarketOrderBook`。
- en: Measuring the latencies inside MarketOrderBook
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 MarketOrderBook 内部测量延迟
- en: The changes and full source for `MarketOrderBook` can be found in the `Chapter11/trading/strategy/market_order_book.cpp`
    source file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketOrderBook` 的更改和完整源代码可以在 `Chapter11/trading/strategy/market_order_book.cpp`
    源文件中找到。'
- en: 'First, in the `MarketOrderBook::onMarketUpdate()` method and the case for the
    `MarketUpdateType::ADD` message, we will measure the call to `MarketOrderBook::addOrder()`.
    This is achieved as usual by using the `START_MEASURE` and `END_MEASURE` macros
    with the `Trading_MarketOrderBook_addOrder` tag:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `MarketOrderBook::onMarketUpdate()` 方法以及 `MarketUpdateType::ADD` 消息的情况中，我们将测量对
    `MarketOrderBook::addOrder()` 的调用。这通常是通过使用 `START_MEASURE` 和 `END_MEASURE` 宏以及
    `Trading_MarketOrderBook_addOrder` 标签来实现的：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To measure the call to `MarketOrderBook::removeOrder()` in the `MarketUpdateType::CANCEL`
    case, we will use the `Trading_MarketOrderBook_removeOrder` tag in the `START
    _MEASURE` and `END_MEASURE` macros:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量在 `MarketUpdateType::CANCEL` 情况下对 `MarketOrderBook::removeOrder()` 的调用，我们将使用
    `Trading_MarketOrderBook_removeOrder` 标签在 `START_MEASURE` 和 `END_MEASURE` 宏中：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we will add a measurement around the call to `MarketOrderBook::updateBBO()`
    and assign it the `Trading_MarketOrderBook_updateBBO` tag:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在对 `MarketOrderBook::updateBBO()` 的调用周围添加测量，并将其分配给 `Trading_MarketOrderBook_updateBBO`
    标签：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The next component to measure is one of the trading algorithms – the `LiquidityTaker`
    algorithm.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要测量的组件是其中一个交易算法——`LiquidityTaker` 算法。
- en: Measuring the latencies inside the LiquidityTaker algorithm
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量 `LiquidityTaker` 算法内部的延迟
- en: The changes we discuss here, as well as the full source code, are in the `Chapter11/trading/strategy/liquidity_taker.h`
    source file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的更改以及完整源代码都位于 `Chapter11/trading/strategy/liquidity_taker.h` 源文件中。
- en: 'Our first measurement is in the `onTradeUpdate()` method for the `LiquidityTaker`
    class. When the signal initiates a trade, we measure the call to `OrderManager::moveOrders()`
    and assign it the `OrderManager_moveOrders` tag, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测量是在 `LiquidityTaker` 类的 `onTradeUpdate()` 方法中。当信号启动交易时，我们测量对 `OrderManager::moveOrders()`
    的调用，并将其分配给 `OrderManager_moveOrders` 标签，如下所示：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The other call we want to measure is in the `onOrderUpdate()` method and measures
    the call to `OrderManager::onOrderUpdate()` using the `START_MEASURE` and `END_MEASURE`
    macros and the `Trading_OrderManager_onOrderUpdate` tag:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测量的另一个调用是在 `onOrderUpdate()` 方法中，我们使用 `START_MEASURE` 和 `END_MEASURE` 宏以及
    `Trading_OrderManager_onOrderUpdate` 标签来测量对 `OrderManager::onOrderUpdate()` 的调用：
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, we are down to our last component for this chapter, updating the `MarketMaker`
    algorithm.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了本章的最后一个组件，更新 `MarketMaker` 算法。
- en: Measuring the latencies inside the MarketMaker algorithm
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量 `MarketMaker` 算法内部的延迟
- en: The changes and the full source code for `MarketMaker` are in the `Chapter11/trading/strategy/market_maker.h`
    source file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketMaker` 的更改和完整源代码位于 `Chapter11/trading/strategy/market_maker.h` 源文件中。'
- en: 'The `MarketMaker::onOrderBookUpdate()` method contains the call to `OrderManager::moveOrders()`,
    which is what we measure in the next code block with the `Trading_OrderManager_moveOrders`
    tag:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketMaker::onOrderBookUpdate()` 方法包含了调用 `OrderManager::moveOrders()`，这是我们接下来在代码块中使用
    `Trading_OrderManager_moveOrders` 标签所测量的内容：'
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The other method, `MarketMaker::onOrderUpdate()`, contains the call to `OrderManager::onOrderUpdate()`,
    which we also measure and to which we will assign the `Trading_OrderManager_onOrderUpdate`
    tag:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法，`MarketMaker::onOrderUpdate()`，包含了调用 `OrderManager::onOrderUpdate()`，我们也会对其进行测量，并将其分配给
    `Trading_OrderManager_onOrderUpdate` 标签：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This concludes all the performance measurement and timestamping-related changes
    across our entire electronic trading ecosystem. We will very quickly look at how
    to run the ecosystem with all the changes we made so far and what differences
    we find in the log files.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了我们在整个电子交易生态系统中进行的所有性能测量和时间戳相关更改。我们将很快查看如何运行经过我们迄今为止所做的所有更改的生态系统，以及我们在日志文件中找到的差异。
- en: Running the entire ecosystem with the new instrumentation system
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的仪器系统运行整个生态系统
- en: 'Running the updated electronic trading ecosystem remains the same as before
    and is launched by running the following script:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更新后的电子交易生态系统与之前相同，通过运行以下脚本启动：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the new ecosystem is done running, you can notice performance measurement
    log entries such as the following for the RDTSC measurements:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新的生态系统运行完成，你可以注意到如下性能测量日志条目，这是针对RDTSC测量的：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'There are also entries such as the following for the RDTSC measurements:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RDTSC测量，也存在如下条目：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There are entries such as the following for the TTT measurements:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TTT测量，也存在如下条目：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And there are also entries such as the following for the TTT measurements:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TTT测量，也存在如下条目：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We will revisit this performance data in the next chapter, but we have now finished
    this chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章重新审视这些性能数据，但现在我们已经完成了这一章。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated completely to measuring the performance of our electronic
    trading ecosystem. First, we built a system to measure and compare the latency
    incurred due to the execution of any arbitrary code block. We also built a system
    to generate nanosecond-level timestamps when notable events occur. We also discussed
    the motivation behind the design of these systems as well as various important
    points to keep in mind when using these performance measurement techniques.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完全致力于衡量我们电子交易生态系统的性能。首先，我们构建了一个系统来衡量和比较执行任何任意代码块所引起的延迟。我们还构建了一个系统，在发生显著事件时生成纳秒级的时间戳。我们还讨论了这些系统设计的动机以及在使用这些性能测量技术时需要注意的各种重要点。
- en: The next section was dedicated to understanding the design and motivation of
    performance measurements within the various components and subcomponents on the
    electronic exchange’s end. We then built and updated all the source code in the
    exchange to add the performance measurement and timestamping code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节致力于理解电子交易所端各个组件和子组件中性能测量的设计和动机。然后，我们更新了交易所中的所有源代码，以添加性能测量和时间戳代码。
- en: After we finished the discussion and implementation of performance measurement
    within the electronic exchange, we performed similar measurements in the trading
    system. Finally, we concluded the chapter by running this updated ecosystem and
    observing the new log entries from the performance measurement system.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成电子交易所内性能测量的讨论和实施后，我们在交易系统中进行了类似的测量。最后，我们通过运行这个更新的生态系统并观察性能测量系统的新日志条目来结束本章。
- en: In the next and concluding chapter, we will analyze this performance data in
    detail, discuss our findings, and discuss how to optimize the performance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将详细分析这些性能数据，讨论我们的发现，并讨论如何优化性能。
