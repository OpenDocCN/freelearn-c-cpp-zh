<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-170" class="chapter-number"><a id="_idTextAnchor177"/>11</h1>&#13;
			<h1 id="_idParaDest-171"><a id="_idTextAnchor178"/>The Target Description</h1>&#13;
			<p>LLVM has a very flexible architecture. You can also add a new target backend to it. The core of a backend is the target description, from which most of the code is generated. In this chapter, you will learn how to add support for a historical CPU.</p>&#13;
			<p>In this chapter, you will cover the following:</p>&#13;
			<ul>&#13;
				<li><em class="italic">Setting the stage for a new backend</em> introduces you to the M88k CPU architecture and shows you where to find the required information</li>&#13;
				<li><em class="italic">Adding the new architecture to the Triple class</em> teaches you how to make LLVM aware of a new CPU architecture</li>&#13;
				<li><em class="italic">Extending the ELF file format definition in LLVM</em> shows you how to add support for the M88k-specific relocations to the libraries and tools that handle ELF object files</li>&#13;
				<li><em class="italic">Creating the target description</em> applies your knowledge of the TableGen language to model the register file and instructions in the target description</li>&#13;
				<li><em class="italic">Adding the M88k backend to LLVM</em> explains the minimal infrastructure required for an LLVM backend</li>&#13;
				<li><em class="italic">Implementing an assembler parser</em> shows you how to develop the assembler</li>&#13;
				<li><em class="italic">Creating the disassembler</em> teaches you how to create the disassembler</li>&#13;
			</ul>&#13;
			<p>By the end of the chapter, you will know how to add a new backend to LLVM. You will acquire the knowledge to develop the register file definition and instruction definition in the target description, and you will know how to create the assembler and disassembler from that description.</p>&#13;
			<h1 id="_idParaDest-172"><a id="_idTextAnchor179"/>Setting the stage for a new backend</h1>&#13;
			<p>Whether commercially needed to support a new CPU or only a hobby project to add support for <a id="_idIndexMarker685"/>some old architecture, adding a new backend to LLVM is a major task. This and the following two chapters outline what you need to develop for a new backend. We will add a backend for the Motorola M88k architecture, which is a RISC architecture from the 1980s.</p>&#13;
			<p class="callout-heading">References</p>&#13;
			<p class="callout">You can read <a id="_idIndexMarker686"/>more about this Motorola architecture on Wikipedia at <a href="https://en.wikipedia.org/wiki/Motorola_88000">https://en.wikipedia.org/wiki/Motorola_88000</a>. The most important information about this architecture is still available on the internet. You can find the CPU manuals with the instruction set and timing information at <a href="http://www.bitsavers.org/components/motorola/88000/">http://www.bitsavers.org/components/motorola/88000/</a>, and the System V ABI M88k Processor supplement with the definitions of the ELF format and the calling convention at <a href="https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463">https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463</a>.</p>&#13;
			<p class="callout">OpenBSD, available <a id="_idIndexMarker687"/>at <a href="https://www.openbsd.org/">https://www.openbsd.org/</a>, still supports the LUNA-88k system. On the OpenBSD system, it is easy to create a GCC cross-compiler for M88k. And <a id="_idIndexMarker688"/>with GXemul, available at <a href="http://gavare.se/gxemul/">http://gavare.se/gxemul/</a>, we get an emulator capable of running certain OpenBSD releases for the M88k architecture.</p>&#13;
			<p>The M88k architecture is long out of production, but we found enough information and tools to make it an interesting goal to add an LLVM backend for it. We will begin with a very basic task of extending the <code>Triple</code> class.</p>&#13;
			<h1 id="_idParaDest-173"><a id="_idTextAnchor180"/>Adding the new architecture to the Triple class</h1>&#13;
			<p>An instance <a id="_idIndexMarker689"/>of the <code>Triple</code> class represents the target platform LLVM is producing code for. To support a new architecture, the first task is to extend the <code>Triple</code> class. In the <code>llvm/include/llvm/TargetParser/Triple.h</code> file, add a member to the <code>ArchType</code> enumeration along with a new predicate:</p>&#13;
			<pre class="source-code">&#13;
class Triple {&#13;
public:&#13;
  enum ArchType {&#13;
      // Many more members&#13;
      m88k,      // M88000 (big endian): m88k&#13;
  };&#13;
  /// Tests whether the target is M88k.&#13;
  bool isM88k() const {&#13;
      return getArch() == Triple::m88k;&#13;
  }&#13;
// Many more methods&#13;
};</pre>			<p>Inside the <code>llvm/lib/TargetParser/Triple.cpp</code> file, there are many methods that <a id="_idIndexMarker690"/>use the <code>ArchType</code> enumeration. You need to extend all of them; for example, in the <code>getArchTypeName()</code> method, you need to add a new <code>case</code> statement as follows:</p>&#13;
			<pre class="source-code">&#13;
 switch (Kind) {&#13;
     // Many more cases&#13;
     <strong class="bold">case m88k:  </strong>         return "m88k";&#13;
  }</pre>			<p>Most times, the compiler will warn you if you forget to handle the new <code>m88k</code> enumeration <a id="_idIndexMarker691"/>member in one of the functions. Next, we will expand the <strong class="bold">Executable and Linkable </strong><strong class="bold">Format</strong> (<strong class="bold">ELF</strong>).</p>&#13;
			<h1 id="_idParaDest-174"><a id="_idTextAnchor181"/>Extending the ELF file format definition in LLVM</h1>&#13;
			<p>The ELF file format is one of the binary object file formats LLVM supports. ELF itself is defined for <a id="_idIndexMarker692"/>many CPU architectures, and there <a id="_idIndexMarker693"/>is also a definition for the M88k architecture. All we need to do is to add the definition of the relocations and some flags. The relocations are given in <a href="B19561_04.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Basics of IR Code Generation</em>, of the <em class="italic">System V ABI M88k Processor</em> supplement book (see link within the <em class="italic">Setting the stage for a new backend</em> section at the beginning of the chapter):</p>&#13;
			<ol>&#13;
				<li>We need to type the following code into the  <code>llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def</code> file:<pre class="source-code">&#13;
#ifndef ELF_RELOC&#13;
#error "ELF_RELOC must be defined"&#13;
#endif&#13;
ELF_RELOC(R_88K_NONE, 0)&#13;
ELF_RELOC(R_88K_COPY, 1)&#13;
// Many more…</pre></li>				<li>We also add the following flags into the <code>llvm/include/llvm/BinaryFormat/ELF.h</code> file, along with the definition of the relocations:<pre class="source-code">&#13;
// M88k Specific e_flags&#13;
enum : unsigned {&#13;
    EF_88K_NABI = 0x80000000,   // Not ABI compliant&#13;
    EF_88K_M88110 = 0x00000004  // File uses 88110-specific features&#13;
};&#13;
// M88k relocations.&#13;
enum {&#13;
    #include "ELFRelocs/M88k.def"&#13;
};</pre><p class="list-inset">The code can be added anywhere in the file, but it is best to keep the file structured and insert it before the code for the MIPS architecture.</p></li>				<li>We also <a id="_idIndexMarker694"/>need to expand some other methods. In the <code>llvm/include/llvm/Object/ELFObjectFile.h</code> file are some methods <a id="_idIndexMarker695"/>that translate between enumeration members and strings. For example, we must add a new <code>case</code> statement to the <code>getFileFormatName()</code> method:<pre class="source-code">&#13;
  switch (EF.getHeader()-&gt;e_ident[ELF::EI_CLASS]) {&#13;
// Many more cases&#13;
    case ELF::EM_88K:&#13;
      return "elf32-m88k";&#13;
  }</pre></li>				<li>Similarly, we extend the <code>getArch()</code> method:<pre class="source-code">&#13;
  switch (EF.getHeader().e_machine) {&#13;
// Many more cases&#13;
  case ELF::EM_88K:&#13;
    return Triple::m88k;</pre></li>				<li>Lastly, we use the relocation definitions in the <code>llvm/lib/Object/ELF.cpp</code> file, in the <code>getELFRelocationTypeName()</code> method:<pre class="source-code">&#13;
  switch (Machine) {&#13;
// Many more cases&#13;
   case ELF::EM_88K:&#13;
    switch (Type) {&#13;
#include "llvm/BinaryFormat/ELFRelocs/M88k.def"&#13;
    default:&#13;
      break;&#13;
    }&#13;
    break;&#13;
  }</pre></li>				<li>To complete <a id="_idIndexMarker696"/>the support, you can v<a id="_idIndexMarker697"/>also extend the <code>llvm/lib/ObjectYAML/ELFYAML.cpp</code> file. This file is used by the <code>yaml2obj</code> and <code>obj2yaml</code> tools, which create an ELF file based on a YAML description, and vice versa. The first addition needs to be done in the <code>ScalarEnumerationTraits&lt;ELFYAML::ELF_EM&gt;::enumeration()</code> method, which lists all the values for the ELF architectures:<pre class="source-code">&#13;
  ECase(EM_88K);</pre></li>				<li>Likewise, in the <code>ScalarEnumerationTraits&lt;ELFYAML::ELF_REL&gt;::enumeration()</code> method, you need to include the definitions of the relocations again:<pre class="source-code">&#13;
  case ELF::EM_88K:&#13;
#include "llvm/BinaryFormat/ELFRelocs/M88k.def"&#13;
    break;</pre></li>			</ol>&#13;
			<p>At this point, we have completed the support of the m88k architecture in the ELF file format. You can use the <code>llvm-readobj</code> tool to inspect an ELF object file, for example, created by a cross-compiler on OpenBSD. Likewise, you can create an ELF object file for the m88k architecture with the <code>yaml2obj</code> tool.</p>&#13;
			<p class="callout-heading">Is adding support for an object file format mandatory?</p>&#13;
			<p class="callout">Integrating support for an architecture into the ELF file format implementation requires only a couple <a id="_idIndexMarker698"/>of lines of code. If the architecture for which you are creating an LLVM backend uses the ELF format, then you should take this route. On the other hand, adding support for a completely new binary file format is a complicated task. If this is required, then an often-used approach is to only output assembler files and use an external assembler to create object files.</p>&#13;
			<p>With these additions, the LLVM implementation of the ELF file format now supports the M88k architecture. In the next section, we create the target description for the M88k architecture, which describes the instructions, the registers, and many more details of the architecture.</p>&#13;
			<h1 id="_idParaDest-175"><a id="_idTextAnchor182"/>Creating the target description</h1>&#13;
			<p>The <code>llvm/include/llvm/Target/Target.td</code> file, which can be found online at <a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td</a>. This file is heavily commented on and is a useful source of information about the use of the definitions.</p>&#13;
			<p>In an ideal world, we would generate the whole backend from the target description. This goal has <a id="_idIndexMarker700"/>not yet been reached, and therefore, we will need to extend the generated code later. Because of its size, the target description is split into several files. The top-level file will be <code>M88k.td</code>, inside the <code>llvm/lib/Target/M88k</code> directory, which also includes the other files. Let’s have a look at some files, beginning with the register definition.</p>&#13;
			<h2 id="_idParaDest-176"><a id="_idTextAnchor183"/>Adding the register definition</h2>&#13;
			<p>A CPU architecture <a id="_idIndexMarker701"/>usually defines a set of registers. The characteristics of these registers can vary. Some architectures allow access to sub-registers. For example, the x86 architecture has special register names to access only a part of a register value. Other architectures do not implement this. In addition to general-purpose, floating-point, and vector registers, an architecture may have special registers for status codes or configuration of floating-point operations. We need to define all this information for LLVM. The register definitions are stored in the <code>M88kRegisterInfo.td</code> file, also found within the <code>llvm/lib/Target/M88k</code> directory.</p>&#13;
			<p>The M88k architecture defines general-purpose registers, extended registers for floating-point operations, and control registers. To keep the example small, we only define the general-purpose registers. We begin by defining a super-class for the registers. A register has a name and an encoding. The name is used in the textual representation of an instruction. Similarly, the encoding is used as part of the binary representation <a id="_idIndexMarker702"/>of an instruction. The architecture defines 32 registers and the encoding for registers therefore uses 5 bits, so we limit the field holding the encoding. We also define that all the generated C++ code should live in the <code>M88k</code> namespace:</p>&#13;
			<pre class="source-code">&#13;
class M88kReg&lt;bits&lt;5&gt; Enc, string n&gt; : Register&lt;n&gt; {&#13;
  let HWEncoding{15-5} = 0;&#13;
  let HWEncoding{4-0} = Enc;&#13;
  let Namespace = "M88k";&#13;
}</pre>			<p>Next, we can define all 32 general-purpose registers. The <code>r0</code> register is special because it always returns the constant <code>0</code> when read, so we set the <code>isConstant</code> flag to <code>true</code> for that register:</p>&#13;
			<pre class="source-code">&#13;
foreach I = 0-31 in {&#13;
  let isConstant = !eq(I, 0) in&#13;
    def R#I : M88kReg&lt;I, "r"#I&gt;;&#13;
}</pre>			<p>For the register allocator, the single registers need to be grouped into register classes. The sequence order of the registers defines the allocation order. The register allocator also needs other information about the registers such as, for example, the value types, which can be stored in a register, the spill size of a register in bits, and the required alignment in memory. Instead of using the <code>RegisterClass</code> base class directly, we create a new <code>M88kRegisterClass</code> class. This allows us to change the parameter list to our needs. It also avoids the repetition of the C++ namespace name used for the generated code, which is the first argument for the <code>RegisterClass</code> class:</p>&#13;
			<pre class="source-code">&#13;
class M88kRegisterClass&lt;list&lt;ValueType&gt; types, int size,&#13;
                        int alignment, dag regList,&#13;
                        int copycost = 1&gt;&#13;
  : RegisterClass&lt;"M88k", types, alignment, regList&gt; {&#13;
      let Size = size;&#13;
      let CopyCost = copycost;&#13;
}</pre>			<p>In addition, we define a class for register operands. Operands describe the input and output of an instruction. They are used during assembling and disassembling of an instruction, and also in the patterns used by the instruction selection phase. Using our own class, we can <a id="_idIndexMarker703"/>give the generated function used to decode a register operand a name that conforms to the LLVM coding guidelines:</p>&#13;
			<pre class="source-code">&#13;
class M88kRegisterOperand&lt;RegisterClass RC&gt;&#13;
    : RegisterOperand&lt;RC&gt; {&#13;
  let DecoderMethod = "decode"#RC#"RegisterClass";&#13;
}</pre>			<p>Based on these definitions, we now define the general-purpose registers. Please note that a general-purpose register of the m88k architecture is 32-bits wide and can hold integer and floating-point values. To avoid writing all register names, we use the <code>sequence</code> generator, which generates a list of strings based on the template string:</p>&#13;
			<pre class="source-code">&#13;
def GPR : M88kRegisterClass&lt;[i32, f32], 32, 32,&#13;
                            (add (sequence "R%u", 0, 31))&gt;;</pre>			<p>Likewise, we define the register operand. The <code>r0</code> register is special because it contains the constant <code>0</code>. This fact can be used by the global instruction selection framework, and therefore, we attach this information to the register operand:</p>&#13;
			<pre class="source-code">&#13;
def GPROpnd : M88kRegisterOperand&lt;GPR&gt; {&#13;
  let GIZeroRegister = R0;&#13;
}</pre>			<p>There is an extension to the m88k architecture that defines an extended register file for floating-point values only. You would define those registers in the same way as the general-purpose registers.</p>&#13;
			<p>The general-purpose registers are also used in pairs, mainly for 64-bit floating point operations, and we need to model them. We use the <code>sub_hi</code> and <code>sub_lo</code> sub-register indices to <a id="_idIndexMarker704"/>describe the high 32 bits and the low 32 bits. We also need to set the C++ namespace for the generated code:</p>&#13;
			<pre class="source-code">&#13;
let Namespace = "M88k" in {&#13;
  def sub_hi : SubRegIndex&lt;32, 0&gt;;&#13;
  def sub_lo : SubRegIndex&lt;32, 32&gt;;&#13;
}</pre>			<p>The register pairs are then defined using the <code>RegisterTuples</code> class. The class takes a list of sub-register indices as the first argument and a list of registers as the second argument. We only need even/odd numbered pairs, and we achieve this with the optional fourth parameter of sequence, which is the stride to use when generating the sequence:</p>&#13;
			<pre class="source-code">&#13;
def GRPair : RegisterTuples&lt;[sub_hi, sub_lo],&#13;
                          [(add (sequence "R%u", 0, 30, 2)),&#13;
                           (add (sequence "R%u", 1, 31, 2))]&gt;;</pre>			<p>To use the register pairs, we define a register class and a register operand:</p>&#13;
			<pre class="source-code">&#13;
def GPR64 : M88kRegisterClass&lt;[i64, f64], 64, 32,&#13;
                              (add GRPair), /*copycost=*/ 2&gt;;&#13;
def GPR64Opnd : M88kRegisterOperand&lt;GPR64&gt;;</pre>			<p>Please note that we set the <code>copycost</code> parameter to <code>2</code> because we need two instructions instead of one to copy a register pair to another register pair.</p>&#13;
			<p>This finishes our definition of the registers. In the next section, we will define the instruction formats.</p>&#13;
			<h2 id="_idParaDest-177"><a id="_idTextAnchor184"/>Defining the instruction formats and the instruction information</h2>&#13;
			<p>An instruction is defined using the TableGen <code>Instruction</code> class. Defining an instruction <a id="_idIndexMarker705"/>is a complex task because we have to consider many details. An instruction has a textual representation used by <a id="_idIndexMarker706"/>the assembler and the disassembler. It has a name, for example, <code>and</code>, and it may have operands. The assembler transforms the textual representation into a binary format, therefore, we must define the layout of that format. For instruction selection, we need to attach a pattern to the instruction. To manage this complexity, we define a class hierarchy. The base classes will describe the various instruction formats and are stored in the <code>M88kIntrFormats.td</code> file. The instructions themselves and other definitions required for the instruction selection are stored in the <code>M88kInstrInfo.td</code> file.</p>&#13;
			<p>Let’s begin with defining a class for the instructions of the m88k architecture called <code>M88kInst</code>. We derive this class from the predefined <code>Instruction</code> class. Our new class has a couple of parameters. The <code>outs</code> and <code>ins</code> parameters describe the output and input operands as a list, using the special <code>dag</code> type. The textual representation of the instruction is split into the mnemonic given in the <code>asm</code> parameter, and the operands. Last, the <code>pattern</code> parameter can hold a pattern used for instruction selection.</p>&#13;
			<p>We also need to define two new fields:</p>&#13;
			<ul>&#13;
				<li>The <code>Inst</code> field is used to hold the bit pattern of the instruction. Because the size of an instruction depends on the platform, this field cannot be predefined. All instructions of the m88k architecture are 32-bit wide, and so this field has the <code>bits&lt;32&gt;</code> type.</li>&#13;
				<li>The other field is called <code>SoftFail</code> and has the same type as <code>Inst</code>. It holds a bit mask used with an instruction for which the actual encoding can differ from the bits in the <code>Inst</code> field and still be valid. The only platform that requires this is ARM, so we can simply set this field to <code>0</code>.</li>&#13;
			</ul>&#13;
			<p>The other fields are defined in the superclass, and we only set the value. Simple computations <a id="_idIndexMarker707"/>are possible in the TableGen language, and we use this when we create the value for the <code>AsmString</code> field, which holds <a id="_idIndexMarker708"/>the full assembler representation. If the <code>operands</code> operand string is empty, then the <code>AsmString</code> field will just have the value of the <code>asm</code> parameter, otherwise, it will be the concatenation of both strings, with a space between them:</p>&#13;
			<pre class="source-code">&#13;
class InstM88k&lt;dag outs, dag ins, string asm, string operands,&#13;
               list&lt;dag&gt; pattern = []&gt;&#13;
  : Instruction {&#13;
  bits&lt;32&gt; Inst;&#13;
  bits&lt;32&gt; SoftFail = 0;&#13;
  let Namespace = "M88k";&#13;
  let Size = 4;&#13;
  dag OutOperandList = outs;&#13;
  dag InOperandList = ins;&#13;
  let AsmString = !if(!eq(operands, ""), asm,&#13;
                      !strconcat(asm, " ", operands));&#13;
  let Pattern = pattern;&#13;
  let DecoderNamespace = "M88k";&#13;
}</pre>			<p>For the instruction encoding, the manufacturer usually groups instructions together, and the instructions of one group have a similar encoding. We can use those groups to systematically create classes defining the instruction formats. For example, all logical operations of the m88k architecture encode the destination register in the bits from 21 to 25 and the first source register in the bits from 16 to 20. Please note the implementation pattern here: we declare the <code>rd</code> and <code>rs1</code> fields for the values, and we assign those values to the correct bit positions of the <code>Inst</code> field, which we defined previously in the superclass:</p>&#13;
			<pre class="source-code">&#13;
class F_L&lt;dag outs, dag ins, string asm, string operands,&#13;
          list&lt;dag&gt; pattern = []&gt;&#13;
   : InstM88k&lt;outs, ins, asm, operands, pattern&gt; {&#13;
  bits&lt;5&gt;  rd;&#13;
  bits&lt;5&gt;  rs1;&#13;
  let Inst{25-21} = rd;&#13;
  let Inst{20-16} = rs1;&#13;
}</pre>			<p>There are <a id="_idIndexMarker709"/>several groups of logical <a id="_idIndexMarker710"/>operations based on this format. One of <a id="_idIndexMarker711"/>them is the group of instructions using three registers, which is called <strong class="bold">triadic addressing mode</strong> in the manual:</p>&#13;
			<pre class="source-code">&#13;
class F_LR&lt;bits&lt;5&gt; func, bits&lt;1&gt; comp, string asm,&#13;
           list&lt;dag&gt; pattern = []&gt;&#13;
   : F_L&lt;(outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),&#13;
         !if(comp, !strconcat(asm, ".c"), asm),&#13;
         "$rd, $rs1, $rs2", pattern&gt; {&#13;
  bits&lt;5&gt;  rs2;&#13;
  let Inst{31-26} = 0b111101;&#13;
  let Inst{15-11} = func;&#13;
  let Inst{10}    = comp;&#13;
  let Inst{9-5}   = 0b00000;&#13;
  let Inst{4-0}   = rs2;&#13;
}</pre>			<p>Let’s examine the functionality provided by this class in more detail. The <code>func</code> parameter specifies the operation. As a special feature, the second operand can be complemented before the operation, which is indicated by setting the <code>1</code>. The mnemonic is given in the <code>asm</code> parameter, and an instruction selection pattern can be passed.</p>&#13;
			<p>With initializing the superclass, we can give more information. The full assembler text template for the <code>and</code> instruction is <code>and $rd, $rs1, $rs2</code>. The operand string is fixed for all instructions of this group, so we can define it here. The mnemonic is given by the user of this class, but we can concatenate the <code>.c</code> suffix here, which denotes that the second <a id="_idIndexMarker712"/>operand should be complemented first. And last, we can define the output and input operands. These operands <a id="_idIndexMarker713"/>are expressed as <code>(</code><code>outs GPROpnd:$rd)</code>.</p>&#13;
			<p>The <code>outs</code> operation denotes this dag as the output operand list. The only argument, <code>GPROpnd:$rd</code>, consists of a type and a name. It connects several pieces we have already seen. The type is <code>GPROnd</code>, which is the name of the register operand we have defined in the previous section. The name <code>$rd</code> refers to the destination register. We used this name in the operand string earlier, and also as a field name in the <code>F_L</code> superclass. The input operands are defined similarly. The rest of the class initializes the other bits of the <code>Inst</code> field. Please take the time and check that all 32 bits are indeed now assigned.</p>&#13;
			<p>We put the final instruction definition in the <code>M88kInstrInfo.td</code> file. Since we have two variants of each logical instruction, we use a multiclass to define both instructions at once. We also define here the pattern for the instruction selection as a directed acyclic graph. The operation in the pattern is <code>set</code>, and the first argument is the destination register. The second argument is a nested graph, which is the actual pattern. Once again, the name of the operation is the first <code>OpNode</code> element. LLVM has many predefined operations, which you find in the <code>llvm/include/llvm/Target/TargetSelectionDAG.td</code> file (<a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td</a>). For example, there is the <code>and</code> operation, which denotes a bitwise AND operation. The arguments are the two source registers, <code>$rs1</code> and <code>$rs2</code>.You read this pattern roughly as follows: if the input to the instruction selection contains an OpNode operation using two registers, then assign the result of this operation to the <code>$rd</code> register and generate this instruction. Utilizing the graph structure, you can define more complex patterns. For example, the second pattern integrates the complement into the pattern using the <code>not</code> operand.</p>&#13;
			<p>A small detail <a id="_idIndexMarker715"/>to point out is that the <a id="_idIndexMarker716"/>logical operations are commutative. This can be helpful for the instruction selection, so we set the <code>isCommutable</code> flag to <code>1</code> for those instructions:</p>&#13;
			<pre class="source-code">&#13;
multiclass Logic&lt;bits&lt;5&gt; Fun, string OpcStr, SDNode OpNode&gt; {&#13;
  let isCommutable = 1 in&#13;
    def rr : F_LR&lt;Fun, /*comp=*/0b0, OpcStr,&#13;
                  [(set i32:$rd,&#13;
                   (OpNode GPROpnd:$rs1, GPROpnd:$rs2))]&gt;;&#13;
  def rrc : F_LR&lt;Fun, /*comp=*/0b1, OpcStr,&#13;
                 [(set i32:$rd,&#13;
                 (OpNode GPROpnd:$rs1, (not GPROpnd:$rs2)))]&gt;;&#13;
}</pre>			<p>And finally, we define the records for the instructions:</p>&#13;
			<pre class="source-code">&#13;
defm AND : Logic&lt;0b01000, "and", and&gt;;&#13;
defm XOR : Logic&lt;0b01010, "xor", xor&gt;;&#13;
defm OR  : Logic&lt;0b01011, "or", or&gt;;</pre>			<p>The first parameter is the bit pattern for the function, the second is the mnemonic, and the third parameter is the dag operation used in the pattern.</p>&#13;
			<p>To fully understand the class hierarchy, revisit the class definitions. The guiding design principle is to avoid the repetition of information. For example, the <code>0b01000</code> function bit pattern is used exactly once. Without the <code>Logic</code> multiclass you would need to type this bit pattern twice and repeat the patterns several times, which is error-prone.</p>&#13;
			<p>Please also note that it is good to establish a naming scheme for the instructions. For example, the record for the <code>and</code> instruction is named <code>ANDrr</code>, while the variant with the complemented <a id="_idIndexMarker717"/>register is named <code>ANDrrc</code>. Those <a id="_idIndexMarker718"/>names end up in the generated C++ source code, and using a naming scheme helps to understand to which assembler instruction the name refers.</p>&#13;
			<p>Up to now, we modeled the register file of the m88k architecture and defined a couple of instructions. In the next section, we will create the top-level file.</p>&#13;
			<h2 id="_idParaDest-178"><a id="_idTextAnchor185"/>Creating the top-level file for the target description</h2>&#13;
			<p>So far, we created the <code>M88kRegisterInfo.td</code>, <code>M88kInstrFormats.td</code>, and <code>M88kInstrInfo.td</code> <a id="_idIndexMarker719"/>files. The target description is a single file, called <code>M88k.td</code>. This file includes the LLVM definitions first, and the files that we have implemented follow afterwards.:</p>&#13;
			<pre class="source-code">&#13;
include "llvm/Target/Target.td"&#13;
include "M88kRegisterInfo.td"&#13;
include "M88kInstrFormats.td"&#13;
include "M88kInstrInfo.td"</pre>			<p>We will extend this <code>include</code> section later when we add more backend functionality.</p>&#13;
			<p>The top-level file also defines some global instances. The first record named <code>M88kInstrInfo</code> holds the information about all instructions:</p>&#13;
			<pre class="source-code">&#13;
def M88kInstrInfo : InstrInfo;</pre>			<p>We call the assembler class <code>M88kAsmParser</code>. To enable TableGen to identify hardcoded registers, we specify that register names are prefixed with a percent sign, and we need to define an assembler parser variant to specify this:</p>&#13;
			<pre class="source-code">&#13;
def M88kAsmParser : AsmParser;&#13;
def M88kAsmParserVariant : AsmParserVariant {&#13;
  let RegisterPrefix = "%";&#13;
}</pre>			<p>And last, we <a id="_idIndexMarker720"/>need to define the target:</p>&#13;
			<pre class="source-code">&#13;
def M88k : Target {&#13;
  let InstructionSet = M88kInstrInfo;&#13;
  let AssemblyParsers  = [M88kAsmParser];&#13;
  let AssemblyParserVariants = [M88kAsmParserVariant];&#13;
}</pre>			<p>We now have defined enough of the target so that we can code the first utility. In the next section, we add the M88k backend to LLVM.</p>&#13;
			<h1 id="_idParaDest-179"><a id="_idTextAnchor186"/>Adding the M88k backend to LLVM</h1>&#13;
			<p>We have not yet discussed where to place the target description files. Each backend in LLVM has <a id="_idIndexMarker721"/>a subdirectory in <code>llvm/lib/Target</code>. We create the <code>M88k</code> directory here and copy the target description files into it.</p>&#13;
			<p>Of course, just adding the TableGen files is not enough. LLVM uses a registry to look up instances <a id="_idIndexMarker722"/>of a target implementation, and it expects certain global functions to register those instances. And since some parts are generated, we can already provide an implementation.</p>&#13;
			<p>All information about a target, like the target triple and factory function for the target machine, assembler, disassembler, and so on, are stored in an instance of the <code>Target</code> class. Each target holds a static instance of this class, and this instance is registered in the central registry:</p>&#13;
			<ol>&#13;
				<li>The implementation is in the <code>M88kTargetInfo.cpp</code> file in the <code>TargetInfo</code> subdirectory in our target. The single instance of the <code>Target</code> class is held inside the <code>getTheM88kTarget()</code> function:<pre class="source-code">&#13;
using namespace llvm;&#13;
Target &amp;llvm::getTheM88kTarget() {&#13;
  static Target TheM88kTarget;&#13;
  return TheM88kTarget;&#13;
}</pre></li>				<li>LLVM requires that each target provides a <code>LLVMInitialize&lt;Target Name&gt;TargetInfo()</code> function to register the target instance. That function must have <a id="_idIndexMarker723"/>a C linkage because it is also used in the LLVM C API:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTargetInfo() {&#13;
    RegisterTarget&lt;Triple::m88k, /*HasJIT=*/false&gt; X(&#13;
      getTheM88kTarget(), "m88k", "M88k", "M88k");&#13;
}</pre></li>				<li>We also <a id="_idIndexMarker724"/>need to create an <code>M88kTargetInfo.h</code> header file in the same directory, which just contains a single declaration:<pre class="source-code">&#13;
namespace llvm {&#13;
class Target;&#13;
Target &amp;getTheM88kTarget();&#13;
}</pre></li>				<li>And last, we add a <code>CMakeLists.txt</code> file for building:<pre class="source-code">&#13;
add_llvm_component_library(LLVMM88kInfo&#13;
  M88kTargetInfo.cpp&#13;
  LINK_COMPONENTS  Support&#13;
  ADD_TO_COMPONENT M88k)</pre></li>			</ol>&#13;
			<p>Next, we partially <a id="_idIndexMarker725"/>populate the target instance with the information used at the <strong class="bold">machine-code </strong>(<strong class="bold">MC</strong>) level. Let’s get started:</p>&#13;
			<ol>&#13;
				<li>The implementation is in the <code>M88kMCTargetDesc.cpp</code> file in the <code>MCTargetDesc</code> subdirectory. TableGen turns the target description we created in the previous section into C++ source code fragments. Here, we include the parts for the register information, the instruction information, and the sub-target information:<pre class="source-code">&#13;
using namespace llvm;&#13;
#define GET_INSTRINFO_MC_DESC&#13;
#include "M88kGenInstrInfo.inc"&#13;
#define GET_SUBTARGETINFO_MC_DESC&#13;
#include "M88kGenSubtargetInfo.inc"&#13;
#define GET_REGINFO_MC_DESC&#13;
#include "M88kGenRegisterInfo.inc"</pre></li>				<li>The target <a id="_idIndexMarker726"/>registry expects a factory method for <a id="_idIndexMarker727"/>each of the classes here. Let’s begin with the instruction information. We allocate an instance of the <code>MCInstrInfo</code> class, and call the <code>InitM88kMCInstrInfo()</code> generated function to populate the object:<pre class="source-code">&#13;
static MCInstrInfo *createM88kMCInstrInfo() {&#13;
    MCInstrInfo *X = new MCInstrInfo();&#13;
    InitM88kMCInstrInfo(X);&#13;
    return X;&#13;
}</pre></li>				<li>Next, we allocate an object of the <code>MCRegisterInfo</code> class and call a generated function to populate it. The additional <code>M88k::R1</code> parameter value tells LLVM that the <code>r1</code> register holds the return address:<pre class="source-code">&#13;
static MCRegisterInfo *&#13;
createM88kMCRegisterInfo(const Triple &amp;TT) {&#13;
    MCRegisterInfo *X = new MCRegisterInfo();&#13;
    InitM88kMCRegisterInfo(X, M88k::R1);&#13;
    return X;&#13;
}</pre></li>				<li>And last, we need <a id="_idIndexMarker728"/>a factory method for the sub-target <a id="_idIndexMarker729"/>information. This method takes a target triple, a CPU name, and a feature string as parameters, and forwards them to the generated method:<pre class="source-code">&#13;
static MCSubtargetInfo *&#13;
createM88kMCSubtargetInfo(const Triple &amp;TT,&#13;
                          StringRef CPU, StringRef FS) {&#13;
  return createM88kMCSubtargetInfoImpl(TT, CPU,&#13;
                                       /*TuneCPU*/ CPU,&#13;
                                       FS);&#13;
}</pre></li>				<li>Having the factory methods defined, we can now register them. Similar to the target registration, LLVM expects a global function called <code>LLVMInitialize&lt;Target Name&gt;TargetMC()</code>:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTargetMC() {&#13;
  TargetRegistry::RegisterMCInstrInfo(&#13;
      getTheM88kTarget(), createM88kMCInstrInfo);&#13;
  TargetRegistry::RegisterMCRegInfo(&#13;
      getTheM88kTarget(), createM88kMCRegisterInfo);&#13;
  TargetRegistry::RegisterMCSubtargetInfo(&#13;
      getTheM88kTarget(), createM88kMCSubtargetInfo);&#13;
}</pre></li>				<li>The <code>M88kMCTargetDesc.h</code> header <a id="_idIndexMarker730"/>file just makes <a id="_idIndexMarker731"/>some generated code available:<pre class="source-code">&#13;
#define GET_REGINFO_ENUM&#13;
#include "M88kGenRegisterInfo.inc"&#13;
#define GET_INSTRINFO_ENUM&#13;
#include "M88kGenInstrInfo.inc"&#13;
#define GET_SUBTARGETINFO_ENUM&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>			</ol>&#13;
			<p>The implementation is almost done. To prevent a linker error, we need to provide another function, which registers a factory method for an object of the <code>TargetMachine</code> class. This class is required for code generation, and we implement it in <a href="B19561_12.xhtml#_idTextAnchor193"><em class="italic">Chapter 12</em></a><em class="italic">, Instruction Selection</em>, up next. Here, we just define an empty function in the <code>M88kTargetMachine.cpp</code> file:</p>&#13;
			<pre class="source-code">&#13;
#include "TargetInfo/M88kTargetInfo.h"&#13;
#include "llvm/MC/TargetRegistry.h"&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTarget() {&#13;
  // TODO Register the target machine. See chapter 12.&#13;
}</pre>			<p>This concludes <a id="_idIndexMarker732"/>our first implementation. However, LLVM does <a id="_idIndexMarker733"/>not yet know about our new backend. To integrate it, open the <code>llvm/CMakeLists.txt</code> file, locate the section defining all the experimental targets, and add the M88k target to the list:</p>&#13;
			<pre class="source-code">&#13;
set(LLVM_ALL_EXPERIMENTAL_TARGETS ARC … <strong class="bold">M88k  </strong>…)</pre>			<p>Assuming the LLVM source code with our new backend is in the directory, you can configure the build by typing the following:</p>&#13;
			<pre class="console">&#13;
$ mkdir build&#13;
$ cd build&#13;
$ cmake -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k \&#13;
  ../llvm-m88k/llvm&#13;
…&#13;
-- Targeting M88k&#13;
…</pre>			<p>After building LLVM, you can verify that the tools already know about our new target:</p>&#13;
			<pre class="console">&#13;
$ bin/llc –version&#13;
LLVM (http://llvm.org/):&#13;
  LLVM version 17.0.2&#13;
  Registered Targets:&#13;
    m88k     - M88k</pre>			<p>The journey to get to this point was difficult, so take a moment to celebrate!</p>&#13;
			<p class="callout-heading">Fixing a possible compile error</p>&#13;
			<p class="callout">There is a small oversight in LLVM 17.0.2, which causes a compile error. In one place in the code, the TableGen emitter for the sub-target information uses the removed value <code>llvm::None</code> instead of <code>std:: nullopt</code>, causing an error while compiling <code>M88kMCTargetDesc.cpp</code>. The easiest way to fix this problem is to cherry-pick the fix from the LLVM 18 development branch: <code>git cherry-pick -</code><code>x a587f429</code>.</p>&#13;
			<p>In the <a id="_idIndexMarker734"/>next section, we implement the assembler parser, which will <a id="_idIndexMarker735"/>give us the first working LLVM tool.</p>&#13;
			<h1 id="_idParaDest-180"><a id="_idTextAnchor187"/>Implementing the assembler parser</h1>&#13;
			<p>The assembler parser is easy to implement, since LLVM provides a framework for it, and large parts are generated from the target description.</p>&#13;
			<p>The <code>ParseInstruction()</code> method in <a id="_idIndexMarker736"/>our class is called when the framework detects that an instruction needs to be parsed. That method parses in input via the provided lexer and constructs a so-called operand vector. An operand can <a id="_idIndexMarker737"/>be a token such as an instruction mnemonic, a register name, or an immediate, or it can be category-specific to the target. For example, two operands are constructed from the <code>jmp %r2</code> input: a token operand for the mnemonic, and a register operand.</p>&#13;
			<p>Then a generated matcher tries to match the operand vector against the instructions. If a match is found, then an instance of the <code>MCInst</code> class is created, which holds the parsed instruction. Otherwise, an error message is emitted. The advantage of this approach is that it automatically derives the matcher from the target description, without needing to handle all syntactical quirks.</p>&#13;
			<p>However, we need to add a couple more support classes to make the assembler parser work. These additional classes are all stored in the <code>MCTargetDesc</code> directory.</p>&#13;
			<h3>Implementing the MCAsmInfo support class for the M88k Target</h3>&#13;
			<p>Within <a id="_idIndexMarker738"/>this section, we <a id="_idIndexMarker739"/>explore <a id="_idIndexMarker740"/>implementing the first required class for the configuration of the assembler parser: the <code>MCAsmInfo</code> class:</p>&#13;
			<ol>&#13;
				<li>We need to set some customization parameters for the assembler parser. The <code>MCAsmInfo</code> base class (<a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h</a>) contains the common parameters. In addition, a subclass is created for each supported object file format; for example, the <code>MCAsmInfoELF</code> class (<a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h</a>). The reasoning behind it is that the system assemblers on systems using the same object file format <a id="_idIndexMarker741"/>share common characteristics because they must support similar features. Our <a id="_idIndexMarker742"/>target operating system is OpenBSD, and it uses the ELF file format, so we derive <a id="_idIndexMarker743"/>our own <code>M88kMCAsmInfo</code> class from the <code>MCAsmInfoELF</code> class. The declaration in the <code>M88kMCAsmInfo.h</code> file is as follows:<pre class="source-code">&#13;
namespace llvm {&#13;
class Triple;&#13;
class M88kMCAsmInfo : public MCAsmInfoELF {&#13;
public:&#13;
  explicit M88kMCAsmInfo(const Triple &amp;TT);&#13;
};</pre></li>				<li>The implementation in the <code>M88kMCAsmInfo.cpp</code> file only sets a couple of default values. Two crucial settings at present are the system using big-endian mode and employing the <code>|</code> symbol for comments. The other settings are for code generation later:<pre class="source-code">&#13;
using namespace llvm;&#13;
M88kMCAsmInfo::M88kMCAsmInfo(const Triple &amp;TT) {&#13;
  IsLittleEndian = false;&#13;
  UseDotAlignForAlignment = true;&#13;
  MinInstAlignment = 4;&#13;
  CommentString = "|"; // # as comment delimiter is only&#13;
                       // allowed at first column&#13;
  ZeroDirective = "\t.space\t";&#13;
  Data64bitsDirective = "\t.quad\t";&#13;
  UsesELFSectionDirectiveForBSS = true;&#13;
  SupportsDebugInformation = false;&#13;
  ExceptionsType = ExceptionHandling::SjLj;&#13;
}</pre></li>			</ol>&#13;
			<p>Now <a id="_idIndexMarker744"/>we have completed the implementation for the <code>MCAsmInfo</code> class. The next class we will learn to implement helps us create a binary representation of the instructions within LLVM.</p>&#13;
			<h3>Implementing the MCCodeEmitter support class for the M88k Target</h3>&#13;
			<p>Internally in LLVM, an instruction is represented by an instance of the <code>MCInst</code> class. An instruction <a id="_idIndexMarker745"/>can be emitted <a id="_idIndexMarker746"/>as an assembler <a id="_idIndexMarker747"/>text or in binary into an object file. The <code>M88kMCCodeEmitter</code> class creates the binary representation of an instruction, while the <code>M88kInstPrinter</code> class emits the textual representation of it.</p>&#13;
			<p>First, we will implement the <code>M88kMCCodeEmitter</code> class, which is stored in the <code>M88kMCCodeEmitter.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>Most of the class is generated by TableGen. Therefore, we only need to add some boilerplate code. Note that there is no corresponding header file; the prototype of the factory function will be added to the <code>M88kMCTargetDesc.h</code> file. It begins with setting up a statistic counter for the number of emitted instructions:<pre class="source-code">&#13;
using namespace llvm;&#13;
#define DEBUG_TYPE "mccodeemitter"&#13;
STATISTIC(MCNumEmitted,&#13;
          "Number of MC instructions emitted");</pre></li>				<li>The <code>M88kMCCodeEmitter</code> class lives in an anonymous namespace. We only need <a id="_idIndexMarker748"/>to implement the <code>encodeInstruction()</code> method, which is declared <a id="_idIndexMarker749"/>in the base <a id="_idIndexMarker750"/>class, and the <code>getMachineOpValue()</code> helper method. The other <code>getBinaryCodeForInstr()</code> method is generated by TableGen from the target description:<pre class="source-code">&#13;
namespace {&#13;
class M88kMCCodeEmitter : public MCCodeEmitter {&#13;
  const MCInstrInfo &amp;MCII;&#13;
  MCContext &amp;Ctx;&#13;
public:&#13;
  M88kMCCodeEmitter(const MCInstrInfo &amp;MCII,&#13;
                    MCContext &amp;Ctx)&#13;
      : MCII(MCII), Ctx(Ctx) {}&#13;
  ~M88kMCCodeEmitter() override = default;&#13;
  void encodeInstruction(&#13;
      const MCInst &amp;MI, raw_ostream &amp;OS,&#13;
      SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
      const MCSubtargetInfo &amp;STI) const override;&#13;
  uint64_t getBinaryCodeForInstr(&#13;
      const MCInst &amp;MI,&#13;
      SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
      const MCSubtargetInfo &amp;STI) const;&#13;
  unsigned&#13;
  getMachineOpValue(const MCInst &amp;MI,&#13;
                    const MCOperand &amp;MO,&#13;
                    SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
                    const MCSubtargetInfo &amp;STI) const;&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>The <code>encodeInstruction()</code> method just looks up the binary representation of <a id="_idIndexMarker751"/>the instruction, increments the statistic counter, and writes the bytes out <a id="_idIndexMarker752"/>in big-endian <a id="_idIndexMarker753"/>format. Remember that the instructions have a fixed size of 4 bytes, therefore we use the <code>uint32_t</code> type on the endian stream:<pre class="source-code">&#13;
void M88kMCCodeEmitter::encodeInstruction(&#13;
    const MCInst &amp;MI, raw_ostream &amp;OS,&#13;
    SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
    const MCSubtargetInfo &amp;STI) const {&#13;
  uint64_t Bits =&#13;
      getBinaryCodeForInstr(MI, Fixups, STI);&#13;
  ++MCNumEmitted;&#13;
  support::endian::write&lt;uint32_t&gt;(OS, Bits,&#13;
                                   support::big);&#13;
}</pre></li>				<li>The task of the <code>getMachineOpValue()</code> method is to return the binary representation of operands. In the target description, we defined the bit ranges where <a id="_idIndexMarker754"/>the registers used are stored in an instruction. Here, we compute the value, which is stored in these places. The method is called from the generated code. We <a id="_idIndexMarker755"/>only support <a id="_idIndexMarker756"/>two cases. For a register, the encoding of the register, which we defined in the target description, is returned. For an immediate, the immediate value is returned:<pre class="source-code">&#13;
unsigned M88kMCCodeEmitter::getMachineOpValue(&#13;
    const MCInst &amp;MI, const MCOperand &amp;MO,&#13;
    SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
    const MCSubtargetInfo &amp;STI) const {&#13;
  if (MO.isReg())&#13;
    return Ctx.getRegisterInfo()-&gt;getEncodingValue(&#13;
        MO.getReg());&#13;
  if (MO.isImm())&#13;
    return static_cast&lt;uint64_t&gt;(MO.getImm());&#13;
  return 0;&#13;
}</pre></li>				<li>And last, we <a id="_idIndexMarker757"/>include <a id="_idIndexMarker758"/>the generated <a id="_idIndexMarker759"/>file and create a factory method for the class:<pre class="source-code">&#13;
#include "M88kGenMCCodeEmitter.inc"&#13;
MCCodeEmitter *&#13;
llvm::createM88kMCCodeEmitter(const MCInstrInfo &amp;MCII,&#13;
                              MCContext &amp;Ctx) {&#13;
  return new M88kMCCodeEmitter(MCII, Ctx);&#13;
}</pre></li>			</ol>&#13;
			<h3>Implementing the instruction printer support class for the M88k Target</h3>&#13;
			<p>The <code>M88kInstPrinter</code> class has a similar structure to the <code>M88kMCCodeEmitter</code> class. As mentioned previously, the <code>InstPrinter</code> class is responsible for emitting the textual <a id="_idIndexMarker760"/>representation of LLVM instructions. Most of the class is generated by TableGen, but we have <a id="_idIndexMarker761"/>to add <a id="_idIndexMarker762"/>support for printing the operands. The class is declared in the <code>M88kInstPrinter.h</code> header file. The implementation is in the <code>M88kInstPrinter.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>Let’s begin with the header file. After including the required header files and declaring the <code>llvm</code> namespace, two forward references are declared to reduce the number of required includes:<pre class="source-code">&#13;
namespace llvm {&#13;
class MCAsmInfo;&#13;
class MCOperand;</pre></li>				<li>Besides <a id="_idIndexMarker763"/>the constructor, we <a id="_idIndexMarker764"/>only need to implement the <code>printOperand()</code> and <code>printInst()</code> methods. The other methods are generated <a id="_idIndexMarker765"/>by TableGen:<pre class="source-code">&#13;
class M88kInstPrinter : public MCInstPrinter {&#13;
public:&#13;
  M88kInstPrinter(const MCAsmInfo &amp;MAI,&#13;
                  const MCInstrInfo &amp;MII,&#13;
                  const MCRegisterInfo &amp;MRI)&#13;
      : MCInstPrinter(MAI, MII, MRI) {}&#13;
  std::pair&lt;const char *, uint64_t&gt;&#13;
  getMnemonic(const MCInst *MI) override;&#13;
  void printInstruction(const MCInst *MI,&#13;
                        uint64_t Address,&#13;
                        const MCSubtargetInfo &amp;STI,&#13;
                        raw_ostream &amp;O);&#13;
  static const char *getRegisterName(MCRegister RegNo);&#13;
  void printOperand(const MCInst *MI, int OpNum,&#13;
                    const MCSubtargetInfo &amp;STI,&#13;
                    raw_ostream &amp;O);&#13;
  void printInst(const MCInst *MI, uint64_t Address,&#13;
                 StringRef Annot,&#13;
                 const MCSubtargetInfo &amp;STI,&#13;
                 raw_ostream &amp;O) override;&#13;
};&#13;
} // end namespace llvm</pre></li>				<li>The <a id="_idIndexMarker766"/>implementation lives in the <code>M88kInstPrint.cpp</code> file. After including the required <a id="_idIndexMarker767"/>header file and using the <code>llvm</code> namespace, the file with the generated <a id="_idIndexMarker768"/>C++ fragments is included:<pre class="source-code">&#13;
using namespace llvm;&#13;
#define DEBUG_TYPE "asm-printer"&#13;
#include "M88kGenAsmWriter.inc"</pre></li>				<li>The <code>printOperand()</code> method checks the type of the operand and emits either a register name or an immediate. The register name is looked up with the <code>getRegisterName()</code> generated method:<pre class="source-code">&#13;
void M88kInstPrinter::printOperand(&#13;
    const MCInst *MI, int OpNum,&#13;
    const MCSubtargetInfo &amp;STI, raw_ostream &amp;O) {&#13;
  const MCOperand &amp;MO = MI-&gt;getOperand(OpNum);&#13;
  if (MO.isReg()) {&#13;
    if (!MO.getReg())&#13;
      O &lt;&lt; '0';&#13;
    else&#13;
      O &lt;&lt; '%' &lt;&lt; getRegisterName(MO.getReg());&#13;
  } else if (MO.isImm())&#13;
    O &lt;&lt; MO.getImm();&#13;
  else&#13;
    llvm_unreachable("Invalid operand");&#13;
}</pre></li>				<li>The <code>printInst()</code> method only calls the <code>printInstruction()</code> generated method <a id="_idIndexMarker769"/>to print <a id="_idIndexMarker770"/>the instruction, and after that, the <code>printAnnotation()</code> method <a id="_idIndexMarker771"/>to print possible annotations:<pre class="source-code">&#13;
void M88kInstPrinter::printInst(&#13;
    const MCInst *MI, uint64_t Address, StringRef Annot,&#13;
    const MCSubtargetInfo &amp;STI, raw_ostream &amp;O) {&#13;
  printInstruction(MI, Address, STI, O);&#13;
  printAnnotation(O, Annot);&#13;
}</pre></li>			</ol>&#13;
			<h3>Implementing M88k-specific target descriptions</h3>&#13;
			<p>In the <code>M88kMCTargetDesc.cpp</code> file, we need to make a couple of additions:</p>&#13;
			<ol>&#13;
				<li>First, we <a id="_idIndexMarker772"/>need a new factory method for the <code>MCInstPrinter</code> class and the <code>MCAsmInfo</code> class:<pre class="source-code">&#13;
static MCInstPrinter *createM88kMCInstPrinter(&#13;
    const Triple &amp;T, unsigned SyntaxVariant,&#13;
    const MCAsmInfo &amp;MAI, const MCInstrInfo &amp;MII,&#13;
    const MCRegisterInfo &amp;MRI) {&#13;
  return new M88kInstPrinter(MAI, MII, MRI);&#13;
}&#13;
static MCAsmInfo *&#13;
createM88kMCAsmInfo(const MCRegisterInfo &amp;MRI,&#13;
                    const Triple &amp;TT,&#13;
                    const MCTargetOptions &amp;Options) {&#13;
  return new M88kMCAsmInfo(TT);&#13;
}</pre></li>				<li>Finally, within <a id="_idIndexMarker773"/>the <code>LLVMInitializeM88kTargetMC()</code> function, we need to add the registration of the factory methods:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTargetMC() {&#13;
  // …&#13;
  TargetRegistry::RegisterMCAsmInfo(&#13;
      getTheM88kTarget(), createM88kMCAsmInfo);&#13;
  TargetRegistry::RegisterMCCodeEmitter(&#13;
      getTheM88kTarget(), createM88kMCCodeEmitter);&#13;
  TargetRegistry::RegisterMCInstPrinter(&#13;
      getTheM88kTarget(), createM88kMCInstPrinter);&#13;
}</pre></li>			</ol>&#13;
			<p>Now we have implemented all required support classes, and we can finally add the assembler parser.</p>&#13;
			<h3>Creating the M88k assembler parser class</h3>&#13;
			<p>There is only an <code>M88kAsmParser.cpp</code> implementation file in the <code>AsmParser</code> directory. The <code>M88kOperand</code> class represents a parsed operand and is used by the generated <a id="_idIndexMarker774"/>source code and our assembler parser implementation in class <code>M88kAssembler</code>. Both classes are in an anonymous namespace, only <a id="_idIndexMarker775"/>the factory method is globally visible. Let’s take a look at the <code>M88kOperand</code> class first:</p>&#13;
			<ol>&#13;
				<li>An operand can be a token, a register, or an immediate. We define the <code>OperandKind</code> enumeration to distinguish between these cases. The current kind is stored in the <code>Kind</code> member. We also store the start and the end location of the operand, which is needed to print the error message:<pre class="source-code">&#13;
class M88kOperand : public MCParsedAsmOperand {&#13;
  enum OperandKind { OpKind_Token, OpKind_Reg,&#13;
                     OpKind_Imm };&#13;
  OperandKind Kind;&#13;
  SMLoc StartLoc, EndLoc;</pre></li>				<li>To store the value, we define a union. The token is stored as a <code>StringRef</code> and the register is identified by its number. The immediate is represented by the <code>MCExpr</code> class:<pre class="source-code">&#13;
   union {&#13;
    StringRef Token;&#13;
    unsigned RegNo;&#13;
    const MCExpr *Imm;&#13;
  };</pre></li>				<li>The constructor initializes all fields but the union. Furthermore, we define methods <a id="_idIndexMarker776"/>to return the value of the start and the end locations:<pre class="source-code">&#13;
public:&#13;
  M88kOperand(OperandKind Kind, SMLoc StartLoc,&#13;
              SMLoc EndLoc)&#13;
      : Kind(Kind), StartLoc(StartLoc), EndLoc(EndLoc) {}&#13;
  SMLoc getStartLoc() const override { return StartLoc; }&#13;
  SMLoc getEndLoc() const override { return EndLoc; }</pre></li>				<li>For each <a id="_idIndexMarker777"/>operand type, we must define four methods. For a register, the methods are <code>isReg()</code> to check whether the operand is a register, <code>getReg()</code> to return the value, <code>createReg()</code> to create a register operand, and <code>addRegOperands()</code> to add an operant to an instruction. The latter function is called by the generated source code when an instruction is constructed. The methods for the token and the immediate are similar:<pre class="source-code">&#13;
  bool isReg() const override {&#13;
    return Kind == OpKind_Reg;&#13;
  }&#13;
  unsigned getReg() const override { return RegNo; }&#13;
  static std::unique_ptr&lt;M88kOperand&gt;&#13;
  createReg(unsigned Num, SMLoc StartLoc,&#13;
            SMLoc EndLoc) {&#13;
    auto Op = std::make_unique&lt;M88kOperand&gt;(&#13;
        OpKind_Reg, StartLoc, EndLoc);&#13;
    Op-&gt;RegNo = Num;&#13;
    return Op;&#13;
  }&#13;
  void addRegOperands(MCInst &amp;Inst, unsigned N) const {&#13;
    assert(N == 1 &amp;&amp; "Invalid number of operands");&#13;
    Inst.addOperand(MCOperand::createReg(getReg()));&#13;
  }</pre></li>				<li>And last, the <a id="_idIndexMarker778"/>superclass defines an abstract <code>print()</code> virtual <a id="_idIndexMarker779"/>method that we need to implement. This is only used for debugging purposes:<pre class="source-code">&#13;
  void print(raw_ostream &amp;OS) const override {&#13;
    switch (Kind) {&#13;
    case OpKind_Imm:&#13;
      OS &lt;&lt; "Imm: " &lt;&lt; getImm() &lt;&lt; "\n"; break;&#13;
    case OpKind_Token:&#13;
      OS &lt;&lt; "Token: " &lt;&lt; getToken() &lt;&lt; "\n"; break;&#13;
    case OpKind_Reg:&#13;
      OS &lt;&lt; "Reg: "&#13;
         &lt;&lt; M88kInstPrinter::getRegisterName(getReg())&#13;
         &lt;&lt; „\n"; break;&#13;
    }&#13;
  }&#13;
};</pre></li>			</ol>&#13;
			<p>Next, we <a id="_idIndexMarker780"/>declare the <code>M88kAsmParser</code> class. The <a id="_idIndexMarker781"/>anonymous name space will end after the declaratio<a id="_idTextAnchor188"/>n:</p>&#13;
			<ol>&#13;
				<li>At the beginning of the class we include the generated fragment:<pre class="source-code">&#13;
class M88kAsmParser : public MCTargetAsmParser {&#13;
#define GET_ASSEMBLER_HEADER&#13;
#include "M88kGenAsmMatcher.inc"</pre></li>				<li>Next, we define the required fields. We need a reference to the actual parser, which is of the <code>MCAsmParser</code> class, and a reference to the sub-target information:<pre class="source-code">&#13;
  MCAsmParser &amp;Parser;&#13;
  const MCSubtargetInfo &amp;SubtargetInfo;</pre></li>				<li>To implement the assembler, we override a couple of methods defined in the <code>MCTargetAsmParser</code> superclass. The <code>MatchAndEmitInstruction()</code> method tries to match an instruction and emits the instruction represented by an instance of the <code>MCInst</code> class. Parsing an instruction is done in the <code>ParseInstruction()</code> method, while the <code>parseRegister()</code> and <code>tryParseRegister()</code> metho<a id="_idTextAnchor189"/>ds are responsible for parsing the register. The other methods are required internally:<pre class="source-code">&#13;
  bool&#13;
  ParseInstruction(ParseInstructionInfo &amp;Info,&#13;
                   StringRef Name, SMLoc NameLoc,&#13;
                   OperandVector &amp;Operands) override;&#13;
  bool parseRegister(MCRegister &amp;RegNo, SMLoc &amp;StartLoc,&#13;
                     SMLoc &amp;EndLoc) override;&#13;
  OperandMatchResultTy&#13;
  tryParseRegister(MCRegister &amp;RegNo, SMLoc &amp;StartLoc,&#13;
                   SMLoc &amp;EndLoc) override;&#13;
  bool parseRegister(MCRegister &amp;RegNo, SMLoc &amp;StartLoc,&#13;
                     SMLoc &amp;EndLoc,&#13;
                     bool RestoreOnFailure);&#13;
  bool parseOperand(OperandVector &amp;Operands,&#13;
                    StringRef Mnemonic);&#13;
  bool MatchAndEmitInstruction(&#13;
      SMLoc IdLoc, unsigned &amp;Opcode,&#13;
      OperandVector &amp;Operands, MCStreamer &amp;Out,&#13;
      uint64_t &amp;ErrorInfo,&#13;
      bool MatchingInlineAsm) override;</pre></li>				<li>The <a id="_idIndexMarker782"/>constructor is defined inline. It mostly <a id="_idIndexMarker783"/>initializes all fields. This finishes the class declaration, after which the anonymous namespace ends:<pre class="source-code">&#13;
public:&#13;
  M88kAsmParser(const MCSubtargetInfo &amp;STI,&#13;
                MCAsmParser &amp;Parser,&#13;
                const MCInstrInfo &amp;MII,&#13;
                const MCTargetOptions &amp;Options)&#13;
      : MCTargetAsmParser(Options, STI, MII),&#13;
        Parser(Parser), SubtargetInfo(STI) {&#13;
    setAvailableFeatures(ComputeAvailableFeatures(&#13;
        SubtargetInfo.getFeatureBits()));&#13;
  }&#13;
};</pre></li>				<li>Now <a id="_idIndexMarker784"/>we include the generated parts <a id="_idIndexMarker785"/>of the assembler:<pre class="source-code">&#13;
#define GET_REGISTER_MATCHER&#13;
#define GET_MATCHER_IMPLEMENTATION&#13;
#include "M88kGenAsmMatcher.inc"</pre></li>				<li>The <code>ParseInstruction()</code> method is called whenever an instruction is expected. It must be able to parse all syntactical forms of an instruction. Currently, we only have instructions that take three operands, which are separated by a comma, so the parsing is simple. Be aware that the return value is <code>true</code> in case of an error!<pre class="source-code">&#13;
bool M88kAsmParser::ParseInstruction(&#13;
    ParseInstructionInfo &amp;Info, StringRef Name,&#13;
    SMLoc NameLoc, OperandVector &amp;Operands) {&#13;
  Operands.push_back(&#13;
      M88kOperand::createToken(Name, NameLoc));&#13;
  if (getLexer().isNot(AsmToken::EndOfStatement)) {&#13;
    if (parseOperand(Operands, Name)) {&#13;
      return Error(getLexer().getLoc(),&#13;
                   "expected operand");&#13;
    }&#13;
    while (getLexer().is(AsmToken::Comma)) {&#13;
      Parser.Lex();&#13;
      if (parseOperand(Operands, Name)) {&#13;
        return Error(getLexer().getLoc(),&#13;
                     "expected operand");&#13;
      }&#13;
    }&#13;
    if (getLexer().isNot(AsmToken::EndOfStatement))&#13;
      return Error(getLexer().getLoc(),&#13;
                   "unexpected token in argument list");&#13;
  }&#13;
  Parser.Lex();&#13;
  return false;&#13;
}</pre></li>				<li>An operand <a id="_idIndexMarker786"/>can be a register or an immediate. We generalize a bit and parse an expression instead of just an integer. This <a id="_idIndexMarker787"/>helps later when adding address modes. When successful, the parsed operand is added to the <code>Operands</code> list:<pre class="source-code">&#13;
bool M88kAsmParser::parseOperand(&#13;
    OperandVector &amp;Operands, StringRef Mnemonic) {&#13;
  if (Parser.getTok().is(AsmToken::Percent)) {&#13;
    MCRegister RegNo;&#13;
    SMLoc StartLoc, EndLoc;&#13;
    if (parseRegister(RegNo, StartLoc, EndLoc,&#13;
                      /*RestoreOnFailure=*/false))&#13;
      return true;&#13;
    Operands.push_back(M88kOperand::createReg(&#13;
        RegNo, StartLoc, EndLoc));&#13;
    return false;&#13;
  }&#13;
  if (Parser.getTok().is(AsmToken::Integer)) {&#13;
    SMLoc StartLoc = Parser.getTok().getLoc();&#13;
    const MCExpr *Expr;&#13;
    if (Parser.parseExpression(Expr))&#13;
      return true;&#13;
    SMLoc EndLoc = Parser.getTok().getLoc();&#13;
    Operands.push_back(&#13;
        M88kOperand::createImm(Expr, StartLoc, EndLoc));&#13;
    return false;&#13;
  }&#13;
  return true;&#13;
}</pre></li>				<li>The <code>parseRegister()</code> method <a id="_idIndexMarker788"/>tries to <a id="_idIndexMarker789"/>parse a register. First, it checks for a percent sign <code>%</code>. If this is followed by an identifier which matches a register name, then we successfully parsed a register, and return <a id="_idIndexMarker790"/>the register number in the <code>RegNo</code> parameter. However, if we cannot identify a register, then we may need to undo <a id="_idIndexMarker791"/>the lexing if the <code>RestoreOnFailure</code> parameter is <code>true</code>:<pre class="source-code">&#13;
bool M88kAsmParser::parseRegister(&#13;
    MCRegister &amp;RegNo, SMLoc &amp;StartLoc, SMLoc &amp;EndLoc,&#13;
    bool RestoreOnFailure) {&#13;
  StartLoc = Parser.getTok().getLoc();&#13;
  if (Parser.getTok().isNot(AsmToken::Percent))&#13;
    return true;&#13;
  const AsmToken &amp;PercentTok = Parser.getTok();&#13;
  Parser.Lex();&#13;
  if (Parser.getTok().isNot(AsmToken::Identifier) ||&#13;
      (RegNo = MatchRegisterName(&#13;
           Parser.getTok().getIdentifier())) == 0) {&#13;
    if (RestoreOnFailure)&#13;
      Parser.getLexer().UnLex(PercentTok);&#13;
    return Error(StartLoc, "invalid register");&#13;
  }&#13;
  Parser.Lex();&#13;
  EndLoc = Parser.getTok().getLoc();&#13;
  return false;&#13;
}</pre></li>				<li>The <code>parseRegister()</code> and <code>tryparseRegister()</code> overridden methods are just <a id="_idIndexMarker792"/>wrappers around the previously <a id="_idIndexMarker793"/>defined method. The latter method also translates the boolean return value into an enumeration member of the <code>OperandMatchResultTy</code> enumeration:<pre class="source-code">&#13;
bool M88kAsmParser::parseRegister(MCRegister &amp;RegNo,&#13;
                                  SMLoc &amp;StartLoc,&#13;
                                  SMLoc &amp;EndL<a id="_idTextAnchor190"/>oc) {&#13;
  return parseRegister(RegNo, StartLoc, EndLoc,&#13;
                       /*RestoreOnFailure=*/false);&#13;
}&#13;
OperandMatchResultTy M88kAsmParser::tryParseRegister(&#13;
    MCRegister &amp;RegNo, SMLoc &amp;StartLoc, SMLoc &amp;EndLoc) {&#13;
  bool Result =&#13;
      parseRegister(RegNo, StartLoc, EndLoc,&#13;
                    /*RestoreOnFailure=*/true);&#13;
  bool PendingErrors = getParser().hasPendingError();&#13;
  getParser().clearPendingErrors();&#13;
  if (PendingErrors)&#13;
    return MatchOperand_ParseFail;&#13;
  if (Result)&#13;
    return MatchOperand_NoMatch;&#13;
  return MatchOperand_Success;&#13;
}</pre></li>				<li>Finally, the <code>MatchAndEmitInstruction()</code> method drives the parsing. Most <a id="_idIndexMarker794"/>of the method is dedicated to emitting <a id="_idIndexMarker795"/>error messages. To identify the instruction, the <code>MatchInstructionImpl()</code> generated method is called:<pre class="source-code">&#13;
bool M88kAsmParser::MatchAndEmitInstruction(&#13;
    SMLoc IdLoc, unsigned &amp;Opcode,&#13;
    OperandVector &amp;Operands, MCStreamer &amp;Out,&#13;
    uint64_t &amp;ErrorInfo, bool MatchingInlineAsm) {&#13;
  MCInst Inst;&#13;
  SMLoc ErrorLoc;&#13;
  switch (MatchInstructionImpl(&#13;
      Operands, Inst, ErrorInfo, MatchingInlineAsm)) {&#13;
  case Match_Success:&#13;
    Out.emitInstruction(Inst, SubtargetInfo);&#13;
    Opcode = Inst.getOpcode();&#13;
    return false;&#13;
  case Match_MissingFeature:&#13;
    return Error(IdLoc, "Instruction use requires "&#13;
                        "option to be enabled");&#13;
  case Match_MnemonicFail:&#13;
    return Error(IdLoc,&#13;
                 "Unrecognized instruction mnemonic");&#13;
  case Match_InvalidOperand: {&#13;
    ErrorLoc = IdLoc;&#13;
    if (ErrorInfo != ~0U) {&#13;
      if (ErrorInfo &gt;= Operands.size())&#13;
        return Error(&#13;
            IdLoc, "Too few operands for instruction");&#13;
      ErrorLoc = ((M88kOperand &amp;)*Operands[ErrorInfo])&#13;
                     .getStartLoc();&#13;
      if (ErrorLoc == SMLoc())&#13;
        ErrorLoc = IdLoc;&#13;
    }&#13;
    return Error(ErrorLoc,&#13;
                 "Invalid operand for instruction");&#13;
  }&#13;
  default:&#13;
    break;&#13;
  }&#13;
  llvm_unreachable("Unknown match type detected!");&#13;
}</pre></li>				<li>And <a id="_idIndexMarker796"/>like some other classes, the assembler <a id="_idIndexMarker797"/>parser has its own factory method:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kAsmParser() {&#13;
  RegisterMCAsmParser&lt;M88kAsmParser&gt; X(&#13;
      getTheM88kTarget());&#13;
}</pre></li>			</ol>&#13;
			<p>This finishes <a id="_idIndexMarker798"/>the implementation of the assembler parser. After building LLVM, we can use the <strong class="bold">llvm-mc</strong> machine code playground tool to assemble an instruction:</p>&#13;
			<pre class="console">&#13;
$ echo 'and %r1,%r2,%r3' | \&#13;
  bin/llvm-mc --triple m88k-openbsd --show-encoding&#13;
        .text&#13;
        and %r1, %r2, %r3  | encoding: [0xf4,0x22,0x40,0x03]</pre>			<p>Note the <a id="_idIndexMarker799"/>use of the vertical bar <code>|</code> as the comments <a id="_idIndexMarker800"/>sign. This is the value we configured in the <code>M88kMCAsmInfo</code> class.</p>&#13;
			<p class="callout-heading">Debugging the assembler matcher</p>&#13;
			<p class="callout">To debug the assembler matcher, you specify the <code>--debug-only=asm-matcher</code> command-line option. This helps with understanding why a parsed instruction fails to match the instructions defined in the target description.</p>&#13;
			<p>In the next section, we will add a disassembler feature to the llvm-mc tool.</p>&#13;
			<h1 id="_idParaDest-181"><a id="_idTextAnchor191"/>Creating the disassembler</h1>&#13;
			<p>Implementing the disassembler is optional. However, the implementation does not require too <a id="_idIndexMarker801"/>much effort, and generating the disassembler table may catch encoding errors that are not checked by the other generators. The disassembler lives in the <code>M88kDisassembler.cpp</code> file, found in the <code>Disassembler</code> subdirectory:</p>&#13;
			<ol>&#13;
				<li>We begin the implementation by defining a debug type and the <code>DecodeStatus</code> type. Both are required for the generated code:<pre class="source-code">&#13;
using namespace llvm;&#13;
#define DEBUG_TYPE "m88k-disassembler"&#13;
using DecodeStatus = MCDisassembler::DecodeStatus;</pre></li>				<li>The <code>M88kDisassmbler</code> class lives in an anonymous namespace. We only need to <a id="_idIndexMarker802"/>implement the <code>getInstruction()</code> method:<pre class="source-code">&#13;
namespace {&#13;
class M88kDisassembler : public MCDisassembler {&#13;
public:&#13;
  M88kDisassembler(const MCSubtargetInfo &amp;STI,&#13;
                   MCContext &amp;Ctx)&#13;
      : MCDisassembler(STI, Ctx) {}&#13;
  ~M88kDisassembler() override = default;&#13;
  DecodeStatus&#13;
  getInstruction(MCInst &amp;instr, uint64_t &amp;Size,&#13;
                 ArrayRef&lt;uint8_t&gt; Bytes,&#13;
                 uint64_t Address,&#13;
                 raw_ostream &amp;CStream) const override;&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>We also need to provide a factory method, which will be registered in the target registry:<pre class="source-code">&#13;
static MCDisassembler *&#13;
createM88kDisassembler(const Target &amp;T,&#13;
                       const MCSubtargetInfo &amp;STI,&#13;
                       MCContext &amp;Ctx) {&#13;
    return new M88kDisassembler(STI, Ctx);&#13;
}&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kDisassembler() {&#13;
  TargetRegistry::RegisterMCDisassembler(&#13;
      getTheM88kTarget(), createM88kDisassembler);&#13;
}</pre></li>				<li>The <code>decodeGPRRegisterClass()</code> function turns a register number into the register enum member generated by TableGen. This is the inverse operation of the <code>M88kInstPrinter:: getMachineOpValue()</code> method. Note that we specified <a id="_idIndexMarker803"/>the name of this function in the <code>DecoderMethod</code> field in the <code>M88kRegisterOperand</code> class:<pre class="source-code">&#13;
static const uint16_t GPRDecoderTable[] = {&#13;
    M88k::R0,  M88k::R1,  M88k::R2,  M88k::R3,&#13;
    // …&#13;
};&#13;
static DecodeStatus&#13;
decodeGPRRegisterClass(MCInst &amp;Inst, uint64_t RegNo,&#13;
                       uint64_t Address,&#13;
                       const void *Decoder) {&#13;
  if (RegNo &gt; 31)&#13;
    return MCDisassembler::Fail;&#13;
  unsigned Register = GPRDecoderTable[RegNo];&#13;
  Inst.addOperand(MCOperand::createReg(Register));&#13;
  return MCDisassembler::Success;&#13;
}</pre></li>				<li>Then we <a id="_idIndexMarker804"/>include the generated disassembler tables:<pre class="source-code">&#13;
#include "M88kGenDisassemblerTables.inc"</pre></li>				<li>And finally, we decode the instruction. For this, we need to take the next four bytes of the <code>Bytes</code> array, create the instruction encoding from them, and call the <code>decodeInstruction()</code> generated function:<pre class="source-code">&#13;
DecodeStatus M88kDisassembler::getInstruction(&#13;
    MCInst &amp;MI, uint64_t &amp;Size, ArrayRef&lt;uint8_t&gt; Bytes,&#13;
    uint64_t Address, raw_ostream &amp;CS) const {&#13;
  if (Bytes.size() &lt; 4) {&#13;
    Size = 0;&#13;
    return MCDisassembler::Fail;&#13;
  }&#13;
  Size = 4;&#13;
  uint32_t Inst = 0;&#13;
  for (uint32_t I = 0; I &lt; Size; ++I)&#13;
    Inst = (Inst &lt;&lt; 8) | Bytes[I];&#13;
  if (decodeInstruction(DecoderTableM88k32, MI, Inst,&#13;
                        Address, this, STI) !=&#13;
      MCDisassembler::Success) {&#13;
      return MCDisassembler::Fail;&#13;
  }&#13;
  return MCDisassembler::Success;&#13;
}</pre></li>			</ol>&#13;
			<p>That is all <a id="_idIndexMarker805"/>that needs to be done for the disassembler. After compiling LLVM, you can test the functionality again with the <code>llvm-mc</code> tool:</p>&#13;
			<pre class="console">&#13;
$ echo "0xf4,0x22,0x40,0x03" | \&#13;
  bin/llvm-mc --triple m88k-openbsd –disassemble&#13;
        .text&#13;
        and %r1, %r2, %r3</pre>			<p>Moreover, we can now use the <code>llvm-objdump</code> tool to disassemble ELF files. However, for it to be really useful, we would need to add all instructions to the target description.</p>&#13;
			<h1 id="_idParaDest-182"><a id="_idTextAnchor192"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to create a LLVM target description, and you developed a simple backend target that supports the assembling and disassembling of instructions for LLVM. You first collected the required documentation and made LLVM aware of the new architecture by enhancing the <code>Triple</code> class. The documentation also includes the relocation definition for the ELF file format, and you added the support for them to LLVM.</p>&#13;
			<p>You then learned about the register definition and the instruction definition in the target description and used the generated C++ source code to implement an instruction assembler and disassembler.</p>&#13;
			<p>In the next chapter, we will add code generation to the backend.</p>&#13;
		</p>&#13;
	</div></body></html>