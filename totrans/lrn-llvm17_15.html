<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer034">&#13;
			<h1 id="_idParaDest-170" class="chapter-number"><a id="_idTextAnchor177"/>11</h1>&#13;
			<h1 id="_idParaDest-171"><a id="_idTextAnchor178"/>The Target Description</h1>&#13;
			<p>LLVM has a very flexible architecture. You can also add a new target backend to it. The core of a backend is the target description, from which most of the code is generated. In this chapter, you will learn how to add support for a <span class="No-Break">historical CPU.</span></p>&#13;
			<p>In this chapter, you will cover <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><em class="italic">Setting the stage for a new backend</em> introduces you to the M88k CPU architecture and shows you where to find the <span class="No-Break">required information</span></li>&#13;
				<li><em class="italic">Adding the new architecture to the Triple class</em> teaches you how to make LLVM aware of a new <span class="No-Break">CPU architecture</span></li>&#13;
				<li><em class="italic">Extending the ELF file format definition in LLVM</em> shows you how to add support for the M88k-specific relocations to the libraries and tools that handle ELF <span class="No-Break">object files</span></li>&#13;
				<li><em class="italic">Creating the target description</em> applies your knowledge of the TableGen language to model the register file and instructions in the <span class="No-Break">target description</span></li>&#13;
				<li><em class="italic">Adding the M88k backend to LLVM</em> explains the minimal infrastructure required for an <span class="No-Break">LLVM backend</span></li>&#13;
				<li><em class="italic">Implementing an assembler parser</em> shows you how to develop <span class="No-Break">the assembler</span></li>&#13;
				<li><em class="italic">Creating the disassembler</em> teaches you how to create <span class="No-Break">the disassembler</span></li>&#13;
			</ul>&#13;
			<p>By the end of the chapter, you will know how to add a new backend to LLVM. You will acquire the knowledge to develop the register file definition and instruction definition in the target description, and you will know how to create the assembler and disassembler from <span class="No-Break">that description.</span></p>&#13;
			<h1 id="_idParaDest-172"><a id="_idTextAnchor179"/>Setting the stage for a new backend</h1>&#13;
			<p>Whether commercially needed to support a new CPU or only a hobby project to add support for <a id="_idIndexMarker685"/>some old architecture, adding a new backend to LLVM is a major task. This and the following two chapters outline what you need to develop for a new backend. We will add a backend for the Motorola M88k architecture, which is a RISC architecture from <span class="No-Break">the 1980s.</span></p>&#13;
			<p class="callout-heading">References</p>&#13;
			<p class="callout">You can read <a id="_idIndexMarker686"/>more about this Motorola architecture on Wikipedia at <a href="https://en.wikipedia.org/wiki/Motorola_88000">https://en.wikipedia.org/wiki/Motorola_88000</a>. The most important information about this architecture is still available on the internet. You can find the CPU manuals with the instruction set and timing information at <a href="http://www.bitsavers.org/components/motorola/88000/">http://www.bitsavers.org/components/motorola/88000/</a>, and the System V ABI M88k Processor supplement with the definitions of the ELF format and the calling convention <span class="No-Break">at </span><a href="https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463"><span class="No-Break">https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463</span></a><span class="No-Break">.</span></p>&#13;
			<p class="callout">OpenBSD, available <a id="_idIndexMarker687"/>at <a href="https://www.openbsd.org/">https://www.openbsd.org/</a>, still supports the LUNA-88k system. On the OpenBSD system, it is easy to create a GCC cross-compiler for M88k. And <a id="_idIndexMarker688"/>with GXemul, available at <a href="http://gavare.se/gxemul/">http://gavare.se/gxemul/</a>, we get an emulator capable of running certain OpenBSD releases for the <span class="No-Break">M88k architecture.</span></p>&#13;
			<p>The M88k architecture is long out of production, but we found enough information and tools to make it an interesting goal to add an LLVM backend for it. We will begin with a very basic task of extending the <span class="No-Break"><strong class="source-inline">Triple</strong></span><span class="No-Break"> class.</span></p>&#13;
			<h1 id="_idParaDest-173"><a id="_idTextAnchor180"/>Adding the new architecture to the Triple class</h1>&#13;
			<p>An instance <a id="_idIndexMarker689"/>of the <strong class="source-inline">Triple</strong> class represents the target platform LLVM is producing code for. To support a new architecture, the first task is to extend the <strong class="source-inline">Triple</strong> class. In the <strong class="source-inline">llvm/include/llvm/TargetParser/Triple.h</strong> file, add a member to the <strong class="source-inline">ArchType</strong> enumeration along with a <span class="No-Break">new predicate:</span></p>&#13;
			<pre class="source-code">&#13;
class Triple {&#13;
public:&#13;
  enum ArchType {&#13;
      // Many more members&#13;
      m88k,      // M88000 (big endian): m88k&#13;
  };&#13;
  /// Tests whether the target is M88k.&#13;
  bool isM88k() const {&#13;
      return getArch() == Triple::m88k;&#13;
  }&#13;
// Many more methods&#13;
};</pre>			<p>Inside the <strong class="source-inline">llvm/lib/TargetParser/Triple.cpp</strong> file, there are many methods that <a id="_idIndexMarker690"/>use the <strong class="source-inline">ArchType</strong> enumeration. You need to extend all of them; for example, in the <strong class="source-inline">getArchTypeName()</strong> method, you need to add a new <strong class="source-inline">case</strong> statement <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
 switch (Kind) {&#13;
     // Many more cases&#13;
     <strong class="bold">case m88k:  </strong>         return "m88k";&#13;
  }</pre>			<p>Most times, the compiler will warn you if you forget to handle the new <strong class="source-inline">m88k</strong> enumeration <a id="_idIndexMarker691"/>member in one of the functions. Next, we will expand the <strong class="bold">Executable and Linkable </strong><span class="No-Break"><strong class="bold">Format</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ELF</strong></span><span class="No-Break">).</span></p>&#13;
			<h1 id="_idParaDest-174"><a id="_idTextAnchor181"/>Extending the ELF file format definition in LLVM</h1>&#13;
			<p>The ELF file format is one of the binary object file formats LLVM supports. ELF itself is defined for <a id="_idIndexMarker692"/>many CPU architectures, and there <a id="_idIndexMarker693"/>is also a definition for the M88k architecture. All we need to do is to add the definition of the relocations and some flags. The relocations are given in <a href="B19561_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Basics of IR Code Generation</em>, of the <em class="italic">System V ABI M88k Processor</em> supplement book (see link within the <em class="italic">Setting the stage for a new backend</em> section at the beginning of <span class="No-Break">the chapter):</span></p>&#13;
			<ol>&#13;
				<li>We need to type the following code into the  <span class="No-Break"><strong class="source-inline">llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def</strong></span><span class="No-Break"> file:</span><pre class="source-code">&#13;
#ifndef ELF_RELOC&#13;
#error "ELF_RELOC must be defined"&#13;
#endif&#13;
ELF_RELOC(R_88K_NONE, 0)&#13;
ELF_RELOC(R_88K_COPY, 1)&#13;
// Many more…</pre></li>				<li>We also add the following flags into the <strong class="source-inline">llvm/include/llvm/BinaryFormat/ELF.h</strong> file, along with the definition of <span class="No-Break">the relocations:</span><pre class="source-code">&#13;
// M88k Specific e_flags&#13;
enum : unsigned {&#13;
    EF_88K_NABI = 0x80000000,   // Not ABI compliant&#13;
    EF_88K_M88110 = 0x00000004  // File uses 88110-specific features&#13;
};&#13;
// M88k relocations.&#13;
enum {&#13;
    #include "ELFRelocs/M88k.def"&#13;
};</pre><p class="list-inset">The code can be added anywhere in the file, but it is best to keep the file structured and insert it before the code for the <span class="No-Break">MIPS architecture.</span></p></li>				<li>We also <a id="_idIndexMarker694"/>need to expand some other methods. In the <strong class="source-inline">llvm/include/llvm/Object/ELFObjectFile.h</strong> file are some methods <a id="_idIndexMarker695"/>that translate between enumeration members and strings. For example, we must add a new <strong class="source-inline">case</strong> statement to the <span class="No-Break"><strong class="source-inline">getFileFormatName()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
  switch (EF.getHeader()-&gt;e_ident[ELF::EI_CLASS]) {&#13;
// Many more cases&#13;
    case ELF::EM_88K:&#13;
      return "elf32-m88k";&#13;
  }</pre></li>				<li>Similarly, we extend the <span class="No-Break"><strong class="source-inline">getArch()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
  switch (EF.getHeader().e_machine) {&#13;
// Many more cases&#13;
  case ELF::EM_88K:&#13;
    return Triple::m88k;</pre></li>				<li>Lastly, we use the relocation definitions in the <strong class="source-inline">llvm/lib/Object/ELF.cpp</strong> file, in the <span class="No-Break"><strong class="source-inline">getELFRelocationTypeName()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
  switch (Machine) {&#13;
// Many more cases&#13;
   case ELF::EM_88K:&#13;
    switch (Type) {&#13;
#include "llvm/BinaryFormat/ELFRelocs/M88k.def"&#13;
    default:&#13;
      break;&#13;
    }&#13;
    break;&#13;
  }</pre></li>				<li>To complete <a id="_idIndexMarker696"/>the support, you can v<a id="_idIndexMarker697"/>also extend the <strong class="source-inline">llvm/lib/ObjectYAML/ELFYAML.cpp</strong> file. This file is used by the <strong class="source-inline">yaml2obj</strong> and <strong class="source-inline">obj2yaml</strong> tools, which create an ELF file based on a YAML description, and vice versa. The first addition needs to be done in the <strong class="source-inline">ScalarEnumerationTraits&lt;ELFYAML::ELF_EM&gt;::enumeration()</strong> method, which lists all the values for the <span class="No-Break">ELF architectures:</span><pre class="source-code">&#13;
  ECase(EM_88K);</pre></li>				<li>Likewise, in the <strong class="source-inline">ScalarEnumerationTraits&lt;ELFYAML::ELF_REL&gt;::enumeration()</strong> method, you need to include the definitions of the <span class="No-Break">relocations again:</span><pre class="source-code">&#13;
  case ELF::EM_88K:&#13;
#include "llvm/BinaryFormat/ELFRelocs/M88k.def"&#13;
    break;</pre></li>			</ol>&#13;
			<p>At this point, we have completed the support of the m88k architecture in the ELF file format. You can use the <strong class="source-inline">llvm-readobj</strong> tool to inspect an ELF object file, for example, created by a cross-compiler on OpenBSD. Likewise, you can create an ELF object file for the m88k architecture with the <span class="No-Break"><strong class="source-inline">yaml2obj</strong></span><span class="No-Break"> tool.</span></p>&#13;
			<p class="callout-heading">Is adding support for an object file format mandatory?</p>&#13;
			<p class="callout">Integrating support for an architecture into the ELF file format implementation requires only a couple <a id="_idIndexMarker698"/>of lines of code. If the architecture for which you are creating an LLVM backend uses the ELF format, then you should take this route. On the other hand, adding support for a completely new binary file format is a complicated task. If this is required, then an often-used approach is to only output assembler files and use an external assembler to create <span class="No-Break">object files.</span></p>&#13;
			<p>With these additions, the LLVM implementation of the ELF file format now supports the M88k architecture. In the next section, we create the target description for the M88k architecture, which describes the instructions, the registers, and many more details of <span class="No-Break">the architecture.</span></p>&#13;
			<h1 id="_idParaDest-175"><a id="_idTextAnchor182"/>Creating the target description</h1>&#13;
			<p>The <strong class="bold">target description</strong> is the heart of a backend implementation. It is written in the TableGen language and defines the basic properties of an architecture, such as the registers and <a id="_idIndexMarker699"/>the instruction formats and patterns for instruction selection. If you are not familiar with the TableGen language, then we recommend reading <a href="B19561_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><em class="italic">, The TableGen Language</em>, first. The base definitions are in the <strong class="source-inline">llvm/include/llvm/Target/Target.td</strong> file, which can be found online at <a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td</a>. This file is heavily commented on and is a useful source of information about the use of <span class="No-Break">the definitions.</span></p>&#13;
			<p>In an ideal world, we would generate the whole backend from the target description. This goal has <a id="_idIndexMarker700"/>not yet been reached, and therefore, we will need to extend the generated code later. Because of its size, the target description is split into several files. The top-level file will be <strong class="source-inline">M88k.td</strong>, inside the <strong class="source-inline">llvm/lib/Target/M88k</strong> directory, which also includes the other files. Let’s have a look at some files, beginning with the <span class="No-Break">register definition.</span></p>&#13;
			<h2 id="_idParaDest-176"><a id="_idTextAnchor183"/>Adding the register definition</h2>&#13;
			<p>A CPU architecture <a id="_idIndexMarker701"/>usually defines a set of registers. The characteristics of these registers can vary. Some architectures allow access to sub-registers. For example, the x86 architecture has special register names to access only a part of a register value. Other architectures do not implement this. In addition to general-purpose, floating-point, and vector registers, an architecture may have special registers for status codes or configuration of floating-point operations. We need to define all this information for LLVM. The register definitions are stored in the <strong class="source-inline">M88kRegisterInfo.td</strong> file, also found within the <span class="No-Break"><strong class="source-inline">llvm/lib/Target/M88k</strong></span><span class="No-Break"> directory.</span></p>&#13;
			<p>The M88k architecture defines general-purpose registers, extended registers for floating-point operations, and control registers. To keep the example small, we only define the general-purpose registers. We begin by defining a super-class for the registers. A register has a name and an encoding. The name is used in the textual representation of an instruction. Similarly, the encoding is used as part of the binary representation <a id="_idIndexMarker702"/>of an instruction. The architecture defines 32 registers and the encoding for registers therefore uses 5 bits, so we limit the field holding the encoding. We also define that all the generated C++ code should live in the <span class="No-Break"><strong class="source-inline">M88k</strong></span><span class="No-Break"> namespace:</span></p>&#13;
			<pre class="source-code">&#13;
class M88kReg&lt;bits&lt;5&gt; Enc, string n&gt; : Register&lt;n&gt; {&#13;
  let HWEncoding{15-5} = 0;&#13;
  let HWEncoding{4-0} = Enc;&#13;
  let Namespace = "M88k";&#13;
}</pre>			<p>Next, we can define all 32 general-purpose registers. The <strong class="source-inline">r0</strong> register is special because it always returns the constant <strong class="source-inline">0</strong> when read, so we set the <strong class="source-inline">isConstant</strong> flag to <strong class="source-inline">true</strong> for <span class="No-Break">that register:</span></p>&#13;
			<pre class="source-code">&#13;
foreach I = 0-31 in {&#13;
  let isConstant = !eq(I, 0) in&#13;
    def R#I : M88kReg&lt;I, "r"#I&gt;;&#13;
}</pre>			<p>For the register allocator, the single registers need to be grouped into register classes. The sequence order of the registers defines the allocation order. The register allocator also needs other information about the registers such as, for example, the value types, which can be stored in a register, the spill size of a register in bits, and the required alignment in memory. Instead of using the <strong class="source-inline">RegisterClass</strong> base class directly, we create a new <strong class="source-inline">M88kRegisterClass</strong> class. This allows us to change the parameter list to our needs. It also avoids the repetition of the C++ namespace name used for the generated code, which is the first argument for the <span class="No-Break"><strong class="source-inline">RegisterClass</strong></span><span class="No-Break"> class:</span></p>&#13;
			<pre class="source-code">&#13;
class M88kRegisterClass&lt;list&lt;ValueType&gt; types, int size,&#13;
                        int alignment, dag regList,&#13;
                        int copycost = 1&gt;&#13;
  : RegisterClass&lt;"M88k", types, alignment, regList&gt; {&#13;
      let Size = size;&#13;
      let CopyCost = copycost;&#13;
}</pre>			<p>In addition, we define a class for register operands. Operands describe the input and output of an instruction. They are used during assembling and disassembling of an instruction, and also in the patterns used by the instruction selection phase. Using our own class, we can <a id="_idIndexMarker703"/>give the generated function used to decode a register operand a name that conforms to the LLVM <span class="No-Break">coding guidelines:</span></p>&#13;
			<pre class="source-code">&#13;
class M88kRegisterOperand&lt;RegisterClass RC&gt;&#13;
    : RegisterOperand&lt;RC&gt; {&#13;
  let DecoderMethod = "decode"#RC#"RegisterClass";&#13;
}</pre>			<p>Based on these definitions, we now define the general-purpose registers. Please note that a general-purpose register of the m88k architecture is 32-bits wide and can hold integer and floating-point values. To avoid writing all register names, we use the <strong class="source-inline">sequence</strong> generator, which generates a list of strings based on the <span class="No-Break">template string:</span></p>&#13;
			<pre class="source-code">&#13;
def GPR : M88kRegisterClass&lt;[i32, f32], 32, 32,&#13;
                            (add (sequence "R%u", 0, 31))&gt;;</pre>			<p>Likewise, we define the register operand. The <strong class="source-inline">r0</strong> register is special because it contains the constant <strong class="source-inline">0</strong>. This fact can be used by the global instruction selection framework, and therefore, we attach this information to the <span class="No-Break">register operand:</span></p>&#13;
			<pre class="source-code">&#13;
def GPROpnd : M88kRegisterOperand&lt;GPR&gt; {&#13;
  let GIZeroRegister = R0;&#13;
}</pre>			<p>There is an extension to the m88k architecture that defines an extended register file for floating-point values only. You would define those registers in the same way as the <span class="No-Break">general-purpose registers.</span></p>&#13;
			<p>The general-purpose registers are also used in pairs, mainly for 64-bit floating point operations, and we need to model them. We use the <strong class="source-inline">sub_hi</strong> and <strong class="source-inline">sub_lo</strong> sub-register indices to <a id="_idIndexMarker704"/>describe the high 32 bits and the low 32 bits. We also need to set the C++ namespace for the <span class="No-Break">generated code:</span></p>&#13;
			<pre class="source-code">&#13;
let Namespace = "M88k" in {&#13;
  def sub_hi : SubRegIndex&lt;32, 0&gt;;&#13;
  def sub_lo : SubRegIndex&lt;32, 32&gt;;&#13;
}</pre>			<p>The register pairs are then defined using the <strong class="source-inline">RegisterTuples</strong> class. The class takes a list of sub-register indices as the first argument and a list of registers as the second argument. We only need even/odd numbered pairs, and we achieve this with the optional fourth parameter of sequence, which is the stride to use when generating <span class="No-Break">the sequence:</span></p>&#13;
			<pre class="source-code">&#13;
def GRPair : RegisterTuples&lt;[sub_hi, sub_lo],&#13;
                          [(add (sequence "R%u", 0, 30, 2)),&#13;
                           (add (sequence "R%u", 1, 31, 2))]&gt;;</pre>			<p>To use the register pairs, we define a register class and a <span class="No-Break">register operand:</span></p>&#13;
			<pre class="source-code">&#13;
def GPR64 : M88kRegisterClass&lt;[i64, f64], 64, 32,&#13;
                              (add GRPair), /*copycost=*/ 2&gt;;&#13;
def GPR64Opnd : M88kRegisterOperand&lt;GPR64&gt;;</pre>			<p>Please note that we set the <strong class="source-inline">copycost</strong> parameter to <strong class="source-inline">2</strong> because we need two instructions instead of one to copy a register pair to another <span class="No-Break">register pair.</span></p>&#13;
			<p>This finishes our definition of the registers. In the next section, we will define the <span class="No-Break">instruction formats.</span></p>&#13;
			<h2 id="_idParaDest-177"><a id="_idTextAnchor184"/>Defining the instruction formats and the instruction information</h2>&#13;
			<p>An instruction is defined using the TableGen <strong class="source-inline">Instruction</strong> class. Defining an instruction <a id="_idIndexMarker705"/>is a complex task because we have to consider many details. An instruction has a textual representation used by <a id="_idIndexMarker706"/>the assembler and the disassembler. It has a name, for example, <strong class="source-inline">and</strong>, and it may have operands. The assembler transforms the textual representation into a binary format, therefore, we must define the layout of that format. For instruction selection, we need to attach a pattern to the instruction. To manage this complexity, we define a class hierarchy. The base classes will describe the various instruction formats and are stored in the <strong class="source-inline">M88kIntrFormats.td</strong> file. The instructions themselves and other definitions required for the instruction selection are stored in the <span class="No-Break"><strong class="source-inline">M88kInstrInfo.td</strong></span><span class="No-Break"> file.</span></p>&#13;
			<p>Let’s begin with defining a class for the instructions of the m88k architecture called <strong class="source-inline">M88kInst</strong>. We derive this class from the predefined <strong class="source-inline">Instruction</strong> class. Our new class has a couple of parameters. The <strong class="source-inline">outs</strong> and <strong class="source-inline">ins</strong> parameters describe the output and input operands as a list, using the special <strong class="source-inline">dag</strong> type. The textual representation of the instruction is split into the mnemonic given in the <strong class="source-inline">asm</strong> parameter, and the operands. Last, the <strong class="source-inline">pattern</strong> parameter can hold a pattern used for <span class="No-Break">instruction selection.</span></p>&#13;
			<p>We also need to define two <span class="No-Break">new fields:</span></p>&#13;
			<ul>&#13;
				<li>The <strong class="source-inline">Inst</strong> field is used to hold the bit pattern of the instruction. Because the size of an instruction depends on the platform, this field cannot be predefined. All instructions of the m88k architecture are 32-bit wide, and so this field has the <span class="No-Break"><strong class="source-inline">bits&lt;32&gt;</strong></span><span class="No-Break"> type.</span></li>&#13;
				<li>The other field is called <strong class="source-inline">SoftFail</strong> and has the same type as <strong class="source-inline">Inst</strong>. It holds a bit mask used with an instruction for which the actual encoding can differ from the bits in the <strong class="source-inline">Inst</strong> field and still be valid. The only platform that requires this is ARM, so we can simply set this field <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
			<p>The other fields are defined in the superclass, and we only set the value. Simple computations <a id="_idIndexMarker707"/>are possible in the TableGen language, and we use this when we create the value for the <strong class="source-inline">AsmString</strong> field, which holds <a id="_idIndexMarker708"/>the full assembler representation. If the <strong class="source-inline">operands</strong> operand string is empty, then the <strong class="source-inline">AsmString</strong> field will just have the value of the <strong class="source-inline">asm</strong> parameter, otherwise, it will be the concatenation of both strings, with a space <span class="No-Break">between them:</span></p>&#13;
			<pre class="source-code">&#13;
class InstM88k&lt;dag outs, dag ins, string asm, string operands,&#13;
               list&lt;dag&gt; pattern = []&gt;&#13;
  : Instruction {&#13;
  bits&lt;32&gt; Inst;&#13;
  bits&lt;32&gt; SoftFail = 0;&#13;
  let Namespace = "M88k";&#13;
  let Size = 4;&#13;
  dag OutOperandList = outs;&#13;
  dag InOperandList = ins;&#13;
  let AsmString = !if(!eq(operands, ""), asm,&#13;
                      !strconcat(asm, " ", operands));&#13;
  let Pattern = pattern;&#13;
  let DecoderNamespace = "M88k";&#13;
}</pre>			<p>For the instruction encoding, the manufacturer usually groups instructions together, and the instructions of one group have a similar encoding. We can use those groups to systematically create classes defining the instruction formats. For example, all logical operations of the m88k architecture encode the destination register in the bits from 21 to 25 and the first source register in the bits from 16 to 20. Please note the implementation pattern here: we declare the <strong class="source-inline">rd</strong> and <strong class="source-inline">rs1</strong> fields for the values, and we assign those values to the correct bit positions of the <strong class="source-inline">Inst</strong> field, which we defined previously in <span class="No-Break">the superclass:</span></p>&#13;
			<pre class="source-code">&#13;
class F_L&lt;dag outs, dag ins, string asm, string operands,&#13;
          list&lt;dag&gt; pattern = []&gt;&#13;
   : InstM88k&lt;outs, ins, asm, operands, pattern&gt; {&#13;
  bits&lt;5&gt;  rd;&#13;
  bits&lt;5&gt;  rs1;&#13;
  let Inst{25-21} = rd;&#13;
  let Inst{20-16} = rs1;&#13;
}</pre>			<p>There are <a id="_idIndexMarker709"/>several groups of logical <a id="_idIndexMarker710"/>operations based on this format. One of <a id="_idIndexMarker711"/>them is the group of instructions using three registers, which is called <strong class="bold">triadic addressing mode</strong> in <span class="No-Break">the manual:</span></p>&#13;
			<pre class="source-code">&#13;
class F_LR&lt;bits&lt;5&gt; func, bits&lt;1&gt; comp, string asm,&#13;
           list&lt;dag&gt; pattern = []&gt;&#13;
   : F_L&lt;(outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),&#13;
         !if(comp, !strconcat(asm, ".c"), asm),&#13;
         "$rd, $rs1, $rs2", pattern&gt; {&#13;
  bits&lt;5&gt;  rs2;&#13;
  let Inst{31-26} = 0b111101;&#13;
  let Inst{15-11} = func;&#13;
  let Inst{10}    = comp;&#13;
  let Inst{9-5}   = 0b00000;&#13;
  let Inst{4-0}   = rs2;&#13;
}</pre>			<p>Let’s examine the functionality provided by this class in more detail. The <strong class="source-inline">func</strong> parameter specifies the operation. As a special feature, the second operand can be complemented before the operation, which is indicated by setting the <strong class="bold">flag</strong> comp to <strong class="source-inline">1</strong>. The mnemonic is given in the <strong class="source-inline">asm</strong> parameter, and an instruction selection pattern can <span class="No-Break">be passed.</span></p>&#13;
			<p>With initializing the superclass, we can give more information. The full assembler text template for the <strong class="source-inline">and</strong> instruction is <strong class="source-inline">and $rd, $rs1, $rs2</strong>. The operand string is fixed for all instructions of this group, so we can define it here. The mnemonic is given by the user of this class, but we can concatenate the <strong class="source-inline">.c</strong> suffix here, which denotes that the second <a id="_idIndexMarker712"/>operand should be complemented first. And last, we can define the output and input operands. These operands <a id="_idIndexMarker713"/>are expressed as <strong class="bold">directed acyclic graphs</strong> or <strong class="bold">dag</strong> for short. A dag has an operation and a list of arguments. An argument <a id="_idIndexMarker714"/>can also be a dag, which allows the construction of complex graphs. For example, the output operand is <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">outs GPROpnd:$rd)</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The <strong class="source-inline">outs</strong> operation denotes this dag as the output operand list. The only argument, <strong class="source-inline">GPROpnd:$rd</strong>, consists of a type and a name. It connects several pieces we have already seen. The type is <strong class="source-inline">GPROnd</strong>, which is the name of the register operand we have defined in the previous section. The name <strong class="source-inline">$rd</strong> refers to the destination register. We used this name in the operand string earlier, and also as a field name in the <strong class="source-inline">F_L</strong> superclass. The input operands are defined similarly. The rest of the class initializes the other bits of the <strong class="source-inline">Inst</strong> field. Please take the time and check that all 32 bits are indeed <span class="No-Break">now assigned.</span></p>&#13;
			<p>We put the final instruction definition in the <strong class="source-inline">M88kInstrInfo.td</strong> file. Since we have two variants of each logical instruction, we use a multiclass to define both instructions at once. We also define here the pattern for the instruction selection as a directed acyclic graph. The operation in the pattern is <strong class="source-inline">set</strong>, and the first argument is the destination register. The second argument is a nested graph, which is the actual pattern. Once again, the name of the operation is the first <strong class="source-inline">OpNode</strong> element. LLVM has many predefined operations, which you find in the <strong class="source-inline">llvm/include/llvm/Target/TargetSelectionDAG.td</strong> file (<a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td</a>). For example, there is the <strong class="source-inline">and</strong> operation, which denotes a bitwise AND operation. The arguments are the two source registers, <strong class="source-inline">$rs1</strong> and <strong class="source-inline">$rs2</strong>.You read this pattern roughly as follows: if the input to the instruction selection contains an OpNode operation using two registers, then assign the result of this operation to the <strong class="source-inline">$rd</strong> register and generate this instruction. Utilizing the graph structure, you can define more complex patterns. For example, the second pattern integrates the complement into the pattern using the <span class="No-Break"><strong class="source-inline">not</strong></span><span class="No-Break"> operand.</span></p>&#13;
			<p>A small detail <a id="_idIndexMarker715"/>to point out is that the <a id="_idIndexMarker716"/>logical operations are commutative. This can be helpful for the instruction selection, so we set the <strong class="source-inline">isCommutable</strong> flag to <strong class="source-inline">1</strong> for <span class="No-Break">those instructions:</span></p>&#13;
			<pre class="source-code">&#13;
multiclass Logic&lt;bits&lt;5&gt; Fun, string OpcStr, SDNode OpNode&gt; {&#13;
  let isCommutable = 1 in&#13;
    def rr : F_LR&lt;Fun, /*comp=*/0b0, OpcStr,&#13;
                  [(set i32:$rd,&#13;
                   (OpNode GPROpnd:$rs1, GPROpnd:$rs2))]&gt;;&#13;
  def rrc : F_LR&lt;Fun, /*comp=*/0b1, OpcStr,&#13;
                 [(set i32:$rd,&#13;
                 (OpNode GPROpnd:$rs1, (not GPROpnd:$rs2)))]&gt;;&#13;
}</pre>			<p>And finally, we define the records for <span class="No-Break">the instructions:</span></p>&#13;
			<pre class="source-code">&#13;
defm AND : Logic&lt;0b01000, "and", and&gt;;&#13;
defm XOR : Logic&lt;0b01010, "xor", xor&gt;;&#13;
defm OR  : Logic&lt;0b01011, "or", or&gt;;</pre>			<p>The first parameter is the bit pattern for the function, the second is the mnemonic, and the third parameter is the dag operation used in <span class="No-Break">the pattern.</span></p>&#13;
			<p>To fully understand the class hierarchy, revisit the class definitions. The guiding design principle is to avoid the repetition of information. For example, the <strong class="source-inline">0b01000</strong> function bit pattern is used exactly once. Without the <strong class="source-inline">Logic</strong> multiclass you would need to type this bit pattern twice and repeat the patterns several times, which <span class="No-Break">is error-prone.</span></p>&#13;
			<p>Please also note that it is good to establish a naming scheme for the instructions. For example, the record for the <strong class="source-inline">and</strong> instruction is named <strong class="source-inline">ANDrr</strong>, while the variant with the complemented <a id="_idIndexMarker717"/>register is named <strong class="source-inline">ANDrrc</strong>. Those <a id="_idIndexMarker718"/>names end up in the generated C++ source code, and using a naming scheme helps to understand to which assembler instruction the <span class="No-Break">name refers.</span></p>&#13;
			<p>Up to now, we modeled the register file of the m88k architecture and defined a couple of instructions. In the next section, we will create the <span class="No-Break">top-level file.</span></p>&#13;
			<h2 id="_idParaDest-178"><a id="_idTextAnchor185"/>Creating the top-level file for the target description</h2>&#13;
			<p>So far, we created the <strong class="source-inline">M88kRegisterInfo.td</strong>, <strong class="source-inline">M88kInstrFormats.td</strong>, and <strong class="source-inline">M88kInstrInfo.td</strong> <a id="_idIndexMarker719"/>files. The target description is a single file, called <strong class="source-inline">M88k.td</strong>. This file includes the LLVM definitions first, and the files that we have implemented <span class="No-Break">follow afterwards.:</span></p>&#13;
			<pre class="source-code">&#13;
include "llvm/Target/Target.td"&#13;
include "M88kRegisterInfo.td"&#13;
include "M88kInstrFormats.td"&#13;
include "M88kInstrInfo.td"</pre>			<p>We will extend this <strong class="source-inline">include</strong> section later when we add more <span class="No-Break">backend functionality.</span></p>&#13;
			<p>The top-level file also defines some global instances. The first record named <strong class="source-inline">M88kInstrInfo</strong> holds the information about <span class="No-Break">all instructions:</span></p>&#13;
			<pre class="source-code">&#13;
def M88kInstrInfo : InstrInfo;</pre>			<p>We call the assembler class <strong class="source-inline">M88kAsmParser</strong>. To enable TableGen to identify hardcoded registers, we specify that register names are prefixed with a percent sign, and we need to define an assembler parser variant to <span class="No-Break">specify this:</span></p>&#13;
			<pre class="source-code">&#13;
def M88kAsmParser : AsmParser;&#13;
def M88kAsmParserVariant : AsmParserVariant {&#13;
  let RegisterPrefix = "%";&#13;
}</pre>			<p>And last, we <a id="_idIndexMarker720"/>need to define <span class="No-Break">the target:</span></p>&#13;
			<pre class="source-code">&#13;
def M88k : Target {&#13;
  let InstructionSet = M88kInstrInfo;&#13;
  let AssemblyParsers  = [M88kAsmParser];&#13;
  let AssemblyParserVariants = [M88kAsmParserVariant];&#13;
}</pre>			<p>We now have defined enough of the target so that we can code the first utility. In the next section, we add the M88k backend <span class="No-Break">to LLVM.</span></p>&#13;
			<h1 id="_idParaDest-179"><a id="_idTextAnchor186"/>Adding the M88k backend to LLVM</h1>&#13;
			<p>We have not yet discussed where to place the target description files. Each backend in LLVM has <a id="_idIndexMarker721"/>a subdirectory in <strong class="source-inline">llvm/lib/Target</strong>. We create the <strong class="source-inline">M88k</strong> directory here and copy the target description files <span class="No-Break">into it.</span></p>&#13;
			<p>Of course, just adding the TableGen files is not enough. LLVM uses a registry to look up instances <a id="_idIndexMarker722"/>of a target implementation, and it expects certain global functions to register those instances. And since some parts are generated, we can already provide <span class="No-Break">an implementation.</span></p>&#13;
			<p>All information about a target, like the target triple and factory function for the target machine, assembler, disassembler, and so on, are stored in an instance of the <strong class="source-inline">Target</strong> class. Each target holds a static instance of this class, and this instance is registered in the <span class="No-Break">central registry:</span></p>&#13;
			<ol>&#13;
				<li>The implementation is in the <strong class="source-inline">M88kTargetInfo.cpp</strong> file in the <strong class="source-inline">TargetInfo</strong> subdirectory in our target. The single instance of the <strong class="source-inline">Target</strong> class is held inside the <span class="No-Break"><strong class="source-inline">getTheM88kTarget()</strong></span><span class="No-Break"> function:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
Target &amp;llvm::getTheM88kTarget() {&#13;
  static Target TheM88kTarget;&#13;
  return TheM88kTarget;&#13;
}</pre></li>				<li>LLVM requires that each target provides a <strong class="source-inline">LLVMInitialize&lt;Target Name&gt;TargetInfo()</strong> function to register the target instance. That function must have <a id="_idIndexMarker723"/>a C linkage because it is also used in the LLVM <span class="No-Break">C API:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTargetInfo() {&#13;
    RegisterTarget&lt;Triple::m88k, /*HasJIT=*/false&gt; X(&#13;
      getTheM88kTarget(), "m88k", "M88k", "M88k");&#13;
}</pre></li>				<li>We also <a id="_idIndexMarker724"/>need to create an <strong class="source-inline">M88kTargetInfo.h</strong> header file in the same directory, which just contains a <span class="No-Break">single declaration:</span><pre class="source-code">&#13;
namespace llvm {&#13;
class Target;&#13;
Target &amp;getTheM88kTarget();&#13;
}</pre></li>				<li>And last, we add a <strong class="source-inline">CMakeLists.txt</strong> file <span class="No-Break">for building:</span><pre class="source-code">&#13;
add_llvm_component_library(LLVMM88kInfo&#13;
  M88kTargetInfo.cpp&#13;
  LINK_COMPONENTS  Support&#13;
  ADD_TO_COMPONENT M88k)</pre></li>			</ol>&#13;
			<p>Next, we partially <a id="_idIndexMarker725"/>populate the target instance with the information used at the <strong class="bold">machine-code </strong>(<strong class="bold">MC</strong>) level. Let’s <span class="No-Break">get started:</span></p>&#13;
			<ol>&#13;
				<li>The implementation is in the <strong class="source-inline">M88kMCTargetDesc.cpp</strong> file in the <strong class="source-inline">MCTargetDesc</strong> subdirectory. TableGen turns the target description we created in the previous section into C++ source code fragments. Here, we include the parts for the register information, the instruction information, and the <span class="No-Break">sub-target information:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
#define GET_INSTRINFO_MC_DESC&#13;
#include "M88kGenInstrInfo.inc"&#13;
#define GET_SUBTARGETINFO_MC_DESC&#13;
#include "M88kGenSubtargetInfo.inc"&#13;
#define GET_REGINFO_MC_DESC&#13;
#include "M88kGenRegisterInfo.inc"</pre></li>				<li>The target <a id="_idIndexMarker726"/>registry expects a factory method for <a id="_idIndexMarker727"/>each of the classes here. Let’s begin with the instruction information. We allocate an instance of the <strong class="source-inline">MCInstrInfo</strong> class, and call the <strong class="source-inline">InitM88kMCInstrInfo()</strong> generated function to populate <span class="No-Break">the object:</span><pre class="source-code">&#13;
static MCInstrInfo *createM88kMCInstrInfo() {&#13;
    MCInstrInfo *X = new MCInstrInfo();&#13;
    InitM88kMCInstrInfo(X);&#13;
    return X;&#13;
}</pre></li>				<li>Next, we allocate an object of the <strong class="source-inline">MCRegisterInfo</strong> class and call a generated function to populate it. The additional <strong class="source-inline">M88k::R1</strong> parameter value tells LLVM that the <strong class="source-inline">r1</strong> register holds the <span class="No-Break">return address:</span><pre class="source-code">&#13;
static MCRegisterInfo *&#13;
createM88kMCRegisterInfo(const Triple &amp;TT) {&#13;
    MCRegisterInfo *X = new MCRegisterInfo();&#13;
    InitM88kMCRegisterInfo(X, M88k::R1);&#13;
    return X;&#13;
}</pre></li>				<li>And last, we need <a id="_idIndexMarker728"/>a factory method for the sub-target <a id="_idIndexMarker729"/>information. This method takes a target triple, a CPU name, and a feature string as parameters, and forwards them to the <span class="No-Break">generated method:</span><pre class="source-code">&#13;
static MCSubtargetInfo *&#13;
createM88kMCSubtargetInfo(const Triple &amp;TT,&#13;
                          StringRef CPU, StringRef FS) {&#13;
  return createM88kMCSubtargetInfoImpl(TT, CPU,&#13;
                                       /*TuneCPU*/ CPU,&#13;
                                       FS);&#13;
}</pre></li>				<li>Having the factory methods defined, we can now register them. Similar to the target registration, LLVM expects a global function called <span class="No-Break"><strong class="source-inline">LLVMInitialize&lt;Target Name&gt;TargetMC()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTargetMC() {&#13;
  TargetRegistry::RegisterMCInstrInfo(&#13;
      getTheM88kTarget(), createM88kMCInstrInfo);&#13;
  TargetRegistry::RegisterMCRegInfo(&#13;
      getTheM88kTarget(), createM88kMCRegisterInfo);&#13;
  TargetRegistry::RegisterMCSubtargetInfo(&#13;
      getTheM88kTarget(), createM88kMCSubtargetInfo);&#13;
}</pre></li>				<li>The <strong class="source-inline">M88kMCTargetDesc.h</strong> header <a id="_idIndexMarker730"/>file just makes <a id="_idIndexMarker731"/>some generated <span class="No-Break">code available:</span><pre class="source-code">&#13;
#define GET_REGINFO_ENUM&#13;
#include "M88kGenRegisterInfo.inc"&#13;
#define GET_INSTRINFO_ENUM&#13;
#include "M88kGenInstrInfo.inc"&#13;
#define GET_SUBTARGETINFO_ENUM&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>			</ol>&#13;
			<p>The implementation is almost done. To prevent a linker error, we need to provide another function, which registers a factory method for an object of the <strong class="source-inline">TargetMachine</strong> class. This class is required for code generation, and we implement it in <a href="B19561_12.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><em class="italic">, Instruction Selection</em>, up next. Here, we just define an empty function in the <span class="No-Break"><strong class="source-inline">M88kTargetMachine.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
#include "TargetInfo/M88kTargetInfo.h"&#13;
#include "llvm/MC/TargetRegistry.h"&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTarget() {&#13;
  // TODO Register the target machine. See chapter 12.&#13;
}</pre>			<p>This concludes <a id="_idIndexMarker732"/>our first implementation. However, LLVM does <a id="_idIndexMarker733"/>not yet know about our new backend. To integrate it, open the <strong class="source-inline">llvm/CMakeLists.txt</strong> file, locate the section defining all the experimental targets, and add the M88k target to <span class="No-Break">the list:</span></p>&#13;
			<pre class="source-code">&#13;
set(LLVM_ALL_EXPERIMENTAL_TARGETS ARC … <strong class="bold">M88k  </strong>…)</pre>			<p>Assuming the LLVM source code with our new backend is in the directory, you can configure the build by typing <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ mkdir build&#13;
$ cd build&#13;
$ cmake -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k \&#13;
  ../llvm-m88k/llvm&#13;
…&#13;
-- Targeting M88k&#13;
…</pre>			<p>After building LLVM, you can verify that the tools already know about our <span class="No-Break">new target:</span></p>&#13;
			<pre class="console">&#13;
$ bin/llc –version&#13;
LLVM (http://llvm.org/):&#13;
  LLVM version 17.0.2&#13;
  Registered Targets:&#13;
    m88k     - M88k</pre>			<p>The journey to get to this point was difficult, so take a moment <span class="No-Break">to celebrate!</span></p>&#13;
			<p class="callout-heading">Fixing a possible compile error</p>&#13;
			<p class="callout">There is a small oversight in LLVM 17.0.2, which causes a compile error. In one place in the code, the TableGen emitter for the sub-target information uses the removed value <strong class="source-inline">llvm::None</strong> instead of <strong class="source-inline">std:: nullopt</strong>, causing an error while compiling <strong class="source-inline">M88kMCTargetDesc.cpp</strong>. The easiest way to fix this problem is to cherry-pick the fix from the LLVM 18 development branch: <strong class="source-inline">git cherry-pick -</strong><span class="No-Break"><strong class="source-inline">x a587f429</strong></span><span class="No-Break">.</span></p>&#13;
			<p>In the <a id="_idIndexMarker734"/>next section, we implement the assembler parser, which will <a id="_idIndexMarker735"/>give us the first working <span class="No-Break">LLVM tool.</span></p>&#13;
			<h1 id="_idParaDest-180"><a id="_idTextAnchor187"/>Implementing the assembler parser</h1>&#13;
			<p>The assembler parser is easy to implement, since LLVM provides a framework for it, and large parts are generated from the <span class="No-Break">target description.</span></p>&#13;
			<p>The <strong class="source-inline">ParseInstruction()</strong> method in <a id="_idIndexMarker736"/>our class is called when the framework detects that an instruction needs to be parsed. That method parses in input via the provided lexer and constructs a so-called operand vector. An operand can <a id="_idIndexMarker737"/>be a token such as an instruction mnemonic, a register name, or an immediate, or it can be category-specific to the target. For example, two operands are constructed from the <strong class="source-inline">jmp %r2</strong> input: a token operand for the mnemonic, and a <span class="No-Break">register operand.</span></p>&#13;
			<p>Then a generated matcher tries to match the operand vector against the instructions. If a match is found, then an instance of the <strong class="source-inline">MCInst</strong> class is created, which holds the parsed instruction. Otherwise, an error message is emitted. The advantage of this approach is that it automatically derives the matcher from the target description, without needing to handle all <span class="No-Break">syntactical quirks.</span></p>&#13;
			<p>However, we need to add a couple more support classes to make the assembler parser work. These additional classes are all stored in the <span class="No-Break"><strong class="source-inline">MCTargetDesc</strong></span><span class="No-Break"> directory.</span></p>&#13;
			<h3>Implementing the MCAsmInfo support class for the M88k Target</h3>&#13;
			<p>Within <a id="_idIndexMarker738"/>this section, we <a id="_idIndexMarker739"/>explore <a id="_idIndexMarker740"/>implementing the first required class for the configuration of the assembler parser: the <span class="No-Break"><strong class="source-inline">MCAsmInfo</strong></span><span class="No-Break"> class:</span></p>&#13;
			<ol>&#13;
				<li>We need to set some customization parameters for the assembler parser. The <strong class="source-inline">MCAsmInfo</strong> base class (<a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h</a>) contains the common parameters. In addition, a subclass is created for each supported object file format; for example, the <strong class="source-inline">MCAsmInfoELF</strong> class (<a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h">https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h</a>). The reasoning behind it is that the system assemblers on systems using the same object file format <a id="_idIndexMarker741"/>share common characteristics because they must support similar features. Our <a id="_idIndexMarker742"/>target operating system is OpenBSD, and it uses the ELF file format, so we derive <a id="_idIndexMarker743"/>our own <strong class="source-inline">M88kMCAsmInfo</strong> class from the <strong class="source-inline">MCAsmInfoELF</strong> class. The declaration in the <strong class="source-inline">M88kMCAsmInfo.h</strong> file is <span class="No-Break">as follows:</span><pre class="source-code">&#13;
namespace llvm {&#13;
class Triple;&#13;
class M88kMCAsmInfo : public MCAsmInfoELF {&#13;
public:&#13;
  explicit M88kMCAsmInfo(const Triple &amp;TT);&#13;
};</pre></li>				<li>The implementation in the <strong class="source-inline">M88kMCAsmInfo.cpp</strong> file only sets a couple of default values. Two crucial settings at present are the system using big-endian mode and employing the <strong class="source-inline">|</strong> symbol for comments. The other settings are for code <span class="No-Break">generation later:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
M88kMCAsmInfo::M88kMCAsmInfo(const Triple &amp;TT) {&#13;
  IsLittleEndian = false;&#13;
  UseDotAlignForAlignment = true;&#13;
  MinInstAlignment = 4;&#13;
  CommentString = "|"; // # as comment delimiter is only&#13;
                       // allowed at first column&#13;
  ZeroDirective = "\t.space\t";&#13;
  Data64bitsDirective = "\t.quad\t";&#13;
  UsesELFSectionDirectiveForBSS = true;&#13;
  SupportsDebugInformation = false;&#13;
  ExceptionsType = ExceptionHandling::SjLj;&#13;
}</pre></li>			</ol>&#13;
			<p>Now <a id="_idIndexMarker744"/>we have completed the implementation for the <strong class="source-inline">MCAsmInfo</strong> class. The next class we will learn to implement helps us create a binary representation of the instructions <span class="No-Break">within LLVM.</span></p>&#13;
			<h3>Implementing the MCCodeEmitter support class for the M88k Target</h3>&#13;
			<p>Internally in LLVM, an instruction is represented by an instance of the <strong class="source-inline">MCInst</strong> class. An instruction <a id="_idIndexMarker745"/>can be emitted <a id="_idIndexMarker746"/>as an assembler <a id="_idIndexMarker747"/>text or in binary into an object file. The <strong class="source-inline">M88kMCCodeEmitter</strong> class creates the binary representation of an instruction, while the <strong class="source-inline">M88kInstPrinter</strong> class emits the textual representation <span class="No-Break">of it.</span></p>&#13;
			<p>First, we will implement the <strong class="source-inline">M88kMCCodeEmitter</strong> class, which is stored in the <span class="No-Break"><strong class="source-inline">M88kMCCodeEmitter.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>Most of the class is generated by TableGen. Therefore, we only need to add some boilerplate code. Note that there is no corresponding header file; the prototype of the factory function will be added to the <strong class="source-inline">M88kMCTargetDesc.h</strong> file. It begins with setting up a statistic counter for the number of <span class="No-Break">emitted instructions:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
#define DEBUG_TYPE "mccodeemitter"&#13;
STATISTIC(MCNumEmitted,&#13;
          "Number of MC instructions emitted");</pre></li>				<li>The <strong class="source-inline">M88kMCCodeEmitter</strong> class lives in an anonymous namespace. We only need <a id="_idIndexMarker748"/>to implement the <strong class="source-inline">encodeInstruction()</strong> method, which is declared <a id="_idIndexMarker749"/>in the base <a id="_idIndexMarker750"/>class, and the <strong class="source-inline">getMachineOpValue()</strong> helper method. The other <strong class="source-inline">getBinaryCodeForInstr()</strong> method is generated by TableGen from the <span class="No-Break">target description:</span><pre class="source-code">&#13;
namespace {&#13;
class M88kMCCodeEmitter : public MCCodeEmitter {&#13;
  const MCInstrInfo &amp;MCII;&#13;
  MCContext &amp;Ctx;&#13;
public:&#13;
  M88kMCCodeEmitter(const MCInstrInfo &amp;MCII,&#13;
                    MCContext &amp;Ctx)&#13;
      : MCII(MCII), Ctx(Ctx) {}&#13;
  ~M88kMCCodeEmitter() override = default;&#13;
  void encodeInstruction(&#13;
      const MCInst &amp;MI, raw_ostream &amp;OS,&#13;
      SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
      const MCSubtargetInfo &amp;STI) const override;&#13;
  uint64_t getBinaryCodeForInstr(&#13;
      const MCInst &amp;MI,&#13;
      SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
      const MCSubtargetInfo &amp;STI) const;&#13;
  unsigned&#13;
  getMachineOpValue(const MCInst &amp;MI,&#13;
                    const MCOperand &amp;MO,&#13;
                    SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
                    const MCSubtargetInfo &amp;STI) const;&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>The <strong class="source-inline">encodeInstruction()</strong> method just looks up the binary representation of <a id="_idIndexMarker751"/>the instruction, increments the statistic counter, and writes the bytes out <a id="_idIndexMarker752"/>in big-endian <a id="_idIndexMarker753"/>format. Remember that the instructions have a fixed size of 4 bytes, therefore we use the <strong class="source-inline">uint32_t</strong> type on the <span class="No-Break">endian stream:</span><pre class="source-code">&#13;
void M88kMCCodeEmitter::encodeInstruction(&#13;
    const MCInst &amp;MI, raw_ostream &amp;OS,&#13;
    SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
    const MCSubtargetInfo &amp;STI) const {&#13;
  uint64_t Bits =&#13;
      getBinaryCodeForInstr(MI, Fixups, STI);&#13;
  ++MCNumEmitted;&#13;
  support::endian::write&lt;uint32_t&gt;(OS, Bits,&#13;
                                   support::big);&#13;
}</pre></li>				<li>The task of the <strong class="source-inline">getMachineOpValue()</strong> method is to return the binary representation of operands. In the target description, we defined the bit ranges where <a id="_idIndexMarker754"/>the registers used are stored in an instruction. Here, we compute the value, which is stored in these places. The method is called from the generated code. We <a id="_idIndexMarker755"/>only support <a id="_idIndexMarker756"/>two cases. For a register, the encoding of the register, which we defined in the target description, is returned. For an immediate, the immediate value <span class="No-Break">is returned:</span><pre class="source-code">&#13;
unsigned M88kMCCodeEmitter::getMachineOpValue(&#13;
    const MCInst &amp;MI, const MCOperand &amp;MO,&#13;
    SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups,&#13;
    const MCSubtargetInfo &amp;STI) const {&#13;
  if (MO.isReg())&#13;
    return Ctx.getRegisterInfo()-&gt;getEncodingValue(&#13;
        MO.getReg());&#13;
  if (MO.isImm())&#13;
    return static_cast&lt;uint64_t&gt;(MO.getImm());&#13;
  return 0;&#13;
}</pre></li>				<li>And last, we <a id="_idIndexMarker757"/>include <a id="_idIndexMarker758"/>the generated <a id="_idIndexMarker759"/>file and create a factory method for <span class="No-Break">the class:</span><pre class="source-code">&#13;
#include "M88kGenMCCodeEmitter.inc"&#13;
MCCodeEmitter *&#13;
llvm::createM88kMCCodeEmitter(const MCInstrInfo &amp;MCII,&#13;
                              MCContext &amp;Ctx) {&#13;
  return new M88kMCCodeEmitter(MCII, Ctx);&#13;
}</pre></li>			</ol>&#13;
			<h3>Implementing the instruction printer support class for the M88k Target</h3>&#13;
			<p>The <strong class="source-inline">M88kInstPrinter</strong> class has a similar structure to the <strong class="source-inline">M88kMCCodeEmitter</strong> class. As mentioned previously, the <strong class="source-inline">InstPrinter</strong> class is responsible for emitting the textual <a id="_idIndexMarker760"/>representation of LLVM instructions. Most of the class is generated by TableGen, but we have <a id="_idIndexMarker761"/>to add <a id="_idIndexMarker762"/>support for printing the operands. The class is declared in the <strong class="source-inline">M88kInstPrinter.h</strong> header file. The implementation is in the <span class="No-Break"><strong class="source-inline">M88kInstPrinter.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>Let’s begin with the header file. After including the required header files and declaring the <strong class="source-inline">llvm</strong> namespace, two forward references are declared to reduce the number of <span class="No-Break">required includes:</span><pre class="source-code">&#13;
namespace llvm {&#13;
class MCAsmInfo;&#13;
class MCOperand;</pre></li>				<li>Besides <a id="_idIndexMarker763"/>the constructor, we <a id="_idIndexMarker764"/>only need to implement the <strong class="source-inline">printOperand()</strong> and <strong class="source-inline">printInst()</strong> methods. The other methods are generated <a id="_idIndexMarker765"/><span class="No-Break">by TableGen:</span><pre class="source-code">&#13;
class M88kInstPrinter : public MCInstPrinter {&#13;
public:&#13;
  M88kInstPrinter(const MCAsmInfo &amp;MAI,&#13;
                  const MCInstrInfo &amp;MII,&#13;
                  const MCRegisterInfo &amp;MRI)&#13;
      : MCInstPrinter(MAI, MII, MRI) {}&#13;
  std::pair&lt;const char *, uint64_t&gt;&#13;
  getMnemonic(const MCInst *MI) override;&#13;
  void printInstruction(const MCInst *MI,&#13;
                        uint64_t Address,&#13;
                        const MCSubtargetInfo &amp;STI,&#13;
                        raw_ostream &amp;O);&#13;
  static const char *getRegisterName(MCRegister RegNo);&#13;
  void printOperand(const MCInst *MI, int OpNum,&#13;
                    const MCSubtargetInfo &amp;STI,&#13;
                    raw_ostream &amp;O);&#13;
  void printInst(const MCInst *MI, uint64_t Address,&#13;
                 StringRef Annot,&#13;
                 const MCSubtargetInfo &amp;STI,&#13;
                 raw_ostream &amp;O) override;&#13;
};&#13;
} // end namespace llvm</pre></li>				<li>The <a id="_idIndexMarker766"/>implementation lives in the <strong class="source-inline">M88kInstPrint.cpp</strong> file. After including the required <a id="_idIndexMarker767"/>header file and using the <strong class="source-inline">llvm</strong> namespace, the file with the generated <a id="_idIndexMarker768"/>C++ fragments <span class="No-Break">is included:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
#define DEBUG_TYPE "asm-printer"&#13;
#include "M88kGenAsmWriter.inc"</pre></li>				<li>The <strong class="source-inline">printOperand()</strong> method checks the type of the operand and emits either a register name or an immediate. The register name is looked up with the <strong class="source-inline">getRegisterName()</strong> <span class="No-Break">generated method:</span><pre class="source-code">&#13;
void M88kInstPrinter::printOperand(&#13;
    const MCInst *MI, int OpNum,&#13;
    const MCSubtargetInfo &amp;STI, raw_ostream &amp;O) {&#13;
  const MCOperand &amp;MO = MI-&gt;getOperand(OpNum);&#13;
  if (MO.isReg()) {&#13;
    if (!MO.getReg())&#13;
      O &lt;&lt; '0';&#13;
    else&#13;
      O &lt;&lt; '%' &lt;&lt; getRegisterName(MO.getReg());&#13;
  } else if (MO.isImm())&#13;
    O &lt;&lt; MO.getImm();&#13;
  else&#13;
    llvm_unreachable("Invalid operand");&#13;
}</pre></li>				<li>The <strong class="source-inline">printInst()</strong> method only calls the <strong class="source-inline">printInstruction()</strong> generated method <a id="_idIndexMarker769"/>to print <a id="_idIndexMarker770"/>the instruction, and after that, the <strong class="source-inline">printAnnotation()</strong> method <a id="_idIndexMarker771"/>to print <span class="No-Break">possible annotations:</span><pre class="source-code">&#13;
void M88kInstPrinter::printInst(&#13;
    const MCInst *MI, uint64_t Address, StringRef Annot,&#13;
    const MCSubtargetInfo &amp;STI, raw_ostream &amp;O) {&#13;
  printInstruction(MI, Address, STI, O);&#13;
  printAnnotation(O, Annot);&#13;
}</pre></li>			</ol>&#13;
			<h3>Implementing M88k-specific target descriptions</h3>&#13;
			<p>In the <strong class="source-inline">M88kMCTargetDesc.cpp</strong> file, we need to make a couple <span class="No-Break">of additions:</span></p>&#13;
			<ol>&#13;
				<li>First, we <a id="_idIndexMarker772"/>need a new factory method for the <strong class="source-inline">MCInstPrinter</strong> class and the <span class="No-Break"><strong class="source-inline">MCAsmInfo</strong></span><span class="No-Break"> class:</span><pre class="source-code">&#13;
static MCInstPrinter *createM88kMCInstPrinter(&#13;
    const Triple &amp;T, unsigned SyntaxVariant,&#13;
    const MCAsmInfo &amp;MAI, const MCInstrInfo &amp;MII,&#13;
    const MCRegisterInfo &amp;MRI) {&#13;
  return new M88kInstPrinter(MAI, MII, MRI);&#13;
}&#13;
static MCAsmInfo *&#13;
createM88kMCAsmInfo(const MCRegisterInfo &amp;MRI,&#13;
                    const Triple &amp;TT,&#13;
                    const MCTargetOptions &amp;Options) {&#13;
  return new M88kMCAsmInfo(TT);&#13;
}</pre></li>				<li>Finally, within <a id="_idIndexMarker773"/>the <strong class="source-inline">LLVMInitializeM88kTargetMC()</strong> function, we need to add the registration of the <span class="No-Break">factory methods:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTargetMC() {&#13;
  // …&#13;
  TargetRegistry::RegisterMCAsmInfo(&#13;
      getTheM88kTarget(), createM88kMCAsmInfo);&#13;
  TargetRegistry::RegisterMCCodeEmitter(&#13;
      getTheM88kTarget(), createM88kMCCodeEmitter);&#13;
  TargetRegistry::RegisterMCInstPrinter(&#13;
      getTheM88kTarget(), createM88kMCInstPrinter);&#13;
}</pre></li>			</ol>&#13;
			<p>Now we have implemented all required support classes, and we can finally add the <span class="No-Break">assembler parser.</span></p>&#13;
			<h3>Creating the M88k assembler parser class</h3>&#13;
			<p>There is only an <strong class="source-inline">M88kAsmParser.cpp</strong> implementation file in the <strong class="source-inline">AsmParser</strong> directory. The <strong class="source-inline">M88kOperand</strong> class represents a parsed operand and is used by the generated <a id="_idIndexMarker774"/>source code and our assembler parser implementation in class <strong class="source-inline">M88kAssembler</strong>. Both classes are in an anonymous namespace, only <a id="_idIndexMarker775"/>the factory method is globally visible. Let’s take a look at the <strong class="source-inline">M88kOperand</strong> <span class="No-Break">class first:</span></p>&#13;
			<ol>&#13;
				<li>An operand can be a token, a register, or an immediate. We define the <strong class="source-inline">OperandKind</strong> enumeration to distinguish between these cases. The current kind is stored in the <strong class="source-inline">Kind</strong> member. We also store the start and the end location of the operand, which is needed to print the <span class="No-Break">error message:</span><pre class="source-code">&#13;
class M88kOperand : public MCParsedAsmOperand {&#13;
  enum OperandKind { OpKind_Token, OpKind_Reg,&#13;
                     OpKind_Imm };&#13;
  OperandKind Kind;&#13;
  SMLoc StartLoc, EndLoc;</pre></li>				<li>To store the value, we define a union. The token is stored as a <strong class="source-inline">StringRef</strong> and the register is identified by its number. The immediate is represented by the <span class="No-Break"><strong class="source-inline">MCExpr</strong></span><span class="No-Break"> class:</span><pre class="source-code">&#13;
   union {&#13;
    StringRef Token;&#13;
    unsigned RegNo;&#13;
    const MCExpr *Imm;&#13;
  };</pre></li>				<li>The constructor initializes all fields but the union. Furthermore, we define methods <a id="_idIndexMarker776"/>to return the value of the start and the <span class="No-Break">end locations:</span><pre class="source-code">&#13;
public:&#13;
  M88kOperand(OperandKind Kind, SMLoc StartLoc,&#13;
              SMLoc EndLoc)&#13;
      : Kind(Kind), StartLoc(StartLoc), EndLoc(EndLoc) {}&#13;
  SMLoc getStartLoc() const override { return StartLoc; }&#13;
  SMLoc getEndLoc() const override { return EndLoc; }</pre></li>				<li>For each <a id="_idIndexMarker777"/>operand type, we must define four methods. For a register, the methods are <strong class="source-inline">isReg()</strong> to check whether the operand is a register, <strong class="source-inline">getReg()</strong> to return the value, <strong class="source-inline">createReg()</strong> to create a register operand, and <strong class="source-inline">addRegOperands()</strong> to add an operant to an instruction. The latter function is called by the generated source code when an instruction is constructed. The methods for the token and the immediate <span class="No-Break">are similar:</span><pre class="source-code">&#13;
  bool isReg() const override {&#13;
    return Kind == OpKind_Reg;&#13;
  }&#13;
  unsigned getReg() const override { return RegNo; }&#13;
  static std::unique_ptr&lt;M88kOperand&gt;&#13;
  createReg(unsigned Num, SMLoc StartLoc,&#13;
            SMLoc EndLoc) {&#13;
    auto Op = std::make_unique&lt;M88kOperand&gt;(&#13;
        OpKind_Reg, StartLoc, EndLoc);&#13;
    Op-&gt;RegNo = Num;&#13;
    return Op;&#13;
  }&#13;
  void addRegOperands(MCInst &amp;Inst, unsigned N) const {&#13;
    assert(N == 1 &amp;&amp; "Invalid number of operands");&#13;
    Inst.addOperand(MCOperand::createReg(getReg()));&#13;
  }</pre></li>				<li>And last, the <a id="_idIndexMarker778"/>superclass defines an abstract <strong class="source-inline">print()</strong> virtual <a id="_idIndexMarker779"/>method that we need to implement. This is only used for <span class="No-Break">debugging purposes:</span><pre class="source-code">&#13;
  void print(raw_ostream &amp;OS) const override {&#13;
    switch (Kind) {&#13;
    case OpKind_Imm:&#13;
      OS &lt;&lt; "Imm: " &lt;&lt; getImm() &lt;&lt; "\n"; break;&#13;
    case OpKind_Token:&#13;
      OS &lt;&lt; "Token: " &lt;&lt; getToken() &lt;&lt; "\n"; break;&#13;
    case OpKind_Reg:&#13;
      OS &lt;&lt; "Reg: "&#13;
         &lt;&lt; M88kInstPrinter::getRegisterName(getReg())&#13;
         &lt;&lt; „\n"; break;&#13;
    }&#13;
  }&#13;
};</pre></li>			</ol>&#13;
			<p>Next, we <a id="_idIndexMarker780"/>declare the <strong class="source-inline">M88kAsmParser</strong> class. The <a id="_idIndexMarker781"/>anonymous name space will end after <span class="No-Break">the declaratio<a id="_idTextAnchor188"/>n:</span></p>&#13;
			<ol>&#13;
				<li>At the beginning of the class we include the <span class="No-Break">generated fragment:</span><pre class="source-code">&#13;
class M88kAsmParser : public MCTargetAsmParser {&#13;
#define GET_ASSEMBLER_HEADER&#13;
#include "M88kGenAsmMatcher.inc"</pre></li>				<li>Next, we define the required fields. We need a reference to the actual parser, which is of the <strong class="source-inline">MCAsmParser</strong> class, and a reference to the <span class="No-Break">sub-target information:</span><pre class="source-code">&#13;
  MCAsmParser &amp;Parser;&#13;
  const MCSubtargetInfo &amp;SubtargetInfo;</pre></li>				<li>To implement the assembler, we override a couple of methods defined in the <strong class="source-inline">MCTargetAsmParser</strong> superclass. The <strong class="source-inline">MatchAndEmitInstruction()</strong> method tries to match an instruction and emits the instruction represented by an instance of the <strong class="source-inline">MCInst</strong> class. Parsing an instruction is done in the <strong class="source-inline">ParseInstruction()</strong> method, while the <strong class="source-inline">parseRegister()</strong> and <strong class="source-inline">tryParseRegister()</strong> metho<a id="_idTextAnchor189"/>ds are responsible for parsing the register. The other methods are <span class="No-Break">required internally:</span><pre class="source-code">&#13;
  bool&#13;
  ParseInstruction(ParseInstructionInfo &amp;Info,&#13;
                   StringRef Name, SMLoc NameLoc,&#13;
                   OperandVector &amp;Operands) override;&#13;
  bool parseRegister(MCRegister &amp;RegNo, SMLoc &amp;StartLoc,&#13;
                     SMLoc &amp;EndLoc) override;&#13;
  OperandMatchResultTy&#13;
  tryParseRegister(MCRegister &amp;RegNo, SMLoc &amp;StartLoc,&#13;
                   SMLoc &amp;EndLoc) override;&#13;
  bool parseRegister(MCRegister &amp;RegNo, SMLoc &amp;StartLoc,&#13;
                     SMLoc &amp;EndLoc,&#13;
                     bool RestoreOnFailure);&#13;
  bool parseOperand(OperandVector &amp;Operands,&#13;
                    StringRef Mnemonic);&#13;
  bool MatchAndEmitInstruction(&#13;
      SMLoc IdLoc, unsigned &amp;Opcode,&#13;
      OperandVector &amp;Operands, MCStreamer &amp;Out,&#13;
      uint64_t &amp;ErrorInfo,&#13;
      bool MatchingInlineAsm) override;</pre></li>				<li>The <a id="_idIndexMarker782"/>constructor is defined inline. It mostly <a id="_idIndexMarker783"/>initializes all fields. This finishes the class declaration, after which the anonymous <span class="No-Break">namespace ends:</span><pre class="source-code">&#13;
public:&#13;
  M88kAsmParser(const MCSubtargetInfo &amp;STI,&#13;
                MCAsmParser &amp;Parser,&#13;
                const MCInstrInfo &amp;MII,&#13;
                const MCTargetOptions &amp;Options)&#13;
      : MCTargetAsmParser(Options, STI, MII),&#13;
        Parser(Parser), SubtargetInfo(STI) {&#13;
    setAvailableFeatures(ComputeAvailableFeatures(&#13;
        SubtargetInfo.getFeatureBits()));&#13;
  }&#13;
};</pre></li>				<li>Now <a id="_idIndexMarker784"/>we include the generated parts <a id="_idIndexMarker785"/>of <span class="No-Break">the assembler:</span><pre class="source-code">&#13;
#define GET_REGISTER_MATCHER&#13;
#define GET_MATCHER_IMPLEMENTATION&#13;
#include "M88kGenAsmMatcher.inc"</pre></li>				<li>The <strong class="source-inline">ParseInstruction()</strong> method is called whenever an instruction is expected. It must be able to parse all syntactical forms of an instruction. Currently, we only have instructions that take three operands, which are separated by a comma, so the parsing is simple. Be aware that the return value is <strong class="source-inline">true</strong> in case of <span class="No-Break">an error!</span><pre class="source-code">&#13;
bool M88kAsmParser::ParseInstruction(&#13;
    ParseInstructionInfo &amp;Info, StringRef Name,&#13;
    SMLoc NameLoc, OperandVector &amp;Operands) {&#13;
  Operands.push_back(&#13;
      M88kOperand::createToken(Name, NameLoc));&#13;
  if (getLexer().isNot(AsmToken::EndOfStatement)) {&#13;
    if (parseOperand(Operands, Name)) {&#13;
      return Error(getLexer().getLoc(),&#13;
                   "expected operand");&#13;
    }&#13;
    while (getLexer().is(AsmToken::Comma)) {&#13;
      Parser.Lex();&#13;
      if (parseOperand(Operands, Name)) {&#13;
        return Error(getLexer().getLoc(),&#13;
                     "expected operand");&#13;
      }&#13;
    }&#13;
    if (getLexer().isNot(AsmToken::EndOfStatement))&#13;
      return Error(getLexer().getLoc(),&#13;
                   "unexpected token in argument list");&#13;
  }&#13;
  Parser.Lex();&#13;
  return false;&#13;
}</pre></li>				<li>An operand <a id="_idIndexMarker786"/>can be a register or an immediate. We generalize a bit and parse an expression instead of just an integer. This <a id="_idIndexMarker787"/>helps later when adding address modes. When successful, the parsed operand is added to the <span class="No-Break"><strong class="source-inline">Operands</strong></span><span class="No-Break"> list:</span><pre class="source-code">&#13;
bool M88kAsmParser::parseOperand(&#13;
    OperandVector &amp;Operands, StringRef Mnemonic) {&#13;
  if (Parser.getTok().is(AsmToken::Percent)) {&#13;
    MCRegister RegNo;&#13;
    SMLoc StartLoc, EndLoc;&#13;
    if (parseRegister(RegNo, StartLoc, EndLoc,&#13;
                      /*RestoreOnFailure=*/false))&#13;
      return true;&#13;
    Operands.push_back(M88kOperand::createReg(&#13;
        RegNo, StartLoc, EndLoc));&#13;
    return false;&#13;
  }&#13;
  if (Parser.getTok().is(AsmToken::Integer)) {&#13;
    SMLoc StartLoc = Parser.getTok().getLoc();&#13;
    const MCExpr *Expr;&#13;
    if (Parser.parseExpression(Expr))&#13;
      return true;&#13;
    SMLoc EndLoc = Parser.getTok().getLoc();&#13;
    Operands.push_back(&#13;
        M88kOperand::createImm(Expr, StartLoc, EndLoc));&#13;
    return false;&#13;
  }&#13;
  return true;&#13;
}</pre></li>				<li>The <strong class="source-inline">parseRegister()</strong> method <a id="_idIndexMarker788"/>tries to <a id="_idIndexMarker789"/>parse a register. First, it checks for a percent sign <strong class="source-inline">%</strong>. If this is followed by an identifier which matches a register name, then we successfully parsed a register, and return <a id="_idIndexMarker790"/>the register number in the <strong class="source-inline">RegNo</strong> parameter. However, if we cannot identify a register, then we may need to undo <a id="_idIndexMarker791"/>the lexing if the <strong class="source-inline">RestoreOnFailure</strong> parameter <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
bool M88kAsmParser::parseRegister(&#13;
    MCRegister &amp;RegNo, SMLoc &amp;StartLoc, SMLoc &amp;EndLoc,&#13;
    bool RestoreOnFailure) {&#13;
  StartLoc = Parser.getTok().getLoc();&#13;
  if (Parser.getTok().isNot(AsmToken::Percent))&#13;
    return true;&#13;
  const AsmToken &amp;PercentTok = Parser.getTok();&#13;
  Parser.Lex();&#13;
  if (Parser.getTok().isNot(AsmToken::Identifier) ||&#13;
      (RegNo = MatchRegisterName(&#13;
           Parser.getTok().getIdentifier())) == 0) {&#13;
    if (RestoreOnFailure)&#13;
      Parser.getLexer().UnLex(PercentTok);&#13;
    return Error(StartLoc, "invalid register");&#13;
  }&#13;
  Parser.Lex();&#13;
  EndLoc = Parser.getTok().getLoc();&#13;
  return false;&#13;
}</pre></li>				<li>The <strong class="source-inline">parseRegister()</strong> and <strong class="source-inline">tryparseRegister()</strong> overridden methods are just <a id="_idIndexMarker792"/>wrappers around the previously <a id="_idIndexMarker793"/>defined method. The latter method also translates the boolean return value into an enumeration member of the <span class="No-Break"><strong class="source-inline">OperandMatchResultTy</strong></span><span class="No-Break"> enumeration:</span><pre class="source-code">&#13;
bool M88kAsmParser::parseRegister(MCRegister &amp;RegNo,&#13;
                                  SMLoc &amp;StartLoc,&#13;
                                  SMLoc &amp;EndL<a id="_idTextAnchor190"/>oc) {&#13;
  return parseRegister(RegNo, StartLoc, EndLoc,&#13;
                       /*RestoreOnFailure=*/false);&#13;
}&#13;
OperandMatchResultTy M88kAsmParser::tryParseRegister(&#13;
    MCRegister &amp;RegNo, SMLoc &amp;StartLoc, SMLoc &amp;EndLoc) {&#13;
  bool Result =&#13;
      parseRegister(RegNo, StartLoc, EndLoc,&#13;
                    /*RestoreOnFailure=*/true);&#13;
  bool PendingErrors = getParser().hasPendingError();&#13;
  getParser().clearPendingErrors();&#13;
  if (PendingErrors)&#13;
    return MatchOperand_ParseFail;&#13;
  if (Result)&#13;
    return MatchOperand_NoMatch;&#13;
  return MatchOperand_Success;&#13;
}</pre></li>				<li>Finally, the <strong class="source-inline">MatchAndEmitInstruction()</strong> method drives the parsing. Most <a id="_idIndexMarker794"/>of the method is dedicated to emitting <a id="_idIndexMarker795"/>error messages. To identify the instruction, the <strong class="source-inline">MatchInstructionImpl()</strong> generated method <span class="No-Break">is called:</span><pre class="source-code">&#13;
bool M88kAsmParser::MatchAndEmitInstruction(&#13;
    SMLoc IdLoc, unsigned &amp;Opcode,&#13;
    OperandVector &amp;Operands, MCStreamer &amp;Out,&#13;
    uint64_t &amp;ErrorInfo, bool MatchingInlineAsm) {&#13;
  MCInst Inst;&#13;
  SMLoc ErrorLoc;&#13;
  switch (MatchInstructionImpl(&#13;
      Operands, Inst, ErrorInfo, MatchingInlineAsm)) {&#13;
  case Match_Success:&#13;
    Out.emitInstruction(Inst, SubtargetInfo);&#13;
    Opcode = Inst.getOpcode();&#13;
    return false;&#13;
  case Match_MissingFeature:&#13;
    return Error(IdLoc, "Instruction use requires "&#13;
                        "option to be enabled");&#13;
  case Match_MnemonicFail:&#13;
    return Error(IdLoc,&#13;
                 "Unrecognized instruction mnemonic");&#13;
  case Match_InvalidOperand: {&#13;
    ErrorLoc = IdLoc;&#13;
    if (ErrorInfo != ~0U) {&#13;
      if (ErrorInfo &gt;= Operands.size())&#13;
        return Error(&#13;
            IdLoc, "Too few operands for instruction");&#13;
      ErrorLoc = ((M88kOperand &amp;)*Operands[ErrorInfo])&#13;
                     .getStartLoc();&#13;
      if (ErrorLoc == SMLoc())&#13;
        ErrorLoc = IdLoc;&#13;
    }&#13;
    return Error(ErrorLoc,&#13;
                 "Invalid operand for instruction");&#13;
  }&#13;
  default:&#13;
    break;&#13;
  }&#13;
  llvm_unreachable("Unknown match type detected!");&#13;
}</pre></li>				<li>And <a id="_idIndexMarker796"/>like some other classes, the assembler <a id="_idIndexMarker797"/>parser has its own <span class="No-Break">factory method:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kAsmParser() {&#13;
  RegisterMCAsmParser&lt;M88kAsmParser&gt; X(&#13;
      getTheM88kTarget());&#13;
}</pre></li>			</ol>&#13;
			<p>This finishes <a id="_idIndexMarker798"/>the implementation of the assembler parser. After building LLVM, we can use the <strong class="bold">llvm-mc</strong> machine code playground tool to assemble <span class="No-Break">an instruction:</span></p>&#13;
			<pre class="console">&#13;
$ echo 'and %r1,%r2,%r3' | \&#13;
  bin/llvm-mc --triple m88k-openbsd --show-encoding&#13;
        .text&#13;
        and %r1, %r2, %r3  | encoding: [0xf4,0x22,0x40,0x03]</pre>			<p>Note the <a id="_idIndexMarker799"/>use of the vertical bar <strong class="source-inline">|</strong> as the comments <a id="_idIndexMarker800"/>sign. This is the value we configured in the <span class="No-Break"><strong class="source-inline">M88kMCAsmInfo</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p class="callout-heading">Debugging the assembler matcher</p>&#13;
			<p class="callout">To debug the assembler matcher, you specify the <strong class="source-inline">--debug-only=asm-matcher</strong> command-line option. This helps with understanding why a parsed instruction fails to match the instructions defined in the <span class="No-Break">target description.</span></p>&#13;
			<p>In the next section, we will add a disassembler feature to the <span class="No-Break">llvm-mc tool.</span></p>&#13;
			<h1 id="_idParaDest-181"><a id="_idTextAnchor191"/>Creating the disassembler</h1>&#13;
			<p>Implementing the disassembler is optional. However, the implementation does not require too <a id="_idIndexMarker801"/>much effort, and generating the disassembler table may catch encoding errors that are not checked by the other generators. The disassembler lives in the <strong class="source-inline">M88kDisassembler.cpp</strong> file, found in the <span class="No-Break"><strong class="source-inline">Disassembler</strong></span><span class="No-Break"> subdirectory:</span></p>&#13;
			<ol>&#13;
				<li>We begin the implementation by defining a debug type and the <strong class="source-inline">DecodeStatus</strong> type. Both are required for the <span class="No-Break">generated code:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
#define DEBUG_TYPE "m88k-disassembler"&#13;
using DecodeStatus = MCDisassembler::DecodeStatus;</pre></li>				<li>The <strong class="source-inline">M88kDisassmbler</strong> class lives in an anonymous namespace. We only need to <a id="_idIndexMarker802"/>implement the <span class="No-Break"><strong class="source-inline">getInstruction()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
namespace {&#13;
class M88kDisassembler : public MCDisassembler {&#13;
public:&#13;
  M88kDisassembler(const MCSubtargetInfo &amp;STI,&#13;
                   MCContext &amp;Ctx)&#13;
      : MCDisassembler(STI, Ctx) {}&#13;
  ~M88kDisassembler() override = default;&#13;
  DecodeStatus&#13;
  getInstruction(MCInst &amp;instr, uint64_t &amp;Size,&#13;
                 ArrayRef&lt;uint8_t&gt; Bytes,&#13;
                 uint64_t Address,&#13;
                 raw_ostream &amp;CStream) const override;&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>We also need to provide a factory method, which will be registered in the <span class="No-Break">target registry:</span><pre class="source-code">&#13;
static MCDisassembler *&#13;
createM88kDisassembler(const Target &amp;T,&#13;
                       const MCSubtargetInfo &amp;STI,&#13;
                       MCContext &amp;Ctx) {&#13;
    return new M88kDisassembler(STI, Ctx);&#13;
}&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kDisassembler() {&#13;
  TargetRegistry::RegisterMCDisassembler(&#13;
      getTheM88kTarget(), createM88kDisassembler);&#13;
}</pre></li>				<li>The <strong class="source-inline">decodeGPRRegisterClass()</strong> function turns a register number into the register enum member generated by TableGen. This is the inverse operation of the <strong class="source-inline">M88kInstPrinter:: getMachineOpValue()</strong> method. Note that we specified <a id="_idIndexMarker803"/>the name of this function in the <strong class="source-inline">DecoderMethod</strong> field in the <span class="No-Break"><strong class="source-inline">M88kRegisterOperand</strong></span><span class="No-Break"> class:</span><pre class="source-code">&#13;
static const uint16_t GPRDecoderTable[] = {&#13;
    M88k::R0,  M88k::R1,  M88k::R2,  M88k::R3,&#13;
    // …&#13;
};&#13;
static DecodeStatus&#13;
decodeGPRRegisterClass(MCInst &amp;Inst, uint64_t RegNo,&#13;
                       uint64_t Address,&#13;
                       const void *Decoder) {&#13;
  if (RegNo &gt; 31)&#13;
    return MCDisassembler::Fail;&#13;
  unsigned Register = GPRDecoderTable[RegNo];&#13;
  Inst.addOperand(MCOperand::createReg(Register));&#13;
  return MCDisassembler::Success;&#13;
}</pre></li>				<li>Then we <a id="_idIndexMarker804"/>include the generated <span class="No-Break">disassembler tables:</span><pre class="source-code">&#13;
#include "M88kGenDisassemblerTables.inc"</pre></li>				<li>And finally, we decode the instruction. For this, we need to take the next four bytes of the <strong class="source-inline">Bytes</strong> array, create the instruction encoding from them, and call the <strong class="source-inline">decodeInstruction()</strong> <span class="No-Break">generated function:</span><pre class="source-code">&#13;
DecodeStatus M88kDisassembler::getInstruction(&#13;
    MCInst &amp;MI, uint64_t &amp;Size, ArrayRef&lt;uint8_t&gt; Bytes,&#13;
    uint64_t Address, raw_ostream &amp;CS) const {&#13;
  if (Bytes.size() &lt; 4) {&#13;
    Size = 0;&#13;
    return MCDisassembler::Fail;&#13;
  }&#13;
  Size = 4;&#13;
  uint32_t Inst = 0;&#13;
  for (uint32_t I = 0; I &lt; Size; ++I)&#13;
    Inst = (Inst &lt;&lt; 8) | Bytes[I];&#13;
  if (decodeInstruction(DecoderTableM88k32, MI, Inst,&#13;
                        Address, this, STI) !=&#13;
      MCDisassembler::Success) {&#13;
      return MCDisassembler::Fail;&#13;
  }&#13;
  return MCDisassembler::Success;&#13;
}</pre></li>			</ol>&#13;
			<p>That is all <a id="_idIndexMarker805"/>that needs to be done for the disassembler. After compiling LLVM, you can test the functionality again with the <span class="No-Break"><strong class="source-inline">llvm-mc</strong></span><span class="No-Break"> tool:</span></p>&#13;
			<pre class="console">&#13;
$ echo "0xf4,0x22,0x40,0x03" | \&#13;
  bin/llvm-mc --triple m88k-openbsd –disassemble&#13;
        .text&#13;
        and %r1, %r2, %r3</pre>			<p>Moreover, we can now use the <strong class="source-inline">llvm-objdump</strong> tool to disassemble ELF files. However, for it to be really useful, we would need to add all instructions to the <span class="No-Break">target description.</span></p>&#13;
			<h1 id="_idParaDest-182"><a id="_idTextAnchor192"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to create a LLVM target description, and you developed a simple backend target that supports the assembling and disassembling of instructions for LLVM. You first collected the required documentation and made LLVM aware of the new architecture by enhancing the <strong class="source-inline">Triple</strong> class. The documentation also includes the relocation definition for the ELF file format, and you added the support for them <span class="No-Break">to LLVM.</span></p>&#13;
			<p>You then learned about the register definition and the instruction definition in the target description and used the generated C++ source code to implement an instruction assembler <span class="No-Break">and disassembler.</span></p>&#13;
			<p>In the next chapter, we will add code generation to <span class="No-Break">the backend.</span></p>&#13;
		</div>&#13;
	</div></body></html>