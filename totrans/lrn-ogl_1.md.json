["```cpp\nbrew install glfw3 \n```", "```cpp\nbrew install glew  \n```", "```cpp\n#include <iostream> \n\n// GLEW \n#define GLEW_STATIC \n#include <GL/glew.h> \n\n// GLFW \n#include <GLFW/glfw3.h> \n```", "```cpp\n// Window dimensions \nconst GLint WIDTH = 800, HEIGHT = 600; \n```", "```cpp\n// The MAIN function, from here we start the application and run the game loop \nint main() \n{ \n   // Init GLFW \n   glfwInit(); \n```", "```cpp\n// Set all the required options for GLFW \nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); \nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); \n```", "```cpp\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); \n```", "```cpp\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); \n```", "```cpp\nglfwWindowHint(GLFW_RESIZABLE, GL_FALSE); \n```", "```cpp\n// Create a GLFWwindow object that we can use for GLFW's functions \nGLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, \"LearnOpenGL\", nullptr, nullptr); \n```", "```cpp\nint screenWidth, screenHeight; \n```", "```cpp\nglfwGetFramebufferSize( window, &screenWidth, &screenHeight ); \n```", "```cpp\nif (nullptr == window) \n{ \n       std::cout << \"Failed to create GLFW window\" << std::endl; \n       glfwTerminate(); \n\n       return EXIT_FAILURE; \n} \n```", "```cpp\nglfwMakeContextCurrent(window); \n```", "```cpp\n// Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions \n   glewExperimental = GL_TRUE; \n```", "```cpp\n// Initialize GLEW to setup the OpenGL Function pointers \nif (GLEW_OK != glewInit()) \n{ \n      std::cout << \"Failed to initialize GLEW\" << std::endl; \n      return EXIT_FAILURE; \n} \n```", "```cpp\n   // Define the viewport dimensions \n   glViewport(0, 0, screenWidth, screenHeight); \n```", "```cpp\n// Game loop \nwhile (!glfwWindowShouldClose(window)) \n{ \n       // Check if any events have been activiated (key pressed, \n       //mouse moved etc.) and call corresponding response functions \n       glfwPollEvents(); \n\n       // Render \n       // Clear the colorbuffer \n       glClearColor(0.2f, 0.3f, 0.3f, 1.0f); \n       glClear(GL_COLOR_BUFFER_BIT); \n\n      // Draw OpenGL \n\n      glfwSwapBuffers(window); \n} \n```", "```cpp\n// Terminate GLFW, clearing any resources allocated by GLFW. \nglfwTerminate(); \n\nreturn EXIT_SUCCESS; \n}    \n\n```", "```cpp\nbrew install sdl2\n```", "```cpp\n#include <iostream> \n```", "```cpp\n#include <SDL.h> \n\n#include <GL/glew.h> \n\n#include <SDL_opengl.h>  \n```", "```cpp\nconst GLint WIDTH = 800, HEIGHT = 600;\n```", "```cpp\nint main(int argc, char *argv[]) \n{ \n```", "```cpp\n   SDL_Init(SDL_INIT_EVERYTHING); \n```", "```cpp\nSDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK,     SDL_GL_CONTEXT_PROFILE_CORE); \n```", "```cpp\nSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3); SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3); SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8); \n```", "```cpp\nSDL_Window *window = SDL_CreateWindow(\"OpenGL\", 0, 0, WIDTH, HEIGHT, SDL_WINDOW_OPENGL); \n```", "```cpp\nSDL_GLContext context = SDL_GL_CreateContext(window); \n\n// Set this to true so GLEW knows to use a modern approach to\nretrieving function pointers and extensions \nglewExperimental = GL_TRUE; \n```", "```cpp\n// Initialize GLEW to setup the OpenGL Function pointers \nif (GLEW_OK != glewInit()) \n{ \n      std::cout << \"Failed to initialize GLEW\" << std::endl; \n      return EXIT_FAILURE; \n}  \n```", "```cpp\n// Define the viewport dimensions \nglViewport(0, 0, WIDTH, HEIGHT); \n```", "```cpp\nSDL_Event windowEvent; \n```", "```cpp\nwhile (true) \n{ \n      if (SDL_PollEvent(&windowEvent)) \n      { \n             if (windowEvent.type == SDL_QUIT) break; \n      } \n\n      // Clear the colorbuffer \n      glClearColor(0.2f, 0.3f, 0.3f, 1.0f); \n      glClear(GL_COLOR_BUFFER_BIT); \n\n      // draw OpenGL \n\n      SDL_GL_SwapWindow(window); \n} \n\n   SDL_GL_DeleteContext(context); \n   SDL_DestroyWindow(window); \n   SDL_Quit(); \n\n   return EXIT_SUCCESS; \n} \n```", "```cpp\n#include <iostream> \n```", "```cpp\n#include <GL/glew.h> \n\n#include <SFML/Window.hpp> \n\nconst GLint WIDTH = 800, HEIGHT = 600; \n```", "```cpp\nint main( ) \n{ \n   sf::ContextSettings settings; \n   settings.depthBits = 24; settings.stencilBits = 8; \n```", "```cpp\nsettings.majorVersion = 3; \nsettings.minorVersion = 3; \nsettings.attributeFlags = sf::ContextSettings::Core; \n```", "```cpp\nsf::Window window( sf::VideoMode( WIDTH, HEIGHT, 32 ), \"OpenGL     SFML\", sf::Style::Titlebar | sf::Style::Close, settings ); \n```", "```cpp\n   glewExperimental = GL_TRUE; \n\n   if ( GLEW_OK != glewInit( ) ) \n   { \n      std::cout << \"Failed to initialize GLEW\" << std::endl; \n\n      return EXIT_FAILURE; \n   } \n\n   bool running = true; \n```", "```cpp\n\nwhile ( running ) \n{ \n   sf::Event windowEvent; \n\n   while ( window.pollEvent( windowEvent ) ) \n   { \n      switch ( windowEvent.type ) \n      { \n      case sf::Event::Closed: \n         running = false; \n\n         break; \n      } \n  }  \n```", "```cpp\n\n      glClearColor( 0.2f, 0.3f, 0.3f, 1.0f ); \n      glClear( GL_COLOR_BUFFER_BIT ); \n\n      // draw OpenGL \n\n      window.display( ); \n   } \n\n   window.close( ); \n\n   return EXIT_SUCCESS; \n  }\n}   \n```"]