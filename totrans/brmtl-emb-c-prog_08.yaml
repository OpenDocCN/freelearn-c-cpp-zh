- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System Tick (SysTick) Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the **System Tick** (**SysTick**) timer,
    an important core peripheral in all Arm Cortex microcontrollers. We will begin
    by introducing the SysTick timer and discussing its most common use cases. Following
    this, we will explore the SysTick timer registers in detail. Finally, we will
    develop a driver for the SysTick timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the SysTick timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a driver for the SysTick timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the SysTick
    timer and be able to effectively implement and utilize it in your Arm Cortex-M
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the SysTick timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **System Tick** timer, commonly known as **SysTick**, is a fundamental component
    of all Arm Cortex microcontrollers. Regardless of the processor core—whether it’s
    Cortex-M0, Cortex-M1, or Cortex-M7—and the silicon manufacturer—be it STMicroelectronics,
    Texas Instruments, or any other—every Arm Cortex microcontroller includes a SysTick
    timer. In this section, we will learn about this essential peripheral and explore
    its registers in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the SysTick timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SysTick timer is a **24-bit down counter** integral to all Arm Cortex-M
    processors. It is designed to offer a configurable time base that can be used
    for various purposes, such as **task scheduling**, **system monitoring**, and
    **time tracking**. This timer provides us with a simple and efficient means of
    **generating periodic interrupts** and serves as a cornerstone for implementing
    system timing functions, including **operating system** (**OS**) tick generation
    for **real-time operating systems** (**RTOSs**). Using SysTick makes our code
    more portable since it is part of the core and not a vendor-specific peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features of the SysTick timer include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**24-bit Reloadable Counter**: The counter decrements from a specified value
    to zero, then reloads automatically to provide a continuous timing operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Core Integration**: Being part of the core, it requires minimal configuration
    and offers low-latency interrupt handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurable Clock Source**: SysTick can operate either from the core clock
    or an external reference clock, providing flexibility in timing accuracy and power
    consumption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupt Generation**: When the counter reaches zero, it can trigger an
    interrupt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SysTick timer typically serves three primary use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OS Tick Generation**: In an RTOS environment, SysTick is commonly used to
    generate the system tick interrupt, which drives the OS scheduler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Periodic Task Execution**: It can be used to trigger regular tasks, such
    as sensor sampling or communication checks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time Delay Functions**: SysTick can provide precise delays for various timing
    functions within the firmware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s explore the registers in the SysTick timer.
  prefs: []
  type: TYPE_NORMAL
- en: SysTick timer registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SysTick timer consists of four primary registers:'
  prefs: []
  type: TYPE_NORMAL
- en: SysTick Control and Status Register (`SYST_CSR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SysTick Reload Value Register (`SYST_RVR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SysTick Current Value Register (`SYST_CVR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SysTick Calibration Value Register (`SYST_CALIB`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s analyze them one by one, starting with the Control and Status Register.
  prefs: []
  type: TYPE_NORMAL
- en: The SysTick Control and Status Register (SYST_CSR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SYST_CSR` register controls the SysTick timer’s operation and provides
    status information. It has the following bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ENABLE (Bit 0)**: Enables or disables the SysTick counter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TICKINT (Bit 1)**: Enables or disables the SysTick interrupt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLKSOURCE (Bit 2)**: Selects the clock source (0 = external reference clock,
    1 = processor clock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COUNTFLAG (Bit 16)**: Indicates whether the counter has reached zero since
    the last read (1 = yes, 0 = no)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the structure of the SysTick Control and Status Register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The SysTick Control and Status Register](img/B21914_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The SysTick Control and Status Register'
  prefs: []
  type: TYPE_NORMAL
- en: The next register is the SysTick Reload Value Register (`SYST_RVR`).
  prefs: []
  type: TYPE_NORMAL
- en: The SysTick Reload Value Register (SYST_RVR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This register specifies the start value to load into the SysTick Current Value
    Register. It is crucial for setting the timer’s period and understanding its bit
    assignments and calculations is essential for effective SysTick configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bits [31:24] Reserved**: These bits are reserved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYST_CVR` register when the counter is enabled and when it reaches zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the structure of the SysTick Reload Value Register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: The SysTick Reload Value Register](img/B21914_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The SysTick Reload Value Register'
  prefs: []
  type: TYPE_NORMAL
- en: Since SysTick is a 24-bit timer, the `RELOAD` value can be any value in the
    range **0x00000001** to **0x00FFFFFF**.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the `RELOAD` value based on the desired timer period, we determine
    the number of clock cycles for the desired period, and then subtract 1 from this
    number to get the `RELOAD` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `RELOAD` value would be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the number of clock cycles in 1 ms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clock cycles = 16,000,000 cycles/second * 0.001 second =** **16,000 cycles**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: 1ms = 0.001 second'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Subtract 1 from the calculated number of clock cycles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**RELOAD = 16,000 - 1 = 15,999** since counting from 0 to 15,999 will give
    us 16000 ticks.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Meaning, to configure the SysTick timer for a 1 ms period with a 16 MHz clock,
    we would set the `RELOAD` value to `SYST_CVR`).
  prefs: []
  type: TYPE_NORMAL
- en: The SysTick Current Value Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SysTick Current Value Register (`SYST_CVR`) holds the current value of the
    SysTick counter. We can use this register to monitor the countdown process and
    to reset the counter when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bits [31:24] Reserved**: These bits are reserved and should not be modified.
    They must be written as zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COUNTFLAG` bit in the SysTick Control and Status Register (`SYST_CSR`). This
    is the SysTick Current Value Register:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.3: The SysTick Current Value Register](img/B21914_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: The SysTick Current Value Register'
  prefs: []
  type: TYPE_NORMAL
- en: The SysTick Calibration Value Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final register of the SysTick timer is the SysTick Calibration Value Register
    (`SYST_CALIB`). This register provides us with the calibration properties of the
    SysTick timer.
  prefs: []
  type: TYPE_NORMAL
- en: The names of these registers are slightly different in the STM32 header files.
    *Table 8.1* provides a clear correspondence between the register names used in
    the *Arm Generic User Guide* documentation and those in the STM32-specific header
    files. This correspondence will help us understand and reference them correctly
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Arm Generic** **User Guide** | **STM32** **Header File**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Control and Status | SYST_CSR | SysTick->CTRL |'
  prefs: []
  type: TYPE_TB
- en: '| Reload Value | SYST_RVR | SysTick->LOAD |'
  prefs: []
  type: TYPE_TB
- en: '| Current Value | SYST_CVR | SysTick->VAL |'
  prefs: []
  type: TYPE_TB
- en: '| Calibration Value | SYST_CALIB | SysTick->CALIB |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Correspondence of SysTick register names'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use the information we have learned to develop
    a driver for the SysTick timer.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a driver for the SysTick timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a driver for the SysTick timer to generate
    precise delays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by making a copy of our last project in our IDE, following the steps
    we learned in [*Chapter 7*](B21914_07.xhtml#_idTextAnchor217). Rename the copied
    project to `SysTick`. Next, create a new file named `systick.c` in the `Src` folder
    and another file named `systick.h` in the `Inc` folder, just like we did for the
    GPIO drivers in the previous lesson.
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate your `systick.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the header file inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This line includes the header file, `systick.h`, which in turn includes `stm32fxx.h`
    to provide access to the register definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define all the macros we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define CTRL_ENABLE (1U << 0)`: Macro to enable the SysTick timer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#define CTRL_CLKSRC (1U << 2)`: Macro to select the internal clock source
    for the SysTick timer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#define CTRL_COUNTFLAG (1U << 16)`: Macro to check the `COUNTFLAG` bit, which
    indicates when the timer has counted to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#define ONE_MSEC_LOAD 16000`: Macro to define the number of clock cycles in
    1 millisecond. This assumes the microcontroller’s clock frequency is 16 MHz. This
    is the default configuration of the NUCLEO-F411 development board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we move on to the function implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This line loads the SysTick timer with the number of clock cycles for 1 millisecond.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we clear the Current Value register with the following to reset the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we select the internal clock source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the SysTick timer, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we enter the loop that handles the delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This loop runs for the specified delay duration. Inside each iteration, it waits
    for the `COUNTFLAG` bit to be set, which indicates the timer has counted down
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we disable the SysTick timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! With these steps, we’ve successfully implemented a delay function
    using the SysTick timer.
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to populate the `systick.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Over here, the `#include <stdint.h>` directive is needed to ensure that we have
    access to standard integer type definitions provided by the C standard library.
    These definitions include fixed-width integer types such as `uint32_t`, `int32_t`,
    `uint16_t`, and so on, which are essential for writing portable and clear code,
    especially in embedded systems programming.
  prefs: []
  type: TYPE_NORMAL
- en: With the driver files complete, we are now ready to test inside `main.c`.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s enhance our `gpio.c` file by adding a new function that toggles
    the LED. This will simplify our code by allowing us to toggle the LED with a single
    function call instead of calling `led_on()` and `led_off()` separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function to your `gpio.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function toggles the state of the LED connected to pin PA5 by using the
    bitwise `XOR` operation on the **Output Data** **Register** (**ODR**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, declare this function in the `gpio.h` file by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update your `main.c` file as shown here to call the SysTick delay
    and LED toggle functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are **toggling the LED at a 500ms interval**. Build the
    project and run it on your development board. You should see the green LED blinking.
    To experiment further, you can modify the delay value and observe how the blinking
    rate of the LED changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the SysTick timer, a core peripheral of all Arm
    Cortex microcontrollers. We began with an introduction to the SysTick timer, discussing
    its significance and common applications, such as generating OS ticks in real-time
    operating systems, executing periodic tasks, and providing precise time delays.
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the SysTick timer’s registers in detail. These included the
    Control and Status Register (`SYST_CSR`), which manages the timer’s operation
    and status; the Reload Value Register (`SYST_RVR`), which sets the timer’s countdown
    period; the Current Value Register (`SYST_CVR`), which holds the current value
    of the countdown; and the Calibration Value Register (`SYST_CALIB`), which provides
    essential calibration properties for accurate timing. We also provided a comparison
    between the register names used in the Arm Generic User Guide and those in the
    STM32 header files to ensure clear correspondence for accurate coding.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter concluded with the development of a SysTick timer driver. We walked
    through the creation and implementation of the `systick_msec_delay` function,
    which introduces millisecond delays using the SysTick timer. To test the driver,
    we integrated it with GPIO functions to toggle our green LED, demonstrating how
    to achieve precise timing and control in embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall learn about another timer peripheral. Unlike the
    SysTick timer, the configuration of this timer peripheral is specific to STM32
    microcontrollers.
  prefs: []
  type: TYPE_NORMAL
