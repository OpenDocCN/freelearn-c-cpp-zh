<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor116"/>8</h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Using Clocks, Timers, and Signals in Linux</h1>
<p>In this chapter, we will commence by exploring the various timers available in the Linux environment. Subsequently, we will delve into the significance of the clock epoch and delve into the concept of UNIX time. Following this, we will unveil the methodology for employing POSIX in Linux to precisely measure time intervals. Transitioning further, we will uncover the realm of <code>std::chrono</code> and examine the capabilities that C++ offers for effective time-related operations. Our journey then progresses to a comprehensive examination of duration, timepoints, and clocks as<a id="_idIndexMarker696"/> delineated within the <code>std::chrono</code> framework. Venturing onward, we will acquaint ourselves with the diverse array of clocks at our disposal within <code>std::chrono</code>. As we navigate our path, we will take our initial steps into harnessing the calendar functionalities provided by <code>std::chrono</code>. In the final leg of our exploration, we will become familiar with time zones and refine our expertise in executing seamless time conversions using the powerful tools of <code>std::chrono</code>.</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>Exploring timers in Linux</li>
<li>Handling time in C++</li>
<li>Using clocks, timers, and ratios</li>
<li>Using calendar and time zone capabilities</li>
</ul>
<p>So, let’s get started!</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>Technical requirements</h1>
<p>All examples in this chapter have been tested in an environment with the following configuration:</p>
<ul>
<li>Linux Mint 21 Cinnamon edition.</li>
<li>GCC 13.2 with compiler flags: <code>-std=c++20</code>.</li>
<li>A stable internet connection.</li>
<li>Please make sure your environment is at least this recent. For all the examples, you can alternatively use <a href="https://godbolt.org/">https://godbolt.org/</a>.</li>
<li>All code examples in this chapter are available for download from <a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208</a>.</li>
</ul>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Handling time in Linux</h1>
<p>Timing is an<a id="_idIndexMarker697"/> essential aspect of any computer system, and Linux is no exception. In<a id="_idIndexMarker698"/> Linux, there are different types of timers available, each designed to handle specific tasks and requirements.</p>
<p>These timers <a id="_idIndexMarker699"/>can be <a id="_idIndexMarker700"/>used to measure the execution time of programs, schedule tasks, trigger events, and more. In this section, we’ll explore the different types of timers available in Linux and how to use them effectively.</p>
<p>Here are the different kinds of timers used in the Linux system:</p>
<ul>
<li><strong class="bold">System timers</strong>: The<a id="_idIndexMarker701"/> Linux kernel uses system timers to keep<a id="_idIndexMarker702"/> track of the time and schedule various tasks. System timers are used to measure the system uptime, delay, and timeouts. The most important system timer in Linux is the <em class="italic">Jiffies</em> timer, which increments by 1 with every tick of the system clock. The Jiffies timer is used to track the time elapsed since the system booted up, and it is frequently used by various kernel modules and drivers.</li>
<li><code>/dev/rtc</code> device file or the <code>hwclock</code> command-line tool. The RTC is used to synchronize the system time during startup and to maintain an accurate timestamp for system events.</li>
<li><strong class="bold">High-Resolution Timers (HRTs)</strong>: HRTs <a id="_idIndexMarker705"/>provide<a id="_idIndexMarker706"/> nanosecond-level resolution, which makes them suitable for real-time applications that require precise timing. HRTs can be used to measure the execution time of a code segment, schedule events with high accuracy, or drive high-speed hardware.</li>
<li><code>timer_create()</code>, <code>timer_settime()</code>, and <code>timer_delete()</code> system calls.</li>
<li><strong class="bold">Timer queues</strong>: Timer queues <a id="_idIndexMarker709"/>are a mechanism<a id="_idIndexMarker710"/> provided by the Linux kernel to schedule events and timeouts. Timer queues are implemented as a priority queue of events, where each event is associated with a timer. Timer queues can be used to schedule periodic tasks, implement timeouts, or trigger events at specific intervals. Timer queues are used extensively in various kernel modules and device drivers.</li>
</ul>
<p>But speaking about timers, we first need to understand what time means in computer systems. Let’s have a look.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Linux epoch</h2>
<p>In <a id="_idIndexMarker711"/>computing, an <em class="italic">epoch</em> refers <a id="_idIndexMarker712"/>to a specific point in time used as a reference for measuring time in a particular system or context. It serves as a starting point from which other time values are calculated or represented. In other words, this is the time from when the computer measures the system time.</p>
<p>The<a id="_idIndexMarker713"/> epoch is often defined as a specific point in time, typically represented as the number of seconds or milliseconds, or other time intervals even smaller than a millisecond elapsed since a particular epoch time. The choice of epoch varies depending <a id="_idIndexMarker714"/>on the system and context. For example, in UNIX-like systems, which Linux is, the epoch is defined as <em class="italic">January 1, 1970, at 00:00:00 UTC</em> (Coordinated Universal Time). This epoch time is often referred to as the <em class="italic">UNIX epoch</em> or <em class="italic">UNIX time</em>. The time values in UNIX-based systems are typically represented as the number of seconds elapsed since the UNIX epoch.</p>
<p>Now, having a better understanding of the UNIX epoch, let’s have a look at some examples of how to use these timers in practice.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Using timers in Linux</h2>
<p>Since we <a id="_idIndexMarker715"/>already know about the different types of timers available in Linux, let’s explore how to use them in our applications. We will look at an example that starts a POSIX timer and waits until it is signaled:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;csignal&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;atomic&gt;
static std::atomic_bool continue_execution{true};
int main() {
    struct sigaction sa{};
    sa.sa_handler = [](int signum) {
        // Timer triggered, stop the loop.
        std::cout &lt;&lt; "Timer expired. Stopping the
          task...\n";
        continue_execution = false;
    };
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGALRM, &amp;sa, nullptr);
    // Configure the timer to trigger every 1 seconds
    struct itimerval timer{
        .it_interval{.tv_sec{1}, .tv_usec{0}},
        .it_value{.tv_sec{1}, .tv_usec{0}}
    };
    // Start the timer
    setitimer(ITIMER_REAL, &amp;timer, nullptr);
    std::cout &lt;&lt; "Timer started. Waiting for timer
      expiration...\n";
    // Keep the program running to allow the timer to
      trigger
    while (continue_execution) {
        sleep(1);
    }
    return 0;
}</pre> <p>In this<a id="_idIndexMarker716"/> example, we define a lambda handler that will be called whenever the timer expires. Inside the handler, we print a message indicating that the timer has expired and set the exit condition of the busy loop.</p>
<p>We set up the signal handler using the <code>sigaction</code> function. Then, we configure the timer using the <code>it_interval</code> and <code>it_value</code> members of the <code>itimerval</code> structure. After configuring the timer, we start it by calling the <code>setitimer</code> POSIX function <a id="_idIndexMarker717"/>with the <code>ITIMER_REAL</code> option, which sets a real-time timer that sends <code>SIGALRM</code> signals when it expires. We enter a loop to keep the program running indefinitely. The <code>sleep(1)</code> call inside the loop ensures that the program does not exit immediately and allows the timer to trigger.</p>
<p>The output of the program is as follows:</p>
<pre class="console">
Program returned: 0
Timer started. Waiting for timer expiration...
Timer expired. Stopping the task...</pre> <p>Another common task in software development is measuring the execution time of a code segment. It can also be achieved by using the POSIX time capabilities. To measure the execution time of a code segment, we can use an HRT in POSIX.</p>
<p>To use an HRT in POSIX, we will use the <code>clock_gettime()</code> function along with the <code>CLOCK_MONOTONIC</code> clock ID. Here’s an example demonstrating the usage of HRTs in POSIX:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;ctime&gt;
static const auto LIMIT{10000};
void just_busy_wait_f() {
    for (auto i{0}; i &lt; LIMIT; ++i) {
        for (auto j{0}; j &lt; LIMIT; ++j);
    }
}
int main() {
    timespec start, end;
    // Start the timer
    clock_gettime(CLOCK_MONOTONIC, &amp;start);
    // Measured code segment
    just_busy_wait_f();
    // Stop the timer
    clock_gettime(CLOCK_MONOTONIC, &amp;end);
    // Calculate the elapsed time
    const auto elapsed{(end.tv_sec - start.tv_sec) +
      (end.tv_nsec - start.tv_nsec) / 1e9};
    std::cout &lt;&lt; "Elapsed time: " &lt;&lt; elapsed &lt;&lt; "
      seconds\n";
    return 0;
}</pre> <p>In this<a id="_idIndexMarker718"/> example, we declare two <code>timespec</code> structures, <code>start</code> and <code>end</code>, to hold the start and end timestamps of the timer. We use the <code>clock_gettime()</code> function to obtain the current time with a high-resolution clock.</p>
<p>We call <code>clock_gettime()</code> twice: once at the beginning of the task (to record the start time) and once at the end (to record the end time). The <code>CLOCK_MONOTONIC</code> clock ID is used, which represents a monotonic clock unaffected by system time adjustments.</p>
<p>After capturing the start and end timestamps, we calculate the elapsed time by subtracting the respective second and nanosecond components of the timestamps. The result is then printed as the elapsed time in seconds.</p>
<p>The example output in our test lab is as follows:</p>
<pre class="console">
Program returned: 0
Elapsed time: 0.169825 seconds</pre> <p>Keep in mind that in your environment, the result could be different.</p>
<p>Note that this example demonstrates one way to measure execution time using a timer. Depending on your requirements, you can choose different timer mechanisms.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>POSIX timer characteristics</h2>
<p>Let’s look at some of the<a id="_idIndexMarker719"/> characteristics that POSIX timers have:</p>
<ul>
<li><strong class="bold">Powerful and flexible</strong>: POSIX timers provide a rich set of features, including different timer types (for example, interval timers and one-shot timers), various clock sources, and precise control over timer behavior</li>
<li><strong class="bold">Low-level control</strong>: POSIX timers offer fine-grained control over timer settings, such as signal handling and timer expiration behavior</li>
<li><strong class="bold">Legacy support</strong>: POSIX timers are part of the POSIX API and have been available on UNIX-like systems for a long time, making them suitable if you need to maintain compatibility with legacy code or specific POSIX requirements</li>
<li><strong class="bold">Platform-specific</strong>: POSIX timers are not available on all platforms, so if portability is a concern, it is better to switch to a more suitable choice</li>
</ul>
<p>But what better alternative do we have in C++? We will see in the next section.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>Handling time in C++</h1>
<p>While <a id="_idIndexMarker720"/>POSIX timers have their own merits, in C++ there are libraries that provide higher-level and more portable solutions for timing and time-related operations.</p>
<p>One good<a id="_idIndexMarker721"/> example of such a library is <code>std::chrono</code>. This is a C++ library that provides a set of utilities for working with time-related operations and measurements. It is part of the Standard Library and is included in the <code>&lt;chrono&gt;</code> header. The <code>std::chrono</code> library provides a flexible and type-safe mechanism for representing and manipulating time durations, time points, clocks, and time-related operations. By using <code>std::chrono</code>, you will benefit from the standardization, type safety, flexibility, and integration that comes with the C++ Standard Library. Some of the advantages<a id="_idIndexMarker722"/> of <code>std::chrono</code> compared to the traditional POSIX approach are as follows:</p>
<ul>
<li><code>std::chrono</code> is part of the C++ Standard Library, making it a cross-platform solution that works consistently across different operating systems and compilers. POSIX, on the other hand, is specific to UNIX-like systems and may not be available or behave consistently on all platforms.</li>
<li><code>std::chrono</code> provides type-safe representations of time durations and points in time. It offers a rich set of duration and clock types that can be used together seamlessly, enabling safer and more expressive code. POSIX timers, while powerful, often rely on low-level types, such as the <code>timespec</code> struct, which can be error-prone and require manual conversions.</li>
<li><code>std::chrono</code> offers a flexible and expressive interface for time-related operations. It provides convenient ways to perform<a id="_idIndexMarker723"/> arithmetic operations on durations, convert between different time units, and format time values. POSIX timers, while suitable for specific timing requirements, lack the high-level abstractions and utilities provided by <code>std::chrono</code>.</li>
<li><code>std::chrono</code> seamlessly integrates with other parts of the C++ Standard Library. It can be used in conjunction with algorithms, containers, and concurrency facilities, allowing for more cohesive and efficient code. POSIX timers, being a lower-level interface, may require additional work to integrate with other C++ Standard Library components.</li>
<li><code>std::chrono</code> benefits from the advancements and features introduced in modern C++. It supports features such as user-defined literals, lambda functions, and type deduction, making it easier to write concise and expressive code. POSIX timers, being part of the POSIX API, may not fully leverage the modern C++ language features.</li>
</ul>
<p>The <code>&lt;chrono&gt;</code> library <a id="_idIndexMarker724"/>provides a comprehensive set of features for working with<a id="_idIndexMarker725"/> time-related operations, such as measuring time durations, representing points in time, and performing various time calculations and conversions. Here are some<a id="_idIndexMarker726"/> key components<a id="_idIndexMarker727"/> and<a id="_idIndexMarker728"/> features of <code>std::chrono</code>:</p>
<ul>
<li><code>&lt;chrono&gt;</code> defines<a id="_idIndexMarker729"/> several clock types that represent different sources of time and different epochs. <code>std::chrono::system_clock</code> represents the system-wide RTC, which is adjustable. <code>std::chrono::steady_clock</code> represents a steady monotonic clock unaffected by system time adjustments, and <code>std::chrono::high_resolution_clock</code> represents a clock with the highest available resolution (if supported by the system).</li>
<li><code>std::chrono::duration</code> template class represents a time interval, that is, a <a id="_idIndexMarker730"/>specified period of time The duration is the tick count using a specific unit of time; for example, a duration of five hours is five ticks of the unit <em class="italic">hour</em>. Different types of durations can be defined, from years to nanoseconds. Example durations include <code>std::chrono::seconds</code>, <code>std::chrono::milliseconds</code>, and <code>std::chrono::months</code>.</li>
<li><code>std::chrono::time_point</code> template class is parameterized by a clock and duration type.</li>
<li><code>std::chrono</code> allows for<a id="_idIndexMarker732"/> conversions between durations and <a id="_idIndexMarker733"/>time points, as well as arithmetic operations involving durations. It provides functions such as <code>std::chrono::duration_cast</code> to convert between <a id="_idIndexMarker734"/>different durations and <code>std::chrono::time_point_cast</code> to convert between different time points.</li>
<li><code>std::chrono</code> provides<a id="_idIndexMarker735"/> utilities for querying the current time, such as <code>std::chrono::system_clock::now()</code>, which returns the current system time point.</li>
<li><code>std::chrono</code> provides <a id="_idIndexMarker736"/>user-defined, time-related literals in the <code>std::literals::chrono_literals</code> namespace. They allow you to create <code>std::chrono::duration</code> objects using literals with time units. This makes the code more readable and convenient when dealing with time-related computations.</li>
<li><code>std::chrono</code> provides <a id="_idIndexMarker737"/>calendar capabilities, such as working with days, months, and years. It also provides notation for leap years and leap seconds.</li>
<li><code>std::chrono</code> provides <a id="_idIndexMarker738"/>information about different time zones across the globe depending on the geographical location.</li>
</ul>
<p>By using <code>std::chrono</code>, you <a id="_idIndexMarker739"/>can perform accurate and portable time <a id="_idIndexMarker740"/>measurements, handle timeouts, calculate time differences, and work with time-related operations in a type-safe manner.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a link to the <code>&lt;chrono&gt;</code> header in the C++ reference documentation: <a href="https://en.cppreference.com/w/cpp/header/chrono">https://en.cppreference.com/w/cpp/header/chrono</a>.</p>
<p>Here’s an example of <a id="_idIndexMarker741"/>how to use <code>std::chrono</code> to measure the execution time of a code snippet:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;chrono&gt;
using namespace std::chrono;
int main() {
    const auto start{steady_clock::now()}; // {1}
    just_busy_wait_f(); // {2}
    const auto end{steady_clock::now()}; // {3}
    const auto dur{duration_cast&lt;milliseconds&gt;(end -
      start)}; // {4}
    std::cout &lt;&lt; "Execution time: " &lt;&lt; dur.count() &lt;&lt; "
      milliseconds\n"; // {5}
    return 0;
}</pre> <p>In the <a id="_idIndexMarker742"/>preceding example, <code>std::chrono::steady_clock</code> is used to measure the execution time of<a id="_idIndexMarker743"/> the same function as from the previous example (see marker <code>{2}</code>). The <code>start</code> and <code>end</code> variables represent the <em class="italic">timepoints</em> taken before and after the code execution using the <code>now()</code> static function of <code>steady_clock</code> (see markers <code>{1}</code> and <code>{3}</code>). <code>std::chrono::duration_cast</code> is used to convert the calculated duration between <a id="_idIndexMarker744"/>the time points in milliseconds (see marker <code>{4}</code>).</p>
<p>The output of the program should be similar to this:</p>
<pre class="console">
Program returned: 0
Execution time: 179 milliseconds</pre> <p>As you can see, the <code>std::chrono::duration</code> class has a <code>count()</code> method, which returns the number of units in a specific duration; see marker <code>{5}</code>.</p>
<p>But let’s get deeper into how this really works.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Using clocks, timers, and ratios</h1>
<p>Before getting into<a id="_idIndexMarker745"/> more examples with clocks and timers, we first have to get a better understanding of how the chrono library <a id="_idIndexMarker746"/>defines a <em class="italic">duration</em>.</p>
<p>As we saw in the previous example, a duration is the distance between two points of time, called <em class="italic">timepoints</em>. In <a id="_idIndexMarker747"/>our previous example, these were the <code>start</code> and <code>end</code> timepoints.</p>
<div><div><img alt="Figure 8.1 – Timepoint and duration" height="228" src="img/Figure_8.1_B20833.jpg" width="577"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Timepoint and duration</p>
<p>The duration itself is a combination of the count of ticks and a fraction that represents the time in seconds from one tick to the next. The fraction is represented by the <code>std::ratio</code> class. Here<a id="_idIndexMarker748"/> are<a id="_idIndexMarker749"/> some examples:</p>
<pre class="source-code">
using namespace std::chrono;
constexpr std::chrono::duration&lt;int, std::ratio&lt;1&gt;&gt;
  six_minutes_1{360};
constexpr std::chrono::duration&lt;double, std::ratio&lt;3600&gt;&gt;
  six_minutes_2{0.1};
constexpr std::chrono::minutes six_minutes_3{6};
constexpr auto six_minutes_4{6min};
std::cout &lt;&lt; six_minutes_1 &lt;&lt; '\n';
std::cout &lt;&lt; six_minutes_2 &lt;&lt; '\n';
std::cout &lt;&lt; six_minutes_3 &lt;&lt; '\n';
std::cout &lt;&lt; six_minutes_4 &lt;&lt; '\n';
static_assert(six_minutes_1 == six_minutes_2);
static_assert(six_minutes_2 == six_minutes_3);
static_assert(six_minutes_3 == six_minutes_4);</pre> <p>In the preceding example, we have defined the<a id="_idIndexMarker750"/> duration of six minutes in several ways. In the <code>six_minutes_1</code> variable, we have specified this duration as a value of 360 seconds. The same duration can also be represented as 1/10 of an hour – the <code>six_minutes_2</code> variable. The last two durations – <code>six_minutes_3</code> and <code>six_minutes_4</code> – represent the same duration of six minutes but using the <code>std::chrono</code> predefined duration types and literals. Here is the output of the preceding code block:</p>
<pre class="console">
360s
0.1h
6min
6min</pre> <p>As you can see, <code>std::duration</code> also<a id="_idIndexMarker751"/> provides pretty formatting capabilities so that once the duration is passed to a string or stream operator, it will add the corresponding suffix so we can see the duration type.</p>
<p>In order to ensure that the preceding durations really correspond to six minutes, we have tested them against <code>static_assert</code>, which would fail the program if they don’t match.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a link to<a id="_idIndexMarker752"/> the <code>std::duration</code> class in the C++ reference documentation: <a href="https://en.cppreference.com/w/cpp/chrono/duration">https://en.cppreference.com/w/cpp/chrono/duration</a>.</p>
<p>Let’s go back to our previous example, slightly change it, and have a<a id="_idIndexMarker753"/> closer look at a <code>timepoint</code> object:</p>
<pre class="source-code">
using namespace std::chrono;
const time_point start{steady_clock::now()}; // {1}
const duration epoch_to_start{start.time_since_epoch()}; //
  {2}
std::cout &lt;&lt; "Time since clock epoch: " &lt;&lt; epoch_to_start
  &lt;&lt; '\n'; // {3}</pre> <p>As you can see, we <a id="_idIndexMarker754"/>again construct a <code>timepoint</code> object, <code>start</code>, in which we get the time at the moment of its instantiation from the <code>steady_clock</code> instance of the Linux system; see marker <code>{1}</code>. The <code>std::chrono::time_point</code> class stores a <code>std::chrono::duration</code> value, which actually indicates the time interval from the start of the clock’s epoch. In order to allow getting that value, the <code>std::chrono::duration</code> class exposes a method that returns the duration, <code>time_since_epoch()</code>, in nanoseconds; see marker <code>{2}</code>.</p>
<p>Here is the result of the preceding code executed in our test environment. Please keep in mind that if you execute this code, the result could be different:</p>
<pre class="console">
Time since clock epoch: 2080809926594ns</pre> <p>Having a time duration in nanoseconds could be inconvenient in some use cases, such as our example of calculating the time it takes for a code block to execute. However converting a duration from a higher-precision type into a lower-precision type results in a loss of precision. Therefore, if we need to see the duration in minutes then in nanoseconds, we can’t just do this:</p>
<pre class="source-code">
using namespace std::chrono;
const minutes
  dur_minutes{steady_clock::now().time_since_epoch()};</pre> <p>This is because the preceding code won’t compile. The reason behind this is that the <code>time_since_epoch()</code> method<a id="_idIndexMarker755"/> returns the duration with a precision of nanoseconds. If we store that data in minutes, we will certainly lose precision. In order to be sure that this won’t be done by mistake, the compiler stops us.</p>
<p>But how can we intentionally convert duration values from one precision into another? As we saw in the first example, we can use the <code>std::chrono::duration_cast</code> function provided by the library. It enables us to make conversions from a duration type with higher precision to a<a id="_idIndexMarker756"/> duration type with lower precision. Let’s rework the preceding example and see how this works:</p>
<pre class="source-code">
using namespace std::chrono;
auto dur_from_epoch{steady_clock::now()
  .time_since_epoch()}; // {1}
minutes dur_minutes{duration_cast&lt;minutes&gt;
  (dur_from_epoch)}; // {2}
std::cout &lt;&lt; "Duration in nanoseconds: " &lt;&lt; dur_from_epoch
  &lt;&lt; '\n'; //{3}
std::cout &lt;&lt; "Duration in minutes: " &lt;&lt; dur_minutes &lt;&lt;
  '\n'; //{4}</pre> <p>As you can see in marker <code>{1}</code>, we again get the duration in nanoseconds from the clock’s epoch. In marker <code>{2}</code>, we initialize another duration variable but this time in minutes. In order to do so, we use <code>std::chrono::duration_cast&lt;minutes&gt;</code>, which converts the value from the source resolution into the destination one and truncates it down to the closest integer value. In our test environment, the result of the preceding code block is as follows:</p>
<pre class="console">
Duration in nanoseconds: 35206835643934ns
Duration in minutes: 586min</pre> <p>We can see that the measured duration in nanoseconds is equivalent to about 586.78 minutes but it is truncated down to 586 minutes.</p>
<p>Of course, we could also need to round up rather than just truncate down values. Fortunately, the <code>chrono</code> library gives us this capability with the <code>std::chrono::round</code> method, which does exactly this. Here is an example:</p>
<pre class="source-code">
using namespace std::chrono;
seconds dur_sec_1{55s}; //{1}
seconds dur_sec_2{65s}; //{2}
minutes dur_min_1{round&lt;minutes&gt;(dur_sec_1)}; //{3}
minutes dur_min_2{round&lt;minutes&gt;(dur_sec_2)}; //{4}
std::cout &lt;&lt; "Rounding up to " &lt;&lt; dur_min_1 &lt;&lt; '\n';
std::cout &lt;&lt; "Rounding down to " &lt;&lt; dur_min_2 &lt;&lt; '\n';</pre> <p>In this example, we <a id="_idIndexMarker757"/>define two duration variables, <code>dur_sec_1</code> and <code>dur_sec_2</code>. <code>dur_sec_1</code> is initialized to 55 seconds (see marker <code>{1}</code>) and <code>dur_sec_2</code> is initialized to 65 seconds (see marker <code>{2}</code>). Then, using the <code>std::chrono::round</code> function, we initialize another two duration variables but this time with a resolution of minutes (see markers <code>{3}</code> and <code>{4}</code>). Both duration variables are rounded to one minute:</p>
<pre class="console">
Rounding up to 1min
Rounding down to 1min</pre> <p>The <code>chrono</code> library also supplies methods for <code>ceil</code> and <code>floor</code> durations. All of them can be found in the official documentation.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The documentation for <code>round</code>, <code>floor</code>, and <code>ceil</code> methods for duration values can be found at these links: <a href="https://en.cppreference.com/w/cpp/chrono/duration/round">https://en.cppreference.com/w/cpp/chrono/duration/round</a>, https://en.cppreference.com/w/cpp/chrono/duration/floor, and <a href="https://en.cppreference.com/w/cpp/chrono/duration/ceil">https://en.cppreference.com/w/cpp/chrono/duration/ceil</a>.</p>
<p>Since we have a better understanding of time operations, let’s have a closer look at the different types of clocks that <code>std::chrono</code> provides for us.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>More about clocks in C++20</h2>
<p>We<a id="_idIndexMarker758"/> already used <code>std::chrono::steady_clock</code> in our previous examples. This is just one of the predefined clocks<a id="_idIndexMarker759"/> in the C++ <code>chrono</code> library<a id="_idIndexMarker760"/> that you can use. <code>std::chrono::steady_clock</code>, as its name suggests, is a clock that is steady. This means that it is a monotonic clock in which time only moves forward, and its timepoint values are always increasing. It is suitable for use when we want to measure intervals of time. Its epoch can vary.</p>
<p>Another frequently used clock is <code>std::chrono::system_clock</code>. In Linux, it represents the time measured by the system. This means that it is not guaranteed to be monotonic, and it <a id="_idIndexMarker761"/>can be adjusted at any moment. In Linux, its epoch matches the UNIX epoch. Let’s see an example:</p>
<pre class="source-code">
using namespace std::chrono;
time_point&lt;system_clock&gt; systemClockEpoch;
std::cout &lt;&lt; std::format("system_clock epoch:
  {0:%F}T{0:%R%z}.", systemClockEpoch) &lt;&lt; '\n';</pre> <p>The preceding example prints the Linux system clock epoch, which corresponds to the UNIX epoch – <code>00:00:00: UTC</code> on <code>1 </code><code>January 1970</code>:</p>
<pre class="console">
system_clock epoch: 1970-01-01T00:00+0000.</pre> <p>Keep in mind that <code>std::chrono::system_clock</code> doesn’t take into <a id="_idIndexMarker762"/>account <em class="italic">leap seconds</em>, which <a id="_idIndexMarker763"/>can be added or subtracted from the measured time. In general, a leap second is a one-second adjustment of UTC, which <a id="_idIndexMarker764"/>can occur twice per year to reflect the accuracy of the Earth’s rotation around the Sun.</p>
<p class="callout-heading">Important note</p>
<p class="callout">More information <a id="_idIndexMarker765"/>about leap seconds can be found at <a href="https://en.wikipedia.org/wiki/Leap_second">https://en.wikipedia.org/wiki/Leap_second</a>.</p>
<p>C++20 introduces several more predefined clocks. Some of them are <code>std::chrono::utc_clock</code>, which measures UTC, and <code>std::chrono::tai_clock</code>, which<a id="_idIndexMarker766"/> measures <strong class="bold">International Atomic </strong><strong class="bold">Time</strong> (<strong class="bold">TAI</strong>).</p>
<p class="callout-heading">Important note</p>
<p class="callout">More <a id="_idIndexMarker767"/>information <a id="_idIndexMarker768"/>about UTC and TAI can be found here: <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">https://en.wikipedia.org/wiki/Coordinated_Universal_Time</a> and <a href="https://en.wikipedia.org/wiki/International_Atomic_Time">https://en.wikipedia.org/wiki/International_Atomic_Time</a>.</p>
<p>A key difference<a id="_idIndexMarker769"/> between the TAI and UTC clocks is that the UTC clock is guaranteed to take into account the leap-second corrections made since the clock epoch, but the TAI clock doesn’t take them into account. Let’s see an example:</p>
<pre class="source-code">
using namespace std::chrono;
tai_time tai{tai_clock::now()};
utc_time utc{utc_clock::now()};
std::cout &lt;&lt; "International atomic time (TAI): " &lt;&lt; tai &lt;&lt;
  '\n';
std::cout &lt;&lt; "Coordinated universal time (UTC): " &lt;&lt; utc &lt;&lt;
  '\n';</pre> <p>In the preceding example, we get the current time from both clocks – <code>utc</code> and <code>tai</code>. Here is the result:</p>
<pre class="console">
International atomic time (TAI): 2023-08-04 14:02:57.95506
Coordinated universal time (UTC): 2023-08-04 14:02:20.95506</pre> <p>As you can see, regardless<a id="_idIndexMarker770"/> of whether both clocks are invoked at the same time, they show different times. And their difference is <em class="italic">exactly 37 seconds</em>. This difference comes from the leap-second adjustments made since they were introduced back in 1972.</p>
<p><code>std::chrono::utc_clock</code> applies leap-second adjustments. By using chrono’s UTC clock, these leap-second adjustments will be done automatically for you, and you don’t need to take any special action. Therefore, the chrono library provides a method to convert between clock types – <code>std::chrono::clock_cast</code>, which converts <code>std::chrono::time_point</code> values from one clock into another. Let’s see another example:</p>
<pre class="source-code">
using namespace std::chrono;
tai_time tai{tai_clock::now()};
std::cout &lt;&lt; "International atomic time (TAI): " &lt;&lt; tai &lt;&lt;
  '\n';
utc_time utc{clock_cast&lt;utc_clock&gt;(tai)};
std::cout &lt;&lt; "Coordinated universal time (UTC): " &lt;&lt; utc &lt;&lt;
  '\n';</pre> <p>As you can <a id="_idIndexMarker771"/>see, the <code>time_point tai</code> object generated by chrono’s TAI clock is converted into a <a id="_idIndexMarker772"/>time point from the UTC clock. The result is as follows:</p>
<pre class="console">
International atomic time (TAI): 2023-08-04 14:16:22.72521
Coordinated universal time (UTC): 2023-08-04 14:15:45.72521</pre> <p>As we expected, the TAI clock is 37 seconds ahead of the UTC one. Therefore, UTC cannot be used to properly measure time differences as a leap second might be added or removed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can find all the predefined clocks in<a id="_idIndexMarker773"/> the C++ chrono library here: <a href="https://en.cppreference.com/w/cpp/chrono#Clocks">https://en.cppreference.com/w/cpp/chrono#Clocks</a>.</p>
<p>Now, since we have a good understanding of timing and clocks, let’s see what capabilities the C++ chrono library provides for calendars and time zones.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Using calendar and time zone capabilities</h1>
<p>C++20 introduces <a id="_idIndexMarker774"/>brand-new support for calendar and time zone operations <a id="_idIndexMarker775"/>to the standard. When we talk about calendar operations, this means operations in days, months, and years. They, together with the time zone notion, allow conversions of time between different time zones taking into account time zone adjustments such as daylight saving time.</p>
<p>Let’s define a date and print it with the help of the <code>chrono</code> library:</p>
<pre class="source-code">
using namespace std::chrono;
year theYear{2023};
month theMonth{8};
day theDay{4};
std::cout &lt;&lt; "Year: " &lt;&lt; theYear;
std::cout &lt;&lt; ", Month: " &lt;&lt; theMonth;
std::cout &lt;&lt; ", Day: " &lt;&lt; theDay &lt;&lt; '\n';</pre> <p>As you can<a id="_idIndexMarker776"/> see, the <code>std::chrono</code> namespace provides <code>year</code>, <code>month</code>, and <code>day</code> classes, which make it easy to work with dates. The benefit of these classes is that they <a id="_idIndexMarker777"/>provide strict type and boundary checks, some operators for summation and subtraction, and formatting capabilities. The result of the preceding code is as follows:</p>
<pre class="console">
Year: 2023, Month: Aug, Day: 04</pre> <p>As you can see, passing the <code>Month</code> variable to <code>operator&lt;&lt;</code> applies formatting so that the value of the month is printed as <code>Aug</code>. Also, these classes provide validation and boundary checks on the applied values:</p>
<pre class="source-code">
using namespace std::chrono;
std::cout &lt;&lt; "Year: " &lt;&lt; year{2023} ;
std::cout &lt;&lt; ", Month: " &lt;&lt; month{13};
std::cout &lt;&lt; ", Day: " &lt;&lt; day{32} &lt;&lt; '\n';</pre> <p>In the preceding example, we have applied an invalid month and day of the month. The result is as follows:</p>
<pre class="console">
Year: 2023, Month: 13 is not a valid month, Day: 32 is not a valid day</pre> <p>As you can see, <code>month</code> and <code>day</code> values are validated, and when they are passed to <code>operator&lt;&lt;</code>, it prints that these values are not valid.</p>
<p>The <code>year</code> class represents a year in the proleptic Gregorian calendar, which enables us to ask whether the year is a leap year or not:</p>
<pre class="source-code">
using namespace std::chrono;
sys_time now{system_clock::now()};
year_month_day today{floor&lt;days&gt;(now)};
std::cout &lt;&lt; "Today is: " &lt;&lt; today &lt;&lt; '\n';
year thisYear{today.year()};
std::cout &lt;&lt; "Year " &lt;&lt; thisYear;
if (thisYear.is_leap()) {
    std::cout &lt;&lt; " is a leap year\n";
} else {
    std::cout &lt;&lt; " is not a leap year\n";
}</pre> <p>In this example, we <a id="_idIndexMarker778"/>first get the current system time – <code>now</code> – and then we <a id="_idIndexMarker779"/>convert it into an object of the <code>year_month_day</code> type. This object represents a convenient field-based timepoint. It holds <code>year</code>, <code>month</code>, and <code>day</code> objects and allows direct access to them. It also supports instantiation from <code>std::chrono::sys_days</code>, which effectively is a timepoint of the system clock in days. Therefore, we pass the <code>now</code> timepoint and create the <code>today</code> object. Then, we get the <code>year</code> object – <code>thisYear</code> – and it checks whether this is a leap year or not using the <code>is_leap()</code> method of the <code>year</code> class:</p>
<pre class="console">
Today is: 2023-08-05
Year 2023 is not a leap year</pre> <p>As expected, 2023 is not a leap year.</p>
<p>The <code>chrono</code> library heavily utilizes <code>operator/</code> for date creation. C++20 provides about 40 overloads of the parameters of this operator. Let’s see an example:</p>
<pre class="source-code">
using namespace std::chrono;
year_month_day date1{July/5d/2023y};
year_month_day date2{1d/October/2023y};
year_month_day date3{2023y/January/27d};
std::cout &lt;&lt; date1 &lt;&lt; '\n';
std::cout &lt;&lt; date2 &lt;&lt; '\n';
std::cout &lt;&lt; date3 &lt;&lt; '\n';</pre> <p>As you can see, we create a <code>year_month_day</code> object by passing the newly introduced <em class="italic">chrono literals</em> for <a id="_idIndexMarker780"/>months, days, and years together with <code>operator/</code>. chrono provides convenient literals for the creation of days; you just have to append <code>d</code> to the day value. The <a id="_idIndexMarker781"/>same is the case for years, you have to append <code>y</code> and you construct a <code>year</code> object. For months, the chrono library defines named constants for all months of the year.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a<a id="_idIndexMarker782"/> link to a list of the month constants in the chrono library: <a href="https://en.cppreference.com/w/cpp/chrono/month">https://en.cppreference.com/w/cpp/chrono/month</a>.</p>
<p>During the instantiation of the <code>year_month_day</code> object, we pass date values using <code>operator/</code>. As is visible from the preceding example, chrono supports many combinations of day, month, and year values. All of them can be found in the standard documentation.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a link to the documentation on all<a id="_idIndexMarker783"/> overloads of <code>operator/</code> for date management: <a href="https://en.cppreference.com/w/cpp/chrono/operator_slash">https://en.cppreference.com/w/cpp/chrono/operator_slash</a>.</p>
<p>All the used overloads in our example are supposed to create valid <code>year_month_date</code> objects. Let’s see the output:</p>
<pre class="console">
2023-07-05
2023-10-01
2023-01-27</pre> <p>As we can see, we have successfully created three separate valid dates with the help of chrono literals and <code>operator/</code>.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>Working with time zones in C++</h2>
<p>The C++20 <code>chrono</code> library <a id="_idIndexMarker784"/>provides capabilities for working <a id="_idIndexMarker785"/>with time zones. It integrates the IANA time zone database, which contains information about the local time in many geographical locations around the globe.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Find more information about the<a id="_idIndexMarker786"/> IANA time zone database here: <a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>.</p>
<p>Using <code>chrono</code>, you can get a copy of the IANA database and browse it for a specific geographical location:</p>
<pre class="source-code">
using namespace std::chrono;
const tzdb&amp; tzdb{get_tzdb()};
const std::vector&lt;time_zone&gt;&amp; tzs{tzdb.zones};
for (const time_zone&amp; tz : tzs) {
    std::cout &lt;&lt; tz.name() &lt;&lt; '\n';
}</pre> <p>As we can see from the example, in the <code>std::chrono</code> namespace, there is a method – <code>get_tzdb()</code> – that returns a reference to the IANA database. In the database, you can find information about its version and also get a sorted list of all available <code>std::chrono::time_zone</code> objects.</p>
<p>The <code>std::chrono::time_zone</code> class stores information about transitions between time zones for its specific geographic area and name. The output from the preceding example is as follows:</p>
<pre class="console">
Africa/Abidjan
Africa/Accra
Africa/Addis_Ababa
Africa/Algiers
Africa/Asmara
Africa/Bamako
...</pre> <p>Now, once<a id="_idIndexMarker787"/> we have all available time zones, let’s try to find a specific<a id="_idIndexMarker788"/> one based on a geographical location and see what the time is there:</p>
<pre class="source-code">
using namespace std::chrono;
const tzdb&amp; tzdb{get_tzdb()};
const std::vector&lt;time_zone&gt;&amp; tzs{tzdb.zones};
const auto&amp; res{std::find_if(tzs.begin(), tzs.end(), []
  (const time_zone&amp; tz){
    std::string name{tz.name()};
    return name.ends_with("Sofia");
})};
if (res != tzs.end()) {
    try {
        const std::string_view myLocation{res-&gt;name()};
        const std::string_view london{"Europe/London"};
        const time_point now{system_clock::now()};
        const zoned_time zt_1{myLocation, now};
        const zoned_time zt_2{london, now};
        std::cout &lt;&lt; myLocation &lt;&lt; ": " &lt;&lt; zt_1 &lt;&lt; '\n';
        std::cout &lt;&lt; london &lt;&lt; ": " &lt;&lt; zt_2 &lt;&lt; '\n';
    } catch (const std::runtime_error&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}</pre> <p>In this example, we again get the list of the available time zones and try to find the time zone for the city of <code>Sofia</code>. Then, we <a id="_idIndexMarker789"/>use the full name of the found time zone to create another object that uses a specific geographical location and the value of the system time – <code>std::chrono::zoned_time</code>. This class represents a logical pair between a time zone <a id="_idIndexMarker790"/>and a point in time. We also create another <code>zoned_time zt_2</code> object but for the city of <code>London</code>, which represents the same time point as <code>zt_1</code> but in another geographical location. The result of the preceding code is as follows:</p>
<pre class="console">
Europe/Sofia: 2023-08-05 13:43:53.503184619 EEST
Europe/London: 2023-08-05 11:43:53.503184619 BST</pre> <p>As you can see, both objects display a valid time but with respect to their geographical locations. This is how we can safely get the current time in a specific geographical location where daylight saving time is also considered.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Summary</h1>
<p>In this chapter, we explored the different timers available within the Linux environment. Subsequently, we gained an understanding of the significance behind the clock epoch and the concept of UNIX time. Following this, we delved into the practical implementation of POSIX in Linux for accurate time measurement. Additionally, we investigated the realm of <code>std::chrono</code> and examined the array of capabilities that C++ affords for effective time-related operations. Our exploration then took us on a detailed journey through duration, timepoints, and clocks as they are defined within the <code>std::chrono</code> framework. Moving forward, we acquainted ourselves with the various clock types at our disposal within <code>std::chrono</code>. As our journey continued, we initiated our exploration into the calendar capabilities presented by <code>std::chrono</code>. Finally, we developed familiarity with time zones and honed our proficiency in executing seamless time conversions utilizing the tools offered by <code>std::chrono</code>. Now, we are ready for the next chapter, where we will go deeper into the specifics of the C++ memory model.</p>
</div>
</div></body></html>