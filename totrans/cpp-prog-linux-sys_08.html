<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer063">
<h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor116"/>8</h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Using Clocks, Timers, and Signals in Linux</h1>
<p>In this chapter, we will commence by exploring the various timers available in the Linux environment. Subsequently, we will delve into the significance of the clock epoch and delve into the concept of UNIX time. Following this, we will unveil the methodology for employing POSIX in Linux to precisely measure time intervals. Transitioning further, we will uncover the realm of <strong class="source-inline">std::chrono</strong> and examine the capabilities that C++ offers for effective time-related operations. Our journey then progresses to a comprehensive examination of duration, timepoints, and clocks as<a id="_idIndexMarker696"/> delineated within the <strong class="source-inline">std::chrono</strong> framework. Venturing onward, we will acquaint ourselves with the diverse array of clocks at our disposal within <strong class="source-inline">std::chrono</strong>. As we navigate our path, we will take our initial steps into harnessing the calendar functionalities provided by <strong class="source-inline">std::chrono</strong>. In the final leg of our exploration, we will become familiar with time zones and refine our expertise in executing seamless time conversions using the powerful tools <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::chrono</strong></span><span class="No-Break">.</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Exploring timers <span class="No-Break">in Linux</span></li>
<li>Handling time <span class="No-Break">in C++</span></li>
<li>Using clocks, timers, <span class="No-Break">and ratios</span></li>
<li>Using calendar and time <span class="No-Break">zone capabilities</span></li>
</ul>
<p>So, let’s <span class="No-Break">get started!</span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>Technical requirements</h1>
<p>All examples in this chapter have been tested in an environment with the <span class="No-Break">following configuration:</span></p>
<ul>
<li>Linux Mint 21 <span class="No-Break">Cinnamon edition.</span></li>
<li>GCC 13.2 with compiler <span class="No-Break">flags: </span><span class="No-Break"><strong class="source-inline">-std=c++20</strong></span><span class="No-Break">.</span></li>
<li>A stable <span class="No-Break">internet connection.</span></li>
<li>Please make sure your environment is at least this recent. For all the examples, you can alternatively <span class="No-Break">use </span><a href="https://godbolt.org/"><span class="No-Break">https://godbolt.org/</span></a><span class="No-Break">.</span></li>
<li>All code examples in this chapter are available for download <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208"><span class="No-Break">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208</span></a><span class="No-Break">.</span></li>
</ul>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Handling time in Linux</h1>
<p>Timing is an<a id="_idIndexMarker697"/> essential aspect of any computer system, and Linux is no exception. In<a id="_idIndexMarker698"/> Linux, there are different types of timers available, each designed to handle specific tasks <span class="No-Break">and requirements.</span></p>
<p>These timers <a id="_idIndexMarker699"/>can be <a id="_idIndexMarker700"/>used to measure the execution time of programs, schedule tasks, trigger events, and more. In this section, we’ll explore the different types of timers available in Linux and how to use <span class="No-Break">them effectively.</span></p>
<p>Here are the different kinds of timers used in the <span class="No-Break">Linux system:</span></p>
<ul>
<li><strong class="bold">System timers</strong>: The<a id="_idIndexMarker701"/> Linux kernel uses system timers to keep<a id="_idIndexMarker702"/> track of the time and schedule various tasks. System timers are used to measure the system uptime, delay, and timeouts. The most important system timer in Linux is the <em class="italic">Jiffies</em> timer, which increments by 1 with every tick of the system clock. The Jiffies timer is used to track the time elapsed since the system booted up, and it is frequently used by various kernel modules <span class="No-Break">and drivers.</span></li>
<li><strong class="bold">Real-Time Clock (RTC)</strong>: The RTC is<a id="_idIndexMarker703"/> a hardware <a id="_idIndexMarker704"/>clock that keeps track of the date and time, even when the system is powered off. The Linux kernel can read and set the RTC through the <strong class="source-inline">/dev/rtc</strong> device file or the <strong class="source-inline">hwclock</strong> command-line tool. The RTC is used to synchronize the system time during startup and to maintain an accurate timestamp for <span class="No-Break">system events.</span></li>
<li><strong class="bold">High-Resolution Timers (HRTs)</strong>: HRTs <a id="_idIndexMarker705"/>provide<a id="_idIndexMarker706"/> nanosecond-level resolution, which makes them suitable for real-time applications that require precise timing. HRTs can be used to measure the execution time of a code segment, schedule events with high accuracy, or drive <span class="No-Break">high-speed hardware.</span></li>
<li><strong class="bold">POSIX timers</strong>: POSIX timers<a id="_idIndexMarker707"/> are a set of timers defined by the <a id="_idIndexMarker708"/>POSIX standard that provide a uniform interface for timer management in Linux. POSIX timers can be used to set up one-shot or periodic timers, which can be triggered by a signal or a thread. POSIX timers are implemented using the <strong class="source-inline">timer_create()</strong>, <strong class="source-inline">timer_settime()</strong>, and <strong class="source-inline">timer_delete()</strong> <span class="No-Break">system calls.</span></li>
<li><strong class="bold">Timer queues</strong>: Timer queues <a id="_idIndexMarker709"/>are a mechanism<a id="_idIndexMarker710"/> provided by the Linux kernel to schedule events and timeouts. Timer queues are implemented as a priority queue of events, where each event is associated with a timer. Timer queues can be used to schedule periodic tasks, implement timeouts, or trigger events at specific intervals. Timer queues are used extensively in various kernel modules and <span class="No-Break">device drivers.</span></li>
</ul>
<p>But speaking about timers, we first need to understand what time means in computer systems. Let’s have <span class="No-Break">a look.</span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Linux epoch</h2>
<p>In <a id="_idIndexMarker711"/>computing, an <em class="italic">epoch</em> refers <a id="_idIndexMarker712"/>to a specific point in time used as a reference for measuring time in a particular system or context. It serves as a starting point from which other time values are calculated or represented. In other words, this is the time from when the computer measures the <span class="No-Break">system time.</span></p>
<p>The<a id="_idIndexMarker713"/> epoch is often defined as a specific point in time, typically represented as the number of seconds or milliseconds, or other time intervals even smaller than a millisecond elapsed since a particular epoch time. The choice of epoch varies depending <a id="_idIndexMarker714"/>on the system and context. For example, in UNIX-like systems, which Linux is, the epoch is defined as <em class="italic">January 1, 1970, at 00:00:00 UTC</em> (Coordinated Universal Time). This epoch time is often referred to as the <em class="italic">UNIX epoch</em> or <em class="italic">UNIX time</em>. The time values in UNIX-based systems are typically represented as the number of seconds elapsed since the <span class="No-Break">UNIX epoch.</span></p>
<p>Now, having a better understanding of the UNIX epoch, let’s have a look at some examples of how to use these timers <span class="No-Break">in practice.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Using timers in Linux</h2>
<p>Since we <a id="_idIndexMarker715"/>already know about the different types of timers available in Linux, let’s explore how to use them in our applications. We will look at an example that starts a POSIX timer and waits until it <span class="No-Break">is signaled:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;csignal&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;atomic&gt;
static std::atomic_bool continue_execution{true};
int main() {
    struct sigaction sa{};
    sa.sa_handler = [](int signum) {
        // Timer triggered, stop the loop.
        std::cout &lt;&lt; "Timer expired. Stopping the
          task...\n";
        continue_execution = false;
    };
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGALRM, &amp;sa, nullptr);
    // Configure the timer to trigger every 1 seconds
    struct itimerval timer{
        .it_interval{.tv_sec{1}, .tv_usec{0}},
        .it_value{.tv_sec{1}, .tv_usec{0}}
    };
    // Start the timer
    setitimer(ITIMER_REAL, &amp;timer, nullptr);
    std::cout &lt;&lt; "Timer started. Waiting for timer
      expiration...\n";
    // Keep the program running to allow the timer to
      trigger
    while (continue_execution) {
        sleep(1);
    }
    return 0;
}</pre> <p>In this<a id="_idIndexMarker716"/> example, we define a lambda handler that will be called whenever the timer expires. Inside the handler, we print a message indicating that the timer has expired and set the exit condition of the <span class="No-Break">busy loop.</span></p>
<p>We set up the signal handler using the <strong class="source-inline">sigaction</strong> function. Then, we configure the timer using the <strong class="source-inline">it_interval</strong> and <strong class="source-inline">it_value</strong> members of the <strong class="source-inline">itimerval</strong> structure. After configuring the timer, we start it by calling the <strong class="source-inline">setitimer</strong> POSIX function <a id="_idIndexMarker717"/>with the <strong class="source-inline">ITIMER_REAL</strong> option, which sets a real-time timer that sends <strong class="source-inline">SIGALRM</strong> signals when it expires. We enter a loop to keep the program running indefinitely. The <strong class="source-inline">sleep(1)</strong> call inside the loop ensures that the program does not exit immediately and allows the timer <span class="No-Break">to trigger.</span></p>
<p>The output of the program is <span class="No-Break">as follows:</span></p>
<pre class="console">
Program returned: 0
Timer started. Waiting for timer expiration...
Timer expired. Stopping the task...</pre> <p>Another common task in software development is measuring the execution time of a code segment. It can also be achieved by using the POSIX time capabilities. To measure the execution time of a code segment, we can use an HRT <span class="No-Break">in POSIX.</span></p>
<p>To use an HRT in POSIX, we will use the <strong class="source-inline">clock_gettime()</strong> function along with the <strong class="source-inline">CLOCK_MONOTONIC</strong> clock ID. Here’s an example demonstrating the usage of HRTs <span class="No-Break">in POSIX:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;ctime&gt;
static const auto LIMIT{10000};
void just_busy_wait_f() {
    for (auto i{0}; i &lt; LIMIT; ++i) {
        for (auto j{0}; j &lt; LIMIT; ++j);
    }
}
int main() {
    timespec start, end;
    // Start the timer
    clock_gettime(CLOCK_MONOTONIC, &amp;start);
    // Measured code segment
    just_busy_wait_f();
    // Stop the timer
    clock_gettime(CLOCK_MONOTONIC, &amp;end);
    // Calculate the elapsed time
    const auto elapsed{(end.tv_sec - start.tv_sec) +
      (end.tv_nsec - start.tv_nsec) / 1e9};
    std::cout &lt;&lt; "Elapsed time: " &lt;&lt; elapsed &lt;&lt; "
      seconds\n";
    return 0;
}</pre> <p>In this<a id="_idIndexMarker718"/> example, we declare two <strong class="source-inline">timespec</strong> structures, <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong>, to hold the start and end timestamps of the timer. We use the <strong class="source-inline">clock_gettime()</strong> function to obtain the current time with a <span class="No-Break">high-resolution clock.</span></p>
<p>We call <strong class="source-inline">clock_gettime()</strong> twice: once at the beginning of the task (to record the start time) and once at the end (to record the end time). The <strong class="source-inline">CLOCK_MONOTONIC</strong> clock ID is used, which represents a monotonic clock unaffected by system <span class="No-Break">time adjustments.</span></p>
<p>After capturing the start and end timestamps, we calculate the elapsed time by subtracting the respective second and nanosecond components of the timestamps. The result is then printed as the elapsed time <span class="No-Break">in seconds.</span></p>
<p>The example output in our test lab is <span class="No-Break">as follows:</span></p>
<pre class="console">
Program returned: 0
Elapsed time: 0.169825 seconds</pre> <p>Keep in mind that in your environment, the result could <span class="No-Break">be different.</span></p>
<p>Note that this example demonstrates one way to measure execution time using a timer. Depending on your requirements, you can choose different <span class="No-Break">timer mechanisms.</span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>POSIX timer characteristics</h2>
<p>Let’s look at some of the<a id="_idIndexMarker719"/> characteristics that POSIX <span class="No-Break">timers have:</span></p>
<ul>
<li><strong class="bold">Powerful and flexible</strong>: POSIX timers provide a rich set of features, including different timer types (for example, interval timers and one-shot timers), various clock sources, and precise control over <span class="No-Break">timer behavior</span></li>
<li><strong class="bold">Low-level control</strong>: POSIX timers offer fine-grained control over timer settings, such as signal handling and timer <span class="No-Break">expiration behavior</span></li>
<li><strong class="bold">Legacy support</strong>: POSIX timers are part of the POSIX API and have been available on UNIX-like systems for a long time, making them suitable if you need to maintain compatibility with legacy code or specific <span class="No-Break">POSIX requirements</span></li>
<li><strong class="bold">Platform-specific</strong>: POSIX timers are not available on all platforms, so if portability is a concern, it is better to switch to a more <span class="No-Break">suitable choice</span></li>
</ul>
<p>But what better alternative do we have in C++? We will see in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>Handling time in C++</h1>
<p>While <a id="_idIndexMarker720"/>POSIX timers have their own merits, in C++ there are libraries that provide higher-level and more portable solutions for timing and <span class="No-Break">time-related operations.</span></p>
<p>One good<a id="_idIndexMarker721"/> example of such a library is <strong class="source-inline">std::chrono</strong>. This is a C++ library that provides a set of utilities for working with time-related operations and measurements. It is part of the Standard Library and is included in the <strong class="source-inline">&lt;chrono&gt;</strong> header. The <strong class="source-inline">std::chrono</strong> library provides a flexible and type-safe mechanism for representing and manipulating time durations, time points, clocks, and time-related operations. By using <strong class="source-inline">std::chrono</strong>, you will benefit from the standardization, type safety, flexibility, and integration that comes with the C++ Standard Library. Some of the advantages<a id="_idIndexMarker722"/> of <strong class="source-inline">std::chrono</strong> compared to the traditional POSIX approach are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">Standardization</strong>: <strong class="source-inline">std::chrono</strong> is part of the C++ Standard Library, making it a cross-platform solution that works consistently across different operating systems and compilers. POSIX, on the other hand, is specific to UNIX-like systems and may not be available or behave consistently on <span class="No-Break">all platforms.</span></li>
<li><strong class="bold">Type safety</strong>: <strong class="source-inline">std::chrono</strong> provides type-safe representations of time durations and points in time. It offers a rich set of duration and clock types that can be used together seamlessly, enabling safer and more expressive code. POSIX timers, while powerful, often rely on low-level types, such as the <strong class="source-inline">timespec</strong> struct, which can be error-prone and require <span class="No-Break">manual conversions.</span></li>
<li><strong class="bold">Flexibility and expressiveness</strong>: <strong class="source-inline">std::chrono</strong> offers a flexible and expressive interface for time-related operations. It provides convenient ways to perform<a id="_idIndexMarker723"/> arithmetic operations on durations, convert between different time units, and format time values. POSIX timers, while suitable for specific timing requirements, lack the high-level abstractions and utilities provided <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">std::chrono</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Integration with the Standard Library</strong>: <strong class="source-inline">std::chrono</strong> seamlessly integrates with other parts of the C++ Standard Library. It can be used in conjunction with algorithms, containers, and concurrency facilities, allowing for more cohesive and efficient code. POSIX timers, being a lower-level interface, may require additional work to integrate with other C++ Standard <span class="No-Break">Library components.</span></li>
<li><strong class="bold">Compatibility with modern C++ features</strong>: <strong class="source-inline">std::chrono</strong> benefits from the advancements and features introduced in modern C++. It supports features such as user-defined literals, lambda functions, and type deduction, making it easier to write concise and expressive code. POSIX timers, being part of the POSIX API, may not fully leverage the modern C++ <span class="No-Break">language features.</span></li>
</ul>
<p>The <strong class="source-inline">&lt;chrono&gt;</strong> library <a id="_idIndexMarker724"/>provides a comprehensive set of features for working with<a id="_idIndexMarker725"/> time-related operations, such as measuring time durations, representing points in time, and performing various time calculations and conversions. Here are some<a id="_idIndexMarker726"/> key components<a id="_idIndexMarker727"/> and<a id="_idIndexMarker728"/> features <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::chrono</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="bold">Clocks</strong>: <strong class="source-inline">&lt;chrono&gt;</strong> defines<a id="_idIndexMarker729"/> several clock types that represent different sources of time and different epochs. <strong class="source-inline">std::chrono::system_clock</strong> represents the system-wide RTC, which is adjustable. <strong class="source-inline">std::chrono::steady_clock</strong> represents a steady monotonic clock unaffected by system time adjustments, and <strong class="source-inline">std::chrono::high_resolution_clock</strong> represents a clock with the highest available resolution (if supported by <span class="No-Break">the system).</span></li>
<li><strong class="bold">Duration</strong>: The <strong class="source-inline">std::chrono::duration</strong> template class represents a time interval, that is, a <a id="_idIndexMarker730"/>specified period of time The duration is the tick count using a specific unit of time; for example, a duration of five hours is five ticks of the unit <em class="italic">hour</em>. Different types of durations can be defined, from years to nanoseconds. Example durations include <strong class="source-inline">std::chrono::seconds</strong>, <strong class="source-inline">std::chrono::milliseconds</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">std::chrono::months</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Time point</strong>: A time point <a id="_idIndexMarker731"/>represents a specific point in time compared to the epoch of a specific clock. The <strong class="source-inline">std::chrono::time_point</strong> template class is parameterized by a clock and <span class="No-Break">duration type.</span></li>
<li><strong class="bold">Time conversions</strong>: <strong class="source-inline">std::chrono</strong> allows for<a id="_idIndexMarker732"/> conversions between durations and <a id="_idIndexMarker733"/>time points, as well as arithmetic operations involving durations. It provides functions such as <strong class="source-inline">std::chrono::duration_cast</strong> to convert between <a id="_idIndexMarker734"/>different durations and <strong class="source-inline">std::chrono::time_point_cast</strong> to convert between different <span class="No-Break">time points.</span></li>
<li><strong class="bold">Clock utilities</strong>: <strong class="source-inline">std::chrono</strong> provides<a id="_idIndexMarker735"/> utilities for querying the current time, such as <strong class="source-inline">std::chrono::system_clock::now()</strong>, which returns the current system <span class="No-Break">time point.</span></li>
<li><strong class="bold">Chrono literals</strong>: <strong class="source-inline">std::chrono</strong> provides <a id="_idIndexMarker736"/>user-defined, time-related literals in the <strong class="source-inline">std::literals::chrono_literals</strong> namespace. They allow you to create <strong class="source-inline">std::chrono::duration</strong> objects using literals with time units. This makes the code more readable and convenient when dealing with <span class="No-Break">time-related computations.</span></li>
<li><strong class="bold">Calendar</strong>: <strong class="source-inline">std::chrono</strong> provides <a id="_idIndexMarker737"/>calendar capabilities, such as working with days, months, and years. It also provides notation for leap years and <span class="No-Break">leap seconds.</span></li>
<li><strong class="bold">Time zones</strong>: <strong class="source-inline">std::chrono</strong> provides <a id="_idIndexMarker738"/>information about different time zones across the globe depending on the <span class="No-Break">geographical location.</span></li>
</ul>
<p>By using <strong class="source-inline">std::chrono</strong>, you <a id="_idIndexMarker739"/>can perform accurate and portable time <a id="_idIndexMarker740"/>measurements, handle timeouts, calculate time differences, and work with time-related operations in a <span class="No-Break">type-safe manner.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a link to the <strong class="source-inline">&lt;chrono&gt;</strong> header in the C++ reference <span class="No-Break">documentation: </span><a href="https://en.cppreference.com/w/cpp/header/chrono"><span class="No-Break">https://en.cppreference.com/w/cpp/header/chrono</span></a><span class="No-Break">.</span></p>
<p>Here’s an example of <a id="_idIndexMarker741"/>how to use <strong class="source-inline">std::chrono</strong> to measure the execution time of a <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;chrono&gt;
using namespace std::chrono;
int main() {
    const auto start{steady_clock::now()}; // {1}
    just_busy_wait_f(); // {2}
    const auto end{steady_clock::now()}; // {3}
    const auto dur{duration_cast&lt;milliseconds&gt;(end -
      start)}; // {4}
    std::cout &lt;&lt; "Execution time: " &lt;&lt; dur.count() &lt;&lt; "
      milliseconds\n"; // {5}
    return 0;
}</pre> <p>In the <a id="_idIndexMarker742"/>preceding example, <strong class="source-inline">std::chrono::steady_clock</strong> is used to measure the execution time of<a id="_idIndexMarker743"/> the same function as from the previous example (see marker <strong class="source-inline">{2}</strong>). The <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> variables represent the <em class="italic">timepoints</em> taken before and after the code execution using the <strong class="source-inline">now()</strong> static function of <strong class="source-inline">steady_clock</strong> (see markers <strong class="source-inline">{1}</strong> and <strong class="source-inline">{3}</strong>). <strong class="source-inline">std::chrono::duration_cast</strong> is used to convert the calculated duration between <a id="_idIndexMarker744"/>the time points in milliseconds (see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{4}</strong></span><span class="No-Break">).</span></p>
<p>The output of the program should be similar <span class="No-Break">to this:</span></p>
<pre class="console">
Program returned: 0
Execution time: 179 milliseconds</pre> <p>As you can see, the <strong class="source-inline">std::chrono::duration</strong> class has a <strong class="source-inline">count()</strong> method, which returns the number of units in a specific duration; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{5}</strong></span><span class="No-Break">.</span></p>
<p>But let’s get deeper into how this <span class="No-Break">really works.</span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Using clocks, timers, and ratios</h1>
<p>Before getting into<a id="_idIndexMarker745"/> more examples with clocks and timers, we first have to get a better understanding of how the chrono library <a id="_idIndexMarker746"/>defines <span class="No-Break">a </span><span class="No-Break"><em class="italic">duration</em></span><span class="No-Break">.</span></p>
<p>As we saw in the previous example, a duration is the distance between two points of time, called <em class="italic">timepoints</em>. In <a id="_idIndexMarker747"/>our previous example, these were the <strong class="source-inline">start</strong> and <span class="No-Break"><strong class="source-inline">end</strong></span><span class="No-Break"> timepoints.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 8.1 – Timepoint and duration" height="228" src="image/Figure_8.1_B20833.jpg" width="577"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Timepoint and duration</p>
<p>The duration itself is a combination of the count of ticks and a fraction that represents the time in seconds from one tick to the next. The fraction is represented by the <strong class="source-inline">std::ratio</strong> class. Here<a id="_idIndexMarker748"/> are<a id="_idIndexMarker749"/> <span class="No-Break">some examples:</span></p>
<pre class="source-code">
using namespace std::chrono;
constexpr std::chrono::duration&lt;int, std::ratio&lt;1&gt;&gt;
  six_minutes_1{360};
constexpr std::chrono::duration&lt;double, std::ratio&lt;3600&gt;&gt;
  six_minutes_2{0.1};
constexpr std::chrono::minutes six_minutes_3{6};
constexpr auto six_minutes_4{6min};
std::cout &lt;&lt; six_minutes_1 &lt;&lt; '\n';
std::cout &lt;&lt; six_minutes_2 &lt;&lt; '\n';
std::cout &lt;&lt; six_minutes_3 &lt;&lt; '\n';
std::cout &lt;&lt; six_minutes_4 &lt;&lt; '\n';
static_assert(six_minutes_1 == six_minutes_2);
static_assert(six_minutes_2 == six_minutes_3);
static_assert(six_minutes_3 == six_minutes_4);</pre> <p>In the preceding example, we have defined the<a id="_idIndexMarker750"/> duration of six minutes in several ways. In the <strong class="source-inline">six_minutes_1</strong> variable, we have specified this duration as a value of 360 seconds. The same duration can also be represented as 1/10 of an hour – the <strong class="source-inline">six_minutes_2</strong> variable. The last two durations – <strong class="source-inline">six_minutes_3</strong> and <strong class="source-inline">six_minutes_4</strong> – represent the same duration of six minutes but using the <strong class="source-inline">std::chrono</strong> predefined duration types and literals. Here is the output of the preceding <span class="No-Break">code block:</span></p>
<pre class="console">
360s
0.1h
6min
6min</pre> <p>As you can see, <strong class="source-inline">std::duration</strong> also<a id="_idIndexMarker751"/> provides pretty formatting capabilities so that once the duration is passed to a string or stream operator, it will add the corresponding suffix so we can see the <span class="No-Break">duration type.</span></p>
<p>In order to ensure that the preceding durations really correspond to six minutes, we have tested them against <strong class="source-inline">static_assert</strong>, which would fail the program if they <span class="No-Break">don’t match.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a link to<a id="_idIndexMarker752"/> the <strong class="source-inline">std::duration</strong> class in the C++ reference <span class="No-Break">documentation: </span><a href="https://en.cppreference.com/w/cpp/chrono/duration"><span class="No-Break">https://en.cppreference.com/w/cpp/chrono/duration</span></a><span class="No-Break">.</span></p>
<p>Let’s go back to our previous example, slightly change it, and have a<a id="_idIndexMarker753"/> closer look at a <span class="No-Break"><strong class="source-inline">timepoint</strong></span><span class="No-Break"> object:</span></p>
<pre class="source-code">
using namespace std::chrono;
const time_point start{steady_clock::now()}; // {1}
const duration epoch_to_start{start.time_since_epoch()}; //
  {2}
std::cout &lt;&lt; "Time since clock epoch: " &lt;&lt; epoch_to_start
  &lt;&lt; '\n'; // {3}</pre> <p>As you can see, we <a id="_idIndexMarker754"/>again construct a <strong class="source-inline">timepoint</strong> object, <strong class="source-inline">start</strong>, in which we get the time at the moment of its instantiation from the <strong class="source-inline">steady_clock</strong> instance of the Linux system; see marker <strong class="source-inline">{1}</strong>. The <strong class="source-inline">std::chrono::time_point</strong> class stores a <strong class="source-inline">std::chrono::duration</strong> value, which actually indicates the time interval from the start of the clock’s epoch. In order to allow getting that value, the <strong class="source-inline">std::chrono::duration</strong> class exposes a method that returns the duration, <strong class="source-inline">time_since_epoch()</strong>, in nanoseconds; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{2}</strong></span><span class="No-Break">.</span></p>
<p>Here is the result of the preceding code executed in our test environment. Please keep in mind that if you execute this code, the result could <span class="No-Break">be different:</span></p>
<pre class="console">
Time since clock epoch: 2080809926594ns</pre> <p>Having a time duration in nanoseconds could be inconvenient in some use cases, such as our example of calculating the time it takes for a code block to execute. However converting a duration from a higher-precision type into a lower-precision type results in a loss of precision. Therefore, if we need to see the duration in minutes then in nanoseconds, we can’t just <span class="No-Break">do this:</span></p>
<pre class="source-code">
using namespace std::chrono;
const minutes
  dur_minutes{steady_clock::now().time_since_epoch()};</pre> <p>This is because the preceding code won’t compile. The reason behind this is that the <strong class="source-inline">time_since_epoch()</strong> method<a id="_idIndexMarker755"/> returns the duration with a precision of nanoseconds. If we store that data in minutes, we will certainly lose precision. In order to be sure that this won’t be done by mistake, the compiler <span class="No-Break">stops us.</span></p>
<p>But how can we intentionally convert duration values from one precision into another? As we saw in the first example, we can use the <strong class="source-inline">std::chrono::duration_cast</strong> function provided by the library. It enables us to make conversions from a duration type with higher precision to a<a id="_idIndexMarker756"/> duration type with lower precision. Let’s rework the preceding example and see how <span class="No-Break">this works:</span></p>
<pre class="source-code">
using namespace std::chrono;
auto dur_from_epoch{steady_clock::now()
  .time_since_epoch()}; // {1}
minutes dur_minutes{duration_cast&lt;minutes&gt;
  (dur_from_epoch)}; // {2}
std::cout &lt;&lt; "Duration in nanoseconds: " &lt;&lt; dur_from_epoch
  &lt;&lt; '\n'; //{3}
std::cout &lt;&lt; "Duration in minutes: " &lt;&lt; dur_minutes &lt;&lt;
  '\n'; //{4}</pre> <p>As you can see in marker <strong class="source-inline">{1}</strong>, we again get the duration in nanoseconds from the clock’s epoch. In marker <strong class="source-inline">{2}</strong>, we initialize another duration variable but this time in minutes. In order to do so, we use <strong class="source-inline">std::chrono::duration_cast&lt;minutes&gt;</strong>, which converts the value from the source resolution into the destination one and truncates it down to the closest integer value. In our test environment, the result of the preceding code block is <span class="No-Break">as follows:</span></p>
<pre class="console">
Duration in nanoseconds: 35206835643934ns
Duration in minutes: 586min</pre> <p>We can see that the measured duration in nanoseconds is equivalent to about 586.78 minutes but it is truncated down to <span class="No-Break">586 minutes.</span></p>
<p>Of course, we could also need to round up rather than just truncate down values. Fortunately, the <strong class="source-inline">chrono</strong> library gives us this capability with the <strong class="source-inline">std::chrono::round</strong> method, which does exactly this. Here is <span class="No-Break">an example:</span></p>
<pre class="source-code">
using namespace std::chrono;
seconds dur_sec_1{55s}; //{1}
seconds dur_sec_2{65s}; //{2}
minutes dur_min_1{round&lt;minutes&gt;(dur_sec_1)}; //{3}
minutes dur_min_2{round&lt;minutes&gt;(dur_sec_2)}; //{4}
std::cout &lt;&lt; "Rounding up to " &lt;&lt; dur_min_1 &lt;&lt; '\n';
std::cout &lt;&lt; "Rounding down to " &lt;&lt; dur_min_2 &lt;&lt; '\n';</pre> <p>In this example, we <a id="_idIndexMarker757"/>define two duration variables, <strong class="source-inline">dur_sec_1</strong> and <strong class="source-inline">dur_sec_2</strong>. <strong class="source-inline">dur_sec_1</strong> is initialized to 55 seconds (see marker <strong class="source-inline">{1}</strong>) and <strong class="source-inline">dur_sec_2</strong> is initialized to 65 seconds (see marker <strong class="source-inline">{2}</strong>). Then, using the <strong class="source-inline">std::chrono::round</strong> function, we initialize another two duration variables but this time with a resolution of minutes (see markers <strong class="source-inline">{3}</strong> and <strong class="source-inline">{4}</strong>). Both duration variables are rounded to <span class="No-Break">one minute:</span></p>
<pre class="console">
Rounding up to 1min
Rounding down to 1min</pre> <p>The <strong class="source-inline">chrono</strong> library also supplies methods for <strong class="source-inline">ceil</strong> and <strong class="source-inline">floor</strong> durations. All of them can be found in the <span class="No-Break">official documentation.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The documentation for <strong class="source-inline">round</strong>, <strong class="source-inline">floor</strong>, and <strong class="source-inline">ceil</strong> methods for duration values can be found at these links: <a href="https://en.cppreference.com/w/cpp/chrono/duration/round">https://en.cppreference.com/w/cpp/chrono/duration/round</a>, https://en.cppreference.com/w/cpp/chrono/duration/floor, <span class="No-Break">and </span><a href="https://en.cppreference.com/w/cpp/chrono/duration/ceil"><span class="No-Break">https://en.cppreference.com/w/cpp/chrono/duration/ceil</span></a><span class="No-Break">.</span></p>
<p>Since we have a better understanding of time operations, let’s have a closer look at the different types of clocks that <strong class="source-inline">std::chrono</strong> provides <span class="No-Break">for us.</span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>More about clocks in C++20</h2>
<p>We<a id="_idIndexMarker758"/> already used <strong class="source-inline">std::chrono::steady_clock</strong> in our previous examples. This is just one of the predefined clocks<a id="_idIndexMarker759"/> in the C++ <strong class="source-inline">chrono</strong> library<a id="_idIndexMarker760"/> that you can use. <strong class="source-inline">std::chrono::steady_clock</strong>, as its name suggests, is a clock that is steady. This means that it is a monotonic clock in which time only moves forward, and its timepoint values are always increasing. It is suitable for use when we want to measure intervals of time. Its epoch <span class="No-Break">can vary.</span></p>
<p>Another frequently used clock is <strong class="source-inline">std::chrono::system_clock</strong>. In Linux, it represents the time measured by the system. This means that it is not guaranteed to be monotonic, and it <a id="_idIndexMarker761"/>can be adjusted at any moment. In Linux, its epoch matches the UNIX epoch. Let’s see <span class="No-Break">an example:</span></p>
<pre class="source-code">
using namespace std::chrono;
time_point&lt;system_clock&gt; systemClockEpoch;
std::cout &lt;&lt; std::format("system_clock epoch:
  {0:%F}T{0:%R%z}.", systemClockEpoch) &lt;&lt; '\n';</pre> <p>The preceding example prints the Linux system clock epoch, which corresponds to the UNIX epoch – <strong class="source-inline">00:00:00: UTC</strong> on <strong class="source-inline">1 </strong><span class="No-Break"><strong class="source-inline">January 1970</strong></span><span class="No-Break">:</span></p>
<pre class="console">
system_clock epoch: 1970-01-01T00:00+0000.</pre> <p>Keep in mind that <strong class="source-inline">std::chrono::system_clock</strong> doesn’t take into <a id="_idIndexMarker762"/>account <em class="italic">leap seconds</em>, which <a id="_idIndexMarker763"/>can be added or subtracted from the measured time. In general, a leap second is a one-second adjustment of UTC, which <a id="_idIndexMarker764"/>can occur twice per year to reflect the accuracy of the Earth’s rotation around <span class="No-Break">the Sun.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">More information <a id="_idIndexMarker765"/>about leap seconds can be found <span class="No-Break">at </span><a href="https://en.wikipedia.org/wiki/Leap_second"><span class="No-Break">https://en.wikipedia.org/wiki/Leap_second</span></a><span class="No-Break">.</span></p>
<p>C++20 introduces several more predefined clocks. Some of them are <strong class="source-inline">std::chrono::utc_clock</strong>, which measures UTC, and <strong class="source-inline">std::chrono::tai_clock</strong>, which<a id="_idIndexMarker766"/> measures <strong class="bold">International Atomic </strong><span class="No-Break"><strong class="bold">Time</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">TAI</strong></span><span class="No-Break">).</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">More <a id="_idIndexMarker767"/>information <a id="_idIndexMarker768"/>about UTC and TAI can be found here: <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">https://en.wikipedia.org/wiki/Coordinated_Universal_Time</a> <span class="No-Break">and </span><a href="https://en.wikipedia.org/wiki/International_Atomic_Time"><span class="No-Break">https://en.wikipedia.org/wiki/International_Atomic_Time</span></a><span class="No-Break">.</span></p>
<p>A key difference<a id="_idIndexMarker769"/> between the TAI and UTC clocks is that the UTC clock is guaranteed to take into account the leap-second corrections made since the clock epoch, but the TAI clock doesn’t take them into account. Let’s see <span class="No-Break">an example:</span></p>
<pre class="source-code">
using namespace std::chrono;
tai_time tai{tai_clock::now()};
utc_time utc{utc_clock::now()};
std::cout &lt;&lt; "International atomic time (TAI): " &lt;&lt; tai &lt;&lt;
  '\n';
std::cout &lt;&lt; "Coordinated universal time (UTC): " &lt;&lt; utc &lt;&lt;
  '\n';</pre> <p>In the preceding example, we get the current time from both clocks – <strong class="source-inline">utc</strong> and <strong class="source-inline">tai</strong>. Here is <span class="No-Break">the result:</span></p>
<pre class="console">
International atomic time (TAI): 2023-08-04 14:02:57.95506
Coordinated universal time (UTC): 2023-08-04 14:02:20.95506</pre> <p>As you can see, regardless<a id="_idIndexMarker770"/> of whether both clocks are invoked at the same time, they show different times. And their difference is <em class="italic">exactly 37 seconds</em>. This difference comes from the leap-second adjustments made since they were introduced back <span class="No-Break">in 1972.</span></p>
<p><strong class="source-inline">std::chrono::utc_clock</strong> applies leap-second adjustments. By using chrono’s UTC clock, these leap-second adjustments will be done automatically for you, and you don’t need to take any special action. Therefore, the chrono library provides a method to convert between clock types – <strong class="source-inline">std::chrono::clock_cast</strong>, which converts <strong class="source-inline">std::chrono::time_point</strong> values from one clock into another. Let’s see <span class="No-Break">another example:</span></p>
<pre class="source-code">
using namespace std::chrono;
tai_time tai{tai_clock::now()};
std::cout &lt;&lt; "International atomic time (TAI): " &lt;&lt; tai &lt;&lt;
  '\n';
utc_time utc{clock_cast&lt;utc_clock&gt;(tai)};
std::cout &lt;&lt; "Coordinated universal time (UTC): " &lt;&lt; utc &lt;&lt;
  '\n';</pre> <p>As you can <a id="_idIndexMarker771"/>see, the <strong class="source-inline">time_point tai</strong> object generated by chrono’s TAI clock is converted into a <a id="_idIndexMarker772"/>time point from the UTC clock. The result is <span class="No-Break">as follows:</span></p>
<pre class="console">
International atomic time (TAI): 2023-08-04 14:16:22.72521
Coordinated universal time (UTC): 2023-08-04 14:15:45.72521</pre> <p>As we expected, the TAI clock is 37 seconds ahead of the UTC one. Therefore, UTC cannot be used to properly measure time differences as a leap second might be added <span class="No-Break">or removed.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You can find all the predefined clocks in<a id="_idIndexMarker773"/> the C++ chrono library <span class="No-Break">here: </span><a href="https://en.cppreference.com/w/cpp/chrono#Clocks"><span class="No-Break">https://en.cppreference.com/w/cpp/chrono#Clocks</span></a><span class="No-Break">.</span></p>
<p>Now, since we have a good understanding of timing and clocks, let’s see what capabilities the C++ chrono library provides for calendars and <span class="No-Break">time zones.</span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Using calendar and time zone capabilities</h1>
<p>C++20 introduces <a id="_idIndexMarker774"/>brand-new support for calendar and time zone operations <a id="_idIndexMarker775"/>to the standard. When we talk about calendar operations, this means operations in days, months, and years. They, together with the time zone notion, allow conversions of time between different time zones taking into account time zone adjustments such as daylight <span class="No-Break">saving time.</span></p>
<p>Let’s define a date and print it with the help of the <span class="No-Break"><strong class="source-inline">chrono</strong></span><span class="No-Break"> library:</span></p>
<pre class="source-code">
using namespace std::chrono;
year theYear{2023};
month theMonth{8};
day theDay{4};
std::cout &lt;&lt; "Year: " &lt;&lt; theYear;
std::cout &lt;&lt; ", Month: " &lt;&lt; theMonth;
std::cout &lt;&lt; ", Day: " &lt;&lt; theDay &lt;&lt; '\n';</pre> <p>As you can<a id="_idIndexMarker776"/> see, the <strong class="source-inline">std::chrono</strong> namespace provides <strong class="source-inline">year</strong>, <strong class="source-inline">month</strong>, and <strong class="source-inline">day</strong> classes, which make it easy to work with dates. The benefit of these classes is that they <a id="_idIndexMarker777"/>provide strict type and boundary checks, some operators for summation and subtraction, and formatting capabilities. The result of the preceding code is <span class="No-Break">as follows:</span></p>
<pre class="console">
Year: 2023, Month: Aug, Day: 04</pre> <p>As you can see, passing the <strong class="source-inline">Month</strong> variable to <strong class="source-inline">operator&lt;&lt;</strong> applies formatting so that the value of the month is printed as <strong class="source-inline">Aug</strong>. Also, these classes provide validation and boundary checks on the <span class="No-Break">applied values:</span></p>
<pre class="source-code">
using namespace std::chrono;
std::cout &lt;&lt; "Year: " &lt;&lt; year{2023} ;
std::cout &lt;&lt; ", Month: " &lt;&lt; month{13};
std::cout &lt;&lt; ", Day: " &lt;&lt; day{32} &lt;&lt; '\n';</pre> <p>In the preceding example, we have applied an invalid month and day of the month. The result is <span class="No-Break">as follows:</span></p>
<pre class="console">
Year: 2023, Month: 13 is not a valid month, Day: 32 is not a valid day</pre> <p>As you can see, <strong class="source-inline">month</strong> and <strong class="source-inline">day</strong> values are validated, and when they are passed to <strong class="source-inline">operator&lt;&lt;</strong>, it prints that these values are <span class="No-Break">not valid.</span></p>
<p>The <strong class="source-inline">year</strong> class represents a year in the proleptic Gregorian calendar, which enables us to ask whether the year is a leap year <span class="No-Break">or not:</span></p>
<pre class="source-code">
using namespace std::chrono;
sys_time now{system_clock::now()};
year_month_day today{floor&lt;days&gt;(now)};
std::cout &lt;&lt; "Today is: " &lt;&lt; today &lt;&lt; '\n';
year thisYear{today.year()};
std::cout &lt;&lt; "Year " &lt;&lt; thisYear;
if (thisYear.is_leap()) {
    std::cout &lt;&lt; " is a leap year\n";
} else {
    std::cout &lt;&lt; " is not a leap year\n";
}</pre> <p>In this example, we <a id="_idIndexMarker778"/>first get the current system time – <strong class="source-inline">now</strong> – and then we <a id="_idIndexMarker779"/>convert it into an object of the <strong class="source-inline">year_month_day</strong> type. This object represents a convenient field-based timepoint. It holds <strong class="source-inline">year</strong>, <strong class="source-inline">month</strong>, and <strong class="source-inline">day</strong> objects and allows direct access to them. It also supports instantiation from <strong class="source-inline">std::chrono::sys_days</strong>, which effectively is a timepoint of the system clock in days. Therefore, we pass the <strong class="source-inline">now</strong> timepoint and create the <strong class="source-inline">today</strong> object. Then, we get the <strong class="source-inline">year</strong> object – <strong class="source-inline">thisYear</strong> – and it checks whether this is a leap year or not using the <strong class="source-inline">is_leap()</strong> method of the <span class="No-Break"><strong class="source-inline">year</strong></span><span class="No-Break"> class:</span></p>
<pre class="console">
Today is: 2023-08-05
Year 2023 is not a leap year</pre> <p>As expected, 2023 is not a <span class="No-Break">leap year.</span></p>
<p>The <strong class="source-inline">chrono</strong> library heavily utilizes <strong class="source-inline">operator/</strong> for date creation. C++20 provides about 40 overloads of the parameters of this operator. Let’s see <span class="No-Break">an example:</span></p>
<pre class="source-code">
using namespace std::chrono;
year_month_day date1{July/5d/2023y};
year_month_day date2{1d/October/2023y};
year_month_day date3{2023y/January/27d};
std::cout &lt;&lt; date1 &lt;&lt; '\n';
std::cout &lt;&lt; date2 &lt;&lt; '\n';
std::cout &lt;&lt; date3 &lt;&lt; '\n';</pre> <p>As you can see, we create a <strong class="source-inline">year_month_day</strong> object by passing the newly introduced <em class="italic">chrono literals</em> for <a id="_idIndexMarker780"/>months, days, and years together with <strong class="source-inline">operator/</strong>. chrono provides convenient literals for the creation of days; you just have to append <strong class="source-inline">d</strong> to the day value. The <a id="_idIndexMarker781"/>same is the case for years, you have to append <strong class="source-inline">y</strong> and you construct a <strong class="source-inline">year</strong> object. For months, the chrono library defines named constants for all months of <span class="No-Break">the year.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a<a id="_idIndexMarker782"/> link to a list of the month constants in the chrono <span class="No-Break">library: </span><a href="https://en.cppreference.com/w/cpp/chrono/month"><span class="No-Break">https://en.cppreference.com/w/cpp/chrono/month</span></a><span class="No-Break">.</span></p>
<p>During the instantiation of the <strong class="source-inline">year_month_day</strong> object, we pass date values using <strong class="source-inline">operator/</strong>. As is visible from the preceding example, chrono supports many combinations of day, month, and year values. All of them can be found in the <span class="No-Break">standard documentation.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The following is a link to the documentation on all<a id="_idIndexMarker783"/> overloads of <strong class="source-inline">operator/</strong> for date <span class="No-Break">management: </span><a href="https://en.cppreference.com/w/cpp/chrono/operator_slash"><span class="No-Break">https://en.cppreference.com/w/cpp/chrono/operator_slash</span></a><span class="No-Break">.</span></p>
<p>All the used overloads in our example are supposed to create valid <strong class="source-inline">year_month_date</strong> objects. Let’s see <span class="No-Break">the output:</span></p>
<pre class="console">
2023-07-05
2023-10-01
2023-01-27</pre> <p>As we can see, we have successfully created three separate valid dates with the help of chrono literals <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">operator/</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>Working with time zones in C++</h2>
<p>The C++20 <strong class="source-inline">chrono</strong> library <a id="_idIndexMarker784"/>provides capabilities for working <a id="_idIndexMarker785"/>with time zones. It integrates the IANA time zone database, which contains information about the local time in many geographical locations around <span class="No-Break">the globe.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Find more information about the<a id="_idIndexMarker786"/> IANA time zone database <span class="No-Break">here: </span><a href="https://www.iana.org/time-zones"><span class="No-Break">https://www.iana.org/time-zones</span></a><span class="No-Break">.</span></p>
<p>Using <strong class="source-inline">chrono</strong>, you can get a copy of the IANA database and browse it for a specific <span class="No-Break">geographical location:</span></p>
<pre class="source-code">
using namespace std::chrono;
const tzdb&amp; tzdb{get_tzdb()};
const std::vector&lt;time_zone&gt;&amp; tzs{tzdb.zones};
for (const time_zone&amp; tz : tzs) {
    std::cout &lt;&lt; tz.name() &lt;&lt; '\n';
}</pre> <p>As we can see from the example, in the <strong class="source-inline">std::chrono</strong> namespace, there is a method – <strong class="source-inline">get_tzdb()</strong> – that returns a reference to the IANA database. In the database, you can find information about its version and also get a sorted list of all available <span class="No-Break"><strong class="source-inline">std::chrono::time_zone</strong></span><span class="No-Break"> objects.</span></p>
<p>The <strong class="source-inline">std::chrono::time_zone</strong> class stores information about transitions between time zones for its specific geographic area and name. The output from the preceding example is <span class="No-Break">as follows:</span></p>
<pre class="console">
Africa/Abidjan
Africa/Accra
Africa/Addis_Ababa
Africa/Algiers
Africa/Asmara
Africa/Bamako
...</pre> <p>Now, once<a id="_idIndexMarker787"/> we have all available time zones, let’s try to find a specific<a id="_idIndexMarker788"/> one based on a geographical location and see what the time <span class="No-Break">is there:</span></p>
<pre class="source-code">
using namespace std::chrono;
const tzdb&amp; tzdb{get_tzdb()};
const std::vector&lt;time_zone&gt;&amp; tzs{tzdb.zones};
const auto&amp; res{std::find_if(tzs.begin(), tzs.end(), []
  (const time_zone&amp; tz){
    std::string name{tz.name()};
    return name.ends_with("Sofia");
})};
if (res != tzs.end()) {
    try {
        const std::string_view myLocation{res-&gt;name()};
        const std::string_view london{"Europe/London"};
        const time_point now{system_clock::now()};
        const zoned_time zt_1{myLocation, now};
        const zoned_time zt_2{london, now};
        std::cout &lt;&lt; myLocation &lt;&lt; ": " &lt;&lt; zt_1 &lt;&lt; '\n';
        std::cout &lt;&lt; london &lt;&lt; ": " &lt;&lt; zt_2 &lt;&lt; '\n';
    } catch (const std::runtime_error&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}</pre> <p>In this example, we again get the list of the available time zones and try to find the time zone for the city of <strong class="source-inline">Sofia</strong>. Then, we <a id="_idIndexMarker789"/>use the full name of the found time zone to create another object that uses a specific geographical location and the value of the system time – <strong class="source-inline">std::chrono::zoned_time</strong>. This class represents a logical pair between a time zone <a id="_idIndexMarker790"/>and a point in time. We also create another <strong class="source-inline">zoned_time zt_2</strong> object but for the city of <strong class="source-inline">London</strong>, which represents the same time point as <strong class="source-inline">zt_1</strong> but in another geographical location. The result of the preceding code is <span class="No-Break">as follows:</span></p>
<pre class="console">
Europe/Sofia: 2023-08-05 13:43:53.503184619 EEST
Europe/London: 2023-08-05 11:43:53.503184619 BST</pre> <p>As you can see, both objects display a valid time but with respect to their geographical locations. This is how we can safely get the current time in a specific geographical location where daylight saving time is <span class="No-Break">also considered.</span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Summary</h1>
<p>In this chapter, we explored the different timers available within the Linux environment. Subsequently, we gained an understanding of the significance behind the clock epoch and the concept of UNIX time. Following this, we delved into the practical implementation of POSIX in Linux for accurate time measurement. Additionally, we investigated the realm of <strong class="source-inline">std::chrono</strong> and examined the array of capabilities that C++ affords for effective time-related operations. Our exploration then took us on a detailed journey through duration, timepoints, and clocks as they are defined within the <strong class="source-inline">std::chrono</strong> framework. Moving forward, we acquainted ourselves with the various clock types at our disposal within <strong class="source-inline">std::chrono</strong>. As our journey continued, we initiated our exploration into the calendar capabilities presented by <strong class="source-inline">std::chrono</strong>. Finally, we developed familiarity with time zones and honed our proficiency in executing seamless time conversions utilizing the tools offered by <strong class="source-inline">std::chrono</strong>. Now, we are ready for the next chapter, where we will go deeper into the specifics of the C++ <span class="No-Break">memory model.</span></p>
</div>
</div></body></html>