<html><head></head><body><div><h1 class="header-title">Qt GUI Programming</h1>
                
            
            
                
<p>This chapter will help you learn how to use Qt to develop applications with a graphical user interface using the Qt Creator IDE. We will get familiar with the core Qt functionality, widgets, layouts, and the signals and slots mechanism that we will later use to create complex systems such as games. We will also cover the various actions and resource systems of Qt. By the end of this chapter, you will be able to write your own programs that communicate with the user through windows and widgets.</p>
<p>The main topics covered in this chapter are as listed:</p>
<ul>
<li>Windows and widgets</li>
<li>Creating a Qt Widgets project and implementing a tic-tac-toe game</li>
<li>Creating widgets with or without the visual form editor</li>
<li>Using layouts to automatically position widgets</li>
<li>Creating and using signals and slots</li>
<li>Using the Qt resource system</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating GUI in Qt</h1>
                
            
            
                
<p>As described in <a href="e9cbf2c5-ac0b-494f-9293-2fb16c98524f.xhtml">Chapter 1</a>, <em>Introduction to Qt,</em> Qt consists of multiple modules. In this chapter, you will learn how to use the Qt Widgets module. It allows you to create classic desktop applications. The <strong>user interface</strong> (<strong>UI</strong>) of these applications consists of <em>widgets</em>.</p>
<p>A widget is a fragment of the UI with a specific look and behavior. Qt provides a lot of built-in widgets that are widely used in applications: labels, text boxes, checkboxes, buttons, and so on. Each of these widgets is represented as an instance of a C++ class derived from <kbd>QWidget</kbd> and provides methods for reading and writing the widget's content. You may also create your own widgets with custom content and behavior.</p>
<p>The base class of <kbd>QWidget</kbd> is <kbd>QObject</kbd>—the most important Qt class that contains multiple useful features. In particular, it implements parent–child relationships between objects, allowing you to organize a collection of objects in your program. Each object can have a parent object and an arbitrary number of children. Making a parent–child relationship between two objects has multiple consequences. When an object is deleted, all its children will be automatically deleted as well. For widgets, there is also a rule that a child occupies an area within the boundaries of its parent. For example, a typical form includes multiple labels, input fields, and buttons. Each of the form's elements is a widget, and the form is their parent widget.</p>
<p>Each widget has a separate coordinate system that is used for painting and event handling within the widget. By default, the origin of this coordinate system is placed in its top-left corner. The child's coordinate system is relative to its parent.</p>
<p>Any widget that is not included into another widget (that is, any <em>top-level widget</em>) becomes a window, and the desktop operating system will provide it with a window frame, which usually usually allows the user to drag around, resize, and close the window (although the presence and content of the window frame can be configured).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Creating a Qt Widgets project</h1>
                
            
            
                
<p>The first step to develop an application with Qt Creator is to create a project using one of the templates provided by the IDE.</p>
<p>From the File menu of Qt Creator, choose New File or Project. There are a number of project types to choose from. Follow the given steps for creating a Qt Desktop project:</p>
<ol>
<li>For a widget-based application, choose the Application group and the Qt Widgets Application template, as shown in the following screenshot:</li>
</ol>
<div><img src="img/7fae213c-deb5-4553-93a3-06f55a5ba55f.png" style="width:52.33em;height:32.50em;" width="896" height="557"/></div>
<ol start="2">
<li>The next step is to choose a name and location for your new project:</li>
</ol>
<div><img src="img/8f6078f9-14e4-4d4b-a70e-0a6e1d22c9b0.png" style="width:51.00em;height:26.75em;" width="908" height="476"/></div>
<ol start="3">
<li>We will create a simple tic-tac-toe game, so we will name our project <kbd>tictactoe</kbd> and provide a nice location for it.</li>
</ol>
<p>If you have a common directory where you put all your projects, you can tick the Use as default project location checkbox for Qt Creator to remember the location and suggest it the next time you start a new project.</p>
<ol start="4">
<li>Next, you need to select the kit (or multiple kits) you want to use with the project. Select the Desktop Qt kit corresponding to the Qt version you want to use:</li>
</ol>
<div><img src="img/467d3550-06b1-4e9c-a21b-3dce8473bf43.png" style="width:39.75em;height:20.83em;" width="908" height="476"/></div>
<ol start="5">
<li>Now you will be presented with the option of creating the first widget for your project. We want to create a widget that will represent the main window of our application, so we can leave the Class name and Base class fields unchanged. We also want to use the visual form editor to edit the content of the main window, so Generate form should also be left checked:</li>
</ol>
<div><img src="img/7591085e-6445-4456-a9b5-c3b3d00af83a.png" style="width:40.50em;height:21.25em;" width="908" height="476"/></div>
<ol start="6">
<li>Then, click on Next and Finish.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>Creator created a new subdirectory in the directory that you previously chose for the location of the project. This new directory (the <strong>project directory</strong>) now contains a number of files. You can use the Projects pane of Qt Creator to list and open these files (refer to <a href="d129202d-f982-4114-b69a-094d0a136fe9.xhtml">Chapter 2</a>, <em>Installation</em>, for an explanation of Qt Creator's basic controls). Let's go through these files.</p>
<p>The <kbd>main.cpp</kbd> file contains an implementation of the <kbd>main()</kbd> function, the entry point of the application, as the following code shows:</p>
<pre>#include "mainwindow.h"
#include &lt;QApplication&gt;
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}</pre>
<p>The <kbd>main()</kbd> function creates an instance of the <kbd>QApplication</kbd> class and feeds it with variables containing the command-line arguments. Then, it instantiates our <kbd>MainWindow</kbd> class, calls its <kbd>show</kbd> method, and finally, returns a value returned by the <kbd>exec</kbd> method of the application object.</p>
<p><kbd>QApplication</kbd> is a singleton class that manages the whole application. In particular, it is responsible for processing events that come from within the application or from external sources. For events to be processed, an event loop needs to be running. The loop waits for incoming events and dispatches them to proper routines. Most things in Qt are done through events: input handling, redrawing, receiving data over the network, triggering timers, and so on. This is the reason we say that Qt is an event-oriented framework. Without an active event loop, the event handling would not function properly. The <kbd>exec()</kbd> call in <kbd>QApplication</kbd> (or, to be more specific, in its base class—<kbd>QCoreApplication</kbd>) is responsible for entering the main event loop of the application. The function does not return until your application requests the event loop to be terminated. When that eventually happens, the <kbd>main</kbd> function returns and your application ends.</p>
<p>The <kbd>mainwindow.h</kbd> and the <kbd>mainwindow.cpp</kbd> files implement the <kbd>MainWindow</kbd> class. For now, there is almost no code in it. The class is derived from <kbd>QMainWindow</kbd> (which, in turn, is derived from <kbd>QWidget</kbd>), so it inherits a lot of methods and behavior from its base class. It also contains a <kbd>Ui::MainWindow *ui</kbd> field, which is initialized in the constructor and deleted in the destructor. The constructor also calls the <kbd>ui-&gt;setupUi(this);</kbd> function.</p>
<p><kbd>Ui::MainWindow</kbd> is an <em>automatically generated</em> class, so there is no declaration of it in the source code. It will be created in the build directory when the project is built. The purpose of this class is to set up our widget and fill it with content based on changes in the form editor. The automatically generated class is not a <kbd>QWidget</kbd>. In fact, it contains only two methods: <kbd>setupUi</kbd>, which performs the initial setup, and <kbd>retranslateUi</kbd>, which updates visible text when the UI language is changed. All widgets and other objects added in the form editor are available as public fields of the <kbd>Ui::MainWindow</kbd> class, so we can access them from within the <kbd>MainWindow</kbd> method as <kbd>ui-&gt;objectName</kbd>.</p>
<p><kbd>mainwindow.ui</kbd> is a form file that can be edited in the visual form editor. If you open it in Qt Creator by double-clicking on it in the Projects pane, Qt Creator will switch to the Design mode. If you switch back to the Edit mode, you will see that this file is actually an XML file containing the hierarchy and properties of all objects edited in Design mode. During the building of the project, a special tool called the User Interface Compiler converts this XML file to the implementation of the <kbd>Ui::MainWindow</kbd> class used in the <kbd>MainWindow</kbd> class.</p>
<p>Note that you don't need to edit the XML file by hand or edit any code in the <kbd>Ui::MainWindow</kbd> class. Making changes in the visual editor is enough to apply them to your <kbd>MainWindow</kbd> class and make the form's objects available to it.</p>
<p>The final file that was generated is called <kbd>tictactoe.pro</kbd> and is the project configuration file. It contains all the information that is required to build your project using the tools that Qt provides. Let's analyze this file (less important directives are omitted):</p>
<pre>QT += core gui
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
TARGET = tictactoe
TEMPLATE = app
SOURCES += main.cpp mainwindow.cpp
HEADERS += mainwindow.h
FORMS   += mainwindow.ui</pre>
<p>The first two lines enable Qt's <kbd>core</kbd>, <kbd>gui</kbd>, and <kbd>widgets</kbd> modules. The <kbd>TEMPLATE</kbd> variable is used to specify that your project file describes an application (as opposed to, for example, a library). The <kbd>TARGET</kbd> variable contains the name of the produced executable (<kbd>tictactoe</kbd>). The last three lines list all files that should be used to build the project.</p>
<p>In fact, <kbd>qmake</kbd> enables Qt Core and Qt GUI modules by default, even if you don't specify them explicitly in the project file. You can opt out of using a default module if you want. For example, you can disable Qt GUI by adding <kbd>QT -= gui</kbd> to the project file.</p>
<p>Before we proceed, let's tell the build system that we want to use C++11 features (such as lambda expressions, scoped enumerations, and range-based <kbd>for</kbd> loops) in our project by adding the following line to <kbd>tictactoe.pro</kbd>:</p>
<pre>CONFIG += c++11</pre>
<p>If we do this, the C++ compiler will receive a flag indicating that C++11 support should be enabled. This may not be needed if your compiler has C++11 support enabled by default. If you wish to use C++14 instead, use <kbd>CONFIG += c++14</kbd>.</p>
<p>What we have now is a complete Qt Widgets project. To build and run it, simply choose the Run entry from the Build drop-down menu or click on the green triangle icon on the left-hand side of the Qt Creator window. After a while, you should see a window pop up. Since we didn't add anything to the window, it is blank:</p>
<div><img src="img/c36a602d-54b2-493c-999d-221be9aee14d.png" style="width:21.08em;height:14.92em;" width="326" height="231"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Design mode interface</h1>
                
            
            
                
<p>Open the <kbd>mainwindow.ui</kbd> file and examine Qt Creator's Design mode:</p>
<div><img src="img/ae9da791-315a-46de-a371-c7b5ecbe36da.png" width="1288" height="1050"/></div>
<p>The Design mode consists of five major parts (they are marked on this screenshot):</p>
<ul>
<li>The central area <strong>(1)</strong> is the main worksheet. It contains a graphical representation of the form being designed where you can move widgets around, compose them into layouts, and see how they react. It also allows further manipulation of the form using the point-and-click method that we will learn later.</li>
<li>The toolbox <strong>(2)</strong> is located in the left part of the window. It contains a list of available types of widget that are arranged into groups containing items with a related or similar functionality. Over the list, you can see a box that lets you filter widgets that are displayed in the list to show only those that match the entered expression. At the beginning of the list, there are also items that are not really widgets—one group contains layouts, and the other one contains so-called spacers, which are a way to push other items away from each other or create an empty space in layouts. The main purpose of the toolbox is to add items to the form in the worksheet. You can do that by grabbing a widget from the list with the mouse, dragging it to the widget in the central area, and releasing the mouse button.</li>
<li>The two tabs <strong>(3)</strong> in the lower part of the window—Action Editor and Signal/Slot Editor—allow us to create helper entities such as actions for the menus and toolbars or signal-slot connections between widgets.</li>
<li>The object tree <strong>(4)</strong> is situated in the top-right corner and contains the hierarchy tree of the form's items. The object name and class name of each item added to the form is displayed in the tree. The topmost item corresponds to the form itself. You can use both the central area and the object tree to select the existing items and access their context menu (for example, if you want to delete an item, you can select the Remove... option in the context menu).</li>
<li>The property editor <strong>(5)</strong> is located in the bottom-right corner. It allows you to view and change the values of all the properties of the item currently selected in the central area and the object tree. Properties are grouped by their classes that they have been declared in, starting from <kbd>QObject</kbd> (the base class implementing properties), which declares only one, but an important, property—<kbd>objectName</kbd>. Following <kbd>QObject</kbd>, there are properties declared in <kbd>QWidget</kbd>, which is a direct descendant of <kbd>QObject</kbd>. They are mainly related to the geometry and layout policies of the widget. Further down the list, you can find properties that come from further derivations of <kbd>QWidget</kbd>, down to the concrete class of the selected widget. The Filter field above the properties can help you find the needed property quickly.</li>
</ul>
<p>Taking a closer look at the property editor, you can see that some of them have <img src="img/878f5938-5dc5-4247-815b-fd27c6847e4f.png" style="width:0.67em;height:0.67em;" width="9" height="9"/> arrows, which reveal new rows when clicked. These are composed properties where the complete property value is determined from more than one subproperty value; for example, if there is a property called <kbd>geometry</kbd> that defines a rectangle, it can be expanded to show four subproperties: <kbd>x</kbd>, <kbd>y</kbd>, <kbd>width</kbd>, and <kbd>height</kbd>. Another thing that you may quickly note is that some property names are displayed in bold. This means that the property value was modified and is different from the default value for this property. This lets you quickly find the properties that you have modified.</p>
<p>If you changed a property's value but decided to stick to the default value later, you should click on the corresponding input field and then click on the small button with an arrow to its right: <img src="img/8f2757a2-9cb3-4982-be2e-51a37e5a5693.png" width="16" height="18"/>. This is not the same as setting the original value by hand. For example, if you examine the <br/>
<kbd>spacing</kbd> property of some layouts, it would appear as if it had some constant default value for (example, 6). However, the actual default value depends on the style the application uses and may be different on a different operating system, so the only way to set the default value is to use the dedicated button and ensure that the property is not displayed in bold anymore.</p>
<p>If you prefer a purely alphabetical order where properties are not grouped by their class, you can switch the view using a pop-up menu that becomes available after you click on the wrench icon positioned over the property list; however, once you get familiar with the hierarchy of Qt classes, it will be much easier to navigate the list when it is sorted by class affinity.</p>
<p>What was described here is the basic tool layout. If you don't like it, you can invoke the context menu from the main worksheet, uncheck the Automatically Hide View Title Bars entry, and use the title bars that appear to re-arrange all the panes to your liking, or even close the ones you don't currently need.</p>
<p>Now that you are familiar with the structure of the visual form editor, you can finally add some content to our widget. We are making a tic-tac-toe game with local multiplayer, so we need some way of displaying which of the two players currently moves. Let's put the game board in the center of the window and display the names of the players above and below the board. When a player needs to move, we will make the corresponding name's font bold. We also need a button that will start a new game.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Adding widgets to the form</h1>
                
            
            
                
<p>Locate the Label item in the toolbox (it's in the Display Widgets category) and drag it to our form. Use the property editor to set the <kbd>objectName</kbd> property of the label to <kbd>player1Name</kbd>. <kbd>objectName</kbd> is a unique identifier of a form item. The object name is used as the name of the public field in the <kbd>Ui::MainWindow</kbd> class, so the label will be available as <kbd>ui-&gt;player1Name</kbd> in the <kbd>MainWindow</kbd> class (and will have a <kbd>QLabel *</kbd> type). Then, locate the <kbd>text</kbd> property in the property editor (it will be in the <kbd>QLabel</kbd> group, as it is the class that introduces the property) and set it to <kbd>Player 1</kbd>. You will see that the text in the central area will be updated accordingly. Add another label, set its <kbd>objectName</kbd> to <kbd>player2Name</kbd> and its <kbd>text</kbd> to <kbd>Player 2</kbd>.</p>
<p>You can select a widget in the central area and press the <em>F2</em> key to edit the text in place. Another way is to double-click on the widget in the form. It works for any widget that can display text.</p>
<p>Drag a Push Button (from the Buttons group) to the form and use the <em>F2</em> key to rename it to <kbd>Start new game</kbd>. If the name does not fit in the button, you can resize it using the blue rectangles on its edges. Set the <kbd>objectName</kbd> of the button to <kbd>startNewGame</kbd>.</p>
<p>There is no built-in widget for our game board, so we will need to create a custom widget for it later. For now, we will use an empty widget. Locate Widget in the Containers group of the toolbox and drag it to the form. Set its <kbd>objectName</kbd> to <kbd>gameBoard</kbd>:</p>
<div><img src="img/0f1336ea-897d-4ace-9ebd-f5712e43bf78.png" width="1288" height="1050"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Layouts</h1>
                
            
            
                
<p>If you build and run the project now, you will see the window with two labels and a button, but they will remain in the exact positions you left them. This is what you almost never want. Usually, it is desired that widgets are automatically resized based on their content and the size of their neighbors. They need to adjust to the changes of the window's size (or, in contrast, the window size may need to be restricted based on possible sizes of the widgets inside of it). This is a very important feature for a cross-platform application, as you cannot assume any particular screen resolution or size of controls. In Qt, all of this requires us to use a special mechanism called <strong>layouts</strong>.</p>
<p>Layouts allow us to arrange the content of a widget, ensuring that its space is used efficiently. When we set a layout on a widget, we can start adding widgets, and even other layouts, and the mechanism will resize and reposition them according to the rules that we specify. When something happens in the user interface that influences how widgets should be displayed (for example, the label text is replaced with longer text, which makes the label require more space to show its content), the layout is triggered again, which recalculates all positions and sizes and updates widgets, as necessary.</p>
<p>Qt comes with a predefined set of layouts that are derived from the <kbd>QLayout</kbd> class, but you can also create your own. The ones that we already have at our disposal are <kbd>QHBoxLayout</kbd> and <kbd>QVBoxLayout</kbd>, which position items horizontally and vertically; <kbd>QGridLayout</kbd>, which arranges items in a grid so that an item can span across columns or rows; and <kbd>QFormLayout</kbd>, which creates two columns of items with item descriptions in one column and item content in the other. There is also <kbd>QStackedLayout</kbd>, which is rarely used directly and which makes one of the items assigned to it possess all the available space. You can see the most common layouts in action in the following figure:</p>
<div><img src="img/401450d2-7946-4d74-9b6c-c9633953cf59.png" style="width:36.83em;height:12.75em;" width="520" height="180"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Adding a layout to the form</h1>
                
            
            
                
<p>Select the MainWindow top-level item in the object tree and click on <img class="" src="img/edc2e5c8-bc8c-41e1-8d0b-44e277ab5230.png" style="width:1.67em;height:1.58em;" width="25" height="24"/> , the Lay Out Vertically icon in the upper toolbar. The button, labels, and the empty widget will be automatically resized to take all the available space of the form in the central area:</p>
<div><img src="img/b51f5675-9922-4430-aac7-544903be7cbd.png" width="1288" height="1050"/></div>
<p>If the items were arranged in a different order, you can drag and drop them to change the order.</p>
<p>Run the application and check that the window's contents are automatically positioned and resized to use all the available space when the window is resized. Unfortunately, the labels take more vertical space than they really require, resulting in an empty space in the application window. We will fix this issue later in this chapter when we learn about size policies.</p>
<p>You can test the layouts of your form without building and running the whole application. Open the Tools menu, go to the Form Editor submenu, and choose the Preview entry. You will see a new window open that looks exactly like the form we just designed. You can resize the window and interact with the objects inside to monitor the behavior of the layouts and widgets. What really happened here is that Qt Creator built a real window for us based on the description that we provided in all the areas of the design mode. Without any compilation, in a blink of an eye, we received a fully working window with all the layouts working and all the properties adjusted to our liking. This is a very important tool, so ensure that you use it often to verify that your layouts are controlling all the widgets as you intended them to—it is much faster than compiling and running the whole application just to check whether the widgets stretch or squeeze properly. You can also resize the form in the central area of the form editor by dragging its bottom-right corner, and if the layouts are set up correctly, the contents should be resized and repositioned.</p>
<p>Now that you can create and display a form, two important operations need to be implemented. First, you need to receive notifications when the user interacts with your form (for example, presses a button) to perform some actions in the code. Second, you need to change the properties of the form's contents programmatically, and fill it with real data (for example, set player names from the code).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Signals and slots</h1>
                
            
            
                
<p>To trigger functionality as a response to something that happens in an application, Qt uses a mechanism of signals and slots. This is another important feature of the <kbd>QObject</kbd> class. It's based on connecting a notification (which Qt calls a <strong>signal</strong>) about a change of state in some object with a function or method (called a <strong>slot</strong>) that is executed when such a notification arises. For example, if a button is pressed, it <strong>emits</strong> (sends) a <kbd>clicked()</kbd> signal. If some method is connected to this signal, the method will be called whenever the button is pressed.</p>
<p>Signals can have arguments that serve as a payload. For example, an input box widget (<kbd>QLineEdit</kbd>) has a <kbd>textEdited(const QString &amp;text)</kbd> signal that's emitted when the user edits the text in the input box. A slot connected to this signal will receive the new text in the input box as its argument (provided it has an argument).</p>
<p>Signals and slots can be used with all classes that inherit <kbd>QObject</kbd> (including all widgets). A signal can be connected to a slot, member function, or functor (which includes a regular global function). When an object emits a signal, any of these entities that are connected to that signal will be called. A signal can also be connected to another signal, in which case emitting the first signal will make the other signal be emitted as well. You can connect any number of slots to a single signal and any number of signals to a single slot.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating signals and slots</h1>
                
            
            
                
<p>If you create a <kbd>QObject</kbd> subclass (or a <kbd>QWidget</kbd> subclass, as QWidget inherits QObject), you can mark a method of this class as a signal or a slot. If the parent class had any signals or non-private slots, your class will also inherit them.</p>
<p>In order for signals and slots to work properly, the class declaration must contain the <kbd>Q_OBJECT</kbd> macro in a private section of its definition (Qt Creator has generated it for us). When the project is built, a special tool called <strong>Meta-Object Compiler</strong> (<strong>moc</strong>) will examine the class's header and generate some extra code necessary for signals and slots to work properly.</p>
<p>Keep in mind that <strong>moc</strong> and all other Qt build tools do not edit the project files. Your C++ files are passed to the compiler without any changes. All special effects are achieved by generating separate C++ files and adding them to the compilation process.</p>
<p>A signal can be created by declaring a class method in the <kbd>signals</kbd> section of the class declaration:</p>
<pre>signals:
    void valueChanged(int newValue);</pre>
<p>However, we don't implement such a method; this will be done automatically by <strong>moc</strong>. We can send (<kbd>emit</kbd>) the signal by calling the method. There is a convention that a signal call should be preceded by the <kbd>emit</kbd> macro.  This macro has no effect (it's actually a blank macro), but it helps us clarify our intent to emit the signal:</p>
<pre>void MyClass::setValue(int newValue) {
    m_value = newValue;
    <strong>emit valueChanged(newValue);</strong>
}</pre>
<p>You should only emit signals from within the class methods, as if it were a protected function.</p>
<p>Slots are class methods declared in the <kbd>private slots</kbd>, <kbd>protected slots</kbd>, or <kbd>public slots</kbd> section of the class declaration. Contrary to signals, slots need to be implemented. Qt will call the slot when a signal connected to it is emitted. The visibility of the slot (private, protected, or public) should be chosen using the same principles as for normal methods.</p>
<p>The C++ standard only describes three types of sections of the class definition (<kbd>private</kbd>, <kbd>protected</kbd>, and <kbd>public</kbd>), so you may wonder how these special sections work. They are actually simple macros: the <kbd>signals</kbd> <br/>macro expands to <kbd>public</kbd>, and <kbd>slots</kbd> is a blank macro. So, the compiler treats them as normal methods. These keywords are, however, used by <strong>moc</strong> to determine how to generate the extra code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Connecting signals and slots</h1>
                
            
            
                
<p>Signals and slots can be connected and disconnected dynamically using the  <kbd>QObject::connect()</kbd> and <kbd>QObject::disconnect()</kbd> functions. A regular, signal-slot connection is defined by the following four attributes:</p>
<ul>
<li>An object that changes its state (sender)</li>
<li>A signal in the sender object</li>
<li>An object that contains the function to be called (receiver)</li>
<li>A slot in the receiver</li>
</ul>
<p>If you want to make the connection, you need to call the <kbd>QObject::connect</kbd> function and pass these four parameters to it. For example, the following code can be used to clear the input box whenever the button is clicked on:</p>
<pre>connect(button,   &amp;QPushButton::clicked,
        lineEdit, &amp;QLineEdit::clear);</pre>
<p>Signals and slots in this code are specified using a standard C++ feature called pointers to member functions. Such a pointer contains the name of the class and the name of the method (in our case, signal or slot) in that class. Qt Creator's code autocompletion will help you write connect statements. In particular, if you press <em>Ctrl</em> + <em>Space</em> after <br/><kbd>connect(button, &amp;</kbd>, it will insert the name of the class, and if you do that after <kbd>connect(button, &amp;QPushButton::</kbd>, it will suggest one of the available signals (in another context, it would suggest all the existing methods of the class).</p>
<p>Note that you can't set the arguments of signals or slots when making a connection. Arguments of the source signal are always determined by the function that emits the signal. Arguments of the receiving slot (or signal) are always the same as the arguments of the source signal, with two exceptions:</p>
<ul>
<li>If the receiving slot or signal has fewer arguments than the source signal, the remaining arguments are ignored. For example, if you want to use the  <kbd>valueChanged(int)</kbd> signal but don't care about the passed value, you can connect this signal to a slot without arguments.</li>
<li>If the types of the corresponding arguments are not the same, but an implicit conversion between them exists, that conversion is performed. This means that you can, for example, connect a signal carrying a <kbd>double</kbd> value with a slot taking an <kbd>int</kbd> parameter.</li>
</ul>
<p>If the signal and the slot do not have compatible signatures, you will get a compile-time error.</p>
<p>An existing connection is automatically destroyed after the sender or the receiver objects are deleted. Manual disconnection is rarely needed. The <kbd>connect()</kbd> function returns a connection handle that can be passed to <kbd>disconnect()</kbd>. Alternatively, you can call  <kbd>disconnect()</kbd> with the same arguments the <kbd>connect()</kbd> was called with to undo the connection.</p>
<p>You don't always need to declare a slot to perform a connection. It's possible to connect a signal to a standalone function:</p>
<pre>connect(button, &amp;QPushButton::clicked, someFunction); </pre>
<p>The function can also be a lambda expression, in which case it is possible to write the code directly in the <kbd>connect</kbd> statement:</p>
<pre>connect(pushButton, &amp;QPushButton::clicked, []()
{
    qDebug() &lt;&lt; "clicked!";
});</pre>
<p>It can be useful if you want to invoke a slot with a fixed argument value that can't be carried by a signal because it has less arguments. A solution is to invoke the slot from a lambda function (or a standalone function):</p>
<pre>connect(pushButton, &amp;QPushButton::clicked, [label]()
{
    label-&gt;setText("button was clicked");
});</pre>
<p>A function can even be replaced with a function object (functor). To do this, we create a class, for which we overload the call operator that is compatible with the signal that we wish to connect to, as shown in the following code snippet:</p>
<pre>class Functor {<br/>public:<br/>    Functor(const QString &amp;name) : m_name(name) {}<br/><strong>    void operator()(bool toggled) const {</strong><br/><strong>        qDebug() &lt;&lt; m_name &lt;&lt; ": button state changed to" &lt;&lt; toggled;</strong><br/><strong>    }</strong><br/>private:<br/>    QString m_name;<br/>};<br/><br/>int main(int argc, char *argv[])<br/>{<br/>    QApplication a(argc, argv);<br/>    QPushButton *button = new QPushButton();<br/>    button-&gt;setCheckable(true);<br/><strong>    QObject::connect(button, &amp;QPushButton::toggled,</strong><br/><strong>                     Functor("my functor"));</strong><br/>    button-&gt;show();<br/>    return a.exec();<br/>}</pre>
<p>This is often a nice way to execute a slot with an additional parameter that is not carried by the signal, as this is much cleaner than using a lambda expression. However, keep in mind that automatic disconnection will not happen when the object referenced in the lambda expression or the functor is deleted. This can lead to a use-after-free bug.</p>
<p>While it is actually possible to connect a signal to a method of a <kbd>QObject</kbd>-based class that is not a slot, doing this is not recommended. Declaring the method as a slot shows your intent better. Additionally, methods that are not slots are not available to Qt at runtime, which is required in some cases.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Old connect syntax</h1>
                
            
            
                
<p>Before Qt 5, the old connect syntax was the only option. It looks as follows:</p>
<pre>connect(spinBox, SIGNAL(valueChanged(int)),
        dial,    SLOT(setValue(int)));</pre>
<p>This statement establishes a connection between the signal of the <kbd>spinBox</kbd> object called <kbd>valueChanged</kbd> that carries an <kbd>int</kbd> parameter and a <kbd>setValue</kbd> slot in the <kbd>dial</kbd> object that accepts an <kbd>int</kbd> parameter. It is forbidden to put argument names or values in a <br/><kbd>connect</kbd> statement. Qt Creator is usually able to suggest all possible inputs in this context if you press <em>Ctrl</em> + <em>Space</em> after <kbd>SIGNAL(</kbd> or <kbd>SLOT(</kbd>.</p>
<p>While this syntax is still available, we discourage its wide use, because it has the following drawbacks:</p>
<ul>
<li>If the signal or the slot is incorrectly referenced (for example, its name or argument types are incorrect) or if argument types of the signals and the slot are not compatible, there will be no compile-time error, only a runtime warning. The new syntax approach performs all the necessary checks at compile time.</li>
<li>The old syntax doesn't support casting argument values to another type (for example, connect a signal carrying a <kbd>double</kbd> value with a slot taking an  <kbd>int</kbd> parameter).</li>
<li>The old syntax doesn't support connecting a signal to a standalone function, a lambda expression, or a functor.</li>
</ul>
<p>The old syntax also uses macros and may look unclear to developers not familiar with Qt. It's hard to say which syntax is easier to read (the old syntax displays argument types, while the new syntax displays the class name instead). However, the new syntax has a big disadvantage when using overloaded signals or slots. The only way to resolve the overloaded function type is to use an explicit cast:</p>
<pre>connect(spinBox,
        static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged), <br/>        ...);</pre>
<p>The old connect syntax includes argument types, so it doesn't have this issue. In this case, the old syntax may look more acceptable, but compile-time checks may still be considered more valuable than shorter code. In this book, we prefer the new syntax, but use the old syntax when working with overloaded methods for the sake of clarity.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Signal and slot access specifiers</h1>
                
            
            
                
<p>As mentioned earlier, you should only emit signals from the class that owns it or from its subclasses. However, if signals were really protected or private, you would not be able to connect to them using the pointer-to-member function syntax. To make such connections possible, signals are made public functions. This means that the compiler won't stop you from calling the signal from outside. If you want to prevent such calls, you can declare <kbd>QPrivateSignal</kbd> as the last argument of the signal:</p>
<pre>signals:<br/>    void valueChanged(int value, QPrivateSignal);</pre>
<p><kbd>QPrivateSignal</kbd> is a private struct created in each <kbd>QObject</kbd> subclass by the <kbd>Q_OBJECT</kbd> macro, so you can only create <kbd>QPrivateSignal</kbd> objects in the current class.</p>
<p>Slots can be public, protected, or private, depending on how you want to restrict access to them. When using the pointer to a member function syntax for connection, you will only be able to create pointers to slots if you have access to them. It's also correct to call a slot directly from any other location as long as you have access to it.</p>
<p>That being said, Qt doesn't really support restricting access to signals and slots. Regardless of how a signal or a slot is declared, you can always access it using the old connect syntax. You can also call any signal or slot using the <kbd>QMetaObject::invokeMethod</kbd> method. While you can restrict direct C++ calls to reduce the possibility of errors, keep in mind that the users of your API still can access any signal or slot if they really want to.</p>
<p>There are some aspects of signals and slots that we have not covered here. We will discuss them later when we deal with multithreading (<em>Online Chapter, </em><a href="https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf" target="_blank">https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf</a>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Receiving the button-click signal from the form</h1>
                
            
            
                
<p>Open the <kbd>mainwindow.h</kbd> file and create a <kbd>private slots</kbd> section in the class declaration, then declare the <kbd>startNewGame()</kbd> private slot, as shown in the following code:</p>
<pre>class MainWindow : public QMainWindow<br/>{<br/>    Q_OBJECT<br/>public:<br/>    explicit MainWindow(QWidget *parent = nullptr);<br/>    ~MainWindow();<br/><strong>private slots:</strong><br/><strong>    void startNewGame();</strong><br/>}</pre>
<p>To quickly implement a freshly declared method, we can ask Qt Creator to create the skeleton code for us by positioning the text cursor at the method declaration, pressing  <em>Alt </em>+<em> Enter</em> on the keyboard, and choosing Add definition in tictactoewidget.cpp from the popup.</p>
<p>It also works the other way round. You can write the method body first and then position the cursor on the method signature, press <em>Alt</em> + <em>Enter</em>, and choose Add (...) declaration from the quick-fix menu. There are also various other context-dependent fixes that are available in Creator.</p>
<p>Write the highlighted code in the implementation of this method:</p>
<pre>void MainWindow::startNewGame()
{
<strong>    qDebug() &lt;&lt; "button clicked!";</strong>
}</pre>
<p>Add <kbd>#include &lt;QDebug&gt;</kbd> to the top section of the <kbd>mainwindow.cpp</kbd> file to make the <kbd>qDebug()</kbd> macro available.</p>
<p>Finally, add a connect statement to the constructor after the <kbd>setupUi()</kbd> call:</p>
<pre>ui-&gt;setupUi(this);<br/><strong>connect(ui-&gt;startNewGame, &amp;QPushButton::clicked,</strong><br/><strong>        this, &amp;MainWindow::startNewGame);</strong></pre>
<p>Run the application and try clicking on the button. The <kbd>button clicked!</kbd> text should appear in the Application Output pane in the bottom part of Qt Creator's window (if the pane isn't activated, use the Application Output button in the bottom panel to open it):</p>
<div><img src="img/f6122bdb-7985-435f-a2ca-4e2919caa3c0.png" width="1187" height="953"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>We created a new private slot in the <kbd>MainWindow</kbd> class and connected the <kbd>clicked()</kbd> signal of the Start new game button to the slot. When the user clicks on the button, Qt will call our slot, and the code we wrote inside it gets executed.</p>
<p>Ensure that you put any operations with the form elements after the <kbd>setupUi()</kbd>  call. This function creates the elements, so <br/><kbd>ui-&gt;startNewGame</kbd> will simply be uninitialized before <kbd>setupUi()</kbd> is called, and attempting to use it will result in undefined behavior.</p>
<p><kbd>qDebug() &lt;&lt; ...</kbd> is a convenient way to print debug information to the <kbd>stderr</kbd> (standard error output) of the application process. It's quite similar to the <kbd>std::cerr &lt;&lt; ...</kbd> method available in the standard library, but it separates supplied values with spaces and appends a new line at the end.</p>
<p>Putting debug outputs everywhere quickly becomes inconvenient. Luckily, Qt Creator has powerful integration with C++ debuggers, so you can use Debug mode to check whether some particular line is executing, see the current values of the local variables at that location, and so on. For example, try setting a break point at the line containing <kbd>qDebug()</kbd> by clicking on the space to the left of the line number (a red circle indicating the break point should appear). Click on the Start Debugging button (a green triangle with a bug at the bottom-left corner of Qt Creator), wait for the application to launch, and press the Start new game button. When the application enters the break point location, it will pause, and Qt Creator's window will be brought to the front. The yellow arrow over the break point circle will indicate the current step of the execution. You can use the buttons below the code editor to continue execution, stop, or execute the process in steps. Learning to use the debugger becomes very important when developing large applications. We will talk more about using the debugger later (<em>Online</em> <em>Chapter, </em><a href="https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf" target="_blank">https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf</a>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Automatic slot connection and its drawbacks</h1>
                
            
            
                
<p>Qt also offers an easier way to make a connection between signals of the form's elements and the slots of the class. You can right-click on the button in the central area of the form editor and select the Go to slot... option. You will be prompted to select one of the signals available in the button's class (<kbd>QPushButton</kbd>). After you select the <kbd>clicked()</kbd> signal, Qt Creator will automatically add a new <kbd>on_startNewGame_clicked</kbd> slot to our  <kbd>MainWindow</kbd> class.</p>
<p>The tricky part is that there is no <kbd>connect()</kbd> call that enforces the connection. How is the button's signal connected to this slot, then? The answer is Qt's automatic slot connection feature. When the constructor calls the <kbd>ui-&gt;setupUi(this)</kbd> function, it creates the widgets and other objects in the form and then calls the <kbd>QMetaObject::connectSlotsByName</kbd> method. This method looks at the list of slots existing in the widget class (in our case, <kbd>MainWindow</kbd>) and searches for ones that have their name in an <kbd>on_&lt;object name&gt;_&lt;signal name&gt;</kbd><br/>
pattern, where <kbd>&lt;object name&gt;</kbd> is the <kbd>objectName</kbd> of an existing child widget and <kbd>&lt;signal name&gt;</kbd> is the name of one of this widget's signals. In our case, a button called <kbd>startNewGame</kbd> is a child widget of our widget, and it has a <kbd>clicked</kbd> signal, so this signal is automatically connected to an <kbd>on_startNewGame_clicked</kbd> slot.</p>
<p>While this is a really convenient feature, it has many drawbacks:</p>
<ul>
<li>It makes your application harder to maintain. If you rename or remove the form element, you have to update or remove the slot manually. If you forget to do that, the application will only produce a warning at runtime when the automatic connection fails. In a large application, especially when not all forms are instantiated at the start of the application, there is a significant risk that you will miss the warning and the application will not work as intended.</li>
<li>You have to use a specific name for the slot (for example,  <kbd>on_startNewGame_clicked()</kbd> instead of a clean-looking <kbd>startNewGame()</kbd>).</li>
<li>Sometimes you want to connect signals from multiple objects to the same slot. Automatic slot connection doesn't provide a way to do this, and creating multiple slots just to call a single function will lead to unnecessary code bloat.</li>
<li>Automatic slot connection has a runtime cost, because it needs to examine the available children and slots and find the matching ones, but it's usually insignificant since it only runs when the form object is created.</li>
</ul>
<p>The basic approach shown in the previous section is much more maintainable. Making an explicit <kbd>connect()</kbd> call with pointers to member functions will ensure that both signal and slot are specified properly. If you rename or remove the button, it will immediately result in a compilation error that is impossible to miss. You are also free to choose a meaningful name for the slot, so you can make it part of your public API, if desired.</p>
<p>Considering all this, we advise against using the automatic slot connection feature, as the convenience does not outweigh the drawbacks.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Changing the texts on the labels from the code</h1>
                
            
            
                
<p>Printing text to the console is not as impressive as changing the text in our form. We don't have GUI for letting users enter their names yet, so we'll hardcode some names for now. Let's change the implementation of our slot to the following:</p>
<pre>void MainWindow::startNewGame()
{
    ui-&gt;player1Name-&gt;setText(tr("Alice"));
    ui-&gt;player2Name-&gt;setText(tr("Bob"));
}</pre>
<p>Now, when you run the application and click on the button, the labels in the form will change. Let's break down this code into pieces:</p>
<ul>
<li>As mentioned earlier, the first label's object is accessible in our class as <kbd>ui-&gt;player1Name</kbd> and has the <kbd>QLabel *</kbd> type.</li>
<li>We're calling the <kbd>setText</kbd> method of the <kbd>QLabel</kbd> class. This is the setter of the <kbd>text</kbd> property of <kbd>QLabel</kbd> (the same property that we edited in the property editor of the Design mode). As per Qt's naming convention, getters should have the same name as the property itself, and setters should have a <kbd>set</kbd> prefix, followed by the property name. You can set the text cursor on <kbd>setText</kbd> and press <em>F1</em> to learn more about the property and its access functions.</li>
<li>The <kbd>tr()</kbd> function (which is short for "translate") is used to translate the text to the current UI language of the application. We will describe the translation infrastructure of Qt in <a href="ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml">Chapter 6</a>, <em>Qt Core Essentials</em>. By default, this function returns the passed string unchanged, but it's a good habit to wrap any and all string literals that are displayed to the user in this function. Any user-visible text that you enter in the form editor is also subject to translation and is passed through a similar function automatically. Only strings that should not be affected by translation (for example, object names that are used as identifiers) should be created without the <kbd>tr()</kbd> function.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating a widget for the tic-tac-toe board</h1>
                
            
            
                
<p>Let's move on to implementing the board. It should contain nine buttons that can display "X" or "O" and allow the players to make their moves. We could add the button directly to the empty widget of our form. However, the behavior of the board is fairly separate from the rest of the form, and it will have quite a bit of logic inside. Following the encapsulation principle, we prefer implementing the board as a separate widget class. Then, we'll replace the empty widget in our main window with the board widget we created.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Choosing between designer forms and plain C++ classes</h1>
                
            
            
                
<p>One way of creating a custom widget is by adding a Designer Form Class to the project. Designer Form Class is a template provided by Qt Creator. It consists of a C++ class that inherits <kbd>QWidget</kbd> (directly or indirectly) and a designer form (<kbd>.ui</kbd> file), tied together by some automatically generated code. Our <kbd>MainWindow</kbd> class also follows this template.</p>
<p>However, if you try to use the visual form editor to create our tic-tac-toe board, you may find it quite inconvenient for this task. One problem is that you need to add nine identical buttons to the form manually. Another issue is accessing these buttons from the code when you need to make a signal connection or change the button's text. The <kbd>ui-&gt;objectName</kbd> approach is not applicable here because you can only access a concrete widget this way, so you'd have to resort to other means, such as the <kbd>findChild()</kbd> method that allows you to search for a child object by its name.</p>
<p>In this case, we prefer to add the buttons in the code, where we can make a loop, set up each button, and put them into an array for easy addressing. The process is pretty similar to how the designer forms operate, but we'll do it by hand. Of course, anything that the form editor can do is accessible through the API.</p>
<p>After you build the project, you can hold <em>Ctrl<strong> </strong></em>and click on <kbd>ui_mainwindow.h</kbd> at the beginning of <kbd>mainwindow.cpp</kbd> to see the code that actually sets up our main window. You should not edit this file, because your changes will not be persistent.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Creating a game board widget</h1>
                
            
            
                
<p>Locate the <kbd>tictactoe</kbd> folder in the project tree (it's the top-level entry corresponding to our whole project), open its context menu, and select Add New... Select C++ in the left list and C++ Class in the central list. Click on the Choose button, input <kbd>TicTacToeWidget</kbd> in the Class name field, and select QWidget in the Base class drop-down list. Click on Next and Finish. Qt Creator will create header and source files for our new class and add them to the project.</p>
<p>Open the <kbd>tictactoewidget.h</kbd> file in Creator and update it by adding the highlighted code:</p>
<pre>#ifndef TICTACTOEWIDGET_H
#define TICTACTOEWIDGET_H
#include &lt;QWidget&gt;
class TicTacToeWidget : public QWidget
{
    Q_OBJECT
public:
    TicTacToeWidget(QWidget *parent = nullptr);
    ~TicTacToeWidget();
<strong>private:
    QVector&lt;QPushButton*&gt; m_board;</strong>
};
#endif // TICTACTOEWIDGET_H </pre>
<p>Our additions create a <kbd>QVector</kbd> object (a container similar to <kbd>std::vector</kbd>) that can hold pointers to instances of the <kbd>QPushButton</kbd> class, which is the most commonly used button class in Qt. We have to include the Qt header containing the <kbd>QPushButton</kbd> declaration. Qt Creator can help us do this quickly. Set the text cursor on <kbd>QPushButton</kbd>, press <em>Alt </em>+ <em>Enter</em>, and select Add #include &lt;QPushButton&gt;. The include directive will appear at the beginning of the file. As you may have noted, each Qt class is declared in the header file that is called exactly the same as the class itself.</p>
<p>From now on, this book will not remind you about adding the include directives to your source code—you will have to take care of this by yourself. This is really easy; just remember that to use a Qt class you need to include a file named after that class.</p>
<p>The next step is to create all the buttons and use a layout to manage their geometries. Switch to the <kbd>tictactoewidget.cpp</kbd> file and locate the constructor.</p>
<p>You can use the <em>F4</em> key to switch between the corresponding header and the source files. You can also use the <em>F2</em> key to navigate from the definition of a method to its implementation, and back.</p>
<p>First, let's create a layout that will hold our buttons:</p>
<pre>QGridLayout *gridLayout = new QGridLayout(this);</pre>
<p>By passing the <kbd>this</kbd> pointer to the layout's constructor, we attached the layout to our widget. Then, we can start adding buttons to the layout:</p>
<pre>for(int row = 0; row &lt; 3; ++row) {
    for(int column = 0; column &lt; 3; ++column) {
        QPushButton *button = new QPushButton(" ");
        gridLayout-&gt;addWidget(button, row, column);
        m_board.append(button);
    }
} </pre>
<p>The code creates a loop over rows and columns of the board. In each iteration, it creates an instance of the <kbd>QPushButton</kbd> class. The content of each button is set to a single space so that it gets the correct initial size. Then, we add the button to the layout in <kbd>row</kbd> and <kbd>column</kbd>. At the end, we store the pointer to the button in the vector that was declared earlier. This lets us reference any of the buttons later on. They are stored in the vector in such an order that the first three buttons of the first row are stored first, then the buttons from the second row, and finally those from the last row.</p>
<p>This should be enough for testing the widget. Let's add it to our main window. Open the <kbd>mainwindow.ui</kbd> file. Invoke the context menu of the empty widget called <kbd>gameBoard</kbd> and choose Promote to. This allows us to <strong>promote</strong> a widget to another class, that is, substitute a widget in the form with an instance of another class.</p>
<p>In our case, we will want to replace the empty widget with our game board. Select QWidget in the Base class name list, because our <kbd>TicTacToeWidget</kbd> is inherited from <kbd>QWidget</kbd>. Input <kbd>TicTacToeWidget</kbd> into the Promoted class name field and verify that the Header file field contains the correct name of the class's header file, as illustrated:</p>
<div><img src="img/8ed6868c-75a7-4316-b77e-29c93b01c7ab.png" style="width:29.25em;height:28.58em;" width="504" height="492"/></div>
<p>Then, click on the button labeled Add and then Promote, to close the dialog and confirm the promotion. You will not note any changes in the form, because the replacement only takes place at runtime (however, you will see the <kbd>TicTacToeWidget</kbd> class name next to <kbd>gameBoard</kbd> in the object tree).</p>
<p>Run the application and check whether the game board appears in the main window:</p>
<div><img src="img/5464969a-5dfc-4cf3-af9b-f75a99f9dde0.png" style="width:27.50em;height:17.58em;" width="503" height="320"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>Not all widget types are directly available in the form designer. Sometimes, we need to use widget classes that will only be created in the project that is being built. The simplest way to be able to put a custom widget on a form is to ask the designer to replace the class name of a standard widget with a custom name. By promoting an object to a different class, we saved a lot of work trying to otherwise fit our game board into the user interface.</p>
<p>You are now familiar with two ways of creating custom widgets: you can use the form editor or add widgets from the code. Both approaches are valuable. When creating a new widget class in your project, choose the most convenient way depending on your current task.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Automatic deletion of objects</h1>
                
            
            
                
<p>You might have noted that although we created a number of objects in the constructor using the <kbd>new</kbd> operator, we didn't destroy those objects anywhere (for example, in the destructor). This is because of the way the memory is managed by Qt. Qt doesn't do any garbage collecting (as C# or Java does), but it has this nice feature related to <kbd>QObject</kbd> parent–child hierarchies. The rule is that whenever a <kbd>QObject</kbd> instance is destroyed, it also deletes all of its children. This is another reason to set parents to the objects that we create—if we do this, we don't have to care about explicitly freeing any memory.</p>
<p>Since all layouts and widgets inside our top-level widget (an instance of <kbd>MainWindow</kbd> class) are its direct or indirect children, they will all be deleted when the main window is destroyed. The <kbd>MainWindow</kbd> object is created in the <kbd>main()</kbd> function without the <kbd>new</kbd> keyword, so it will be deleted at the end of the application after <kbd>a.exec()</kbd> returns.</p>
<p>When working with widgets, it's pretty easy to verify that every object has a proper parent. You can assume that anything that is displayed inside the window is a direct or indirect child of that window. However, the parent–child relationship becomes less apparent when working with invisible objects, so you should always check that each object has a proper parent and therefore will be deleted at some point. For example, in our <kbd>TicTacToeWidget</kbd> class, the <kbd>gridLayout</kbd> object receives its parent through a constructor argument (<kbd>this</kbd>). The button objects are initially created without a parent, but the <kbd>addWidget()</kbd> function assigns a parent widget to them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Functionality of a tic-tac-toe board</h1>
                
            
            
                
<p>We need to implement a function that will be called upon by clicking on any of the nine buttons on the board. It has to change the text of the button that was clicked on—either "X" or "O"—based on which player made the move. It then has to check whether the move resulted in the game being won by the player (or a draw if no more moves are possible), and if the game ended, it should emit an appropriate signal, informing the environment about the event.</p>
<p>When the user clicks on a button, the <kbd>clicked()</kbd> signal is emitted. Connecting this signal to a custom slot lets us implement the mentioned functionality, but since the signal doesn't carry any parameters, how do we tell which button caused the slot to be triggered? We could connect each button to a separate slot, but that's an ugly solution. Fortunately, there are two ways of working around this problem. When a slot is invoked, a pointer to the object that caused the signal to be sent is accessible through a special method in <kbd>QObject</kbd>, called <kbd>sender()</kbd>. We can use that pointer to find out which of the nine buttons stored in the board list is the one that caused the signal to fire:</p>
<pre>void TicTacToeWidget::someSlot() {
    QPushButton *button = static_cast&lt;QPushButton*&gt;(sender());
    int buttonIndex = m_board.indexOf(button);
    // ...
} </pre>
<p>While <kbd>sender()</kbd> is a useful call, we should try to avoid it in our own code as it breaks some principles of object-oriented programming. Moreover, there are situations where calling this function is not safe. A better way is to use a dedicated class called <kbd>QSignalMapper</kbd>, which lets us achieve a similar result without using <kbd>sender()</kbd> directly. Modify the constructor of <kbd>TicTacToeWidget</kbd>, as follows:</p>
<pre>QGridLayout *gridLayout = new QGridLayout(this);
QSignalMapper *mapper = new QSignalMapper(this);
for(int row = 0; row &lt; 3; ++row) {
    for(int column = 0; column &lt; 3; ++column) {
        QPushButton *button = new QPushButton(" ");
        gridLayout-&gt;addWidget(button, row, column);
        m_board.append(button);
        mapper-&gt;setMapping(button, m_board.count() - 1);
        connect(button, SIGNAL(clicked()), mapper, SLOT(map()));
    }
}
connect(mapper, SIGNAL(mapped(int)),
        this,   SLOT(handleButtonClick(int)));</pre>
<p>Here, we first created an instance of <kbd>QSignalMapper</kbd> and passed a pointer to the board widget as its parent so that the mapper is deleted when the widget is deleted.</p>
<p>Almost all subclasses of <kbd>QObject</kbd> can receive a pointer to the parent object in the constructor. In fact, our <kbd>MainWindow</kbd> and <kbd>TicTacToeWidget</kbd> classes can also do that, thanks to the code Qt Creator generated in their constructors. Following this rule in custom <kbd>QObject</kbd>-based classes is recommended. While the parent argument is often optional, it's a good idea to pass it when possible, because objects will be automatically deleted when the parent is deleted. However, there are a few cases where this is redundant, for example, when you add a widget to a layout, the layout will automatically set the parent widget for it.</p>
<p>Then, when we create buttons, we "teach" the mapper that each of the buttons has a number associated with it—the first button will have the number <kbd>0</kbd>, the second one will be bound to the number <kbd>1</kbd>, and so on. By connecting the <kbd>clicked()</kbd> signal from the button to the mapper's <kbd>map()</kbd> slot, we tell the mapper to process that signal. When the mapper receives the signal from any of the buttons, it will find the mapping of the sender of the signal and emit another signal—<kbd>mapped()</kbd>—with the mapped number as its parameter. This allows us to connect to that signal with a new slot (<kbd>handleButtonClick()</kbd>) that takes the index of the button in the board list.</p>
<p>Before we create and implement the slot, we need to create a useful enum type and a few helper methods. First, add the following code to the public section of the class declaration in the <kbd>tictactoewidget.h</kbd> file:</p>
<pre>enum class Player {
    Invalid, Player1, Player2, Draw
};
Q_ENUM(Player)</pre>
<p>This enum lets us specify information about players in the game. The <kbd>Q_ENUM</kbd> macro will make Qt recognize the enum (for example, it will allow you to pass the values of this type to <kbd>qDebug()</kbd> and also make serialization easier). Generally, it's a good idea to use <kbd>Q_ENUM</kbd> for any enum in a <kbd>QObject</kbd>-based class.</p>
<p>We can use the <kbd>Player</kbd> enum immediately to mark whose move it is now. To do so, add a private field to the class:</p>
<pre>Player m_currentPlayer; </pre>
<p>Don't forget to give the new field an initial value in the constructor:</p>
<pre>m_currentPlayer = Player::Invalid;</pre>
<p>Then, add the two public methods to manipulate the value of this field:</p>
<pre>Player currentPlayer() const <br/>{ <br/>    return m_currentPlayer; <br/>}<br/>void setCurrentPlayer(Player p)
{
    if(m_currentPlayer == p) {
        return;
    }
    m_currentPlayer = p;
    emit currentPlayerChanged(p);
} </pre>
<p>The last method emits a signal, so we have to add the signal declaration to the class definition along with another signal that we will use:</p>
<pre>signals:
    void currentPlayerChanged(Player);
    void gameOver(Player); </pre>
<p>We only emit the <kbd>currentPlayerChanged</kbd> signal when the current player really changes. You always have to pay attention that you don't emit a "changed" signal when you set a value to a field to the same value that it had before the function was called. Users of your classes expect that if a signal is called changed, it is emitted when the value really changes. Otherwise, this can lead to an infinite loop in signal emissions if you have two objects that connect their value setters to the other object's changed signal.</p>
<p>Now it is time to implement the slot itself. First, declare it in the header file:</p>
<pre>private slots:
    void handleButtonClick(int index);</pre>
<p>Use  <em>Alt </em>+ <em>Enter</em> to quickly generate a definition for the new method, as we did earlier.</p>
<p>When any of the buttons is pressed, the <kbd>handleButtonClick()</kbd> slot will be called. The index of the button clicked on will be received as the argument. We can now implement the slot in the <kbd>.cpp</kbd> file:</p>
<pre>void TicTacToeWidget::handleButtonClick(int index)
{
    if (m_currentPlayer == Player::Invalid) {
        return; // game is not started
    }
    if(index &lt; 0 || index &gt;= m_board.size()) {
        return; // out of bounds check
    }
    QPushButton *button = m_board[index];
    if(button-&gt;text() != " ") return; // invalid move
    button-&gt;setText(currentPlayer() == Player::Player1 ? "X" : "O");
    Player winner = checkWinCondition();
    if(winner == Player::Invalid) {
        setCurrentPlayer(currentPlayer() == Player::Player1 ?
                         Player::Player2 : Player::Player1);
        return;
    } else {
        emit gameOver(winner);
    }
}</pre>
<p>Here, we first retrieve a pointer to the button based on its index. Then, we check whether the button contains an empty space—if not, then it's already occupied, so we return from the method so that the player can pick another field in the board. Next, we set the current player's mark on the button. Then, we check whether the player has won the game. If the game didn't end, we switch the current player and return; otherwise, we emit a <kbd>gameOver()</kbd> signal, telling our environment who won the game. The <kbd>checkWinCondition()</kbd> method returns <kbd>Player1</kbd>, <kbd>Player2</kbd>, or <kbd>Draw</kbd> if the game has ended, and <kbd>Invalid</kbd> otherwise. We will not show the implementation of this method here, as it is quite lengthy. Try implementing it on your own, and if you encounter problems, you can see the solution in the code bundle that accompanies this book.</p>
<p>The last thing we need to do in this class is to add another public method for starting a new game. It will clear the board and set the current player:</p>
<pre>void TicTacToeWidget::initNewGame() {
    for(QPushButton *button: m_board) {
        button-&gt;setText(" ");
    }
    setCurrentPlayer(Player::Player1);
}</pre>
<p>Now we only need to call this method in the <kbd>MainWindow::startNewGame</kbd> method:</p>
<pre>void MainWindow::startNewGame()
{
    ui-&gt;player1Name-&gt;setText(tr("Alice"));
    ui-&gt;player2Name-&gt;setText(tr("Bob"));
    ui-&gt;gameBoard-&gt;initNewGame();
}</pre>
<p>Note that <kbd>ui-&gt;gameBoard</kbd> actually has a <kbd>TicTacToeWidget *</kbd> type, and we can call its methods even though the form editor doesn't know anything specific about our custom class. This is the result of the <em>promoting</em> that we did earlier.</p>
<p>It's time to see how all this works together! Run the application, click on the Start new game button, and you should be able to play some tic-tac-toe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Reacting to the game board's signals</h1>
                
            
            
                
<p>While writing a turn-based board game, it is a good idea to always clearly mark whose turn it is now to make a move. We will do this by marking the moving player's name in bold. There is already a signal in the board class that tells us that the current player has changed, which we can react to update the labels.</p>
<p>We need to connect the board's <kbd>currentPlayerChanged</kbd> signal to a new slot in the <kbd>MainWindow</kbd> class. Let's add appropriate code into the <kbd>MainWindow</kbd> constructor:</p>
<pre>ui-&gt;setupUi(this);
connect(ui-&gt;gameBoard, &amp;TicTacToeWidget::currentPlayerChanged,
        this, &amp;MainWindow::updateNameLabels);</pre>
<p>Now, for the slot itself, declare the following methods in the <kbd>MainWindow</kbd> class:</p>
<pre>private:<br/>    void setLabelBold(QLabel *label, bool isBold);<br/>private slots:<br/>    void updateNameLabels();</pre>
<p>Now implement them using the following code:</p>
<pre>void MainWindow::setLabelBold(QLabel *label, bool isBold)
{
    QFont f = label-&gt;font();
    f.setBold(isBold);
    label-&gt;setFont(f);
}

void MainWindow::updateNameLabels()
{
    setLabelBold(ui-&gt;player1Name,
        ui-&gt;gameBoard-&gt;currentPlayer() == <br/>            TicTacToeWidget::Player::Player1);
    setLabelBold(ui-&gt;player2Name,
        ui-&gt;gameBoard-&gt;currentPlayer() == <br/>            TicTacToeWidget::Player::Player2);
}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p><kbd>QWidget</kbd> (and, by extension, any widget class) has a <kbd>font</kbd> property that determines the properties of the font this widget uses. This property has the <kbd>QFont</kbd> type. We can't just write <kbd>label-&gt;font()-&gt;setBold(isBold);</kbd>, because <kbd>font()</kbd> returns a const reference, so we have to make a copy of the <kbd>QFont</kbd> object. That copy has no connection to the label, so we need to call <kbd>label-&gt;setFont(f)</kbd> to apply our changes. To avoid repetition of this procedure, we created a helper function, called <kbd>setLabelBold</kbd>.</p>
<p>The last thing that needs to be done is to handle the situation when the game ends. Connect the <kbd>gameOver()</kbd> signal from the board to a new slot in the main window class. Implement the slot as follows:</p>
<pre>void MainWindow::handleGameOver(TicTacToeWidget::Player winner) {
    QString message;
    if(winner == TicTacToeWidget::Player::Draw) {
        message = tr("Game ended with a draw.");
    } else {
        QString winnerName = winner == TicTacToeWidget::Player::Player1 ?
                    ui-&gt;player1Name-&gt;text() : ui-&gt;player2Name-&gt;text();
        message = tr("%1 wins").arg(winnerName);
    }
    QMessageBox::information(this, tr("Info"), message);
}</pre>
<p>This code checks who won the game, assembles the message (we will learn more about <kbd>QString</kbd> in <a href="ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml">Chapter 6</a>, <em>Qt Core Essentials</em>), and shows it using a static method <kbd>QMessageBox::information()</kbd> that shows a modal dialog containing the message and a button that allows us to close the dialog.</p>
<p>Run the game and check that it now highlights the current player and shows the message when the game ends.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Advanced form editor usage</h1>
                
            
            
                
<p>Now it's time to give the players a way to input their names. We will do that by adding a game configuration dialog that will appear when starting a new game.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Designing the game configuration dialog</h1>
                
            
            
                
<p>First, select Add New... in the context menu of the tictactoe project and choose to create a new Qt Designer Form Class, as shown in the following screenshot:</p>
<div><img src="img/bdc07682-129e-4dde-8333-1f0d9c9d9814.png" style="width:49.08em;height:30.17em;" width="888" height="546"/></div>
<p>In the window that appears, choose Dialog with Buttons Bottom:</p>
<div><img src="img/ce1d80a0-cc52-43b7-8578-c3f657a15be8.png" style="width:49.75em;height:32.75em;" width="834" height="549"/></div>
<p>Adjust the class name to <kbd>ConfigurationDialog</kbd>, leave the rest of the settings at their default values, and complete the wizard. The files that appear in the project (<kbd>.cpp</kbd>, <kbd>.h</kbd>, and <kbd>.ui</kbd>) are very similar to the files generated for the <kbd>MainWindow</kbd> class when we created our project. The only difference is that <kbd>MainWindow</kbd> uses <kbd>QMainWindow</kbd> as its base class, and <kbd>ConfigurationDialog</kbd> uses <kbd>QDialog</kbd>. Also, a <kbd>MainWindow</kbd> instance is created in the <kbd>main</kbd> function, so it shows when the application is started, while we'll need to create a <kbd>ConfigurationDialog</kbd> instance somewhere else in the code. <kbd>QDialog</kbd> implements behavior that is common for dialogs; in addition to the main content, it displays one or multiple buttons. When the dialog is selected, the user can interact with the dialog and then press one of the buttons. After this, the dialog is usually destroyed. <kbd>QDialog</kbd> has a convenient <kbd>exec()</kbd> method that doesn't return until the user makes a choice, and then it returns information about the pressed button. We will see that in action after we finish creating the dialog.</p>
<p>Drag and drop two labels and two line edits on the form, position them roughly in a grid, double-click on each of the labels, and adjust their captions to receive a result similar to the following:</p>
<div><img src="img/eb639bb0-adb9-435b-a282-71a731156d62.png" style="width:15.50em;height:8.33em;" width="259" height="138"/></div>
<p>Change the <kbd>objectName</kbd> property of the line edits to <kbd>player1Name</kbd> and <kbd>player2Name</kbd>. Then, click on some empty space in the form and choose the Layout in a grid entry in the upper toolbar. You should see the widgets snap into place—that's because you have just applied a layout to the form. Open the Tools menu, go to the Form Editor submenu, and choose the Preview entry to preview the form.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Accelerators and label buddies</h1>
                
            
            
                
<p>Now, we will focus on giving the dialog some more polish. The first thing we will do is add accelerators to our widgets. These are keyboard shortcuts that, when activated, cause particular widgets to gain keyboard focus or perform a predetermined action (for example, toggle a checkbox or push a button). Accelerators are usually marked by underlining them, as follows:</p>
<div><img src="img/819ca76d-6b77-4915-ac24-28a12dd42bd1.png" style="width:14.42em;height:3.08em;" width="177" height="38"/></div>
<p>We will set accelerators to our line edits so that when the user activates an accelerator for the first field, it will gain focus. Through this, we can enter the name of the first player, and, similarly, when the accelerator for the second line edit is triggered, we can start typing in the name for the second player.</p>
<p>Start by selecting the first label on the left-hand side of the first line edit. Press <em>F2</em> and change the text to <kbd>Player &amp;A Name:</kbd>. The <kbd>&amp;</kbd> character marks the character directly after it as an accelerator for the widget. Accelerators may not work with digits on some platforms, so we decided to use a letter instead. Similarly, rename the second label to <kbd>Player &amp;B Name:</kbd>.</p>
<p>For widgets that are composed of both text and the actual functionality (for example, a button), this is enough to make accelerators work. However, since <kbd>QLineEdit</kbd> does not have any text associated with it, we have to use a separate widget for that. This is why we have set the accelerator on the label. Now we need to associate the label with the line edit so that the activation of the label's accelerator will forward it to the widget of our choice. This is done by setting a so-called <strong>buddy</strong> for the label. You can do this in code using the <kbd>setBuddy</kbd> method of the <kbd>QLabel</kbd> class or using Creator's form designer. Since we're already in the Design mode, we'll use the latter approach. For that, we need to activate a dedicated mode in the form designer.</p>
<p>Look at the upper part of Creator's window; directly above the form, you will find a toolbar containing a couple of icons. Click on the one labeled Edit buddies <img src="img/bd8d678d-e636-412f-9615-94b0a118a51f.png" width="18" height="18"/>. Now, move the mouse cursor over the label, press the mouse button, and drag from the label toward the line edit. When you drag the label over the line edit, you'll see a graphical visualization of a connection being set between the label and the line edit. If you release the button now, the association will be made permanent. You should note that when such an association is made, the ampersand character (<kbd>&amp;</kbd>) vanishes from the label, and the character behind it gets an underscore. Repeat this for the other label and corresponding line edit. Click on the Edit widgets <img src="img/20601812-6569-4f11-bf91-8da1075bde0f.png" width="18" height="18"/> button above the form to return the form editor to the default mode. Now, you can preview the form again and check whether accelerators work as expected; pressing <em>Alt</em> + <em>A</em> and <em>Alt</em> + <em>B</em> should set the text cursor to the first and second text field, respectively.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The tab order</h1>
                
            
            
                
<p>While you're previewing the form, you can check another aspect of the UI design. Note which line edit receives the focus when the form is open. There is a chance that the second line edit will be activated first. To check and modify the order of focus, close the preview and switch to the tab order editing mode by clicking on the icon called Edit Tab Order <img src="img/460bf650-c6b2-4fd7-9aee-5964deaa583d.png" width="18" height="18"/> in the toolbar.</p>
<p>This mode associates a box with a number to each focusable widget. By clicking on the rectangle in the order you wish the widgets to gain focus, you can reorder values, thus re-ordering focus. Now make it so that the order is as shown here:</p>
<div><img src="img/3acd881b-1e37-4f41-8996-68deac128a55.png" style="width:19.17em;height:9.00em;" width="340" height="160"/></div>
<p>Our form only has two widgets that can receive focus (except for the dialog's buttons, but their tab order is managed automatically). If you create a form with multiple controls, there is a good chance that when you press the <em>Tab</em> key repeatedly, the focus will start jumping back and forth between buttons and line edits instead of a linear progress from top to bottom (which is an intuitive order for this particular dialog). You can use this mode to correct the tab order.</p>
<p>Enter the preview again and check whether the focus changes according to what you've set.</p>
<p>When deciding about the tab order, it is good to consider which fields in the dialog are mandatory and which are optional. It is a good idea to allow the user to tab through all the mandatory fields first, then to the dialog confirmation button (for example, one that says OK or Accept), and then cycle through all the optional fields. Thanks to this, the user will be able to quickly fill all the mandatory fields and accept the dialog without the need to cycle through all the optional fields that the user wants to leave as their default values.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Public interface of the dialog</h1>
                
            
            
                
<p>The next thing to do is to allow to store and read player names from outside the dialog—since the <kbd>ui</kbd> component is private, there is no access to it from outside the class code. This is a common situation and one that Qt is also compliant with. Each data field in almost every Qt class is private and may contain accessors (a getter and optionally a setter), which are public methods that allow us to read and store values for data fields. Our dialog has two such fields—the names for the two players.</p>
<p>Names of setter methods in Qt are usually started with <kbd>set</kbd>, followed by the name of the property with the first letter converted to uppercase. In our situation, the two setters will be called <kbd>setPlayer1Name</kbd> and <kbd>setPlayer2Name</kbd>, and they will both accept <kbd>QString</kbd> and return <kbd>void</kbd>. Declare them in the class header, as shown in the following code snippet:</p>
<pre>void setPlayer1Name(const QString &amp;p1name);
void setPlayer2Name(const QString &amp;p2name); </pre>
<p>Implement their bodies in the <kbd>.cpp</kbd> file:</p>
<pre>void ConfigurationDialog::setPlayer1Name(const QString &amp;p1name)
{
    ui-&gt;player1Name-&gt;setText(p1name);
}
void ConfigurationDialog::setPlayer2Name(const QString &amp;p2name)
{
    ui-&gt;player2Name-&gt;setText(p2name);
} </pre>
<p>Getter methods in Qt are usually called the same as the property that they are related to—<kbd>player1Name</kbd> and <kbd>player2Name</kbd>. Put the following code in the header file:</p>
<pre>QString player1Name() const;
QString player2Name() const;</pre>
<p>Put the following code in the implementation file:</p>
<pre>QString ConfigurationDialog::player1Name() const
{
    return ui-&gt;player1Name-&gt;text();
}
QString ConfigurationDialog::player2Name() const
{
    return ui-&gt;player2Name-&gt;text();
}</pre>
<p>Our dialog is now ready. Let's use it in the <kbd>MainWindow::startNewGame</kbd> function to request player names before starting the game:</p>
<pre>ConfigurationDialog dialog(this);
if(dialog.exec() == QDialog::Rejected) {
    return; // do nothing if dialog rejected
}
ui-&gt;player1Name-&gt;setText(dialog.player1Name());
ui-&gt;player2Name-&gt;setText(dialog.player2Name());
ui-&gt;gameBoard-&gt;initNewGame();</pre>
<p>In this slot, we create the settings dialog and show it to the user, forcing them to enter player names. The <kbd>exec()</kbd> function doesn't return until the dialog is accepted or cancelled. If the dialog was canceled, we abandon the creation of a new game. Otherwise, we ask the dialog for player names and set them on appropriate labels. Finally, we initialize the board so that users can play the game. The dialog object was created without the <kbd>new</kbd> keyword, so it will be deleted immediately after this.</p>
<p>Now you can run the application and see how the configuration dialog works.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Polishing the application</h1>
                
            
            
                
<p>We have implemented all the important functionalities of our game, and now we will start improving it by exploring other Qt features.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Size policies</h1>
                
            
            
                
<p>If you change the height of the main window of our game, you will note that different widgets are resized in a different way. In particular, buttons retain their original height, and labels gain empty fields to the top and bottom of the text:</p>
<div><img src="img/71d369a8-8ea3-4326-a746-134750868752.png" style="width:16.83em;height:19.42em;" width="300" height="346"/></div>
<p>This is because each widget has a property called <kbd>sizePolicy</kbd>, which decides how a widget is to be resized by a layout. You can set separate size policies for horizontal and vertical directions. A button has a vertical size policy of <kbd>Fixed</kbd> by default, which means that the height of the widget will not change from the default height regardless of how much space there is available. A label has a <kbd>Preferred</kbd> size policy by default. The following are the available size policies:</p>
<ul>
<li><kbd>Ignored</kbd>: In this, the default size of the widget is ignored and the widget can freely grow and shrink</li>
<li><kbd>Fixed</kbd>: In this, the default size is the only allowed size of the widget</li>
<li><kbd>Preferred</kbd>: In this, the default size is the desired size, but both smaller and bigger sizes are acceptable</li>
<li><kbd>Minimum</kbd>: In this, the default size is the smallest acceptable size for the widget, but the widget can be made larger without hurting its functionality</li>
<li><kbd>Maximum</kbd>: In this, the default size is the largest size of the widget, and the widget can be shrunk (even to nothing) without hurting its functionality</li>
<li><kbd>Expanding</kbd>: In this, the default size is the desired size; a smaller size (even zero) is acceptable, but the widget is able to increase its usefulness when more and more space is assigned to it</li>
<li><kbd>MinimumExpanding</kbd>: This is a combination of <kbd>Minimum</kbd> and <kbd>Expanding</kbd>—the widget is greedy in terms of space, and it cannot be made smaller than its default size</li>
</ul>
<p>How do we determine the default size? The answer is by the size returned by the <kbd>sizeHint</kbd> virtual method. For layouts, the size is calculated based on the sizes and size policies of their child widgets and nested layouts. For basic widgets, the value returned by <kbd>sizeHint</kbd> depends on the content of the widget. In the case of a button, if it holds a line of text and an icon, <kbd>sizeHint</kbd> will return the size that is required to fully encompass the text, icon, some space between them, the button frame, and the padding between the frame and content itself.</p>
<p>In our form, we prefer that when the main window is resized, the labels will keep their height, and the game board buttons will grow. To do this, open <kbd>mainwindow.ui</kbd> in the form editor, select the first label, and then hold <em>Ctrl</em> and click on the second label. Now both labels are selected, so we can edit their properties at the same time. Locate <kbd>sizePolicy</kbd> in the property editor (if you're having trouble locating a property, use the Filter field above the property editor) and expand it by clicking on the triangle to its left. Set Vertical Policy to Fixed. You will see the changes in the form's layout immediately.</p>
<p>The buttons on the game board are created in the code, so navigate to the constructor of <kbd>TicTacToeWidget</kbd> class and set the size policy using the following code:</p>
<pre>QPushButton *button = new QPushButton(" ");
button-&gt;setSizePolicy(QSizePolicy::Preferred,
                      QSizePolicy::Preferred);</pre>
<p>This will change both the horizontal and vertical policy of buttons to <kbd>Preferred</kbd>. Run the game and observe the changes:</p>
<div><img src="img/13866103-ac2b-41ff-b074-c4013aa6241f.png" style="width:20.50em;height:23.75em;" width="373" height="431"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Protecting against invalid input</h1>
                
            
            
                
<p>The configuration dialog did not have any validation until now. Let's make it such that the button to accept the dialog is only enabled when neither of the two line edits is empty (that is, when both the fields contain player names). To do this, we need to connect the  <kbd>textChanged</kbd> signal of each line edit to a slot that will perform the task.</p>
<p>First, go to the <kbd>configurationdialog.h</kbd> file and create a private slot <kbd>void updateOKButtonState();</kbd> in the <kbd>ConfigurationDialog</kbd> class (you will need to add the <kbd>private slots</kbd> section manually). Use the following code to implement this slot:</p>
<pre>void ConfigurationDialog::updateOKButtonState()
{
    QPushButton *okButton = ui-&gt;buttonBox-&gt;button(QDialogButtonBox::Ok);
    okButton-&gt;setEnabled(!ui-&gt;player1Name-&gt;text().isEmpty() &amp;&amp;
                         !ui-&gt;player2Name-&gt;text().isEmpty());
}</pre>
<p>This code asks the button box that currently contains the OK and Cancel buttons to give a pointer to the button that accepts the dialog (we have to do that because the buttons are not contained in the form directly, so there are no fields for them in <kbd>ui</kbd>). Then, we set the button's <kbd>enabled</kbd> property based on whether both player names contain valid values or not.</p>
<p>Next, edit the constructor of the dialog to connect two signals to our new slot. The button state also needs to be updated when we first create the dialog, so add an invocation of <kbd>updateOKButtonState()</kbd> to the constructor:</p>
<pre>ui-&gt;setupUi(this);<br/><strong>connect(ui-&gt;player1Name, &amp;QLineEdit::textChanged,</strong><br/><strong>        this, &amp;ConfigurationDialog::updateOKButtonState);</strong><br/><strong>connect(ui-&gt;player2Name, &amp;QLineEdit::textChanged,</strong><br/><strong>        this, &amp;ConfigurationDialog::updateOKButtonState);</strong><br/><strong>updateOKButtonState();</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Main menu and toolbars</h1>
                
            
            
                
<p>As you may remember, any widget that has no parent will be displayed as a window. However, when we created our main window, we selected <kbd>QMainWindow</kbd> as the base class. If we had selected <kbd>QWidget</kbd> instead, we would still be able to do everything we did up to this point. However, the <kbd>QMainWindow</kbd> class provides some unique functionality that we will now use.</p>
<p>A main window represents the control center of an application. It can contain menus, toolbars, docking widgets, a status bar, and the <em>central widget</em> that contains the main content of the window, as shown in the following diagram:</p>
<div><img src="img/d1058ef8-d0f9-4068-92b8-2a1520a7134a.png" style="width:20.25em;height:18.42em;" width="1082" height="984"/></div>
<p>If you open the <kbd>mainwindow.ui</kbd> file and take a look at the object tree, you will see the mandatory <kbd>centralWidget</kbd> that actually contains our form. There are also optional <kbd>menuBar</kbd>, <kbd>mainToolBar</kbd>, and <kbd>statusBar</kbd> that were added automatically when Qt Creator generated the form.</p>
<p>The central widget part doesn't need any extra explanation; it is a regular widget like any other. We will also not focus on dock widgets or the status bar here. They are useful components, but you can learn about them yourself. Instead, we will spend some time mastering menus and toolbars. You have surely seen and used toolbars and menus in many applications, and you know how important they are for a good user experience.</p>
<p>The main menu has a bit of unusual behavior. It's usually positioned in the top part of the window, but in macOS and some Linux environments, the main menu is separated from the window and displayed in the top area of the screen. Toolbars, on the other hand, can be moved freely by the user and docked horizontally or vertically to the sides of the main window.</p>
<p>The main class shared by both these concepts is <kbd>QAction</kbd>, which represents a functionality that can be invoked by a user. A single action can be used in multiple places—it can be an entry in a menu (the <kbd>QMenu</kbd> instances) or in a toolbar (<kbd>QToolBar</kbd>), a button, or a keyboard shortcut (<kbd>QShortcut</kbd>). Manipulating the action (for example, changing its text) causes all its incarnations to update. For example, if you have a Save entry in the menu (with a keyboard shortcut bound to it), a Save icon in the toolbar, and maybe also a Save button somewhere else in your user interface and you want to disallow saving the document (for example, a map in your dungeons and dragons game level editor) because its contents haven't changed since the document was last loaded. In this case, if the menu entry, toolbar icon, and button are all linked to the same <kbd>QAction</kbd> instance, then, once you set the <kbd>enabled</kbd> property of the action to <kbd>false</kbd>, all the three entities will become disabled as well. This is an easy way to keep different parts of your application in sync—if you disable an action object, you can be sure that all entries that trigger the functionality represented by the action are also disabled. Actions can be instantiated in code or created graphically using Action Editor in Qt Creator. An action can have different pieces of data associated with it—a text, tooltip, status bar tip, icons, and others that are less often used. All these are used by incarnations of your actions.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Creating a menu and a toolbar</h1>
                
            
            
                
<p>Let's replace our boring Start new game button with a menu entry and a toolbar icon. First, select the button and press the <em>Delete</em> key to delete it. Then, locate Action Editor in the bottom-center part of the form editor and click on the New button on its toolbar. Enter the following values in the dialog (you can fill the Shortcut field by pressing the key combination you want to use):</p>
<div><img src="img/51eab088-b6dd-4d37-b0a0-2a20a99ed886.png" style="width:21.17em;height:16.67em;" width="377" height="296"/></div>
<p>Locate the toolbar in the central area (between the Type Here text and the first label) and drag the line containing the New Game action from the action editor to the toolbar, which results in a button appearing in the toolbar.</p>
<p>To create a menu for the window, double-click on the Type Here text on the top of the form and replace the text with <kbd>&amp;File</kbd> (although our application doesn't work with files, we will follow this tradition). Then, drag the New Game action from the action editor over the newly created menu, but do not drop it there yet. The menu should open now, and you can drag the action so that a red bar appears in the submenu in the position where you want the menu entry to appear; now you can release the mouse button to create the entry.</p>
<p>Now we should restore the functionality that was broken when we deleted the button. Navigate to the constructor of the <kbd>MainWindow</kbd> class and adjust the <kbd>connect()</kbd> call:</p>
<pre>connect(ui-&gt;startNewGame, <strong>&amp;QAction::triggered</strong>,<br/>        this, &amp;MainWindow::startNewGame);</pre>
<p>Actions, like widgets, are accessible through the <kbd>ui</kbd> object. The <kbd>ui-&gt;startNewGame</kbd> object is now a <kbd>QAction</kbd> instead of a <kbd>QPushButton</kbd>, and we use its <kbd>triggered()</kbd> signal to detect whether the action was selected in some way.</p>
<p>Now, if you run the application, you can select the menu entry, press a button on the toolbar, or press the <em>Ctrl</em> + <em>N</em> keys. Either of these operations will cause the action to emit the <kbd>triggered()</kbd> signal, and the game configuration dialog should appear.</p>
<p>Like widgets, <kbd>QAction</kbd> objects have some useful methods that are accessible in our form class. For example, executing <kbd>ui-&gt;startNewGame-&gt;setEnabled(false)</kbd> will disable all ways to trigger the New Game action.</p>
<p>Let's add another action for quitting the application (although the user can already do it just by closing the main window). Use the action editor to add a new action with text <kbd>Quit</kbd>, object name <kbd>quit</kbd>, and shortcut <em>Ctrl</em> + <em>Q</em>. Add it to the menu and the toolbar, like the first action.</p>
<p>We can add a new slot that stops the application, but such a slot already exists in <kbd>QApplication</kbd>, so let's just reuse it. Locate the constructor of our form in <kbd>mainwindow.cpp</kbd> and append the following code:</p>
<pre>connect(ui-&gt;quit, &amp;QAction::triggered,
        qApp,     &amp;QApplication::quit);</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>The <kbd>qApp</kbd> macro is a shortcut for a function that returns a pointer to the application singleton object, so when the action is triggered, Qt will call the <kbd>quit()</kbd> slot on the <kbd>QApplication</kbd> object created in <kbd>main()</kbd>, which, in turn, will cause the application to end.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Qt resource system</h1>
                
            
            
                
<p>Buttons in the toolbar usually display icons instead of text. To implement this, we need to add icon files to our project and assign them to the actions we created.</p>
<p>One way of creating icons is by loading images from the filesystem. The problem with this is that you have to install a bunch of files along with your application, and you need to always know where they are located to be able to provide paths to access them. Fortunately, Qt provides a convenient and portable way to embed arbitrary files (such as images for icons) directly in the executable file. This is done by preparing resource files that are later compiled in the binary. Qt Creator provides a graphical tool for this as well.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Adding icons to the project</h1>
                
            
            
                
<p>We will add icons to our Start new game and Quit actions. First, use your file manager to create a new subdirectory called <kbd>icons</kbd> in the project directory. Place two icon files in the <kbd>icons</kbd> directory. You can use icons from the files provided with the book.</p>
<p>Click on Add New... in the context menu of the tictactoe project and select Qt Resource File (located in Qt category). Name it <kbd>resources</kbd>, and finish the wizard. Qt Creator will add a new <kbd>resources.qrc</kbd> file to the project (it will be displayed under the Resources category in the project tree).</p>
<p>Locate the new <kbd>resources.qrc</kbd> file in the project tree of Qt Creator and choose Add Existing Files... in its context menu. Select both icons, and confirm their addition to the resources.</p>
<p>Open the <kbd>mainwindow.ui</kbd> form, and double-click on one of the actions in the action editor. Click on the "..." button next to the Icon field, select icons in the left part of the window, and select the appropriate icon in the right part of the window. Once you confirm changes in the dialogs, the corresponding button on the toolbar will switch to displaying the icon instead of the text. The menu entry will also gain the selected icon. Repeat this operation for the second action. Our game should now look like this:</p>
<div><img src="img/e178a580-a24e-43a2-8da6-929e3eecf922.png" style="width:16.83em;height:15.17em;" width="300" height="270"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Have a go hero – Extending the game</h1>
                
            
            
                
<p>There are a lot of subtle improvements you can make in the project. For example, you can change the title of the main window (by editing its <kbd>windowTitle</kbd> property), add accelerators to the actions, disable the board buttons that do nothing on click, remove the status bar, or use it for displaying the game status.</p>
<p>As an additional exercise, you can try to modify the code we wrote in this chapter to allow playing the game on boards bigger than 3 × 3. Let the user decide the size of the board (you can modify the game options dialog for that and use <kbd>QSlider</kbd> and <kbd>QSpinBox</kbd> to allow the user to choose the size of the board), and you can then instruct <kbd>TicTacToeWidget</kbd> to build the board based on the size it gets. Remember to adjust the game-winning logic! If at any point you run into a dead end and do not know which classes and functions to use, consult the reference manual.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pop quiz</h1>
                
            
            
                
<p>Q1. Which classes can have signals?</p>
<ol>
<li>All classes derived from <kbd>QWidget</kbd>.</li>
<li>All classes derived from <kbd>QObject</kbd>.</li>
<li>All classes.</li>
</ol>
<p>Q2. For which of the following do you have to provide your own implementation?</p>
<ol>
<li>A signal.</li>
<li>A slot.</li>
<li>Both.</li>
</ol>
<p>Q3. A method that returns the preferred size of a widget is called which of these?</p>
<ol>
<li><kbd>preferredSize</kbd>.</li>
<li><kbd>sizeHint</kbd>.</li>
<li><kbd>defaultSize</kbd>.</li>
</ol>
<p>Q4. What is the purpose of the <kbd>QAction</kbd> object?</p>
<ol>
<li>It represents a functionality that a user can invoke in the program.</li>
<li>It holds a key sequence to move the focus on a widget.</li>
<li>It is a base class for all forms generated using the form editor.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned how to create simple graphical user interfaces with Qt. We went through two approaches: designing the user interface with a graphical tool that generates most of the code for us, and creating user interface classes by writing all the code directly. None of them is better than the other. The form designer allows you to avoid boilerplate code and helps you handle large forms with a lot of controls. On the other hand, the code writing approach gives you more control over the process and allows you to create automatically populated and dynamic interfaces.</p>
<p>We also learned how to use signals and slots in Qt. You should now be able to create simple user interfaces and fill them with logic by connecting signals to slots—predefined ones as well as custom ones that you now know how to define and fill with code.</p>
<p>Qt contains many widget types, but we didn't introduce them to you one by one. There is a really nice explanation of many widget types in the Qt manual called Qt Widget Gallery, which shows most of them in action. If you have any doubts about using any of those widgets, you can check the example code and also look up the appropriate class in the Qt reference manual to learn more about them.</p>
<p>As you already saw, Qt allows you to create custom widget classes, but in this chapter our custom classes mostly reused the default widgets. It's also possible to modify how the widget responds to events and implement custom painting. We will get to this advanced topic in <a href="2083bd66-78eb-4b33-a103-b7d1158544ef.xhtml">Chapter 8</a>,<em> Custom Widgets</em>. However, if you want to implement a game with custom 2D graphics, there is a simpler alternative—the Graphics View Framework that we'll use in the next chapter.</p>


            

            
        
    </div>



  </body></html>