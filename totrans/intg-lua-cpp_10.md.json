["```cpp\ntypedef void * (*lua_Alloc) (void *ud,\n                             void *ptr,\n                             size_t osize,\n                             size_t nsize);\n```", "```cpp\nlua_State *lua_newstate (lua_Alloc f, void *ud)\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    LuaExecutor(const LuaExecutorListener &listener,\n                bool overrideAllocator = false);\n};\n```", "```cpp\nnamespace\n{\nvoid *luaAlloc(\n    void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    (void)ud;\n    std::cout << \"[luaAlloc] ptr=\" << std::hex << ptr\n              << std::dec << \", osize=\" << osize\n              << \", nsize=\" << nsize;\n    void *newPtr = NULL;\n    if (nsize == 0)\n    {\n        free(ptr);\n    }\n    else\n    {\n        newPtr = realloc(ptr, nsize);\n    }\n    std::cout << std::dec << \", newPtr=\" << newPtr\n              << std::endl;\n    return newPtr;\n}\n}\n```", "```cpp\nLuaExecutor::LuaExecutor(\n    const LuaExecutorListener &listener,\n    bool overrideAllocator)\n    : L(overrideAllocator ? lua_newstate(luaAlloc, NULL)\n                          : luaL_newstate()),\n      listener(listener)\n{ ... }\n```", "```cpp\n#include \"LuaExecutor.h\"\n#include \"LoggingLuaExecutorListener.h\"\n#include \"LuaModuleExporter.hpp\"\n#include \"Destinations.h\"\nint main()\n{\n    auto listener = std::make_unique<\n        LoggingLuaExecutorListener>();\n    auto lua = std::make_unique<LuaExecutor>(\n        *listener, true);\n    auto module = LuaModuleExporter<Destinations>::make(\n        DestinationsLuaModuleDef::def);\n    lua->registerModule(module);\n    lua->executeFile(\"script.lua\");\n    return 0;\n}\n```", "```cpp\nprint(\"======script begin======\")\ndst = Destinations.new()\ndst:wish(\"London\", \"Paris\", \"Amsterdam\")\ndst:went(\"Paris\")\nprint(\"Visited:\", dst:list_visited())\nprint(\"Unvisited:\", dst:list_unvisited())\nprint(\"======script end======\")\n```", "```cpp\n...\n[Lua] ======script begin======\n[luaAlloc] ptr=0x0, osize=7, nsize=56, newPtr=0x14e7060c0\nDestinations instance created: 0x14e7060e0\n[luaAlloc] ptr=0x0, osize=4, nsize=47, newPtr=0x14e706100\n[luaAlloc] ptr=0x0, osize=5, nsize=56, newPtr=0x14e706130\n[luaAlloc] ptr=0x0, osize=0, nsize=48, newPtr=0x14e706170\n[luaAlloc] ptr=0x0, osize=0, nsize=96, newPtr=0x14e7061a0\n[luaAlloc] ptr=0x14e706170, osize=48, nsize=0, newPtr=0x0\n...\n[Lua] Visited: Paris\n[Lua] Unvisited: Amsterdam London\n[Lua] ======script end======\nDestinations instance destroyed: 0x14e7060e0\n...\n```", "```cpp\nstatic int luaNew(lua_State *L)\n{\n    ...\n    T **userdata = reinterpret_cast<T **>(\n        lua_newuserdatauv(L, sizeof(T *), 0));\n    T *obj = luaModuleDef.createInstance(L, nullptr);\n    *userdata = obj;\n    ...\n}\n```", "```cpp\nT* obj = new (addr) T();\n```", "```cpp\nstruct LuaModuleDef\n{\n    const bool isManagingMemory;\n};\n```", "```cpp\nconst std::function<T *(lua_State *, void *)>\ncreateInstance = [this](lua_State *, void *addr) -> T *\n{\n    if (isManagingMemory)\n    {\n        return new T();\n    }\n    else\n    {\n        return new (addr) T();\n    }\n};\n```", "```cpp\nconst std::function<void(T *)>\ndestroyInstance = [this](T *obj)\n{\n    if (isManagingMemory)\n    {\n        delete obj;\n    }\n    else\n    {\n        obj->~T();\n    }\n};\n```", "```cpp\nstatic int luaNew(lua_State *L)\n{\n    auto exporter = getExporter(L);\n    auto luaModuleDef = exporter->luaModuleDef;\n    if (luaModuleDef.isManagingMemory)\n    {\n        T **userdata = reinterpret_cast<T **>(\n            lua_newuserdatauv(L, sizeof(T *), 0));\n        T *obj = luaModuleDef.createInstance(L, nullptr);\n        *userdata = obj;\n    }\n    else\n    {\n        T *userdata = reinterpret_cast<T *>(\n            lua_newuserdatauv(L, sizeof(T), 0));\n        luaModuleDef.createInstance(L, userdata);\n    }\n    lua_copy(L, -1, 1);\n    lua_settop(L, 1);\n    ...\n}\n```", "```cpp\nstatic int luaDelete(lua_State *L)\n{\n    auto luaModuleDef = getExporter(L)->luaModuleDef;\n    T *obj = luaModuleDef.isManagingMemory\n        ? *reinterpret_cast<T **>(lua_touserdata(L, 1))\n        : reinterpret_cast<T *>(lua_touserdata(L, 1));\n    luaModuleDef.destroyInstance(obj);\n    return 0;\n}\n```", "```cpp\ninline Destinations *getObj(lua_State *L)\n{\n    luaL_checkudata(L, 1, DestinationsLuaModuleDef::def\n        .metatableName().c_str());\n    if (DestinationsLuaModuleDef::def.isManagingMemory)\n    {\n        return *reinterpret_cast<Destinations **>(\n            lua_touserdata(L, 1));\n    }\n    else\n    {\n        return reinterpret_cast<Destinations *>(\n            lua_touserdata(L, 1));\n    }\n}\n```", "```cpp\nLuaModuleDef DestinationsLuaModuleDef::def =\nLuaModuleDef<Destinations>{\n    \"Destinations\",\n    {{\"wish\", luaWish},\n     {\"went\", luaWent},\n     {\"list_visited\", luaListVisited},\n     {\"list_unvisited\", luaListUnvisited},\n     {NULL, NULL}},\n    false,\n};\n```", "```cpp\nChapter10 % ./executable\n[Lua] ======script begin======\nDestinations instance created: 0x135e0af10\n[Lua] Visited: Paris\n[Lua] Unvisited: Amsterdam London\n[Lua] ======script end======\nDestinations instance destroyed: 0x135e0af10\n```"]