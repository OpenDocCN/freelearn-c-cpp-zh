<html><head></head><body>
<div><h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-60">Setting Up the Development Environment for a C++ Embedded Project</h1>
<p>In the previous chapter, we explored the embedded tools ecosystem and reviewed the most widely used tools in the industry. Now, we’ll set requirements for a modern embedded development environment and each of its components. Then, we’ll set up our development environment for running the examples that will be provided in the remainder of this book.</p>
<p>One of the major selling points of integrated environments is their ease of use. They provide you with everything you need through simple installation steps. Customized environments, on the other hand, require all components to be installed individually, including all the dependencies for each component. It’s important to ensure reproducible builds and a reliable debugging environment, so containerizing customized environments is of great importance.</p>
<p>You’ll be provided with a Docker container for the development environment that we’ll be using in this book, but we’ll analyze all of its components individually. Understanding the tools that we use in our daily work is necessary to comprehend and control the processes behind them.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList">Requirements for a modern software development environment</li>
<li class="bulletList">Containerized development environment</li>
<li class="bulletList">Containerized development environment and Visual Studio Code</li>
</ul>
<h1 class="heading-1" id="_idParaDest-61">Technical requirements</h1>
<p class="normal">For this chapter, you will need to have Docker installed (<a href="https://www.docker.com/).">https://www.docker.com/).</a> Please follow the installation instructions provided for your specific operating system. This chapter will guide you through the basic steps for downloading and running a container with a preconfigured development environment. For more advanced Docker usage, please refer to the official Docker documentation available on their website.</p>
<p class="normal">The code from this chapter is available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).</a></p>
<h1 class="heading-1" id="_idParaDest-62">Requirements for a modern software development environment</h1>
<p><strong class="keyWord">Firmware development</strong> is no different than any other form of software development and the tools we use are crucial for <a id="_idIndexMarker181"/>effective<a id="_idIndexMarker182"/> work. To make this book and the examples accessible as much as possible, the first requirement we’ll set is to use free tools. The <strong class="keyWord">compiler</strong> is the <a id="_idIndexMarker183"/>basis and the most important part of every development requirement, so let’s define the requirements and choose a compiler for our needs.</p>
<h2 class="heading-2" id="_idParaDest-63">Compiler</h2>
<p>Since we’re exploring <a id="_idIndexMarker184"/>modern C++, we’ll require <a id="_idIndexMarker185"/>compiler support for the C++23 standard. The latest version of <strong class="keyWord">ARM GNU Toolchain</strong> (based on GCC) is 13.2; it <a id="_idIndexMarker186"/>supports C++23 and is free. It’s also the most commonly used free compiler toolchain for ARM development, making it a perfect fit for our compiler.</p>
<p>ARM GNU Toolchain comes with<a id="_idIndexMarker187"/> C and C++ compilers, <strong class="keyWord">GNU Debugger</strong> (<strong class="keyWord">GDB</strong>), which we’ll use for debugging, and other useful tools, such as <code class="inlineCode">objcopy</code>, <code class="inlineCode">objdump</code>, <code class="inlineCode">size</code>, and more, and can be downloaded from <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.</a> The architecture that we need for Arm Cortex-M is <code class="inlineCode">arm-none-eabi</code>. </p>
<p>ARM GNU Toolchain for <code class="inlineCode">arm-none-eabi</code> is available for all common host architectures:</p>
<ul>
<li class="bulletList">GNU/Linux x86_64 and AArch64 host architectures</li>
<li class="bulletList">Windows x86 host architecture only (compatible with <code class="inlineCode">x86_64</code>)</li>
<li class="bulletList">macOS x86_64 and Apple silicon</li>
</ul>
<p class="normal">Compiling a single file or few files is as simple as running a few commands in the terminal, but building even the simplest embedded projects involves the following steps:</p>
<ol>
<li>Compile all C and C++ source files, the file that contains the main function, and at least several<a id="_idIndexMarker188"/> files from <strong class="keyWord">Hardware Abstraction Layer</strong> (<strong class="keyWord">HAL</strong>). You’ll learn more about HAL in <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>.<ol>
<li class="numberedList" value="2">Set up compiler include paths.</li>
<li class="numberedList">Set up compiler C and C++ flags.</li>
<li class="numberedList">Set up compiler define macros.</li>
<li class="numberedList">Compile the startup assembly script.</li>
<li class="numberedList">Set up linker options, including the linker script, static libraries, CPU architecture and instruction set, and standard library options.</li>
</ol>
</li>
</ol>
<p class="normal">Upon doing this, we must convert the ELF file into other formats that are commonly used by flashing programs, such as <code class="inlineCode">bin</code> and <code class="inlineCode">hex</code>.</p>
<p>Running all of these tasks manually in the terminal would be a tedious process, so the next requirement for our development environment is <em class="italic">build automation</em>. The first candidate for build automation is the <strong class="keyWord">make</strong> utility. It’s a common tool that’s used for automating huge amounts of software projects across different industries. It would be a good fit for the task, but it’s an old tool with odd syntax. However, we can use <strong class="keyWord">CMake</strong>, a more flexible tool with more modern syntax that <a id="_idIndexMarker189"/>can generate Makefiles for us.</p>
<h2 class="heading-2" id="_idParaDest-64">Build automation</h2>
<p><strong class="keyWord">CMake</strong> isn’t<a id="_idIndexMarker190"/> an actual <a id="_idIndexMarker191"/>build automation tool, but it generates files for other automation tools, such as the make utility. It’s cross-platform, free, and open source software for the build automation process, which involves testing, packaging, and installing software. It does so by using a compiler-independent method.</p>
<p>We’ll use <strong class="keyWord">CMake</strong> to help us generate targets for the make utility that will do the following:</p>
<ul>
<li class="bulletList">Configure source files, including paths and linker settings to build ELF files</li>
<li class="bulletList">Convert ELF files into hex and binary formats</li>
<li class="bulletList">Start the simulator and load it with the generated ELF file</li>
</ul>
<p>We’ll use build automation not only to build the firmware but also to start the simulator that will run the firmware.</p>
<h2 class="heading-2" id="_idParaDest-65">Simulator</h2>
<p>To make this book <a id="_idIndexMarker192"/>accessible to a wide audience, we’ll be<a id="_idIndexMarker193"/> using a <strong class="keyWord">simulator</strong> to run the examples that have been compiled for the ARM Cortex M <a id="_idIndexMarker194"/>target. <strong class="keyWord">Renode </strong>(<a href="https://github.com/renode/renode)">https://github.com/renode/renode)</a> is an open source simulating framework with good support for ARM targets.</p>
<p>Renode allows you to run simulations with multiple targets and simulate wireless and wired connections between them. We’ll use it in a simple scenario that involves running simulations on a single target. Renode can also start a GDB server, allowing you to connect to it and debug the target.</p>
<p>We’ll integrate simulation execution and debugging, as well as compiler and build automation, using<a id="_idIndexMarker195"/> the highly configurable <strong class="keyWord">Visual Studio Code</strong>.</p>
<h2 class="heading-2" id="_idParaDest-66">Code editor</h2>
<p><strong class="keyWord">Visual Studio Code</strong> is a modern<a id="_idIndexMarker196"/> and flexible <a id="_idIndexMarker197"/>code editor. It provides us with all the extensions we need to integrate all our tools into a single environment. We’ll install the following extensions in Visual Studio Code:</p>
<ul>
<li class="bulletList"><strong class="keyWord">C/C++</strong>: This extension <a id="_idIndexMarker198"/>provides syntax highlighting, code autocompletion, and code navigation</li>
<li class="bulletList"><strong class="keyWord">Cortex-Debug</strong>: This extension allows debugging to be performed via GDB</li>
<li class="bulletList"><strong class="keyWord">CS 128 Clang-Tidy</strong>: This extension integrates clang-tidy into Visual Studio Code</li>
<li class="bulletList"><strong class="keyWord">Dev Containers</strong>: This extension attaches to running a container and uses it for development purposes</li>
</ul>
<p>We’ll base our development environment on a Docker container. Visual Studio Code will attach to that container and use it.</p>
<h1 class="heading-1" id="_idParaDest-67">Containerized development environment</h1>
<p class="normal">The Visual Studio<a id="_idIndexMarker199"/> Code Dev Containers extension allows Visual Studio Code to attach to a running Docker container and use all the tools inside it that have been installed. To use this feature, we need to build a container.</p>
<p>We’ll use Docker to build a container with the following tools:</p>
<ul>
<li class="bulletList">ARM GNU Toolchain version 13.2</li>
<li class="bulletList">CMake and the make utility</li>
<li class="bulletList">Renode version 1.14</li>
</ul>
<p>Make sure you’ve installed Docker on your host machine by following the instructions provided on the official website (<a href="https://docs.docker.com)">https://docs.docker.com)</a>.</p>
<p>You can find the <strong class="keyWord">Dockerfile</strong> that will be used to build the container in this book’s GitHub repository (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)</a>, in the <code class="inlineCode">Chapter04</code> folder.</p>
<p>There’s also an image that you can download from Docker Hub (<a href="https://hub.docker.com/).">https://hub.docker.com/).</a> You can pull it using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker pull mahmutbegovic/cpp_in_embedded_systems:latest
</code></pre>
<p>Make sure that the Docker daemon has been started by following the instructions for your platform; they’re available on the official website. After downloading the image, start Docker using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker run -d -it --name dev_env mahmutbegovic/cpp_in_embedded_systems
</code></pre>
<p>This will start the<a id="_idIndexMarker200"/> Docker container in detached and interactive mode. If you’ve already created A Docker container using the <code class="inlineCode">docker run</code> command, you need to start it by running the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker start dev_env
</code></pre>
<p class="normal">To access the bash of the started container, we can use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker exec -it dev_env /bin/bash
</code></pre>
<p class="normal">As shown in the following screenshot, we can run various commands to ensure the compiler, debugger, simulator, and other tools have been installed in the container:</p>
<figure class="mediaobject"><img alt="Figure 4.1 – Development environment container bash" src="img/B22402_04_01.png"/></figure>
<p class="packt_figref">Figure 4.1 – Development environment container bash</p>
<p><em class="italic">Figure 4.1</em> shows the<a id="_idIndexMarker201"/> expected outputs from the commands we used to check the versions of the tools that we’ve installed.</p>
<p>We can use the running container as a self-contained environment. Let’s start by cloning the project GitHub repository (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):</a></p>
<pre class="programlisting con"><code class="hljs-con">$ git clone https://github.com/PacktPublishing/Cpp-in-Embedded-Systems.git
</code></pre>
<p>Once you’ve done this, go to the <code class="inlineCode">Chapter04/bare</code> folder. This folder contains the <em class="italic">Hello, World!</em> example firmware for STM32F072 that we’ll run in Renode. The project is organized into the following folders:</p>
<ul>
<li class="bulletList"><code class="inlineCode">app</code>: Contains the business layer code, including <code class="inlineCode">main.cpp</code></li>
<li class="bulletList"><code class="inlineCode">hal</code>: Contains the HAL C++ code</li>
<li class="bulletList"><code class="inlineCode">platform</code>: Contains platform-specific code, including the ST-provided HAL layer in C and the CMSIS, startup, and linker scripts</li>
<li class="bulletList"><code class="inlineCode">renode_scripts</code>: Contains Renode simulator scripts</li>
</ul>
<p>In the project folder, you’ll <a id="_idIndexMarker202"/>also see <code class="inlineCode">CMakeLists.txt</code>, a CMake file that we’ll use to specify how the firmware is built. Let’s learn how to use CMake with the help of an example.</p>
<h2 class="heading-2" id="_idParaDest-68">Building the Hello, World! program using CMake</h2>
<p>We can use CMake to <a id="_idIndexMarker203"/>specify a toolchain, source files, compiler<a id="_idIndexMarker204"/> include paths, and compiler <a id="_idIndexMarker205"/>flags. The first thing we must do in a CMake file is specify the CMake version that’s in use, as shown in the following line:</p>
<pre class="programlisting con"><code class="hljs-con">cmake_minimum_required(VERSION 3.13)
</code></pre>
<p class="normal">CMake is a powerful tool that allows us to write highly flexible build files. We can write toolchain details in separate files and include them in the main project file, which would allow us to reuse them for different architectures. However, in our example, we have the toolchain details in the main CMake file. The following lines specify various toolchain components:</p>
<p>set(CMAKE_C_COMPILER “arm-none-eabi-gcc”)</p>
<p>set(CMAKE_CXX_COMPILER “arm-none-eabi-g++”)</p>
<p>set(CMAKE_ASM_COMPILER “arm-none-eabi-gcc”)</p>
<p class="normal">Using the <code class="inlineCode">CMAKE_C_COMPILER</code>, <code class="inlineCode">CMAKE_CXX_COMPILER</code>, and <code class="inlineCode">CMAKE_ASM_COMPILER</code> CMake variables, we specify paths for the C, C++, and assembler compilers, respectively. We need to use all three since our project contains ST-provided HAL written in C, our C++ code, and an assembly startup script.</p>
<p class="normal">Now, we must specify various compiler options and preprocessor macros by running the following lines in our <code class="inlineCode">CMakeLists.txt</code> file:</p>
<p>set(CDEFS “-DUSE_HAL_DRIVER -DSTM32F072xB”)</p>
<p>set(MCU “-mcpu=cortex-m0 -mthumb”)</p>
<p>set(COMMON_FLAGS “${MCU} ${CDEFS} -fdata-sections -ffunction-sections -Wno-address-of-packed-member -Wall -Wextra -Wno-unused-parameter”)</p>
<p>set(CMAKE_C_FLAGS “${COMMON_FLAGS}”)</p>
<p>set(CMAKE_CXX_FLAGS “${COMMON_FLAGS} -Wno-register -fno-exceptions -fno-rtti -fno-threadsafe-statics”)</p>
<p>Here, we set the <code class="inlineCode">USE_HAL_DRIVER</code> and <code class="inlineCode">STM32F072xB</code> compile-time macros, which are used by ST’s HAL. Then, we set some compiler flags that are used for both C and C++ files:</p>
<ul>
<li class="bulletList"><code class="inlineCode">-mcpu=cortex-m0</code> and -<code class="inlineCode">mthumb</code>: Architecture-specific flags.</li>
<li class="bulletList"><code class="inlineCode">-fdata-sections</code>: This option tells the compiler to place data items in their own sections in the resulting objectfile. This can be useful for optimization purposes (removing unused sections).</li>
<li class="bulletList"><code class="inlineCode">-ffunction-sections</code>: Similar to <code class="inlineCode">-fdata-sections</code>, but for functions. Each function gets its own section, allowing the linker to potentially discard unused functions.</li>
<li class="bulletList"><code class="inlineCode">-Wno-address-of-packed-member</code>: Suppresses warnings related to taking the address of a <a id="_idIndexMarker206"/>packed <a id="_idIndexMarker207"/>member of a structure.</li>
<li class="bulletList"><code class="inlineCode">-Wall</code>: Enables<a id="_idIndexMarker208"/> all the common warning messages recommended for normal operation.</li>
</ul>
<ul>
<li><code class="inlineCode">-Wextra</code>: Enables extra warning flags that aren’t enabled by <code class="inlineCode">-Wall</code>.<ul>
<li class="bulletList"><code class="inlineCode">-Wno-unused-parameter</code>: Disables warnings about unused parameters in functions.</li>
</ul>
</li>
</ul>
<p class="normal">Then, we set the C++-specific compiler flags:</p>
<ul>
<li class="bulletList"><code class="inlineCode">-Wno-register</code>: Disables warnings about the use of the <code class="inlineCode">register</code> keyword, which is deprecated in modern C++ but might be used in legacy code</li>
<li class="bulletList"><code class="inlineCode">-fno-exceptions</code>: Disables support for exceptions in C++</li>
<li class="bulletList"><code class="inlineCode">-fno-rtti</code>: Disables <strong class="keyWord">Run-Time Type Information</strong> (<strong class="keyWord">RTTI</strong>)</li>
<li class="bulletList"><code class="inlineCode">-fno-threadsafe-statics</code>: Prevents <a id="_idIndexMarker209"/>the compiler from using extra code to ensure that static local variables are initialized in a thread-safe way</li>
</ul>
<p class="normal">The next part of our CMake file is project-specific: we must declare a new project, give it a name, enable the languages we want to use, and specify a CMake target, source files, and linker options.</p>
<p class="normal">This is our basic<a id="_idIndexMarker210"/> setup<a id="_idIndexMarker211"/> compiler setup for a C++ (mixed with C) project:</p>
<pre class="programlisting code"><code class="hljs-code">project(bare VERSION 1.0.6)
enable_language(C CXX ASM)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)
# global include directories
include_directories(
  ${CMAKE_SOURCE_DIR}/platform/inc
  ${CMAKE_SOURCE_DIR}/platform/CMSIS/Device/ST/STM32F0xx/Include
${CMAKE_SOURCE_DIR}/platform/CMSIS/Include
${CMAKE_SOURCE_DIR}/platform/STM32F0xx_HAL_Driver/Inc
  ${CMAKE_SOURCE_DIR}/app/inc
  ${CMAKE_SOURCE_DIR}/hal/uart/inc
  ${CMAKE_SOURCE_DIR}/hal/inc
  )
set(EXECUTABLE ${PROJECT_NAME}.elf)
add_executable(
  ${EXECUTABLE}
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_cortex.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_rcc.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart_ex.c
  platform/startup_stm32f072xb.s
  platform/src/stm32f0xx_hal_msp.c
  platform/src/stm32f0xx_it.c
  platform/src/system_stm32f0xx.c
  app/src/main.cpp
  hal/uart/src/uart_stm32.cpp
  )
</code></pre>
<p>In the preceding CMake code, we have <code class="inlineCode">TARGET</code>. This represents an entity that’s being built by a CMake, be it the entire firmware (an executable file) or a static library. In our case, the target is the entire firmware, and the target name is created using the project name and <code class="inlineCode">.elf</code> suffix, meaning CMake will create a <code class="inlineCode">bare.elf</code> target for us.</p>
<p class="normal">The remaining<a id="_idIndexMarker212"/> step is to specify linker options using <a id="_idIndexMarker213"/>the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">target_link_options(
  ${EXECUTABLE}
  PUBLIC
  -T${CMAKE_SOURCE_DIR}/platform/STM32F072C8Tx_FLASH.ld
  -mcpu=cortex-m0
  -mthumb
  -specs=nano.specs
  -Wl,--no-warn-rwx-segments
  -Wl,-Map=${PROJECT_NAME}.map,--cref
  -Wl,--gc-sections)
</code></pre>
<p class="normal">Here, we specify the linker script to be used – that is, <code class="inlineCode">STM32F072C8Tx_FLASH.ld</code> – set a target CPU and<a id="_idIndexMarker214"/> instruction set, and specify the new-lib nano<a id="_idIndexMarker215"/> system library and map file to be<a id="_idIndexMarker216"/> created.</p>
<p>Now, let’s build the firmware using CMake.</p>
<h2 class="heading-2" id="_idParaDest-69">Building a firmware using CMake</h2>
<p>Here, we’ll create a <a id="_idIndexMarker217"/>build folder and configure the build in <code class="inlineCode">Debug</code> mode <a id="_idIndexMarker218"/>using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Cpp-in-Embedded-Systems/Chapter04/bare/
$ mkdir build &amp;&amp; cd build
$ cmake .. -DCMAKE_BUILD_TYPE=Debug
</code></pre>
<p>If you list the files in the build folder using <code class="inlineCode">ls –l</code>, you’ll see that CMake generated <code class="inlineCode">Makefile</code>, which is used to build the firmware. Let’s run it to build the firmware:</p>
<pre class="programlisting con"><code class="hljs-con">$ make -j4
</code></pre>
<p class="normal">You should see the following output:</p>
<figure class="mediaobject"><img alt="Figure 4.2 – Building the firmware" src="img/B22402_04_02.png"/></figure>
<p class="packt_figref">Figure 4.2 – Building the firmware</p>
<p class="normal"><em class="italic">Figure 4</em><em class="italic">.2</em> shows the output of building the firmware. We can run the resulting ELF file, <code class="inlineCode">bare.elf</code>, in Renode using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">$ make run_in_renode
</code></pre>
<p>This will start <a id="_idIndexMarker219"/>the simulator using the <code class="inlineCode">stm32f072.resc</code> Renode script from the <code class="inlineCode">renode_scripts</code> folder. The script will create a new Renode machine using the STM32F072 target architecture and load it with the <code class="inlineCode">bare.elf</code> file. We’ll see the following as part of the terminal output:</p>
<figure class="mediaobject"><img alt="Figure 4.3 – Running firmware in Renode" src="img/B22402_04_03.png"/></figure>
<p class="packt_figref">Figure 4.3 – Running firmware in Renode</p>
<p class="normal"><em class="italic">Figure 4</em><em class="italic">.3</em> shows the output of the simulation running in Renode in console mode with GUI disabled. To stop the<a id="_idIndexMarker220"/> simulation, type <em class="italic">q</em> and press <em class="italic">Enter</em>.</p>
<p class="normal">Keep in mind that if <a id="_idIndexMarker221"/>you stop or reset the Docker container, all the changes, including the cloned GitHub repository, will be lost. To prevent this from happening, you need to save them using the <code class="inlineCode">docker commit</code> command.</p>
<p class="normal">At this point, we have a pretty development environment contained in a Docker container. However, to fully utilize it, we must connect it to Visual Studio Code.</p>
<h1 class="heading-1" id="_idParaDest-70">Containerized development environment and Visual Studio Code</h1>
<p>To start, install <a id="_idIndexMarker222"/>Visual Studio <a id="_idIndexMarker223"/>Code (<a href="https://code.visualstudio.com/)">https://code.visualstudio.com/)</a>. Once you’ve done this, go to <strong class="screenText">Extensions</strong> and search for and install the following extensions:</p>
<ul>
<li class="bulletList">C/C++</li>
<li class="bulletList">Cortex-Debug</li>
<li class="bulletList">CS 128 Clang-Tidy</li>
<li class="bulletList">Dev Containers</li>
</ul>
<p>Once you’ve done this, open <strong class="screenText">View</strong>| <strong class="screenText">Command Palette</strong> (<em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">P</em>), find <strong class="screenText">Dev Containers: Attach to Running Container</strong>, and select <code class="inlineCode">dev_env</code>. This should open a new Visual Studio Code window where the container’s name is in the bottom left bar:</p>
<figure class="mediaobject"><img alt="Figure 4.4 – Visual Studio Code attached to a running container" src="img/B22402_04_04.png"/></figure>
<p class="packt_figref">Figure 4.4 – Visual Studio Code attached to a running container</p>
<p><em class="italic">Figure 4.4</em> shows that Visual Studio Code was successfully attached to the running container. Now, let’s open the project folder at <code class="inlineCode">/workspace/Cpp-in-Embedded-Systems/Chapter04/bare</code>. Open <code class="inlineCode">main.cpp</code> in the <strong class="screenText">EXPLORER</strong> view and set a breakpoint on line 23, as shown<a id="_idIndexMarker224"/> in the<a id="_idIndexMarker225"/> following screenshot:</p>
<figure class="mediaobject"><img alt="Figure 4.5 – Setting a breakpoint in Visual Studio Code" src="img/B22402_04_05.png"/></figure>
<p class="packt_figref">Figure 4.5 – Setting a breakpoint in Visual Studio Code</p>
<p class="normal">After setting<a id="_idIndexMarker226"/> a <a id="_idIndexMarker227"/>breakpoint, as shown in <em class="italic">Figure 4</em><em class="italic">.5</em>, select <strong class="screenText">Run</strong>| <strong class="screenText">Start Debugging</strong> (<em class="italic">F5</em>). This will do the following:</p>
<ul>
<li class="bulletList">Configure the project in debug mode</li>
<li class="bulletList">Start the simulator and load ELF</li>
<li class="bulletList">Connect the GDB client to the GDB server running in the simulator</li>
<li class="bulletList">Allow you to debug the target running in the simulator</li>
</ul>
<p>If everything has been set up correctly, the program flow will stop on line 23, and you’ll see the following output:</p>
<figure class="mediaobject"><img alt="Figure 4.6 – Visual Studio Code program flow" src="img/B22402_04_06.png"/></figure>
<p class="packt_figref">Figure 4.6 – Visual Studio Code program flow</p>
<p><em class="italic">Figure 4.6</em> shows that <a id="_idIndexMarker228"/>the <a id="_idIndexMarker229"/>program flow stopped on line 23. We can switch to the <strong class="screenText">TERMINAL</strong> view to see the output from Renode. Renode is in console mode, and it will also display <strong class="screenText">UART</strong>. Let’s switch to the <strong class="screenText">TERMINAL</strong> view and hit <strong class="screenText">Continue</strong> (<em class="italic">F5</em>). You should see the following output:</p>
<figure class="mediaobject"><img alt="Figure 4.7 – Visual Studio Code Renode output" src="img/B22402_04_07.png"/></figure>
<p class="packt_figref">Figure 4.7 – Visual Studio Code Renode output</p>
<p>In <em class="italic">Figure 4.7</em>, we can see<a id="_idIndexMarker230"/> the <a id="_idIndexMarker231"/>Renode output in Visual Studio Code’s <strong class="screenText">TERMINAL</strong> view. To be able to debug assembly files, we need to do the following in Visual Studio Code:</p>
<ol>
<li class="numberedList" value="1">Go to <strong class="screenText">File</strong>|<strong class="screenText">Preferences</strong>|<strong class="screenText">Settings</strong>.</li>
<li class="numberedList">Search for <code class="inlineCode">Allow Breakpoints Everywhere</code> and select the relevant checkbox.</li>
</ol>
<p class="normal">Now, we can set a breakpoint in <strong class="screenText">platform/startup_stm32f072xb.s</strong> on line 87, stop the debugging session, and run it again. The program flow should stop, as shown here:</p>
<figure class="mediaobject"><img alt="Figure 4.8 – Visual Studio Code assembly debugging" src="img/B22402_04_08.png"/></figure>
<p class="packt_figref">Figure 4.8 – Visual Studio Code assembly debugging</p>
<p>In <em class="italic">Figure 4.8</em>, we can see that the program flow executes the <code class="inlineCode">SystemInit</code> function on line 87 of the assembly startup script, before the <code class="inlineCode">main</code> function. If we use <strong class="screenText">Step Into</strong> (<em class="italic">F11</em>), the program flow will enter the <code class="inlineCode">SystemInit</code> function and Visual Studio Code will open <code class="inlineCode">platform/src/system_stm32f0xx.c</code> file. If you keep moving using <strong class="screenText">Step Over</strong> (<em class="italic">F10</em>), you’ll eventually enter the <a id="_idIndexMarker232"/>main<a id="_idIndexMarker233"/> function. This shows us that <code class="inlineCode">main</code> isn’t the first function to be called.</p>
<p class="normal">Note that <code class="inlineCode">Reset_Handler</code> from <code class="inlineCode">startup_stm32f072xb.s</code> is the entry point of the firmware. This is defined in the linker script (<code class="inlineCode">platform/STM32F072C8Tx_FLASH.ld</code>). It does the following:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Initializes the stack pointer</strong>: It sets the initial stack pointer from the end of the stack (<code class="inlineCode">_estack</code>).</li>
<li class="bulletList"><strong class="keyWord">Copies data</strong>: It copies the initialization values from flash memory to SRAM for the data section, which ensures that initialized global/static variables are set up correctly.</li>
<li class="bulletList"><strong class="keyWord">Zeroes BSS</strong>: It clears the BSS section by setting it to zero, which is required for uninitialized global/static variables.</li>
<li class="bulletList"><strong class="keyWord">Calls SystemInit</strong>: The <code class="inlineCode">SystemInit</code> function is used to set the default system clock (system clock source, PLL multiplier and divider factors, AHB/APBx prescalers, and flash settings).</li>
<li class="bulletList"><strong class="keyWord">Calls __libc_init_array</strong>: The <code class="inlineCode">__libc_init_array</code> function is used to initialize the static constructors in a C++ program or to run initialization functions in C programs.</li>
<li class="bulletList"><strong class="keyWord">Calls main</strong>: This operation concludes the activities of the startup script and transfers program flow to the <code class="inlineCode">main</code> function.</li>
</ul>
<p>With our modern development environment now fully set up, we’re ready to dive into learning C++ for embedded systems. The Renode simulator allows us to run, test, and debug our firmware efficiently, eliminating <a id="_idIndexMarker234"/>the need<a id="_idIndexMarker235"/> for physical hardware in the initial stages of development. This provides a flexible and efficient solution for embedded system learning and testing.</p>
<h1 class="heading-1" id="_idParaDest-71">Summary</h1>
<p class="normal">In this chapter, we defined the components of our development environment for C++ in embedded systems. We went through all of its components using a Docker container, which we connected to Visual Studio Code to enable a seamless development experience and debugging.</p>
<p class="normal">We also set up compiler flags using CMake, ran the firmware using the Renode simulator, and learned how to set up our C and C++ runtime environment by going through the relevant assembly startup script using a debugger.</p>
<p>In the next chapter, we’ll use the development environment we created in this chapter to learn more about classes in C++.</p>
</div>
</body></html>