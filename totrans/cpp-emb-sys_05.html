<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 class="chapterTitle" id="_idParaDest-60"><span class="koboSpan" id="kobo.2.1">Setting Up the Development Environment for a C++ Embedded Project</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored the embedded tools ecosystem and reviewed the most widely used tools in the industry. </span><span class="koboSpan" id="kobo.3.2">Now, we’ll set requirements for a modern embedded development environment and each of its components. </span><span class="koboSpan" id="kobo.3.3">Then, we’ll set up our development environment for running the examples that will be provided in the remainder of this book.</span></p>
<p><span class="koboSpan" id="kobo.4.1">One of the major selling points of integrated environments is their ease of use. </span><span class="koboSpan" id="kobo.4.2">They provide you with everything you need through simple installation steps. </span><span class="koboSpan" id="kobo.4.3">Customized environments, on the other hand, require all components to be installed individually, including all the dependencies for each component. </span><span class="koboSpan" id="kobo.4.4">It’s important to ensure reproducible builds and a reliable debugging environment, so containerizing customized environments is of great importance.</span></p>
<p><span class="koboSpan" id="kobo.5.1">You’ll be provided with a Docker container for the development environment that we’ll be using in this book, but we’ll analyze all of its components individually. </span><span class="koboSpan" id="kobo.5.2">Understanding the tools that we use in our daily work is necessary to comprehend and control the processes behind them.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, we’re going to cover the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Requirements for a modern software development environment</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Containerized development environment</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Containerized development environment and Visual Studio Code</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-61"><span class="koboSpan" id="kobo.10.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.11.1">For this chapter, you will need to have Docker installed (</span><a href="https://www.docker.com/)."><span class="url"><span class="koboSpan" id="kobo.12.1">https://www.docker.com/).</span></span></a><span class="koboSpan" id="kobo.13.1"> Please follow the installation instructions provided for your specific operating system. </span><span class="koboSpan" id="kobo.13.2">This chapter will guide you through the basic steps for downloading and running a container with a preconfigured development environment. </span><span class="koboSpan" id="kobo.13.3">For more advanced Docker usage, please refer to the official Docker documentation available on their website.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.14.1">The code from this chapter is available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04)."><span class="url"><span class="koboSpan" id="kobo.15.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).</span></span></a></p>
<h1 class="heading-1" id="_idParaDest-62"><span class="koboSpan" id="kobo.16.1">Requirements for a modern software development environment</span></h1>
<p><strong class="keyWord"><span class="koboSpan" id="kobo.17.1">Firmware development</span></strong><span class="koboSpan" id="kobo.18.1"> is no different than any other form of software development and the tools we use are crucial for </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.19.1">effective</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.20.1"> work. </span><span class="koboSpan" id="kobo.20.2">To make this book and the examples accessible as much as possible, the first requirement we’ll set is to use free tools. </span><span class="koboSpan" id="kobo.20.3">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.21.1">compiler</span></strong><span class="koboSpan" id="kobo.22.1"> is the </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.23.1">basis and the most important part of every development requirement, so let’s define the requirements and choose a compiler for our needs.</span></p>
<h2 class="heading-2" id="_idParaDest-63"><span class="koboSpan" id="kobo.24.1">Compiler</span></h2>
<p><span class="koboSpan" id="kobo.25.1">Since we’re exploring </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.26.1">modern C++, we’ll require </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.27.1">compiler support for the C++23 standard. </span><span class="koboSpan" id="kobo.27.2">The latest version of </span><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">ARM GNU Toolchain</span></strong><span class="koboSpan" id="kobo.29.1"> (based on GCC) is 13.2; it </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.30.1">supports C++23 and is free. </span><span class="koboSpan" id="kobo.30.2">It’s also the most commonly used free compiler toolchain for ARM development, making it a perfect fit for our compiler.</span></p>
<p><span class="koboSpan" id="kobo.31.1">ARM GNU Toolchain comes with</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.32.1"> C and C++ compilers, </span><strong class="keyWord"><span class="koboSpan" id="kobo.33.1">GNU Debugger</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.35.1">GDB</span></strong><span class="koboSpan" id="kobo.36.1">), which we’ll use for debugging, and other useful tools, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">objcopy</span></code><span class="koboSpan" id="kobo.38.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">objdump</span></code><span class="koboSpan" id="kobo.40.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">size</span></code><span class="koboSpan" id="kobo.42.1">, and more, and can be downloaded from </span><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads."><span class="url"><span class="koboSpan" id="kobo.43.1">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.</span></span></a><span class="koboSpan" id="kobo.44.1"> The architecture that we need for Arm Cortex-M is </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">arm-none-eabi</span></code><span class="koboSpan" id="kobo.46.1">. </span></p>
<p><span class="koboSpan" id="kobo.47.1">ARM GNU Toolchain for </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">arm-none-eabi</span></code><span class="koboSpan" id="kobo.49.1"> is available for all common host architectures:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.50.1">GNU/Linux x86_64 and AArch64 host architectures</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.51.1">Windows x86 host architecture only (compatible with </span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">x86_64</span></code><span class="koboSpan" id="kobo.53.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.54.1">macOS x86_64 and Apple silicon</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.55.1">Compiling a single file or few files is as simple as running a few commands in the terminal, but building even the simplest embedded projects involves the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.56.1">Compile all C and C++ source files, the file that contains the main function, and at least several</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.57.1"> files from </span><strong class="keyWord"><span class="koboSpan" id="kobo.58.1">Hardware Abstraction Layer</span></strong><span class="koboSpan" id="kobo.59.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.60.1">HAL</span></strong><span class="koboSpan" id="kobo.61.1">). </span><span class="koboSpan" id="kobo.61.2">You’ll learn more about HAL in </span><a href="Chapter_12.xhtml"><em class="italic"><span class="koboSpan" id="kobo.62.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.63.1">.</span><ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.64.1">Set up compiler include paths.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.65.1">Set up compiler C and C++ flags.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.66.1">Set up compiler define macros.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.67.1">Compile the startup assembly script.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.68.1">Set up linker options, including the linker script, static libraries, CPU architecture and instruction set, and standard library options.</span></li>
</ol>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.69.1">Upon doing this, we must convert the ELF file into other formats that are commonly used by flashing programs, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">bin</span></code><span class="koboSpan" id="kobo.71.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">hex</span></code><span class="koboSpan" id="kobo.73.1">.</span></p>
<p><span class="koboSpan" id="kobo.74.1">Running all of these tasks manually in the terminal would be a tedious process, so the next requirement for our development environment is </span><em class="italic"><span class="koboSpan" id="kobo.75.1">build automation</span></em><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">The first candidate for build automation is the </span><strong class="keyWord"><span class="koboSpan" id="kobo.77.1">make</span></strong><span class="koboSpan" id="kobo.78.1"> utility. </span><span class="koboSpan" id="kobo.78.2">It’s a common tool that’s used for automating huge amounts of software projects across different industries. </span><span class="koboSpan" id="kobo.78.3">It would be a good fit for the task, but it’s an old tool with odd syntax. </span><span class="koboSpan" id="kobo.78.4">However, we can use </span><strong class="keyWord"><span class="koboSpan" id="kobo.79.1">CMake</span></strong><span class="koboSpan" id="kobo.80.1">, a more flexible tool with more modern syntax that </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.81.1">can generate Makefiles for us.</span></p>
<h2 class="heading-2" id="_idParaDest-64"><span class="koboSpan" id="kobo.82.1">Build automation</span></h2>
<p><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">CMake</span></strong><span class="koboSpan" id="kobo.84.1"> isn’t</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.85.1"> an actual </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.86.1">build automation tool, but it generates files for other automation tools, such as the make utility. </span><span class="koboSpan" id="kobo.86.2">It’s cross-platform, free, and open source software for the build automation process, which involves testing, packaging, and installing software. </span><span class="koboSpan" id="kobo.86.3">It does so by using a compiler-independent method.</span></p>
<p><span class="koboSpan" id="kobo.87.1">We’ll use </span><strong class="keyWord"><span class="koboSpan" id="kobo.88.1">CMake</span></strong><span class="koboSpan" id="kobo.89.1"> to help us generate targets for the make utility that will do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.90.1">Configure source files, including paths and linker settings to build ELF files</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.91.1">Convert ELF files into hex and binary formats</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.92.1">Start the simulator and load it with the generated ELF file</span></li>
</ul>
<p><span class="koboSpan" id="kobo.93.1">We’ll use build automation not only to build the firmware but also to start the simulator that will run the firmware.</span></p>
<h2 class="heading-2" id="_idParaDest-65"><span class="koboSpan" id="kobo.94.1">Simulator</span></h2>
<p><span class="koboSpan" id="kobo.95.1">To make this book </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.96.1">accessible to a wide audience, we’ll be</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.97.1"> using a </span><strong class="keyWord"><span class="koboSpan" id="kobo.98.1">simulator</span></strong><span class="koboSpan" id="kobo.99.1"> to run the examples that have been compiled for the ARM Cortex M </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.100.1">target. </span><strong class="keyWord"><span class="koboSpan" id="kobo.101.1">Renode </span></strong><span class="koboSpan" id="kobo.102.1">(</span><a href="https://github.com/renode/renode)"><span class="url"><span class="koboSpan" id="kobo.103.1">https://github.com/renode/renode)</span></span></a><span class="koboSpan" id="kobo.104.1"> is an open source simulating framework with good support for ARM targets.</span></p>
<p><span class="koboSpan" id="kobo.105.1">Renode allows you to run simulations with multiple targets and simulate wireless and wired connections between them. </span><span class="koboSpan" id="kobo.105.2">We’ll use it in a simple scenario that involves running simulations on a single target. </span><span class="koboSpan" id="kobo.105.3">Renode can also start a GDB server, allowing you to connect to it and debug the target.</span></p>
<p><span class="koboSpan" id="kobo.106.1">We’ll integrate simulation execution and debugging, as well as compiler and build automation, using</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.107.1"> the highly configurable </span><strong class="keyWord"><span class="koboSpan" id="kobo.108.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.109.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-66"><span class="koboSpan" id="kobo.110.1">Code editor</span></h2>
<p><strong class="keyWord"><span class="koboSpan" id="kobo.111.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.112.1"> is a modern</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.113.1"> and flexible </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.114.1">code editor. </span><span class="koboSpan" id="kobo.114.2">It provides us with all the extensions we need to integrate all our tools into a single environment. </span><span class="koboSpan" id="kobo.114.3">We’ll install the following extensions in Visual Studio Code:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.115.1">C/C++</span></strong><span class="koboSpan" id="kobo.116.1">: This extension </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.117.1">provides syntax highlighting, code autocompletion, and code navigation</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.118.1">Cortex-Debug</span></strong><span class="koboSpan" id="kobo.119.1">: This extension allows debugging to be performed via GDB</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.120.1">CS 128 Clang-Tidy</span></strong><span class="koboSpan" id="kobo.121.1">: This extension integrates clang-tidy into Visual Studio Code</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.122.1">Dev Containers</span></strong><span class="koboSpan" id="kobo.123.1">: This extension attaches to running a container and uses it for development purposes</span></li>
</ul>
<p><span class="koboSpan" id="kobo.124.1">We’ll base our development environment on a Docker container. </span><span class="koboSpan" id="kobo.124.2">Visual Studio Code will attach to that container and use it.</span></p>
<h1 class="heading-1" id="_idParaDest-67"><span class="koboSpan" id="kobo.125.1">Containerized development environment</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.126.1">The Visual Studio</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.127.1"> Code Dev Containers extension allows Visual Studio Code to attach to a running Docker container and use all the tools inside it that have been installed. </span><span class="koboSpan" id="kobo.127.2">To use this feature, we need to build a container.</span></p>
<p><span class="koboSpan" id="kobo.128.1">We’ll use Docker to build a container with the following tools:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.129.1">ARM GNU Toolchain version 13.2</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.130.1">CMake and the make utility</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.131.1">Renode version 1.14</span></li>
</ul>
<p><span class="koboSpan" id="kobo.132.1">Make sure you’ve installed Docker on your host machine by following the instructions provided on the official website (</span><a href="https://docs.docker.com)"><span class="url"><span class="koboSpan" id="kobo.133.1">https://docs.docker.com)</span></span></a><span class="koboSpan" id="kobo.134.1">.</span></p>
<p><span class="koboSpan" id="kobo.135.1">You can find the </span><strong class="keyWord"><span class="koboSpan" id="kobo.136.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.137.1"> that will be used to build the container in this book’s GitHub repository (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)"><span class="url"><span class="koboSpan" id="kobo.138.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)</span></span></a><span class="koboSpan" id="kobo.139.1">, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">Chapter04</span></code><span class="koboSpan" id="kobo.141.1"> folder.</span></p>
<p><span class="koboSpan" id="kobo.142.1">There’s also an image that you can download from Docker Hub (</span><a href="https://hub.docker.com/)."><span class="url"><span class="koboSpan" id="kobo.143.1">https://hub.docker.com/).</span></span></a><span class="koboSpan" id="kobo.144.1"> You can pull it using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.145.1">$ docker pull mahmutbegovic/cpp_in_embedded_systems:latest
</span></code></pre>
<p><span class="koboSpan" id="kobo.146.1">Make sure that the Docker daemon has been started by following the instructions for your platform; they’re available on the official website. </span><span class="koboSpan" id="kobo.146.2">After downloading the image, start Docker using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.147.1">$ docker run -d -it --name dev_env mahmutbegovic/cpp_in_embedded_systems
</span></code></pre>
<p><span class="koboSpan" id="kobo.148.1">This will start the</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.149.1"> Docker container in detached and interactive mode. </span><span class="koboSpan" id="kobo.149.2">If you’ve already created A Docker container using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">docker run</span></code><span class="koboSpan" id="kobo.151.1"> command, you need to start it by running the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.152.1">$ docker start dev_env
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.153.1">To access the bash of the started container, we can use the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.154.1">$ docker exec -it dev_env /bin/bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.155.1">As shown in the following screenshot, we can run various commands to ensure the compiler, debugger, simulator, and other tools have been installed in the container:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.156.1"><img alt="Figure 4.1 – Development environment container bash" src="../Images/B22402_04_01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.157.1">Figure 4</span></span><span class="koboSpan" id="kobo.158.1">.1 – Development environment container bash</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.159.1">Figure 4.1</span></em><span class="koboSpan" id="kobo.160.1"> shows the</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.161.1"> expected outputs from the commands we used to check the versions of the tools that we’ve installed.</span></p>
<p><span class="koboSpan" id="kobo.162.1">We can use the running container as a self-contained environment. </span><span class="koboSpan" id="kobo.162.2">Let’s start by cloning the project GitHub repository (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):"><span class="url"><span class="koboSpan" id="kobo.163.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):</span></span></a></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.164.1">$ git clone https://github.com/PacktPublishing/Cpp-in-Embedded-Systems.git
</span></code></pre>
<p><span class="koboSpan" id="kobo.165.1">Once you’ve done this, go to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">Chapter04/bare</span></code><span class="koboSpan" id="kobo.167.1"> folder. </span><span class="koboSpan" id="kobo.167.2">This folder contains the </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Hello, World!</span></em><span class="koboSpan" id="kobo.169.1"> example firmware for STM32F072 that we’ll run in Renode. </span><span class="koboSpan" id="kobo.169.2">The project is organized into the following folders:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">app</span></code><span class="koboSpan" id="kobo.171.1">: Contains the business layer code, including </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">main.cpp</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">hal</span></code><span class="koboSpan" id="kobo.174.1">: Contains the HAL C++ code</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">platform</span></code><span class="koboSpan" id="kobo.176.1">: Contains platform-specific code, including the ST-provided HAL layer in C and the CMSIS, startup, and linker scripts</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">renode_scripts</span></code><span class="koboSpan" id="kobo.178.1">: Contains Renode simulator scripts</span></li>
</ul>
<p><span class="koboSpan" id="kobo.179.1">In the project folder, you’ll </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.180.1">also see </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">CMakeLists.txt</span></code><span class="koboSpan" id="kobo.182.1">, a CMake file that we’ll use to specify how the firmware is built. </span><span class="koboSpan" id="kobo.182.2">Let’s learn how to use CMake with the help of an example.</span></p>
<h2 class="heading-2" id="_idParaDest-68"><span class="koboSpan" id="kobo.183.1">Building the Hello, World! </span><span class="koboSpan" id="kobo.183.2">program using CMake</span></h2>
<p><span class="koboSpan" id="kobo.184.1">We can use CMake to </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.185.1">specify a toolchain, source files, compiler</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.186.1"> include paths, and compiler </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.187.1">flags. </span><span class="koboSpan" id="kobo.187.2">The first thing we must do in a CMake file is specify the CMake version that’s in use, as shown in the following line:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.188.1">cmake_minimum_required(VERSION 3.13)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.189.1">CMake is a powerful tool that allows us to write highly flexible build files. </span><span class="koboSpan" id="kobo.189.2">We can write toolchain details in separate files and include them in the main project file, which would allow us to reuse them for different architectures. </span><span class="koboSpan" id="kobo.189.3">However, in our example, we have the toolchain details in the main CMake file. </span><span class="koboSpan" id="kobo.189.4">The following lines specify various toolchain components:</span></p>
<p><span class="koboSpan" id="kobo.190.1">set(CMAKE_C_COMPILER “arm-none-eabi-gcc”)</span></p>
<p><span class="koboSpan" id="kobo.191.1">set(CMAKE_CXX_COMPILER “arm-none-eabi-g++”)</span></p>
<p><span class="koboSpan" id="kobo.192.1">set(CMAKE_ASM_COMPILER “arm-none-eabi-gcc”)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">CMAKE_C_COMPILER</span></code><span class="koboSpan" id="kobo.195.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">CMAKE_CXX_COMPILER</span></code><span class="koboSpan" id="kobo.197.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">CMAKE_ASM_COMPILER</span></code><span class="koboSpan" id="kobo.199.1"> CMake variables, we specify paths for the C, C++, and assembler compilers, respectively. </span><span class="koboSpan" id="kobo.199.2">We need to use all three since our project contains ST-provided HAL written in C, our C++ code, and an assembly startup script.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.200.1">Now, we must specify various compiler options and preprocessor macros by running the following lines in our </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">CMakeLists.txt</span></code><span class="koboSpan" id="kobo.202.1"> file:</span></p>
<p><span class="koboSpan" id="kobo.203.1">set(CDEFS “-DUSE_HAL_DRIVER -DSTM32F072xB”)</span></p>
<p><span class="koboSpan" id="kobo.204.1">set(MCU “-mcpu=cortex-m0 -mthumb”)</span></p>
<p><span class="koboSpan" id="kobo.205.1">set(COMMON_FLAGS “${MCU} ${CDEFS} -fdata-sections -ffunction-sections -Wno-address-of-packed-member -Wall -Wextra -Wno-unused-parameter”)</span></p>
<p><span class="koboSpan" id="kobo.206.1">set(CMAKE_C_FLAGS “${COMMON_FLAGS}”)</span></p>
<p><span class="koboSpan" id="kobo.207.1">set(CMAKE_CXX_FLAGS “${COMMON_FLAGS} -Wno-register -fno-exceptions -fno-rtti -fno-threadsafe-statics”)</span></p>
<p><span class="koboSpan" id="kobo.208.1">Here, we set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">USE_HAL_DRIVER</span></code><span class="koboSpan" id="kobo.210.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">STM32F072xB</span></code><span class="koboSpan" id="kobo.212.1"> compile-time macros, which are used by ST’s HAL. </span><span class="koboSpan" id="kobo.212.2">Then, we set some compiler flags that are used for both C and C++ files:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">-mcpu=cortex-m0</span></code><span class="koboSpan" id="kobo.214.1"> and -</span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">mthumb</span></code><span class="koboSpan" id="kobo.216.1">: Architecture-specific flags.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">-fdata-sections</span></code><span class="koboSpan" id="kobo.218.1">: This option tells the compiler to place data items in their own sections in the resulting objectfile. </span><span class="koboSpan" id="kobo.218.2">This can be useful for optimization purposes (removing unused sections).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">-ffunction-sections</span></code><span class="koboSpan" id="kobo.220.1">: Similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">-fdata-sections</span></code><span class="koboSpan" id="kobo.222.1">, but for functions. </span><span class="koboSpan" id="kobo.222.2">Each function gets its own section, allowing the linker to potentially discard unused functions.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.223.1">-Wno-address-of-packed-member</span></code><span class="koboSpan" id="kobo.224.1">: Suppresses warnings related to taking the address of a </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.225.1">packed </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.226.1">member of a structure.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">-Wall</span></code><span class="koboSpan" id="kobo.228.1">: Enables</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.229.1"> all the common warning messages recommended for normal operation.</span></li>
</ul>
<ul>
<li><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">-Wextra</span></code><span class="koboSpan" id="kobo.231.1">: Enables extra warning flags that aren’t enabled by </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">-Wall</span></code><span class="koboSpan" id="kobo.233.1">.</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">-Wno-unused-parameter</span></code><span class="koboSpan" id="kobo.235.1">: Disables warnings about unused parameters in functions.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.236.1">Then, we set the C++-specific compiler flags:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">-Wno-register</span></code><span class="koboSpan" id="kobo.238.1">: Disables warnings about the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">register</span></code><span class="koboSpan" id="kobo.240.1"> keyword, which is deprecated in modern C++ but might be used in legacy code</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">-fno-exceptions</span></code><span class="koboSpan" id="kobo.242.1">: Disables support for exceptions in C++</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">-fno-rtti</span></code><span class="koboSpan" id="kobo.244.1">: Disables </span><strong class="keyWord"><span class="koboSpan" id="kobo.245.1">Run-Time Type Information</span></strong><span class="koboSpan" id="kobo.246.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.247.1">RTTI</span></strong><span class="koboSpan" id="kobo.248.1">)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">-fno-threadsafe-statics</span></code><span class="koboSpan" id="kobo.250.1">: Prevents </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.251.1">the compiler from using extra code to ensure that static local variables are initialized in a thread-safe way</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.252.1">The next part of our CMake file is project-specific: we must declare a new project, give it a name, enable the languages we want to use, and specify a CMake target, source files, and linker options.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.253.1">This is our basic</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.254.1"> setup</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.255.1"> compiler setup for a C++ (mixed with C) project:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.256.1">project</span></span><span class="koboSpan" id="kobo.257.1">(bare VERSION </span><span class="hljs-number"><span class="koboSpan" id="kobo.258.1">1.0</span></span><span class="koboSpan" id="kobo.259.1">.</span><span class="hljs-number"><span class="koboSpan" id="kobo.260.1">6</span></span><span class="koboSpan" id="kobo.261.1">)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.262.1">enable_language</span></span><span class="koboSpan" id="kobo.263.1">(C CXX ASM)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.264.1">set</span></span><span class="koboSpan" id="kobo.265.1">(CMAKE_CXX_STANDARD </span><span class="hljs-number"><span class="koboSpan" id="kobo.266.1">17</span></span><span class="koboSpan" id="kobo.267.1">)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.268.1">set</span></span><span class="koboSpan" id="kobo.269.1">(CMAKE_CXX_STANDARD_REQUIRED </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.270.1">True</span></span><span class="koboSpan" id="kobo.271.1">)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.272.1"># global include directories</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">include_directories</span></span><span class="koboSpan" id="kobo.274.1">(
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.275.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.276.1">/platform/inc
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.277.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.278.1">/platform/CMSIS/Device/ST/STM32F0xx/</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.279.1">Include</span></span>
<span class="hljs-variable"><span class="koboSpan" id="kobo.280.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.281.1">/platform/CMSIS/</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.282.1">Include</span></span>
<span class="hljs-variable"><span class="koboSpan" id="kobo.283.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.284.1">/platform/STM32F0xx_HAL_Driver/Inc
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.285.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.286.1">/app/inc
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.287.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.288.1">/hal/uart/inc
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.289.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.290.1">/hal/inc
  )
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.291.1">set</span></span><span class="koboSpan" id="kobo.292.1">(EXECUTABLE </span><span class="hljs-variable"><span class="koboSpan" id="kobo.293.1">${PROJECT_NAME}</span></span><span class="koboSpan" id="kobo.294.1">.elf)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.295.1">add_executable</span></span><span class="koboSpan" id="kobo.296.1">(
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.297.1">${EXECUTABLE}</span></span><span class="koboSpan" id="kobo.298.1">
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_cortex.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_rcc.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart.c
  platform/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_uart_ex.c
  platform/startup_stm32f072xb.s
  platform/src/stm32f0xx_hal_msp.c
  platform/src/stm32f0xx_it.c
  platform/src/system_stm32f0xx.c
  app/src/main.cpp
  hal/uart/src/uart_stm32.cpp
  )
</span></code></pre>
<p><span class="koboSpan" id="kobo.299.1">In the preceding CMake code, we have </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">TARGET</span></code><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">This represents an entity that’s being built by a CMake, be it the entire firmware (an executable file) or a static library. </span><span class="koboSpan" id="kobo.301.3">In our case, the target is the entire firmware, and the target name is created using the project name and </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">.elf</span></code><span class="koboSpan" id="kobo.303.1"> suffix, meaning CMake will create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">bare.elf</span></code><span class="koboSpan" id="kobo.305.1"> target for us.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.306.1">The remaining</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.307.1"> step is to specify linker options using </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.308.1">the following lines:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">target_link_options</span></span><span class="koboSpan" id="kobo.310.1">(
  </span><span class="hljs-variable"><span class="koboSpan" id="kobo.311.1">${EXECUTABLE}</span></span><span class="koboSpan" id="kobo.312.1">
  PUBLIC
  -T</span><span class="hljs-variable"><span class="koboSpan" id="kobo.313.1">${CMAKE_SOURCE_DIR}</span></span><span class="koboSpan" id="kobo.314.1">/platform/STM32F072C8Tx_FLASH.ld
  -mcpu=cortex-m0
  -mthumb
  -specs=nano.specs
  -Wl,--no-warn-rwx-segments
  -Wl,-Map=</span><span class="hljs-variable"><span class="koboSpan" id="kobo.315.1">${PROJECT_NAME}</span></span><span class="koboSpan" id="kobo.316.1">.map,--cref
  -Wl,--gc-sections)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.317.1">Here, we specify the linker script to be used – that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">STM32F072C8Tx_FLASH.ld</span></code><span class="koboSpan" id="kobo.319.1"> – set a target CPU and</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.320.1"> instruction set, and specify the new-lib nano</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.321.1"> system library and map file to be</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.322.1"> created.</span></p>
<p><span class="koboSpan" id="kobo.323.1">Now, let’s build the firmware using CMake.</span></p>
<h2 class="heading-2" id="_idParaDest-69"><span class="koboSpan" id="kobo.324.1">Building a firmware using CMake</span></h2>
<p><span class="koboSpan" id="kobo.325.1">Here, we’ll create a </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.326.1">build folder and configure the build in </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">Debug</span></code><span class="koboSpan" id="kobo.328.1"> mode </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.329.1">using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.330.1">$ cd Cpp-in-Embedded-Systems/Chapter04/bare/
$ mkdir build &amp;&amp; cd build
$ cmake .. </span><span class="koboSpan" id="kobo.330.2">-DCMAKE_BUILD_TYPE=Debug
</span></code></pre>
<p><span class="koboSpan" id="kobo.331.1">If you list the files in the build folder using </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">ls –l</span></code><span class="koboSpan" id="kobo.333.1">, you’ll see that CMake generated </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">Makefile</span></code><span class="koboSpan" id="kobo.335.1">, which is used to build the firmware. </span><span class="koboSpan" id="kobo.335.2">Let’s run it to build the firmware:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.336.1">$ make -j4
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.337.1">You should see the following output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.338.1"><img alt="Figure 4.2 – Building the firmware" src="../Images/B22402_04_02.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.339.1">Figure 4</span></span><span class="koboSpan" id="kobo.340.1">.2 – Building the firmware</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.342.1">.2</span></em><span class="koboSpan" id="kobo.343.1"> shows the output of building the firmware. </span><span class="koboSpan" id="kobo.343.2">We can run the resulting ELF file, </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">bare.elf</span></code><span class="koboSpan" id="kobo.345.1">, in Renode using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.346.1">$ make run_in_renode
</span></code></pre>
<p><span class="koboSpan" id="kobo.347.1">This will start </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.348.1">the simulator using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">stm32f072.resc</span></code><span class="koboSpan" id="kobo.350.1"> Renode script from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">renode_scripts</span></code><span class="koboSpan" id="kobo.352.1"> folder. </span><span class="koboSpan" id="kobo.352.2">The script will create a new Renode machine using the STM32F072 target architecture and load it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">bare.elf</span></code><span class="koboSpan" id="kobo.354.1"> file. </span><span class="koboSpan" id="kobo.354.2">We’ll see the following as part of the terminal output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.355.1"><img alt="Figure 4.3 – Running firmware in Renode" src="../Images/B22402_04_03.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.356.1">Figure 4</span></span><span class="koboSpan" id="kobo.357.1">.3 – Running firmware in Renode</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.358.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.359.1">.3</span></em><span class="koboSpan" id="kobo.360.1"> shows the output of the simulation running in Renode in console mode with GUI disabled. </span><span class="koboSpan" id="kobo.360.2">To stop the</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.361.1"> simulation, type </span><em class="italic"><span class="koboSpan" id="kobo.362.1">q</span></em><span class="koboSpan" id="kobo.363.1"> and press </span><em class="italic"><span class="koboSpan" id="kobo.364.1">Enter</span></em><span class="koboSpan" id="kobo.365.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.366.1">Keep in mind that if </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.367.1">you stop or reset the Docker container, all the changes, including the cloned GitHub repository, will be lost. </span><span class="koboSpan" id="kobo.367.2">To prevent this from happening, you need to save them using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">docker commit</span></code><span class="koboSpan" id="kobo.369.1"> command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.370.1">At this point, we have a pretty development environment contained in a Docker container. </span><span class="koboSpan" id="kobo.370.2">However, to fully utilize it, we must connect it to Visual Studio Code.</span></p>
<h1 class="heading-1" id="_idParaDest-70"><span class="koboSpan" id="kobo.371.1">Containerized development environment and Visual Studio Code</span></h1>
<p><span class="koboSpan" id="kobo.372.1">To start, install </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.373.1">Visual Studio </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.374.1">Code (</span><a href="https://code.visualstudio.com/)"><span class="url"><span class="koboSpan" id="kobo.375.1">https://code.visualstudio.com/)</span></span></a><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">Once you’ve done this, go to </span><strong class="screenText"><span class="koboSpan" id="kobo.377.1">Extensions</span></strong><span class="koboSpan" id="kobo.378.1"> and search for and install the following extensions:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.379.1">C/C++</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.380.1">Cortex-Debug</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.381.1">CS 128 Clang-Tidy</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.382.1">Dev Containers</span></li>
</ul>
<p><span class="koboSpan" id="kobo.383.1">Once you’ve done this, open </span><strong class="screenText"><span class="koboSpan" id="kobo.384.1">View</span></strong><span class="koboSpan" id="kobo.385.1">| </span><strong class="screenText"><span class="koboSpan" id="kobo.386.1">Command Palette</span></strong><span class="koboSpan" id="kobo.387.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.388.1">Ctrl</span></em><span class="koboSpan" id="kobo.389.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.390.1">Shift</span></em><span class="koboSpan" id="kobo.391.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.392.1">P</span></em><span class="koboSpan" id="kobo.393.1">), find </span><strong class="screenText"><span class="koboSpan" id="kobo.394.1">Dev Containers: Attach to Running Container</span></strong><span class="koboSpan" id="kobo.395.1">, and select </span><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">dev_env</span></code><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">This should open a new Visual Studio Code window where the container’s name is in the bottom left bar:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.398.1"><img alt="Figure 4.4 – Visual Studio Code attached to a running container" src="../Images/B22402_04_04.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.399.1">Figure 4</span></span><span class="koboSpan" id="kobo.400.1">.4 – Visual Studio Code attached to a running container</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.401.1">Figure 4.4</span></em><span class="koboSpan" id="kobo.402.1"> shows that Visual Studio Code was successfully attached to the running container. </span><span class="koboSpan" id="kobo.402.2">Now, let’s open the project folder at </span><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">/workspace/Cpp-in-Embedded-Systems/Chapter04/bare</span></code><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">Open </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">main.cpp</span></code><span class="koboSpan" id="kobo.406.1"> in the </span><strong class="screenText"><span class="koboSpan" id="kobo.407.1">EXPLORER</span></strong><span class="koboSpan" id="kobo.408.1"> view and set a breakpoint on line 23, as shown</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.409.1"> in the</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.410.1"> following screenshot:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.411.1"><img alt="Figure 4.5 – Setting a breakpoint in Visual Studio Code" src="../Images/B22402_04_05.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.412.1">Figure 4</span></span><span class="koboSpan" id="kobo.413.1">.5 – Setting a breakpoint in Visual Studio Code</span></p>
<p class="normal"><span class="koboSpan" id="kobo.414.1">After setting</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.415.1"> a </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.416.1">breakpoint, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.417.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.418.1">.5</span></em><span class="koboSpan" id="kobo.419.1">, select </span><strong class="screenText"><span class="koboSpan" id="kobo.420.1">Run</span></strong><span class="koboSpan" id="kobo.421.1">| </span><strong class="screenText"><span class="koboSpan" id="kobo.422.1">Start Debugging</span></strong><span class="koboSpan" id="kobo.423.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.424.1">F5</span></em><span class="koboSpan" id="kobo.425.1">). </span><span class="koboSpan" id="kobo.425.2">This will do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.426.1">Configure the project in debug mode</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.427.1">Start the simulator and load ELF</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.428.1">Connect the GDB client to the GDB server running in the simulator</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.429.1">Allow you to debug the target running in the simulator</span></li>
</ul>
<p><span class="koboSpan" id="kobo.430.1">If everything has been set up correctly, the program flow will stop on line 23, and you’ll see the following output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.431.1"><img alt="Figure 4.6 – Visual Studio Code program flow" src="../Images/B22402_04_06.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.432.1">Figure 4</span></span><span class="koboSpan" id="kobo.433.1">.6 – Visual Studio Code program flow</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.434.1">Figure 4.6</span></em><span class="koboSpan" id="kobo.435.1"> shows that </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.436.1">the </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.437.1">program flow stopped on line 23. </span><span class="koboSpan" id="kobo.437.2">We can switch to the </span><strong class="screenText"><span class="koboSpan" id="kobo.438.1">TERMINAL</span></strong><span class="koboSpan" id="kobo.439.1"> view to see the output from Renode. </span><span class="koboSpan" id="kobo.439.2">Renode is in console mode, and it will also display </span><strong class="screenText"><span class="koboSpan" id="kobo.440.1">UART</span></strong><span class="koboSpan" id="kobo.441.1">. </span><span class="koboSpan" id="kobo.441.2">Let’s switch to the </span><strong class="screenText"><span class="koboSpan" id="kobo.442.1">TERMINAL</span></strong><span class="koboSpan" id="kobo.443.1"> view and hit </span><strong class="screenText"><span class="koboSpan" id="kobo.444.1">Continue</span></strong><span class="koboSpan" id="kobo.445.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.446.1">F5</span></em><span class="koboSpan" id="kobo.447.1">). </span><span class="koboSpan" id="kobo.447.2">You should see the following output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.448.1"><img alt="Figure 4.7 – Visual Studio Code Renode output" src="../Images/B22402_04_07.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.449.1">Figure 4</span></span><span class="koboSpan" id="kobo.450.1">.7 – Visual Studio Code Renode output</span></p>
<p><span class="koboSpan" id="kobo.451.1">In </span><em class="italic"><span class="koboSpan" id="kobo.452.1">Figure 4.7</span></em><span class="koboSpan" id="kobo.453.1">, we can see</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.454.1"> the </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.455.1">Renode output in Visual Studio Code’s </span><strong class="screenText"><span class="koboSpan" id="kobo.456.1">TERMINAL</span></strong><span class="koboSpan" id="kobo.457.1"> view. </span><span class="koboSpan" id="kobo.457.2">To be able to debug assembly files, we need to do the following in Visual Studio Code:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.458.1">Go to </span><strong class="screenText"><span class="koboSpan" id="kobo.459.1">File</span></strong><span class="koboSpan" id="kobo.460.1">|</span><strong class="screenText"><span class="koboSpan" id="kobo.461.1">Preferences</span></strong><span class="koboSpan" id="kobo.462.1">|</span><strong class="screenText"><span class="koboSpan" id="kobo.463.1">Settings</span></strong><span class="koboSpan" id="kobo.464.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.465.1">Search for </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">Allow Breakpoints Everywhere</span></code><span class="koboSpan" id="kobo.467.1"> and select the relevant checkbox.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.468.1">Now, we can set a breakpoint in </span><strong class="screenText"><span class="koboSpan" id="kobo.469.1">platform/startup_stm32f072xb.s</span></strong><span class="koboSpan" id="kobo.470.1"> on line 87, stop the debugging session, and run it again. </span><span class="koboSpan" id="kobo.470.2">The program flow should stop, as shown here:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.471.1"><img alt="Figure 4.8 – Visual Studio Code assembly debugging" src="../Images/B22402_04_08.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.472.1">Figure 4</span></span><span class="koboSpan" id="kobo.473.1">.8 – Visual Studio Code assembly debugging</span></p>
<p><span class="koboSpan" id="kobo.474.1">In </span><em class="italic"><span class="koboSpan" id="kobo.475.1">Figure 4.8</span></em><span class="koboSpan" id="kobo.476.1">, we can see that the program flow executes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">SystemInit</span></code><span class="koboSpan" id="kobo.478.1"> function on line 87 of the assembly startup script, before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">main</span></code><span class="koboSpan" id="kobo.480.1"> function. </span><span class="koboSpan" id="kobo.480.2">If we use </span><strong class="screenText"><span class="koboSpan" id="kobo.481.1">Step Into</span></strong><span class="koboSpan" id="kobo.482.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.483.1">F11</span></em><span class="koboSpan" id="kobo.484.1">), the program flow will enter the </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">SystemInit</span></code><span class="koboSpan" id="kobo.486.1"> function and Visual Studio Code will open </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">platform/src/system_stm32f0xx.c</span></code><span class="koboSpan" id="kobo.488.1"> file. </span><span class="koboSpan" id="kobo.488.2">If you keep moving using </span><strong class="screenText"><span class="koboSpan" id="kobo.489.1">Step Over</span></strong><span class="koboSpan" id="kobo.490.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.491.1">F10</span></em><span class="koboSpan" id="kobo.492.1">), you’ll eventually enter the </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.493.1">main</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.494.1"> function. </span><span class="koboSpan" id="kobo.494.2">This shows us that </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">main</span></code><span class="koboSpan" id="kobo.496.1"> isn’t the first function to be called.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Note that </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">Reset_Handler</span></code><span class="koboSpan" id="kobo.499.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">startup_stm32f072xb.s</span></code><span class="koboSpan" id="kobo.501.1"> is the entry point of the firmware. </span><span class="koboSpan" id="kobo.501.2">This is defined in the linker script (</span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">platform/STM32F072C8Tx_FLASH.ld</span></code><span class="koboSpan" id="kobo.503.1">). </span><span class="koboSpan" id="kobo.503.2">It does the following:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.504.1">Initializes the stack pointer</span></strong><span class="koboSpan" id="kobo.505.1">: It sets the initial stack pointer from the end of the stack (</span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">_estack</span></code><span class="koboSpan" id="kobo.507.1">).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.508.1">Copies data</span></strong><span class="koboSpan" id="kobo.509.1">: It copies the initialization values from flash memory to SRAM for the data section, which ensures that initialized global/static variables are set up correctly.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.510.1">Zeroes BSS</span></strong><span class="koboSpan" id="kobo.511.1">: It clears the BSS section by setting it to zero, which is required for uninitialized global/static variables.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.512.1">Calls SystemInit</span></strong><span class="koboSpan" id="kobo.513.1">: The </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">SystemInit</span></code><span class="koboSpan" id="kobo.515.1"> function is used to set the default system clock (system clock source, PLL multiplier and divider factors, AHB/APBx prescalers, and flash settings).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.516.1">Calls __libc_init_array</span></strong><span class="koboSpan" id="kobo.517.1">: The </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">__libc_init_array</span></code><span class="koboSpan" id="kobo.519.1"> function is used to initialize the static constructors in a C++ program or to run initialization functions in C programs.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.520.1">Calls main</span></strong><span class="koboSpan" id="kobo.521.1">: This operation concludes the activities of the startup script and transfers program flow to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.522.1">main</span></code><span class="koboSpan" id="kobo.523.1"> function.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.524.1">With our modern development environment now fully set up, we’re ready to dive into learning C++ for embedded systems. </span><span class="koboSpan" id="kobo.524.2">The Renode simulator allows us to run, test, and debug our firmware efficiently, eliminating </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.525.1">the need</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.526.1"> for physical hardware in the initial stages of development. </span><span class="koboSpan" id="kobo.526.2">This provides a flexible and efficient solution for embedded system learning and testing.</span></p>
<h1 class="heading-1" id="_idParaDest-71"><span class="koboSpan" id="kobo.527.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.528.1">In this chapter, we defined the components of our development environment for C++ in embedded systems. </span><span class="koboSpan" id="kobo.528.2">We went through all of its components using a Docker container, which we connected to Visual Studio Code to enable a seamless development experience and debugging.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.529.1">We also set up compiler flags using CMake, ran the firmware using the Renode simulator, and learned how to set up our C and C++ runtime environment by going through the relevant assembly startup script using a debugger.</span></p>
<p><span class="koboSpan" id="kobo.530.1">In the next chapter, we’ll use the development environment we created in this chapter to learn more about classes in C++.</span></p>
</div>
</body></html>