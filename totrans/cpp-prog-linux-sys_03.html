<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-49"><a id="_idTextAnchor047"/>3</h1>
<h1 id="_idParaDest-50"><a id="_idTextAnchor048"/>Navigating through the Filesystems</h1>
<p>In this chapter, we will revisit the concepts of a file, which were discussed briefly in <a href="B20833_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>. You will learn in detail about the <strong class="bold">filesystem</strong> (<strong class="bold">FS</strong>) in Linux and its specifics. We will not go to certain filesystem implementations, as you will see there’re many, but we will establish the fundamentals of working with them. You will learn more about Linux’s FS hierarchy – its partitions, object types, and some frequently used operations.</p>
<p>You will get familiar with<a id="_idIndexMarker221"/> the <code>string_views</code>. Some of the operations you learn about here will be revisited again in <a href="B20833_05.xhtml#_idTextAnchor075"><em class="italic">Chapter 5</em></a>, when we will discuss error handling.</p>
<p>Last but not least, you will learn hands-on about the fundamental <strong class="bold">inter-process communication </strong>(<strong class="bold">IPC</strong>) mechanism known<a id="_idIndexMarker222"/> as <strong class="bold">pipes</strong>. We will also discuss signals as system entities and their impact on communication. If you’re unfamiliar with data transfers between processes, then this is where you should start. If you are experienced, then you may notice that the code could be much more complicated – implementing server-client applications with pipes, for example. We are aware of that, but we believe that the examples are a good basis to start from – additional scalability of this mechanism has unwanted knock-on effects. We discuss this more in <a href="B20833_07.xhtml#_idTextAnchor101"><em class="italic">Chapter 7</em></a>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Going through Linux’s filesystem fundamentals</li>
<li>Executing filesystem operations with C++</li>
<li>IPC through anonymous pipes and named pipes</li>
<li>Briefly observing the signal handling</li>
</ul>
<h1 id="_idParaDest-51"><a id="_idTextAnchor049"/>Technical requirements</h1>
<p>In order to run the code examples, the reader must prepare the following:</p>
<ul>
<li>A Linux-based system capable of compiling and executing C and C++20 (for example, Linux Mint 21):<ul><li><strong class="bold">gcc12.2</strong> compiler: <a href="https://gcc.gnu.org/git/gcc.gitgcc-source">https://gcc.gnu.org/git/gcc.git gcc-source</a></li><li><strong class="bold">g++</strong> with <strong class="bold">-std=c++2a</strong> flags for the C++ code</li><li><strong class="bold">gcc </strong>without flags for the C code</li></ul></li>
<li>For all the examples, you can alternatively use <a href="https://godbolt.org/%0D">https://godbolt.org/.</a></li>
<li>Code examples could be found here: <a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203</a><a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203%0D"/></li>
</ul>
<h1 id="_idParaDest-52"><a id="_idTextAnchor050"/>Going through Linux’s filesystem fundamentals</h1>
<p>We went through some of the Unix (and Linux) filesystem definitions in <a href="B20833_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>. Let’s see how<a id="_idIndexMarker223"/> they really matter in the bigger picture of system programming. You probably remember what types of files there are in the Linux system – regular files, directories, special files, links, sockets, and named pipes. We are going to deal with most of them in this chapter and learn about what purpose they serve. One way to think about files in Unix, including Linux, is the following simple statement:</p>
<p>“<em class="italic">On a UNIX system, everything is a file; if something is not a file, it is </em><em class="italic">a process.</em>”</p>
<p>So, everything that’s not a process has an API, which includes file operation system calls. Let’s agree that a file is the main instrument for the logical organization of data. Then there must be something that is the main instrument for file organization. Well, this is where the file management system, or simply <a id="_idIndexMarker224"/>the FS, comes into play. It looks after the files’ layout on the physical medium – the <code>open()</code>, <code>write()</code>), and so on.</p>
<p>The FS also allows the user to forget the hardware’s specifics for a moment and focus on data operations, as well as using the FS like an ordered catalog. It helps with the files’ structure and data visualization on the UI or CLI, access permissions, and the effective usage of resources. While the user has the chance to focus on file creation, deletion, modifications, and <a id="_idIndexMarker226"/>sharing, the FS cares more about data accuracy, device driver error handling, multiple user accesses, and so on. This is an important point, as we will observe some error states later in the book – for example, in <a href="B20833_05.xhtml#_idTextAnchor075"><em class="italic">Chapter 5</em></a>, where the FS is the entity that creates the exception cases. And it also affects task scheduling, as we mentioned earlier. Let’s look at the FS structure and its specifics in Linux.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor051"/>Linux’s FS</h2>
<p>We have to mention <a id="_idIndexMarker227"/>that there are many kinds of FSs. Each of them suits its own purposes, as the user experience implies multiple preferences, and not all of them exist together. Linux has the strength to support over 100 FSes. A combination of them can run simultaneously on a single system. This provides an opportunity for the user to operate with them optimally and benefit from all of them. If the FS is required just to organize the file structure, then an ordinary one could do the trick – for example, <code>ext2</code> or <code>FAT</code>. If we want file consistency and less error-prone operations, then<a id="_idIndexMarker228"/> a <code>ext4</code>, <code>ReiserFS</code>, or <code>XFS</code>. For online data <a id="_idIndexMarker229"/>stores, <code>NFS</code> and <code>CIFS</code>, might come in handy. Large files and a large number of small files require specific <a id="_idIndexMarker230"/>management, too, so <code>ZFS</code> and <code>btrfs</code>, are useful. Last, but not least, there are FSes that are not backed by physical storage but represent entities in the <code>proc</code>, <code>sys</code>, <code>ram</code>, and <code>tmp</code>. However, at an abstract level, the file operations seem to be the same. So, we can have a unified interface. It not only allows system programmers to use the different FSes in the same way but also allows the OS’s UI to visualize the file structure – all of the files and directories – under the same FS tree. Linux realizes this through<a id="_idIndexMarker232"/> the <strong class="bold">virtual filesystem</strong> (<strong class="bold">VFS</strong>). It is also referred to<a id="_idIndexMarker233"/> as <strong class="bold">virtual FS switch</strong> – a layer residing in the kernel, providing a generic interface for the programs. Before we go into detail, let’s see how it looks from a design standpoint.</p>
<div><div><img alt="Figure 3.1 – A VFS software layer in Linux kernel" height="993" src="img/Figure_3.1_B20833.jpg" width="630"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – A VFS software layer in Linux kernel</p>
<p>Additionally, the <a id="_idIndexMarker234"/>VFS is object-oriented. This will not help us much with C++ code, unfortunately. Still, it is a good example of object-oriented programming in C, as the objects are actually of a <code>struct</code> type, containing file data and function pointers to the file operations. We will talk about those objects a bit later in the chapter. Let’s look at the directory structure and standardized partitioning now.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor052"/>Directory structure and partitioning</h2>
<p>The directory structure<a id="_idIndexMarker235"/> in Linux is well <a id="_idIndexMarker236"/>presented in the <code>#!</code>. You can read more about them by executing this command:</p>
<pre class="console">
$ man magic</pre> <p>Getting back to the FS structure – it starts with the <code>root</code> directory, denoted with <code>/</code>. The <code>root</code> FS is mounted on that directory in the early stages of the system’s boot sequence. Every other <a id="_idIndexMarker237"/>FS is mounted during the OS startup or even later during normal operations. You can check your own configuration as follows:</p>
<pre class="console">
$ cat /etc/fstab
# /etc/fstab: static file system information.
...
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
# / was on /dev/sda5 during installation
UUID=618800a5-57e8-43c1-9856-0a0a14ebf344 /               ext4    errors=remount-ro 0       1
# /boot/efi was on /dev/sda1 during installation
UUID=D388-FA76  /boot/efi       vfat    umask=0077      0       1
/swapfile                                 none            swap    sw              0       0</pre> <p>It provides information about the <em class="italic">mount points</em> and the respective FS types. Outside this file, the FSes will be visible in the system as separate directories with their exact paths. Every one of them can be accessed through the <code>root</code> directory. An important point is that <code>/</code> and <code>/root</code> are different directories, as the first is the <code>root</code> directory and the latter is the home directory of the <em class="italic">root user</em>. Some other important partitions and directories are the following:</p>
<ul>
<li><code>/bin</code>: Includes common user executables.</li>
<li><code>/boot</code>: Includes the Linux system startup files, the static part of the kernel, and the bootloader configuration.</li>
<li><code>/dev</code>: Includes references to all peripheral hardware, which is represented through files with a special file type, <code>'c'</code> or <code>'b'</code>, and they provide access to the real devices. We mentioned these special file types in <a href="B20833_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</li>
<li><code>/etc</code>: Includes the system configuration files.</li>
<li><code>/home</code>: This is the top-level directory, which is available for user files, and all users have their respective common subdirectory there.</li>
<li><code>/lib</code>: This includes shared library files that are needed to start the system.</li>
<li><code>/mnt</code>: The temporary mount point for external FSes. It makes a good combination with <code>/media</code>, where media devices such as USB flash drives are mounted.</li>
<li><code>/opt</code>: This consists of optional files and third-party software applications.</li>
<li><code>/proc</code>: This contains information about the system resources.</li>
<li><code>/tmp</code>: This is a temporary directory used by the OS and several programs for temporal storage – it will be cleaned up after reboot.</li>
<li><code>/sbin</code>: This includes the system binary files, usually utilized by the system administrator.</li>
<li><code>/usr</code>: This includes read-only files most of the time, but there are exceptions. It is for programs, libraries and binaries, <em class="italic">man</em> files, and documentation.</li>
<li><code>/var</code>: This includes variable data files – usually log files, database files, archived e-mails, and so on.</li>
</ul>
<p>Let’s <a id="_idIndexMarker238"/>get back to <strong class="bold">mount points</strong> and <strong class="bold">FS partitions</strong>. As <a id="_idIndexMarker239"/>not many people are familiar with those, we will take the <a id="_idIndexMarker240"/>opportunity to briefly explain them. A good reason for this is that, as already mentioned, system programmers work with many FSes at a time, and some of them are related to network drives or different devices.</p>
<p>Linux does not assign a letter to a partition as Windows does; therefore, you can easily confuse a separate device for a simple directory. Most of the time, this shouldn’t be a big deal, but it might become a problem when you care about resource management, resiliency, and security. For example, vehicles overall have strict requirements for hardware durability, which extends to 10-15 years of serviceability. With this in mind, you must be aware of a device’s characteristics, especially if you write on it frequently or fill its entire space meaninglessly. The way an FS manages the data is also crucial to a peripheral’s memory exhaustion in time, so this choice is important.</p>
<p><code>fstab</code> shows <a id="_idIndexMarker241"/>where FSes are mounted, but it also describes something else. First of all, let’s remember that <strong class="bold">FS partitions</strong> have <a id="_idIndexMarker242"/>the purpose of separating a single device – a hard drive, for example – into multiple partitions. This is used mostly in embedded systems with safety requirements. However, Linux also <a id="_idIndexMarker243"/>provides <strong class="bold">Logical Volume Manager</strong> (<strong class="bold">LVM</strong>), which allows flexible setups. In other words, FSes can easily get shrunk or enlarged, which is preferable on larger-scale systems.</p>
<p>The creation of multiple FSs serves not only as a user data grouping tool but also allows other partitions to remain intact if one goes out due to failure. Another usage is when a device’s storage is unavailable – often, it’s just full of data. The entire system might stop working because it also relies on storage space. Therefore, it is better to fill only a single FS entirely and raise an error. The other FS will be left intact, and the system will continue working. From that point of view, it is a secure and robust solution. Just keep in mind that it doesn’t protect you from overall device failure. For that reason, many network storage devices rely on<a id="_idIndexMarker244"/> a <strong class="bold">Redundant Array of Inexpensive Disks </strong>(<strong class="bold">RAID</strong>). We will not deal with it here, but we encourage you to read more about it.</p>
<p>Now, you probably observed some additional data in the <code>fstab</code> output earlier. Except for the <strong class="bold">root partition</strong>, we <a id="_idIndexMarker245"/>actually divide the partition types into <strong class="bold">data</strong> and <strong class="bold">swap</strong> partitions:</p>
<ul>
<li><strong class="bold">The data partition</strong>: This <a id="_idIndexMarker246"/>includes the root partition, together with all necessary information for system startup and normal run. It also includes standard data on Linux.</li>
<li><code>swap</code> in <code>fstab</code>, and it provides the system with the option to move data from the main memory to the NVM in cases of memory overflow. It is visible only to the system itself. This doesn’t mean you should overflow your RAM, but just keep it for extra flexibility in order to not compromise the system’s availability. Just remember, the NVM is much slower than the main memory chips!</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">The system administrator generally configures the partitions’ layout. Sometimes, one partition is spread across multiple NVM devices. This design is strictly related to the system’s purpose. Once the partitions are available to you as a user, you can only add more. We strongly discourage you from changing their properties unless you’re well aware of what you’re doing and why.</p>
<p>What <a id="_idIndexMarker248"/>about the <code>df</code> command. In our case, this is the following:</p>
<pre class="console">
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            5,9G     0  5,9G   0% /dev
tmpfs           1,2G  1,3M  1,2G   1% /run
/dev/sda5        39G   24G   14G  64% /
tmpfs           6,0G     0  6,0G   0% /dev/shm
tmpfs           5,0M  4,0K  5,0M   1% /run/lock
tmpfs           6,0G     0  6,0G   0% /sys/fs/cgroup
/dev/sda1       511M  4,0K  511M   1% /boot/efi
tmpfs           1,2G   16K  1,2G   1% /run/user/29999</pre> <p>It is easy to see the relationship between the FS type and the mount point, for example, the <code>Filesystem</code> and <code>Mounted on</code> columns. We will not go into more detail on this, but we encourage you to read more about the <code>parted</code> tool, which is used exactly for the creation and editing of partitions.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor053"/>Linux FS objects</h2>
<p>As we already <a id="_idIndexMarker251"/>mentioned in the previous section, the FS is realized through objects, and there are four main types we care about:</p>
<ul>
<li><strong class="bold">Superblock</strong>: This <a id="_idIndexMarker252"/>represents the mounted FS metadata – the respective device, the modification flags, the corresponding FS type, the FS access permissions, the modified files, and so on.</li>
<li><code>open()</code>, <code>create()</code>, <code>lookup()</code>, <code>mkdir()</code>. Regular<a id="_idIndexMarker255"/> files, special files, directories, and <code>stat</code> command:<pre class="source-code">
$ stat test
  File: test
  Size: 53248         Blocks: 104        IO Block: 4096   regular file
Device: 805h/2053d    Inode: 696116      Links: 1
Access: (0775/-rwxrwxr-x)  Uid: (29999/     oem)   Gid: (29999/     oem)
...</pre><p class="list-inset">Now, look at the permission bits – <code>0775/-rwxrwxr-x</code>. Both the numbers and the symbol flags have the same meaning but are different representations. <code>-</code> means the flag is not set. <code>r</code> means the file is readable by the current user, group, or everyone (reading left to right). <code>w</code> means <code>x</code> stands for <code>p</code> in front, it marks this file as a <code>1</code>. Other symbols you might see during your operations are <code>d</code> for <code>b</code> for <code>c</code> for <code>s</code> for <strong class="bold">sockets</strong>.</p></li> <li><strong class="bold">Directory entry (dentry)</strong>: For <a id="_idIndexMarker256"/>usability, we<a id="_idIndexMarker257"/> will not refer to physical files using numbers as the inode does but, instead, using names and locations. So, we need a translation table, mapping symbolic names (for users) to inode numbers (for the kernel). The easiest way to represent this is through the pathname, such as the following:<pre class="source-code">
$ ls -li test
696116 -rwxrwxr-x 1 oem oem 53248 Jul 30 08:29 test</pre><p class="list-inset">As you can see, the inode is the same as the previous example – <code>696116</code>, and the symbolic name is <code>test</code>.</p></li> <li><code>open()</code> and destroyed at <code>close()</code>. Some of the members this object contains are the <code>open()</code> method is called for the specific FS realization, and the file is placed into the file descriptor table of the calling process. In user-space, the file descriptor is used for the application’s file operations.</li>
</ul>
<p>The following diagram provides an overview of single-file access through multiple processes:</p>
<div><div><img alt="Figure 3.2 – File access organization" height="1075" src="img/Figure_3.2_B20833.jpg" width="1656"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – File access organization</p>
<p>We <a id="_idIndexMarker262"/>can see a<a id="_idIndexMarker263"/> few interesting things here. Although the processes open the same file, they go through different execution paths before reaching the real data. First of all, the processes have their <a id="_idIndexMarker264"/>own <code>fork()</code>, the child gets the same <strong class="bold">open file table</strong>. The independent process points to a separate one. Then, let’s say we have two <strong class="bold">dentries</strong> for the same file and our file objects point to it. Such a situation occurs when we reach the same physical file through different pathnames. As we work with the same file, the entries will point to a single inode and <strong class="bold">superblock</strong> instances. From then on, the exact FS, where the file resides, will take over with its specific functions.</p>
<p>One disclaimer, though – the OS is not an arbiter of simultaneous file updates by multiple processes. It will schedule those operations by the rules we discussed in the previous chapter. If you want to make a specific policy for such actions, then this must be designed and applied explicitly. Although the FS provides file locking as a <code>sudo rm -rf</code>, you might delete ones that are currently in use. This can lead to irreversible system issues. We use file locking to ensure safe, concurrent access to the file’s contents. It allows only one process to access the file at a given time, thus avoiding possible race conditions, which you will learn about in <a href="B20833_06.xhtml#_idTextAnchor086"><em class="italic">Chapter 6</em></a>. Linux supports two kinds of file locks – advisory locks and mandatory locks, which you can read more about here: <a href="https://www.kernel.org/doc/html/next/filesystems/locking.xhtml">https://www.kernel.org/doc/html/next/filesystems/locking.xhtml</a>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The unique numbers for physical file identification through the respective inodes are not endless. The VFS might contain so many tiny files that it exhausts its abilities to create new files, while there’s still free space on the NVM. This error is observed on high-scale systems more often than you may think.</p>
<p>You’ve probably also wondered about the ways to reach the same file through different pathnames. Well, do <a id="_idIndexMarker266"/>you recall our discussion on link files in <a href="B20833_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>? We talked about <strong class="bold">hard links</strong> and <strong class="bold">symbolic links</strong>. The <a id="_idIndexMarker267"/>first ones are always available for a given file – for example, when there’s at least one hard link, related to a piece of data, then the corresponding file is considered to exist in the FS. Through it, a pathname is directly associated with the point on the NVM where the file resides and can be opened from. Multiple pathnames to the same point on the device lead to multiple hard link constructions. Let’s check it out. First, we will list the data for some of our files:</p>
<pre class="console">
$ ls -li some_data
695571 -rw-rw-r-- 1 oem 5 May 28 18:13 some_data</pre> <p>Then, we will create a hard link for the same file through the <code>ln</code> command, and list both files:</p>
<pre class="console">
$ ln some_data some_data_hl
$ ls -li some_data some_data_hl
695571 -rw-rw-r-- 2 oem oem 5 May 28 18:13 some_data
695571 -rw-rw-r-- 2 oem oem 5 May 28 18:13 some_data_hl</pre> <p>As you can see, they both have the same inode because they have different character names, but they are the same file. The only true representation of the file is the <code>695571</code>. This means they truly point to the same block of the hard drive. Then, we see that the hard link counter has increased from <code>1</code> to <code>2</code> (between the access permissions and the <code>uid</code> columns).</p>
<p><code>ln</code> command again, but this time we will add the <code>-s</code> option. We will list all of the files so far:</p>
<pre class="console">
$ ln -s some_data some_data_sl
$ ls -li some_data some_data_hl some_data_sl
695571 -rw-rw-r-- 2 oem oem 5 May 28 18:13 some_data
695571 -rw-rw-r-- 2 oem oem 5 May 28 18:13 some_data_hl
694653 lrwxrwxrwx 1 oem oem 9 May 28 18:16 some_data_sl -&gt; some_data</pre> <p>You can easily see that the new file – <code>some_data_sl</code> – has a different inode from the original file and its <a id="_idIndexMarker269"/>hard link. It points to a new location in the NVM and has its own access permissions. In addition, it shows visually which pathname it truly points to. Even if there’s a symbolic link to a symbolic link, <code>ls -li</code> will still present the file a symbolic link is set to point to, such as the following:</p>
<pre class="console">
696063 -rw-rw-r--  1 oem oem  4247 Jul  2 13:25 test.dat
696043 lrwxrwxrwx  1 oem oem     8 Aug  6 10:07 testdat_sl -&gt; test.dat
696024 lrwxrwxrwx  1 oem oem    10 Aug  6 10:07 testdat_sl2 -&gt; testdat_sl</pre> <p>And check out the sizes in bytes – the original file is only <code>4247</code> bytes in size, while the symbolic link is <code>8</code> bytes, and the next is <code>10</code>. Actually, the original file size doesn’t matter for the symbolic link’s size, but something else does – you could figure it out by counting the number of characters in the referred file’s <strong class="bold">pathname</strong>.</p>
<p>All of the preceding filenames will provide you with the ability to access and modify the file. They also provide you with the flexibility to get data from multiple access points without duplication and meaningless usage of extra storage space. Many system programmers use symbolic links to reorder the FS, just for the purposes of easier data management for some specialized user processes. The Linux system itself does that, just to reorder the FS hierarchy for <a id="_idIndexMarker270"/>the same reasons. Let’s <a id="_idIndexMarker271"/>create an overview of this example through the following diagram:</p>
<div><div><img alt="Figure 3.3 – A hard link and symbolic link overview" height="387" src="img/Figure_3.3_B20833.jpg" width="1166"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – A hard link and symbolic link overview</p>
<p class="callout-heading">Important note</p>
<p class="callout">Even if the original file is moved or deleted, the symbolic link will continue to point to its pathname as a target, while the hard link must point to an existing file. The symbolic link will work across partitions, but the hard link doesn’t link paths on different volumes or FSes.</p>
<p>In the next section, we will continue to manipulate files, but this time through C++ code.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor054"/>Executing FS operations with C++</h1>
<p>With C++17 FS operations<a id="_idIndexMarker272"/> that are closer to the system programming are facilitated. The FS library allows the C++ developer to distinguish <a id="_idIndexMarker273"/>between the Linux fs types and perform certain operations with them. Let’s take a look at an exemplary interface:</p>
<pre class="source-code">
bool is_directory(const std::filesystem::path&amp; p)</pre> <p>This method checks whether a given pathname is a <code>is_fifo()</code>, <code>is_regular_file()</code>, <code>is_socket()</code>, and <code>is_symlink()</code>. Can you tell why we don’t have the <code>is_hardlink()</code> method? That’s right – if two files with different character names point to a single inode, then both of them provide access to the same content. It doesn’t matter whether the inode’s hard link counter is higher than one, although we could get it through the <code>hard_link_count()</code> method.</p>
<p>As the C++ language is compilable on multiple OSes, the FS functions are also dependent on the respective FSes for those exact systems. For example, FAT does not support symbolic links; therefore, the methods related to them will fail, and the error handling is left to the system programmer. You can use the <code>std::filesystem::filesystem_error</code> exception object to get details about the current error’s FS error state. Such discussions are available in <a href="B20833_05.xhtml#_idTextAnchor075"><em class="italic">Chapter 5</em></a>.</p>
<p>We <a id="_idIndexMarker274"/>mentioned earlier that the concurrent file access has <a id="_idIndexMarker275"/>to be managed by the software engineer, or the OS will schedule the operations as it sees fit. The same goes for this library, too. Don’t expect it to handle race conditions or modification conflicts itself. Now, let’s see how some of the operations can be used. One disclaimer though – as mentioned, error conditions will be discussed later, so we will not focus on them here.</p>
<p>We will create a new directory (marker <code>{1}</code> in the following code segment):</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;filesystem&gt;
using namespace std;
using namespace std::filesystem;
int main() {
    auto result = create_directory("test_dir"); // {1}
    if (result)
        cout &lt;&lt; "Directory created successfully!\n";
    else
        cout &lt;&lt; "Directory creation failed!\n";
    return 0;
}</pre> <p>Now, let’s see what happened on the FS:</p>
<pre class="console">
$ ./create_dir
Directory created successfully!</pre> <p>If you call the program again, it will fail, as the directory already exists:</p>
<pre class="console">
.$ /create_dir
Directory creation failed!</pre> <p>We<a id="_idIndexMarker276"/> populate the new directory, as described in the example earlier (<em class="italic">see </em><em class="italic">Figure 3</em><em class="italic">.3</em>), but this time with C++ code (markers <code>{1}</code> and <code>{2}</code> in the following code):</p>
<pre class="source-code">
...
int main() {
    if (exists("some_data")) {
       create_hard_link("some_data", "some_data_hl");// {1}
       create_symlink("some_data", "some_data_sl"); // {2}
    }
...</pre> <p>Of course, it is <a id="_idIndexMarker277"/>important to call the program from the directory, where <code>some_data</code> is, or provide its pathname accordingly – through the <code>some_data</code>, so it’s <code>9</code> bytes in size. Still, the picture is almost the same – of course, the inodes are different:</p>
<pre class="console">
79105062 rw-rw-r-- 2 oem oem 9 May 29 16:33 some_data
79105062 rw-rw-r-- 2 oem oem 9 May 29 16:33 some_data_hl
79112163 lrwxrwxrwx 1 oem oem 9 May 29 17:04 some_data_sl  -&gt; some_data</pre> <p>We also create by hand a new inner directory, called <code>inner_test_dir</code>, with a new file, called <code>inner_some_data</code>. Let’s iterate through the directory, both non-recursively (marker <code>{1}</code> in the following code) and recursively, and print out the directory contents (marker <code>{2}</code> in the following code):</p>
<pre class="source-code">
...
int main() {
    const path path_to_iterate{"test_dir"};
    for (auto const&amp; dir_entry :
        directory_iterator{path_to_iterate}) { // {1}
        cout &lt;&lt; dir_entry.path() &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
    for (auto const&amp; dir_entry :
        recursive_directory_iterator{path_to_iterate}) {
        cout &lt;&lt; dir_entry.path() &lt;&lt; endl; // {2}
    }
    return 0;
}</pre> <p>The<a id="_idIndexMarker278"/> output <a id="_idIndexMarker279"/>is not surprising:</p>
<pre class="console">
"test_dir/inner_test_dir"
"test_dir/some_data"
"test_dir/some_data_sl"
"test_dir/some_data_hl"
"test_dir/inner_test_dir"
"test_dir/inner_test_dir/inner_some_data"
"test_dir/some_data"
"test_dir/some_data_sl"
"test_dir/some_data_hl"</pre> <p>Now, we<a id="_idIndexMarker280"/> want to check whether some of the files are <a id="_idIndexMarker281"/>symbolic links (marker <code>{1}</code> in the following code), and if so, let’s print out their targets:</p>
<pre class="source-code">
...
int main() {
    const path path_to_iterate{"test_dir"};
    for (auto const&amp; dir_entry :
        recursive_directory_iterator{path_to_iterate}) {
        auto result = is_symlink(dir_entry.path()); // {1}
        if (result) cout &lt;&lt; read_symlink(dir_entry.path());
    }
}</pre> <p>Again, the output is as expected – the target is the initial source file:</p>
<pre class="console">
$ ./sym_link_check
"some_data"</pre> <p>Let’s try to rename the symbolic link file (marker <code>{1}</code> in the following code segment), before we continue with some other modifications:</p>
<pre class="source-code">
...
int main() {
    if (exists("some_data_sl")) {
        rename("some_data_sl", "some_data_sl_rndm"); // {1}
    }
...</pre> <p>We see that the renaming is successful:</p>
<pre class="console">
79112163 lrwxrwxrwx 1 oem oem 9 May 29 17:04 some_data_sl_rndm -&gt; some_data</pre> <p>Let’s<a id="_idIndexMarker282"/> remove the initial file – <code>some_data</code> (marker <code>{2}</code> in the following code), and observe the<a id="_idIndexMarker283"/> free space on the system changing (markers <code>{1}</code> and <code>{3}</code> in the following code):</p>
<pre class="source-code">
...
int main() {
    if (exists("some_data")) {
        std::filesystem::space_info space_obj =
            space(current_path());// {1}
        cout &lt;&lt; "Capacity: "
            &lt;&lt; space_obj.capacity &lt;&lt; endl;
        cout &lt;&lt; "Free: "
            &lt;&lt; space_obj.free &lt;&lt; endl;
        cout &lt;&lt; "Available: "
            &lt;&lt; space_obj.available &lt;&lt; endl;
        remove("some_data"); // {2}
        space_obj = space(current_path()); // {3}
        cout &lt;&lt; "Capacity: "
            &lt;&lt; space_obj.capacity &lt;&lt; endl;
        cout &lt;&lt; "Free: "
            &lt;&lt; space_obj.free &lt;&lt; endl;
        cout &lt;&lt; "Available: "
            &lt;&lt; space_obj.available &lt;&lt; endl;
    }
...</pre> <p>And here’s the output:</p>
<pre class="console">
Capacity: 41678012416
Free: 16555171840
Available: 14689452032
Capacity: 41678012416
Free: 16555175936
Available: 14689456128</pre> <p>As <a id="_idIndexMarker284"/>you can see <code>4096</code> bytes have been freed, although the <a id="_idIndexMarker285"/>file was only <code>9</code> bytes in size. This is because the minimum value we actually use is the size of one NVM block – the smallest unit of data the OS can write in or read from a file. In this case, it is 4 KB. If the details are not interesting to you, but you only want to check whether the space values have been updated, then with C++ 20, you also have the <code>==</code> operator overload; thus you can directly compare the two <code>space_info</code> objects, which are actually behind the returned values of <code>space()</code> (markers <code>{1}</code> and <code>{3}</code>).</p>
<p>We used these code examples to go quickly through the C++ filesystem library. We hope it is a good overview for you, although we have jumped a bit from function to function. It should be useful in your work. The next section deals with something very important – the fundamentals of multi-process communication. As you already know from the beginning of this chapter, Linux treats everything that’s not a process as a file. The same goes for communication resources, and we will delve into them armed with our C++ knowledge. There will be a bit more theory, so stay with us!</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor055"/>IPC through anonymous pipes and named pipes</h1>
<p>Before we <a id="_idIndexMarker286"/>even start working on this topic, let us ask you this. Have you ever done the following:</p>
<pre class="console">
$ cat some_data | grep data
some data</pre> <p>If yes, then you probably call <code>|</code> a <code>|</code>-symbolled pipe the same as them? No! That’s an anonymous pipe. System programmers differentiate between the so-called <code>pipefs</code>, while the user executes the standard VFS system calls. We are going to use pipes as examples to visualize some observations for the FS as well. Let’s get into it then!</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor056"/>Anonymous or unnamed pipes</h2>
<p><code>|</code> symbol, you can easily conclude that such implementation is related more to short-term communication, and it is not persistent in time. Anonymous pipes have two endpoints – a read one and a write one. Both of these are represented by a file descriptor. As soon as both endpoints are closed, the pipe will be destroyed, as there are no more ways to reference it through an open file descriptor. In addition, this type of communication is known as a simplex FIFO communication – for example, it creates a one-way-only data transfer – most often from a parent process to a child. Let’s see one example, which uses the system calls to create an anonymous pipe and a simple data transfer:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
using namespace std;
constexpr auto BUFF_LEN = 64;
constexpr auto pipeIn   = 0;
constexpr auto pipeOut  = 1;</pre> <p>We <a id="_idIndexMarker291"/>require an<a id="_idIndexMarker292"/> integer array to hold the file descriptors, representing the pipe’s <em class="italic">in</em> and <em class="italic">out</em> endpoints – <code>a_pipe</code>. Then, this array is passed to the <code>pipe()</code> system call, which will return <code>-1</code> if there is an error, or <code>0</code> on success (see marker <code>{1}</code>):</p>
<pre class="source-code">
int main() {
   int a_pipe[2]{};
   char buff[BUFF_LEN + 1]{};
   if (pipe(a_pipe) == -1) {  // {1}
       perror("Pipe creation failed");
       exit(EXIT_FAILURE);
   }
   else {
      if (int pid = fork(); pid == -1) {
         perror("Process creation failed");
         exit(EXIT_FAILURE);
      }
      else if (pid == 0) {
         // Child: will be the reader!
         sleep(1); // Just to give some extra time!
         close(a_pipe[pipeOut]); // {2}
         read(a_pipe[pipeIn], buff, BUFF_LEN); // {3}
         cout &lt;&lt; "Child: " &lt;&lt; buff &lt;&lt; endl;
     }</pre> <p>We create a new process through <code>fork()</code>, as we did in <a href="B20833_02.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>. Knowing this, can you tell how many pipes are created at the end? That’s right – one pipe is created, and the file descriptors are shared between the processes.</p>
<p>As the<a id="_idIndexMarker293"/> data <a id="_idIndexMarker294"/>transfer is one-way, we need to close the unused endpoint for each process – markers <code>{2}</code> and <code>{4}</code>. If the process writes and reads its own <strong class="bold">pipe</strong> in and out file descriptors, it will only get the information that it has written there beforehand:</p>
<pre class="source-code">
      else {
         // Parent: will be the writer!
         close(a_pipe[pipeIn]); // {4}
         const char *msg = {"Sending message to child!"};
         write(a_pipe[pipeOut], msg, strlen(msg) + 1);
         // {5}
      }
   }
   return 0;
}</pre> <p>In other words, we forbid the child from <em class="italic">talking</em><em class="italic"> back</em> to the parent, and the parent can only send data to the child. The data is sent simply by writing it into a file and reading from it (see markers <code>{3}</code> and <code>{5}</code>). This is a very simple piece of code, and usually, the communication through anonymous pipes is that simple. However, be careful – <code>write()</code> and <code>read()</code> are blocking calls; if there’s nothing to be read from the pipe (the pipe buffer is empty), the respective process-reader will be blocked. If the pipe capacity is exhausted (the pipe buffer is full), the process-writer will be blocked. If there’s no reader to consume the data, <code>SIGPIPE</code> will be triggered. We will provide such an example in the last section of this chapter. There’s no risk of race conditions in the way we will present them in <a href="B20833_06.xhtml#_idTextAnchor086"><em class="italic">Chapter 6</em></a>, but synchronization of data creation and consumption is still in the programmer’s hands. The next diagram provides you with some additional information on what happens when we use the anonymous pipe:</p>
<div><div><img alt="Figure 3.4 – An anonymous pipe communication mechanism" height="633" src="img/Figure_3.4_B20833.jpg" width="1044"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – An anonymous pipe communication mechanism</p>
<p>In the<a id="_idIndexMarker295"/> background, at <a id="_idIndexMarker296"/>the kernel level, there are a few more operations going on:</p>
<div><div><img alt="Figure 3.5 – Anonymous pipe creation" height="667" src="img/Figure_3.5_B20833.jpg" width="993"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Anonymous pipe creation</p>
<p>The pipe’s capacity can be checked and set using the <code>fcntl(fd, F_GETPIPE_SZ)</code> and <code>F_SETPIPE_SZ</code> operations, respectively. You can see that the pipe has 16 <em class="italic">pages</em> by default. The <em class="italic">page</em> is the smallest unit of data the <em class="italic">virtual memory</em> can manage. If a single page is 4,096 KB, then it could transfer 65,536 bytes of data before it overflows. We will discuss this later in the chapter. However, keep in mind that some systems may vary, and the info from <em class="italic">Figure 3</em><em class="italic">.5</em> might be wrong for you. In a similar fashion, we can represent what happens at a lower level during <code>read()</code> and <code>write()</code> operations.</p>
<p>In the following<a id="_idIndexMarker297"/> diagram, the question of using an FS as a shared (global) memory arises. Note that although the FS has its own protection mechanisms through mutexes, this will not help us at a user level to synchronize the data correctly. Simply modifying a regular file through <a id="_idIndexMarker298"/>multiple processes will cause trouble, as mentioned earlier. Doing so with a pipe will cause less trouble, but we are still not on the safe side. As you can see, the <strong class="bold">scheduler</strong> is<a id="_idIndexMarker299"/> involved, and we might end up in a <strong class="bold">deadlock</strong> of <a id="_idIndexMarker300"/>constantly waiting processes. This is easier to avoid with anonymous pipes than with named pipes.</p>
<div><div><img alt="Figure 3.6 – Pipe read and write operations" height="859" src="img/Figure_3.6_B20833.jpg" width="986"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Pipe read and write operations</p>
<p>Now that we have our communication established, why do we need an additional file type such as the named pipe? We will discuss this in the next section.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor057"/>Named pipes</h2>
<p>Named pipes <a id="_idIndexMarker301"/>are <em class="italic">a bit more complex</em> than anonymous pipes, as there’s more programable <a id="_idIndexMarker302"/>context to them. For example, they have character names and are observable by a user in an FS. They are not destroyed after a process finishes working with them but, instead, when a specific system call for the file removal is executed – <code>unlink()</code>. Therefore, we can say that they provide <em class="italic">persistency</em>. In a similar fashion to anonymous pipes, we can demonstrate named pipes in the following CLI command, creating <code>fifo_example</code> as a result:</p>
<pre class="console">
$ ./test &gt; fifo_example
$ cat fifo_example
$ Child: Sending message to child!</pre> <p>Also, the<a id="_idIndexMarker303"/> communication is duplexed – for example, the data transfer could work both ways. Still, your work might push you in the<a id="_idIndexMarker304"/> direction of wrapping system calls with C++ code. The next example provides a sample overview, with the disclaimer that it is exemplary, and as C++ context is added to the code, the program becomes larger in size. Let’s get an example from the <strong class="bold">pipe</strong> from earlier, which we can modify with C++ code, but the behavior remains the same:</p>
<pre class="source-code">
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;filesystem&gt;
#include &lt;string_view&gt;
using namespace std;
using namespace std::filesystem;
static string_view fifo_name     = "example_fifo"; // {1}
static constexpr size_t buf_size = 64;
void write(int out_fd,
           string_view message) { // {2}
    write(out_fd,
          message.data(),
          message.size());
}</pre> <p>At marker <code>{1}</code>, we introduce the <code>string_view</code> object. It represents a pair of pointers to a string or an array, and its respective size. As it is a <code>view-handle</code> class type, we preferably <a id="_idIndexMarker305"/>and cheaply pass it by value (see marker <code>{2}</code>), together with the expected substring <a id="_idIndexMarker306"/>operation interface. It is always <code>const</code>, so you don’t need to declare it as such. So, it’s an object and it’s bigger in size, but it has the benefit of being unconditionally safe – taking care of typical C string error cases, such as <code>NULL-termination</code>. Any issue will be handled at compile time. In our case, we can simply use it as a <code>const char*</code> or <code>const string</code> alternative. Let’s proceed with the reader:</p>
<pre class="source-code">
string read(int in_fd) { // {3}
    array &lt;char, buf_size&gt; buffer;
    size_t bytes = read(in_fd,
                        buffer.data(),
                        buffer.size());
    if (bytes &gt; 0) {
        return {buffer.data(), bytes}; // {4}
    }
    return {};
}
int main() {
    if (!exists(fifo_name))
        mkfifo(fifo_name.data(), 0666); // {5}
    if (pid_t childId = fork(); childId == -1) {
        perror("Process creation failed");
        exit(EXIT_FAILURE);
    }</pre> <p>Markers <code>{2}</code> and <code>{3}</code> show the C++ wrappers of <code>write()</code> and <code>read()</code> respectively. You can see that instead of doing <code>strlen()</code> or <code>sizeof()</code> acrobatics, we use the <code>string_view</code>’s and the <code>array</code>’s <code>data()</code> and <code>size()</code>, respectively, because they are packed together through the respective object. One important point is that we use <code>array&lt;char, buf_size&gt;</code> to be specific about the buffer size and type. Similarly, we can use <code>string</code> instead of <code>array</code>, as it is defined as <code>basic_string&lt;char&gt;</code>, and we can limit its size with <code>reserve(buf_size)</code>. The choice really depends on your<a id="_idIndexMarker307"/> needs later in the function. In our case, we will use <code>array</code> as a direct representation of reading a fixed-sized <code>char</code> buffer from the pipe. We construct the resultant <code>string</code> afterward or leave it empty (see marker <code>{4}</code>).</p>
<p>Now, we will <a id="_idIndexMarker308"/>use the already known <code>exists()</code> function to discard a second <code>mkfifo()</code> call by the process that arrives second. Then, we check whether the file is truly a FIFO (see marker <code>{6}</code>):</p>
<pre class="source-code">
    else {
        if(is_fifo(fifo_name)) { // {6}
            if (childId == 0) {
                if (int named_pipe_fd =
                        open(fifo_name.data(), O_RDWR);
                    named_pipe_fd &gt;= 0) { // {7}
                    string message;
                    message.reserve(buf_size);
                    sleep(1);
                    message = read(named_pipe_fd); // {8}
                    string_view response_msg
                        = "Child printed the message!";
                    cout &lt;&lt; "Child: " &lt;&lt; message &lt;&lt; endl;
                    write(named_pipe_fd,
                          response_msg); // {9}
                    close(named_pipe_fd);
                }</pre> <p>Now, look<a id="_idIndexMarker309"/> at markers <code>{7}</code> and <code>{10}</code>. Do you see where we open the pipe, where we keep this result, and where we check its value? Correct – we keep these operations packed together in the <code>if</code> statement, thus focusing our scope on the same logical place. Then, we <a id="_idIndexMarker310"/>read from the pipe through the newly added function wrapper (markers <code>{8}</code> and <code>{12}</code>). And then we write to the pipe through the <code>write()</code> wrapper (markers <code>{9}</code> and <code>{11}</code>). Note that at marker <code>{9}</code>, we pass <code>string_view</code> to the function, while at marker <code>{11}</code>, we pass a <code>string</code>. It works for both cases, thus additionally proving our point of using <code>string_views</code> for such interfaces, instead of <code>const string</code>, <code>const char *</code>, and so on:</p>
<pre class="source-code">
                else {
                    cout &lt;&lt; "Child cannot open the pipe!"
                         &lt;&lt; endl;
                }
            }
            else if (childId &gt; 0) {
                if (int named_pipe_fd =
                        open(fifo_name.data(), O_RDWR);
                    named_pipe_fd &gt;= 0) { // {10}
                    string message
                    = "Sending some message to the child!";
                    write(named_pipe_fd,
                          message); // {11}
                    sleep(1);
                    message = read(named_pipe_fd); // {12}
                    cout &lt;&lt; "Parent: " &lt;&lt; message &lt;&lt; endl;
                    close(named_pipe_fd);
                }
            }
            else {
                cout &lt;&lt; "Fork failed!";
      }</pre> <p>The pipe is<a id="_idIndexMarker311"/> removed at marker <code>{13}</code>, but we will keep it for experiments. For example, we can list the named pipe:</p>
<pre class="console">
$ ls -la example_fifo
prw-r--r-- 1 oem oem 0 May 30 13:45 example_fifo</pre> <p>Please <a id="_idIndexMarker312"/>observe that its size is <code>0</code>. This means that everything written in was consumed. On <code>close()</code>, the kernel will flush the file descriptors and will destroy the FIFO object in the main memory, as it did for the anonymous pipe. It is possible sometimes that the <em class="italic">reader</em> doesn’t consume the data fully. As you may remember, it can store data for 16 pages. That’s why we encourage you to use the number of bytes, returned by the <code>read()</code> and <code>write()</code> functions, to decide whether the processes have to be terminated or not. Now, look at the permission bits – do you see something interesting there? Yes – there is an extra <code>p</code> in front of them, which marks this file as a pipe. Did you observe this somewhere earlier in the chapter? If not, you can go back and check the permissions bits of the inode. </p>
<p>Let’s continue with the last code snippet:</p>
<pre class="source-code">
            remove(fifo_name); // {13}
        }
    }
    return 0;
}</pre> <p>This is a simple one-time ping-pong application with the following output:</p>
<pre class="console">
Child: Sending some message to the child!
Parent: Child printed the message!</pre> <p>You can still use <a id="_idIndexMarker313"/>an IO operation to send the message, but then <code>string_view</code> wouldn’t do. In the next section, we will provide a brief overview of what happens when communication through a pipe is disturbed. To keep the focus on system calls, we will put aside C++ for now.</p>
<p>Let’s now <a id="_idIndexMarker314"/>return to the C++ filesystem library. We can check whether the current file is truly a FIFO file through the library operations. If so, let’s delete it with the <code>remove()</code> function. It will be the same as <code>unlink()</code>, although one level of abstraction over the system call itself. Again, this will give us some platform independency:</p>
<pre class="source-code">
...
int main() {
    if (exists("example_fifo") &amp;&amp; is_fifo("example_fifo")){
        remove("example_fifo");
        cout &lt;&lt; "FIFO is removed";
    } ...</pre> <p>As you see, we use the already known methods, which were explained earlier in the chapter. Let’s see what happens at the VFS and kernel levels now:</p>
<div><div><img alt="Figure 3.7 – Named pipe creation system operations" height="862" src="img/Figure_3.7_B20833.jpg" width="767"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Named pipe creation system operations</p>
<p>This diagram, as <a id="_idIndexMarker315"/>well as the next one, gives you an example of why the anonymous pipe is considered a bit more lightweight. See how many functions calls there are between the initial system call from the process caller until the actual FS inode operation is executed. That said, together with the additional effort to close and delete files, it is easy to conclude<a id="_idIndexMarker316"/> that even the related code is larger. Still, the named pipe is used for persistency and communication between different processes, including ones that don’t have a parent-child relationship. Just think about it – you have the communication resource endpoint in the FS, you know its character name, and then you only have to open it from two independent processes, and start the data transfer. A similar approach is used by other IPC mechanisms, as we will discuss later in <a href="B20833_07.xhtml#_idTextAnchor101"><em class="italic">Chapter 7</em></a>. Until then, check out the following diagram to see how many operations there are between the simple <code>open()</code> function and the creation of the FIFO buffer in the kernel:</p>
<div><div><img alt="Figure 3.8 – Named pipe opening and transformation to pipe" height="886" src="img/Figure_3.8_B20833.jpg" width="671"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Named pipe opening and transformation to pipe</p>
<p>The <a id="_idIndexMarker317"/>filesystem<a id="_idIndexMarker318"/> library doesn’t allow you to directly work with the file descriptors. At the same time, the system calls expect them. Someday, it might be different in the C++ Standard.</p>
<p class="callout-heading">Note</p>
<p class="callout">There’s an already known non-standard approach to associating a file descriptor with <code>iostream</code>. You can refer to it here: <a href="http://www.josuttis.com/cppcode/fdstream.xhtml">http://www.josuttis.com/cppcode/fdstream.xhtml</a>.</p>
<p>We will use the next section to provide a brief overview of what happens when communication through a pipe is disturbed.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor058"/>Briefly observing signal handling</h1>
<p>Signals in<a id="_idIndexMarker319"/> Linux <a id="_idIndexMarker320"/>are a powerful and simple way to synchronize processes through software interrupts sent to them, indicating that an important event has occurred. They have a different nature, depending on their roles. Some of them are ignorable, while others are not and cause a process to be blocked, unblocked, or terminated. We discussed those behaviors in the previous chapter, but is there something we could do to gracefully handle them? We will use the anonymous pipe example to trigger a <code>SIGPIPE</code> signal. </p>
<p>Let’s see the following example:</p>
<pre class="source-code">
...
void handle_sigpipe(int sig) { // {1}
   printf("SIGPIPE handled!\n");
}
int main() {
   int an_pipe[2] = {0};
   char buff[BUFF_LEN + 1] = {0};
   if (pipe(an_pipe) == 0) {
      int pid = fork();
      if (pid == 0) {
         close(an_pipe[pipeOut]); // {2}
         close(an_pipe[pipeIn]);
      }</pre> <p>We define a <code>SIGPIPE</code> handler (marker <code>{1}</code>), where we could provide additional functionality if this signal is triggered. We intentionally close both the pipe endpoints of the child, so there’s no process that would read from it. Then, we declare a signal action, which maps<a id="_idIndexMarker321"/> the signal handler to the action itself (markers <code>{3}</code> and <code>{4}</code>). We provide some time for the child to close the file descriptors, and then we try to write in the <strong class="bold">pipe</strong>:</p>
<pre class="source-code">
      else {
         struct sigaction act = {0};
         sigemptyset(&amp;act.sa_mask);
         act.sa_handler = handle_sigpipe; // {3}
         if(sigaction(SIGPIPE, &amp;act, 0) == -1) {// {4}
            perror("sigaction"); return (1);
         }
         close(an_pipe[pipeIn]);
         sleep(1);
         const char *msg = {"Sending message to child!"};
         write(an_pipe[pipeOut], msg, strlen(msg) + 1);
// {5} ...</pre> <p>The kernel will trigger <code>SIGPIPE</code>, which intends to block the parent until there’s someone to read from it. In this case, we print out a message, telling the user that the signal is received and the parent process will be terminated. Actually, this is the default behavior to handle such a signal. We use the handle to inform the user accordingly:</p>
<pre class="console">
$ ./sighandler_test
SIGPIPE handled!</pre> <p>However, we can also ignore the signal through the following simple change on marker <code>{3}</code>:</p>
<pre class="source-code">
act.sa_handler = SIG_IGN; // {3}</pre> <p>Calling the program once again will not trigger the handler, which means that the signal is ignored and <a id="_idIndexMarker322"/>the process will continue as per its workflow. You can use both approaches in your code, but be careful – some signals cannot be ignored. We will use this knowledge later in the book.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor059"/>Summary</h1>
<p>In this chapter, we didn’t show any examples of file data modifications through C++. Our goals were mostly related to explaining the different Linux FS entities. We use the C++ filesystem library to enrich the knowledge in this direction – for example, improving system programming awareness. You learned about the roles of the different FS objects and their specifics. You also have the C++ instruments to manage file resources and level up your abstraction. There were also some hands-on examples of how to communicate between processes through anonymous and named pipes. Their implementation at the OS level was discussed as well, and we briefly explored signal handling in Linux.</p>
<p>In the next chapter, we will finally dive deeper into the C++ language, laying the foundations for its safe and secure usage, according to the latest standard. Later in the book, we will revisit some code segments shown in this chapter. We will continuously improve them through the usage of new C++ features.</p>
</div>
</div></body></html>