- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up the Development Environment for a C++ Embedded Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the embedded tools ecosystem and reviewed
    the most widely used tools in the industry. Now, we’ll set requirements for a
    modern embedded development environment and each of its components. Then, we’ll
    set up our development environment for running the examples that will be provided
    in the remainder of this book.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major selling points of integrated environments is their ease of
    use. They provide you with everything you need through simple installation steps.
    Customized environments, on the other hand, require all components to be installed
    individually, including all the dependencies for each component. It’s important
    to ensure reproducible builds and a reliable debugging environment, so containerizing
    customized environments is of great importance.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be provided with a Docker container for the development environment that
    we’ll be using in this book, but we’ll analyze all of its components individually.
    Understanding the tools that we use in our daily work is necessary to comprehend
    and control the processes behind them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for a modern software development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized development environment and Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have Docker installed ([https://www.docker.com/).](https://www.docker.com/).)
    Please follow the installation instructions provided for your specific operating
    system. This chapter will guide you through the basic steps for downloading and
    running a container with a preconfigured development environment. For more advanced
    Docker usage, please refer to the official Docker documentation available on their
    website.
  prefs: []
  type: TYPE_NORMAL
- en: The code from this chapter is available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).)
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for a modern software development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Firmware development** is no different than any other form of software development
    and the tools we use are crucial for effective work. To make this book and the
    examples accessible as much as possible, the first requirement we’ll set is to
    use free tools. The **compiler** is the basis and the most important part of every
    development requirement, so let’s define the requirements and choose a compiler
    for our needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we’re exploring modern C++, we’ll require compiler support for the C++23
    standard. The latest version of **ARM GNU Toolchain** (based on GCC) is 13.2;
    it supports C++23 and is free. It’s also the most commonly used free compiler
    toolchain for ARM development, making it a perfect fit for our compiler.
  prefs: []
  type: TYPE_NORMAL
- en: ARM GNU Toolchain comes with C and C++ compilers, **GNU Debugger** (**GDB**),
    which we’ll use for debugging, and other useful tools, such as `objcopy`, `objdump`,
    `size`, and more, and can be downloaded from [https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.)
    The architecture that we need for Arm Cortex-M is `arm-none-eabi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM GNU Toolchain for `arm-none-eabi` is available for all common host architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: GNU/Linux x86_64 and AArch64 host architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows x86 host architecture only (compatible with `x86_64`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS x86_64 and Apple silicon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compiling a single file or few files is as simple as running a few commands
    in the terminal, but building even the simplest embedded projects involves the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile all C and C++ source files, the file that contains the main function,
    and at least several files from **Hardware Abstraction Layer** (**HAL**). You’ll
    learn more about HAL in [*Chapter 12*](Chapter_12.xhtml).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up compiler include paths.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up compiler C and C++ flags.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up compiler define macros.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the startup assembly script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up linker options, including the linker script, static libraries, CPU architecture
    and instruction set, and standard library options.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon doing this, we must convert the ELF file into other formats that are commonly
    used by flashing programs, such as `bin` and `hex`.
  prefs: []
  type: TYPE_NORMAL
- en: Running all of these tasks manually in the terminal would be a tedious process,
    so the next requirement for our development environment is *build automation*.
    The first candidate for build automation is the **make** utility. It’s a common
    tool that’s used for automating huge amounts of software projects across different
    industries. It would be a good fit for the task, but it’s an old tool with odd
    syntax. However, we can use **CMake**, a more flexible tool with more modern syntax
    that can generate Makefiles for us.
  prefs: []
  type: TYPE_NORMAL
- en: Build automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CMake** isn’t an actual build automation tool, but it generates files for
    other automation tools, such as the make utility. It’s cross-platform, free, and
    open source software for the build automation process, which involves testing,
    packaging, and installing software. It does so by using a compiler-independent
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use **CMake** to help us generate targets for the make utility that will
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure source files, including paths and linker settings to build ELF files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert ELF files into hex and binary formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the simulator and load it with the generated ELF file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll use build automation not only to build the firmware but also to start
    the simulator that will run the firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make this book accessible to a wide audience, we’ll be using a **simulator**
    to run the examples that have been compiled for the ARM Cortex M target. **Renode**
    ([https://github.com/renode/renode)](https://github.com/renode/renode)) is an
    open source simulating framework with good support for ARM targets.
  prefs: []
  type: TYPE_NORMAL
- en: Renode allows you to run simulations with multiple targets and simulate wireless
    and wired connections between them. We’ll use it in a simple scenario that involves
    running simulations on a single target. Renode can also start a GDB server, allowing
    you to connect to it and debug the target.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll integrate simulation execution and debugging, as well as compiler and
    build automation, using the highly configurable **Visual Studio Code**.
  prefs: []
  type: TYPE_NORMAL
- en: Code editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio Code** is a modern and flexible code editor. It provides us
    with all the extensions we need to integrate all our tools into a single environment.
    We’ll install the following extensions in Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C/C++**: This extension provides syntax highlighting, code autocompletion,
    and code navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cortex-Debug**: This extension allows debugging to be performed via GDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CS 128 Clang-Tidy**: This extension integrates clang-tidy into Visual Studio
    Code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dev Containers**: This extension attaches to running a container and uses
    it for development purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll base our development environment on a Docker container. Visual Studio
    Code will attach to that container and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Containerized development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Visual Studio Code Dev Containers extension allows Visual Studio Code to
    attach to a running Docker container and use all the tools inside it that have
    been installed. To use this feature, we need to build a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use Docker to build a container with the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: ARM GNU Toolchain version 13.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake and the make utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renode version 1.14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you’ve installed Docker on your host machine by following the instructions
    provided on the official website ([https://docs.docker.com)](https://docs.docker.com)).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the **Dockerfile** that will be used to build the container in
    this book’s GitHub repository ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)),
    in the `Chapter04` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also an image that you can download from Docker Hub ([https://hub.docker.com/).](https://hub.docker.com/).)
    You can pull it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the Docker daemon has been started by following the instructions
    for your platform; they’re available on the official website. After downloading
    the image, start Docker using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the Docker container in detached and interactive mode. If you’ve
    already created A Docker container using the `docker run` command, you need to
    start it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the bash of the started container, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, we can run various commands to ensure
    the compiler, debugger, simulator, and other tools have been installed in the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Development environment container bash](img/B22402_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Development environment container bash
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.1* shows the expected outputs from the commands we used to check
    the versions of the tools that we’ve installed.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the running container as a self-contained environment. Let’s start
    by cloning the project GitHub repository ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done this, go to the `Chapter04/bare` folder. This folder contains
    the *Hello, World!* example firmware for STM32F072 that we’ll run in Renode. The
    project is organized into the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app`: Contains the business layer code, including `main.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hal`: Contains the HAL C++ code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`platform`: Contains platform-specific code, including the ST-provided HAL
    layer in C and the CMSIS, startup, and linker scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renode_scripts`: Contains Renode simulator scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the project folder, you’ll also see `CMakeLists.txt`, a CMake file that we’ll
    use to specify how the firmware is built. Let’s learn how to use CMake with the
    help of an example.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Hello, World! program using CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use CMake to specify a toolchain, source files, compiler include paths,
    and compiler flags. The first thing we must do in a CMake file is specify the
    CMake version that’s in use, as shown in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake is a powerful tool that allows us to write highly flexible build files.
    We can write toolchain details in separate files and include them in the main
    project file, which would allow us to reuse them for different architectures.
    However, in our example, we have the toolchain details in the main CMake file.
    The following lines specify various toolchain components:'
  prefs: []
  type: TYPE_NORMAL
- en: set(CMAKE_C_COMPILER “arm-none-eabi-gcc”)
  prefs: []
  type: TYPE_NORMAL
- en: set(CMAKE_CXX_COMPILER “arm-none-eabi-g++”)
  prefs: []
  type: TYPE_NORMAL
- en: set(CMAKE_ASM_COMPILER “arm-none-eabi-gcc”)
  prefs: []
  type: TYPE_NORMAL
- en: Using the `CMAKE_C_COMPILER`, `CMAKE_CXX_COMPILER`, and `CMAKE_ASM_COMPILER`
    CMake variables, we specify paths for the C, C++, and assembler compilers, respectively.
    We need to use all three since our project contains ST-provided HAL written in
    C, our C++ code, and an assembly startup script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must specify various compiler options and preprocessor macros by running
    the following lines in our `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: set(CDEFS “-DUSE_HAL_DRIVER -DSTM32F072xB”)
  prefs: []
  type: TYPE_NORMAL
- en: set(MCU “-mcpu=cortex-m0 -mthumb”)
  prefs: []
  type: TYPE_NORMAL
- en: set(COMMON_FLAGS “${MCU} ${CDEFS} -fdata-sections -ffunction-sections -Wno-address-of-packed-member
    -Wall -Wextra -Wno-unused-parameter”)
  prefs: []
  type: TYPE_NORMAL
- en: set(CMAKE_C_FLAGS “${COMMON_FLAGS}”)
  prefs: []
  type: TYPE_NORMAL
- en: set(CMAKE_CXX_FLAGS “${COMMON_FLAGS} -Wno-register -fno-exceptions -fno-rtti
    -fno-threadsafe-statics”)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we set the `USE_HAL_DRIVER` and `STM32F072xB` compile-time macros, which
    are used by ST’s HAL. Then, we set some compiler flags that are used for both
    C and C++ files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-mcpu=cortex-m0` and -`mthumb`: Architecture-specific flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fdata-sections`: This option tells the compiler to place data items in their
    own sections in the resulting objectfile. This can be useful for optimization
    purposes (removing unused sections).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ffunction-sections`: Similar to `-fdata-sections`, but for functions. Each
    function gets its own section, allowing the linker to potentially discard unused
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wno-address-of-packed-member`: Suppresses warnings related to taking the
    address of a packed member of a structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wall`: Enables all the common warning messages recommended for normal operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wextra`: Enables extra warning flags that aren’t enabled by `-Wall`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wno-unused-parameter`: Disables warnings about unused parameters in functions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we set the C++-specific compiler flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Wno-register`: Disables warnings about the use of the `register` keyword,
    which is deprecated in modern C++ but might be used in legacy code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fno-exceptions`: Disables support for exceptions in C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fno-rtti`: Disables **Run-Time Type Information** (**RTTI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fno-threadsafe-statics`: Prevents the compiler from using extra code to ensure
    that static local variables are initialized in a thread-safe way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next part of our CMake file is project-specific: we must declare a new
    project, give it a name, enable the languages we want to use, and specify a CMake
    target, source files, and linker options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our basic setup compiler setup for a C++ (mixed with C) project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding CMake code, we have `TARGET`. This represents an entity that’s
    being built by a CMake, be it the entire firmware (an executable file) or a static
    library. In our case, the target is the entire firmware, and the target name is
    created using the project name and `.elf` suffix, meaning CMake will create a
    `bare.elf` target for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining step is to specify linker options using the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify the linker script to be used – that is, `STM32F072C8Tx_FLASH.ld`
    – set a target CPU and instruction set, and specify the new-lib nano system library
    and map file to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s build the firmware using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Building a firmware using CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we’ll create a build folder and configure the build in `Debug` mode using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you list the files in the build folder using `ls –l`, you’ll see that CMake
    generated `Makefile`, which is used to build the firmware. Let’s run it to build
    the firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Building the firmware](img/B22402_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Building the firmware
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.2* shows the output of building the firmware. We can run the resulting
    ELF file, `bare.elf`, in Renode using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the simulator using the `stm32f072.resc` Renode script from
    the `renode_scripts` folder. The script will create a new Renode machine using
    the STM32F072 target architecture and load it with the `bare.elf` file. We’ll
    see the following as part of the terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Running firmware in Renode](img/B22402_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Running firmware in Renode
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.3* shows the output of the simulation running in Renode in console
    mode with GUI disabled. To stop the simulation, type *q* and press *Enter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if you stop or reset the Docker container, all the changes,
    including the cloned GitHub repository, will be lost. To prevent this from happening,
    you need to save them using the `docker commit` command.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a pretty development environment contained in a Docker
    container. However, to fully utilize it, we must connect it to Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Containerized development environment and Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, install Visual Studio Code ([https://code.visualstudio.com/)](https://code.visualstudio.com/)).
    Once you’ve done this, go to **Extensions** and search for and install the following
    extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: C/C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cortex-Debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CS 128 Clang-Tidy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve done this, open **View**| **Command Palette** (*Ctrl* + *Shift*
    + *P*), find **Dev Containers: Attach to Running Container**, and select `dev_env`.
    This should open a new Visual Studio Code window where the container’s name is
    in the bottom left bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Visual Studio Code attached to a running container](img/B22402_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Visual Studio Code attached to a running container
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.4* shows that Visual Studio Code was successfully attached to the
    running container. Now, let’s open the project folder at `/workspace/Cpp-in-Embedded-Systems/Chapter04/bare`.
    Open `main.cpp` in the **EXPLORER** view and set a breakpoint on line 23, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Setting a breakpoint in Visual Studio Code](img/B22402_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Setting a breakpoint in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting a breakpoint, as shown in *Figure 4**.5*, select **Run**| **Start
    Debugging** (*F5*). This will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the project in debug mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the simulator and load ELF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect the GDB client to the GDB server running in the simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow you to debug the target running in the simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If everything has been set up correctly, the program flow will stop on line
    23, and you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Visual Studio Code program flow](img/B22402_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Visual Studio Code program flow
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.6* shows that the program flow stopped on line 23\. We can switch
    to the **TERMINAL** view to see the output from Renode. Renode is in console mode,
    and it will also display **UART**. Let’s switch to the **TERMINAL** view and hit
    **Continue** (*F5*). You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Visual Studio Code Renode output](img/B22402_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Visual Studio Code Renode output
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.7*, we can see the Renode output in Visual Studio Code’s **TERMINAL**
    view. To be able to debug assembly files, we need to do the following in Visual
    Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File**|**Preferences**|**Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Allow Breakpoints Everywhere` and select the relevant checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can set a breakpoint in **platform/startup_stm32f072xb.s** on line
    87, stop the debugging session, and run it again. The program flow should stop,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Visual Studio Code assembly debugging](img/B22402_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Visual Studio Code assembly debugging
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4.8*, we can see that the program flow executes the `SystemInit`
    function on line 87 of the assembly startup script, before the `main` function.
    If we use **Step Into** (*F11*), the program flow will enter the `SystemInit`
    function and Visual Studio Code will open `platform/src/system_stm32f0xx.c` file.
    If you keep moving using **Step Over** (*F10*), you’ll eventually enter the main
    function. This shows us that `main` isn’t the first function to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `Reset_Handler` from `startup_stm32f072xb.s` is the entry point of
    the firmware. This is defined in the linker script (`platform/STM32F072C8Tx_FLASH.ld`).
    It does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializes the stack pointer**: It sets the initial stack pointer from the
    end of the stack (`_estack`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copies data**: It copies the initialization values from flash memory to SRAM
    for the data section, which ensures that initialized global/static variables are
    set up correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zeroes BSS**: It clears the BSS section by setting it to zero, which is required
    for uninitialized global/static variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calls SystemInit**: The `SystemInit` function is used to set the default
    system clock (system clock source, PLL multiplier and divider factors, AHB/APBx
    prescalers, and flash settings).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calls __libc_init_array**: The `__libc_init_array` function is used to initialize
    the static constructors in a C++ program or to run initialization functions in
    C programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calls main**: This operation concludes the activities of the startup script
    and transfers program flow to the `main` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our modern development environment now fully set up, we’re ready to dive
    into learning C++ for embedded systems. The Renode simulator allows us to run,
    test, and debug our firmware efficiently, eliminating the need for physical hardware
    in the initial stages of development. This provides a flexible and efficient solution
    for embedded system learning and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we defined the components of our development environment for
    C++ in embedded systems. We went through all of its components using a Docker
    container, which we connected to Visual Studio Code to enable a seamless development
    experience and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: We also set up compiler flags using CMake, ran the firmware using the Renode
    simulator, and learned how to set up our C and C++ runtime environment by going
    through the relevant assembly startup script using a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll use the development environment we created in this
    chapter to learn more about classes in C++.
  prefs: []
  type: TYPE_NORMAL
