- en: File Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理
- en: Data storage is a mandatory feature in all applications. When we enter any data
    while running a program, that data is stored as RAM, which means that it is temporary
    in nature. We will not get that data back when running the program the next time.
    But what if we want the data to stay there so we can refer to it again when we
    need it? In this case, we have to store the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储是所有应用程序的必备功能。当我们运行程序时输入任何数据，该数据将存储为RAM，这意味着它是临时的。当我们下次运行程序时，我们将无法获取该数据。但如果我们希望数据保留在那里，以便在需要时再次引用它，那么在这种情况下，我们必须存储数据。
- en: 'Basically, we want our data to be stored and to be accessible and available
    for reuse whenever required. In C, data storage can be done through traditional
    file handling techniques and through the database system. The following are the
    two types of file handling available in C:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们希望我们的数据能够被存储，并且可以在需要时随时访问和重用。在C语言中，数据存储可以通过传统的文件处理技术以及数据库系统来完成。以下是C语言中可用的两种文件处理类型：
- en: '**Sequential file handling**: Data is written in a simple text format and can
    be read and written sequentially. To read the *n*^(th) line, we have to first
    read *n*-1 lines.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序文件处理**：数据以简单的文本格式写入，可以顺序读取和写入。要读取第 *n* 行，我们必须首先读取 *n*-1 行。'
- en: '**Random file handling**: Data is written as bytes and can be read or written
    randomly. We can read or write any line randomly by positioning the file pointer
    at the desired location.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机文件处理**：数据以字节形式写入，可以随机读取或写入。我们可以通过将文件指针定位在所需位置来随机读取或写入任何行。'
- en: 'In this chapter, we will go through the following recipes using file handling:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用文件处理方法介绍以下食谱：
- en: Reading a text file and converting all characters after a period into uppercase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文本文件并将句号后面的所有字符转换为大写
- en: Displaying the contents of a random file in reverse order
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以逆序显示随机文件的内容
- en: Counting the number of vowels in a file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算文件中元音字母的数量
- en: Replacing a word in a file with another word
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用另一个词替换文件中的词
- en: Encrypting a file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密文件
- en: Before we start with the recipes, let's review some of the functions we will
    be using to create our recipes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写食谱之前，让我们回顾一下我们将使用的一些函数。
- en: Functions used in file handling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理中使用的函数
- en: I've divided this section into two parts. In the first part, we will look at
    the functions specific to the sequential file handling method. In the second,
    we will look at the functions used for random files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我将本节分为两部分。在第一部分，我们将探讨与顺序文件处理方法相关的特定函数。在第二部分，我们将探讨用于随机文件的函数。
- en: Functions commonly used in sequential file handling
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用于顺序文件处理的函数
- en: The following are some of the functions that are used to open, close, read,
    and write in a sequential file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于在顺序文件中打开、关闭、读取和写入的函数。
- en: fopen()
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fopen()
- en: 'The `fopen()` function is used for opening a file for reading, writing, and
    doing other operations. Here is its syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen()`函数用于打开文件进行读取、写入和其他操作。以下是它的语法：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `file_name` represents the file that we want to work on and `mode` states
    the purpose for which we want to open the file. It can be any of the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`file_name`代表我们想要操作的文件，而`mode`说明了我们打开文件的目的。它可以是指以下任何一种：
- en: '`r`**:** This opens the file in read mode and sets the file pointer at the
    first character of the file.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`**:** 这将以读取模式打开文件并将文件指针设置为文件的第一字符。'
- en: '`w`**:** This opens the file in write mode. If the file exists, it will be
    overwritten.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`**:** 以写入模式打开文件。如果文件已存在，它将被覆盖。'
- en: '`a`**:** Opens the file in append mode. Newly entered data will be added at
    the end of the file.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`**:** 以追加模式打开文件。新输入的数据将被添加到文件末尾。'
- en: '`r+`**:** This opens the file in read and write mode. The file pointer is set
    to point at the beginning of the file. The file content will not be deleted if
    it already exists. It will not create a file if it does not already exist.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r+`**:** 这将以读写模式打开文件。文件指针被设置为指向文件的开头。如果文件已存在，则内容不会被删除。如果文件不存在，则不会创建文件。'
- en: '`w+`**:** This also opens the file in read and write mode. The file pointer
    is set to point at the beginning of the file. The file content will be deleted
    if it already exists, but the file will be created if it does not already exist.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w+`**:** 这也将文件以读写模式打开。文件指针被设置为指向文件的开头。如果文件已存在，则内容将被删除，但如果文件不存在，则将被创建。'
- en: '`a+`**:** This opens a file for reading as well as for appending new content.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`**:** 这将以读取和追加新内容的方式打开文件。'
- en: The `fopen` function returns a file descriptor that points to the file for performing
    different operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen`函数返回一个文件描述符，指向文件以执行不同的操作。'
- en: fclose()
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fclose()
- en: 'The `fclose()` function is used for closing the file. Here is its syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`fclose()`函数用于关闭文件。以下是它的语法：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `file_pointer` represents the file pointer that is pointing at the open
    file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`file_pointer`代表指向打开文件的文件指针。
- en: The function returns a `0` value if the file is successfully closed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件成功关闭，函数返回`0`值。
- en: fgets()
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fgets()
- en: 'The `fgets()` function is used for reading a string from the specified file.
    Here is its syntax:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets()`函数用于从指定的文件中读取一个字符串。以下是它的语法：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function has the following features:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数具有以下特性：
- en: '`string`**:** This represents the character array to which the data that is
    read from the file will be assigned.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`**:** 这代表一个字符数组，从文件中读取的数据将被分配到这个数组中。'
- en: '`length`**:** This represents the maximum number of characters that can be
    read from the file. The *length-1* number of characters will be read from the
    file. The reading of data from the file will stop either at *length-1* location
    or at the new line character, `\n`, whichever comes first.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`**:** 这代表可以从文件中读取的最大字符数。将读取*length-1*个字符。从文件中读取数据将在*length-1*位置或在新行字符`\n`处停止，哪个先到就停止。'
- en: '`file_pointer`**:** This represents the file pointer that is pointing at the
    file.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_pointer`**:** 这代表指向文件的文件指针。'
- en: fputs()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fputs()
- en: 'The `fputs()` function is used for writing into the file. Here is its syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`fputs()`函数用于写入文件。以下是它的语法：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `string` represents the character array containing the data to be written
    into the file. The `file_pointer` phrase represents the file pointer that is pointing
    at the file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`string`代表包含要写入文件的数据的字符数组。`file_pointer`短语代表指向文件的文件指针。
- en: Functions commonly used in random files
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用于随机文件的函数
- en: The following functions are used to set the file pointer at a specified location
    in the random file, indicate the location where the file pointer is pointing currently,
    and rewind the file pointer to the beginning of the random file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于在随机文件中设置文件指针到指定位置，指示文件指针当前指向的位置，以及将文件指针重置到随机文件的开始位置。
- en: fseek()
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fseek()
- en: 'The `fseek()` function is used for setting the file pointer at the specific
    position in the file. Here is its syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`fseek()`函数用于在文件中设置文件指针到特定位置。以下是它的语法：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function has the following features:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数具有以下特性：
- en: '`file_pointer`**:** This represents the file pointer that points at the file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_pointer`**:** 这代表指向文件的文件指针。'
- en: '`offset`**:** This represents the number of bytes that the file pointer needs
    to be moved from the position specified by the location parameter. If the value
    of `offset` is positive, the file pointer will move forward in the file, and if
    it is negative, the file pointer will move backward from the given position.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`**:** 这代表文件指针需要从由位置参数指定的位置移动的字节数。如果`offset`的值为正，文件指针将在文件中向前移动，如果为负，文件指针将从给定位置向后移动。'
- en: '`location`**:** This is the value that defines the position from which the
    file pointer needs to be moved. That is, the file pointer will be moved equal
    to the number of bytes specified by the `offset` parameter from the position specified
    by the `location` parameter. Its value can be `0`, `1`, or `2`, as shown in the
    following table:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`**:** 这是定义文件指针需要移动的位置的值。也就是说，文件指针将从`location`参数指定的位置移动等于`offset`参数指定的字节数。其值可以是`0`、`1`或`2`，如下表所示：'
- en: '| **Value** | **Meaning** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **含义** |'
- en: '| `0` | The file pointer will be moved from the beginning of the file |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 文件指针将从文件开头移动'
- en: '| `1` | The file pointer will be moved from the current position |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 文件指针将从当前位置移动'
- en: '| `2` | The file pointer will be moved from the end of the file |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 文件指针将从文件末尾移动'
- en: 'Let''s look at the following example. Here, the file pointer will be moved
    `5` bytes forward from the beginning of the file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。在这里，文件指针将从文件开头向前移动`5`个字节：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following example, the file pointer will be moved `5` bytes backward
    from the end of the file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，文件指针将从文件末尾向后移动`5`个字节：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ftell()
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ftell()
- en: 'The `ftell()` function returns the byte location where `file_pointer` is currently
    pointing at the file. Here is its syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftell()`函数返回`file_pointer`当前在文件中指向的字节位置。以下是它的语法：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `file_pointer` is a file pointer pointing at the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`file_pointer`是一个指向文件的文件指针。
- en: rewind()
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rewind()
- en: 'The `rewind()` function is used for moving the file pointer back to the beginning
    of the specified file. Here is its syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`rewind()`函数用于将文件指针移动到指定文件的开始。以下是它的语法：'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `file_pointer` is a file pointer pointing at the file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`file_pointer`是一个指向文件的文件指针。
- en: In this chapter, we will learn to use both types of file handling using recipes
    that make real-time applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习使用两种类型的文件处理，通过制作实时应用的食谱。
- en: Reading a text file and converting all characters after the period into uppercase
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文本文件并将所有点号后面的字符转换为大写
- en: Say we have a file that contains some text. We think that there is an anomaly
    in the text—every first character after the period is in lowercase when it should
    be in uppercase. In this recipe, we will read that text file and convert each
    character after the period (`.`) that is, in lowercase into uppercase.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含一些文本的文件。我们认为文本中存在一个异常——每个点号后的第一个字符应该是大写，但实际上却是小写。在这个食谱中，我们将读取这个文本文件，并将点号（`.`）后面的每个小写字符转换为大写。
- en: In this recipe, I assume that you know how to create a text file and how to
    read a text file. If you don't know how to perform these actions, you will find
    programs for both of them in *Appendix A*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我假设你知道如何创建文本文件和如何读取文本文件。如果你不知道如何执行这些操作，你将在*附录A*中找到这两个程序。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open the sequential file in read-only mode using the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码以只读模式打开顺序文件：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate. Set this up using the following
    code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在或权限不足，将显示错误消息，程序将终止。使用以下代码设置：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One line is read from the file, as shown in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取一行，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each character of the line is accessed and checked for the presence of periods,
    as shown in the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个字符的行都会被访问并检查是否存在点号，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If a period is found, the character following the period is checked to confirm
    whether it is in uppercase, as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到点号，则检查点号后面的字符以确认它是否为大写，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the character following the period is in lowercase, a value of `32` is subtracted
    from the ASCII value of the lowercase character to convert it into uppercase,
    as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果点号后面的字符是小写，则从小写字符的ASCII值中减去`32`以将其转换为大写，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the line is not yet over, then the sequence from step 4 onward is repeated
    till step 6; otherwise, the updated line is displayed on the screen, as shown
    in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果行还没有结束，则从步骤4开始的序列将重复到步骤6；否则，更新的行将在屏幕上显示，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check whether the end of file has been reached using the following code. If
    the file is not over, repeat the sequence from step 3:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查是否到达了文件末尾。如果文件没有结束，则重复从步骤3开始的序列：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding steps are pictorially explained in the following diagram (*Figure
    6.1*):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤在以下图中以图示方式解释（*图6.1*）：
- en: '![](img/a31410ee-7823-423e-8319-f11eaa3c4111.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a31410ee-7823-423e-8319-f11eaa3c4111.png)'
- en: Figure 6.1
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1
- en: 'The `convertcase.c` program for converting a lowercase character found after
    a period in a file into uppercase is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件中点号后面的小写字母转换为大写的`convertcase.c`程序如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's go behind the scenes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The file whose name is supplied as a command-line argument is opened in read-only
    mode and is pointed to by the file pointer, `fp`. This recipe is focused on reading
    a file and changing its case, so if the file does not exist or does not have read
    permission, an error will be displayed and the program will terminate.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以命令行参数提供的文件名打开的文件以只读模式打开，并由文件指针`fp`指向。这个食谱专注于读取文件并更改其大小写，因此如果文件不存在或没有读取权限，将显示错误信息，程序将终止。
- en: A `while` loop will be set to execute until `feof` (the end of file) is reached.
    Within the `while` loop, each line of the file will be read one by one and assigned
    to the string named `buffer`. The `fgets()` function will be used to read one
    line at a time from the file. A number of characters will be read from the file
    until the newline character, `\n`, is reached, to a maximum of 254.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将设置一个`while`循环，直到`feof`（文件末尾）到达时执行。在`while`循环内，将逐行读取文件并将每一行分配给名为`buffer`的字符串。将使用`fgets()`函数一次读取文件中的一行。从文件中读取一定数量的字符，直到遇到换行符`\n`，最多读取254个字符。
- en: 'The following steps will be performed on each of the lines assigned to the
    string buffer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将对分配给字符串缓冲区的每一行执行：
- en: The length of the buffer string will be computed and a `for` loop will be executed
    to access each of the characters in the string buffer.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计算缓冲区字符串的长度，并执行一个`for`循环以访问字符串缓冲区中的每个字符。
- en: The string buffer will be checked to see whether there are any periods in it.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将检查字符串缓冲区中是否有任何句点。
- en: If one is found, the character following it will be checked to see whether it
    is into lowercase. ASCII values will be used to then convert the lowercase characters
    into uppercase (refer to [Chapter 2](6cbb6fdb-cd55-4e74-bd5a-2a2f91575490.xhtml),
    *Managing Strings*, for more information on the ASCII values that correspond to
    the letters of the alphabet). If the character following the period is in lowercase,
    a value of `32` will be deducted from the ASCII value of the lowercase character
    to convert it into uppercase. Remember, the ASCII value of uppercase characters
    is lower by a value of `32` than their corresponding lowercase characters.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了，将检查其后的字符是否为小写。然后使用ASCII值将小写字符转换为大写（有关对应字母的ASCII值的更多信息，请参阅[第2章](6cbb6fdb-cd55-4e74-bd5a-2a2f91575490.xhtml)，*字符串管理*）。如果句点后的字符是小写，则从小写字符的ASCII值中减去`32`以将其转换为大写。记住，大写字母的ASCII值比对应的小写字母低`32`。
- en: The updated string `buffer` with the character following the period converted
    into uppercase will be displayed on the screen.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在屏幕上显示更新后的字符串`buffer`，其中句点后的字符已被转换为大写。
- en: When all the lines of the file are read and displayed, the file pointed to by
    the `fp` pointer will be closed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取并显示文件的所有行后，指向`fp`指针的文件将被关闭。
- en: 'Let''s use GCC to compile the `convertcase.c` program as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`convertcase.c`程序，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you get no errors or warnings, this means that the `convertcase.c` program
    has been compiled into an executable file, `convertcase.exe`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`convertcase.c`程序已被编译成可执行文件`convertcase.exe`。
- en: 'Let''s say that I have created a file called `textfile.txt` with the following
    content:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我已经创建了一个名为`textfile.txt`的文件，其内容如下：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command is executed in Windows' Command Prompt.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令是在Windows的命令提示符中执行的。
- en: 'Let''s run the executable file, `convertcase.exe`, and then pass the `textfile.txt`
    file to it, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行可执行文件`convertcase.exe`，然后将`textfile.txt`文件传递给它，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see in the preceding output that the characters that were in lowercase
    after the period are now converted into uppercase.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的输出中看到，句点后的字符现在已被转换为大写。
- en: Let's move on to the next recipe!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱！
- en: Displaying the contents of a random file in reverse order
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以相反的顺序显示随机文件的文件内容
- en: Let's say that we have a random file that contains some lines of text. Let's
    find out how to reverse the contents of this file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含一些文本行的随机文件。让我们来看看如何反转这个文件的文件内容。
- en: This program will not give the correct output if a random file does not exist.
    Please read *Appendix A* to learn how to create a random file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果随机文件不存在，此程序将不会给出正确的输出。请阅读*附录A*了解如何创建随机文件。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open the random file in read-only mode using the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码以只读模式打开随机文件：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在或没有足够的权限，将会显示错误消息，并且程序将终止，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To read the random file in reverse order, execute a loop equal to the number
    of lines in the file. Every iteration of the loop will read one line beginning
    from the bottom of the file. The following formula will be used to find out the
    number of lines in the file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按相反顺序读取随机文件，执行一个等于文件行数的循环。循环的每次迭代都将从文件底部开始读取一行。以下公式将用于找出文件中的行数：
- en: '*total number of bytes used in the file/size of one line in bytes*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件中使用的总字节数/每行的字节数*'
- en: 'The code for doing this is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的代码如下：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because the file has to be read in reverse order, the file pointer will be
    positioned at the bottom of the file, as shown in the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为文件必须按相反顺序读取，所以文件指针将被定位在文件底部，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set a loop to execute that equals the number of lines in the file computed
    in step 3, as shown in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个循环，使其执行的次数等于步骤3中计算的文件行数，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the loop, the file pointer will be positioned as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，文件指针将被定位如下：
- en: '![](img/67c562c8-1e75-45e9-a08f-dbd7ef8e98bb.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67c562c8-1e75-45e9-a08f-dbd7ef8e98bb.png)'
- en: Figure 6.2
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2
- en: 'To read the last line, the file pointer will be positioned at the byte location
    where the last line begins, at the **-1 x sizeof(line)** byte location. The last
    line will be read and displayed on the screen, as shown in the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取最后一行，文件指针将被定位在最后一行开始的字节位置，即**-1 x sizeof(line)**字节位置。最后一行将被读取并显示在屏幕上，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, the file pointer will be positioned at the byte location from where the
    second last line begins, at the **-2 x sizeof(line)** byte location. Again, the
    second last line will be read and displayed on the screen.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，文件指针将被定位在倒数第二行开始的字节位置，即**-2 x sizeof(line)**字节位置。再次，倒数第二行将被读取并显示在屏幕上。
- en: The procedure will be repeated until all of the lines in the file have been
    read and displayed on the screen.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程将重复进行，直到文件中的所有行都被读取并显示在屏幕上。
- en: 'The `readrandominreverse.c` program for reading the random file in reverse
    order is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 读取随机文件的反向读取程序`readrandominreverse.c`如下：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's go behind the scenes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We will open the chosen file in read-only mode. If the file opens successfully,
    it will be pointed at by the file pointer `fp`. Next, we will find out the total
    number of lines in the file using the following formula:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以只读模式打开选定的文件。如果文件成功打开，它将由文件指针`fp`指向。接下来，我们将使用以下公式找出文件中的总行数：
- en: '*total number of bytes used by the file/number of bytes used by one line*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件使用的总字节数/每行使用的字节数*'
- en: To know the total number of bytes used by the file, the file pointer will be
    positioned at the bottom of the file and we will invoke the `ftell` function.
    The `ftell` function finds the current location of the file pointer. Because the
    file pointer is at the end of the file, using this function will tell us the total
    number of bytes used by the file. To find the number of bytes used by one line,
    we will use the `sizeof` function. We will apply the preceding formula to compute
    the total number of lines in the file; this will be assigned to the variable,
    `nol`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道文件使用的总字节数，文件指针将被定位在文件底部，我们将调用`ftell`函数。`ftell`函数找到文件指针的当前位置。因为文件指针在文件末尾，使用此函数将告诉我们文件使用的总字节数。要找出一行使用的字节数，我们将使用`sizeof`函数。我们将应用前面的公式来计算文件中的总行数；这将分配给变量`nol`。
- en: We will set a `for` loop to execute for `nol` number of times. Within the `for`
    loop, the file pointer will be positioned at the end of the last line so that
    all of the lines from the file can be accessed in reverse order. So, the file
    pointer is first set at the `(-1 * size of one line)` location at the bottom of
    the file. Once the file pointer is positioned at this location, we will use the
    `fread` function to read the last line of the file and assign it to the structure
    variable line. The string in line will then be displayed on the screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个`for`循环，使其执行`nol`次。在`for`循环内部，文件指针将被定位在最后一行的末尾，以便可以按相反顺序访问文件中的所有行。因此，文件指针首先被设置在文件底部的`(-1
    * 一行的大小)`位置。一旦文件指针定位在这个位置，我们将使用`fread`函数读取文件的最后一行并将其分配给结构变量`line`。然后，`line`中的字符串将在屏幕上显示。
- en: After displaying the last line on the screen, the file pointer will be set at
    the byte position of the second last line at `(-2 * size of one line)`. We will
    again use the `fread` function to read the second last line and display it on
    the screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示最后一行后，文件指针将设置在倒数第二行的字节位置 `(-2 * 一行的大小)`。我们将再次使用 `fread` 函数读取倒数第二行并在屏幕上显示它。
- en: This procedure will be executed for the number of times that the `for` loop
    executes, and the `for` loop will execute the same number of times as there are
    lines in the file. Then the file will be closed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将执行 `for` 循环执行的次数，`for` 循环将执行与文件中行数相同的次数。然后关闭文件。
- en: 'Let''s use GCC to compile the `readrandominreverse.c` program, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `readrandominreverse.c` 程序，如下所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you get no errors or warnings, this means that the `readrandominreverse.c`
    program has been compiled into an executable file, `readrandominreverse.exe`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着 `readrandominreverse.c` 程序已经被编译成一个可执行文件，`readrandominreverse.exe`。
- en: 'Let''s assume that we have a random file, `random.data`, with the following
    text:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个随机文件，`random.data`，包含以下文本：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s run the executable file, `readrandominreverse.exe`, to display the random
    file, `random.data`, in reverse order using the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行可执行文件 `readrandominreverse.exe`，使用以下代码以逆序显示随机文件 `random.data`：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By comparing the original file with the preceding output, you can see that the
    file content is displayed in reverse order.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较原始文件与前面的输出，你可以看到文件内容是逆序显示的。
- en: Now, let's move on to the next recipe!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Counting the number of vowels in a file
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算文件中元音的数量
- en: In this recipe, we will open a sequential text file and count the number of
    vowels (both uppercase and lowercase) that it contains.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将打开一个顺序文本文件并计算它包含的元音数量（大写和小写）。
- en: In this recipe, I will assume that a sequential file already exists. Please
    read *Appendix A* to learn how to create a sequential file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我将假设一个顺序文件已经存在。请阅读 *附录 A* 了解如何创建顺序文件。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open the sequential file in read-only mode using the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码以只读模式打开顺序文件：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在或没有足够的权限，将显示错误消息，程序将终止，如下所示：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initialize the counter that will count the number of vowels in the file to
    `0`, as shown in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将将用于计算文件中元音数量的计数器初始化为 `0`，如下所示：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One line is read from the file, as shown in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取一行，如下所示：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Each character of the line is accessed and checked for any lowercase or uppercase
    vowels, as shown in the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问并检查每一行的每个字符，看是否有任何小写或大写元音，如下所示：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If any vowel is found, the value of the counter is incremented by `1`, as shown
    in the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到任何元音，计数器的值将增加 `1`，如下所示：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Step 5 will be repeated until the end of the line has been reached. Check whether
    the end of the file has been reached. Repeat from step 4 until the end of the
    file, as shown in the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤 5 将重复执行，直到达到行尾。检查是否已到达文件末尾。从步骤 4 重复，直到文件末尾，如下所示：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Display the count of the number of vowels in the file by printing the value
    in the counter variable on the screen, as shown in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在屏幕上打印计数变量中的值来显示文件中元音数量的计数，如下所示：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding steps are shown in the following diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤如下所示：
- en: '![](img/507cecd3-b283-46cc-a3ec-9e8f1c177a35.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/507cecd3-b283-46cc-a3ec-9e8f1c177a35.png)'
- en: Figure 6.3
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3
- en: 'The `countvowels.c` program to count the number of vowels in a sequential text
    file is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算顺序文本文件中元音数量的 `countvowels.c` 程序如下：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's go behind the scenes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后看看。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will open the chosen sequential file in read-only mode. If the file opens
    successfully, it will be pointed at by the file pointer, `fp`. To count the number
    of vowels in the file, we will initialize a counter from `0`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以只读模式打开所选顺序文件。如果文件成功打开，它将由文件指针 `fp` 指向。为了计算文件中的元音数量，我们将从 `0` 初始化一个计数器。
- en: We will set a `while` loop to execute until the file pointer, `fp`, reaches
    the end of the file. Within the `while` loop, each line in the file will be read
    using the `fgets` function. The `fgets` function will read the `BUFFSIZE` number
    of characters from the file. The value of the `BUFFSIZE` variable is `255`, so
    `fgets` will read either `254` characters from the file or will read characters
    until the newline character, `\n`, is reached, whichever comes first.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个`while`循环，直到文件指针`fp`到达文件末尾才执行。在`while`循环内，将使用`fgets`函数读取文件中的每一行。`fgets`函数将从文件中读取`BUFFSIZE`个字符。`BUFFSIZE`变量的值是`255`，所以`fgets`将读取文件中的`254`个字符或读取字符直到遇到换行符`\n`，以先到者为准。
- en: The line read from the file is assigned to the `buffer` string. To display the
    file contents along with the count of the vowels, the content in the `buffer`
    string is displayed on the screen. The length of the `buffer` string will be computed
    and a `for` loop will be set to execute equaling the length of the string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取的行被分配给`buffer`字符串。为了显示文件内容以及元音的数量，`buffer`字符串中的内容将在屏幕上显示。将计算`buffer`字符串的长度，并设置一个`for`循环，使其执行等于字符串长度的次数。
- en: Each of the characters in the buffer string will be checked in the `for` loop.
    If any lowercase or uppercase vowels appear in the line, the value of the counter
    variable will be incremented by `1`. When the `while` loop ends, the counter variable
    will have the total count of the vowels present in the file. Finally, the value
    in the counter variable will be displayed on the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区字符串中的每个字符都将通过`for`循环进行检查。如果行中出现任何小写或大写元音，则计数器变量的值将增加`1`。当`while`循环结束时，计数器变量将包含文件中存在的元音总数。最后，计数器变量中的值将在屏幕上显示。
- en: 'Let''s use GCC to compile the `countvowels.c` program as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC按照以下方式编译`countvowels.c`程序：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you get no errors or warnings, then this means that the `countvowels.c` program
    has been compiled into an executable file called `countvowels.exe`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，则表示`countvowels.c`程序已编译成名为`countvowels.exe`的可执行文件。
- en: 'Let''s assume that we have a text file called `textfile.txt` with some content.
    We will run the executable file, `countvowels.exe`, and supply the `textfile.txt`
    file to it to count the number of vowels in it, as shown in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`textfile.txt`的文本文件，其中包含一些内容。我们将运行可执行文件`countvowels.exe`，并将`textfile.txt`文件作为参数传递给它，以计算其中的元音数量，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can see from the output of the program that the program not only displays
    the count of the vowels, but also the complete content of the file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序输出中可以看出，程序不仅显示了元音的数量，还显示了文件的完整内容。
- en: Now, let's move on to the next recipe!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Replacing a word in a file with another word
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中将一个单词替换为另一个单词
- en: Let's say that you want to replace all occurrences of the word `is` with the
    word `was` in one of your files. Let's find out how to do this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将文件中所有`is`单词替换为`was`。让我们看看如何做到这一点。
- en: In this recipe, I will assume that a sequential file already exists. Please
    read *Appendix A* to learn how to create a sequential file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我将假设已经存在一个顺序文件。请阅读*附录A*了解如何创建顺序文件。
- en: How to do it…
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open the file in read-only mode using the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码以只读模式打开文件：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在或没有足够的权限，将显示错误消息，程序将终止，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Enter the word to be replaced using the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码输入要替换的单词：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Enter the new word that will replace the old word using the following code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码输入将替换旧单词的新单词：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Read a line from the file using the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码从文件中读取一行：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Check whether the word to be replaced appears anywhere in the line using the
    following code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查要替换的单词是否出现在行的任何位置：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the word appears in the line, then simply replace it with the new word using
    the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单词出现在行中，则只需使用以下代码将其替换为新单词：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the word does not appear anywhere in the line, then move on to the next
    step. Print the line with the replaced word using the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单词在任何位置都没有出现，则继续到下一步。使用以下代码打印替换单词的行：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Check whether the end of the file has been reached using the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查是否到达了文件末尾：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the end of the file has not yet been reached, go to step 4\. Close the file
    using the following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未到达文件末尾，则转到步骤4。使用以下代码关闭文件：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `replaceword.c` program replaces the specified word in a file with another
    word and displays the modified content on the screen:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceword.c`程序用另一个单词替换文件中的指定单词，并在屏幕上显示修改后的内容：'
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's go behind the scenes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Open the chosen file in read-only mode. If the file opens successfully, then
    the file pointer, `fp`, will be set to point at it. Enter the word to be replaced
    and assign it to the string variable, `str1`. Similarly, enter the new string
    that will be assigned to another string variable, `str2`. The length of the two
    strings, `str1` and `str2`, will be computed and assigned to the variables, `ls1`
    and `ls2`, respectively.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以只读模式打开选定的文件。如果文件成功打开，则文件指针`fp`将被设置为指向它。输入要替换的单词并将其分配给字符串变量`str1`。同样，输入将被分配给另一个字符串变量`str2`的新字符串。两个字符串`str1`和`str2`的长度将被计算并分别分配给变量`ls1`和`ls2`。
- en: Set a `while` loop to execute until the file pointed at by `fp` pointer gets
    over. Within the `while` loop, one line from the file will be read using the `fgets`
    function. The `fgets` function reads the file until the maximum length that is
    specified or the new line character, `\n`, is reached, whichever comes first.
    Because strings are terminated with a mandatory null character, `\0`, a maximum
    of `254` characters will be read from the file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个`while`循环，直到`fp`指针指向的文件结束为止执行。在`while`循环内，将使用`fgets`函数从文件中读取一行。`fgets`函数读取文件，直到指定的最大长度或遇到换行符`\n`，以先到者为准。由于字符串以强制性的空字符`\0`结尾，因此从文件中最多读取`254`个字符。
- en: The string that is read from the file will be assigned to the `line` variable.
    The length of the `line` string will be computed and assigned to the `ll` variable.
    Using a `for` loop, each of the characters in the line variable will be accessed
    to check whether they match with `str1[0]`—that is, with the first character of
    the string to be replaced. The characters in the `line` variable that don't match
    with the string to be replaced will be assigned to another string, called `nline`.
    The `nline` string will contain the desired content—that is, all of the characters
    of the `line` variable and the new string. If it exists in `line`, then the string
    will be replaced with the new string and the entire modified content will be assigned
    to the new string, `nline`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取的字符串将被分配给`line`变量。`line`字符串的长度将被计算并分配给`ll`变量。使用`for`循环，访问`line`变量中的每个字符，以检查它们是否与要替换的字符串的第一个字符`str1[0]`匹配。与要替换的字符串不匹配的`line`变量中的字符将被分配给另一个字符串，称为`nline`。`nline`字符串将包含所需的内容，即`line`变量的所有字符和新字符串。如果它在`line`中存在，则该字符串将被替换为新字符串，整个修改后的内容将被分配给新字符串`nline`。
- en: If the first character of the string to be replaced matches with any of the
    characters in `line`, then the `while` loop will be used to match all of the successive
    characters of the string that is to be replaced with the successive characters
    in `line`. If all of the characters of the string that is to be replaced match
    with successive characters in `line`, then all of the characters of the string
    to be replaced are replaced with the new string and assigned to the new string,
    `nline`. That way, the `while` loop will read one line of text at a time from
    the file, searching for occurrences of the string to be replaced. If it is found,
    it replaces it with the new string and assigns the modified line of text to another
    string, `nline`. The null character, `\0`, is added to the modified string, `nline`,
    and is displayed on the screen. Finally, the file pointed to by the file pointer,
    `fp`, is closed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要替换的字符串的第一个字符与`line`中的任何字符匹配，则将使用`while`循环来匹配要替换的字符串的后续字符与`line`中的后续字符。如果要替换的字符串的所有字符都与`line`中的后续字符匹配，则将所有要替换的字符串的字符替换为新字符串，并分配给新字符串`nline`。这样，`while`循环将一次读取文件中的一行文本，搜索要替换的字符串的出现。如果找到，则将其替换为新字符串，并将修改后的文本行分配给另一个字符串`nline`。在修改后的字符串`nline`中添加空字符`\0`，并在屏幕上显示。最后，关闭由文件指针`fp`指向的文件。
- en: In this recipe, I am replacing the desired word and another string and displaying
    the updated content on the screen. If you want the updated content to be written
    into another file, then you can always open another file in write mode and execute
    the `fputs` function to write the updated content in it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我正在替换所需的单词和另一个字符串，并在屏幕上显示更新后的内容。如果你想将更新后的内容写入另一个文件，你总是可以以写入模式打开另一个文件，并执行`fputs`函数来将更新后的内容写入其中。
- en: 'Let''s use GCC to compile the `replaceword.c` program, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`replaceword.c`程序，如下所示：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you get no errors or warnings, then this means that the `replaceword.c`
    program has been compiled into an executable file, `replaceword.exe`. Let''s run
    the executable file, `replaceword.exe`, and supply a text file to it. We will
    assume that a text file called `textfile.txt` exists and has the following content:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，那么这意味着`replaceword.c`程序已经被编译成了一个可执行文件，名为`replaceword.exe`。让我们运行这个可执行文件`replaceword.exe`，并向它提供一个文本文件。我们将假设存在一个名为`textfile.txt`的文本文件，并包含以下内容：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s use this file to replace one of its words with another word using
    the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码用另一个单词替换文件中的一个单词：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see that all occurrences of the word `is` are replaced by `was` in `textfile.txt`,
    and the modified content is displayed on the screen. We've successfully replaced
    the words of our choice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在`textfile.txt`中所有`is`单词的出现都被替换成了`was`，并且修改后的内容显示在屏幕上。我们已经成功替换了我们选择的单词。
- en: Now, let's move on to the next recipe!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到下一个菜谱！
- en: Encrypting a file
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件加密
- en: Encryption means converting content into a coded format so that unauthorized
    persons will be unable to see or access the original content of the file. A text
    file can be encrypted by applying a formula to the ASCII value of the content.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 加密意味着将内容转换为编码格式，这样未经授权的人员将无法看到或访问文件的原始内容。可以通过应用公式到内容的ASCII值来加密文本文件。
- en: The formula or code can be of your choosing, and it can be as simple or complex
    as you want. For example, let's say that you have chosen to replace the current
    ASCII value of all letters by moving them forward 15 values. In this case, if
    the letter is a lowercase *a* that has the ASCII value of 97, then the forward
    shift of the ASCII values by 15 will make the *encrypted* letter a lowercase *p*,
    which has the ASCII value of 112 (97 + 15 = 112).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 公式或代码可以由你选择，它可以像你想要的那样简单或复杂。例如，假设你选择将所有字母的当前ASCII值向前移动15个值。在这种情况下，如果字母是ASCII值为97的小写字母*a*，那么ASCII值向前移动15个值将使加密后的字母变为小写字母*p*，其ASCII值为112（97
    + 15 = 112）。
- en: In this recipe, I assume that a sequential file that you want to encrypt already
    exists. Please read *Appendix A* to learn how to create a sequential file. You
    can also refer to *Appendix A* if you want to know how an encrypted file is decrypted.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我假设你想要加密的顺序文件已经存在。请阅读*附录A*了解如何创建顺序文件。如果你想知道加密文件是如何解密的，也可以参考*附录A*。
- en: How to do it…
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open the source file in read-only mode using the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码以只读模式打开源文件：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在或没有足够的权限，将会显示错误消息，并且程序将终止，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Open the destination file, the file where the encrypted text will be written,
    in write-only mode using the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码以只写模式打开目标文件，即将要写入加密文本的文件：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Read a line from the file and access each of its characters using the following
    code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码从文件中读取一行，并使用以下代码访问其每个字符：
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using the following code, subtract a value of `45` from the ASCII value of
    each of the characters in the line to encrypt that character:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，从每一行的每个字符的ASCII值中减去`45`来加密该字符：
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Repeat step 5 until the line is over. Once all of the characters in the line
    are encrypted, write the encrypted line into the destination file using the following
    code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤5，直到行结束。一旦行中的所有字符都被加密，使用以下代码将加密行写入目标文件：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Check whether the end of the file has been reached using the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查是否到达了文件末尾：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Close the two files using the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码关闭两个文件：
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding steps are shown in the following diagram:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤在以下图中展示：
- en: '![](img/5d3d9f9e-269f-4a4d-ae0c-f97b79da7af2.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d3d9f9e-269f-4a4d-ae0c-f97b79da7af2.png)'
- en: Figure 6.4
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4
- en: 'The `encryptfile.c` program to encrypt a file is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文件的`encryptfile.c`程序如下：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, let's go behind the scenes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first file name that is passed through the command-line arguments is opened
    in read-only mode. The second file name that is passed through the command-line
    arguments is opened in write-only mode. If both files are opened correctly, then
    the `fp` and `fq` pointers , respectively, will point at the read-only and write-only
    files.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行参数传递的第一个文件名将以只读模式打开。通过命令行参数传递的第二个文件名将以只写模式打开。如果两个文件都正确打开，那么`fp`和`fq`指针分别将指向只读和只写文件。
- en: We will set a `while` loop to execute until it reaches the end of the source
    file. Within the loop, one line from the source file will be read using the `fgets`
    function. The `fgets` function reads the specified number of bytes from the file
    or until the new line character, `\n`, is reached. If the new line character does
    not appear in the file, then the `BUFFSIZE` constant limits the bytes to be read
    from the file to `254`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个`while`循环，直到它达到源文件的末尾才执行。在循环内部，将使用`fgets`函数从源文件中读取一行。`fgets`函数从文件中读取指定数量的字节，或者直到遇到新行字符`\n`。如果文件中没有出现新行字符，那么`BUFFSIZE`常量将限制从文件中读取的字节数为`254`。
- en: The line read from the file is assigned to the `buffer` string . The length
    of the string `buffer` is computed and assigned to the variable, `n`. We will
    then set a `for` loop to execute until it reaches the end of the length of the
    `buffer` string, and within the loop, the ASCII value of each character will be
    changed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取的行被分配给`buffer`字符串。计算字符串`buffer`的长度并将其分配给变量`n`。然后我们将设置一个`for`循环，直到它达到`buffer`字符串的长度末尾才执行，在循环内部，将改变每个字符的ASCII值。
- en: To encrypt the file, we will subtract a value of `45` from the ASCII value of
    each of the characters, although we can apply any formula we like. Just ensure
    that you remember the formula, as we will need to reverse it in order to decrypt
    the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加密文件，我们将从每个字符的ASCII值中减去`45`，尽管我们可以应用任何我们喜欢的公式。只需确保你记住这个公式，因为我们将在解密文件时需要反转它。
- en: After applying the formula to all of the characters, the encrypted line will
    be written into the target file. In addition, to display the encrypted version
    on the screen, the encrypted line will be displayed on the screen.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在将公式应用于所有字符后，加密行将被写入目标文件。此外，为了在屏幕上显示加密版本，加密行也将显示在屏幕上。
- en: When the `while` loop is finished, all of the lines from the source file will
    be written into the target file after they are encrypted. Finally, the two files
    will be closed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环完成后，所有从源文件读取的行在加密后将被写入目标文件。最后，将关闭这两个文件。
- en: 'Let''s use GCC to compile the `encryptfile.c` program, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`encryptfile.c`程序，如下所示：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you get no errors or warnings, this means that the `encryptfile.c` program
    has been compiled into an executable file, `encryptfile.exe`. Let's run this executable
    file.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到错误或警告，这意味着`encryptfile.c`程序已经被编译成可执行文件，`encryptfile.exe`。让我们运行这个可执行文件。
- en: 'Before running the executable file, though, let''s take a look at the text
    file, `textfile.txt`, which will be encrypted using this program. The contents
    of this text file are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行可执行文件之前，让我们先看看将被此程序加密的文本文件`textfile.txt`的内容。该文本文件的内容如下：
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s run the executable file, `encryptfile.exe`, on `textfile.txt` and put
    the encrypted content into another file named `encrypted.txt` using the following
    code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`textfile.txt`上运行可执行文件`encryptfile.exe`，并使用以下代码将加密内容放入另一个名为`encrypted.txt`的文件中：
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The normal content in `textfile.txt` is encrypted and the encrypted content
    is written into another file named `encrypted.txt`. The encrypted content will
    appear as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`textfile.txt`中的普通内容被加密，加密内容被写入另一个名为`encrypted.txt`的文件。加密内容将如下所示：'
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding command is executed in Windows' Command Prompt.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在Windows的命令提示符中执行。
- en: Voila! We've successfully encrypted the file!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功加密了文件！
- en: See also
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn how to create and read content in sequential file, random file and
    decrypting a file visit *Appendix C* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在顺序文件、随机文件中创建和读取内容以及解密文件，请访问此链接上的*附录C*：[https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf).
