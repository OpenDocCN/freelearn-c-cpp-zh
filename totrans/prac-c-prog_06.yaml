- en: File Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data storage is a mandatory feature in all applications. When we enter any data
    while running a program, that data is stored as RAM, which means that it is temporary
    in nature. We will not get that data back when running the program the next time.
    But what if we want the data to stay there so we can refer to it again when we
    need it? In this case, we have to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we want our data to be stored and to be accessible and available
    for reuse whenever required. In C, data storage can be done through traditional
    file handling techniques and through the database system. The following are the
    two types of file handling available in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequential file handling**: Data is written in a simple text format and can
    be read and written sequentially. To read the *n*^(th) line, we have to first
    read *n*-1 lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random file handling**: Data is written as bytes and can be read or written
    randomly. We can read or write any line randomly by positioning the file pointer
    at the desired location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following recipes using file handling:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file and converting all characters after a period into uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the contents of a random file in reverse order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the number of vowels in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a word in a file with another word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start with the recipes, let's review some of the functions we will
    be using to create our recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Functions used in file handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've divided this section into two parts. In the first part, we will look at
    the functions specific to the sequential file handling method. In the second,
    we will look at the functions used for random files.
  prefs: []
  type: TYPE_NORMAL
- en: Functions commonly used in sequential file handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some of the functions that are used to open, close, read,
    and write in a sequential file.
  prefs: []
  type: TYPE_NORMAL
- en: fopen()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fopen()` function is used for opening a file for reading, writing, and
    doing other operations. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `file_name` represents the file that we want to work on and `mode` states
    the purpose for which we want to open the file. It can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`**:** This opens the file in read mode and sets the file pointer at the
    first character of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`**:** This opens the file in write mode. If the file exists, it will be
    overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`**:** Opens the file in append mode. Newly entered data will be added at
    the end of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r+`**:** This opens the file in read and write mode. The file pointer is set
    to point at the beginning of the file. The file content will not be deleted if
    it already exists. It will not create a file if it does not already exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w+`**:** This also opens the file in read and write mode. The file pointer
    is set to point at the beginning of the file. The file content will be deleted
    if it already exists, but the file will be created if it does not already exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`**:** This opens a file for reading as well as for appending new content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fopen` function returns a file descriptor that points to the file for performing
    different operations.
  prefs: []
  type: TYPE_NORMAL
- en: fclose()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fclose()` function is used for closing the file. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `file_pointer` represents the file pointer that is pointing at the open
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The function returns a `0` value if the file is successfully closed.
  prefs: []
  type: TYPE_NORMAL
- en: fgets()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fgets()` function is used for reading a string from the specified file.
    Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string`**:** This represents the character array to which the data that is
    read from the file will be assigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`**:** This represents the maximum number of characters that can be
    read from the file. The *length-1* number of characters will be read from the
    file. The reading of data from the file will stop either at *length-1* location
    or at the new line character, `\n`, whichever comes first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file_pointer`**:** This represents the file pointer that is pointing at the
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fputs()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fputs()` function is used for writing into the file. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `string` represents the character array containing the data to be written
    into the file. The `file_pointer` phrase represents the file pointer that is pointing
    at the file.
  prefs: []
  type: TYPE_NORMAL
- en: Functions commonly used in random files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following functions are used to set the file pointer at a specified location
    in the random file, indicate the location where the file pointer is pointing currently,
    and rewind the file pointer to the beginning of the random file.
  prefs: []
  type: TYPE_NORMAL
- en: fseek()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fseek()` function is used for setting the file pointer at the specific
    position in the file. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_pointer`**:** This represents the file pointer that points at the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`**:** This represents the number of bytes that the file pointer needs
    to be moved from the position specified by the location parameter. If the value
    of `offset` is positive, the file pointer will move forward in the file, and if
    it is negative, the file pointer will move backward from the given position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`**:** This is the value that defines the position from which the
    file pointer needs to be moved. That is, the file pointer will be moved equal
    to the number of bytes specified by the `offset` parameter from the position specified
    by the `location` parameter. Its value can be `0`, `1`, or `2`, as shown in the
    following table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Value** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | The file pointer will be moved from the beginning of the file |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | The file pointer will be moved from the current position |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | The file pointer will be moved from the end of the file |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the following example. Here, the file pointer will be moved
    `5` bytes forward from the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the file pointer will be moved `5` bytes backward
    from the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ftell()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ftell()` function returns the byte location where `file_pointer` is currently
    pointing at the file. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `file_pointer` is a file pointer pointing at the file.
  prefs: []
  type: TYPE_NORMAL
- en: rewind()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `rewind()` function is used for moving the file pointer back to the beginning
    of the specified file. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `file_pointer` is a file pointer pointing at the file.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to use both types of file handling using recipes
    that make real-time applications.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file and converting all characters after the period into uppercase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we have a file that contains some text. We think that there is an anomaly
    in the text—every first character after the period is in lowercase when it should
    be in uppercase. In this recipe, we will read that text file and convert each
    character after the period (`.`) that is, in lowercase into uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I assume that you know how to create a text file and how to
    read a text file. If you don't know how to perform these actions, you will find
    programs for both of them in *Appendix A*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the sequential file in read-only mode using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate. Set this up using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One line is read from the file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each character of the line is accessed and checked for the presence of periods,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If a period is found, the character following the period is checked to confirm
    whether it is in uppercase, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the character following the period is in lowercase, a value of `32` is subtracted
    from the ASCII value of the lowercase character to convert it into uppercase,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the line is not yet over, then the sequence from step 4 onward is repeated
    till step 6; otherwise, the updated line is displayed on the screen, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the end of file has been reached using the following code. If
    the file is not over, repeat the sequence from step 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding steps are pictorially explained in the following diagram (*Figure
    6.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a31410ee-7823-423e-8319-f11eaa3c4111.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The `convertcase.c` program for converting a lowercase character found after
    a period in a file into uppercase is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The file whose name is supplied as a command-line argument is opened in read-only
    mode and is pointed to by the file pointer, `fp`. This recipe is focused on reading
    a file and changing its case, so if the file does not exist or does not have read
    permission, an error will be displayed and the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop will be set to execute until `feof` (the end of file) is reached.
    Within the `while` loop, each line of the file will be read one by one and assigned
    to the string named `buffer`. The `fgets()` function will be used to read one
    line at a time from the file. A number of characters will be read from the file
    until the newline character, `\n`, is reached, to a maximum of 254.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will be performed on each of the lines assigned to the
    string buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the buffer string will be computed and a `for` loop will be executed
    to access each of the characters in the string buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The string buffer will be checked to see whether there are any periods in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If one is found, the character following it will be checked to see whether it
    is into lowercase. ASCII values will be used to then convert the lowercase characters
    into uppercase (refer to [Chapter 2](6cbb6fdb-cd55-4e74-bd5a-2a2f91575490.xhtml),
    *Managing Strings*, for more information on the ASCII values that correspond to
    the letters of the alphabet). If the character following the period is in lowercase,
    a value of `32` will be deducted from the ASCII value of the lowercase character
    to convert it into uppercase. Remember, the ASCII value of uppercase characters
    is lower by a value of `32` than their corresponding lowercase characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The updated string `buffer` with the character following the period converted
    into uppercase will be displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all the lines of the file are read and displayed, the file pointed to by
    the `fp` pointer will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `convertcase.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you get no errors or warnings, this means that the `convertcase.c` program
    has been compiled into an executable file, `convertcase.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that I have created a file called `textfile.txt` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command is executed in Windows' Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the executable file, `convertcase.exe`, and then pass the `textfile.txt`
    file to it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding output that the characters that were in lowercase
    after the period are now converted into uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the contents of a random file in reverse order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we have a random file that contains some lines of text. Let's
    find out how to reverse the contents of this file.
  prefs: []
  type: TYPE_NORMAL
- en: This program will not give the correct output if a random file does not exist.
    Please read *Appendix A* to learn how to create a random file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the random file in read-only mode using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the random file in reverse order, execute a loop equal to the number
    of lines in the file. Every iteration of the loop will read one line beginning
    from the bottom of the file. The following formula will be used to find out the
    number of lines in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*total number of bytes used in the file/size of one line in bytes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for doing this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the file has to be read in reverse order, the file pointer will be
    positioned at the bottom of the file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a loop to execute that equals the number of lines in the file computed
    in step 3, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the loop, the file pointer will be positioned as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67c562c8-1e75-45e9-a08f-dbd7ef8e98bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the last line, the file pointer will be positioned at the byte location
    where the last line begins, at the **-1 x sizeof(line)** byte location. The last
    line will be read and displayed on the screen, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, the file pointer will be positioned at the byte location from where the
    second last line begins, at the **-2 x sizeof(line)** byte location. Again, the
    second last line will be read and displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The procedure will be repeated until all of the lines in the file have been
    read and displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `readrandominreverse.c` program for reading the random file in reverse
    order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will open the chosen file in read-only mode. If the file opens successfully,
    it will be pointed at by the file pointer `fp`. Next, we will find out the total
    number of lines in the file using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*total number of bytes used by the file/number of bytes used by one line*'
  prefs: []
  type: TYPE_NORMAL
- en: To know the total number of bytes used by the file, the file pointer will be
    positioned at the bottom of the file and we will invoke the `ftell` function.
    The `ftell` function finds the current location of the file pointer. Because the
    file pointer is at the end of the file, using this function will tell us the total
    number of bytes used by the file. To find the number of bytes used by one line,
    we will use the `sizeof` function. We will apply the preceding formula to compute
    the total number of lines in the file; this will be assigned to the variable,
    `nol`.
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `for` loop to execute for `nol` number of times. Within the `for`
    loop, the file pointer will be positioned at the end of the last line so that
    all of the lines from the file can be accessed in reverse order. So, the file
    pointer is first set at the `(-1 * size of one line)` location at the bottom of
    the file. Once the file pointer is positioned at this location, we will use the
    `fread` function to read the last line of the file and assign it to the structure
    variable line. The string in line will then be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: After displaying the last line on the screen, the file pointer will be set at
    the byte position of the second last line at `(-2 * size of one line)`. We will
    again use the `fread` function to read the second last line and display it on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure will be executed for the number of times that the `for` loop
    executes, and the `for` loop will execute the same number of times as there are
    lines in the file. Then the file will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `readrandominreverse.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you get no errors or warnings, this means that the `readrandominreverse.c`
    program has been compiled into an executable file, `readrandominreverse.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a random file, `random.data`, with the following
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the executable file, `readrandominreverse.exe`, to display the random
    file, `random.data`, in reverse order using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By comparing the original file with the preceding output, you can see that the
    file content is displayed in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Counting the number of vowels in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will open a sequential text file and count the number of
    vowels (both uppercase and lowercase) that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I will assume that a sequential file already exists. Please
    read *Appendix A* to learn how to create a sequential file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the sequential file in read-only mode using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the counter that will count the number of vowels in the file to
    `0`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One line is read from the file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Each character of the line is accessed and checked for any lowercase or uppercase
    vowels, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If any vowel is found, the value of the counter is incremented by `1`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 5 will be repeated until the end of the line has been reached. Check whether
    the end of the file has been reached. Repeat from step 4 until the end of the
    file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the count of the number of vowels in the file by printing the value
    in the counter variable on the screen, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding steps are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/507cecd3-b283-46cc-a3ec-9e8f1c177a35.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3
  prefs: []
  type: TYPE_NORMAL
- en: 'The `countvowels.c` program to count the number of vowels in a sequential text
    file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will open the chosen sequential file in read-only mode. If the file opens
    successfully, it will be pointed at by the file pointer, `fp`. To count the number
    of vowels in the file, we will initialize a counter from `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `while` loop to execute until the file pointer, `fp`, reaches
    the end of the file. Within the `while` loop, each line in the file will be read
    using the `fgets` function. The `fgets` function will read the `BUFFSIZE` number
    of characters from the file. The value of the `BUFFSIZE` variable is `255`, so
    `fgets` will read either `254` characters from the file or will read characters
    until the newline character, `\n`, is reached, whichever comes first.
  prefs: []
  type: TYPE_NORMAL
- en: The line read from the file is assigned to the `buffer` string. To display the
    file contents along with the count of the vowels, the content in the `buffer`
    string is displayed on the screen. The length of the `buffer` string will be computed
    and a `for` loop will be set to execute equaling the length of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the characters in the buffer string will be checked in the `for` loop.
    If any lowercase or uppercase vowels appear in the line, the value of the counter
    variable will be incremented by `1`. When the `while` loop ends, the counter variable
    will have the total count of the vowels present in the file. Finally, the value
    in the counter variable will be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `countvowels.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you get no errors or warnings, then this means that the `countvowels.c` program
    has been compiled into an executable file called `countvowels.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a text file called `textfile.txt` with some content.
    We will run the executable file, `countvowels.exe`, and supply the `textfile.txt`
    file to it to count the number of vowels in it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output of the program that the program not only displays
    the count of the vowels, but also the complete content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a word in a file with another word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that you want to replace all occurrences of the word `is` with the
    word `was` in one of your files. Let's find out how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I will assume that a sequential file already exists. Please
    read *Appendix A* to learn how to create a sequential file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the file in read-only mode using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the word to be replaced using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the new word that will replace the old word using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Read a line from the file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the word to be replaced appears anywhere in the line using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the word appears in the line, then simply replace it with the new word using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the word does not appear anywhere in the line, then move on to the next
    step. Print the line with the replaced word using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the end of the file has been reached using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the end of the file has not yet been reached, go to step 4\. Close the file
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `replaceword.c` program replaces the specified word in a file with another
    word and displays the modified content on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the chosen file in read-only mode. If the file opens successfully, then
    the file pointer, `fp`, will be set to point at it. Enter the word to be replaced
    and assign it to the string variable, `str1`. Similarly, enter the new string
    that will be assigned to another string variable, `str2`. The length of the two
    strings, `str1` and `str2`, will be computed and assigned to the variables, `ls1`
    and `ls2`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Set a `while` loop to execute until the file pointed at by `fp` pointer gets
    over. Within the `while` loop, one line from the file will be read using the `fgets`
    function. The `fgets` function reads the file until the maximum length that is
    specified or the new line character, `\n`, is reached, whichever comes first.
    Because strings are terminated with a mandatory null character, `\0`, a maximum
    of `254` characters will be read from the file.
  prefs: []
  type: TYPE_NORMAL
- en: The string that is read from the file will be assigned to the `line` variable.
    The length of the `line` string will be computed and assigned to the `ll` variable.
    Using a `for` loop, each of the characters in the line variable will be accessed
    to check whether they match with `str1[0]`—that is, with the first character of
    the string to be replaced. The characters in the `line` variable that don't match
    with the string to be replaced will be assigned to another string, called `nline`.
    The `nline` string will contain the desired content—that is, all of the characters
    of the `line` variable and the new string. If it exists in `line`, then the string
    will be replaced with the new string and the entire modified content will be assigned
    to the new string, `nline`.
  prefs: []
  type: TYPE_NORMAL
- en: If the first character of the string to be replaced matches with any of the
    characters in `line`, then the `while` loop will be used to match all of the successive
    characters of the string that is to be replaced with the successive characters
    in `line`. If all of the characters of the string that is to be replaced match
    with successive characters in `line`, then all of the characters of the string
    to be replaced are replaced with the new string and assigned to the new string,
    `nline`. That way, the `while` loop will read one line of text at a time from
    the file, searching for occurrences of the string to be replaced. If it is found,
    it replaces it with the new string and assigns the modified line of text to another
    string, `nline`. The null character, `\0`, is added to the modified string, `nline`,
    and is displayed on the screen. Finally, the file pointed to by the file pointer,
    `fp`, is closed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I am replacing the desired word and another string and displaying
    the updated content on the screen. If you want the updated content to be written
    into another file, then you can always open another file in write mode and execute
    the `fputs` function to write the updated content in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `replaceword.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, then this means that the `replaceword.c`
    program has been compiled into an executable file, `replaceword.exe`. Let''s run
    the executable file, `replaceword.exe`, and supply a text file to it. We will
    assume that a text file called `textfile.txt` exists and has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use this file to replace one of its words with another word using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can see that all occurrences of the word `is` are replaced by `was` in `textfile.txt`,
    and the modified content is displayed on the screen. We've successfully replaced
    the words of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption means converting content into a coded format so that unauthorized
    persons will be unable to see or access the original content of the file. A text
    file can be encrypted by applying a formula to the ASCII value of the content.
  prefs: []
  type: TYPE_NORMAL
- en: The formula or code can be of your choosing, and it can be as simple or complex
    as you want. For example, let's say that you have chosen to replace the current
    ASCII value of all letters by moving them forward 15 values. In this case, if
    the letter is a lowercase *a* that has the ASCII value of 97, then the forward
    shift of the ASCII values by 15 will make the *encrypted* letter a lowercase *p*,
    which has the ASCII value of 112 (97 + 15 = 112).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I assume that a sequential file that you want to encrypt already
    exists. Please read *Appendix A* to learn how to create a sequential file. You
    can also refer to *Appendix A* if you want to know how an encrypted file is decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the source file in read-only mode using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the destination file, the file where the encrypted text will be written,
    in write-only mode using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Read a line from the file and access each of its characters using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following code, subtract a value of `45` from the ASCII value of
    each of the characters in the line to encrypt that character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat step 5 until the line is over. Once all of the characters in the line
    are encrypted, write the encrypted line into the destination file using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the end of the file has been reached using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the two files using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding steps are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d3d9f9e-269f-4a4d-ae0c-f97b79da7af2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4
  prefs: []
  type: TYPE_NORMAL
- en: 'The `encryptfile.c` program to encrypt a file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first file name that is passed through the command-line arguments is opened
    in read-only mode. The second file name that is passed through the command-line
    arguments is opened in write-only mode. If both files are opened correctly, then
    the `fp` and `fq` pointers , respectively, will point at the read-only and write-only
    files.
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `while` loop to execute until it reaches the end of the source
    file. Within the loop, one line from the source file will be read using the `fgets`
    function. The `fgets` function reads the specified number of bytes from the file
    or until the new line character, `\n`, is reached. If the new line character does
    not appear in the file, then the `BUFFSIZE` constant limits the bytes to be read
    from the file to `254`.
  prefs: []
  type: TYPE_NORMAL
- en: The line read from the file is assigned to the `buffer` string . The length
    of the string `buffer` is computed and assigned to the variable, `n`. We will
    then set a `for` loop to execute until it reaches the end of the length of the
    `buffer` string, and within the loop, the ASCII value of each character will be
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt the file, we will subtract a value of `45` from the ASCII value of
    each of the characters, although we can apply any formula we like. Just ensure
    that you remember the formula, as we will need to reverse it in order to decrypt
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: After applying the formula to all of the characters, the encrypted line will
    be written into the target file. In addition, to display the encrypted version
    on the screen, the encrypted line will be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When the `while` loop is finished, all of the lines from the source file will
    be written into the target file after they are encrypted. Finally, the two files
    will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `encryptfile.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you get no errors or warnings, this means that the `encryptfile.c` program
    has been compiled into an executable file, `encryptfile.exe`. Let's run this executable
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the executable file, though, let''s take a look at the text
    file, `textfile.txt`, which will be encrypted using this program. The contents
    of this text file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the executable file, `encryptfile.exe`, on `textfile.txt` and put
    the encrypted content into another file named `encrypted.txt` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The normal content in `textfile.txt` is encrypted and the encrypted content
    is written into another file named `encrypted.txt`. The encrypted content will
    appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command is executed in Windows' Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Voila! We've successfully encrypted the file!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn how to create and read content in sequential file, random file and
    decrypting a file visit *Appendix C* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf).'
  prefs: []
  type: TYPE_NORMAL
