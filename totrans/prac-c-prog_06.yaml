- en: File Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data storage is a mandatory feature in all applications. When we enter any data
    while running a program, that data is stored as RAM, which means that it is temporary
    in nature. We will not get that data back when running the program the next time.
    But what if we want the data to stay there so we can refer to it again when we
    need it? In this case, we have to store the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we want our data to be stored and to be accessible and available
    for reuse whenever required. In C, data storage can be done through traditional
    file handling techniques and through the database system. The following are the
    two types of file handling available in C:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequential file handling**: Data is written in a simple text format and can
    be read and written sequentially. To read the *n*^(th) line, we have to first
    read *n*-1 lines.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random file handling**: Data is written as bytes and can be read or written
    randomly. We can read or write any line randomly by positioning the file pointer
    at the desired location.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following recipes using file handling:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file and converting all characters after a period into uppercase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the contents of a random file in reverse order
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the number of vowels in a file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a word in a file with another word
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting a file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start with the recipes, let's review some of the functions we will
    be using to create our recipes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Functions used in file handling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've divided this section into two parts. In the first part, we will look at
    the functions specific to the sequential file handling method. In the second,
    we will look at the functions used for random files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Functions commonly used in sequential file handling
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some of the functions that are used to open, close, read,
    and write in a sequential file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: fopen()
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fopen()` function is used for opening a file for reading, writing, and
    doing other operations. Here is its syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `file_name` represents the file that we want to work on and `mode` states
    the purpose for which we want to open the file. It can be any of the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`r`**:** This opens the file in read mode and sets the file pointer at the
    first character of the file.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`**:** This opens the file in write mode. If the file exists, it will be
    overwritten.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`**:** Opens the file in append mode. Newly entered data will be added at
    the end of the file.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r+`**:** This opens the file in read and write mode. The file pointer is set
    to point at the beginning of the file. The file content will not be deleted if
    it already exists. It will not create a file if it does not already exist.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w+`**:** This also opens the file in read and write mode. The file pointer
    is set to point at the beginning of the file. The file content will be deleted
    if it already exists, but the file will be created if it does not already exist.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`**:** This opens a file for reading as well as for appending new content.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fopen` function returns a file descriptor that points to the file for performing
    different operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: fclose()
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fclose()` function is used for closing the file. Here is its syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `file_pointer` represents the file pointer that is pointing at the open
    file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The function returns a `0` value if the file is successfully closed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: fgets()
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fgets()` function is used for reading a string from the specified file.
    Here is its syntax:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function has the following features:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`string`**:** This represents the character array to which the data that is
    read from the file will be assigned.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`**:** This represents the maximum number of characters that can be
    read from the file. The *length-1* number of characters will be read from the
    file. The reading of data from the file will stop either at *length-1* location
    or at the new line character, `\n`, whichever comes first.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file_pointer`**:** This represents the file pointer that is pointing at the
    file.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fputs()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fputs()` function is used for writing into the file. Here is its syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `string` represents the character array containing the data to be written
    into the file. The `file_pointer` phrase represents the file pointer that is pointing
    at the file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Functions commonly used in random files
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following functions are used to set the file pointer at a specified location
    in the random file, indicate the location where the file pointer is pointing currently,
    and rewind the file pointer to the beginning of the random file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: fseek()
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fseek()` function is used for setting the file pointer at the specific
    position in the file. Here is its syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function has the following features:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`file_pointer`**:** This represents the file pointer that points at the file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`**:** This represents the number of bytes that the file pointer needs
    to be moved from the position specified by the location parameter. If the value
    of `offset` is positive, the file pointer will move forward in the file, and if
    it is negative, the file pointer will move backward from the given position.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`**:** This is the value that defines the position from which the
    file pointer needs to be moved. That is, the file pointer will be moved equal
    to the number of bytes specified by the `offset` parameter from the position specified
    by the `location` parameter. Its value can be `0`, `1`, or `2`, as shown in the
    following table:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Value** | **Meaning** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `0` | The file pointer will be moved from the beginning of the file |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `1` | The file pointer will be moved from the current position |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `2` | The file pointer will be moved from the end of the file |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the following example. Here, the file pointer will be moved
    `5` bytes forward from the beginning of the file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following example, the file pointer will be moved `5` bytes backward
    from the end of the file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ftell()
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ftell()` function returns the byte location where `file_pointer` is currently
    pointing at the file. Here is its syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `file_pointer` is a file pointer pointing at the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: rewind()
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `rewind()` function is used for moving the file pointer back to the beginning
    of the specified file. Here is its syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `file_pointer` is a file pointer pointing at the file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to use both types of file handling using recipes
    that make real-time applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file and converting all characters after the period into uppercase
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we have a file that contains some text. We think that there is an anomaly
    in the text—every first character after the period is in lowercase when it should
    be in uppercase. In this recipe, we will read that text file and convert each
    character after the period (`.`) that is, in lowercase into uppercase.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I assume that you know how to create a text file and how to
    read a text file. If you don't know how to perform these actions, you will find
    programs for both of them in *Appendix A*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the sequential file in read-only mode using the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate. Set this up using the following
    code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One line is read from the file, as shown in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each character of the line is accessed and checked for the presence of periods,
    as shown in the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If a period is found, the character following the period is checked to confirm
    whether it is in uppercase, as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the character following the period is in lowercase, a value of `32` is subtracted
    from the ASCII value of the lowercase character to convert it into uppercase,
    as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the line is not yet over, then the sequence from step 4 onward is repeated
    till step 6; otherwise, the updated line is displayed on the screen, as shown
    in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check whether the end of file has been reached using the following code. If
    the file is not over, repeat the sequence from step 3:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding steps are pictorially explained in the following diagram (*Figure
    6.1*):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a31410ee-7823-423e-8319-f11eaa3c4111.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The `convertcase.c` program for converting a lowercase character found after
    a period in a file into uppercase is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's go behind the scenes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The file whose name is supplied as a command-line argument is opened in read-only
    mode and is pointed to by the file pointer, `fp`. This recipe is focused on reading
    a file and changing its case, so if the file does not exist or does not have read
    permission, an error will be displayed and the program will terminate.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop will be set to execute until `feof` (the end of file) is reached.
    Within the `while` loop, each line of the file will be read one by one and assigned
    to the string named `buffer`. The `fgets()` function will be used to read one
    line at a time from the file. A number of characters will be read from the file
    until the newline character, `\n`, is reached, to a maximum of 254.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will be performed on each of the lines assigned to the
    string buffer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The length of the buffer string will be computed and a `for` loop will be executed
    to access each of the characters in the string buffer.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The string buffer will be checked to see whether there are any periods in it.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If one is found, the character following it will be checked to see whether it
    is into lowercase. ASCII values will be used to then convert the lowercase characters
    into uppercase (refer to [Chapter 2](6cbb6fdb-cd55-4e74-bd5a-2a2f91575490.xhtml),
    *Managing Strings*, for more information on the ASCII values that correspond to
    the letters of the alphabet). If the character following the period is in lowercase,
    a value of `32` will be deducted from the ASCII value of the lowercase character
    to convert it into uppercase. Remember, the ASCII value of uppercase characters
    is lower by a value of `32` than their corresponding lowercase characters.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The updated string `buffer` with the character following the period converted
    into uppercase will be displayed on the screen.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all the lines of the file are read and displayed, the file pointed to by
    the `fp` pointer will be closed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `convertcase.c` program as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you get no errors or warnings, this means that the `convertcase.c` program
    has been compiled into an executable file, `convertcase.exe`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that I have created a file called `textfile.txt` with the following
    content:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command is executed in Windows' Command Prompt.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the executable file, `convertcase.exe`, and then pass the `textfile.txt`
    file to it, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see in the preceding output that the characters that were in lowercase
    after the period are now converted into uppercase.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the contents of a random file in reverse order
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we have a random file that contains some lines of text. Let's
    find out how to reverse the contents of this file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: This program will not give the correct output if a random file does not exist.
    Please read *Appendix A* to learn how to create a random file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the random file in read-only mode using the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To read the random file in reverse order, execute a loop equal to the number
    of lines in the file. Every iteration of the loop will read one line beginning
    from the bottom of the file. The following formula will be used to find out the
    number of lines in the file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*total number of bytes used in the file/size of one line in bytes*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for doing this is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because the file has to be read in reverse order, the file pointer will be
    positioned at the bottom of the file, as shown in the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set a loop to execute that equals the number of lines in the file computed
    in step 3, as shown in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the loop, the file pointer will be positioned as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67c562c8-1e75-45e9-a08f-dbd7ef8e98bb.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the last line, the file pointer will be positioned at the byte location
    where the last line begins, at the **-1 x sizeof(line)** byte location. The last
    line will be read and displayed on the screen, as shown in the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, the file pointer will be positioned at the byte location from where the
    second last line begins, at the **-2 x sizeof(line)** byte location. Again, the
    second last line will be read and displayed on the screen.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The procedure will be repeated until all of the lines in the file have been
    read and displayed on the screen.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `readrandominreverse.c` program for reading the random file in reverse
    order is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's go behind the scenes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will open the chosen file in read-only mode. If the file opens successfully,
    it will be pointed at by the file pointer `fp`. Next, we will find out the total
    number of lines in the file using the following formula:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*total number of bytes used by the file/number of bytes used by one line*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: To know the total number of bytes used by the file, the file pointer will be
    positioned at the bottom of the file and we will invoke the `ftell` function.
    The `ftell` function finds the current location of the file pointer. Because the
    file pointer is at the end of the file, using this function will tell us the total
    number of bytes used by the file. To find the number of bytes used by one line,
    we will use the `sizeof` function. We will apply the preceding formula to compute
    the total number of lines in the file; this will be assigned to the variable,
    `nol`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `for` loop to execute for `nol` number of times. Within the `for`
    loop, the file pointer will be positioned at the end of the last line so that
    all of the lines from the file can be accessed in reverse order. So, the file
    pointer is first set at the `(-1 * size of one line)` location at the bottom of
    the file. Once the file pointer is positioned at this location, we will use the
    `fread` function to read the last line of the file and assign it to the structure
    variable line. The string in line will then be displayed on the screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: After displaying the last line on the screen, the file pointer will be set at
    the byte position of the second last line at `(-2 * size of one line)`. We will
    again use the `fread` function to read the second last line and display it on
    the screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: This procedure will be executed for the number of times that the `for` loop
    executes, and the `for` loop will execute the same number of times as there are
    lines in the file. Then the file will be closed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `readrandominreverse.c` program, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you get no errors or warnings, this means that the `readrandominreverse.c`
    program has been compiled into an executable file, `readrandominreverse.exe`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a random file, `random.data`, with the following
    text:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s run the executable file, `readrandominreverse.exe`, to display the random
    file, `random.data`, in reverse order using the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By comparing the original file with the preceding output, you can see that the
    file content is displayed in reverse order.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Counting the number of vowels in a file
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will open a sequential text file and count the number of
    vowels (both uppercase and lowercase) that it contains.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I will assume that a sequential file already exists. Please
    read *Appendix A* to learn how to create a sequential file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the sequential file in read-only mode using the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initialize the counter that will count the number of vowels in the file to
    `0`, as shown in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One line is read from the file, as shown in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Each character of the line is accessed and checked for any lowercase or uppercase
    vowels, as shown in the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If any vowel is found, the value of the counter is incremented by `1`, as shown
    in the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Step 5 will be repeated until the end of the line has been reached. Check whether
    the end of the file has been reached. Repeat from step 4 until the end of the
    file, as shown in the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Display the count of the number of vowels in the file by printing the value
    in the counter variable on the screen, as shown in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding steps are shown in the following diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/507cecd3-b283-46cc-a3ec-9e8f1c177a35.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The `countvowels.c` program to count the number of vowels in a sequential text
    file is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's go behind the scenes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will open the chosen sequential file in read-only mode. If the file opens
    successfully, it will be pointed at by the file pointer, `fp`. To count the number
    of vowels in the file, we will initialize a counter from `0`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `while` loop to execute until the file pointer, `fp`, reaches
    the end of the file. Within the `while` loop, each line in the file will be read
    using the `fgets` function. The `fgets` function will read the `BUFFSIZE` number
    of characters from the file. The value of the `BUFFSIZE` variable is `255`, so
    `fgets` will read either `254` characters from the file or will read characters
    until the newline character, `\n`, is reached, whichever comes first.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The line read from the file is assigned to the `buffer` string. To display the
    file contents along with the count of the vowels, the content in the `buffer`
    string is displayed on the screen. The length of the `buffer` string will be computed
    and a `for` loop will be set to execute equaling the length of the string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Each of the characters in the buffer string will be checked in the `for` loop.
    If any lowercase or uppercase vowels appear in the line, the value of the counter
    variable will be incremented by `1`. When the `while` loop ends, the counter variable
    will have the total count of the vowels present in the file. Finally, the value
    in the counter variable will be displayed on the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `countvowels.c` program as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you get no errors or warnings, then this means that the `countvowels.c` program
    has been compiled into an executable file called `countvowels.exe`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a text file called `textfile.txt` with some content.
    We will run the executable file, `countvowels.exe`, and supply the `textfile.txt`
    file to it to count the number of vowels in it, as shown in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can see from the output of the program that the program not only displays
    the count of the vowels, but also the complete content of the file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a word in a file with another word
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that you want to replace all occurrences of the word `is` with the
    word `was` in one of your files. Let's find out how to do this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I will assume that a sequential file already exists. Please
    read *Appendix A* to learn how to create a sequential file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the file in read-only mode using the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Enter the word to be replaced using the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Enter the new word that will replace the old word using the following code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Read a line from the file using the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Check whether the word to be replaced appears anywhere in the line using the
    following code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the word appears in the line, then simply replace it with the new word using
    the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the word does not appear anywhere in the line, then move on to the next
    step. Print the line with the replaced word using the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Check whether the end of the file has been reached using the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the end of the file has not yet been reached, go to step 4\. Close the file
    using the following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `replaceword.c` program replaces the specified word in a file with another
    word and displays the modified content on the screen:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's go behind the scenes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the chosen file in read-only mode. If the file opens successfully, then
    the file pointer, `fp`, will be set to point at it. Enter the word to be replaced
    and assign it to the string variable, `str1`. Similarly, enter the new string
    that will be assigned to another string variable, `str2`. The length of the two
    strings, `str1` and `str2`, will be computed and assigned to the variables, `ls1`
    and `ls2`, respectively.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Set a `while` loop to execute until the file pointed at by `fp` pointer gets
    over. Within the `while` loop, one line from the file will be read using the `fgets`
    function. The `fgets` function reads the file until the maximum length that is
    specified or the new line character, `\n`, is reached, whichever comes first.
    Because strings are terminated with a mandatory null character, `\0`, a maximum
    of `254` characters will be read from the file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The string that is read from the file will be assigned to the `line` variable.
    The length of the `line` string will be computed and assigned to the `ll` variable.
    Using a `for` loop, each of the characters in the line variable will be accessed
    to check whether they match with `str1[0]`—that is, with the first character of
    the string to be replaced. The characters in the `line` variable that don't match
    with the string to be replaced will be assigned to another string, called `nline`.
    The `nline` string will contain the desired content—that is, all of the characters
    of the `line` variable and the new string. If it exists in `line`, then the string
    will be replaced with the new string and the entire modified content will be assigned
    to the new string, `nline`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: If the first character of the string to be replaced matches with any of the
    characters in `line`, then the `while` loop will be used to match all of the successive
    characters of the string that is to be replaced with the successive characters
    in `line`. If all of the characters of the string that is to be replaced match
    with successive characters in `line`, then all of the characters of the string
    to be replaced are replaced with the new string and assigned to the new string,
    `nline`. That way, the `while` loop will read one line of text at a time from
    the file, searching for occurrences of the string to be replaced. If it is found,
    it replaces it with the new string and assigns the modified line of text to another
    string, `nline`. The null character, `\0`, is added to the modified string, `nline`,
    and is displayed on the screen. Finally, the file pointed to by the file pointer,
    `fp`, is closed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I am replacing the desired word and another string and displaying
    the updated content on the screen. If you want the updated content to be written
    into another file, then you can always open another file in write mode and execute
    the `fputs` function to write the updated content in it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `replaceword.c` program, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you get no errors or warnings, then this means that the `replaceword.c`
    program has been compiled into an executable file, `replaceword.exe`. Let''s run
    the executable file, `replaceword.exe`, and supply a text file to it. We will
    assume that a text file called `textfile.txt` exists and has the following content:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s use this file to replace one of its words with another word using
    the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see that all occurrences of the word `is` are replaced by `was` in `textfile.txt`,
    and the modified content is displayed on the screen. We've successfully replaced
    the words of our choice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting a file
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption means converting content into a coded format so that unauthorized
    persons will be unable to see or access the original content of the file. A text
    file can be encrypted by applying a formula to the ASCII value of the content.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The formula or code can be of your choosing, and it can be as simple or complex
    as you want. For example, let's say that you have chosen to replace the current
    ASCII value of all letters by moving them forward 15 values. In this case, if
    the letter is a lowercase *a* that has the ASCII value of 97, then the forward
    shift of the ASCII values by 15 will make the *encrypted* letter a lowercase *p*,
    which has the ASCII value of 112 (97 + 15 = 112).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I assume that a sequential file that you want to encrypt already
    exists. Please read *Appendix A* to learn how to create a sequential file. You
    can also refer to *Appendix A* if you want to know how an encrypted file is decrypted.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the source file in read-only mode using the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the file does not exist or does not have enough permissions, an error message
    will be displayed and the program will terminate, as shown in the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Open the destination file, the file where the encrypted text will be written,
    in write-only mode using the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Read a line from the file and access each of its characters using the following
    code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using the following code, subtract a value of `45` from the ASCII value of
    each of the characters in the line to encrypt that character:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Repeat step 5 until the line is over. Once all of the characters in the line
    are encrypted, write the encrypted line into the destination file using the following
    code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Check whether the end of the file has been reached using the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Close the two files using the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding steps are shown in the following diagram:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d3d9f9e-269f-4a4d-ae0c-f97b79da7af2.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The `encryptfile.c` program to encrypt a file is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, let's go behind the scenes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first file name that is passed through the command-line arguments is opened
    in read-only mode. The second file name that is passed through the command-line
    arguments is opened in write-only mode. If both files are opened correctly, then
    the `fp` and `fq` pointers , respectively, will point at the read-only and write-only
    files.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `while` loop to execute until it reaches the end of the source
    file. Within the loop, one line from the source file will be read using the `fgets`
    function. The `fgets` function reads the specified number of bytes from the file
    or until the new line character, `\n`, is reached. If the new line character does
    not appear in the file, then the `BUFFSIZE` constant limits the bytes to be read
    from the file to `254`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The line read from the file is assigned to the `buffer` string . The length
    of the string `buffer` is computed and assigned to the variable, `n`. We will
    then set a `for` loop to execute until it reaches the end of the length of the
    `buffer` string, and within the loop, the ASCII value of each character will be
    changed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt the file, we will subtract a value of `45` from the ASCII value of
    each of the characters, although we can apply any formula we like. Just ensure
    that you remember the formula, as we will need to reverse it in order to decrypt
    the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: After applying the formula to all of the characters, the encrypted line will
    be written into the target file. In addition, to display the encrypted version
    on the screen, the encrypted line will be displayed on the screen.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: When the `while` loop is finished, all of the lines from the source file will
    be written into the target file after they are encrypted. Finally, the two files
    will be closed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `encryptfile.c` program, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you get no errors or warnings, this means that the `encryptfile.c` program
    has been compiled into an executable file, `encryptfile.exe`. Let's run this executable
    file.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the executable file, though, let''s take a look at the text
    file, `textfile.txt`, which will be encrypted using this program. The contents
    of this text file are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s run the executable file, `encryptfile.exe`, on `textfile.txt` and put
    the encrypted content into another file named `encrypted.txt` using the following
    code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The normal content in `textfile.txt` is encrypted and the encrypted content
    is written into another file named `encrypted.txt`. The encrypted content will
    appear as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding command is executed in Windows' Command Prompt.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Voila! We've successfully encrypted the file!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn how to create and read content in sequential file, random file and
    decrypting a file visit *Appendix C* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在顺序文件、随机文件中创建和读取内容以及解密文件，请访问此链接上的*附录C*：[https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20C.pdf).
