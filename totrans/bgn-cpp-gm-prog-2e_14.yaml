- en: '*Chapter 13*: Sound Effects, File I/O, and Finishing the Game'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are nearly there. This short chapter will demonstrate how we can easily manipulate
    files stored on the hard drive using the C++ standard library, and we will also
    add sound effects. Of course, we know how to add sound effects, but we will discuss
    exactly where in the code the calls to the `play` function will go. We will also
    tie up a few loose ends to make the game complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading the hi-score using file input and file output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the player to level up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple never-ending waves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading the high score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File `fstream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include `fstream` in the same way we included `sstream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, add a new folder in the `ZombieArena` folder called `gamedata`. Next, right-click
    in this folder and create a new file called `scores.txt`. It is in this file that
    we will save the player's high score. You can easily open the file and add a score
    to it. If you do, make sure it is quite a low score so that we can easily test
    whether beating that score results in the new score being added. Be sure to close
    the file once you are done with it or the game will not be able to access it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we will create an `ifstream` object called `inputFile`
    and send the folder and file we just created as a parameter to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`if(inputFile.is_open())` checks that the file exists and is ready to read
    from. We then put the contents of the file into `hiScore` and close the file.
    Add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can handle saving a potentially new high score. Within the block that
    handles the player''s health being less than or equal to zero, we need to create
    an `ofstream` object called `outputFile`, write the value of `hiScore` to the
    text file, and then close the file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can play the game and your hi-score will be saved. Quit the game and notice
    that your hi-score is still there if you play it again.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some noise.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create all the `SoundBuffer` and `Sound` objects that
    we need to add a range of sound effects to the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the required SFML `#include` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go ahead and add the seven `SoundBuffer` and `Sound` objects that load
    and prepare the seven sound files that we prepared in [*Chapter 8*](B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183)*,
    SFML Views – Starting the Zombie Shooter Game*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, the seven sound effects are ready to play. We just need to work out where
    in our code each of the calls to the `play` function will go.
  prefs: []
  type: TYPE_NORMAL
- en: Leveling up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code we will add allows the player to level up between waves.
    It is because of the work we have already done that this is straightforward to
    achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the `LEVELING_UP` state where we handle
    player input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The player can now level up each time a wave of zombies is cleared. We can't,
    however, increase the number of zombies or the size of the level just yet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the `LEVELING_UP` state, right after the code we have just
    added, amend the code that runs when the state changes from `LEVELING_UP` to `PLAYING`.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the code in full. I have highlighted the lines that are either new or
    have been slightly amended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add or amend the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code starts by incrementing the `wave` variable. Then, the code
    is amended to make the number of zombies and size of the arena relative to the
    new value of `wave`. Finally, we add the call to `powerup.play()` to play the
    leveling up sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already determine the size of the arena and the number of zombies by the
    value of the `wave` variable. We must also reset the ammo and gun-related variables,
    as well as setting `wave` and `score` to zero at the start of each new game. Find
    the following code in the event-handling section of the game loop and add the
    following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can play the game, the player can get even more powerful, and the zombies
    will get ever more numerous within an arena of increasing size—until they die.
    Then, the game starts all over again.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the rest of the sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will add the rest of the calls to the `play` function. We will deal
    with each of them individually, as locating exactly where they go is key to playing
    them at the right moment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects while the player is reloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following highlighted code in three places to play the appropriate
    `reload` or `reloadFailed` sound when the player presses the *R* key to attempt
    to reload their gun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The player will now get an audible response when they reload or attempt to reload.
    Let's move on to playing a shooting sound.
  prefs: []
  type: TYPE_NORMAL
- en: Making a shooting sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following highlighted call to `shoot.play()` near the end of the code
    that handles the player clicking the left mouse button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The game will now play a satisfying shooting sound. Next, we will play a sound
    when the player is hit by a zombie.
  prefs: []
  type: TYPE_NORMAL
- en: Playing a sound when the player is hit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this following code, we wrap the call to `hit.play` in a test to see if the
    `player.hit` function returns true. Remember that the `player.hit` function tests
    to see if a hit has been recorded in the previous 100 milliseconds. This will
    have the effect of playing a fast-repeating thud sound, but not so fast that the
    sound blurs into one noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the call to `hit.play`, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The player will hear an ominous thudding sound when a zombie touches them, and
    this sound will repeat around five times per second if the zombie continues touching
    them. The logic for this is contained in the `hit` function of the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: Playing a sound when getting a pickup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the player picks up a health pickup, we will play the regular pickup sound.
    However, when the player gets an ammo pickup, we will play the reload sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two calls to play sounds within the appropriate collision detection
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Making a splat sound when a zombie is shot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a call to `splat.play` at the end of the section of code that detects a
    bullet colliding with a zombie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now play the completed game and watch the number of zombies and the
    arena increase each wave. Choose your level-ups carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finished the Zombie Arena game. It has been quite a journey. We have learned
    a whole bunch of C++ fundamentals, such as references, pointers, OOP, and classes.
    In addition, we have used SFML to manage cameras (views), vertex arrays, and collision
    detection. We learned how to use sprite sheets to reduce the number of calls to
    `window.draw` and speed up the frame rate. Using C++ pointers, the STL, and a
    little bit of OOP, we built a singleton class to manage our textures. In the next
    project, we will extend this idea to manage all of our game's assets.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up in the penultimate project of this book, we will discover particle
    effects, directional sound, and split-screen co-op gaming. In C++, we will encounter
    inheritance, polymorphism, and a few more new concepts as well.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions that might be on your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Q) Despite using classes, I am finding that the code is getting very long and
    unmanageable again.
  prefs: []
  type: TYPE_NORMAL
- en: A) One of the biggest issues is the structure of our code. As we learn more
    C++, we will also learn ways to make the code more manageable and generally less
    lengthy. We will do so in the next project and the final project too. By the end
    of this book, you will know about a number of strategies that you can use to manage
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Q) The sound effects seem a bit flat and unrealistic. How can they be improved?
  prefs: []
  type: TYPE_NORMAL
- en: A) One way to significantly improve the feeling the player gets from sound is
    to make the sound directional, as well as changing the volume based on the distance
    of the sound source to the player character. We will use SFML's advanced sound
    features in the next project.
  prefs: []
  type: TYPE_NORMAL
