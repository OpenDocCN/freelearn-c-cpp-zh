<html><head></head><body>
<div id="_idContainer045">
<h1 class="chapter-number" id="_idParaDest-181"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-182"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.2.1">Writing Generic Containers with Implicit Memory Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we wrote a working (if simple) implementation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.5.1">-like type in </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.7.1">, as well as a working (if, again, simple) implementation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">std::forward_list&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.9.1">-like type in </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.11.1">. </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Not bad!</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In the case of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.15.1"> type, after an initial effort that led to a working but sometimes inefficient implementation, we made the effort to separate allocation from construction, something that reduced the amount of redundant effort required at runtime but came at the cost of a more subtle implementation. </span><span class="koboSpan" id="kobo.15.2">In this more sophisticated implementation, we distinguished parts of the underlying storage that are initialized from those that are not and, of course, operated on both parts appropriately (treating objects as objects and raw memory as such). </span><span class="koboSpan" id="kobo.15.3">For example, we used assignment (and algorithms that use the assignment operator) to replace the contents of existing objects but preferred placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">new</span></strong><span class="koboSpan" id="kobo.17.1"> (and algorithms that rely on this mechanism) to create objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">raw memory.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.21.1"> implementation from the previous chapter is a class expressed with a sizable amount of source code. </span><span class="koboSpan" id="kobo.21.2">One of the reasons for this situation is the explicit memory management we have been doing. </span><span class="koboSpan" id="kobo.21.3">Indeed, we have made a </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.23.1"> object responsible for both the management of the underlying memory block and the objects stored therein, and this double responsibility came with a cost. </span><span class="koboSpan" id="kobo.23.2">In this chapter, we will revisit that design by making memory management </span><em class="italic"><span class="koboSpan" id="kobo.24.1">implicit</span></em><span class="koboSpan" id="kobo.25.1"> and we will discuss the consequences of this new approach. </span><span class="koboSpan" id="kobo.25.2">Hopefully, dear reader, this will lead you toward a possible simplification and refinement of your </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">coding practices.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">In this chapter, our goals will be </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.29.1">To adapt a hand-written container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.31.1"> in such a way as to significantly simplify its memory </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">management responsibilities</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">To understand the consequences of our design on source </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">code complexity</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">To understand the consequences of our design on </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">exception safety</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">We will spend most of our energy on revisiting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.39.1"> container, but we will also revisit </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.41.1"> to see if we can apply the same kind of reasoning to both container types. </span><span class="koboSpan" id="kobo.41.2">By the end of this chapter, at least in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.43.1">, we will still have a hand-written container that manages memory efficiently and distinguishes raw memory from constructed objects, but our implementation will be significantly simpler than the one we produced in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.45.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Note that with respect to </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.48.1">, this chapter will compare two versions. </span><span class="koboSpan" id="kobo.48.2">One will be named the “</span><em class="italic"><span class="koboSpan" id="kobo.49.1">naïve</span></em><span class="koboSpan" id="kobo.50.1"> version” and will be the initial implementation that uses objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">T</span></strong><span class="koboSpan" id="kobo.52.1"> throughout the underlying storage. </span><span class="koboSpan" id="kobo.52.2">The other will be named the “</span><em class="italic"><span class="koboSpan" id="kobo.53.1">sophisticated</span></em><span class="koboSpan" id="kobo.54.1"> version” and will be the implementation that considers the underlying storage as being made of two (potentially empty) “sections,” with objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">T</span></strong><span class="koboSpan" id="kobo.56.1"> at the beginning and raw memory at </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the end.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.58.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.59.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13"><span class="No-Break"><span class="koboSpan" id="kobo.61.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.63.1">Some words about the code excerpts in this chapter</span></p>
<p class="callout"><span class="koboSpan" id="kobo.64.1">This chapter will for the most part revisit and modify (hopefully simplifying!) the code examples from </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.66.1">, using ideas from previous chapters (notably </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.68.1"> and </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.69.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.70.1">) along the way. </span><span class="koboSpan" id="kobo.70.2">Since a lot of the code used for </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.72.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.74.1"> will not change, we will not write the entire classes all over again to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">undue repetition.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.76.1">Instead, we will concentrate on the most meaningful modifications made to the previous versions of those classes, sometimes comparing implementations “before” and “after” modifications have been made. </span><span class="koboSpan" id="kobo.76.2">Of course, the code samples in the GitHub repository are complete and can be used to “complete </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">the picture.”</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.78.1">Why explicit memory management complicates our implementation</span></h1>
<p><span class="koboSpan" id="kobo.79.1">Let’s look for a </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.80.1">moment at one of the constructors for </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.82.1"> as written in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.83.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">For simplicity, we will use the constructor that accepts a number of elements and an initial value for these elements as arguments. </span><span class="koboSpan" id="kobo.84.3">If we limit ourselves to the naïve version where </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">elems</span></strong><span class="koboSpan" id="kobo.86.1"> points to a sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">T</span></strong><span class="koboSpan" id="kobo.88.1"> objects and put aside for the moment the more sophisticated version where </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">elems</span></strong><span class="koboSpan" id="kobo.90.1"> points to a block of memory that holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">T</span></strong><span class="koboSpan" id="kobo.92.1"> objects at the beginning and raw memory at the end, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">// naïve version with elems of type T*</span></strong><span class="koboSpan" id="kobo.96.1">
   Vector(size_type n, const_reference init)
      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {
      try {
         std::fill(begin(), end(), init);
      } catch (...) {
         delete [] elems;
         throw;
      }
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.97.1">This constructor allocates an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">T</span></strong><span class="koboSpan" id="kobo.99.1"> objects, initializes them through a sequence of assignments, “handles” exceptions, and so on. </span><span class="koboSpan" id="kobo.99.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">try</span></strong><span class="koboSpan" id="kobo.101.1"> block and its corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">catch</span></strong><span class="koboSpan" id="kobo.103.1"> block are part of our implementation, but not because we want to handle exceptions raised by the constructors of </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">T</span></strong><span class="koboSpan" id="kobo.105.1"> objects. </span><span class="koboSpan" id="kobo.105.2">Indeed: how could we know what exceptions it could throw if we do not know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">T</span></strong><span class="koboSpan" id="kobo.107.1"> is? </span><span class="koboSpan" id="kobo.107.2">We insert these blocks because we need to explicitly deallocate and destroy the array if we are to avoid leaks. </span><span class="koboSpan" id="kobo.107.3">The situation gets even more complicated if we look at the more sophisticated version that distinguishes allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">from construction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.109.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">// sophisticated version with elems of type T*</span></strong><span class="koboSpan" id="kobo.111.1">
   Vector(size_type n, const_reference init)
      : elems{ static_cast&lt;pointer&gt;(
           std::malloc(n * sizeof(value_type))
        ) }, nelems{ n }, cap{ n } {
      try {
         std::uninitialized_fill(begin(), end(), init);
      } catch (...) {
         std::free(elems);
         throw;
      }
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.112.1">As we can see, we do this work because we decided that </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.114.1"> would be the </span><em class="italic"><span class="koboSpan" id="kobo.115.1">owner</span></em><span class="koboSpan" id="kobo.116.1"> of that memory. </span><span class="koboSpan" id="kobo.116.2">And we are totally allowed to do so! </span><span class="koboSpan" id="kobo.116.3">But what if we made something else</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.117.1"> responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">our memory?</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.119.1">Implicit memory management with a smart pointer</span></h1>
<p><span class="koboSpan" id="kobo.120.1">In C++, the simplest </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.121.1">way to change our </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.123.1"> implementation from one that manually manages memory to one that does so implicitly is through a smart pointer. </span><span class="koboSpan" id="kobo.123.2">The idea here is, essentially, to change the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">elems</span></strong><span class="koboSpan" id="kobo.125.1"> data member of </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.127.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">T*</span></strong><span class="koboSpan" id="kobo.129.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">std::unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">We will look at this from </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">two angles:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.133.1">How does this change impact the naïve version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.135.1">? </span><span class="koboSpan" id="kobo.135.2">As a reminder, our naïve version from </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.137.1"> did not distinguish between objects and raw memory in the underlying storage, and thus only stored objects. </span><span class="koboSpan" id="kobo.137.2">This led to a simpler implementation, but also one that needlessly constructed objects on many occasions and was much slower than the more sophisticated implementation for non-trivially </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">constructible types.</span></span></li>
<li><span class="koboSpan" id="kobo.139.1">How does this change impact the sophisticated version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.141.1"> that avoided the performance trap of constructing unnecessary objects at the cost of a somewhat more </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">complicated implementation?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.143.1">In both cases, we will examine selected member functions that are indicative of the impact of this change. </span><span class="koboSpan" id="kobo.143.2">The full implementations of both the naïve and the sophisticated implementations</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.144.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.146.1"> are available to peruse and use in the GitHub repository associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">this book.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.148.1">Impact on the naïve Vector&lt;T&gt; implementation</span></h2>
<p><span class="koboSpan" id="kobo.149.1">If we were basing our </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.150.1">simplification</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.151.1"> effort on the initial, naïve version of </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.152.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.153.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">elems</span></strong><span class="koboSpan" id="kobo.155.1"> simply pointed to a contiguous sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">T</span></strong><span class="koboSpan" id="kobo.157.1"> objects, this would be rather simple, as we </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">could change:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.159.1">// naïve implementation, explicit memory management</span></strong><span class="koboSpan" id="kobo.160.1">
// declaration of the data members...
</span><strong class="bold"><span class="koboSpan" id="kobo.161.1">pointer elems{};</span></strong><span class="koboSpan" id="kobo.162.1">
size_type nelems{}, cap{};</span></pre> <p><span class="koboSpan" id="kobo.163.1">… </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">to:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.165.1">// naïve implementation, implicit memory management</span></strong><span class="koboSpan" id="kobo.166.1">
// declaration of the data members...
</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">std::unique_ptr&lt;value_type[]&gt; elems;</span></strong><span class="koboSpan" id="kobo.168.1">
size_type nelems{}, cap{};</span></pre> <p><span class="koboSpan" id="kobo.169.1">… and then change the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">begin()</span></strong><span class="koboSpan" id="kobo.171.1"> member functions </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">from this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.173.1">// naïve implementation, explicit memory management</span></strong><span class="koboSpan" id="kobo.174.1">
iterator begin() {
   return </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">elems</span></strong><span class="koboSpan" id="kobo.176.1">; // raw pointer to the memory block
}
const_iterator begin() const {
   return </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">elems</span></strong><span class="koboSpan" id="kobo.178.1">; // raw pointer to the memory block
}</span></pre> <p><span class="koboSpan" id="kobo.179.1">… </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">to this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.181.1">// naïve implementation, implicit memory management</span></strong><span class="koboSpan" id="kobo.182.1">
iterator begin() {
   return </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">elems.get()</span></strong><span class="koboSpan" id="kobo.184.1">; // raw pointer to the beginning
                       // of the underlying memory block
}
const_iterator begin() const {
   return </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">elems.get()</span></strong><span class="koboSpan" id="kobo.186.1">; // likewise
}</span></pre> <p><span class="koboSpan" id="kobo.187.1">Just doing this would be sufficient to significantly simplify the implementation of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.189.1"> as deallocating memory would become implicit. </span><span class="koboSpan" id="kobo.189.2">For example, we could simplify each</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.190.1"> constructor </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.191.1">by removing the exception handling altogether, changing, for example, the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">following implementation:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.193.1">// naïve implementation, explicit memory management</span></strong><span class="koboSpan" id="kobo.194.1">
   Vector(size_type n, const_reference init)
      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {
      try {
         std:: fill(begin(), end(), init);
      } catch (...) {
         delete [] elems;
         throw;
      }
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.195.1">… for this significantly </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">simpler one:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.197.1">// naïve implementation, implicit memory management</span></strong><span class="koboSpan" id="kobo.198.1">
   Vector(size_type n, const_reference init)
      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {
      std:: fill(begin(), end(), init);
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.199.1">The reason for this simplification is </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.201.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.203.1"> object is responsible for the allocated memory, then deleting the array will be done implicitly when the destructor is called, but for a destructor to be called, there needs to be an object to destroy: a </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.205.1"> constructor needs to have succeeded! </span><span class="koboSpan" id="kobo.205.2">That explains why we need to catch whatever exception was thrown, manually delete the array, and re-throw whatever exception was thrown: until the closing brace of a destructor is reached, there is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.207.1"> object to destruct and all resource management has to be </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">done explicitly.</span></span></li>
<li><span class="koboSpan" id="kobo.209.1">On the other hand, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">elems</span></strong><span class="koboSpan" id="kobo.211.1"> is a smart pointer, then it becomes responsible for the pointee as soon as the smart pointer itself has been constructed, and this occurs </span><em class="italic"><span class="koboSpan" id="kobo.212.1">before</span></em><span class="koboSpan" id="kobo.213.1"> the opening brace of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.215.1"> constructor. </span><span class="koboSpan" id="kobo.215.2">This means that once </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">elems</span></strong><span class="koboSpan" id="kobo.217.1"> has been constructed, it </span><em class="italic"><span class="koboSpan" id="kobo.218.1">will</span></em><span class="koboSpan" id="kobo.219.1"> be destructed if an exception leaves the constructor, freeing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.221.1"> object-to-be from the task of destructing the array. </span><span class="koboSpan" id="kobo.221.2">To be clear: when we reach the opening brace of the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.223.1">, the data members of </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">*this</span></strong><span class="koboSpan" id="kobo.225.1"> have been constructed, and for that reason, they will be destructed if an exception is thrown, even if the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">*this</span></strong><span class="koboSpan" id="kobo.227.1"> itself does not conclude. </span><span class="koboSpan" id="kobo.227.2">The object model of C++ is truly wonderful in </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">such situations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.229.1">The more</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.230.1"> astute</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.231.1"> among you, dear readers, will have noticed that even if one was writing code for a company where exceptions are disallowed or frowned upon, the exception-safety we gained from using a smart pointer remains. </span><span class="koboSpan" id="kobo.231.2">We have (discretely) written exception-safe code without writing the words </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">try</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.233.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Other examples of simplification through the introduction of implicit memory management would include move operations and the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.238.1">, which would change </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">from this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.240.1">// naïve implementation, explicit memory management</span></strong><span class="koboSpan" id="kobo.241.1">
   Vector(Vector &amp;&amp;other)
      : elems{ std::exchange(other.elems, nullptr) },
        nelems{ std::exchange(other.nelems, 0) },
        cap{ std::exchange(other.cap, 0) } {
   }
   Vector&amp; operator=(Vector &amp;&amp;other) {
      Vector{ other }.swap(*this);
      return *this;
   }
   ~Vector() {
      delete [] elems;
   }
// ...</span></pre> <p><span class="koboSpan" id="kobo.242.1">… to </span><a id="_idIndexMarker726"/><span class="No-Break"><span class="koboSpan" id="kobo.243.1">simply</span></span><span class="No-Break"><a id="_idIndexMarker727"/></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1"> this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.245.1">// naïve implementation, implicit memory management</span></strong><span class="koboSpan" id="kobo.246.1">
   Vector(Vector&amp;&amp;) = default;
   Vector&amp; operator=(Vector&amp;&amp;) = default;
   ~Vector() = default;
// ...</span></pre> <p><span class="koboSpan" id="kobo.247.1">Making move operations </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">=default</span></strong><span class="koboSpan" id="kobo.249.1"> works because type </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.251.1"> does “the right thing” when moving and transfers ownership of the pointee from the source to </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the destination.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.253.1">Something to be aware of</span></p>
<p class="callout"><span class="koboSpan" id="kobo.254.1">By making the move operations </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">=default</span></strong><span class="koboSpan" id="kobo.256.1">, we induced a slight semantic change in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.258.1"> implementation. </span><span class="koboSpan" id="kobo.258.2">The C++ standard recommends that a moved-from is in a valid yet unspecified state but does not go into detail as to what “valid” means. </span><span class="koboSpan" id="kobo.258.3">Our hand-written move operations restored the moved-from object to the equivalent of a default-constructed </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.260.1"> object, but the “defaulted” one leaves the moved-from object with a null </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">elems</span></strong><span class="koboSpan" id="kobo.262.1"> but with potentially non-zero size and capacity. </span><span class="koboSpan" id="kobo.262.2">This still works in practice as long as user code does not use the moved-from object unless it has first been reassigned to, but it is a semantic change that deserves to </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">be acknowledged.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Yet another interesting simplification would be the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">resize()</span></strong><span class="koboSpan" id="kobo.266.1"> member function. </span><span class="koboSpan" id="kobo.266.2">In </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.267.1">the </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.268.1">original, naïve </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.270.1"> implementation, we had </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.272.1">// naïve implementation, explicit memory management</span></strong><span class="koboSpan" id="kobo.273.1">
   void resize(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = new T[new_cap];
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::move(begin(), end(), p);
      } else try {
         std::copy(begin(), end(), p);
      } catch (...) {
         delete[] p;
         throw;
      }
      delete[] elems;
      elems = p;
      cap = new_cap;
   }</span></pre> <p><span class="koboSpan" id="kobo.274.1">Here, again, we are faced with the possibility of an exception being thrown from the copy assignment of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">T</span></strong><span class="koboSpan" id="kobo.276.1"> object to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">T</span></strong><span class="koboSpan" id="kobo.278.1"> object and need to handle exceptions in order to avoid leaking resources. </span><span class="koboSpan" id="kobo.278.2">Going from explicit resource handling to implicit resource handling, we get </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.280.1">// naïve implementation, implicit memory management</span></strong><span class="koboSpan" id="kobo.281.1">
   void resize(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = std::make_unique&lt;value_type[]&gt;(new_cap);
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::move(begin(), end(), p.get());
      } else {
         std::copy(begin(), end(), p.get());
      }
      elems.reset(p.release());
      cap = new_cap;
   }</span></pre> <p><span class="koboSpan" id="kobo.282.1">As you can see, the</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.283.1"> entire </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.284.1">exception handling code is gone. </span><span class="koboSpan" id="kobo.284.2">Object </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">p</span></strong><span class="koboSpan" id="kobo.286.1"> owns the new array and will destroy it when the function concludes execution. </span><span class="koboSpan" id="kobo.286.2">Once the copies (or the moves, depending on whether the move assignment of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">T</span></strong><span class="koboSpan" id="kobo.288.1"> is or is not marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">noexcept</span></strong><span class="koboSpan" id="kobo.290.1">) are completed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">elems</span></strong><span class="koboSpan" id="kobo.292.1"> lets go of the previously owned array through </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">reset()</span></strong><span class="koboSpan" id="kobo.294.1"> (destroying it at the same time) and “steals” ownership of the array released by </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">p</span></strong><span class="koboSpan" id="kobo.296.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">release()</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">Note that writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">elems = std::move(p);</span></strong><span class="koboSpan" id="kobo.300.1"> would have had a </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">similar effect.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Applying this simplification process throughout </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.304.1">, source code gradually shrinks and, on a container like the naïve version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.306.1"> that only contains objects, no raw memory block at the end of the underlying storage, we can save almost 25% of the number </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.307.1">of source code lines (going from roughly 180 lines to 140 lines for this academic implementation). </span><span class="koboSpan" id="kobo.307.2">Try it and see </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">for yourself!</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.309.1">Impact on the sophisticated Vector&lt;T&gt; implementation</span></h2>
<p><span class="koboSpan" id="kobo.310.1">Applying the</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.311.1"> same</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.312.1"> technique to the more sophisticated </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.314.1"> will require a bit more work as the default behavior of the destructor of an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">std::unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.316.1"> will be to apply </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">operator delete[]</span></strong><span class="koboSpan" id="kobo.318.1"> to the pointer it owns. </span><span class="koboSpan" id="kobo.318.2">As we know at this point, our sophisticated implementation can be conceptualized as being made of two (potentially empty) “sections”: an initial section made of </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">T</span></strong><span class="koboSpan" id="kobo.320.1"> objects manually placed into raw memory followed by another section of uninitialized, raw memory devoid of objects. </span><span class="koboSpan" id="kobo.320.2">As such, we need to handle each “section” in a </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">different manner.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">We will still use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">std::unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.324.1"> object to manage the memory, but we will need to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">custom deleter</span></strong><span class="koboSpan" id="kobo.326.1"> object (something we discussed in </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.328.1"> and in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.329.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.330.1">) to take into account the specifics of our implementation. </span><span class="koboSpan" id="kobo.330.2">This object will need knowledge of the runtime state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.332.1"> object it will accompany since it will have to know where each “section” of the underlying storage starts as well as where it ends, and that is something that changes as the code </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">is executing.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">The first important point of this implementation, and this is a point that has been recurring but that we probably did not insist upon enough, is that we want our implementations to expose the same interface to client code, regardless of implementation variations. </span><span class="koboSpan" id="kobo.334.2">This is sometimes impossible or unreasonable to achieve, but it is nonetheless a meaningful and worthwhile target. </span><span class="koboSpan" id="kobo.334.3">This includes our choice of internal public types: for example, the fact that we use a smart pointer to manage the underlying memory does not change the fact that a pointer to an element is </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">T*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
// ...
</span><span class="koboSpan" id="kobo.338.2">template &lt;class T&gt;
class Vector {
public:
   using value_type = T;
   using size_type = std::size_t;
   using pointer = T*;
   using const_pointer = const T*;
   using reference = T&amp;;
   using const_reference = const T&amp;;
   // ...</span></pre> <p><span class="koboSpan" id="kobo.339.1">Now, since we want to define </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">elems</span></strong><span class="koboSpan" id="kobo.341.1"> as being a smart pointer that owns and manages the underlying storage instead of being a raw pointer, we will need to define the custom deleter that will be used by that </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">smart pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">An important aspect of this problem is that the custom deleter will need to know the state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.345.1"> object to know what part of the underlying storage holds objects. </span><span class="koboSpan" id="kobo.345.2">For this reason, the custom deleter of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">std::unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.347.1"> will be stateful and store a reference named </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">source</span></strong><span class="koboSpan" id="kobo.349.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.351.1"> object. </span><span class="koboSpan" id="kobo.351.2">Through </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">source</span></strong><span class="koboSpan" id="kobo.353.1">, The function call operator of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">deleter</span></strong><span class="koboSpan" id="kobo.355.1"> object will have access to the sequence of objects in the container (the half-open sequence from </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">source.begin()</span></strong><span class="koboSpan" id="kobo.357.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">source.end()</span></strong><span class="koboSpan" id="kobo.359.1">) and will</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.360.1"> be able to </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">destroy()</span></strong><span class="koboSpan" id="kobo.362.1"> these objects </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.363.1">before freeing the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">underlying storage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
   // ...
</span><span class="koboSpan" id="kobo.365.2">private:
</span><strong class="bold"><span class="koboSpan" id="kobo.366.1">   struct deleter {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.367.1">      Vector&amp; source;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.368.1">      void operator()(value_type* p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.369.1">         std::destroy(std::begin(source),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.370.1">                      std::end(source));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.371.1">         std::free(static_cast&lt;void*&gt;(p));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.372.1">      }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.373.1">   };</span></strong><span class="koboSpan" id="kobo.374.1">
   std::unique_ptr&lt;value_type[], </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">deleter</span></strong><span class="koboSpan" id="kobo.376.1">&gt; elems;
   size_type nelems{},
             cap{};
   // ...</span></pre> <p><span class="koboSpan" id="kobo.377.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">elems</span></strong><span class="koboSpan" id="kobo.379.1"> data member knows that the type of the custom deleter will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">deleter</span></strong><span class="koboSpan" id="kobo.381.1">, but the actual object that will play the role of deleter will have to know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.383.1"> object it will interact with. </span><span class="koboSpan" id="kobo.383.2">The constructors of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.385.1"> will be responsible for providing this information, and we will need to be careful with the ways in which we implement our move operations in order to make sure we do not transfer the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">deleter</span></strong><span class="koboSpan" id="kobo.387.1"> object’s state and make our </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">code incoherent.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">As mentioned with the naïve version, we need to adapt the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">begin()</span></strong><span class="koboSpan" id="kobo.391.1"> member functions to take into account the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">elems</span></strong><span class="koboSpan" id="kobo.393.1"> is a smart pointer but that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">iterator</span></strong><span class="koboSpan" id="kobo.395.1"> interface relies on </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">raw pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
   // ...
</span><span class="koboSpan" id="kobo.397.2">   using iterator = pointer;
   using const_iterator = const_pointer;
</span><strong class="bold"><span class="koboSpan" id="kobo.398.1">   iterator begin() { return elems.get(); }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.399.1">   const_iterator begin() const { return elems.get(); }</span></strong><span class="koboSpan" id="kobo.400.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.401.1">Our constructors</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.402.1"> will </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.403.1">need to adapt to the fact that we have a custom deleter that will clean up if anything bad happens, or if the program concludes normally. </span><span class="koboSpan" id="kobo.403.2">Three examples of </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Vector&lt;T&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.405.1">constructors follow:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
   // ...
</span><span class="koboSpan" id="kobo.406.2">   constexpr Vector()
      : elems{ nullptr, </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">deleter { *this }</span></strong><span class="koboSpan" id="kobo.408.1"> } {
   }
   Vector(size_type n, const_reference init)
      : elems{ static_cast&lt;pointer&gt;(
           std::malloc(n * sizeof(value_type))
        ), </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">deleter{ *this }</span></strong><span class="koboSpan" id="kobo.410.1">
      } {
      std::uninitialized_fill(begin(), begin() + n, init);
      nelems = cap = n;
   }
   Vector(Vector&amp;&amp; other) noexcept
      : elems{ std::exchange(
           other.elems.release()), deleter{ *this }
        },
        nelems{ std::exchange(other.nelems, 0) },
        cap{ std::exchange(other.cap, 0) } {
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.411.1">Please note that we are not expressing the move constructor with </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">=default</span></strong><span class="koboSpan" id="kobo.413.1"> in this case as we do not want to transfer the custom deleter, our implementation having associated this object with a specific </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Vector&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">A small note is in order here: we are passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">*this</span></strong><span class="koboSpan" id="kobo.418.1"> to the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">deleter</span></strong><span class="koboSpan" id="kobo.420.1"> object, but we are doing so </span><em class="italic"><span class="koboSpan" id="kobo.421.1">before</span></em><span class="koboSpan" id="kobo.422.1"> the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">*this</span></strong><span class="koboSpan" id="kobo.424.1"> has been completed, so </span><em class="italic"><span class="koboSpan" id="kobo.425.1">anything</span></em><span class="koboSpan" id="kobo.426.1"> done by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">deleter</span></strong><span class="koboSpan" id="kobo.428.1"> object before the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">*this</span></strong><span class="koboSpan" id="kobo.430.1"> concludes (before the closing brace of its constructor) deserves care </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">and attention.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">In our case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">deleter</span></strong><span class="koboSpan" id="kobo.434.1"> object will come into play if the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">elems</span></strong><span class="koboSpan" id="kobo.436.1"> comes into play, which will happen if the constructor of an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">T</span></strong><span class="koboSpan" id="kobo.438.1"> throws. </span><span class="koboSpan" id="kobo.438.2">We need to make sure that the values of the data members of </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">*this</span></strong><span class="koboSpan" id="kobo.440.1"> are coherent whenever there is a possibility that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">deleter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.442.1">object intervenes.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">In our </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.444.1">case, since</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.445.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">begin()</span></strong><span class="koboSpan" id="kobo.447.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">end()</span></strong><span class="koboSpan" id="kobo.449.1"> member functions return iterators that define a half-open range of objects and, as we now know, </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">std::uninitialized_fill()</span></strong><span class="koboSpan" id="kobo.451.1"> calls the constructors and (if an exception is thrown) destroys the objects that have been constructed, we have to make sure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">nelems==0</span></strong><span class="koboSpan" id="kobo.453.1"> until all of the objects have been constructed. </span><span class="koboSpan" id="kobo.453.2">Note that we defined the range to initialize as </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">begin()</span></strong><span class="koboSpan" id="kobo.455.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">begin()+n</span></strong><span class="koboSpan" id="kobo.457.1">, and waited until after the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">std::uninitialized_fill()</span></strong><span class="koboSpan" id="kobo.459.1"> to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">nelems</span></strong><span class="koboSpan" id="kobo.461.1">: this way, </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">begin()==end()</span></strong><span class="koboSpan" id="kobo.463.1"> if an exception is thrown, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">deleter</span></strong><span class="koboSpan" id="kobo.465.1"> object will not try to </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">destruct “non-objects.”</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">Other constructors of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.469.1"> are likewise simplified; we will not show them here so consider them as not-so-dreaded “exercises left to </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">the reader.”</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">The simplification of </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.473.1"> is made evident with some of the special member functions that now require little or no effort on our part. </span><span class="koboSpan" id="kobo.473.2">Of note in this regard is the destructor, which can now be defaulted; as mentioned with the move constructor earlier in this section, we do not default the move assignment to avoid transferring the custom deleter’s </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.474.1">internal </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.475.1">state, as can be seen in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">code excerpt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
   // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.478.1">   ~Vector() = default;</span></strong><span class="koboSpan" id="kobo.479.1">
   void swap(Vector&amp; other) noexcept {
      using std::swap;
</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">      swap(elems, other.elems);</span></strong><span class="koboSpan" id="kobo.481.1">
      swap(nelems, other.nelems);
      swap(cap, other.cap);
   }
   Vector&amp; operator=(const Vector&amp; other) {
      Vector{ other }.swap(*this);
      return *this;
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.482.1">   Vector&amp; operator=(Vector&amp;&amp; other) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.483.1">      Vector{ std::move(other) }.swap(*this);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.484.1">      return *this;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.485.1">   }</span></strong><span class="koboSpan" id="kobo.486.1">
   reference operator[](size_type n) { return </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">elems[n]</span></strong><span class="koboSpan" id="kobo.488.1">; }
   const_reference operator[](size_type n) const {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.489.1">elems[n]</span></strong><span class="koboSpan" id="kobo.490.1">;
   }</span></pre> <p><span class="koboSpan" id="kobo.491.1">Member functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">swap()</span></strong><span class="koboSpan" id="kobo.493.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">operator[]</span></strong><span class="koboSpan" id="kobo.495.1"> have been shown to make it clear that </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">std::unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.497.1"> behaves in many ways like a “regular” array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">T</span></strong><span class="koboSpan" id="kobo.499.1"> objects. </span><span class="koboSpan" id="kobo.499.2">Many other member functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.501.1"> remain unchanged, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">front()</span></strong><span class="koboSpan" id="kobo.503.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">back()</span></strong><span class="koboSpan" id="kobo.505.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">operator==()</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">operator!=()</span></strong><span class="koboSpan" id="kobo.509.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">grow()</span></strong><span class="koboSpan" id="kobo.511.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">push_back()</span></strong><span class="koboSpan" id="kobo.513.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">emplace_back()</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">Please refer to </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.516.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.517.1"> for details on </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">these functions.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">reserve()</span></strong><span class="koboSpan" id="kobo.521.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">resize()</span></strong><span class="koboSpan" id="kobo.523.1"> functions can also be simplified through the use of smart pointers, as we can get rid of explicit exception management and yet remain exception-safe since </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">std::unique_ptr&lt;T[]&gt;</span></strong><span class="koboSpan" id="kobo.525.1"> is an </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">RAII</span></strong><span class="koboSpan" id="kobo.527.1"> type </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.528.1">and handles memory </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">reserve()</span></strong><span class="koboSpan" id="kobo.532.1">, we now use smart pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">p</span></strong><span class="koboSpan" id="kobo.534.1"> to hold the allocated memory, then either </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">move()</span></strong><span class="koboSpan" id="kobo.536.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">copy()</span></strong><span class="koboSpan" id="kobo.538.1"> the objects from </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">elems</span></strong><span class="koboSpan" id="kobo.540.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">p</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">Once this is done, we </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">destroy()</span></strong><span class="koboSpan" id="kobo.544.1"> the objects left in </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">elems</span></strong><span class="koboSpan" id="kobo.546.1">, after which </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">p</span></strong><span class="koboSpan" id="kobo.548.1"> relinquishes its pointer and transfers it</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.549.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">elems</span></strong><span class="koboSpan" id="kobo.551.1">, and</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.552.1"> the only thing left to do is to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">container’s capacity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
   // ...
</span><span class="koboSpan" id="kobo.554.2">   void reserve(size_type new_cap) {
      if (new_cap &lt;= capacity()) return;
      std::unique_ptr&lt;value_type[]&gt; p{
         static_cast&lt;pointer&gt;(
            std::malloc(new_cap * sizeof(T))
         )
      };
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p.get());
      } else {
         std::uninitialized_copy(begin(), end(), p.get());
      }
      std::destroy(begin(), end());
      elems.reset(p.release());
      cap = new_cap;
   }</span></pre> <p><span class="koboSpan" id="kobo.555.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">resize()</span></strong><span class="koboSpan" id="kobo.557.1">, we now use smart pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">p</span></strong><span class="koboSpan" id="kobo.559.1"> to hold the allocated memory, then either </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">move()</span></strong><span class="koboSpan" id="kobo.561.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">copy()</span></strong><span class="koboSpan" id="kobo.563.1"> the objects from </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">elems</span></strong><span class="koboSpan" id="kobo.565.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">p</span></strong><span class="koboSpan" id="kobo.567.1"> and construct default </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">T</span></strong><span class="koboSpan" id="kobo.569.1"> objects in the remaining part of the memory block. </span><span class="koboSpan" id="kobo.569.2">Once this is done, we </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">destroy()</span></strong><span class="koboSpan" id="kobo.571.1"> the objects left in </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">elems</span></strong><span class="koboSpan" id="kobo.573.1">, after which </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">p</span></strong><span class="koboSpan" id="kobo.575.1"> relinquishes its pointer and transfers it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">elems</span></strong><span class="koboSpan" id="kobo.577.1">, and the only </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.578.1">thing </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.579.1">left to do is to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">container’s capacity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
   // ...
</span><span class="koboSpan" id="kobo.581.2">   void resize(size_type new_cap) {
      if (new_cap &lt;= capacity()) return;
      std::unique_ptr&lt;value_type[]&gt; p =
         static_cast&lt;pointer&gt;(
            std::malloc(new_cap * sizeof(T))
         );
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p.get());
      } else {
         std::uninitialized_copy(begin(), end(), p.get());
      }
      std::uninitialized_fill(
         p.get() + size(), p.get() + new_cap, value_type{}
      );
      std::destroy(begin(), end());
      elems.reset(p.release());
      nelems = cap = new_cap;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.582.1">The magic of it all, or so to speak, is that our other member functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">insert()</span></strong><span class="koboSpan" id="kobo.584.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">erase()</span></strong><span class="koboSpan" id="kobo.586.1"> are built on top of basic abstractions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">reserve()</span></strong><span class="koboSpan" id="kobo.588.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">begin()</span></strong><span class="koboSpan" id="kobo.590.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">end()</span></strong><span class="koboSpan" id="kobo.592.1">, and so on, which means they do not have to be modified to take into account this </span><a id="_idIndexMarker748"/><span class="No-Break"><span class="koboSpan" id="kobo.593.1">representational </span></span><span class="No-Break"><a id="_idIndexMarker749"/></span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">change.</span></span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.595.1">Consequences of this redesign</span></h1>
<p><span class="koboSpan" id="kobo.596.1">What are the consequences </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.597.1">of this “redesign” of sorts? </span><span class="koboSpan" id="kobo.597.2">They have been </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.598.1">mentioned along the way, but </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">let’s summarize:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.600.1">For user code, consequences are essentially none: an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.602.1"> occupies the same space in memory with the implicit memory management implementation and almost the same space with the explicit memory management implementation (where the custom deleter is stateful), and each exposes the same </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">public interface.</span></span></li>
<li><span class="koboSpan" id="kobo.604.1">There are essentially no speed costs either, for reasons explained in </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.605.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.606.1">: in code compiled with optimization levels other than the basic, made-for-debugging ones, going through </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.608.1"> will, due to function call inlining, lead to code that is as efficient as going through </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">T*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.612.1">The implementation is made significantly simpler: fewer instructions, no explicit exception handling code, more member functions that can </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">be defaulted…</span></span></li>
<li><span class="koboSpan" id="kobo.614.1">An important aspect of this implicit memory management implementation is that it is exception-safe even in the absence of explicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">try</span></strong><span class="koboSpan" id="kobo.616.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">catch</span></strong><span class="koboSpan" id="kobo.618.1"> blocks. </span><span class="koboSpan" id="kobo.618.2">This can make a difference in many situations: for example, you might be in a situation where exceptions are not allowed but find yourself using a library where exceptions are a possibility… or can simply call </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">operator new()</span></strong><span class="koboSpan" id="kobo.620.1"> in a situation where memory is constrained. </span><span class="koboSpan" id="kobo.620.2">Our implementation with implicit memory management would be safe under such circumstances, but an implementation taking a manual memory management approach with no exception handling code would not be </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">so “lucky.”</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.622.1">The effort involved in implementing the custom deleter seems to be a sound investment with </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.624.1">. </span><span class="koboSpan" id="kobo.624.2">Now, you</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.625.1"> might wonder whether the situation is similar with </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.626.1">node-based containers, so we will explore this question by revisiting the naïve </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.628.1"> implementation from </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.629.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.630.1">.</span></span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.631.1">Generalizing to ForwardList&lt;T&gt;?</span></h1>
<p><span class="koboSpan" id="kobo.632.1">We now know that we can </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.633.1">adapt the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.635.1">, transforming it from an explicit memory management model to an implicit one, and that so doing has lots of advantages. </span><span class="koboSpan" id="kobo.635.2">It is tempting to do the same with other containers, but before embarking on such an adventure, it might be wise to analyze the problem </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">a little.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">We implemented a node-based container with explicit memory management named </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.639.1"> in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.640.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.641.1">. </span><span class="koboSpan" id="kobo.641.2">What would be the impact of trying to change the implementation of this container to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">more implicit?</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.643.1">Attempt - making each node responsible for its successor</span></h2>
<p><span class="koboSpan" id="kobo.644.1">In our exploration of ways in which we could try to make memory management in a node-based container more implicit, one possible approach could be to change the definition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">ForwardList&lt;T&gt;::Node</span></strong><span class="koboSpan" id="kobo.646.1"> such that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">next</span></strong><span class="koboSpan" id="kobo.648.1"> data member becomes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">std::unique_ptr&lt;Node&gt;</span></strong><span class="koboSpan" id="kobo.650.1"> instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Node*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">As a synopsis, we would get </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.656.1">
template &lt;class T&gt;
class ForwardList {
public:
   // ...
</span><span class="koboSpan" id="kobo.656.2">private:
   struct Node {
      value_type value;
      </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">std::unique_ptr&lt;Node&gt; next; // &lt;--</span></strong><span class="koboSpan" id="kobo.658.1">
      Node(const_reference value) : value{ value } {
      }
      Node(value_type&amp;&amp; value) : value{ std::move(value) }{
      }
   };
   </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">Node* head{};</span></strong><span class="koboSpan" id="kobo.660.1">
   size_type nelems{};
   // ...</span></pre> <p><span class="koboSpan" id="kobo.661.1">This might seem like an</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.662.1"> improvement at first glance, since it would simplify the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.664.1"> down to </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
   // ...
</span><span class="koboSpan" id="kobo.666.2">   ~ForwardList() {
      </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">delete head; // &lt;-- lots of work starts here!</span></strong><span class="koboSpan" id="kobo.668.1">
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.669.1">This simplification would induce a kind of “domino effect”: since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">next</span></strong><span class="koboSpan" id="kobo.671.1"> data member of a node becomes the owner of its successor node in the list, and since this is true for every node in the chain (except for </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">head</span></strong><span class="koboSpan" id="kobo.673.1"> itself), then destructing the first node ensures the destruction of its successor, and of that successor’s successor, and </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">This apparent simplification hides a tricky fact: when calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">delete head;</span></strong><span class="koboSpan" id="kobo.677.1"> under this implementation, </span><em class="italic"><span class="koboSpan" id="kobo.678.1">we might be provoking a stack overflow</span></em><span class="koboSpan" id="kobo.679.1">. </span><span class="koboSpan" id="kobo.679.2">Indeed, we replaced a loop that applied </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">delete</span></strong><span class="koboSpan" id="kobo.681.1"> on each node in succession with something that’s essentially a recursive call, meaning that the impact on stack usage changed from something that was fixed to something that is proportional to the number of nodes in the list. </span><span class="koboSpan" id="kobo.681.2">That’s unpleasant </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">news indeed!</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">At this point, dear reader, maybe you are thinking “Well, I was only going to use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.685.1"> type for small lists anyway, so I’m not worried.” </span><span class="koboSpan" id="kobo.685.2">If that expresses your line of thinking, maybe we should explore other implications of this implementation decision in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">ForwardList&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.687.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">One such implication is that iterators get a little bit more complicated: we do not want an iterator over nodes to be the sole owner of the node it is traversing. </span><span class="koboSpan" id="kobo.688.2">That would be destructive indeed, as nodes would be destroyed as we are iterating over the list. </span><span class="koboSpan" id="kobo.688.3">For this reason, </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">ForwardList&lt;T&gt;::Node&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.690.1"> (where </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">U</span></strong><span class="koboSpan" id="kobo.692.1"> is either </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">T</span></strong><span class="koboSpan" id="kobo.694.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">const T</span></strong><span class="koboSpan" id="kobo.696.1">) would still have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">T*</span></strong><span class="koboSpan" id="kobo.698.1"> data member, meaning that </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">operator++()</span></strong><span class="koboSpan" id="kobo.700.1">, for example, would need to obtain the underlying </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.701.1">pointer of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.703.1"> data member in </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">each node:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
   // ...
</span><span class="koboSpan" id="kobo.705.2">   template &lt;class U&gt; class Iterator {
   public:
      // ...
</span><span class="koboSpan" id="kobo.705.3">   private:
      </span><strong class="bold"><span class="koboSpan" id="kobo.706.1">Node* cur{};</span></strong><span class="koboSpan" id="kobo.707.1">
   public:
      // ...
</span><span class="koboSpan" id="kobo.707.2">      Iterator&amp; operator++() {
         </span><strong class="bold"><span class="koboSpan" id="kobo.708.1">cur = cur-&gt;next.get(); // &lt;--</span></strong><span class="koboSpan" id="kobo.709.1">
         return *this;
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.710.1">That’s a slight complexity increase, but nothing that is impossible </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">to manage.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">In </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.713.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.714.1">, we made most of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.716.1"> constructors converge towards the more general sequence constructor that takes a pair of forward iterators of some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">It</span></strong><span class="koboSpan" id="kobo.718.1"> as arguments. </span><span class="koboSpan" id="kobo.718.2">This constructor would become in part more complex, as chaining nodes would now require knowledge that we are using smart pointers inside each node, but cleanup in case an exception is thrown would only require deleting the head node and letting </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.719.1">the aforementioned “domino effect” </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">take place:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.721.1">
   // ...
</span><span class="koboSpan" id="kobo.721.2">   template &lt;std::forward_iterator It&gt;
   ForwardList(It b, It e) {
      try {
         if (b == e) return;
         </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">head = new Node{ *b };</span></strong><span class="koboSpan" id="kobo.723.1">
         auto q = head;
         ++nelems;
         for (++b; b != e; ++b) {
            </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">q-&gt;next = std::make_unique&lt;Node&gt;(*b); // &lt;--</span></strong><span class="koboSpan" id="kobo.725.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.726.1">q = q-&gt;next.get(); // &lt;--</span></strong><span class="koboSpan" id="kobo.727.1">
            ++nelems;
         }
      } catch (...) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.728.1">delete head; // &lt;--</span></strong><span class="koboSpan" id="kobo.729.1">
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.730.1">Most member functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.732.1"> would remain unchanged. </span><span class="koboSpan" id="kobo.732.2">There would be slight adjustments to such things as </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">push_front()</span></strong><span class="koboSpan" id="kobo.734.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.736.1">
   // ...
</span><span class="koboSpan" id="kobo.736.2">   void push_front(const_reference val) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.737.1">auto p = new Node{ val };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.738.1">      p-&gt;next = std::unique_ptr&lt;Node&gt;{ head }; // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.739.1">      head = p;</span></strong><span class="koboSpan" id="kobo.740.1">
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">auto p = new Node{ std::move(val) };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.742.1">      p-&gt;next = std::unique_ptr&lt;Node&gt;{ head }; // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.743.1">      head = p;</span></strong><span class="koboSpan" id="kobo.744.1">
      ++nelems;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.745.1">As can be seen, we</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.746.1"> need to distinguish code that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">head</span></strong><span class="koboSpan" id="kobo.748.1"> data member from code that uses the other nodes in the chain. </span><span class="koboSpan" id="kobo.748.2">Similar adjustments would apply to any member function that modifies the structure of the list, including, notably, insertions </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">and suppressions.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">A more interesting, and probably more enlightening, member function would be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">insert_after()</span></strong><span class="koboSpan" id="kobo.752.1"> member function that inserts one element after a given iterator in the list. </span><span class="koboSpan" id="kobo.752.2">Let’s look at this function </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">in detail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.754.1">
   // ...
</span><span class="koboSpan" id="kobo.754.2">   iterator
      insert_after(iterator pos, const_reference value) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">auto p = std::make_unique&lt;Node&gt;(value); // &lt;-- A</span></strong><span class="koboSpan" id="kobo.756.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.757.1">p-&gt;next.reset(pos.cur-&gt;next.get()); // &lt;-- B</span></strong><span class="koboSpan" id="kobo.758.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.759.1">pos.cur-&gt;next.release(); // &lt;-- C</span></strong><span class="koboSpan" id="kobo.760.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">pos.cur-&gt;next.reset(p.get()); // &lt;-- D</span></strong><span class="koboSpan" id="kobo.762.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">p.release(); // &lt;-- E</span></strong><span class="koboSpan" id="kobo.764.1">
      ++nelems;
      </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">return { pos.cur-&gt;next.get() }; // &lt;-- F</span></strong><span class="koboSpan" id="kobo.766.1">
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.767.1">Hum, that’s quite a lot of updated text! </span><span class="koboSpan" id="kobo.767.2">How did this function get so complicated? </span><span class="koboSpan" id="kobo.767.3">Looking at the “lettered” comments, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.769.1">On line </span><em class="italic"><span class="koboSpan" id="kobo.770.1">A</span></em><span class="koboSpan" id="kobo.771.1">, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">std::unique_ptr&lt;Node&gt;</span></strong><span class="koboSpan" id="kobo.773.1"> object named </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">p</span></strong><span class="koboSpan" id="kobo.775.1"> for the value to be inserted. </span><span class="koboSpan" id="kobo.775.2">We know the newly created node will not be the first node in the list since the function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">insert_after()</span></strong><span class="koboSpan" id="kobo.777.1">, and requires an iterator to an existing “before” node (named </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">pos</span></strong><span class="koboSpan" id="kobo.779.1"> here), so that makes sense. </span><span class="koboSpan" id="kobo.779.2">For the same reason, we know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">pos</span></strong><span class="koboSpan" id="kobo.781.1"> is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">end()</span></strong><span class="koboSpan" id="kobo.783.1">, which, by definition, does not point to a valid node in </span><a id="_idIndexMarker759"/><span class="No-Break"><span class="koboSpan" id="kobo.784.1">our container.</span></span></li>
<li><span class="koboSpan" id="kobo.785.1">On line </span><em class="italic"><span class="koboSpan" id="kobo.786.1">B</span></em><span class="koboSpan" id="kobo.787.1">, we do what is required to make the successor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">p</span></strong><span class="koboSpan" id="kobo.789.1"> the successor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">pos</span></strong><span class="koboSpan" id="kobo.791.1">. </span><span class="koboSpan" id="kobo.791.2">That requires some care since </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">pos.cur-&gt;next</span></strong><span class="koboSpan" id="kobo.793.1"> is guaranteed to be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">std::unique_ptr&lt;Node&gt;</span></strong><span class="koboSpan" id="kobo.795.1"> (it obviously cannot be </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">head</span></strong><span class="koboSpan" id="kobo.797.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">pos.cur</span></strong><span class="koboSpan" id="kobo.799.1"> is “before” </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">pos.cur-&gt;next</span></strong><span class="koboSpan" id="kobo.801.1">) and we made </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">p</span></strong><span class="koboSpan" id="kobo.803.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">std::unique_ptr&lt;Node&gt;</span></strong><span class="koboSpan" id="kobo.805.1">. </span><span class="koboSpan" id="kobo.805.2">We are displacing responsibility over the successor node of </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">pos.cur</span></strong><span class="koboSpan" id="kobo.807.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">p-&gt;next</span></strong><span class="koboSpan" id="kobo.809.1">, effectively inserting </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">pos-&gt;next</span></strong><span class="koboSpan" id="kobo.811.1"> after </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">p</span></strong><span class="koboSpan" id="kobo.813.1"> (albeit in a </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">complicated way).</span></span></li>
<li><span class="koboSpan" id="kobo.815.1">On line </span><em class="italic"><span class="koboSpan" id="kobo.816.1">C</span></em><span class="koboSpan" id="kobo.817.1">, we are ensuring that </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">pos.cur</span></strong><span class="koboSpan" id="kobo.819.1"> relinquishes its responsibility over </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">pos.cur-&gt;next</span></strong><span class="koboSpan" id="kobo.821.1">. </span><span class="koboSpan" id="kobo.821.2">This is important since, if we did not do so, then replacing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">std::unique_ptr&lt;Node&gt;</span></strong><span class="koboSpan" id="kobo.823.1"> would destroy the pointee. </span><span class="koboSpan" id="kobo.823.2">Line </span><em class="italic"><span class="koboSpan" id="kobo.824.1">B</span></em><span class="koboSpan" id="kobo.825.1"> ensured that </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">pos.cur-&gt;next</span></strong><span class="koboSpan" id="kobo.827.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">p-&gt;next</span></strong><span class="koboSpan" id="kobo.829.1"> would lead to the same object, which would have been disastrous had we stopped there (two objects responsible for the same pointee is a semantic problem we do </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">not need).</span></span></li>
<li><span class="koboSpan" id="kobo.831.1">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">pos.cur-&gt;next</span></strong><span class="koboSpan" id="kobo.833.1"> has been disconnected, we move to line </span><em class="italic"><span class="koboSpan" id="kobo.834.1">D</span></em><span class="koboSpan" id="kobo.835.1"> where we make it point to the raw pointer underneath </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">p</span></strong><span class="koboSpan" id="kobo.837.1">. </span><span class="koboSpan" id="kobo.837.2">This would, again, lead to a shared responsibility over a </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">Node</span></strong><span class="koboSpan" id="kobo.839.1">, so we continue with line </span><em class="italic"><span class="koboSpan" id="kobo.840.1">E</span></em><span class="koboSpan" id="kobo.841.1"> where we disconnect </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">p</span></strong><span class="koboSpan" id="kobo.843.1"> from its </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">underlying pointer.</span></span></li>
<li><span class="koboSpan" id="kobo.845.1">Line </span><em class="italic"><span class="koboSpan" id="kobo.846.1">F</span></em><span class="koboSpan" id="kobo.847.1"> concludes the work in this function by returning the expected iterator to a raw (thus </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">non-owning) pointer.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.849.1">That is… complicated. </span><span class="koboSpan" id="kobo.849.2">The main reason why this is complicated is that most of the effort in this function is the transfer of ownership. </span><span class="koboSpan" id="kobo.849.3">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.851.1"> object represents sole ownership over a </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">T*</span></strong><span class="koboSpan" id="kobo.853.1">, after all, and in a linked list, each and every insertion or suppression requires moving pointers around, thus transferring ownership between nodes. </span><span class="koboSpan" id="kobo.853.2">We simplified an occasional situation (deletion of the nodes) by complicating most of</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.854.1"> the operations in our type. </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">That’s… sad.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.856.1">On meaning and responsibility semantics</span></p>
<p class="callout"><span class="koboSpan" id="kobo.857.1">Smart pointers are all about encoding meaning and responsibility in the type system. </span><span class="koboSpan" id="kobo.857.2">Simplifying user code is important, but it’s not the main point of these types. </span><span class="koboSpan" id="kobo.857.3">In a </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.859.1">object, the real owner of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">T</span></strong><span class="koboSpan" id="kobo.861.1"> objects is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.863.1"> object, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">ForwardList&lt;T&gt;::Node&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.865.1"> objects are (from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.867.1"> object’s perspective) essentially a storage facility. </span><span class="koboSpan" id="kobo.867.2">Trying to change this can be made to work, but the ensuing complexity is an indication that </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">something’s suspicious.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.869.1">When writing a class, especially a container class, it’s essential that we have a clear view of the role intended for each type. </span><span class="koboSpan" id="kobo.869.2">We know that iterators are non-owning by nature (we could, however, envision </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.871.1"> objects that co-own the pointee in some use cases). </span><span class="koboSpan" id="kobo.871.2">As far as containers and their underlying representation goes, the important point is that the responsibilities of each type need to be clear if our design is going to </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">be manageable.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">Okay, so making a node responsible for its successor did not work. </span><span class="koboSpan" id="kobo.873.2">Would simply making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">head</span></strong><span class="koboSpan" id="kobo.875.1"> member of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.877.1"> object responsible for the other nodes in the list make our </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">lives better?</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.879.1">Attempt: making the head pointer responsible for the other nodes</span></h2>
<p><span class="koboSpan" id="kobo.880.1">As seen in the previous section, making each node responsible for its successor is semantically incorrect. </span><span class="koboSpan" id="kobo.880.2">It leads to complex, involved, and error-prone code, and the aspects of the implementation that are simplified by this transformation are mostly outweighed by the added complexity in </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">other places.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">Maybe just making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">head</span></strong><span class="koboSpan" id="kobo.884.1"> node a </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">std::unique_ptr&lt;Node&gt;</span></strong><span class="koboSpan" id="kobo.886.1"> object with a custom deleter</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.887.1"> responsible for deleting the entire list would be beneficial? </span><span class="koboSpan" id="kobo.887.2">Well, we can assuredly try </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">this approach.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">As a synopsis, we would now get </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
template &lt;class T&gt;
class ForwardList {
   // ...
</span><span class="koboSpan" id="kobo.891.2">   struct Node {
      value_type value;
      </span><strong class="bold"><span class="koboSpan" id="kobo.892.1">Node* next = nullptr;</span></strong><span class="koboSpan" id="kobo.893.1">
      Node(const_reference value) : value{ value } {
      }
      Node(value_type&amp;&amp; value) : value{ std::move(value) }{
      }
   };
</span><strong class="bold"><span class="koboSpan" id="kobo.894.1">   struct deleter { // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.895.1">      void operator()(Node* p) const {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.896.1">         while (p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.897.1">            Node* q = p-&gt;next;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.898.1">            delete p;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.899.1">            p = q;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.900.1">         }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.901.1">      }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.902.1">   };</span></strong><span class="koboSpan" id="kobo.903.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.904.1">std::unique_ptr&lt;Node, deleter&gt; head;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.905.1">// ...</span></strong></pre> <p><span class="koboSpan" id="kobo.906.1">We now have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.908.1"> type that, when an object of that type is destroyed, implicitly ensures that the nodes in the list are destructed. </span><span class="koboSpan" id="kobo.908.2">The entire list remains built from raw pointers, such that nodes are not responsible for memory management, which is probably an upgrade from the </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">previous attempt.</span></span></p>
<p><span class="koboSpan" id="kobo.910.1">With this implementation, we would get a defaulted </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.912.1"> destructor, which is a good thing. </span><span class="koboSpan" id="kobo.912.2">There would be a tiny complexity increase in </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">clear()</span></strong><span class="koboSpan" id="kobo.914.1"> where we need to distinguish</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.915.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">head</span></strong><span class="koboSpan" id="kobo.917.1"> smart pointer from the </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">underlying pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.919.1">
   // ...
</span><span class="koboSpan" id="kobo.919.2">   void clear() noexcept {
      </span><strong class="bold"><span class="koboSpan" id="kobo.920.1">for (auto p = head.get(); p; ) { // &lt;--</span></strong><span class="koboSpan" id="kobo.921.1">
         auto q = p-&gt;next;
         delete p;
         p = q;
      }
      nelems = 0;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.922.1">The iterator interface needs to be adapted somewhat since </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">head</span></strong><span class="koboSpan" id="kobo.924.1"> is not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">Node*</span></strong><span class="koboSpan" id="kobo.926.1"> anymore, but iterators trade in </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">non-owning resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.928.1">
   // ...
</span><span class="koboSpan" id="kobo.928.2">   </span><strong class="bold"><span class="koboSpan" id="kobo.929.1">iterator begin() { return { head.get() }; } // &lt;--</span></strong><span class="koboSpan" id="kobo.930.1">
   const_iterator begin() const {
      </span><strong class="bold"><span class="koboSpan" id="kobo.931.1">return { head.get() }; // &lt;--</span></strong><span class="koboSpan" id="kobo.932.1">
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.933.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.935.1"> constructor that takes a pair of iterators and towards which most other constructors converge</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.936.1"> requires </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">slight modifications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
   // ...
</span><span class="koboSpan" id="kobo.938.2">   template &lt;std::forward_iterator It&gt;
      ForwardList(It b, It e) {
         if(b == e) return;
         </span><strong class="bold"><span class="koboSpan" id="kobo.939.1">head.reset(new Node{ *b }); // &lt;--</span></strong><span class="koboSpan" id="kobo.940.1">
         </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">auto q = head.get(); // &lt;--</span></strong><span class="koboSpan" id="kobo.942.1">
         ++nelems;
         for(++b; b != e; ++b) {
            q-&gt;next = new Node{ *b };
            q = q-&gt;next;
            ++nelems;
         }
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.943.1">The exception handling side of this member function is indeed simplified, being made implicit from the fact that, should any constructor of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">T</span></strong><span class="koboSpan" id="kobo.945.1"> object throw an exception, the previously created</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.946.1"> nodes will </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">be destroyed.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">As in the previous version, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">push_front()</span></strong><span class="koboSpan" id="kobo.950.1"> member functions will require some adjustment as they interact with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">head</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.952.1">data member:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.953.1">
   // ...
</span><span class="koboSpan" id="kobo.953.2">   void push_front(const_reference val) {
      auto p = new Node{ val };
      </span><strong class="bold"><span class="koboSpan" id="kobo.954.1">p-&gt;next = head.get(); // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.955.1">      head.release(); // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.956.1">      head.reset(p); // &lt;--</span></strong><span class="koboSpan" id="kobo.957.1">
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
      auto p = new Node{ std::move(val) };
      </span><strong class="bold"><span class="koboSpan" id="kobo.958.1">p-&gt;next = head.get(); // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.959.1">      head.release(); // &lt;--</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.960.1">      head.reset(p); // &lt;--</span></strong><span class="koboSpan" id="kobo.961.1">
      ++nelems;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.962.1">On the upside, no member function that does not interact with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">head</span></strong><span class="koboSpan" id="kobo.964.1"> data member requires </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">any modification.</span></span></p>
<p><span class="koboSpan" id="kobo.966.1">Is this “implicitness” worth it? </span><span class="koboSpan" id="kobo.966.2">It probably depends on the way in which you approach writing code. </span><span class="koboSpan" id="kobo.966.3">We did gain something of value in implicit exception safety. </span><span class="koboSpan" id="kobo.966.4">There is value in separating concerns, and</span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.967.1"> this implementation does free the container from the task of managing memory (for the most part). </span><span class="koboSpan" id="kobo.967.2">It is up to you, dear reader, to determine whether the reduced complexity “here” outweighs the added </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">complexity “there.”</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.969.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.970.1">In this chapter, we reexamined containers written in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.971.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.972.1">, seeking to use implicit memory management tools in such a way as to make our implementations simpler and safer. </span><span class="koboSpan" id="kobo.972.2">We did reach an improvement in </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.974.1"> but the results obtained with our node-based </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.976.1"> container were… not absent, but arguably less conclusive depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">your perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">In the next chapter, we will introduce the idea of allocators, objects that inform containers as to how memory should be obtained or liberated, and examine how they impact the ways in which we </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">write code.</span></span></p>
</div>
</body></html>