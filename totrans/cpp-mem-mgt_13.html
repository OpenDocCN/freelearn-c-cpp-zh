<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-181"><a id="_idTextAnchor187"/>13</h1>
<h1 id="_idParaDest-182"><a id="_idTextAnchor188"/>Writing Generic Containers with Implicit Memory Management</h1>
<p>In the previous chapter, we wrote a working (if simple) implementation of a <code>std::vector&lt;T&gt;</code>-like type in <code>Vector&lt;T&gt;</code>, as well as a working (if, again, simple) implementation of a <code>std::forward_list&lt;T&gt;</code>-like type in <code>ForwardList&lt;T&gt;</code>. Not bad!</p>
<p>In the case of our <code>Vector&lt;T&gt;</code> type, after an initial effort that led to a working but sometimes inefficient implementation, we made the effort to separate allocation from construction, something that reduced the amount of redundant effort required at runtime but came at the cost of a more subtle implementation. In this more sophisticated implementation, we distinguished parts of the underlying storage that are initialized from those that are not and, of course, operated on both parts appropriately (treating objects as objects and raw memory as such). For example, we used assignment (and algorithms that use the assignment operator) to replace the contents of existing objects but preferred placement <code>new</code> (and algorithms that rely on this mechanism) to create objects in raw memory.</p>
<p>Our <code>Vector&lt;T&gt;</code> implementation from the previous chapter is a class expressed with a sizable amount of source code. One of the reasons for this situation is the explicit memory management we have been doing. Indeed, we have made a <code>Vector&lt;T&gt;</code> object responsible for both the management of the underlying memory block and the objects stored therein, and this double responsibility came with a cost. In this chapter, we will revisit that design by making memory management <em class="italic">implicit</em> and we will discuss the consequences of this new approach. Hopefully, dear reader, this will lead you toward a possible simplification and refinement of your coding practices.</p>
<p>In this chapter, our goals will be as follows:</p>
<ul>
<li>To adapt a hand-written container such as <code>Vector&lt;T&gt;</code> in such a way as to significantly simplify its memory management responsibilities</li>
<li>To understand the consequences of our design on source code complexity</li>
<li>To understand the consequences of our design on exception safety</li>
</ul>
<p>We will spend most of our energy on revisiting the <code>Vector&lt;T&gt;</code> container, but we will also revisit <code>ForwardList&lt;T&gt;</code> to see if we can apply the same kind of reasoning to both container types. By the end of this chapter, at least in the case of <code>Vector&lt;T&gt;</code>, we will still have a hand-written container that manages memory efficiently and distinguishes raw memory from constructed objects, but our implementation will be significantly simpler than the one we produced in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>.</p>
<p>Note that with respect to <code>Vector&lt;T&gt;</code>, this chapter will compare two versions. One will be named the “<em class="italic">naïve</em> version” and will be the initial implementation that uses objects of type <code>T</code> throughout the underlying storage. The other will be named the “<em class="italic">sophisticated</em> version” and will be the implementation that considers the underlying storage as being made of two (potentially empty) “sections,” with objects of type <code>T</code> at the beginning and raw memory at the end.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor189"/>Technical requirements</h1>
<p>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter13</a>.</p>
<p class="callout-heading">Some words about the code excerpts in this chapter</p>
<p class="callout">This chapter will for the most part revisit and modify (hopefully simplifying!) the code examples from <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>, using ideas from previous chapters (notably <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a> and <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>) along the way. Since a lot of the code used for <code>Vector&lt;T&gt;</code> and <code>ForwardList&lt;T&gt;</code> will not change, we will not write the entire classes all over again to avoid undue repetition.</p>
<p class="callout">Instead, we will concentrate on the most meaningful modifications made to the previous versions of those classes, sometimes comparing implementations “before” and “after” modifications have been made. Of course, the code samples in the GitHub repository are complete and can be used to “complete the picture.”</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor190"/>Why explicit memory management complicates our implementation</h1>
<p>Let’s look for a <a id="_idIndexMarker716"/>moment at one of the constructors for <code>Vector&lt;T&gt;</code> as written in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>. For simplicity, we will use the constructor that accepts a number of elements and an initial value for these elements as arguments. If we limit ourselves to the naïve version where <code>elems</code> points to a sequence of <code>T</code> objects and put aside for the moment the more sophisticated version where <code>elems</code> points to a block of memory that holds <code>T</code> objects at the beginning and raw memory at the end, we have the following:</p>
<pre class="source-code">
   <strong class="bold">// naïve version with elems of type T*</strong>
   Vector(size_type n, const_reference init)
      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {
      try {
         std::fill(begin(), end(), init);
      } catch (...) {
         delete [] elems;
         throw;
      }
   }
// ...</pre> <p>This constructor allocates an array of <code>T</code> objects, initializes them through a sequence of assignments, “handles” exceptions, and so on. The <code>try</code> block and its corresponding <code>catch</code> block are part of our implementation, but not because we want to handle exceptions raised by the constructors of <code>T</code> objects. Indeed: how could we know what exceptions it could throw if we do not know what <code>T</code> is? We insert these blocks because we need to explicitly deallocate and destroy the array if we are to avoid leaks. The situation gets even more complicated if we look at the more sophisticated version that distinguishes allocation from construction:</p>
<pre class="source-code">
   <strong class="bold">// sophisticated version with elems of type T*</strong>
   Vector(size_type n, const_reference init)
      : elems{ static_cast&lt;pointer&gt;(
           std::malloc(n * sizeof(value_type))
        ) }, nelems{ n }, cap{ n } {
      try {
         std::uninitialized_fill(begin(), end(), init);
      } catch (...) {
         std::free(elems);
         throw;
      }
   }
// ...</pre> <p>As we can see, we do this work because we decided that <code>Vector&lt;T&gt;</code> would be the <em class="italic">owner</em> of that memory. And we are totally allowed to do so! But what if we made something else<a id="_idIndexMarker717"/> responsible for our memory?</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor191"/>Implicit memory management with a smart pointer</h1>
<p>In C++, the simplest <a id="_idIndexMarker718"/>way to change our <code>Vector&lt;T&gt;</code> implementation from one that manually manages memory to one that does so implicitly is through a smart pointer. The idea here is, essentially, to change the type of the <code>elems</code> data member of <code>Vector&lt;T&gt;</code> from <code>T*</code> to <code>std::unique_ptr&lt;T[]&gt;</code>. We will look at this from two angles:</p>
<ul>
<li>How does this change impact the naïve version of <code>Vector&lt;T&gt;</code>? As a reminder, our naïve version from <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a> did not distinguish between objects and raw memory in the underlying storage, and thus only stored objects. This led to a simpler implementation, but also one that needlessly constructed objects on many occasions and was much slower than the more sophisticated implementation for non-trivially constructible types.</li>
<li>How does this change impact the sophisticated version of <code>Vector&lt;T&gt;</code> that avoided the performance trap of constructing unnecessary objects at the cost of a somewhat more complicated implementation?</li>
</ul>
<p>In both cases, we will examine selected member functions that are indicative of the impact of this change. The full implementations of both the naïve and the sophisticated implementations<a id="_idIndexMarker719"/> of <code>Vector&lt;T&gt;</code> are available to peruse and use in the GitHub repository associated with this book.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor192"/>Impact on the naïve Vector&lt;T&gt; implementation</h2>
<p>If we were basing our <a id="_idIndexMarker720"/>simplification<a id="_idIndexMarker721"/> effort on the initial, naïve version of <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a> where <code>elems</code> simply pointed to a contiguous sequence of <code>T</code> objects, this would be rather simple, as we could change:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, explicit memory management</strong>
// declaration of the data members...
<strong class="bold">pointer elems{};</strong>
size_type nelems{}, cap{};</pre> <p>… to:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, implicit memory management</strong>
// declaration of the data members...
<strong class="bold">std::unique_ptr&lt;value_type[]&gt; elems;</strong>
size_type nelems{}, cap{};</pre> <p>… and then change the implementation of the <code>begin()</code> member functions from this:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, explicit memory management</strong>
iterator begin() {
   return <strong class="bold">elems</strong>; // raw pointer to the memory block
}
const_iterator begin() const {
   return <strong class="bold">elems</strong>; // raw pointer to the memory block
}</pre> <p>… to this:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, implicit memory management</strong>
iterator begin() {
   return <strong class="bold">elems.get()</strong>; // raw pointer to the beginning
                       // of the underlying memory block
}
const_iterator begin() const {
   return <strong class="bold">elems.get()</strong>; // likewise
}</pre> <p>Just doing this would be sufficient to significantly simplify the implementation of type <code>Vector&lt;T&gt;</code> as deallocating memory would become implicit. For example, we could simplify each<a id="_idIndexMarker722"/> constructor <a id="_idIndexMarker723"/>by removing the exception handling altogether, changing, for example, the following implementation:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, explicit memory management</strong>
   Vector(size_type n, const_reference init)
      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {
      try {
         std:: fill(begin(), end(), init);
      } catch (...) {
         delete [] elems;
         throw;
      }
   }
// ...</pre> <p>… for this significantly simpler one:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, implicit memory management</strong>
   Vector(size_type n, const_reference init)
      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {
      std:: fill(begin(), end(), init);
   }
// ...</pre> <p>The reason for this simplification is the following:</p>
<ul>
<li>If the <code>Vector&lt;T&gt;</code> object is responsible for the allocated memory, then deleting the array will be done implicitly when the destructor is called, but for a destructor to be called, there needs to be an object to destroy: a <code>Vector&lt;T&gt;</code> constructor needs to have succeeded! That explains why we need to catch whatever exception was thrown, manually delete the array, and re-throw whatever exception was thrown: until the closing brace of a destructor is reached, there is no <code>Vector&lt;T&gt;</code> object to destruct and all resource management has to be done explicitly.</li>
<li>On the other hand, if <code>elems</code> is a smart pointer, then it becomes responsible for the pointee as soon as the smart pointer itself has been constructed, and this occurs <em class="italic">before</em> the opening brace of the <code>Vector&lt;T&gt;</code> constructor. This means that once <code>elems</code> has been constructed, it <em class="italic">will</em> be destructed if an exception leaves the constructor, freeing the <code>Vector&lt;T&gt;</code> object-to-be from the task of destructing the array. To be clear: when we reach the opening brace of the constructor of <code>Vector&lt;T&gt;</code>, the data members of <code>*this</code> have been constructed, and for that reason, they will be destructed if an exception is thrown, even if the construction of <code>*this</code> itself does not conclude. The object model of C++ is truly wonderful in such situations.</li>
</ul>
<p>The more<a id="_idIndexMarker724"/> astute<a id="_idIndexMarker725"/> among you, dear readers, will have noticed that even if one was writing code for a company where exceptions are disallowed or frowned upon, the exception-safety we gained from using a smart pointer remains. We have (discretely) written exception-safe code without writing the words <code>try</code> or <code>catch</code>.</p>
<p>Other examples of simplification through the introduction of implicit memory management would include move operations and the destructor of <code>Vector&lt;T&gt;</code>, which would change from this:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, explicit memory management</strong>
   Vector(Vector &amp;&amp;other)
      : elems{ std::exchange(other.elems, nullptr) },
        nelems{ std::exchange(other.nelems, 0) },
        cap{ std::exchange(other.cap, 0) } {
   }
   Vector&amp; operator=(Vector &amp;&amp;other) {
      Vector{ other }.swap(*this);
      return *this;
   }
   ~Vector() {
      delete [] elems;
   }
// ...</pre> <p>… to <a id="_idIndexMarker726"/>simply<a id="_idIndexMarker727"/> this:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, implicit memory management</strong>
   Vector(Vector&amp;&amp;) = default;
   Vector&amp; operator=(Vector&amp;&amp;) = default;
   ~Vector() = default;
// ...</pre> <p>Making move operations <code>=default</code> works because type <code>std::unique_ptr</code> does “the right thing” when moving and transfers ownership of the pointee from the source to the destination.</p>
<p class="callout-heading">Something to be aware of</p>
<p class="callout">By making the move operations <code>=default</code>, we induced a slight semantic change in our <code>Vector&lt;T&gt;</code> implementation. The C++ standard recommends that a moved-from is in a valid yet unspecified state but does not go into detail as to what “valid” means. Our hand-written move operations restored the moved-from object to the equivalent of a default-constructed <code>Vector&lt;T&gt;</code> object, but the “defaulted” one leaves the moved-from object with a null <code>elems</code> but with potentially non-zero size and capacity. This still works in practice as long as user code does not use the moved-from object unless it has first been reassigned to, but it is a semantic change that deserves to be acknowledged.</p>
<p>Yet another interesting simplification would be the implementation of the <code>resize()</code> member function. In <a id="_idIndexMarker728"/>the <a id="_idIndexMarker729"/>original, naïve <code>Vector&lt;T&gt;</code> implementation, we had the following:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, explicit memory management</strong>
   void resize(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = new T[new_cap];
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::move(begin(), end(), p);
      } else try {
         std::copy(begin(), end(), p);
      } catch (...) {
         delete[] p;
         throw;
      }
      delete[] elems;
      elems = p;
      cap = new_cap;
   }</pre> <p>Here, again, we are faced with the possibility of an exception being thrown from the copy assignment of a <code>T</code> object to a <code>T</code> object and need to handle exceptions in order to avoid leaking resources. Going from explicit resource handling to implicit resource handling, we get the following:</p>
<pre class="source-code">
<strong class="bold">// naïve implementation, implicit memory management</strong>
   void resize(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = std::make_unique&lt;value_type[]&gt;(new_cap);
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::move(begin(), end(), p.get());
      } else {
         std::copy(begin(), end(), p.get());
      }
      elems.reset(p.release());
      cap = new_cap;
   }</pre> <p>As you can see, the<a id="_idIndexMarker730"/> entire <a id="_idIndexMarker731"/>exception handling code is gone. Object <code>p</code> owns the new array and will destroy it when the function concludes execution. Once the copies (or the moves, depending on whether the move assignment of type <code>T</code> is or is not marked as <code>noexcept</code>) are completed, <code>elems</code> lets go of the previously owned array through <code>reset()</code> (destroying it at the same time) and “steals” ownership of the array released by <code>p</code> through <code>release()</code>. Note that writing <code>elems = std::move(p);</code> would have had a similar effect.</p>
<p>Applying this simplification process throughout <code>Vector&lt;T&gt;</code>, source code gradually shrinks and, on a container like the naïve version of <code>Vector&lt;T&gt;</code> that only contains objects, no raw memory block at the end of the underlying storage, we can save almost 25% of the number <a id="_idIndexMarker732"/>of source code lines (going from roughly 180 lines to 140 lines for this academic implementation). Try it and see for yourself!</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor193"/>Impact on the sophisticated Vector&lt;T&gt; implementation</h2>
<p>Applying the<a id="_idIndexMarker733"/> same<a id="_idIndexMarker734"/> technique to the more sophisticated <code>Vector&lt;T&gt;</code> will require a bit more work as the default behavior of the destructor of an object of type <code>std::unique_ptr&lt;T[]&gt;</code> will be to apply <code>operator delete[]</code> to the pointer it owns. As we know at this point, our sophisticated implementation can be conceptualized as being made of two (potentially empty) “sections”: an initial section made of <code>T</code> objects manually placed into raw memory followed by another section of uninitialized, raw memory devoid of objects. As such, we need to handle each “section” in a different manner.</p>
<p>We will still use a <code>std::unique_ptr&lt;T[]&gt;</code> object to manage the memory, but we will need to use a <code>custom deleter</code> object (something we discussed in <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a> and in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>) to take into account the specifics of our implementation. This object will need knowledge of the runtime state of the <code>Vector&lt;T&gt;</code> object it will accompany since it will have to know where each “section” of the underlying storage starts as well as where it ends, and that is something that changes as the code is executing.</p>
<p>The first important point of this implementation, and this is a point that has been recurring but that we probably did not insist upon enough, is that we want our implementations to expose the same interface to client code, regardless of implementation variations. This is sometimes impossible or unreasonable to achieve, but it is nonetheless a meaningful and worthwhile target. This includes our choice of internal public types: for example, the fact that we use a smart pointer to manage the underlying memory does not change the fact that a pointer to an element is a <code>T*</code>:</p>
<pre class="source-code">
// ...
template &lt;class T&gt;
class Vector {
public:
   using value_type = T;
   using size_type = std::size_t;
   using pointer = T*;
   using const_pointer = const T*;
   using reference = T&amp;;
   using const_reference = const T&amp;;
   // ...</pre> <p>Now, since we want to define <code>elems</code> as being a smart pointer that owns and manages the underlying storage instead of being a raw pointer, we will need to define the custom deleter that will be used by that smart pointer.</p>
<p>An important aspect of this problem is that the custom deleter will need to know the state of the <code>Vector&lt;T&gt;</code> object to know what part of the underlying storage holds objects. For this reason, the custom deleter of our <code>std::unique_ptr&lt;T[]&gt;</code> will be stateful and store a reference named <code>source</code> to the <code>Vector&lt;T&gt;</code> object. Through <code>source</code>, The function call operator of the <code>deleter</code> object will have access to the sequence of objects in the container (the half-open sequence from <code>source.begin()</code> to <code>source.end()</code>) and will<a id="_idIndexMarker735"/> be able to <code>destroy()</code> these objects <a id="_idIndexMarker736"/>before freeing the underlying storage:</p>
<pre class="source-code">
   // ...
private:
<strong class="bold">   struct deleter {</strong>
<strong class="bold">      Vector&amp; source;</strong>
<strong class="bold">      void operator()(value_type* p) {</strong>
<strong class="bold">         std::destroy(std::begin(source),</strong>
<strong class="bold">                      std::end(source));</strong>
<strong class="bold">         std::free(static_cast&lt;void*&gt;(p));</strong>
<strong class="bold">      }</strong>
<strong class="bold">   };</strong>
   std::unique_ptr&lt;value_type[], <strong class="bold">deleter</strong>&gt; elems;
   size_type nelems{},
             cap{};
   // ...</pre> <p>The <code>elems</code> data member knows that the type of the custom deleter will be <code>deleter</code>, but the actual object that will play the role of deleter will have to know what <code>Vector&lt;T&gt;</code> object it will interact with. The constructors of a <code>Vector&lt;T&gt;</code> will be responsible for providing this information, and we will need to be careful with the ways in which we implement our move operations in order to make sure we do not transfer the <code>deleter</code> object’s state and make our code incoherent.</p>
<p>As mentioned with the naïve version, we need to adapt the <code>begin()</code> member functions to take into account the fact that <code>elems</code> is a smart pointer but that our <code>iterator</code> interface relies on raw pointers:</p>
<pre class="source-code">
   // ...
   using iterator = pointer;
   using const_iterator = const_pointer;
<strong class="bold">   iterator begin() { return elems.get(); }</strong>
<strong class="bold">   const_iterator begin() const { return elems.get(); }</strong>
   // ...</pre> <p>Our constructors<a id="_idIndexMarker737"/> will <a id="_idIndexMarker738"/>need to adapt to the fact that we have a custom deleter that will clean up if anything bad happens, or if the program concludes normally. Three examples of <code>Vector&lt;T&gt;</code> constructors follow:</p>
<pre class="source-code">
   // ...
   constexpr Vector()
      : elems{ nullptr, <strong class="bold">deleter { *this }</strong> } {
   }
   Vector(size_type n, const_reference init)
      : elems{ static_cast&lt;pointer&gt;(
           std::malloc(n * sizeof(value_type))
        ), <strong class="bold">deleter{ *this }</strong>
      } {
      std::uninitialized_fill(begin(), begin() + n, init);
      nelems = cap = n;
   }
   Vector(Vector&amp;&amp; other) noexcept
      : elems{ std::exchange(
           other.elems.release()), deleter{ *this }
        },
        nelems{ std::exchange(other.nelems, 0) },
        cap{ std::exchange(other.cap, 0) } {
   }
   // ...</pre> <p>Please note that we are not expressing the move constructor with <code>=default</code> in this case as we do not want to transfer the custom deleter, our implementation having associated this object with a specific <code>Vector&lt;T&gt;</code> object.</p>
<p>A small note is in order here: we are passing <code>*this</code> to the constructor of the <code>deleter</code> object, but we are doing so <em class="italic">before</em> the construction of <code>*this</code> has been completed, so <em class="italic">anything</em> done by the <code>deleter</code> object before the construction of <code>*this</code> concludes (before the closing brace of its constructor) deserves care and attention.</p>
<p>In our case, the <code>deleter</code> object will come into play if the destructor of <code>elems</code> comes into play, which will happen if the constructor of an object of type <code>T</code> throws. We need to make sure that the values of the data members of <code>*this</code> are coherent whenever there is a possibility that the <code>deleter</code> object intervenes.</p>
<p>In our <a id="_idIndexMarker739"/>case, since<a id="_idIndexMarker740"/> the <code>begin()</code> and <code>end()</code> member functions return iterators that define a half-open range of objects and, as we now know, <code>std::uninitialized_fill()</code> calls the constructors and (if an exception is thrown) destroys the objects that have been constructed, we have to make sure that <code>nelems==0</code> until all of the objects have been constructed. Note that we defined the range to initialize as <code>begin()</code> and <code>begin()+n</code>, and waited until after the call to <code>std::uninitialized_fill()</code> to change <code>nelems</code>: this way, <code>begin()==end()</code> if an exception is thrown, and the <code>deleter</code> object will not try to destruct “non-objects.”</p>
<p>Other constructors of class <code>Vector&lt;T&gt;</code> are likewise simplified; we will not show them here so consider them as not-so-dreaded “exercises left to the reader.”</p>
<p>The simplification of <code>Vector&lt;T&gt;</code> is made evident with some of the special member functions that now require little or no effort on our part. Of note in this regard is the destructor, which can now be defaulted; as mentioned with the move constructor earlier in this section, we do not default the move assignment to avoid transferring the custom deleter’s <a id="_idIndexMarker741"/>internal <a id="_idIndexMarker742"/>state, as can be seen in the following code excerpt:</p>
<pre class="source-code">
   // ...
<strong class="bold">   ~Vector() = default;</strong>
   void swap(Vector&amp; other) noexcept {
      using std::swap;
<strong class="bold">      swap(elems, other.elems);</strong>
      swap(nelems, other.nelems);
      swap(cap, other.cap);
   }
   Vector&amp; operator=(const Vector&amp; other) {
      Vector{ other }.swap(*this);
      return *this;
   }
<strong class="bold">   Vector&amp; operator=(Vector&amp;&amp; other) {</strong>
<strong class="bold">      Vector{ std::move(other) }.swap(*this);</strong>
<strong class="bold">      return *this;</strong>
<strong class="bold">   }</strong>
   reference operator[](size_type n) { return <strong class="bold">elems[n]</strong>; }
   const_reference operator[](size_type n) const {
      return <strong class="bold">elems[n]</strong>;
   }</pre> <p>Member functions <code>swap()</code> and <code>operator[]</code> have been shown to make it clear that <code>std::unique_ptr&lt;T[]&gt;</code> behaves in many ways like a “regular” array of <code>T</code> objects. Many other member functions of <code>Vector&lt;T&gt;</code> remain unchanged, such as <code>front()</code>, <code>back()</code>, <code>operator==()</code>, <code>operator!=()</code>, <code>grow()</code>, <code>push_back()</code>, and <code>emplace_back()</code>. Please refer to <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a> for details on these functions.</p>
<p>The <code>reserve()</code> and <code>resize()</code> functions can also be simplified through the use of smart pointers, as we can get rid of explicit exception management and yet remain exception-safe since <code>std::unique_ptr&lt;T[]&gt;</code> is an <strong class="bold">RAII</strong> type <a id="_idIndexMarker743"/>and handles memory for us.</p>
<p>In the case of <code>reserve()</code>, we now use smart pointer <code>p</code> to hold the allocated memory, then either <code>move()</code> or <code>copy()</code> the objects from <code>elems</code> to <code>p</code>. Once this is done, we <code>destroy()</code> the objects left in <code>elems</code>, after which <code>p</code> relinquishes its pointer and transfers it<a id="_idIndexMarker744"/> to <code>elems</code>, and<a id="_idIndexMarker745"/> the only thing left to do is to update the container’s capacity:</p>
<pre class="source-code">
   // ...
   void reserve(size_type new_cap) {
      if (new_cap &lt;= capacity()) return;
      std::unique_ptr&lt;value_type[]&gt; p{
         static_cast&lt;pointer&gt;(
            std::malloc(new_cap * sizeof(T))
         )
      };
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p.get());
      } else {
         std::uninitialized_copy(begin(), end(), p.get());
      }
      std::destroy(begin(), end());
      elems.reset(p.release());
      cap = new_cap;
   }</pre> <p>In the case of <code>resize()</code>, we now use smart pointer <code>p</code> to hold the allocated memory, then either <code>move()</code> or <code>copy()</code> the objects from <code>elems</code> to <code>p</code> and construct default <code>T</code> objects in the remaining part of the memory block. Once this is done, we <code>destroy()</code> the objects left in <code>elems</code>, after which <code>p</code> relinquishes its pointer and transfers it to <code>elems</code>, and the only <a id="_idIndexMarker746"/>thing <a id="_idIndexMarker747"/>left to do is to update the container’s capacity:</p>
<pre class="source-code">
   // ...
   void resize(size_type new_cap) {
      if (new_cap &lt;= capacity()) return;
      std::unique_ptr&lt;value_type[]&gt; p =
         static_cast&lt;pointer&gt;(
            std::malloc(new_cap * sizeof(T))
         );
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p.get());
      } else {
         std::uninitialized_copy(begin(), end(), p.get());
      }
      std::uninitialized_fill(
         p.get() + size(), p.get() + new_cap, value_type{}
      );
      std::destroy(begin(), end());
      elems.reset(p.release());
      nelems = cap = new_cap;
   }
   // ...</pre> <p>The magic of it all, or so to speak, is that our other member functions such as <code>insert()</code> and <code>erase()</code> are built on top of basic abstractions such as <code>reserve()</code>, <code>begin()</code>, <code>end()</code>, and so on, which means they do not have to be modified to take into account this <a id="_idIndexMarker748"/>representational <a id="_idIndexMarker749"/>change.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor194"/>Consequences of this redesign</h1>
<p>What are the consequences <a id="_idIndexMarker750"/>of this “redesign” of sorts? They have been <a id="_idIndexMarker751"/>mentioned along the way, but let’s summarize:</p>
<ul>
<li>For user code, consequences are essentially none: an object of type <code>Vector&lt;T&gt;</code> occupies the same space in memory with the implicit memory management implementation and almost the same space with the explicit memory management implementation (where the custom deleter is stateful), and each exposes the same public interface.</li>
<li>There are essentially no speed costs either, for reasons explained in <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>: in code compiled with optimization levels other than the basic, made-for-debugging ones, going through <code>std::unique_ptr&lt;T&gt;</code> will, due to function call inlining, lead to code that is as efficient as going through a <code>T*</code>.</li>
<li>The implementation is made significantly simpler: fewer instructions, no explicit exception handling code, more member functions that can be defaulted…</li>
<li>An important aspect of this implicit memory management implementation is that it is exception-safe even in the absence of explicit <code>try</code> and <code>catch</code> blocks. This can make a difference in many situations: for example, you might be in a situation where exceptions are not allowed but find yourself using a library where exceptions are a possibility… or can simply call <code>operator new()</code> in a situation where memory is constrained. Our implementation with implicit memory management would be safe under such circumstances, but an implementation taking a manual memory management approach with no exception handling code would not be so “lucky.”</li>
</ul>
<p>The effort involved in implementing the custom deleter seems to be a sound investment with <code>Vector&lt;T&gt;</code>. Now, you<a id="_idIndexMarker752"/> might wonder whether the situation is similar with <a id="_idIndexMarker753"/>node-based containers, so we will explore this question by revisiting the naïve <code>ForwardList&lt;T&gt;</code> implementation from <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor195"/>Generalizing to ForwardList&lt;T&gt;?</h1>
<p>We now know that we can <a id="_idIndexMarker754"/>adapt the implementation of <code>Vector&lt;T&gt;</code>, transforming it from an explicit memory management model to an implicit one, and that so doing has lots of advantages. It is tempting to do the same with other containers, but before embarking on such an adventure, it might be wise to analyze the problem a little.</p>
<p>We implemented a node-based container with explicit memory management named <code>ForwardList&lt;T&gt;</code> in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>. What would be the impact of trying to change the implementation of this container to make it more implicit?</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor196"/>Attempt - making each node responsible for its successor</h2>
<p>In our exploration of ways in which we could try to make memory management in a node-based container more implicit, one possible approach could be to change the definition of <code>ForwardList&lt;T&gt;::Node</code> such that the <code>next</code> data member becomes a <code>std::unique_ptr&lt;Node&gt;</code> instead of a <code>Node*</code>.</p>
<p>As a synopsis, we would get the following:</p>
<pre class="source-code">
template &lt;class T&gt;
class ForwardList {
public:
   // ...
private:
   struct Node {
      value_type value;
      <strong class="bold">std::unique_ptr&lt;Node&gt; next; // &lt;--</strong>
      Node(const_reference value) : value{ value } {
      }
      Node(value_type&amp;&amp; value) : value{ std::move(value) }{
      }
   };
   <strong class="bold">Node* head{};</strong>
   size_type nelems{};
   // ...</pre> <p>This might seem like an<a id="_idIndexMarker755"/> improvement at first glance, since it would simplify the destructor of <code>ForwardList&lt;T&gt;</code> down to the following:</p>
<pre class="source-code">
   // ...
   ~ForwardList() {
      <strong class="bold">delete head; // &lt;-- lots of work starts here!</strong>
   }
   // ...</pre> <p>This simplification would induce a kind of “domino effect”: since the <code>next</code> data member of a node becomes the owner of its successor node in the list, and since this is true for every node in the chain (except for <code>head</code> itself), then destructing the first node ensures the destruction of its successor, and of that successor’s successor, and so on.</p>
<p>This apparent simplification hides a tricky fact: when calling <code>delete head;</code> under this implementation, <em class="italic">we might be provoking a stack overflow</em>. Indeed, we replaced a loop that applied <code>delete</code> on each node in succession with something that’s essentially a recursive call, meaning that the impact on stack usage changed from something that was fixed to something that is proportional to the number of nodes in the list. That’s unpleasant news indeed!</p>
<p>At this point, dear reader, maybe you are thinking “Well, I was only going to use this <code>ForwardList&lt;T&gt;</code> type for small lists anyway, so I’m not worried.” If that expresses your line of thinking, maybe we should explore other implications of this implementation decision in our <code>ForwardList&lt;T&gt;</code> class.</p>
<p>One such implication is that iterators get a little bit more complicated: we do not want an iterator over nodes to be the sole owner of the node it is traversing. That would be destructive indeed, as nodes would be destroyed as we are iterating over the list. For this reason, <code>ForwardList&lt;T&gt;::Node&lt;U&gt;</code> (where <code>U</code> is either <code>T</code> or <code>const T</code>) would still have a <code>T*</code> data member, meaning that <code>operator++()</code>, for example, would need to obtain the underlying <a id="_idIndexMarker756"/>pointer of the <code>std::unique_ptr&lt;T&gt;</code> data member in each node:</p>
<pre class="source-code">
   // ...
   template &lt;class U&gt; class Iterator {
   public:
      // ...
   private:
      <strong class="bold">Node* cur{};</strong>
   public:
      // ...
      Iterator&amp; operator++() {
         <strong class="bold">cur = cur-&gt;next.get(); // &lt;--</strong>
         return *this;
      }
   // ...</pre> <p>That’s a slight complexity increase, but nothing that is impossible to manage.</p>
<p>In <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>, we made most of our <code>ForwardList&lt;T&gt;</code> constructors converge towards the more general sequence constructor that takes a pair of forward iterators of some type <code>It</code> as arguments. This constructor would become in part more complex, as chaining nodes would now require knowledge that we are using smart pointers inside each node, but cleanup in case an exception is thrown would only require deleting the head node and letting <a id="_idIndexMarker757"/>the aforementioned “domino effect” take place:</p>
<pre class="source-code">
   // ...
   template &lt;std::forward_iterator It&gt;
   ForwardList(It b, It e) {
      try {
         if (b == e) return;
         <strong class="bold">head = new Node{ *b };</strong>
         auto q = head;
         ++nelems;
         for (++b; b != e; ++b) {
            <strong class="bold">q-&gt;next = std::make_unique&lt;Node&gt;(*b); // &lt;--</strong>
            <strong class="bold">q = q-&gt;next.get(); // &lt;--</strong>
            ++nelems;
         }
      } catch (...) {
         <strong class="bold">delete head; // &lt;--</strong>
         throw;
      }
   }
   // ...</pre> <p>Most member functions of <code>ForwardList&lt;T&gt;</code> would remain unchanged. There would be slight adjustments to such things as <code>push_front()</code>, for example:</p>
<pre class="source-code">
   // ...
   void push_front(const_reference val) {
      <strong class="bold">auto p = new Node{ val };</strong>
<strong class="bold">      p-&gt;next = std::unique_ptr&lt;Node&gt;{ head }; // &lt;--</strong>
<strong class="bold">      head = p;</strong>
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
      <strong class="bold">auto p = new Node{ std::move(val) };</strong>
<strong class="bold">      p-&gt;next = std::unique_ptr&lt;Node&gt;{ head }; // &lt;--</strong>
<strong class="bold">      head = p;</strong>
      ++nelems;
   }
   // ...</pre> <p>As can be seen, we<a id="_idIndexMarker758"/> need to distinguish code that uses the <code>head</code> data member from code that uses the other nodes in the chain. Similar adjustments would apply to any member function that modifies the structure of the list, including, notably, insertions and suppressions.</p>
<p>A more interesting, and probably more enlightening, member function would be the <code>insert_after()</code> member function that inserts one element after a given iterator in the list. Let’s look at this function in detail:</p>
<pre class="source-code">
   // ...
   iterator
      insert_after(iterator pos, const_reference value) {
      <strong class="bold">auto p = std::make_unique&lt;Node&gt;(value); // &lt;-- A</strong>
      <strong class="bold">p-&gt;next.reset(pos.cur-&gt;next.get()); // &lt;-- B</strong>
      <strong class="bold">pos.cur-&gt;next.release(); // &lt;-- C</strong>
      <strong class="bold">pos.cur-&gt;next.reset(p.get()); // &lt;-- D</strong>
      <strong class="bold">p.release(); // &lt;-- E</strong>
      ++nelems;
      <strong class="bold">return { pos.cur-&gt;next.get() }; // &lt;-- F</strong>
   }
   // ...</pre> <p>Hum, that’s quite a lot of updated text! How did this function get so complicated? Looking at the “lettered” comments, we have the following:</p>
<ul>
<li>On line <em class="italic">A</em>, we create a <code>std::unique_ptr&lt;Node&gt;</code> object named <code>p</code> for the value to be inserted. We know the newly created node will not be the first node in the list since the function is <code>insert_after()</code>, and requires an iterator to an existing “before” node (named <code>pos</code> here), so that makes sense. For the same reason, we know that <code>pos</code> is not <code>end()</code>, which, by definition, does not point to a valid node in <a id="_idIndexMarker759"/>our container.</li>
<li>On line <em class="italic">B</em>, we do what is required to make the successor of <code>p</code> the successor of <code>pos</code>. That requires some care since <code>pos.cur-&gt;next</code> is guaranteed to be a <code>std::unique_ptr&lt;Node&gt;</code> (it obviously cannot be <code>head</code> as <code>pos.cur</code> is “before” <code>pos.cur-&gt;next</code>) and we made <code>p</code> a <code>std::unique_ptr&lt;Node&gt;</code>. We are displacing responsibility over the successor node of <code>pos.cur</code> to <code>p-&gt;next</code>, effectively inserting <code>pos-&gt;next</code> after <code>p</code> (albeit in a complicated way).</li>
<li>On line <em class="italic">C</em>, we are ensuring that <code>pos.cur</code> relinquishes its responsibility over <code>pos.cur-&gt;next</code>. This is important since, if we did not do so, then replacing that <code>std::unique_ptr&lt;Node&gt;</code> would destroy the pointee. Line <em class="italic">B</em> ensured that <code>pos.cur-&gt;next</code> and <code>p-&gt;next</code> would lead to the same object, which would have been disastrous had we stopped there (two objects responsible for the same pointee is a semantic problem we do not need).</li>
<li>Once <code>pos.cur-&gt;next</code> has been disconnected, we move to line <em class="italic">D</em> where we make it point to the raw pointer underneath <code>p</code>. This would, again, lead to a shared responsibility over a <code>Node</code>, so we continue with line <em class="italic">E</em> where we disconnect <code>p</code> from its underlying pointer.</li>
<li>Line <em class="italic">F</em> concludes the work in this function by returning the expected iterator to a raw (thus non-owning) pointer.</li>
</ul>
<p>That is… complicated. The main reason why this is complicated is that most of the effort in this function is the transfer of ownership. A <code>std::unique_ptr&lt;T&gt;</code> object represents sole ownership over a <code>T*</code>, after all, and in a linked list, each and every insertion or suppression requires moving pointers around, thus transferring ownership between nodes. We simplified an occasional situation (deletion of the nodes) by complicating most of<a id="_idIndexMarker760"/> the operations in our type. That’s… sad.</p>
<p class="callout-heading">On meaning and responsibility semantics</p>
<p class="callout">Smart pointers are all about encoding meaning and responsibility in the type system. Simplifying user code is important, but it’s not the main point of these types. In a <code>ForwardList&lt;T&gt;</code>object, the real owner of the <code>T</code> objects is the <code>ForwardList&lt;T&gt;</code> object, and the <code>ForwardList&lt;T&gt;::Node&lt;U&gt;</code> objects are (from the <code>ForwardList&lt;T&gt;</code> object’s perspective) essentially a storage facility. Trying to change this can be made to work, but the ensuing complexity is an indication that something’s suspicious.</p>
<p class="callout">When writing a class, especially a container class, it’s essential that we have a clear view of the role intended for each type. We know that iterators are non-owning by nature (we could, however, envision <code>shared_ptr&lt;T&gt;</code> objects that co-own the pointee in some use cases). As far as containers and their underlying representation goes, the important point is that the responsibilities of each type need to be clear if our design is going to be manageable.</p>
<p>Okay, so making a node responsible for its successor did not work. Would simply making the <code>head</code> member of a <code>ForwardList&lt;T&gt;</code> object responsible for the other nodes in the list make our lives better?</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor197"/>Attempt: making the head pointer responsible for the other nodes</h2>
<p>As seen in the previous section, making each node responsible for its successor is semantically incorrect. It leads to complex, involved, and error-prone code, and the aspects of the implementation that are simplified by this transformation are mostly outweighed by the added complexity in other places.</p>
<p>Maybe just making the <code>head</code> node a <code>std::unique_ptr&lt;Node&gt;</code> object with a custom deleter<a id="_idIndexMarker761"/> responsible for deleting the entire list would be beneficial? Well, we can assuredly try this approach.</p>
<p>As a synopsis, we would now get the following:</p>
<pre class="source-code">
template &lt;class T&gt;
class ForwardList {
   // ...
   struct Node {
      value_type value;
      <strong class="bold">Node* next = nullptr;</strong>
      Node(const_reference value) : value{ value } {
      }
      Node(value_type&amp;&amp; value) : value{ std::move(value) }{
      }
   };
<strong class="bold">   struct deleter { // &lt;--</strong>
<strong class="bold">      void operator()(Node* p) const {</strong>
<strong class="bold">         while (p) {</strong>
<strong class="bold">            Node* q = p-&gt;next;</strong>
<strong class="bold">            delete p;</strong>
<strong class="bold">            p = q;</strong>
<strong class="bold">         }</strong>
<strong class="bold">      }</strong>
<strong class="bold">   };</strong>
   <strong class="bold">std::unique_ptr&lt;Node, deleter&gt; head;</strong>
<code>ForwardList&lt;T&gt;</code> type that, when an object of that type is destroyed, implicitly ensures that the nodes in the list are destructed. The entire list remains built from raw pointers, such that nodes are not responsible for memory management, which is probably an upgrade from the previous attempt.</p>
<p>With this implementation, we would get a defaulted <code>ForwardList&lt;T&gt;</code> destructor, which is a good thing. There would be a tiny complexity increase in <code>clear()</code> where we need to distinguish<a id="_idIndexMarker762"/> the <code>head</code> smart pointer from the underlying pointer:</p>
<pre class="source-code">
   // ...
   void clear() noexcept {
      <strong class="bold">for (auto p = head.get(); p; ) { // &lt;--</strong>
         auto q = p-&gt;next;
         delete p;
         p = q;
      }
      nelems = 0;
   }
   // ...</pre> <p>The iterator interface needs to be adapted somewhat since <code>head</code> is not a <code>Node*</code> anymore, but iterators trade in non-owning resources:</p>
<pre class="source-code">
   // ...
   <strong class="bold">iterator begin() { return { head.get() }; } // &lt;--</strong>
   const_iterator begin() const {
      <strong class="bold">return { head.get() }; // &lt;--</strong>
   }
   // ...</pre> <p>The <code>ForwardList&lt;T&gt;</code> constructor that takes a pair of iterators and towards which most other constructors converge<a id="_idIndexMarker763"/> requires slight modifications:</p>
<pre class="source-code">
   // ...
   template &lt;std::forward_iterator It&gt;
      ForwardList(It b, It e) {
         if(b == e) return;
         <strong class="bold">head.reset(new Node{ *b }); // &lt;--</strong>
         <strong class="bold">auto q = head.get(); // &lt;--</strong>
         ++nelems;
         for(++b; b != e; ++b) {
            q-&gt;next = new Node{ *b };
            q = q-&gt;next;
            ++nelems;
         }
      }
   // ...</pre> <p>The exception handling side of this member function is indeed simplified, being made implicit from the fact that, should any constructor of a <code>T</code> object throw an exception, the previously created<a id="_idIndexMarker764"/> nodes will be destroyed.</p>
<p>As in the previous version, our <code>push_front()</code> member functions will require some adjustment as they interact with the <code>head</code> data member:</p>
<pre class="source-code">
   // ...
   void push_front(const_reference val) {
      auto p = new Node{ val };
      <strong class="bold">p-&gt;next = head.get(); // &lt;--</strong>
<strong class="bold">      head.release(); // &lt;--</strong>
<strong class="bold">      head.reset(p); // &lt;--</strong>
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
      auto p = new Node{ std::move(val) };
      <strong class="bold">p-&gt;next = head.get(); // &lt;--</strong>
<strong class="bold">      head.release(); // &lt;--</strong>
<strong class="bold">      head.reset(p); // &lt;--</strong>
      ++nelems;
   }
   // ...</pre> <p>On the upside, no member function that does not interact with the <code>head</code> data member requires any modification.</p>
<p>Is this “implicitness” worth it? It probably depends on the way in which you approach writing code. We did gain something of value in implicit exception safety. There is value in separating concerns, and<a id="_idIndexMarker765"/> this implementation does free the container from the task of managing memory (for the most part). It is up to you, dear reader, to determine whether the reduced complexity “here” outweighs the added complexity “there.”</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor198"/>Summary</h1>
<p>In this chapter, we reexamined containers written in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>, seeking to use implicit memory management tools in such a way as to make our implementations simpler and safer. We did reach an improvement in <code>Vector&lt;T&gt;</code> but the results obtained with our node-based <code>ForwardList&lt;T&gt;</code> container were… not absent, but arguably less conclusive depending on your perspective.</p>
<p>In the next chapter, we will introduce the idea of allocators, objects that inform containers as to how memory should be obtained or liberated, and examine how they impact the ways in which we write code.</p>
</div>
</body></html>