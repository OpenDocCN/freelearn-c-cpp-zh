- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compile-Time Computation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Compile-time computation** refers to the ability of a compiler to execute
    functions at compile time, instead of converting them to machine code. This means
    that the results of complex operations can be calculated by the compiler and stored
    in variables that are used at runtime. A compiler can execute a function at compile
    time only if all arguments of the function are known at compile time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We can use compile-time computation in C++ firmware to calculate complex math
    operations, generate lookup tables and arrays in general, and use the generated
    values at runtime. Performing these operations at compile time will save valuable
    memory and processor (space and time) resources and make them available for other,
    more important operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to learn how to use compile-time computation in
    C++ to shift complex operations at compile time and save valuable resources. In
    this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `constexpr` specifier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consteval specifier
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler for x86 architecture. This will allow you to see standard
    output (stdio) results and better observe the code’s behavior. As we are using
    a lot of modern C++ features, make sure to select the C++23 standard by adding
    `-std=c++23` to the compiler options box.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly code. Most of the examples
    can also be run in the Renode simulator on an ARM Cortex-M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first available mechanism for compile-time computation in C++ was **Template
    Meta-Programming (TMP)**. Using TMP, we can store the results of operations in
    types, as shown in the following example of computing the factorial:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run this example in Compiler Explorer (even without optimizations),
    you will see that it returns 120\. The generated assembly code is short and does
    not contain any function calls. It simply places the value 120 in the return register
    in the `main` function, meaning the factorial computation was done at compile
    time. You can see the generated assembly code here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We performed the following steps in the preceding example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a class template factorial. It has an unsigned int, N, as the parameter
    and only one member: `static const unsigned int value = N * factorial<N-1>::value`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the assignment expression of the member `value`, we use recursion at the
    template level as we calculate it by multiplying `N` by the `value` from the factorial
    instantiated with `N – 1`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define factorial template specialization for 0, making it a base type that
    will stop recursion, meaning that `factorial<0>::value` will contain `1`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand the recursion at the template level, we will write down
    the entire recursion chain for the preceding example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`factorial<5>::value = 5 * factorial<4>::value;`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<4>::value = 4 * factorial<3>::value;`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<3>::value = 3 * factorial<2>::value;`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<2>::value = 2 * factorial<1>::value;`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<1>::value = 1 * factorial<0>::value;`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<0>::value = 1;`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we substitute the base value of `factorial<0>` with `1`, back up the chain,
    we have the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`factorial<1>::value = 1 * 1 = 1`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<2>::value = 2 * 1 = 2`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<3>::value = 3 * 2 = 6`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<4>::value = 4 * 6 = 24`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<5>::value = 5 * 24 = 120`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main` function computes the factorial of `5` by accessing `factorial<5>::value`
    and returns it. The recursion is terminated by the specialized template for `factorial<0>`,
    which provides the base case. The final result is that the program returns `120`,
    the factorial of `5`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: While TMP allows for compile-time computations, it often involves complex recursive
    patterns that can be difficult to read and maintain. To address these challenges,
    C++11 introduced the `constexpr` specifier, which has become the preferred mechanism
    for compile-time computations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: constexpr specifier
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `constexpr` **specifier**, we declare that it is possible to evaluate
    variables and functions at compile time. There are limitations to what can be
    evaluated at compile time. A `constexpr` variable must meet the following requirements:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'It needs to be of a `literal` type, any of the following:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar types such as arithmetic types, enumerations, and pointers
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of `literal` types
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that meet specific requirements (such as a trivial `constexpr` de`struct`or,
    all of its non-static data members are `literal` types, or at least one `constexpr`
    con`struct`or).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be immediately initialized.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire expression of its initialization needs to be a constant expression.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go through the following example to better understand the requirements
    for `constexpr` variables:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this example in Compiler Explorer using `x86-64 GCC 14.2` compiler,
    without optimization enabled, we can observe the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The program returns `0`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting assembly is small, and it just moves `0` to return the register.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you change the initialization of the `ret` variable so that the sine function
    takes `3.14/2` as the argument, the program will return `1`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we try to change the compiler in Compiler Explorer to `x86-64 clang
    18.1.0`, we will get the following compiler error:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The compiler reports that we are violating the rule that says that the entire
    expression of its initialization needs to be a constant expression, as the function
    `sin,` in the expression `round(sin(3.14))`, is non-`constexpr`. This is because
    Clang’s implementation of math functions is non-`constexpr`, while GCC implements
    them as `constexpr` functions. Many math functions will be `constexpr` functions
    in the new C++26 standard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器报告说我们违反了规则，即其初始化的整个表达式需要是一个常量表达式，因为在表达式`round(sin(3.14))`中的函数`sin`不是`constexpr`。这是因为Clang对数学函数的实现不是`constexpr`，而GCC将其实现为`constexpr`函数。在新的C++26标准中，许多数学函数都将被实现为`constexpr`函数。
- en: 'Although the upcoming C++26 standard mandates that math functions should be
    `constexpr`, we will utilize the current GCC implementation because it is the
    compiler we are using for our STM32 target in the examples throughout this book.
    All `constexpr` functions must meet the following requirements:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管即将到来的C++26标准强制要求数学函数应该是`constexpr`，但我们将利用当前的GCC实现，因为我们在这本书的例子中使用的编译器是用于我们的STM32目标。所有`constexpr`函数都必须满足以下要求：
- en: Its `return` type must be of the `literal` type.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的`return`类型必须是`literal`类型。
- en: Each of its parameters must be of the `literal` type.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的每个参数都必须是`literal`类型。
- en: If a function is not a con`struct`or, it must have only one `return` statement.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数不是构造函数，它必须只有一个`return`语句。
- en: 'To better understand `constexpr` functions, let us implement the factorial
    algorithm as a `constexpr` function in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`constexpr`函数，让我们在下面的例子中将阶乘算法实现为一个`constexpr`函数：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we implemented the `factorial` algorithm as a simple `constexpr`
    function. Comparing it to a TMP-based solution, this code looks familiar to many
    developers with a C background. There is no recursion at the template level and
    strange syntax. C++11 `constexpr` functions still relied on recursion, but C++14
    relaxed constraints on `constexpr` functions and allowed using local variables
    and loops.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将阶乘算法实现为一个简单的`constexpr`函数。与基于TMP的解决方案相比，这个代码对许多有C背景的开发者来说看起来很熟悉。在模板级别没有递归和奇怪的语法。C++11的`constexpr`函数仍然依赖于递归，但C++14放宽了对`constexpr`函数的限制，并允许使用局部变量和循环。
- en: 'If we run the preceding example in Compiler Explorer using the `x86-64 GCC
    14.2` compiler, without optimization enabled, we can observe the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在编译器探索器中使用`x86-64 GCC 14.2`编译器运行前面的例子，并且没有启用优化，我们可以观察到以下情况：
- en: The program returns 120.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序返回120。
- en: The resulting assembly is small, and it just moves 120 to the return register.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的汇编代码很小，它只是将120移动到返回寄存器。
- en: There is no `factorial` function in the resulting assembly code, meaning that
    the compiler executed this function at compile time. We supplied a factorial function
    with a constant expression argument and the compiler evaluated the function at
    compile time.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的汇编代码中没有`factorial`函数，这意味着编译器在编译时执行了这个函数。我们提供了一个带有常量表达式参数的阶乘函数，编译器在编译时评估了这个函数。
- en: If we remove the `constexpr` specifier from the `calc_val` and `ret` variables
    declarations, we will see the `factorial` function in the resulting assembly call,
    and in `main`, we will see a call to this function, meaning that in this case,
    the `factorial` function is being executed at runtime, and in the case of firmware,
    it will be part of the binary.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们从`calc_val`和`ret`变量的声明中移除`constexpr`指定符，我们将在生成的汇编调用中看到`factorial`函数，在`main`函数中，我们将看到对这个函数的调用，这意味着在这种情况下，`factorial`函数是在运行时执行的，在固件的情况下，它将是二进制的一部分。
- en: As we can see from this example, the `constexpr` function can be executed at
    both compile time and runtime, depending on the arguments we supply it with. Next,
    we will go over practical examples to see how we can apply the `constexpr` specifier
    in firmware development.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从本例中可以看到，`constexpr`函数可以在编译时和运行时执行，具体取决于我们提供给它的参数。接下来，我们将通过实际例子来了解如何在固件开发中应用`constexpr`指定符。
- en: Example 1 – MAC address parser
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例1 – MAC地址解析器
- en: 'The **Medium Access Control** (**MAC**) address is used in the MAC layer of
    different communication stacks, including Ethernet, Wi-Fi, and Bluetooth. Here,
    we will create a 48-bit MAC address compile-time parser that will help us convert
    a common format of a MAC address written as hex numbers separated by a colon into
    an array of `uint8_t`, which is usually used in software stacks. The code is shown
    here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**介质访问控制**（**MAC**）地址用于不同通信栈的 MAC 层，包括以太网、Wi-Fi 和蓝牙。在这里，我们将创建一个 48 位 MAC 地址编译时解析器，它将帮助我们将常见的以冒号分隔的十六进制数字格式的
    MAC 地址转换为 `uint8_t` 数组，这在软件栈中通常使用。代码如下所示：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `main` function, we create an instance of the `struct` `mac_address`,
    by providing a con`struct`or with `"00:11:22:33:44:55"`. If we run the preceding
    example in Compiler Explorer using the x86-64 GCC 14.2 compiler, without optimization
    enabled, we can observe the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们通过提供一个构造函数 `"00:11:22:33:44:55"` 来创建 `struct` `mac_address` 的实例。如果我们使用
    x86-64 GCC 14.2 编译器，在 Compiler Explorer 中运行前面的示例，并且没有启用优化，我们可以观察到以下内容：
- en: The program returns `85` as a decimal number. Converting it to hex format, we
    will get 0x55, which corresponds to the last byte from the MAC address `00:11:22:33:44:55`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序以十进制数 `85` 返回。将其转换为十六进制格式，我们将得到 0x55，这对应于 MAC 地址 `00:11:22:33:44:55` 的最后一个字节。
- en: The resulting assembly is small. It populates the stack with bytes from the
    MAC address we used in the con`struct`or. There are no calls to the con`struct`or,
    meaning it is executed at compile time.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的汇编代码很小。它使用我们在构造函数中使用的 MAC 地址的字节填充栈。没有对构造函数的调用，这意味着它在编译时执行。
- en: If we change the MAC address provided in the con`struct`or to `"000:11:22:33:44:55"`
    or `"G0:11:22:33:44:55"`, the compiler will generate an error due to failed `static_assert(addr.is_valid)`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将构造函数中提供的 MAC 地址更改为 `"000:11:22:33:44:55"` 或 `"G0:11:22:33:44:55"`，编译器将由于
    `static_assert(addr.is_valid)` 失败而生成错误。
- en: 'Let us now explain the `struct` `mac_address` in more detail:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更详细地解释 `struct` `mac_address`：
- en: The `struct` contains the members `std::array<uint8_t, c_bytes_num> bytes` and
    `bool is_valid`. It doesn’t contain any methods except the con`struct`or.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该 `struct` 包含成员 `std::array<uint8_t, c_bytes_num> bytes` 和 `bool is_valid`。它不包含任何方法，除了构造函数。
- en: The con`struct`or accepts the `std::string_view` class template, which encapsulates
    a pointer to the first element of the provided string literal, and its size.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数接受 `std::string_view` 类模板，它封装了对提供的字符串字面量第一个元素的指针及其大小。
- en: The con`struct`or creates substring views using the `susbstr` method on the
    `string_view` object and it uses `std::from_char` to convert them to `uint8_t`
    values, which are stored in the `bytes` array.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数使用 `string_view` 对象上的 `susbstr` 方法创建子串视图，并使用 `std::from_char` 将它们转换为 `uint8_t`
    值，这些值存储在 `bytes` 数组中。
- en: The con`struct`or sets the bool `is_valid` to true if there are no errors. Using
    `static_assert`, we can validate at compile time that the provided MAC address
    string literal was converted successfully. We cannot use asserts in `constexpr`
    functions. The alternative is to throw an exception, which would result in a compile-time
    error, but we decided not to use exceptions for our embedded target.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有错误，构造函数将 bool `is_valid` 设置为 true。使用 `static_assert`，我们可以在编译时验证提供的 MAC 地址字符串字面量是否成功转换。我们无法在
    `constexpr` 函数中使用断言。另一种选择是抛出异常，这将导致编译时错误，但我们决定不为我们的嵌入式目标使用异常。
- en: 'You can also run the preceding example in the Renode simulator on the STM32
    target. Start Visual Studio Code, attach it to the running container, and open
    the `Chapter11/compile_time` project, as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 STM32 目标的 Renode 模拟器中运行前面的示例。启动 Visual Studio Code，将其附加到正在运行的容器，并打开如[*第
    4 章*](Chapter_04.xhtml)所述的 `Chapter11/compile_time` 项目，然后在 Visual Studio Code
    终端中运行以下命令，或者在容器终端中直接运行：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is part of the `main` function from the `main_constexpr_mac_address.cpp`
    file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自 `main_constexpr_mac_address.cpp` 文件的 `main` 函数的一部分：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To confirm that all the work of converting a string literal to an array is performed
    at compile time, you can bind the reference `mac_ref` to `addr_arr` and compare
    binary sizes in both cases. They are both 6,564 bytes, meaning that the `constexpr`
    con`struct`or is not included in the binary as it is actually executed at compile
    time by the compiler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认将字符串字面量转换为数组的所有工作都是在编译时完成的，您可以绑定引用`mac_ref`到`addr_arr`，并比较两种情况下的二进制大小。它们都是6,564字节，这意味着`constexpr`构造函数没有包含在二进制文件中，因为它实际上是在编译时由编译器执行的。
- en: Next, we will go through an example of creating a lookup table for a temperature
    thermistor using `constexpr` functions in C++.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个示例来展示如何使用C++中的`constexpr`函数创建温度热敏电阻的查找表。
- en: Example 2 – Generating a lookup table
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2 – 生成查找表
- en: 'Thermistors are resistors whose resistance changes with temperature. They are
    commonly used in embedded systems. They usually have a non-linear curve. There
    are different methods to approximate an **Analog-to-Digital Converter** (**ADC**)
    reading from a thermistor into a temperature. One of the most used methods is
    the **beta coefficient**. It is calculated by measuring the thermistor’s resistance
    at two temperature points. It is used to calculate temperature using the following
    equation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 热敏电阻是电阻随温度变化的电阻器。它们在嵌入式系统中被广泛使用。它们通常具有非线性曲线。有不同方法来近似将热敏电阻的模拟-数字转换器（**ADC**）读数转换为温度。最常用的方法之一是**贝塔系数**。它是通过测量热敏电阻在两个温度点的电阻来计算的。它用于使用以下方程计算温度：
- en: '![](img/B22402_11_001.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22402_11_001.png)'
- en: In this equation, *T*[0] is a room temperature of 25^oC (298.15K) and *R*[0]
    is the resistance of a thermistor at room temperature. Using the beta coefficient
    (a constant provided by the manufacturer) is a simplification of the thermistor’s
    curve as it relies on measuring the curve only at two points.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方程中，*T*[0]是25°C（298.15K）的室温，*R*[0]是室温下热敏电阻的电阻。使用贝塔系数（由制造商提供的常数）是对热敏电阻曲线的简化，因为它只依赖于在两个点测量曲线。
- en: 'The Steinhart-Hart equation provides a more accurate curve-fitting method as
    it relies on four coefficients calculated by measuring the thermistor at four
    temperature points. The equation is shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Steinhart-Hart方程提供了一种更精确的曲线拟合方法，因为它依赖于通过在四个温度点测量热敏电阻计算出的四个系数。方程如下所示：
- en: '![](img/B22402_11_002.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22402_11_002.png)'
- en: Coefficients *A*, *B*, *C*, and *D* are calculated after measuring the thermistor’s
    temperature at four different temperature points – meaning these are constants
    that are given for a thermistor by the manufacturer. The calculated temperature
    from the Steinhart-Hart equation is in Kelvins. The drawback of the Steinhart-Hart
    equation is it is computationally heavy for small, embedded targets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 系数*A*、*B*、*C*和*D*是在测量热敏电阻在四个不同温度点的温度后计算的——这意味着这些是制造商为热敏电阻提供的常数。使用Steinhart-Hart方程计算的温度是以开尔文为单位的。Steinhart-Hart方程的缺点是它在小型嵌入式目标中计算量较大。
- en: In this example, we will create a lookup table using the Steinhart-Hart equation
    and rely on it to determine temperature by reading a value from the ADC in our
    embedded target. As we can see from the equation, temperature is a function of
    resistance and given constants. For a selected range of resistance, and with a
    selected resolution, we will generate a lookup table of temperature values. Then,
    we will simulate a reading of the thermistor resistance and search the lookup
    table to determine the temperature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用Steinhart-Hart方程创建一个查找表，并依靠它通过读取我们嵌入式目标中的ADC值来确定温度。从方程中我们可以看出，温度是电阻和给定常数的函数。对于选定的电阻范围和选定的分辨率，我们将生成一个温度值的查找表。然后，我们将模拟读取热敏电阻的电阻值，并在查找表中搜索以确定温度。
- en: 'We will select a range of resistance that we want to base the lookup table
    on, and the number of points we want to use. For this, we need functionality that
    will generate an array of numbers in the given range that are evenly spaced, also
    called linear space. Next, we will use that linear space as an argument to a signal
    generator. Let’s start with implementing this as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择一个电阻范围，这是我们想要基于查找表的基础，以及我们想要使用的点的数量。为此，我们需要一个功能，它将生成给定范围内的均匀分布的数字数组，也称为线性空间。接下来，我们将使用这个线性空间作为信号发生器的参数。让我们从以下实现开始：
- en: 'Here is the code showing the linear space generator:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是展示线性空间生成器的代码：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run this program, it will print 10 numbers in the range of 0 to 10, as
    shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The numbers printed are generated at compile time by the `signal` `struct`.
    To connect this back to our example, imagine that these are the values of resistance
    for which we want to calculate the temperature using the Steinhart-Hart equation.
    Let’s go through the implementation in detail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The `signal` is a class template. Template parameters are `typename T` and `std::size_t
    N`. They determine the array type that the `struct` is based on.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `struct` derives from `std::array<T, N>`. We based it on `std::array` to
    be able to use range-based for loops easily and standard library algorithms.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `constexpr` con`struct`or, we use `static_assert` to make sure that `N`
    is greater than 1, and we populate the underlying array with evenly spaced points
    between `begin` and `end`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `main`, we provide `float` and `10` as template arguments to the `struct
    signal`, and `0` and `9` as `begin` and `end` points for the linear space to the
    con`struct`or. We use a range-based for loop to go through elements of the compile-time-generated
    object `x_axis` and print its elements.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will expand the signal `struct` with an additional con`struct`or that
    allows us to create a signal based on another signal and a lambda we will use
    to provide a math function to generate elements of a new signal. The code for
    a new con`struct`or is shown here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this con`struct`or, we initialize elements of a new signal by calling the
    passed `fun` on elements of the passed signal `sig`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a new signal, as shown in this code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you are following the example using Compiler Explorer, make sure to include
    the `<cmath>` header as we are using the `std::sin` function. Running it will
    give the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, we created a new signal named `sine` by passing `x_axis` and the
    lambda `[](int x){return std::sin(x);}` to the newly created con`struct`or.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To connect this with the example, now we can generate a lookup table using simple
    math functions (such as `std::sin`) and linear space generated with the signal
    con`struct`or from *step 1*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Generating a lookup table
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate more complex functions, we need to expand the `signal` class with
    more functionality:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will overload the operators `*` and `/`, to multiply signals by constants
    and divide constants by elements of signal. The code is shown here:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this code, we overloaded the operators `*` and `/`, enabling multiplication
    and division of a signal with a scalar, as in:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code will create a new signal called `result`, which will be the
    result of the multiplication of every element of signal `sig` by scalar `2.0`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can create a new signal by dividing the existing signal by a
    scalar, as shown here:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code will create a new signal called `result`, which will be the result
    of the division of every element of signal `sig` by scalar `2.0`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'To support scalars from the left side of operators `*` and `/`, we need to
    implement the global operators `operator*` and `operator/`. We will do so by declaring
    them as friends to the `struct signal`, as shown here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了支持运算符 `*` 和 `/` 左侧的标量，我们需要实现全局运算符 `operator*` 和 `operator/`。我们将通过将它们声明为 `struct
    signal` 的友元来实现，如下所示：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The friend function `operator*` in this code allows scalar multiplication when
    the scalar is on the left-hand side (scalar * signal), which is not possible with
    the member function alone. As multiplication has a commutative property (*a *
    b = b * a*), we simply call the member function `operator*` and return the result
    (`return sig * t`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的友元函数 `operator*` 允许当标量位于左侧时进行标量乘法（标量 * 信号），这是仅使用成员函数无法实现的。由于乘法具有交换性（*a
    * b = b * a*），我们只需调用成员函数 `operator*` 并返回结果（`return sig * t`）。
- en: 'In the friend function `operator/`, we perform the following steps:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在友元函数 `operator/` 中，我们执行以下步骤：
- en: Create a new signal, `ret`.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的信号，`ret`。
- en: Iterate over the elements of the signal `sig`, and for each element, the scalar
    `t` is divided by the element.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历信号 `sig` 的元素，并对每个元素，将标量 `t` 除以该元素。
- en: We return the signal `ret`.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回信号 `ret`。
- en: 'By overloading the operators `*` and `/` both as global and as member functions,
    we can now create signals as in the following example:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将运算符 `*` 和 `/` 都作为全局函数和成员函数重载，我们现在可以创建如下示例中的信号：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code will result in the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将产生以下输出：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see from this output, the originally created `x_axis`, representing
    linear space from 0 to 9.00 with 10 points, is multiplied by 2.0 to create `linear_fun`.
    Then we divide `linear_fun` by 2.0 to create `linear_fun2`, which matches the
    `x_axis`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中看到的，最初创建的 `x_axis`，表示从 0 到 9.00 的线性空间，有 10 个点，被乘以 2.0 以创建 `linear_fun`。然后我们将
    `linear_fun` 除以 2.0 以创建 `linear_fun2`，它与 `x_axis` 匹配。
- en: 'To be able to write the full Steinhart-Hart equation, we also need to overload
    operators `+` and `-`, as shown here:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够写出完整的 Steinhart-Hart 方程，我们还需要重载运算符 `+` 和 `-`，如下所示：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, we overload the following operators:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们重载了以下运算符：
- en: A member `constexpr signal operator+(const T &t)`, allowing us to add a scalar
    to a signal (signal + scalar)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员 `constexpr signal operator+(const T &t)`，允许我们将标量添加到信号（信号 + 标量）
- en: A member `constexpr signal operator-(const T &t)`, allowing us to subtract a
    scalar from a signal (signal - scalar)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员 `constexpr signal operator-(const T &t)`，允许我们从信号中减去标量（信号 - 标量）
- en: A member `constexpr signal operator+(const signal &sig)`, allowing us to add
    two signals, element by element (signal1 + signal2)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员 `constexpr signal operator+(const signal &sig)`，允许我们逐元素相加两个信号（signal1 + signal2）
- en: Global `constexpr signal operator+(const T &t, const signal &sig)`, allowing
    us to add a signal to a scalar (scalar + signal)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局 `constexpr signal operator+(const T &t, const signal &sig)`，允许我们将信号添加到标量（标量
    + 信号）
- en: Writing a signal representing the Steinhart-Hart equation
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写表示 Steinhart-Hart 方程的信号
- en: 'Now we have all the elements we need to write a signal that represents the
    Steinhart-Hart equation, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了编写表示 Steinhart-Hart 方程的信号的所需所有元素，如下所示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code generates points from the Steinhart-Hart equation through the following
    steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过以下步骤生成 Steinhart-Hart 方程的点：
- en: Define the *A*, *B*, *C*, and *D* coefficients.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 *A*、*B*、*C* 和 *D* 系数。
- en: Create values for resistance in the range 1 to 10 kOhms across 50 points.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 50 个点之间创建 1 到 10 kOhms 的电阻值。
- en: Calculate values of temperature in Kelvins using the Steinhart-Hart equation
    in points from the generated resistance signal. We convert temperature to Celsius
    by subtracting 273.15.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的电阻信号的点计算开尔文温度值。我们将温度转换为摄氏度，通过减去 273.15。
- en: Save the values from the generated resistance and temperature signals into a
    CSV file (file operations require including the `<fstream>` header).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的电阻和温度信号的值保存到 CSV 文件中（文件操作需要包含 `<fstream>` 头文件）。
- en: 'You can run the full example in a Docker container. Start Visual Studio Code,
    attach it to the running container, and open the `Chapter11/signal_generator`
    project, as described in [*Chapter 4*](Chapter_04.xhtml), and then run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Docker 容器中运行完整的示例。启动 Visual Studio Code，将其附加到正在运行的容器，并打开如[*第 4 章*](Chapter_04.xhtml)所述的
    `Chapter11/signal_generator` 项目，然后在 Visual Studio Code 终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the example will result in a CSV file being created (`out.csv`). We
    can generate an image from the created CSV file using the following command in
    the terminal:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例将生成一个 CSV 文件（`out.csv`）。我们可以使用以下终端命令从创建的 CSV 文件生成图像：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can transfer the generated image using the `docker cp` command from the
    host machine:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker cp` 命令从主机机器传输生成的图像：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command will transfer the generated image `curve.png` to the host machine.
    We can also see the same image here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成的图像 `curve.png` 传输到主机机器。我们也可以在这里看到相同的图像：
- en: '![Figure 11.1 – Steinhart-Hart curve](img/B22402_11_01.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Steinhart-Hart 曲线](img/B22402_11_01.png)'
- en: Figure 11.1 – Steinhart-Hart curve
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Steinhart-Hart 曲线
- en: '*Figure 11**.1* depicts the calculated Steinhart-Hart curve. Values for resistance
    and temperature were generated at compile time using the `signal` `struct`. Next,
    we will use the generated curve in Renode to read a temperature from a simulated
    thermistor using the ADC. Here is an image of a circuit showing how the thermistor
    is connected to the microcontroller:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11**.1* 展示了计算出的 Steinhart-Hart 曲线。使用 `signal` `struct` 在编译时生成了电阻和温度的值。接下来，我们将使用生成的曲线在
    Renode 中读取模拟热敏电阻的 ADC 电压。以下是显示热敏电阻如何连接到微控制器的电路图像：'
- en: '![Figure 11.2 – Thermistor circuit](img/B22402_11_02.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 热敏电阻电路](img/B22402_11_02.png)'
- en: Figure 11.2 – Thermistor circuit
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 热敏电阻电路
- en: '*Figure 11**.2* depicts a voltage divider with a thermistor. If we measure
    the voltage on the ADC pin, we can calculate the thermistor’s resistance using
    the following equation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11**.2* 展示了一个带有热敏电阻的分压器。如果我们测量 ADC 引脚上的电压，我们可以使用以下方程计算热敏电阻的电阻：'
- en: '![](img/B22402_11_003.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22402_11_003.png)'
- en: 'In the preceding equation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中：
- en: '*R*[T] is the calculated resistance of the thermistor.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*[T] 是热敏电阻的计算电阻。'
- en: '*R*[2] is the resistance of a resistor with a known value.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*[2] 是已知值的电阻的电阻。'
- en: '*V*[CC] is the power supply voltage.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*V*[CC] 是电源电压。'
- en: '*V*[ADC] is the voltage measured by the ADC.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*V*[ADC] 是 ADC 测量的电压。'
- en: 'We can model a voltage divider using a simple `struct` in C++, shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 C++ 中的简单 `struct` 来模拟分压器，如下所示：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code shows the `struct` `voltage_divider`. We will go through its details:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了 `struct` `voltage_divider`。我们将详细探讨其细节：
- en: It uses strong type resistance and voltage defined in namespace units. You can
    check the implementation details for these strong types in the project folder,
    `Chapter11/compile_time/util`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用在 `units` 命名空间中定义的强类型电阻和电压。您可以在项目文件夹 `Chapter11/compile_time/util` 中检查这些强类型的实现细节。
- en: We instantiate an object of voltage_divider using list initialization as in
    `voltage_divider divider{10e3_Ohm, 3.3_V}`. `10e3_Ohm` and `3.3_V` are user-defined
    literals for types `resistance` and `voltage`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用列表初始化创建 `voltage_divider` 对象，如 `voltage_divider divider{10e3_Ohm, 3.3_V}`。`10e3_Ohm`
    和 `3.3_V` 是 `resistance` 和 `voltage` 类型的用户定义文字。
- en: The `struct` has a single method, `units::resistance get_r1(units::voltage vadc)`.
    It calculates the R1 value from a voltage divider circuit based on the provided
    voltage on ADC. In our case, this is the thermistor’s resistance.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct` 有一个单独的方法，`units::resistance get_r1(units::voltage vadc)`。它根据提供的 ADC
    电压从分压器电路计算 R1 值。在我们的例子中，这是热敏电阻的电阻。'
- en: Analyzing the usage example firmware code
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析使用示例固件代码
- en: 'Next, we will go through the firmware code in a while loop in the `main` function
    from `Chapter11/compile_time/app/src/main_lookup_table.cpp`. It is shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从 `Chapter11/compile_time/app/src/main_lookup_table.cpp` 中的 `main` 函数的循环中查看固件代码。如下所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let us analyze this code in detail:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析此代码：
- en: We are calling the `get_reading` method on the object `adc`. It is of type `hal::adc_stm32`,
    and it returns `std::expected<units::voltage, adc::error>`. It is an error-handling
    technique that we covered in [*Chapter 7*](Chapter_07.xhtml). You can check the
    implementation details of the `adc_stm32` class in the project folder, `Chapter11/compile_time/hal/adc`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在对象 `adc` 上调用 `get_reading` 方法。它属于 `hal::adc_stm32` 类型，并返回 `std::expected<units::voltage,
    adc::error>`。这是一种错误处理技术，我们在 [*第 7 章*](Chapter_07.xhtml) 中讨论过。您可以在项目文件夹 `Chapter11/compile_time/hal/adc`
    中检查 `adc_stm32` 类的实现细节。
- en: If the call to `get_reading` was successful, we dereference the returned object
    to get access to the voltage, which we pass to `voltage_divider`'s `get_r1` method
    to calculate the thermistor’s value.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `get_reading` 调用成功，我们将返回的对象解引用以获取电压，并将其传递给 `voltage_divider` 的 `get_r1` 方法来计算热敏电阻的值。
- en: Next, we use the algorithm `std::lower_bound` to get an iterator to the first
    element in the `resistance` signal that is not ordered before calculating the
    thermistor’s value. If we find such an element, we calculate its position using
    `std::distance`, and index `temperature_celsius` to get the temperature value.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用算法`std::lower_bound`来获取在计算热敏电阻值之前，`resistance`信号中第一个未排序元素的迭代器。如果我们找到这样的元素，我们使用`std::distance`计算其位置，并使用索引`temperature_celsius`获取温度值。
- en: Finally, we print the ADC’s voltage, the thermistor’s resistance, and the temperature
    value. Note that we printed the float value of temperature using `ints`, as printing
    floats increases the binary size of the firmware.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打印出ADC的电压、热敏电阻的阻值和温度值。请注意，我们使用`ints`打印温度的浮点值，因为打印浮点值会增加固件的二进制大小。
- en: 'To run the firmware in the Renode simulator on the STM32 target, start Visual
    Studio Code, attach it to the running container, and open the `Chapter11/compile_time`
    project, as described in [*Chapter 4*](Chapter_04.xhtml), then run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要在STM32目标上的Renode模拟器中运行固件，请启动Visual Studio Code，将其附加到正在运行的容器，并打开如[*第4章*](Chapter_04.xhtml)中所述的`Chapter11/compile_time`项目，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To simulate voltage on the ADC, please enter the following command in the terminal
    running Renode:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Renode终端模拟ADC上的电压，请输入以下命令：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command will feed a voltage of 1700 mV to the ADC in three successive
    readings. This will result in the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将连续三次读取向ADC提供1700 mV的电压。这将产生以下输出：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command shows that for a value of 1700 mV on the ADC, we calculated a thermistor
    value of 9412 Ohms, resulting in a temperature of 26.2⁰C. As an exercise, feed
    the simulation with different ADC voltage values and compare the results with
    the curve graph from previous steps.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示，当ADC上的值为1700 mV时，我们计算出的热敏电阻值为9412欧姆，从而得出温度为26.2⁰C。作为一个练习，向模拟中输入不同的ADC电压值，并将结果与之前步骤中的曲线图进行比较。
- en: The `constexpr` specifier is a flexible tool in C++ allowing us to run a function
    at both compile time and runtime. If we want to make sure that a function is evaluated
    only at compile time, we can use the consteval specifier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`指定符是C++中的一个灵活工具，允许我们在编译时和运行时运行函数。如果我们想确保函数仅在编译时评估，我们可以使用consteval指定符。'
- en: consteval specifier
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: consteval指定符
- en: 'The **consteval specifier** may be applied only to functions. It specifies
    that a function is a so-called immediate function and that every call to it must
    result in a compile-time constant. Let’s go through the following simple example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**consteval指定符**只能应用于函数。它指定了一个函数是一个所谓的即时函数，并且对它的每次调用都必须在编译时产生一个常量。让我们通过以下简单的例子来了解：'
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you run this example in Compiler Explorer using the `x86-64 GCC 14.2` compiler,
    without optimization enabled, we can observe the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`x86-64 GCC 14.2`编译器在编译器探索器中运行此示例，并且没有启用优化，我们可以观察到以下内容：
- en: The program returns 4.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序返回4。
- en: The resulting assembly is small, and it just moves 4 to the return register.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的汇编代码很小，它只是将4移动到返回寄存器。
- en: Removing the `constexpr` specifier from the variable `arg` will result in the
    function square being generated and a call to it in the `main` function.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从变量`arg`中移除`constexpr`指定符将导致生成函数square并在`main`函数中调用它。
- en: 'Now, let’s change the function `square` `constexpr` specifier to `consteval`,
    as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将函数`square`的`constexpr`指定符更改为`consteval`，如下所示：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the program in Compiler Explorer, it will return `4` and result
    in small assembly code. However, if we now remove the `constexpr` specifier from
    the variable `arg`, the compilation will fail with the following error:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编译器探索器中运行程序，它将返回`4`并生成小的汇编代码。然而，如果我们现在从变量`arg`中移除`constexpr`指定符，编译将失败，并出现以下错误：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The consteval specifier ensures that a function is evaluated only at compile
    time. This prevents the function from being accidentally run at runtime, which
    could happen with a `constexpr` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: consteval指定符确保函数仅在编译时评估。这防止了函数在运行时意外运行，这可能会发生在`constexpr`函数中。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored techniques for compile-time computation in C++.
    We covered the basics of TMP and provided an in-depth explanation of the `constexpr`
    specifier, using examples relevant to embedded systems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 C++ 中的编译时计算技术。我们介绍了 TMP 的基础知识，并深入解释了 `constexpr` 指示符，通过嵌入式系统相关的示例进行说明。
- en: With the knowledge from this chapter, you can generate lookup tables and convert
    human-readable addresses, UUIDs, and similar data into arrays used by communication
    stacks, all at compile time. This allows you to write expressive code that generates
    complex mathematical signals without consuming extra memory or processing time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的知识，你可以生成查找表，并将可读地址、UUID 以及类似数据转换为通信栈使用的数组，这一切都在编译时完成。这允许你编写生成复杂数学信号的代码，而不会消耗额外的内存或处理时间。
- en: Next, we will go over the techniques used in writing a HAL in C++.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍在 C++ 中编写 HAL 所使用的技巧。
- en: Join our community on Discord
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_code_Discord.png)'
