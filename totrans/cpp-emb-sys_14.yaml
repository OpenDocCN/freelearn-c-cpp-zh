- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compile-Time Computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Compile-time computation** refers to the ability of a compiler to execute
    functions at compile time, instead of converting them to machine code. This means
    that the results of complex operations can be calculated by the compiler and stored
    in variables that are used at runtime. A compiler can execute a function at compile
    time only if all arguments of the function are known at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use compile-time computation in C++ firmware to calculate complex math
    operations, generate lookup tables and arrays in general, and use the generated
    values at runtime. Performing these operations at compile time will save valuable
    memory and processor (space and time) resources and make them available for other,
    more important operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to learn how to use compile-time computation in
    C++ to shift complex operations at compile time and save valuable resources. In
    this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `constexpr` specifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consteval specifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler for x86 architecture. This will allow you to see standard
    output (stdio) results and better observe the code’s behavior. As we are using
    a lot of modern C++ features, make sure to select the C++23 standard by adding
    `-std=c++23` to the compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly code. Most of the examples
    can also be run in the Renode simulator on an ARM Cortex-M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11)).
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first available mechanism for compile-time computation in C++ was **Template
    Meta-Programming (TMP)**. Using TMP, we can store the results of operations in
    types, as shown in the following example of computing the factorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this example in Compiler Explorer (even without optimizations),
    you will see that it returns 120\. The generated assembly code is short and does
    not contain any function calls. It simply places the value 120 in the return register
    in the `main` function, meaning the factorial computation was done at compile
    time. You can see the generated assembly code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We performed the following steps in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a class template factorial. It has an unsigned int, N, as the parameter
    and only one member: `static const unsigned int value = N * factorial<N-1>::value`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the assignment expression of the member `value`, we use recursion at the
    template level as we calculate it by multiplying `N` by the `value` from the factorial
    instantiated with `N – 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define factorial template specialization for 0, making it a base type that
    will stop recursion, meaning that `factorial<0>::value` will contain `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand the recursion at the template level, we will write down
    the entire recursion chain for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`factorial<5>::value = 5 * factorial<4>::value;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<4>::value = 4 * factorial<3>::value;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<3>::value = 3 * factorial<2>::value;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<2>::value = 2 * factorial<1>::value;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<1>::value = 1 * factorial<0>::value;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<0>::value = 1;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we substitute the base value of `factorial<0>` with `1`, back up the chain,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`factorial<1>::value = 1 * 1 = 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<2>::value = 2 * 1 = 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<3>::value = 3 * 2 = 6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<4>::value = 4 * 6 = 24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorial<5>::value = 5 * 24 = 120`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main` function computes the factorial of `5` by accessing `factorial<5>::value`
    and returns it. The recursion is terminated by the specialized template for `factorial<0>`,
    which provides the base case. The final result is that the program returns `120`,
    the factorial of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: While TMP allows for compile-time computations, it often involves complex recursive
    patterns that can be difficult to read and maintain. To address these challenges,
    C++11 introduced the `constexpr` specifier, which has become the preferred mechanism
    for compile-time computations.
  prefs: []
  type: TYPE_NORMAL
- en: constexpr specifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `constexpr` **specifier**, we declare that it is possible to evaluate
    variables and functions at compile time. There are limitations to what can be
    evaluated at compile time. A `constexpr` variable must meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It needs to be of a `literal` type, any of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar types such as arithmetic types, enumerations, and pointers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of `literal` types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that meet specific requirements (such as a trivial `constexpr` de`struct`or,
    all of its non-static data members are `literal` types, or at least one `constexpr`
    con`struct`or).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be immediately initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire expression of its initialization needs to be a constant expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go through the following example to better understand the requirements
    for `constexpr` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this example in Compiler Explorer using `x86-64 GCC 14.2` compiler,
    without optimization enabled, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The program returns `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting assembly is small, and it just moves `0` to return the register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you change the initialization of the `ret` variable so that the sine function
    takes `3.14/2` as the argument, the program will return `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we try to change the compiler in Compiler Explorer to `x86-64 clang
    18.1.0`, we will get the following compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The compiler reports that we are violating the rule that says that the entire
    expression of its initialization needs to be a constant expression, as the function
    `sin,` in the expression `round(sin(3.14))`, is non-`constexpr`. This is because
    Clang’s implementation of math functions is non-`constexpr`, while GCC implements
    them as `constexpr` functions. Many math functions will be `constexpr` functions
    in the new C++26 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the upcoming C++26 standard mandates that math functions should be
    `constexpr`, we will utilize the current GCC implementation because it is the
    compiler we are using for our STM32 target in the examples throughout this book.
    All `constexpr` functions must meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Its `return` type must be of the `literal` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of its parameters must be of the `literal` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function is not a con`struct`or, it must have only one `return` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand `constexpr` functions, let us implement the factorial
    algorithm as a `constexpr` function in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we implemented the `factorial` algorithm as a simple `constexpr`
    function. Comparing it to a TMP-based solution, this code looks familiar to many
    developers with a C background. There is no recursion at the template level and
    strange syntax. C++11 `constexpr` functions still relied on recursion, but C++14
    relaxed constraints on `constexpr` functions and allowed using local variables
    and loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding example in Compiler Explorer using the `x86-64 GCC
    14.2` compiler, without optimization enabled, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The program returns 120.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting assembly is small, and it just moves 120 to the return register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `factorial` function in the resulting assembly code, meaning that
    the compiler executed this function at compile time. We supplied a factorial function
    with a constant expression argument and the compiler evaluated the function at
    compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we remove the `constexpr` specifier from the `calc_val` and `ret` variables
    declarations, we will see the `factorial` function in the resulting assembly call,
    and in `main`, we will see a call to this function, meaning that in this case,
    the `factorial` function is being executed at runtime, and in the case of firmware,
    it will be part of the binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see from this example, the `constexpr` function can be executed at
    both compile time and runtime, depending on the arguments we supply it with. Next,
    we will go over practical examples to see how we can apply the `constexpr` specifier
    in firmware development.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – MAC address parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Medium Access Control** (**MAC**) address is used in the MAC layer of
    different communication stacks, including Ethernet, Wi-Fi, and Bluetooth. Here,
    we will create a 48-bit MAC address compile-time parser that will help us convert
    a common format of a MAC address written as hex numbers separated by a colon into
    an array of `uint8_t`, which is usually used in software stacks. The code is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we create an instance of the `struct` `mac_address`,
    by providing a con`struct`or with `"00:11:22:33:44:55"`. If we run the preceding
    example in Compiler Explorer using the x86-64 GCC 14.2 compiler, without optimization
    enabled, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The program returns `85` as a decimal number. Converting it to hex format, we
    will get 0x55, which corresponds to the last byte from the MAC address `00:11:22:33:44:55`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting assembly is small. It populates the stack with bytes from the
    MAC address we used in the con`struct`or. There are no calls to the con`struct`or,
    meaning it is executed at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we change the MAC address provided in the con`struct`or to `"000:11:22:33:44:55"`
    or `"G0:11:22:33:44:55"`, the compiler will generate an error due to failed `static_assert(addr.is_valid)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now explain the `struct` `mac_address` in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` contains the members `std::array<uint8_t, c_bytes_num> bytes` and
    `bool is_valid`. It doesn’t contain any methods except the con`struct`or.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The con`struct`or accepts the `std::string_view` class template, which encapsulates
    a pointer to the first element of the provided string literal, and its size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The con`struct`or creates substring views using the `susbstr` method on the
    `string_view` object and it uses `std::from_char` to convert them to `uint8_t`
    values, which are stored in the `bytes` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The con`struct`or sets the bool `is_valid` to true if there are no errors. Using
    `static_assert`, we can validate at compile time that the provided MAC address
    string literal was converted successfully. We cannot use asserts in `constexpr`
    functions. The alternative is to throw an exception, which would result in a compile-time
    error, but we decided not to use exceptions for our embedded target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also run the preceding example in the Renode simulator on the STM32
    target. Start Visual Studio Code, attach it to the running container, and open
    the `Chapter11/compile_time` project, as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is part of the `main` function from the `main_constexpr_mac_address.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To confirm that all the work of converting a string literal to an array is performed
    at compile time, you can bind the reference `mac_ref` to `addr_arr` and compare
    binary sizes in both cases. They are both 6,564 bytes, meaning that the `constexpr`
    con`struct`or is not included in the binary as it is actually executed at compile
    time by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go through an example of creating a lookup table for a temperature
    thermistor using `constexpr` functions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – Generating a lookup table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thermistors are resistors whose resistance changes with temperature. They are
    commonly used in embedded systems. They usually have a non-linear curve. There
    are different methods to approximate an **Analog-to-Digital Converter** (**ADC**)
    reading from a thermistor into a temperature. One of the most used methods is
    the **beta coefficient**. It is calculated by measuring the thermistor’s resistance
    at two temperature points. It is used to calculate temperature using the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22402_11_001.png)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, *T*[0] is a room temperature of 25^oC (298.15K) and *R*[0]
    is the resistance of a thermistor at room temperature. Using the beta coefficient
    (a constant provided by the manufacturer) is a simplification of the thermistor’s
    curve as it relies on measuring the curve only at two points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Steinhart-Hart equation provides a more accurate curve-fitting method as
    it relies on four coefficients calculated by measuring the thermistor at four
    temperature points. The equation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22402_11_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Coefficients *A*, *B*, *C*, and *D* are calculated after measuring the thermistor’s
    temperature at four different temperature points – meaning these are constants
    that are given for a thermistor by the manufacturer. The calculated temperature
    from the Steinhart-Hart equation is in Kelvins. The drawback of the Steinhart-Hart
    equation is it is computationally heavy for small, embedded targets.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will create a lookup table using the Steinhart-Hart equation
    and rely on it to determine temperature by reading a value from the ADC in our
    embedded target. As we can see from the equation, temperature is a function of
    resistance and given constants. For a selected range of resistance, and with a
    selected resolution, we will generate a lookup table of temperature values. Then,
    we will simulate a reading of the thermistor resistance and search the lookup
    table to determine the temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will select a range of resistance that we want to base the lookup table
    on, and the number of points we want to use. For this, we need functionality that
    will generate an array of numbers in the given range that are evenly spaced, also
    called linear space. Next, we will use that linear space as an argument to a signal
    generator. Let’s start with implementing this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code showing the linear space generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run this program, it will print 10 numbers in the range of 0 to 10, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The numbers printed are generated at compile time by the `signal` `struct`.
    To connect this back to our example, imagine that these are the values of resistance
    for which we want to calculate the temperature using the Steinhart-Hart equation.
    Let’s go through the implementation in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `signal` is a class template. Template parameters are `typename T` and `std::size_t
    N`. They determine the array type that the `struct` is based on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `struct` derives from `std::array<T, N>`. We based it on `std::array` to
    be able to use range-based for loops easily and standard library algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `constexpr` con`struct`or, we use `static_assert` to make sure that `N`
    is greater than 1, and we populate the underlying array with evenly spaced points
    between `begin` and `end`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `main`, we provide `float` and `10` as template arguments to the `struct
    signal`, and `0` and `9` as `begin` and `end` points for the linear space to the
    con`struct`or. We use a range-based for loop to go through elements of the compile-time-generated
    object `x_axis` and print its elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will expand the signal `struct` with an additional con`struct`or that
    allows us to create a signal based on another signal and a lambda we will use
    to provide a math function to generate elements of a new signal. The code for
    a new con`struct`or is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this con`struct`or, we initialize elements of a new signal by calling the
    passed `fun` on elements of the passed signal `sig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a new signal, as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are following the example using Compiler Explorer, make sure to include
    the `<cmath>` header as we are using the `std::sin` function. Running it will
    give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we created a new signal named `sine` by passing `x_axis` and the
    lambda `[](int x){return std::sin(x);}` to the newly created con`struct`or.
  prefs: []
  type: TYPE_NORMAL
- en: To connect this with the example, now we can generate a lookup table using simple
    math functions (such as `std::sin`) and linear space generated with the signal
    con`struct`or from *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a lookup table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate more complex functions, we need to expand the `signal` class with
    more functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will overload the operators `*` and `/`, to multiply signals by constants
    and divide constants by elements of signal. The code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code, we overloaded the operators `*` and `/`, enabling multiplication
    and division of a signal with a scalar, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a new signal called `result`, which will be the
    result of the multiplication of every element of signal `sig` by scalar `2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can create a new signal by dividing the existing signal by a
    scalar, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will create a new signal called `result`, which will be the result
    of the division of every element of signal `sig` by scalar `2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support scalars from the left side of operators `*` and `/`, we need to
    implement the global operators `operator*` and `operator/`. We will do so by declaring
    them as friends to the `struct signal`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The friend function `operator*` in this code allows scalar multiplication when
    the scalar is on the left-hand side (scalar * signal), which is not possible with
    the member function alone. As multiplication has a commutative property (*a *
    b = b * a*), we simply call the member function `operator*` and return the result
    (`return sig * t`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the friend function `operator/`, we perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new signal, `ret`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the elements of the signal `sig`, and for each element, the scalar
    `t` is divided by the element.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the signal `ret`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By overloading the operators `*` and `/` both as global and as member functions,
    we can now create signals as in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from this output, the originally created `x_axis`, representing
    linear space from 0 to 9.00 with 10 points, is multiplied by 2.0 to create `linear_fun`.
    Then we divide `linear_fun` by 2.0 to create `linear_fun2`, which matches the
    `x_axis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to write the full Steinhart-Hart equation, we also need to overload
    operators `+` and `-`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code, we overload the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: A member `constexpr signal operator+(const T &t)`, allowing us to add a scalar
    to a signal (signal + scalar)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A member `constexpr signal operator-(const T &t)`, allowing us to subtract a
    scalar from a signal (signal - scalar)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A member `constexpr signal operator+(const signal &sig)`, allowing us to add
    two signals, element by element (signal1 + signal2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global `constexpr signal operator+(const T &t, const signal &sig)`, allowing
    us to add a signal to a scalar (scalar + signal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a signal representing the Steinhart-Hart equation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have all the elements we need to write a signal that represents the
    Steinhart-Hart equation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates points from the Steinhart-Hart equation through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the *A*, *B*, *C*, and *D* coefficients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create values for resistance in the range 1 to 10 kOhms across 50 points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate values of temperature in Kelvins using the Steinhart-Hart equation
    in points from the generated resistance signal. We convert temperature to Celsius
    by subtracting 273.15.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the values from the generated resistance and temperature signals into a
    CSV file (file operations require including the `<fstream>` header).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can run the full example in a Docker container. Start Visual Studio Code,
    attach it to the running container, and open the `Chapter11/signal_generator`
    project, as described in [*Chapter 4*](Chapter_04.xhtml), and then run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example will result in a CSV file being created (`out.csv`). We
    can generate an image from the created CSV file using the following command in
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can transfer the generated image using the `docker cp` command from the
    host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will transfer the generated image `curve.png` to the host machine.
    We can also see the same image here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Steinhart-Hart curve](img/B22402_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Steinhart-Hart curve
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.1* depicts the calculated Steinhart-Hart curve. Values for resistance
    and temperature were generated at compile time using the `signal` `struct`. Next,
    we will use the generated curve in Renode to read a temperature from a simulated
    thermistor using the ADC. Here is an image of a circuit showing how the thermistor
    is connected to the microcontroller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Thermistor circuit](img/B22402_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Thermistor circuit
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.2* depicts a voltage divider with a thermistor. If we measure
    the voltage on the ADC pin, we can calculate the thermistor’s resistance using
    the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22402_11_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*R*[T] is the calculated resistance of the thermistor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*[2] is the resistance of a resistor with a known value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*V*[CC] is the power supply voltage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*V*[ADC] is the voltage measured by the ADC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can model a voltage divider using a simple `struct` in C++, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows the `struct` `voltage_divider`. We will go through its details:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses strong type resistance and voltage defined in namespace units. You can
    check the implementation details for these strong types in the project folder,
    `Chapter11/compile_time/util`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We instantiate an object of voltage_divider using list initialization as in
    `voltage_divider divider{10e3_Ohm, 3.3_V}`. `10e3_Ohm` and `3.3_V` are user-defined
    literals for types `resistance` and `voltage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `struct` has a single method, `units::resistance get_r1(units::voltage vadc)`.
    It calculates the R1 value from a voltage divider circuit based on the provided
    voltage on ADC. In our case, this is the thermistor’s resistance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the usage example firmware code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will go through the firmware code in a while loop in the `main` function
    from `Chapter11/compile_time/app/src/main_lookup_table.cpp`. It is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us analyze this code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We are calling the `get_reading` method on the object `adc`. It is of type `hal::adc_stm32`,
    and it returns `std::expected<units::voltage, adc::error>`. It is an error-handling
    technique that we covered in [*Chapter 7*](Chapter_07.xhtml). You can check the
    implementation details of the `adc_stm32` class in the project folder, `Chapter11/compile_time/hal/adc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the call to `get_reading` was successful, we dereference the returned object
    to get access to the voltage, which we pass to `voltage_divider`'s `get_r1` method
    to calculate the thermistor’s value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the algorithm `std::lower_bound` to get an iterator to the first
    element in the `resistance` signal that is not ordered before calculating the
    thermistor’s value. If we find such an element, we calculate its position using
    `std::distance`, and index `temperature_celsius` to get the temperature value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we print the ADC’s voltage, the thermistor’s resistance, and the temperature
    value. Note that we printed the float value of temperature using `ints`, as printing
    floats increases the binary size of the firmware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the firmware in the Renode simulator on the STM32 target, start Visual
    Studio Code, attach it to the running container, and open the `Chapter11/compile_time`
    project, as described in [*Chapter 4*](Chapter_04.xhtml), then run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To simulate voltage on the ADC, please enter the following command in the terminal
    running Renode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will feed a voltage of 1700 mV to the ADC in three successive
    readings. This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command shows that for a value of 1700 mV on the ADC, we calculated a thermistor
    value of 9412 Ohms, resulting in a temperature of 26.2⁰C. As an exercise, feed
    the simulation with different ADC voltage values and compare the results with
    the curve graph from previous steps.
  prefs: []
  type: TYPE_NORMAL
- en: The `constexpr` specifier is a flexible tool in C++ allowing us to run a function
    at both compile time and runtime. If we want to make sure that a function is evaluated
    only at compile time, we can use the consteval specifier.
  prefs: []
  type: TYPE_NORMAL
- en: consteval specifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **consteval specifier** may be applied only to functions. It specifies
    that a function is a so-called immediate function and that every call to it must
    result in a compile-time constant. Let’s go through the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this example in Compiler Explorer using the `x86-64 GCC 14.2` compiler,
    without optimization enabled, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The program returns 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting assembly is small, and it just moves 4 to the return register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the `constexpr` specifier from the variable `arg` will result in the
    function square being generated and a call to it in the `main` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s change the function `square` `constexpr` specifier to `consteval`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the program in Compiler Explorer, it will return `4` and result
    in small assembly code. However, if we now remove the `constexpr` specifier from
    the variable `arg`, the compilation will fail with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The consteval specifier ensures that a function is evaluated only at compile
    time. This prevents the function from being accidentally run at runtime, which
    could happen with a `constexpr` function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored techniques for compile-time computation in C++.
    We covered the basics of TMP and provided an in-depth explanation of the `constexpr`
    specifier, using examples relevant to embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge from this chapter, you can generate lookup tables and convert
    human-readable addresses, UUIDs, and similar data into arrays used by communication
    stacks, all at compile time. This allows you to write expressive code that generates
    complex mathematical signals without consuming extra memory or processing time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over the techniques used in writing a HAL in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
