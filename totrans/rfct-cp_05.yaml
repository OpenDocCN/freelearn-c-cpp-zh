- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Significance of Naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you delve deeper into the world of C++, or any other programming language
    for that matter, one thing becomes increasingly clear – the power of a name. In
    this chapter, we will explore the profound importance of naming conventions in
    writing clean, maintainable, and efficient C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: In computer programming, names are given to variables, functions, classes, and
    numerous other entities. These names serve as identifiers, playing a pivotal role
    in how we, as programmers, interact with the components of our code. While it
    may seem a trivial matter to some, choosing the right names can have a profound
    impact on the understandability and maintainability of a software project. The
    names we choose to represent the different elements of our program are the first
    layer of documentation that anyone, including our future selves, has when they
    approach our code.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a developer named Mia who works with a class named `WeatherData`. This
    class has two getter methods – `get_tempreture()` and `get_humidity()`. The former
    method simply returns the current temperature value stored in a member variable.
    It’s an O(1) operation, since it involves returning an already-stored value. The
    latter does more than just return a value. It actually initiates a connection
    to a remote weather service, retrieves the latest humidity data, and then returns
    it. This operation is considerably costly, involving network communication and
    data processing, making it far from an O(1) operation. Mia, focusing on optimizing
    a function in the project, sees these two getters and assumes they are similar
    in terms of efficiency due to their naming. She uses `get_humidity()` within a
    loop, expecting it to be a simple, efficient retrieval of a stored value, similar
    to `get_temperature()`. The performance of the function plummets due to the repeated,
    expensive calls to `get_humidity()`. The network requests and data processing
    involved in each call significantly slow down the execution, leading to an inefficient
    use of resources and a slowdown in the application’s performance. This could have
    been avoided if the method had been named `fetch_humidity()` instead of `get_humidity()`.
    The name `fetch_humidity()` would have made it clear that the method is not a
    simple getter but, rather, a more expensive operation that involves fetching data
    from a remote service.
  prefs: []
  type: TYPE_NORMAL
- en: The art of naming requires careful consideration and a good understanding of
    both the problem domain and the programming language. This chapter provides a
    comprehensive discussion of the general approach to creating and naming variables,
    class members, methods, and functions in C++. We will debate the trade-offs of
    long names versus short names, as well as the role of comments in clarifying our
    intentions.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the importance of coding conventions and the benefits they bring
    to individual developers and teams alike. Consistent application of a well-thought-out
    naming convention can streamline the coding process, reduce errors, and greatly
    enhance the readability of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand why good naming practices are
    not just an afterthought but also an essential component of good software development.
    We will equip you with strategies and conventions to help you write code that
    can be easily read, understood, and maintained by others – and by you, when you
    revisit your own code months or years down the line.
  prefs: []
  type: TYPE_NORMAL
- en: General naming principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of the specific **Object-Oriented Programming** (**OOP**) language
    you’re using, certain universal naming principles can help improve the clarity
    and maintainability of your code. These principles aim to ensure that names in
    your code provide sufficient information about their use and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptiveness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Names should accurately describe the purpose or value of the variable, function,
    class, or method they are identifying. For instance, `getSalary()` for a function
    is more informative than simply `getS()`.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consistency in naming conventions is one of the most vital principles in writing
    clear and maintainable code. When you’re consistent with your naming throughout
    your code base, it becomes much easier to read, understand, and debug your code.
    The reason for this is that once a developer learns your naming pattern, they
    can apply their understanding across the entire code base, rather than having
    to figure out what each individual name means in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consistency applies to many areas, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`snake_case` (e.g., `employee_salary`), stick to that style throughout your
    entire code base. Don’t switch between snake_case, camelCase (e.g., `employeeSalary`),
    and PascalCase (e.g., `EmployeeSalary`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_` for member variables (e.g., `m_value`), ensure this rule is followed everywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num` to represent `number` (as in `numEmployees`), then always use `num` whenever
    you mean `number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Employee`), method names are verbs (`calculateSalary`), and Boolean variables
    or methods often start with `is`, `has`, `can`, or similar prefixes (`isAvailable`
    and `hasCompleted`). Stick with these conventions consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s say you’re working on a large code base where classes represent various
    types of employees in a company. You’ve decided to name your classes as singular
    nouns in PascalCase, methods as verbs in snake_case, and variables in snake_case
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'A consistent implementation of this naming convention might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SoftwareEngineer` class is a singular noun and uses PascalCase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assign_task` method is a verb and uses snake_case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `current_task` is in snake_case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being consistent with this convention will help anyone reading your code to
    immediately recognize what each name represents. This way, the cognitive load
    is reduced, and developers can focus on the actual logic, rather than being distracted
    by inconsistent or confusing names.
  prefs: []
  type: TYPE_NORMAL
- en: Unambiguity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unambiguity means that names should not be misleading. Avoid using names that
    could be interpreted in multiple ways, or that contradict established conventions
    or expectations. For example, suppose you have a `Document` class and a method
    named `process`. Without more context, the method name is ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `process` could mean a number of things. Are we going to parse
    the document? Are we going to render it? Are we going to save it to a file? Or
    are we going to perform all these operations? It’s unclear.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more specific method name could help to clarify its purpose. Depending on
    what the method is supposed to do, it could be named `parse`, `render`, `save`,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each of these method names gives a much clearer indication of what the method
    does, removing the ambiguity of the original `process` method name.
  prefs: []
  type: TYPE_NORMAL
- en: Pronounceability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Names should be easily pronounceable. This facilitates verbal communication
    about the code between developers.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables with larger scopes and longer lifetimes usually have more influence
    on a system and, hence, deserve more thoughtful, clear, and descriptive names.
    This helps ensure that they’re understood in all contexts where they’re used.
    Here’s a more detailed breakdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Global variables can be accessed from anywhere in a program, and their lifetime
    extends for the duration of the program. Therefore, they deserve especially careful
    consideration when naming. The name should be descriptive enough to clearly indicate
    its role in the system. Additionally, global variables can create unexpected dependencies,
    which makes the program harder to understand and maintain. Therefore, the use
    of global variables should be minimized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Class member variables can be accessed from any method within the class, and
    their lifetime is tied to the lifetime of the class instance. They should have
    clear and descriptive names that reflect their role within the class. It’s often
    useful to follow a naming convention that distinguishes them from local variables
    (e.g., an `m_` prefix or `_` suffix):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Local variables are confined to a specific function or block and exist only
    for the duration of that function or block. These variables typically need less
    descriptive names compared to global variables or class members, but they should
    still clearly convey their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop variables and temporary variables have the shortest scope and lifetime,
    usually confined to a small loop or a small block of code. As a result, they typically
    have the simplest names (such as `i`, `j`, and `temp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The key idea here is, the broader the scope and the longer the lifetime of a
    variable, the more potential there is for confusion about its purpose, so the
    more descriptive its name should be. The goal is to make code as clear and understandable
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid encoding type or scope information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In modern programming languages, encoding type or scope information into names
    (often known as Hungarian notation) is usually unnecessary and can lead to confusion
    or errors, especially when refactoring. While this can occasionally be helpful,
    especially in languages with weak typing, it has several downsides that make it
    less suitable for use in strongly typed languages such as C++:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of a variable might change in the future, but its name often doesn’t.
    This leads to misleading situations where a variable’s name suggests one type
    but it actually has another. For example, you might start with a vector of IDs
    (`std::vector<Id> id_array`) and later change it to `set<Id>` to avoid duplication,
    but the variable name still suggests it’s an array or vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modern development environments provide features such as type inference, hovering
    tooltips showing types, and powerful refactoring tools, which all make manually
    encoding types into names largely redundant. For example, VS Code with the clangd
    plugin installed and the “inlay hints” feature turned on deducts types on the
    fly, including `auto`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Inlay hints in VS Code](img/B19606_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Inlay hints in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'This applies to CLion by JetBrains too:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefixes in Hungarian notation can make variable names harder to read, especially
    for those not familiar with the notation. It may not be immediately obvious to
    a new developer what `dwCount` (a `DWORD`, or double word, often used to represent
    an unsigned long integer) means.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strongly typed languages such as C++ already check type safety at compile time,
    reducing the need to encode type information in the variable name. In the following
    example, `integers` is declared as `std::vector<int>`, and `sentence` is declared
    as `std::string`. The C++ compiler is aware of these types and will ensure that
    operations on these variables are type-safe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the code attempts to assign `sentence` to `integers`, a compile-time error
    is produced because `sentence` is not of the correct type (`std::vector<int>`).
    This happens despite the fact that neither of the variable names encode type information.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler’s type-checking eliminates the need to include the type in the
    variable names (such as `strSentence` or `vecIntegers`), a practice common in
    languages that do not perform such strong compile-time type-checking. The `integers`
    and `sentence` variable names are sufficiently descriptive without encoding the
    type information.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, you often come across situations where multiple logical concepts
    are represented using the same underlying type. For instance, you may have identifiers
    for `Users` and `Products` in your system, both of which are represented as integers.
    While C++’s static type checking provides a level of safety, it won’t differentiate
    between `UserId` and `ProductId` – they’re both just integers as far as the compiler
    is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: However, using the same type for these different concepts can lead to bugs.
    It’s entirely possible, for example, to mistakenly pass `UserId` where `ProductId`
    was expected, and the compiler wouldn’t catch this error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this issue, you can leverage C++’s rich type system to introduce
    new types representing these different concepts, even when they share the same
    underlying representation. This way, the compiler can catch these bugs at compile
    time, enhancing the robustness of your software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `UserId` and `ProductId` are distinct types. Even
    though their underlying representation is the same (`int`), passing `ProductId`
    to a function expecting `UserId` results in a compile-time error. This adds an
    additional layer of type safety to your code.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a glimpse into how you can utilize C++’s rich static type system
    to create more robust and safer code. We will delve into this topic in more detail
    in [*Chapter 6*](B19606_06.xhtml#_idTextAnchor092), *Utilizing a Rich Static Type
    System* *in C++*.
  prefs: []
  type: TYPE_NORMAL
- en: Class and method naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OOP languages, classes represent concepts or things, and their instances
    (objects) are specific manifestations of those things. As such, both class names
    and their instances are most appropriately named using nouns or noun phrases.
    They represent entities in the system, whether they’re tangible (such as `Employee`
    and `Invoice`) or conceptual (such as `Transaction` and `DatabaseConnection`).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, methods in classes typically represent actions that an object
    of that class can perform, or messages that can be sent to it. As such, they’re
    most effectively named using verbs or verb phrases. They act as instructions that
    can be carried out by the object, allowing it to interact with other objects in
    meaningful ways.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a `Document` class with a `print` method. We can say “document, print”
    or “print the document,” which is a clear, imperative statement in line with how
    we might communicate the action in everyday language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This noun-verb consistency in naming classes and methods aligns well with the
    way we naturally understand and communicate about objects and actions in the real
    world, contributing to the readability and comprehensibility of our code. Moreover,
    it lends itself well to the principle of encapsulation in OOP, where objects manage
    their own behavior (methods) and state (member variables).
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining this convention allows developers to write code that’s more intuitive,
    self-documenting, and easier to maintain. It creates a common language and understanding
    among developers, reducing the cognitive load when reading code and making the
    code base easier to navigate and reason about. Therefore, it’s recommended to
    adhere to these conventions in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable names should reflect the data they hold. A good variable name describes
    the kind of value the variable contains, not just its purpose in the algorithm
    you’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoiding magic numbers, Numerical values with unexplained meanings in the source
    code. They can lead to code that is harder to read, understand, and maintain.
    Let’s consider a `MessageSender` class that sends messages, and if a message size
    is greater than a certain limit, it splits the message into chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `1024` is a magic number. It likely represents a maximum
    message size, but it’s not immediately clear. It can confuse others (or future
    you) reading your code. Here’s a refactored example with a named constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this refactored version, we’ve replaced the magic number `1024` with a named
    constant, `MAX_MESSAGE_SIZE`. It’s now clear that `1024` is the maximum message
    size. Using named constants in this way makes your code more readable and maintainable.
    If the maximum message size needs to change in the future, you only need to update
    it in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Utilize namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces in C++ are incredibly valuable in preventing naming conflicts and
    properly structuring your code. The issue of naming conflicts, or collisions,
    arises when two or more identifiers in a program bear the same name. For instance,
    you might have a class named `Id` in two subsystems of your application – networking
    representing a connection ID and user ID in user management. Using them both without
    namespaces would cause a naming collision, and the compiler wouldn’t know which
    `Id` you are referring to in your code.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this, C++ provides the `namespace` keyword to encapsulate a functionality
    under a unique name. Namespaces are designed to solve the problem of name conflicts.
    By wrapping your code inside a namespace, you prevent it from colliding with same-named
    identifiers in other portions of your code or third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `product_name::Router` won’t conflict with any other `Router`
    class in your product’s code or a third-party library. If you develop library
    code, it is highly recommended to wrap all its entities, such as classes, functions,
    and variables, in a namespace. This will prevent name clashes with other libraries
    or the user’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common in C++ to mirror the project’s directory structure with namespaces,
    making it easier to understand where different parts of the code base are located.
    For example, if you have a file at the `ProductRepo/Networking/Router.cpp` path,
    you might declare the `Router` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can then refer to the class with the fully qualified name `product_name::networking::Router`.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s worth noting that until C++20, the language didn’t natively support
    a module system that could replace or enhance the functionality provided by namespaces.
    With the arrival of modules in C++20, some of the practices might be changing,
    but understanding namespaces and their usage in naming is still vital.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to use namespaces is to express the complexity levels of your code.
    For example, library code may have entities expected to be used by library consumers
    and internal ones. The following code snippet demonstrates this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this extended example, the `communication::Client` class provides a high-level
    interface for sending and receiving messages. It uses the `advanced::http::Client`
    class for the actual implementation, but this detail is hidden from the users
    of the library. They don’t need to know about the advanced class unless they aren’t
    satisfied with the functionality provided by the default client and need more
    control.
  prefs: []
  type: TYPE_NORMAL
- en: The `Client` class, in the `communication::http::advanced` namespace, provides
    more low-level functionality that gives users more control over the details of
    the communication.
  prefs: []
  type: TYPE_NORMAL
- en: This organization makes it clear what functionality is intended for most users
    (`Client`) and what is provided for more advanced usage (`HttpClient`). Using
    namespaces in this way also helps avoid name clashes and keeps the code base well-organized.
    This approach is used by many libraries and frameworks – for example, it’s common
    for Boost libraries to have a `detail` namespace for internal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The use of domain-specific language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are well-established terms in the problem domain, use them in your
    code. This can make your code easier to understand for people familiar with the
    domain. For example, in finance, terms such as “portfolio,” “asset,” “bond,” “equity,”
    “ticker,” and “dividend” are commonly used. If you’re writing an application related
    to finance, it’s beneficial to use these terms in your class and variable names,
    as they clearly convey their roles to anyone with a background in finance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Portfolio`, `Asset`, `Bond`, `Equity`, `Ticker`, and `total_dividend()`
    are all terms that are directly borrowed from the domain of finance. A developer
    or stakeholder who’s familiar with finance will understand the purpose of these
    classes and methods just by their names. This helps to create a common language
    between the developers, stakeholders, and domain experts, which can greatly facilitate
    communication and understanding. Note that it is not recommended to use `double`
    in real-world financial applications, as it does not have an accurate enough representation
    to prevent rounding errors from accumulating when doing arithmetic with monetary
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the goal of these principles is to make your code as clear and easy
    to understand as possible. Writing code is not just about communicating with the
    computer; it’s also about communicating with other developers, including your
    future self.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing long names and comments in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proper naming conventions play a critical role in the clarity and readability
    of your code. Names of classes, methods, and variables should be descriptive enough
    to convey their purpose and functionality. Ideally, a well-chosen name can replace
    the need for additional comments, making your code self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: However, there’s a delicate balance to be struck. While long, descriptive names
    can be helpful, excessively long names can also be cumbersome and detract from
    the readability of code. On the other hand, overly short names can be ambiguous
    and make the code harder to understand. The key is to find the right balance –
    names should be long enough to convey their purpose, but not so long as to be
    unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example from a hypothetical networking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `route` method name and the `message`, `receiver`, and `message_content`
    variable names are all sufficiently descriptive to understand what the method
    does and what each variable represents. Additional comments to explain their roles
    aren’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, there are cases where language constructs can’t fully express
    the intent or nuances of your code, such as when relying on specific behavior
    from a third-party library or when coding a complex algorithm. In these cases,
    additional comments are necessary to provide context or explain why certain decisions
    were made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the comment is necessary to highlight a specific behavior of the
    third-party routing library, which isn’t immediately apparent from the language
    constructs alone.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, strive to make your code as self-explanatory as possible
    through good naming practices, but don’t hesitate to use comments when they’re
    necessary to provide important context or clarify complex logic. Remember, the
    ultimate goal is to create code that is easy to read, understand, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring popular C++ coding conventions – Google, LLVM, and Mozilla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the realm of C++ programming, adhering to a consistent coding convention
    is crucial to ensure code clarity and maintainability. Among the myriad of styles
    available, three prominent conventions stand out for their widespread use and
    distinct approaches – Google’s C++ Style Guide, LLVM Coding Standards, and Mozilla’s
    Coding Style. This overview delves into the key aspects of each, highlighting
    their unique practices and philosophies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.cc` and `.h` extensions for implementation and header files, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kCamelCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CamelCase` for class names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` or `&` with the variable name (`int* ptr`, not `int *ptr`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**: Avoid non-const global variables, and prefer algorithms over
    loops where possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cpp` extension, and header files use `.h`.*   `camelBack` style. Member variables
    have a trailing underscore.*   `CamelCase`.*   `*` or `&` adjacent to the type
    (`int *ptr`, not `int* ptr`).*   **Modern C++ usage**: Encourages the use of modern
    C++ features and patterns.*   `.cpp` and `.``h` extensions*   `camelCase` for
    variables and functions, `CamelCase` for classes, and `SCREAMING_SNAKE_CASE` for
    constants*   `CamelCase` is used for class names*   `*` or `&` adjacent to the
    type*   **Emphasis on performance**: Encourages writing efficient code with a
    focus on browser performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these conventions has its own philosophy and rationale. Google’s style
    guide emphasizes consistency within a vast code base and across a large number
    of developers. LLVM’s standards focus on clean, efficient code that leverages
    modern C++ features. Mozilla’s style balances readability and performance, reflecting
    its origins in web technology development. It’s important to choose a style that
    aligns with your project’s goals, team size, and the specific technologies you
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the critical role of naming programming. We recognized
    that good, consistent naming practices elevate the readability and maintainability
    of code, while also aiding in its self-documentation.
  prefs: []
  type: TYPE_NORMAL
- en: We pondered over the balance between using long descriptive names and shorter
    names supplemented by comments, understanding that both have their place in different
    contexts. The use of domain-specific language in naming was recommended for clarity,
    while “magic numbers” were cautioned against due to their opacity.
  prefs: []
  type: TYPE_NORMAL
- en: The influence of a variable’s scope and lifetime on its naming was also discussed,
    emphasizing the need for more descriptive names for those variables with larger
    scopes and longer lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter wrapped up by stressing the value of adhering to a coding convention
    for naming, which instills consistency across the code base, thereby streamlining
    the code reading and comprehension process.
  prefs: []
  type: TYPE_NORMAL
- en: The insights garnered from this chapter serve as a foundation for the upcoming
    discussion on effectively leveraging the rich static type system in C++ for safer,
    cleaner, and clearer code. In the next chapter, we will shift our focus to the
    effective utilization of C++’s rich static type system.
  prefs: []
  type: TYPE_NORMAL
