- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: The Significance of Naming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名的意义
- en: As you delve deeper into the world of C++, or any other programming language
    for that matter, one thing becomes increasingly clear – the power of a name. In
    this chapter, we will explore the profound importance of naming conventions in
    writing clean, maintainable, and efficient C++ code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你深入探索 C++ 的世界，或者任何其他编程语言，一个越来越清晰的事实是——名称的力量。在本章中，我们将探讨命名约定在编写干净、可维护和高效的 C++
    代码中的深远重要性。
- en: In computer programming, names are given to variables, functions, classes, and
    numerous other entities. These names serve as identifiers, playing a pivotal role
    in how we, as programmers, interact with the components of our code. While it
    may seem a trivial matter to some, choosing the right names can have a profound
    impact on the understandability and maintainability of a software project. The
    names we choose to represent the different elements of our program are the first
    layer of documentation that anyone, including our future selves, has when they
    approach our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，名称被赋予变量、函数、类以及众多其他实体。这些名称作为标识符，在我们作为程序员与代码组件交互中扮演着关键角色。虽然对一些人来说这可能是一件微不足道的事情，但选择正确的名称可以对软件项目的可理解性和可维护性产生深远的影响。我们选择的名称来表示程序的不同元素是我们代码的第一层文档，包括我们未来的自己，当他们接近我们的代码时。
- en: Imagine a developer named Mia who works with a class named `WeatherData`. This
    class has two getter methods – `get_tempreture()` and `get_humidity()`. The former
    method simply returns the current temperature value stored in a member variable.
    It’s an O(1) operation, since it involves returning an already-stored value. The
    latter does more than just return a value. It actually initiates a connection
    to a remote weather service, retrieves the latest humidity data, and then returns
    it. This operation is considerably costly, involving network communication and
    data processing, making it far from an O(1) operation. Mia, focusing on optimizing
    a function in the project, sees these two getters and assumes they are similar
    in terms of efficiency due to their naming. She uses `get_humidity()` within a
    loop, expecting it to be a simple, efficient retrieval of a stored value, similar
    to `get_temperature()`. The performance of the function plummets due to the repeated,
    expensive calls to `get_humidity()`. The network requests and data processing
    involved in each call significantly slow down the execution, leading to an inefficient
    use of resources and a slowdown in the application’s performance. This could have
    been avoided if the method had been named `fetch_humidity()` instead of `get_humidity()`.
    The name `fetch_humidity()` would have made it clear that the method is not a
    simple getter but, rather, a more expensive operation that involves fetching data
    from a remote service.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个名叫 Mia 的开发者，她使用一个名为 `WeatherData` 的类。这个类有两个获取方法——`get_temperature()` 和 `get_humidity()`。前者方法只是简单地返回存储在成员变量中的当前温度值。这是一个
    O(1) 操作，因为它只涉及返回一个已存储的值。后者不仅仅返回一个值。它实际上启动了一个与远程天气服务的连接，检索最新的湿度数据，然后返回它。这个操作相当昂贵，涉及到网络通信和数据处理，远非
    O(1) 操作。Mia 专注于优化项目中的一个函数，看到这两个获取方法，并假设它们在效率上相似，因为它们的命名。她在循环中使用 `get_humidity()`，期望它是一个简单的、高效的存储值检索，类似于
    `get_temperature()`。由于重复调用 `get_humidity()`，函数的性能急剧下降。每次调用中涉及的网络请求和数据处理显著减慢了执行速度，导致资源使用效率低下，并减缓了应用程序的性能。如果方法被命名为
    `fetch_humidity()` 而不是 `get_humidity()`，这种情况本可以避免。`fetch_humidity()` 这个名称会清楚地表明该方法不是一个简单的获取器，而是一个更昂贵的操作，它涉及到从远程服务获取数据。
- en: The art of naming requires careful consideration and a good understanding of
    both the problem domain and the programming language. This chapter provides a
    comprehensive discussion of the general approach to creating and naming variables,
    class members, methods, and functions in C++. We will debate the trade-offs of
    long names versus short names, as well as the role of comments in clarifying our
    intentions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的艺术需要仔细的考虑和对问题域以及编程语言的深入了解。本章提供了对创建和命名变量、类成员、方法和函数在 C++ 中的通用方法的全面讨论。我们将辩论长名称与短名称之间的权衡，以及注释在阐明我们的意图中的作用。
- en: We will explore the importance of coding conventions and the benefits they bring
    to individual developers and teams alike. Consistent application of a well-thought-out
    naming convention can streamline the coding process, reduce errors, and greatly
    enhance the readability of the code base.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨编码约定的重要性以及它们为个人开发者和团队带来的好处。一致地应用经过深思熟虑的命名约定可以简化编码过程，减少错误，并极大地提高代码库的可读性。
- en: By the end of this chapter, you will understand why good naming practices are
    not just an afterthought but also an essential component of good software development.
    We will equip you with strategies and conventions to help you write code that
    can be easily read, understood, and maintained by others – and by you, when you
    revisit your own code months or years down the line.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解良好的命名习惯不仅是一个事后考虑，而且是良好软件开发的一个基本组成部分。我们将为你提供策略和约定，帮助你编写其他人（以及你自己，当你几个月或几年后再次查看自己的代码时）都能轻松阅读、理解和维护的代码。
- en: General naming principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名的一般原则
- en: Regardless of the specific **Object-Oriented Programming** (**OOP**) language
    you’re using, certain universal naming principles can help improve the clarity
    and maintainability of your code. These principles aim to ensure that names in
    your code provide sufficient information about their use and functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是哪种具体的**面向对象编程**（**OOP**）语言，某些通用的命名原则可以帮助提高代码的清晰性和可维护性。这些原则旨在确保代码中的名称提供了足够的信息关于它们的使用和功能。
- en: Descriptiveness
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述性
- en: Names should accurately describe the purpose or value of the variable, function,
    class, or method they are identifying. For instance, `getSalary()` for a function
    is more informative than simply `getS()`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 名称应准确描述变量、函数、类或方法的目的或值。例如，对于函数 `getSalary()` 比简单地 `getS()` 更有信息量。
- en: Consistency
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: Consistency in naming conventions is one of the most vital principles in writing
    clear and maintainable code. When you’re consistent with your naming throughout
    your code base, it becomes much easier to read, understand, and debug your code.
    The reason for this is that once a developer learns your naming pattern, they
    can apply their understanding across the entire code base, rather than having
    to figure out what each individual name means in isolation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名约定上的一致性是编写清晰且可维护代码的最重要原则之一。当你在整个代码库中保持命名的一致性时，阅读、理解和调试你的代码会变得容易得多。原因在于一旦开发者学会了你的命名模式，他们就可以在整个代码库中应用他们的理解，而无需单独弄清楚每个名称的含义。
- en: 'Consistency applies to many areas, including the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性适用于许多领域，包括以下内容：
- en: '`snake_case` (e.g., `employee_salary`), stick to that style throughout your
    entire code base. Don’t switch between snake_case, camelCase (e.g., `employeeSalary`),
    and PascalCase (e.g., `EmployeeSalary`).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `snake_case`（例如，`employee_salary`），在整个代码库中坚持这种风格。不要在 snake_case、camelCase（例如，`employeeSalary`）和
    PascalCase（例如，`EmployeeSalary`）之间切换。
- en: '`m_` for member variables (e.g., `m_value`), ensure this rule is followed everywhere.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_` 用于成员变量（例如，`m_value`），确保在所有地方遵循此规则。'
- en: '`num` to represent `number` (as in `numEmployees`), then always use `num` whenever
    you mean `number`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `num` 来表示 `number`（例如，`numEmployees`），然后始终在表示 `number` 时使用 `num`。
- en: '`Employee`), method names are verbs (`calculateSalary`), and Boolean variables
    or methods often start with `is`, `has`, `can`, or similar prefixes (`isAvailable`
    and `hasCompleted`). Stick with these conventions consistently.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名（例如，`Employee`），方法名是动词（`calculateSalary`），布尔变量或方法通常以 `is`、`has`、`can` 或类似的词缀开头（例如
    `isAvailable` 和 `hasCompleted`）。始终一致地遵循这些约定。
- en: Let’s say you’re working on a large code base where classes represent various
    types of employees in a company. You’ve decided to name your classes as singular
    nouns in PascalCase, methods as verbs in snake_case, and variables in snake_case
    too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理一个大型代码库，其中类代表公司中的各种员工类型。你已经决定使用 PascalCase 为类命名，使用 snake_case 为方法命名，以及使用
    snake_case 为变量命名。
- en: 'A consistent implementation of this naming convention might look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名约定的一个一致实现可能看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down this code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个代码片段：
- en: The `SoftwareEngineer` class is a singular noun and uses PascalCase
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoftwareEngineer` 类是一个单数名词，并使用 PascalCase'
- en: The `assign_task` method is a verb and uses snake_case
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assign_task` 方法是一个动词，并使用 snake_case'
- en: The variable `current_task` is in snake_case
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `current_task` 使用 snake_case
- en: Being consistent with this convention will help anyone reading your code to
    immediately recognize what each name represents. This way, the cognitive load
    is reduced, and developers can focus on the actual logic, rather than being distracted
    by inconsistent or confusing names.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与此约定保持一致将有助于任何阅读你代码的人立即识别每个名称所代表的内容。这样，认知负担就会减轻，开发者可以专注于实际的逻辑，而不是被不一致或混淆的名称所分散注意力。
- en: Unambiguity
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确性
- en: 'Unambiguity means that names should not be misleading. Avoid using names that
    could be interpreted in multiple ways, or that contradict established conventions
    or expectations. For example, suppose you have a `Document` class and a method
    named `process`. Without more context, the method name is ambiguous:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 明确性意味着名称不应具有误导性。避免使用可能被解释为多种方式或与既定约定或期望相矛盾的名字。例如，假设你有一个`Document`类和一个名为`process`的方法。在没有更多上下文的情况下，该方法名称是模糊的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, `process` could mean a number of things. Are we going to parse
    the document? Are we going to render it? Are we going to save it to a file? Or
    are we going to perform all these operations? It’s unclear.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`process`可能意味着许多事情。我们是解析文档吗？我们要渲染它吗？我们要将其保存到文件中吗？还是我们要执行所有这些操作？这并不明确。
- en: 'A more specific method name could help to clarify its purpose. Depending on
    what the method is supposed to do, it could be named `parse`, `render`, `save`,
    and so on:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更具体的方法名称可以帮助阐明其目的。根据该方法预期要执行的操作，它可以命名为`parse`、`render`、`save`等：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each of these method names gives a much clearer indication of what the method
    does, removing the ambiguity of the original `process` method name.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法名称的每个都提供了对方法所做工作的更清晰指示，消除了原始`process`方法名称的歧义。
- en: Pronounceability
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发音性
- en: Names should be easily pronounceable. This facilitates verbal communication
    about the code between developers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 名称应该易于发音。这有助于开发者之间就代码进行口头交流。
- en: Scope and lifetimes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围和生命周期
- en: Variables with larger scopes and longer lifetimes usually have more influence
    on a system and, hence, deserve more thoughtful, clear, and descriptive names.
    This helps ensure that they’re understood in all contexts where they’re used.
    Here’s a more detailed breakdown.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 范围更大、生命周期更长的变量通常对系统有更大的影响，因此需要更深思熟虑、清晰和描述性的名称。这有助于确保它们在所有使用它们的上下文中都能被理解。以下是一个更详细的分解。
- en: 'Global variables can be accessed from anywhere in a program, and their lifetime
    extends for the duration of the program. Therefore, they deserve especially careful
    consideration when naming. The name should be descriptive enough to clearly indicate
    its role in the system. Additionally, global variables can create unexpected dependencies,
    which makes the program harder to understand and maintain. Therefore, the use
    of global variables should be minimized:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量可以在程序的任何地方访问，并且其生命周期持续整个程序。因此，在命名时需要特别小心。名称应该足够描述性，以清楚地表明其在系统中的作用。此外，全局变量可能会创建意外的依赖关系，这使得程序更难以理解和维护。因此，应尽量减少全局变量的使用：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Class member variables can be accessed from any method within the class, and
    their lifetime is tied to the lifetime of the class instance. They should have
    clear and descriptive names that reflect their role within the class. It’s often
    useful to follow a naming convention that distinguishes them from local variables
    (e.g., an `m_` prefix or `_` suffix):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类成员变量可以从类中的任何方法访问，并且它们的生命周期与类实例的生命周期绑定。它们应该有清晰且描述性的名称，反映其在类中的角色。通常，遵循一个命名约定来区分它们与局部变量是有用的（例如，使用`m_`前缀或`_`后缀）：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Local variables are confined to a specific function or block and exist only
    for the duration of that function or block. These variables typically need less
    descriptive names compared to global variables or class members, but they should
    still clearly convey their purpose:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量仅限于特定的函数或代码块，并且只存在于该函数或代码块执行期间。与全局变量或类成员变量相比，这些变量通常需要更简洁的命名，但它们仍然应该清楚地传达其用途：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Loop variables and temporary variables have the shortest scope and lifetime,
    usually confined to a small loop or a small block of code. As a result, they typically
    have the simplest names (such as `i`, `j`, and `temp`):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 循环变量和临时变量具有最短的范围和生命周期，通常局限于一个小循环或一小段代码。因此，它们通常具有最简单的名称（如`i`、`j`和`temp`）：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key idea here is, the broader the scope and the longer the lifetime of a
    variable, the more potential there is for confusion about its purpose, so the
    more descriptive its name should be. The goal is to make code as clear and understandable
    as possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键思想是，变量的作用域越广，生命周期越长，对其用途的混淆可能性就越大，因此其名称应该越具有描述性。目标是使代码尽可能清晰易懂。
- en: Avoid encoding type or scope information
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免编码类型或作用域信息
- en: 'In modern programming languages, encoding type or scope information into names
    (often known as Hungarian notation) is usually unnecessary and can lead to confusion
    or errors, especially when refactoring. While this can occasionally be helpful,
    especially in languages with weak typing, it has several downsides that make it
    less suitable for use in strongly typed languages such as C++:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代编程语言中，将类型或作用域信息编码到名称中（通常称为匈牙利符号法）通常是多余的，并且可能导致混淆或错误，尤其是在重构时。虽然这偶尔可能有所帮助，尤其是在弱类型语言中，但它有几个缺点，使得它不太适合用于像C++这样的强类型语言：
- en: The type of a variable might change in the future, but its name often doesn’t.
    This leads to misleading situations where a variable’s name suggests one type
    but it actually has another. For example, you might start with a vector of IDs
    (`std::vector<Id> id_array`) and later change it to `set<Id>` to avoid duplication,
    but the variable name still suggests it’s an array or vector.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的类型可能会在未来改变，但它的名字通常不会。这导致了一些误导性的情况，其中变量的名字暗示了一种类型，但实际上它具有另一种类型。例如，你可能从一个ID向量（`std::vector<Id>
    id_array`）开始，后来将其更改为 `set<Id>` 以避免重复，但变量名仍然暗示它是一个数组或向量。
- en: 'Modern development environments provide features such as type inference, hovering
    tooltips showing types, and powerful refactoring tools, which all make manually
    encoding types into names largely redundant. For example, VS Code with the clangd
    plugin installed and the “inlay hints” feature turned on deducts types on the
    fly, including `auto`:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代开发环境提供了诸如类型推断、显示类型的悬停工具提示和强大的重构工具等功能，这些都使得手动将类型编码到名称中变得几乎不再必要。例如，安装了clangd插件并开启了“内联提示”功能的VS
    Code会动态推断类型，包括 `auto`：
- en: '![Figure 5.1 – Inlay hints in VS Code](img/B19606_05_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – VS Code中的内联提示](img/B19606_05_01.jpg)'
- en: Figure 5.1 – Inlay hints in VS Code
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – VS Code中的内联提示
- en: 'This applies to CLion by JetBrains too:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于JetBrains的CLion：
- en: Prefixes in Hungarian notation can make variable names harder to read, especially
    for those not familiar with the notation. It may not be immediately obvious to
    a new developer what `dwCount` (a `DWORD`, or double word, often used to represent
    an unsigned long integer) means.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匈牙利符号法中的前缀可能会使变量名更难以阅读，尤其是对于那些不熟悉这种符号的人来说。对于新开发者来说，`dwCount`（一个 `DWORD`，或双字，通常用来表示无符号长整数）的含义可能并不立即明显。
- en: 'Strongly typed languages such as C++ already check type safety at compile time,
    reducing the need to encode type information in the variable name. In the following
    example, `integers` is declared as `std::vector<int>`, and `sentence` is declared
    as `std::string`. The C++ compiler is aware of these types and will ensure that
    operations on these variables are type-safe:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型语言，如C++，已经在编译时检查类型安全，减少了在变量名中编码类型信息的需要。在下面的示例中，`integers` 被声明为 `std::vector<int>`，而
    `sentence` 被声明为 `std::string`。C++ 编译器知道这些类型，并将确保对这些变量的操作是类型安全的：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the code attempts to assign `sentence` to `integers`, a compile-time error
    is produced because `sentence` is not of the correct type (`std::vector<int>`).
    This happens despite the fact that neither of the variable names encode type information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码尝试将 `sentence` 赋值给 `integers` 时，会产生编译时错误，因为 `sentence` 的类型不正确（`std::vector<int>`）。尽管这两个变量名都没有编码类型信息，这种情况仍然会发生。
- en: The compiler’s type-checking eliminates the need to include the type in the
    variable names (such as `strSentence` or `vecIntegers`), a practice common in
    languages that do not perform such strong compile-time type-checking. The `integers`
    and `sentence` variable names are sufficiently descriptive without encoding the
    type information.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的类型检查消除了在变量名中包含类型信息（如 `strSentence` 或 `vecIntegers`）的需要，这在没有执行此类强编译时类型检查的语言中是一种常见的做法。`integers`
    和 `sentence` 变量名已经足够描述性，无需编码类型信息。
- en: In programming, you often come across situations where multiple logical concepts
    are represented using the same underlying type. For instance, you may have identifiers
    for `Users` and `Products` in your system, both of which are represented as integers.
    While C++’s static type checking provides a level of safety, it won’t differentiate
    between `UserId` and `ProductId` – they’re both just integers as far as the compiler
    is concerned.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，你经常会遇到多个逻辑概念使用相同的底层类型来表示的情况。例如，在你的系统中，你可能既有`Users`的标识符，也有`Products`的标识符，它们都表示为整数。虽然C++的静态类型检查提供了一定程度的安全性，但它不会区分`UserId`和`ProductId`——对编译器来说，它们只是整数。
- en: However, using the same type for these different concepts can lead to bugs.
    It’s entirely possible, for example, to mistakenly pass `UserId` where `ProductId`
    was expected, and the compiler wouldn’t catch this error.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用相同的类型来表示这些不同的概念可能会导致错误。例如，错误地传递`UserId`而不是预期的`ProductId`是完全可能的，编译器不会捕获这个错误。
- en: 'To address this issue, you can leverage C++’s rich type system to introduce
    new types representing these different concepts, even when they share the same
    underlying representation. This way, the compiler can catch these bugs at compile
    time, enhancing the robustness of your software:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以利用C++丰富的类型系统引入代表这些不同概念的新类型，即使它们具有相同的底层表示。这样，编译器可以在编译时捕获这些错误，增强你软件的健壮性：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, `UserId` and `ProductId` are distinct types. Even
    though their underlying representation is the same (`int`), passing `ProductId`
    to a function expecting `UserId` results in a compile-time error. This adds an
    additional layer of type safety to your code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`UserId`和`ProductId`是不同的类型。尽管它们的底层表示相同（`int`），但将`ProductId`传递给期望`UserId`的函数会导致编译时错误。这为你代码增加了额外的类型安全性。
- en: This is just a glimpse into how you can utilize C++’s rich static type system
    to create more robust and safer code. We will delve into this topic in more detail
    in [*Chapter 6*](B19606_06.xhtml#_idTextAnchor092), *Utilizing a Rich Static Type
    System* *in C++*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是展示了如何利用C++丰富的静态类型系统来创建更健壮和更安全的代码。我们将在[*第6章*](B19606_06.xhtml#_idTextAnchor092)“在C++中利用丰富的静态类型系统”中更详细地探讨这个话题。
- en: Class and method naming
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和方法命名
- en: In OOP languages, classes represent concepts or things, and their instances
    (objects) are specific manifestations of those things. As such, both class names
    and their instances are most appropriately named using nouns or noun phrases.
    They represent entities in the system, whether they’re tangible (such as `Employee`
    and `Invoice`) or conceptual (such as `Transaction` and `DatabaseConnection`).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，类代表概念或事物，它们的实例（对象）是这些事物的具体表现。因此，类名及其实例最恰当地使用名词或名词短语来命名。它们代表系统中的实体，无论是有形的（如`Employee`和`Invoice`）还是概念性的（如`Transaction`和`DatabaseConnection`）。
- en: On the other hand, methods in classes typically represent actions that an object
    of that class can perform, or messages that can be sent to it. As such, they’re
    most effectively named using verbs or verb phrases. They act as instructions that
    can be carried out by the object, allowing it to interact with other objects in
    meaningful ways.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类中的方法通常代表该类对象可以执行的动作，或者可以发送给它的消息。因此，它们最有效地使用动词或动词短语来命名。它们作为可以被对象执行的操作指令，允许它以有意义的方式与其他对象进行交互。
- en: Consider a `Document` class with a `print` method. We can say “document, print”
    or “print the document,” which is a clear, imperative statement in line with how
    we might communicate the action in everyday language.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有`print`方法的`Document`类。我们可以说“document, print”或“print the document”，这是一个符合我们日常语言中传达动作方式的清晰、祈使性陈述。
- en: 'Here’s an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This noun-verb consistency in naming classes and methods aligns well with the
    way we naturally understand and communicate about objects and actions in the real
    world, contributing to the readability and comprehensibility of our code. Moreover,
    it lends itself well to the principle of encapsulation in OOP, where objects manage
    their own behavior (methods) and state (member variables).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名类和方法时，名词-动词的一致性与我们自然理解和交流现实世界中的对象和动作的方式非常吻合，有助于提高我们代码的可读性和可理解性。此外，它很好地符合面向对象中的封装原则，其中对象管理自己的行为（方法）和状态（成员变量）。
- en: Maintaining this convention allows developers to write code that’s more intuitive,
    self-documenting, and easier to maintain. It creates a common language and understanding
    among developers, reducing the cognitive load when reading code and making the
    code base easier to navigate and reason about. Therefore, it’s recommended to
    adhere to these conventions in OOP.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 维持这个约定可以让开发者编写更直观、自文档化和易于维护的代码。它为开发者之间创造了一种共同的语言和理解，减少了阅读代码时的认知负荷，并使代码库更容易导航和推理。因此，在面向对象编程中，建议遵守这些约定。
- en: Naming variables
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量命名
- en: Variable names should reflect the data they hold. A good variable name describes
    the kind of value the variable contains, not just its purpose in the algorithm
    you’ve written.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名应该反映它们所持有的数据。一个好的变量名描述了变量包含的值的类型，而不仅仅是它在算法中的作用。
- en: 'Avoiding magic numbers, Numerical values with unexplained meanings in the source
    code. They can lead to code that is harder to read, understand, and maintain.
    Let’s consider a `MessageSender` class that sends messages, and if a message size
    is greater than a certain limit, it splits the message into chunks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 避免魔法数字，源代码中具有未解释含义的数值。它们可能导致难以阅读、理解和维护的代码。让我们考虑一个`MessageSender`类，它发送消息，如果消息大小超过某个限制，它将消息分割成块：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, `1024` is a magic number. It likely represents a maximum
    message size, but it’s not immediately clear. It can confuse others (or future
    you) reading your code. Here’s a refactored example with a named constant:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`1024`是一个魔法数字。它可能代表一个最大消息大小，但并不立即清楚。它可能会使阅读你代码的人（或未来的你）感到困惑。以下是一个使用命名常量的重构示例：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this refactored version, we’ve replaced the magic number `1024` with a named
    constant, `MAX_MESSAGE_SIZE`. It’s now clear that `1024` is the maximum message
    size. Using named constants in this way makes your code more readable and maintainable.
    If the maximum message size needs to change in the future, you only need to update
    it in one place.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构版本中，我们将魔法数字`1024`替换为命名常量`MAX_MESSAGE_SIZE`。现在很清楚，`1024`是最大消息大小。以这种方式使用命名常量使你的代码更易于阅读和维护。如果将来需要更改最大消息大小，你只需在一个地方更新即可。
- en: Utilize namespaces
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用命名空间
- en: Namespaces in C++ are incredibly valuable in preventing naming conflicts and
    properly structuring your code. The issue of naming conflicts, or collisions,
    arises when two or more identifiers in a program bear the same name. For instance,
    you might have a class named `Id` in two subsystems of your application – networking
    representing a connection ID and user ID in user management. Using them both without
    namespaces would cause a naming collision, and the compiler wouldn’t know which
    `Id` you are referring to in your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的命名空间在防止命名冲突和正确组织代码方面极其宝贵。命名冲突，或称碰撞，发生在程序中的两个或多个标识符具有相同名称时。例如，你可能在应用程序的两个子系统（网络表示连接ID和用户管理中的用户ID）中都有一个名为`Id`的类。如果不使用命名空间使用它们，就会导致命名冲突，编译器将不知道在代码中你指的是哪个`Id`。
- en: To mitigate this, C++ provides the `namespace` keyword to encapsulate a functionality
    under a unique name. Namespaces are designed to solve the problem of name conflicts.
    By wrapping your code inside a namespace, you prevent it from colliding with same-named
    identifiers in other portions of your code or third-party libraries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，C++提供了`namespace`关键字来封装一个具有独特名称的功能。命名空间旨在解决名称冲突的问题。通过将你的代码包裹在一个命名空间内，你可以防止它与代码其他部分或第三方库中具有相同名称的标识符发生冲突。
- en: 'Here’s an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, `product_name::Router` won’t conflict with any other `Router`
    class in your product’s code or a third-party library. If you develop library
    code, it is highly recommended to wrap all its entities, such as classes, functions,
    and variables, in a namespace. This will prevent name clashes with other libraries
    or the user’s code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`product_name::Router`不会与你的产品代码或第三方库中的任何其他`Router`类冲突。如果你开发库代码，强烈建议将所有实体（如类、函数和变量）都包裹在一个命名空间中。这将防止与其他库或用户代码发生名称冲突。
- en: 'It’s common in C++ to mirror the project’s directory structure with namespaces,
    making it easier to understand where different parts of the code base are located.
    For example, if you have a file at the `ProductRepo/Networking/Router.cpp` path,
    you might declare the `Router` class like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，将项目的目录结构映射到命名空间中是很常见的，这使得理解代码库的不同部分所在的位置变得更容易。例如，如果你有一个位于`ProductRepo/Networking/Router.cpp`路径的文件，你可能会这样声明`Router`类：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can then refer to the class with the fully qualified name `product_name::networking::Router`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用完全限定名称 `product_name::networking::Router` 来引用该类。
- en: However, it’s worth noting that until C++20, the language didn’t natively support
    a module system that could replace or enhance the functionality provided by namespaces.
    With the arrival of modules in C++20, some of the practices might be changing,
    but understanding namespaces and their usage in naming is still vital.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，直到 C++20 之前，该语言并没有原生支持一个可以替代或增强命名空间提供的功能的模块系统。随着 C++20 中模块的到来，一些实践可能会发生变化，但理解命名空间及其在命名中的使用仍然至关重要。
- en: 'Another way to use namespaces is to express the complexity levels of your code.
    For example, library code may have entities expected to be used by library consumers
    and internal ones. The following code snippet demonstrates this approach:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间的另一种方式是表达代码的复杂程度。例如，库代码可能包含预期由库消费者使用的实体和内部实体。以下代码片段展示了这种方法：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this extended example, the `communication::Client` class provides a high-level
    interface for sending and receiving messages. It uses the `advanced::http::Client`
    class for the actual implementation, but this detail is hidden from the users
    of the library. They don’t need to know about the advanced class unless they aren’t
    satisfied with the functionality provided by the default client and need more
    control.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个扩展示例中，`communication::Client` 类提供了一个用于发送和接收消息的高级接口。它使用 `advanced::http::Client`
    类进行实际实现，但这个细节对库的用户来说是隐藏的。除非他们对默认客户端提供的功能不满意并需要更多控制，否则他们不需要了解高级类。
- en: The `Client` class, in the `communication::http::advanced` namespace, provides
    more low-level functionality that gives users more control over the details of
    the communication.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `communication::http::advanced` 命名空间中的 `Client` 类提供了更多低级功能，使用户能够更多地控制通信的细节。
- en: This organization makes it clear what functionality is intended for most users
    (`Client`) and what is provided for more advanced usage (`HttpClient`). Using
    namespaces in this way also helps avoid name clashes and keeps the code base well-organized.
    This approach is used by many libraries and frameworks – for example, it’s common
    for Boost libraries to have a `detail` namespace for internal implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式清楚地说明了大多数用户（`Client`）期望的功能以及为更高级使用（`HttpClient`）提供的功能。以这种方式使用命名空间也有助于避免名称冲突并保持代码库井然有序。这种方法被许多库和框架所采用——例如，Boost
    库通常有一个 `detail` 命名空间用于内部实现。
- en: The use of domain-specific language
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特定领域的语言
- en: If there are well-established terms in the problem domain, use them in your
    code. This can make your code easier to understand for people familiar with the
    domain. For example, in finance, terms such as “portfolio,” “asset,” “bond,” “equity,”
    “ticker,” and “dividend” are commonly used. If you’re writing an application related
    to finance, it’s beneficial to use these terms in your class and variable names,
    as they clearly convey their roles to anyone with a background in finance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题域中有公认的术语，请在您的代码中使用它们。这可以使熟悉该领域的人更容易理解您的代码。例如，在金融领域，术语“投资组合”、“资产”、“债券”、“股票”、“股票代码”和“股息”是常用的。如果您正在编写与金融相关的应用程序，使用这些术语作为类和变量名称是有益的，因为它们清楚地传达了它们在金融背景下的角色。
- en: 'Consider the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, `Portfolio`, `Asset`, `Bond`, `Equity`, `Ticker`, and `total_dividend()`
    are all terms that are directly borrowed from the domain of finance. A developer
    or stakeholder who’s familiar with finance will understand the purpose of these
    classes and methods just by their names. This helps to create a common language
    between the developers, stakeholders, and domain experts, which can greatly facilitate
    communication and understanding. Note that it is not recommended to use `double`
    in real-world financial applications, as it does not have an accurate enough representation
    to prevent rounding errors from accumulating when doing arithmetic with monetary
    values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`Portfolio`、`Asset`、`Bond`、`Equity`、`Ticker` 和 `total_dividend()` 都是直接从金融领域借用的术语。熟悉金融的开发者或利益相关者只需通过它们的名称就能理解这些类和方法的目的。这有助于在开发者、利益相关者和领域专家之间建立共同语言，从而极大地促进沟通和理解。请注意，在现实世界的金融应用中不推荐使用
    `double`，因为它不足以精确表示货币值进行算术运算时防止舍入误差累积。
- en: Remember, the goal of these principles is to make your code as clear and easy
    to understand as possible. Writing code is not just about communicating with the
    computer; it’s also about communicating with other developers, including your
    future self.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些原则的目标是使代码尽可能清晰易懂。编写代码不仅仅是与计算机交流；它也是与其他开发者交流，包括你未来的自己。
- en: Balancing long names and comments in code
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中平衡长名称和注释
- en: Proper naming conventions play a critical role in the clarity and readability
    of your code. Names of classes, methods, and variables should be descriptive enough
    to convey their purpose and functionality. Ideally, a well-chosen name can replace
    the need for additional comments, making your code self-explanatory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的命名规范在代码的清晰性和可读性中起着至关重要的作用。类、方法和变量的名称应该足够描述性，以便传达其目的和功能。理想情况下，一个精心挑选的名称可以替代额外的注释，使代码易于理解。
- en: However, there’s a delicate balance to be struck. While long, descriptive names
    can be helpful, excessively long names can also be cumbersome and detract from
    the readability of code. On the other hand, overly short names can be ambiguous
    and make the code harder to understand. The key is to find the right balance –
    names should be long enough to convey their purpose, but not so long as to be
    unwieldy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要找到一个微妙的平衡点。虽然长而描述性的名称可能有所帮助，但过长的名称也可能变得繁琐，并降低代码的可读性。另一方面，过短的名称可能含糊不清，并使代码更难以理解。关键是找到正确的平衡——名称应该足够长以传达其目的，但又不至于过长而难以驾驭。
- en: 'Consider this example from a hypothetical networking application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一个假设的网络应用程序的例子：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the `route` method name and the `message`, `receiver`, and `message_content`
    variable names are all sufficiently descriptive to understand what the method
    does and what each variable represents. Additional comments to explain their roles
    aren’t necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`route` 方法名称以及 `message`、`receiver` 和 `message_content` 变量名称都足够描述性，可以理解方法的作用以及每个变量的含义。不需要额外的注释来解释它们的作用。
- en: That being said, there are cases where language constructs can’t fully express
    the intent or nuances of your code, such as when relying on specific behavior
    from a third-party library or when coding a complex algorithm. In these cases,
    additional comments are necessary to provide context or explain why certain decisions
    were made.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有些情况下，语言结构无法完全表达代码的意图或细微差别，例如当依赖于第三方库的特定行为或编写复杂算法时。在这些情况下，需要额外的注释来提供上下文或解释为什么做出了某些决定。
- en: 'Take this, for instance:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以此为例：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, the comment is necessary to highlight a specific behavior of the
    third-party routing library, which isn’t immediately apparent from the language
    constructs alone.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，注释是必要的，以突出第三方路由库的特定行为，这些行为仅从语言结构本身来看并不立即明显。
- en: As a general rule, strive to make your code as self-explanatory as possible
    through good naming practices, but don’t hesitate to use comments when they’re
    necessary to provide important context or clarify complex logic. Remember, the
    ultimate goal is to create code that is easy to read, understand, and maintain.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，应努力通过良好的命名实践使代码尽可能具有自解释性，但在需要提供重要上下文或阐明复杂逻辑时，不要犹豫使用注释。记住，最终目标是创建易于阅读、理解和维护的代码。
- en: Exploring popular C++ coding conventions – Google, LLVM, and Mozilla
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索流行的C++编码规范——谷歌、LLVM和Mozilla
- en: 'In the realm of C++ programming, adhering to a consistent coding convention
    is crucial to ensure code clarity and maintainability. Among the myriad of styles
    available, three prominent conventions stand out for their widespread use and
    distinct approaches – Google’s C++ Style Guide, LLVM Coding Standards, and Mozilla’s
    Coding Style. This overview delves into the key aspects of each, highlighting
    their unique practices and philosophies:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++编程领域，遵循一致的编码规范对于确保代码清晰性和可维护性至关重要。在众多可用的风格中，三种突出的规范因其广泛的使用和独特的做法而脱颖而出——谷歌的C++风格指南、LLVM编码标准和Mozilla的编码风格。本概述深入探讨了每个规范的关键方面，突出了它们的独特实践和哲学：
- en: '`.cc` and `.h` extensions for implementation and header files, respectively'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cc` 和 `.h` 扩展名分别用于实现文件和头文件'
- en: '`kCamelCase`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kCamelCase`'
- en: '`CamelCase` for class names'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CamelCase` 用于类名'
- en: '`*` or `&` with the variable name (`int* ptr`, not `int *ptr`)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 或 `&` 与变量名一起使用（`int* ptr`，而不是 `int *ptr`）'
- en: '**Limitations**: Avoid non-const global variables, and prefer algorithms over
    loops where possible'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：避免使用非const全局变量，并在可能的情况下优先使用算法而不是循环'
- en: '`.cpp` extension, and header files use `.h`.*   `camelBack` style. Member variables
    have a trailing underscore.*   `CamelCase`.*   `*` or `&` adjacent to the type
    (`int *ptr`, not `int* ptr`).*   **Modern C++ usage**: Encourages the use of modern
    C++ features and patterns.*   `.cpp` and `.``h` extensions*   `camelCase` for
    variables and functions, `CamelCase` for classes, and `SCREAMING_SNAKE_CASE` for
    constants*   `CamelCase` is used for class names*   `*` or `&` adjacent to the
    type*   **Emphasis on performance**: Encourages writing efficient code with a
    focus on browser performance'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cpp` 扩展名，以及头文件使用 `.h`。*   `camelBack` 风格。成员变量有一个尾随下划线。*   `CamelCase`。*   `*`
    或 `&` 靠近类型（`int *ptr`，而不是 `int* ptr`）。*   **现代C++用法**：鼓励使用现代C++特性和模式。*   `.cpp`
    和 `.h` 扩展名*   变量和函数使用 `camelCase`，类使用 `CamelCase`，常量使用 `SCREAMING_SNAKE_CASE`。*   类名使用
    `CamelCase`。*   `*` 或 `&` 靠近类型*   **强调性能**：鼓励编写注重浏览器性能的效率代码'
- en: Each of these conventions has its own philosophy and rationale. Google’s style
    guide emphasizes consistency within a vast code base and across a large number
    of developers. LLVM’s standards focus on clean, efficient code that leverages
    modern C++ features. Mozilla’s style balances readability and performance, reflecting
    its origins in web technology development. It’s important to choose a style that
    aligns with your project’s goals, team size, and the specific technologies you
    work with.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些约定都有其自身的哲学和理由。谷歌的风格指南强调在庞大的代码库和众多开发者之间保持一致性。LLVM的标准侧重于编写干净、高效的代码，利用现代C++特性。Mozilla的风格在可读性和性能之间取得平衡，反映了其在网络技术发展中的起源。选择与你的项目目标、团队规模以及你工作的具体技术相一致的风格是很重要的。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the critical role of naming programming. We recognized
    that good, consistent naming practices elevate the readability and maintainability
    of code, while also aiding in its self-documentation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了命名在编程中的关键作用。我们认识到，良好的、一致的命名实践可以提高代码的可读性和可维护性，同时也有助于其自我文档化。
- en: We pondered over the balance between using long descriptive names and shorter
    names supplemented by comments, understanding that both have their place in different
    contexts. The use of domain-specific language in naming was recommended for clarity,
    while “magic numbers” were cautioned against due to their opacity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们思考了使用长描述性名称和较短名称并辅以注释之间的平衡，理解到在不同的上下文中两者都有其位置。建议在命名中使用领域特定语言以提高清晰度，同时由于它们的不可透明性而警告不要使用“魔法数字”。
- en: The influence of a variable’s scope and lifetime on its naming was also discussed,
    emphasizing the need for more descriptive names for those variables with larger
    scopes and longer lifetimes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域和生命周期对其命名的影响也得到了讨论，强调了为那些作用域较大、生命周期较长的变量使用更具描述性的名称的必要性。
- en: The chapter wrapped up by stressing the value of adhering to a coding convention
    for naming, which instills consistency across the code base, thereby streamlining
    the code reading and comprehension process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以强调遵循命名编码规范的价值结束，这可以在代码库中建立一致性，从而简化代码的阅读和理解过程。
- en: The insights garnered from this chapter serve as a foundation for the upcoming
    discussion on effectively leveraging the rich static type system in C++ for safer,
    cleaner, and clearer code. In the next chapter, we will shift our focus to the
    effective utilization of C++’s rich static type system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中获得的认识为即将讨论如何有效地利用C++丰富的静态类型系统以编写更安全、更干净、更清晰的代码奠定了基础。在下一章中，我们将把重点转移到有效地利用C++丰富的静态类型系统上。
