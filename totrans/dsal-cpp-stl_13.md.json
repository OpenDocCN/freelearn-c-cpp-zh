["```cpp\nstd::vector<int> vec(5);\nstd::iota(vec.begin(), vec.end(), 1);\n// vec now holds: {1, 2, 3, 4, 5}\n```", "```cpp\n#include <iostream>\n#include <numeric>\n#include <vector>\nint main() {\n  const int numTimeSteps = 100;\n  std::vector<double> timeSteps(numTimeSteps);\n  // Generate a sequence of time steps using std::iota\n  double timeStep = 0.01; // Time step size\n  std::iota(timeSteps.begin(), timeSteps.end(), 0);\n  // Scale the time steps to represent actual time\n  for (double &t : timeSteps) { t *= timeStep; }\n  // Now, timeSteps contains a sequence of time points for\n  // simulation\n  // Simulate a simple system over time (e.g., particle\n  // movement)\n  for (const double t : timeSteps) {\n    // Simulate the system's behavior at time t\n    // ...\n    std::cout << \"Time: \" << t << std::endl;\n  }\n  return 0;\n}\n```", "```cpp\nTime:0\nTime: 0.01\nTime: 0.02\nTime: 0.03\nTime: 0.04\nTime: 0.05\n...\n```", "```cpp\nstd::vector<int> vec = {1, 2, 3, 4, 5};\nint sum = std::accumulate(vec.begin(), vec.end(), 0);\n// sum will be 15\n```", "```cpp\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <vector>\nint main() {\n  std::vector<std::string> words = {\"Hello\", \", \", \"world\",\n                                    \"!\"};\n  std::string concatenated = std::accumulate(\n      words.begin(), words.end(), std::string(\"\"),\n      [](const std::string &x, const std::string &y) {\n        return x + y;\n      });\n  std::cout << \"Concatenated string: \" << concatenated\n            << std::endl;\n  return 0;\n}\n```", "```cpp\nConcatenated string: Hello, world!\n```", "```cpp\nstd::vector<int> vec = {2, 4, 6, 8, 10};\nstd::vector<int> result(5);\nstd::adjacent_difference(vec.begin(), vec.end(), result.begin());\n// result holds: {2, 2, 2, 2, 2}\n```", "```cpp\n#include <iostream>\n#include <numeric>\n#include <vector>\nint main() {\n  std::vector<double> values = {8.0, 16.0, 64.0, 256.0,\n                                4096.0};\n  // Create a vector to store the calculated ratios\n  std::vector<double> ratios(values.size());\n  // Write a lambda to use in adjacent_difference\n  auto lambda = [](double x, double y) {\n    if (x == 0.0) {\n      // Handle division by zero for the first element\n      return 0.0;\n    } else {\n      // Calculate the ratio between y and x\n      return y / x;\n    }\n  };\n  // Calculate the ratios between consecutive elements\n  std::adjacent_difference(values.begin(), values.end(),\n                           ratios.begin(), lambda);\n  // The first element in the ratios vector is 0.0 because\n  //there's no previous element\n  // Print the calculated ratios for the remaining elements\n  std::cout << \"Ratios between consecutive elements:\\n\";\n  for (size_t i = 1; i < ratios.size(); ++i) {\n    std::cout << \"Ratio \" << i << \": \" << ratios[i]\n              << \"\\n\";\n  }\n  return 0;\n}\n```", "```cpp\nRatios between consecutive elements:\nRatio 1: 0.5\nRatio 2: 0.25\nRatio 3: 0.25\nRatio 4: 0.0625\n```", "```cpp\nstd::vector<int> vec1 = {1, 2, 3};\nstd::vector<int> vec2 = {4, 5, 6};\nint product = std::inner_product(vec1.begin(), vec1.end(),\n                                 vec2.begin(), 0);\n// product will be 32 (because 1*4 + 2*5 + 3*6 = 32)\n```", "```cpp\n#include <execution>\n#include <iostream>\n#include <numeric>\n#include <vector>\nint main() {\n  // Create a large vector of numbers\n  const int dataSize = 1000000;\n  std::vector<int> numbers(dataSize);\n  // Initialize the vector with some values (e.g., 1 to\n  // dataSize)\n  std::iota(numbers.begin(), numbers.end(), 1);\n  // Calculate the sum of the numbers in parallel\n  int parallelSum = std::reduce(\n      std::execution::par, numbers.begin(), numbers.end());\n  std::cout << \"Parallel Sum: \" << parallelSum\n            << std::endl;\n  return 0;\n}\n```", "```cpp\nParallel Sum: 1784293664\n```", "```cpp\n#include <algorithm>\n#include <execution>\n#include <iostream>\n#include <numeric>\n#include <vector>\nint main() {\n  const long int dataSize = 1000;\n  std::vector<long int> numbers(dataSize);\n  std::iota(numbers.begin(), numbers.end(), 1);\n  // Use std::transform_reduce to square each element and\n  // sum them up in parallel\n  long int parallelSumOfSquares = std::transform_reduce(\n      std::execution::par, numbers.begin(), numbers.end(),\n      0, // Initial value for the accumulation\n      std::plus<long int>(),\n      [](long int x) { return x * x; });\n  std::cout << \"Parallel Sum of Squares:\"\n            << parallelSumOfSquares << \"\\n\";\n  return 0;\n}\n```", "```cpp\nParallel Sum of Squares: 333833500\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> d = {10, 20, 30, 40, 50,\n                        60, 70, 80, 90};\n  int tgt = 40;\n  auto lb = std::lower_bound(d.begin(), d.end(), tgt);\n  auto ub = std::upper_bound(d.begin(), d.end(), tgt);\n  bool exists =\n      std::binary_search(d.begin(), d.end(), tgt);\n  std::vector<int> set1 = {10, 20, 30, 40, 50};\n  std::vector<int> set2 = {30, 40, 50, 60, 70};\n  std::vector<int> intersection(\n      std::min(set1.size(), set2.size()));\n  auto it = std::set_intersection(set1.begin(), set1.end(),\n                                  set2.begin(), set2.end(),\n                                  intersection.begin());\n  std::vector<int> difference(\n      std::max(set1.size(), set2.size()));\n  auto diffEnd = std::set_difference(\n      set1.begin(), set1.end(), set2.begin(), set2.end(),\n      difference.begin());\n  bool isSorted = std::is_sorted(d.begin(), d.end());\n  std::cout << \"Lower Bound:\"\n            << std::distance(d.begin(), lb) << \"\\n\";\n  std::cout << \"Upper Bound:\"\n            << std::distance(d.begin(), ub) << \"\\n\";\n  std::cout << \"Exists: \" << exists << \"\\n\";\n  std::cout << \"Intersection: \";\n  for (auto i = intersection.begin(); i != it; ++i)\n    std::cout << *i << \" \";\n  std::cout << \"\\n\";\n  std::cout << \"Difference: \";\n  for (auto i = difference.begin(); i != diffEnd; ++i)\n    std::cout << *i << \" \";\n  std::cout << \"\\n\";\n  std::cout << \"Is Sorted: \" << isSorted << \"\\n\";\n  return 0;\n}\n```", "```cpp\nLower Bound: 3\nUpper Bound: 4\nExists: 1\nIntersection: 30 40 50\nDifference: 10 20\nIs Sorted: 1\n```"]