<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1.   Get Your Qt Feet Wet  </h1></div></div></div><p>If you know C++ but have never touched Qt, or if you have made some intermediate Qt applications, this chapter will ensure that your Qt foundations are safe before studying advanced concepts in the following chapters.</p><p>We will teach you to create a simple todo application using Qt Creator. This application will display a list of tasks that you can create/update/delete. We will cover the Qt Creator and Qt Designer interfaces, an introduction to the signal/slot mechanism, the creation of a custom widget with custom signals/slots, and its integration into your application.</p><p>You will implement a todo app using new C++14 semantics: lambdas, auto variables, and for loops. Each one of these concepts will be explained in depth and will be used throughout the book.</p><p>At the end of this chapter, you will be able to create a desktop application with a flexible UI using Qt widgets and new C++ semantics.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Qt project basic structure</li><li class="listitem">Qt Designer interface</li><li class="listitem">UI fundamentals</li><li class="listitem">Signals and slots</li><li class="listitem">Custom <code class="literal">QWidget</code></li><li class="listitem">C++14 lambda, auto, for each</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec7"/>Creating a project</h1></div></div></div><p>The first thing to do is to start Qt Creator.</p><p>In Qt Creator, you can create a new Qt project via <strong>File</strong> | <strong>New File or Project</strong> | <strong>Application</strong> | <strong>Qt Widgets Application</strong> | <strong>Choose</strong>.</p><p>The wizard will then guide you through four steps:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Location</strong>: You must choose a project name and a location.</li><li class="listitem"><strong>Kits</strong>: Target platforms that your project aims at (Desktop, Android, and so on).</li><li class="listitem"><strong>Details</strong>: Base class information and name for the generated class.</li><li class="listitem"><strong>Summary</strong>: Allows you to configure your new project as a subproject and automatically add it to a version control system.</li></ol><div></div><p>Even if all default values can be kept, please at least set a useful project name such as "todo" or "TodoApp." We won't blame you if you want to call it "Untitled" or "Hello world."</p><p>Once done, Qt Creator will generate several files that you can see in the <strong>Projects</strong> hierarchy view:</p><div><img src="img/image00350.jpeg" alt="Creating a project"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">.pro</code> file is Qt's configuration project file. As Qt adds specific file formats and C++ keywords, an intermediate build step is performed, parsing all files to generate final files. This process is done by <code class="literal">qmake</code>, an executable from the Qt SDK. It will also generate the final Makefiles for your project.</p><p>A basic <code class="literal">.pro</code> file generally contains:</p><div><ul class="itemizedlist"><li class="listitem">Qt modules used (<code class="literal">core</code>, <code class="literal">gui</code>, and so on)</li><li class="listitem">Target name (<code class="literal">todo</code>, <code class="literal">todo.exe</code>, and so on)</li><li class="listitem">Project template (<code class="literal">app</code>, <code class="literal">lib</code>, and so on)</li><li class="listitem">Sources, headers, and forms</li></ul></div><p>There are some great features that come with Qt and C++14. This book will showcase them in all its projects. For <code class="literal">GCC</code> and <code class="literal">CLANG</code> compilers, you must add <code class="literal">CONFIG += c++14</code> to the <code class="literal">.pro</code> file to enable C++14 on a Qt project, as shown in the following code:</p><pre class="programlisting">QT       += core gui 
CONFIG   += c++14 
 
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets 
 
TARGET = todo 
TEMPLATE = app 
 
SOURCES += main.cpp \ 
           MainWindow.cpp 
 
HEADERS  += MainWindow.h \ 
 
FORMS    += MainWindow.ui \ 
</pre><p>The <code class="literal">MainWindow.h</code> and <code class="literal">MainWindow.cpp</code> files are the headers/sources for the <code class="literal">MainWindow</code> class. These files contain the default GUI generated by the wizard.</p><p>The <code class="literal">MainWindow.ui</code> file is your UI design file in XML format. It can be edited more easily with Qt Designer. This tool is a <strong>WYSIWYG</strong> (<strong>What You See Is What You Get</strong>) editor that helps you to add and adjust your graphical components (widgets).</p><p>Here is the <code class="literal">main.cpp</code> file, with its well-known function:</p><pre class="programlisting">#include "MainWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) 
{ 
    QApplication a(argc, argv); 
    MainWindow w; 
    w.show(); 
 
    return a.exec(); 
} 
</pre><p>As usual, the <code class="literal">main.cpp</code> file contains the program entry point. It will, by default, perform two actions:</p><div><ul class="itemizedlist"><li class="listitem">Instantiate and show your main window</li><li class="listitem">Instantiate a <code class="literal">QApplication</code> and execute the blocking main event loop</li></ul></div><p>This is the bottom-left toolbar for Qt Creator:</p><div><img src="img/image00351.jpeg" alt="Creating a project"/></div><p style="clear:both; height: 1em;"> </p><p>Use it to build and start your <code class="literal">todo</code> application in debug mode:</p><div><ol class="orderedlist arabic"><li class="listitem">Check that the project is in <strong>Debug</strong> build mode.</li><li class="listitem">Use the hammer button to build your project.</li><li class="listitem">Start debugging using the green Play button with a little blue bug.</li></ol><div></div><p>You will discover a wonderful and beautifully empty window. We will rectify this after explaining how this <code class="literal">MainWindow</code> is constructed:</p><div><img src="img/image00352.jpeg" alt="Creating a project"/><div><p>An empty <strong>MainWindow</strong> screenshot</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip3"/>Tip</h3><p><strong>Qt tip</strong>
</p><div><ul class="itemizedlist"><li class="listitem">Press <em>Ctrl</em> + <em>B</em> (for Windows/Linux) or <em>Command</em> + <em>B</em> (for Mac) to build your project</li><li class="listitem">Press <em>F5</em> (for Windows / Linux) or <em>Command</em> +<em>R</em> (for Mac) to run your application in debug mode</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec8"/>MainWindow structure</h1></div></div></div><p>This generated class is a perfect yet simple example of Qt framework usage; we will dissect it together. As mentioned previously, the <code class="literal">MainWindow.ui</code> file describes your UI design and <code class="literal">MainWindow.h</code>/ <code class="literal">MainWindow.cpp</code> is the C++ object where you can manipulate the UI with code.</p><p>It is important to take a look at the header file <code class="literal">MainWindow.h</code>. Our <code class="literal">MainWindow</code> object inherits from Qt's <code class="literal">QMainWindow</code> class:</p><pre class="programlisting">#include &lt;QMainWindow&gt; 
 
namespace Ui { 
class MainWindow; 
} 
 
class MainWindow : public QMainWindow 
{ 
    Q_OBJECT 
 
public: 
    explicit MainWindow(QWidget *parent = 0); 
    ~MainWindow(); 
private: 
    Ui::MainWindow *ui; 
}; 
</pre><p>As our class inherits from the <code class="literal">QMainWindow</code> class, on top of the header file, we add the corresponding include. The second part is the forward declaration of the <code class="literal">Ui::MainWindow</code>, as we only declare a pointer.</p><p>The <code class="literal">Q_OBJECT</code> can look a little strange to a non-Qt developer. This macro allows the class to define its own signals/slots and more globally Qt's meta-object system. These features will be covered later in this chapter.</p><p>This class defines a public constructor and destructor. The latter is pretty common. But the constructor takes a parameter parent. This parameter is a <code class="literal">QWidget</code> pointer that is <code class="literal">null</code> by default.</p><p>A <code class="literal">QWidget</code> is a UI component. It can be a label, a textbox, a button, and so on. If you define a parent-child relationship between your window, layout, and other UI widgets, memory management of your application will be easier. Indeed, in this case, deleting the parent is enough because its destructor will take care of also deleting its child, which in turn will delete its children and so on.</p><p>Our <code class="literal">MainWindow</code> class extends <code class="literal">QMainWindow</code> from the Qt framework. We have a <code class="literal">ui</code> member variable in the private fields. The type is a pointer of <code class="literal">Ui::MainWindow</code>, which is defined in the <code class="literal">ui_MainWindow.h</code> file generated by Qt. It's the C++ transcription of the UI design file <code class="literal">MainWindow.ui</code>. The <code class="literal">ui</code> member variable will allow you to interact with your UI components (<code class="literal">QLabel</code>, <code class="literal">QPushButton</code>, and so on) from C++, as shown in the following figure:</p><div><img src="img/image00353.jpeg" alt="MainWindow structure"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip4"/>Tip</h3><p><strong>C++ tip</strong></p><p>If your class only uses pointers or references for a class type, you can avoid including the header by using forward declaration. That will drastically reduce compilation time.</p></div><p>Now that the header part is done, we can talk about the <code class="literal">MainWindow.cpp</code> source file.</p><p>In the following code snippet, the first include is our class header. The second one is the include required by the generated class <code class="literal">Ui::MainWindow</code>. This include is required as we only use a forward declaration in the header:</p><pre class="programlisting">#include "MainWindow.h" 
#include "ui_MainWindow.h" 
 
MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow) 
{ 
    ui-&gt;setupUi(this); 
</pre><p>In many cases, Qt generates a good piece of code using the initializer list. The <code class="literal">parent</code> argument is used to call the superclass constructor <code class="literal">QMainWindow</code>. Our private member variable <code class="literal">ui</code> is also initialized now.</p><p>Now that <code class="literal">ui</code> is initialized, we must call the <code class="literal">setupUi</code> function to initialize all widgets used by the <code class="literal">MainWindow.ui</code> design file:</p><p>As we initialize a pointer in the constructor, it must be cleaned in the destructor:</p><pre class="programlisting">MainWindow::~MainWindow() 
{ 
    delete ui; 
} 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Qt Designer</h1></div></div></div><p>Qt Designer is a major tool for developing Qt applications. This WYSIWYG editor will help you easily design your GUI. If you switch between <strong>Edit</strong> mode and <strong>Design</strong> mode for the <code class="literal">MainWindow.ui</code> file, you will see the real XML content and the designer:</p><div><img src="img/image00354.jpeg" alt="Qt Designer"/></div><p style="clear:both; height: 1em;"> </p><p>The designer displays several parts:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Form Editor</strong>: This is a visual representation of the form (empty for now)</li><li class="listitem"><strong>Widget Box</strong>: This contains all widgets that can be used with your form</li><li class="listitem"><strong>Object Inspector</strong>: This displays your form as a hierarchical tree</li><li class="listitem"><strong>Property Editor</strong>: This enumerates the properties of the selected widget</li><li class="listitem"><strong>Action Editor/Signal &amp; Slots Editor</strong>: This handles connections between your objects</li></ul></div><p>It's time to embellish this empty window! Let's drag and drop a <strong>Label</strong> widget from the <strong>Display Widgets</strong> section on the form. You can change the name and the text properties from the properties editor.</p><p>As we are making a <code class="literal">todo</code> application, we suggest these properties:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">objectName</code>: <code class="literal">statusLabel</code></li><li class="listitem"><code class="literal">text</code>: <code class="literal">Status: 0 todo/0 done</code></li></ul></div><p>This label will later display the count of <code class="literal">todo</code> tasks and the count of tasks already done. OK, save, build, and start your application. You should now see your new label in the window.</p><p>You can now add a push button with those properties:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">objectName</code>: <code class="literal">addTaskButton</code></li><li class="listitem"><code class="literal">text</code>: <code class="literal">Add task</code></li></ul></div><p>You should get a result close to this:</p><div><img src="img/image00355.jpeg" alt="Qt Designer"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip5"/>Tip</h3><p><strong>Qt tip</strong></p><p>You can edit the text property of a widget directly on your form by double-clicking on it!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Signals and slots</h1></div></div></div><p>The Qt framework brings a flexible message exchange mechanism through three concepts: signals, slots, and connections:</p><div><ul class="itemizedlist"><li class="listitem">A <code class="literal">signal</code> is a message sent by an object</li><li class="listitem">A <code class="literal">slot</code> is a function that will be called when this signal is triggered</li><li class="listitem">The <code class="literal">connect</code> function specifies which <code class="literal">signal</code> is linked to which <code class="literal">slot</code></li></ul></div><p>Qt already provides signals and slots for its classes, which you can use in your application. For example, <code class="literal">QPushButton</code> has a <code class="literal">signal clicked()</code>, which will be triggered when the user clicks on the button. The <code class="literal">QApplication</code> class has a <code class="literal">slot quit()</code> function, which can be called when you want to terminate your application.</p><p>Here is why you will love Qt signals and slots:</p><div><ul class="itemizedlist"><li class="listitem">A slot remains an ordinary function, so you can call it yourself</li><li class="listitem">A single signal can be linked to different slots</li><li class="listitem">A single slot can be called by different linked signals</li><li class="listitem">A connection can be made between a signal and a slot from different objects, and even between objects living inside different threads!</li></ul></div><p>Keep in mind that, to be able to connect a <code class="literal">signal</code> to a <code class="literal">slot</code>, their methods' signatures must match. The count, order, and type of arguments must be identical. Note that signals and slots never return values.</p><p>This is the syntax of a Qt connection:</p><pre class="programlisting">connect(sender, &amp;Sender::signalName,  
    receiver, &amp;Receiver::slotName); 
</pre><p>The first test that we can do to use this wonderful mechanism is to connect an existing <code class="literal">signal</code> with an existing <code class="literal">slot</code>. We will add this connect call to the <code class="literal">MainWindow</code> constructor:</p><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow) 
{ 
    ui-&gt;setupUi(this); 
    connect(ui-&gt;addTaskButton, &amp;QPushButton::clicked, 
    QApplication::instance(), &amp;QApplication::quit); 
} 
</pre><p>Let's analyze how a connection is done:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">sender</code>: This is the object that will send the signal. In our example, it is the <code class="literal">QPushButton</code> named <code class="literal">addTaskButton</code> added from the UI designer.</li><li class="listitem"><code class="literal">&amp;Sender::signalName</code>: This is the pointer to the member signal function. Here, we want do something when the clicked signal is triggered.</li><li class="listitem"><code class="literal">receiver</code>: This is the object that will receive and handle the signal. In our case, it is the <code class="literal">QApplication</code> object created in <code class="literal">main.cpp</code>.</li><li class="listitem"><code class="literal">&amp;Receiver::slotName</code>: This is a pointer to one of the receiver's <code class="literal">member</code> slot functions. In this example, we use the built-in <code class="literal">quit()</code> slot from <code class="literal">Qapplication</code>, which will exit the application.</li></ul></div><p>You can now compile and run this short example. You will terminate the application if you click on the <code class="literal">addTaskButton</code> of your <code class="literal">MainWindow</code>.</p><div><h3 class="title"><a id="tip6"/>Tip</h3><p><strong>Qt tip</strong></p><p>You can connect a signal to another signal. The second signal will be emitted when the first one is triggered.</p></div><p>Now that you know how to connect a signal to an existing slot, let's see how to declare and implement a custom <code class="literal">addTask()</code> slot in our <code class="literal">MainWindow</code> class. This slot will be called when the user clicks on <code class="literal">ui-&gt;addTaskButton</code>.</p><p>This is the updated <code class="literal">MainWindow.h</code>:</p><pre class="programlisting">class MainWindow : public QMainWindow 
{ 
    Q_OBJECT 
 
public: 
    explicit MainWindow(QWidget *parent = 0); 
    ~MainWindow(); 
 
public slots: 
    void addTask(); 
 
private: 
    Ui::MainWindow *ui; 
}; 
</pre><p>Qt uses a specific <code class="literal">slot</code> keyword to identify slots. Since a slot is a function, you can always adjust the visibility (<code class="literal">public</code>, <code class="literal">protected</code> or <code class="literal">private</code>) depending on your needs.</p><p>Add this slot implementation in the <code class="literal">MainWindow.cpp</code> file:</p><pre class="programlisting">void MainWindow::addTask() 
{ 
    qDebug() &lt;&lt; "User clicked on the button!"; 
} 
</pre><p>Qt provides an efficient way of displaying debug information with the <code class="literal">QDebug</code> class. An easy way to obtain a <code class="literal">QDebug</code> object is to call the <code class="literal">qDebug()</code> function. Then, you can use the stream operator to send your debug information.</p><p>Update the top of the file like this:</p><pre class="programlisting">#include &lt;QDebug&gt; 
 
MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow) 
{ 
    ui-&gt;setupUi(this); 
    connect(ui-&gt;addTaskButton, &amp;QPushButton::clicked, 
    this, &amp;MainWindow::addTask); 
} 
</pre><p>Since we now use <code class="literal">qDebug()</code> in out slot, we must include <code class="literal">&lt;QDebug&gt;</code>. The updated connect now calls our custom slot instead of quitting the application.</p><p>Build and run the application. If you click on the button, you will see your debug message inside the Qt Creator <code class="literal">Application Output</code> tab.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Custom QWidget</h1></div></div></div><p>We now have to create the <code class="literal">Task</code> class that will hold our data (task name and completed status). This class will have its form file separated from <code class="literal">MainWindow</code>. Qt Creator provides an automatic tool to generate a base class and the associated form.</p><p>Click on <strong>File</strong> | <strong>New File or Project</strong> | <strong>Qt</strong> | <strong>Qt Designer Form Class</strong>. There are several form templates; you will recognize Main Window, which Qt Creator created for us when we started the <code class="literal">todo</code> app project. Select <strong>Widget</strong> and name the class <code class="literal">Task</code>, then click on <strong>Next</strong>. Here is a summary of what Qt Creator will do:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">Task.h</code> file and a <code class="literal">Task.cpp</code> file.</li><li class="listitem">Create the associated <code class="literal">Task.ui</code> and do the plumbing to connect it to <code class="literal">Task.h</code>.</li><li class="listitem">Add these three new files to <code class="literal">todo.pro</code> so they can be compiled.</li></ol><div></div><p>Finish and, voilÃ , the <code class="literal">Task</code> class is ready to be filled. We will jump into the <code class="literal">Task.ui</code> first. Start by dragging and dropping a <code class="literal">Check Box</code> (put <code class="literal">checkbox</code> in the <code class="literal">objectName</code>) and a <code class="literal">Push Button</code> (<code class="literal">objectName</code> = <code class="literal">removeButton</code>):</p><div><img src="img/image00356.jpeg" alt="Custom QWidget"/><div><p>My alignment looks great, let's ship this to the customers!</p></div></div><p style="clear:both; height: 1em;"> </p><p>Unless you have a pixel-perfect eye, your items are not very well aligned. You need to indicate how your widgets should be laid out and how they should react when the window geometry changes (for example, when the user resizes the window). For this, Qt has several default layout classes:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Vertical Layout</code>: In this layout, widgets are vertically stacked</li><li class="listitem"><code class="literal">Horizontal Layout</code>: In this layout, widgets are horizontally stacked</li><li class="listitem"><code class="literal">Grid Layout</code>: In this layout, widgets are arranged in a grid that can be subdivided into smaller cells</li><li class="listitem"><code class="literal">Form Layout</code>: In this layout, widgets are arranged like a web form, a label, and an input</li></ul></div><p>Every layout will try to constrain all widgets to occupy equal surfaces. It will either change the widgets' shape or add extra margins, depending on each widget's constraints. A <code class="literal">Check Box</code> will not be stretched but a <code class="literal">Push Button</code> will.</p><p>In our <code class="literal">Task</code> object, we want this to be horizontally stacked. In the <strong>Form Editor</strong> tab, right-click on the window and select <strong>Lay out</strong> | <strong>Lay out Horizontally</strong>. Each time you add a new widget in this layout, it will be arranged horizontally.</p><p>Now add a <code class="literal">Push Button (objectName = editButton)</code> line just after the <code class="literal">checkbox</code> object.</p><p>The <strong>Form Editor</strong> window offers a realistic preview of how your UI will render. If you stretch the window now, you can observe how each widget will react to this event. When resizing horizontally, you can note that the push buttons are stretched. It looks bad. We need something to "hint" to the layout that these buttons should not be stretched. Enter the <code class="literal">Spacer</code> widget. Take the <code class="literal">Horizontal Spacer</code> in the widget box and drop it after the <code class="literal">checkbox</code> object:</p><div><img src="img/image00357.jpeg" alt="Custom QWidget"/></div><p style="clear:both; height: 1em;"> </p><p>A spacer is a special widget that tries to push (horizontally or vertically) adjacent widgets to force them to take up as little space as possible. The <code class="literal">editButton</code> and <code class="literal">removeButton</code> objects now take up only the space of their text and will be pushed to the edge of the window when it is resized.</p><p>You can add sub layouts of any type in a form (vertical, horizontal, grid, form) and create a complex-looking application with a combination of widgets, spacers, and layouts. These tools are targeted at designing a good-looking desktop application that can react properly to different window geometries.</p><p>The Designer part is finished, so we can switch to the <code class="literal">Task</code> source code. Since we created a Qt Designer Form class, <code class="literal">Task</code> is closely linked to its UI. We will use this as leverage to store our model in a single place. When we create a <code class="literal">Task</code> object, it has to have a name:</p><pre class="programlisting">#ifndef TASK_H 
#define TASK_H 
 
#include &lt;QWidget&gt; 
#include &lt;QString&gt; 
 
namespace Ui { 
class Task; 
} 
 
class Task : public QWidget 
{ 
    Q_OBJECT 
 
public: 
    explicit Task(const QString&amp; name, QWidget *parent = 0); 
    ~Task(); 
 
    void setName(const QString&amp; name); 
    QString name() const; 
    bool isCompleted() const; 
     
private: 
    Ui::Task *ui; 
}; 
 
#endif // TASK_H 
</pre><p>The constructor specifies a name, and as you can see there are no private fields storing any state of the object. All this will be done in the form part. We also added some getters and setters that will interact with the form. It is better to have a model completely separated from the UI, but our example is simple enough to merge them. Moreover, <code class="literal">Task</code> implementation details are hidden from the outside world and can still be refactored later on. Here is the content of the <code class="literal">Task.cpp</code> file:</p><pre class="programlisting">#include "Task.h" 
#include "ui_Task.h" 
 
Task::Task(const QString&amp; name, QWidget *parent) : 
        QWidget(parent), 
        ui(new Ui::Task) 
{ 
    ui-&gt;setupUi(this); 
    setName(name); 
} 
 
Task::~Task() 
{ 
    delete ui; 
} 
 
void Task::setName(const QString&amp; name) 
{ 
    ui-&gt;checkbox-&gt;setText(name); 
} 
 
QString Task::name() const 
{ 
    return ui-&gt;checkbox-&gt;text(); 
} 
 
bool Task::isCompleted() const 
{ 
   return ui-&gt;checkbox-&gt;isChecked(); 
} 
</pre><p>The implementation is straightforward; we store the information in our <code class="literal">ui-&gt;checkbox</code> and the <code class="literal">name()</code> and <code class="literal">isCompleted()</code> getters take their data from the <code class="literal">ui-&gt;checkbox</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Adding a task</h1></div></div></div><p>We will now rearrange the layout of <code class="literal">MainWindow</code> to be able to display our todo tasks. Right now, there is no widget where we can display our tasks. Open the <code class="literal">MainWindow.ui</code> file and edit it to get the following result:</p><div><img src="img/image00358.jpeg" alt="Adding a task"/></div><p style="clear:both; height: 1em;"> </p><p>If we detail the content, we have:</p><div><ul class="itemizedlist"><li class="listitem">A vertical layout for <code class="literal">centralWidget</code> containing the <code class="literal">toolbarLayout</code> file and the <code class="literal">tasksLayout</code> file.</li><li class="listitem">A vertical spacer pushing these layouts to the top, forcing them to take up the smallest possible space.</li><li class="listitem">We got rid of <code class="literal">menuBar</code>, <code class="literal">mainToolBar</code>, and <code class="literal">statusBar</code>. Qt Creator created them automatically, we simply don't need them for our purposes. You can guess their uses from their names.</li></ul></div><p>Do not forget to rename the <code class="literal">MainWindow</code> title to <code class="literal">Todo</code> by selecting the <strong>MainWindow</strong> in the <strong>Object Inspector</strong> window and editing the <strong>Qwidget</strong> | <strong>windowTitle</strong> property. Your app deserves to be named properly.</p><div><h3 class="title"><a id="tip7"/>Tip</h3><p><strong>Qt Tip</strong></p><p>Press <em>Shift</em> + <em>F4</em> in Designer mode to switch between the form editor and the source.</p></div><p>Now that the <code class="literal">MainWindow</code> UI is ready to welcome tasks, let's switch to the code part. The application has to keep track of the new tasks. Add the following in the <code class="literal">MainWindow.h</code> file:</p><pre class="programlisting">#include &lt;QVector&gt; 
 
#include "Task.h" 
 
class MainWindow : public QMainWindow 
{ 
    // MAINWINDOW_H 
 
public slots: 
    void addTask(); 
 
private: 
    Ui::MainWindow *ui; 
    QVector&lt;Task*&gt; mTasks; 
}; 
</pre><p>The <code class="literal">QVector</code> is the Qt container class providing a dynamic array, which is an equivalent of the <code class="literal">std::vector</code>. As a general rule, STL containers are more customizable but might miss some features compared to Qt containers. If you use C++11 smart pointers, you should favor <code class="literal">std</code> containers, but we will get into that later.</p><p>In the Qt documentation of <code class="literal">QVector</code>, you might stumble upon the following statement: "<em>For most purposes, </em><code class="literal">QList</code><em> is the right class to use</em>". There is a debate about this in the Qt community:</p><div><ul class="itemizedlist"><li class="listitem">Do you often need to insert objects larger than a pointer at the beginning or in the middle of your array? Use a <code class="literal">QList</code> class.</li><li class="listitem">Need contiguous memory allocation? Less CPU and memory overhead? Use a <code class="literal">QVector</code> class.</li></ul></div><p>The already added slot <code class="literal">addTask()</code> will now be called each time we want to add a new <code class="literal">Task</code> object to the <code class="literal">mTasks</code> function.</p><p>Let's fill our <code class="literal">QVector</code> tasks each time <code class="literal">addTaskButton</code> is clicked. First, we connect the <code class="literal">clicked()</code> signal in the <code class="literal">MainWindow.cpp</code> file:</p><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow), 
    mTasks() 
{ 
    ui-&gt;setupUi(this); 
    connect(ui-&gt;addTaskButton, &amp;QPushButton::clicked,  
    this, &amp;MainWindow::addTask); 
}; 
</pre><div><h3 class="title"><a id="tip8"/>Tip</h3><p><strong>C++ tip</strong></p><p>As a best practice, try to always initialize member variables in the initializer list and respect the order of variable declarations. Your code will run faster and you will avoid unnecessary variable copies. Take a look at the standard C++ documentation at <a class="ulink" href="https://isocpp.org/wiki/faq/ctors#init-lists">https://isocpp.org/wiki/faq/ctors#init-lists</a>.</p></div><p>The body of the <code class="literal">addTask()</code> function should look like this:</p><pre class="programlisting">void MainWindow::addTask() 
{ 
        qDebug() &lt;&lt; "Adding new task"; 
        Task* task = new Task("Untitled task"); 
        mTasks.append(task); 
        ui-&gt;tasksLayout-&gt;addWidget(task); 
} 
</pre><p>We created a new task and added it to our <code class="literal">mTask</code> vector. Because Task is a <code class="literal">QWidget</code>, we also added it directly to the <code class="literal">tasksLayout</code>. An important thing to note here is that we never managed this new task's memory. Where is the <code class="literal">delete task</code> instruction? This is a key feature of the Qt Framework we started to broach earlier in the chapter; the <code class="literal">QObject</code> class parenting automatically handles object destruction.</p><p>In our case, the <code class="literal">ui-&gt;tasksLayout-&gt;addWidget(task)</code> call has an interesting side-effect; the ownership of the task is transferred to <code class="literal">tasksLayout</code>. The <code class="literal">QObject*</code> parent defined in <code class="literal">Task</code> constructor is now <code class="literal">tasksLayout</code>, and the <code class="literal">Task</code> destructor will be called when <code class="literal">tasksLayout</code> releases its own memory by recursively iterating through its children and calling their destructor.</p><p>This will happen at this precise moment:</p><pre class="programlisting">MainWindow::~MainWindow() 
{ 
    delete ui; 
} 
</pre><p>When <code class="literal">MainWindow</code> is released (remember, it's a stack variable allocated in the <code class="literal">main.cpp</code> file), it will call <code class="literal">delete ui</code>, which in turn will bring down the whole <code class="literal">QObject</code> hierarchy. This feature has interesting consequences. First, if you use the <code class="literal">QObject</code> parenting model in your application, you will have much less memory to manage. Second, it can collide with some new C++11 semantics, specifically the smart pointers. We will get into that in later chapters.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Using a QDialog</h1></div></div></div><p>We deserve something better than an untitled task. The user needs to define its name when it's created. The easiest path would be to display a dialog where the user can input the task name. Fortunately Qt offers us a very configurable dialog that fits perfectly in <code class="literal">addTask()</code>:</p><pre class="programlisting">#include &lt;QInputDialog&gt; 
... 
void MainWindow::addTask() 
{ 
    bool ok; 
    QString name = QInputDialog::getText(this,  
        tr("Add task"), 
        tr("Task name"), 
        QLineEdit::Normal, 
        tr("Untitled task"),               &amp;ok); 
    if (ok &amp;&amp; !name.isEmpty()) { 
        qDebug() &lt;&lt; "Adding new task"; 
        Task* task = new Task(name); 
        mTasks.append(task); 
        ui-&gt;tasksLayout-&gt;addWidget(task); 
    } 
} 
</pre><p>The <code class="literal">QinputDialog::getText</code> function is a static blocking function that displays the dialog. When the user validates/cancels the dialog, the code continues. If we run the application and try to add a new task, we'll see this:</p><div><img src="img/image00359.jpeg" alt="Using a QDialog"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">QInputDialog::getText</code> signature looks like this:</p><pre class="programlisting">QString QinputDialog::getText( 
  QWidget* parent,  
      const QString&amp; title,  
      const QString&amp; label,  
      QLineEdit::EchoMode mode = QLineEdit::Normal,  
      const QString&amp; text = QString(),  
      bool* ok = 0, ...)</pre><p>Let's break it down:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">parent</code>: This is the parent widget (<code class="literal">MainWindow</code>) to which the <code class="literal">QinputDialog</code> is attached. This is another instance of the <code class="literal">QObject</code> class's parenting model.</li><li class="listitem"><code class="literal">title</code>: This is the title displayed in the window title. In our example, we use <code class="literal">tr("Add task")</code>, which is how Qt handles i18n in your code. We will see later on how to provide multiple translations for a given string.</li><li class="listitem"><code class="literal">label</code>: This is the label displayed right above the input text field.</li><li class="listitem"><code class="literal">mode</code>: This is how the input field is rendered (password mode will hide the text).</li><li class="listitem"><code class="literal">ok</code>: This is a pointer to a variable that is set to true if the user presses <strong>OK</strong> and to false if the user presses <strong>Cancel</strong>.</li><li class="listitem"><code class="literal">QString</code>: The returned <code class="literal">QString</code> is what the user has typed.</li></ul></div><p>There are a few more optional parameters we can safely ignore for our example.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Distributing code responsibility</h1></div></div></div><p>Great, the user can now specify the task name when it's created. What if he makes an error when typing the name? The next logical step is to rename the task after we created it. We'll take a slightly different approach. We want our <code class="literal">Task</code> to be as autonomous as possible. If we attach it to another component (rather than <code class="literal">MainWindow</code>), this renaming feature has to keep working. Thus, this responsibility has to be given to the <code class="literal">Task</code> class:</p><pre class="programlisting">// In Task.h 
public slots: 
    void rename(); 
 
// In Task.cpp 
#include &lt;QInputDialog&gt; 
 
Task::Task(const QString&amp; name, QWidget *parent) : 
       QWidget(parent), 
       ui(new Ui::Task) 
{ 
   ui-&gt;setupUi(this); 
   setName(name); 
   connect(ui-&gt;editButton, &amp;QPushButton::clicked, this, &amp;Task::rename); 
} 
... 
void Task::rename() 
{ 
    bool ok; 
    QString value = QInputDialog::getText(this, tr("Edit task"), 
                                          tr("Task name"), 
                                          QLineEdit::Normal, 
                                          this-&gt;name(), &amp;ok); 
    if (ok &amp;&amp; !value.isEmpty()) { 
        setName(value); 
    } 
} 
</pre><p>We add a public slot <code class="literal">rename() </code>to connect it to a signal. The body of <code class="literal">rename()</code> reuses what we had previously covered with <code class="literal">QInputDialog</code>. The only difference is the <code class="literal">QInputDialog</code> default value, which is the current task name. When <code class="literal">setName(value)</code> is called, the UI is instantly refreshed with the new value; there's nothing to synchronize or update, the Qt main loop will do its job.</p><p>The nice thing is that <code class="literal">Task::rename()</code> is completely autonomous. Nothing has been modified in <code class="literal">MainWindow</code>, so we have effectively zero coupling between our <code class="literal">Task</code> and the parent <code class="literal">QWidget</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Emitting a custom signal using lambdas</h1></div></div></div><p>The remove task is straightforward to implement, but we'll study some new concepts along the way. The <code class="literal">Task</code> has to notify its owner and parent (<code class="literal">MainWindow</code>) that the <code class="literal">removeTaskButton</code><code class="literal">QPushButton</code> has been clicked. We'll implement this by defining a custom signal <code class="literal">removed</code> in <code class="literal">Task.h</code> files:</p><pre class="programlisting">class Task : public QWidget 
{ 
    ... 
public slots: 
    void rename(); 
signals: 
    void removed(Task* task); 
   ... 
}; 
</pre><p>Like we did for the slots, we have to add the Qt keyword signals in our header. Since a <code class="literal">signal</code> is used only to notify another class, the <code class="literal">public</code> keyword is not needed (it even raises a compilation error). A <code class="literal">signal</code> is simply a notification sent to the receiver (the connected <code class="literal">slot</code>); it implies that there is no function body for the <code class="literal">removed(Task* task)</code> function. We added the <code class="literal">task</code> parameter to allow the receiver to know which task asked to be removed. The next step is to emit the <code class="literal">removed</code> signal upon the <code class="literal">removeButton</code> click. This is done in the <code class="literal">Task.cpp</code> file:</p><pre class="programlisting">Task::Task(const QString&amp; name, QWidget *parent) : 
        QWidget(parent), 
        ui(new Ui::Task) 
{ 
    ui-&gt;setupUi(this); 
    ... 
    connect(ui-&gt;removeButton, &amp;QPushButton::clicked, [this] { 
        emit removed(this); 
    }); 
} 
</pre><p>This code excerpt shows a very interesting feature of C++11: <code class="literal">lambdas</code>. In our example, the <code class="literal">lambda</code> is the following part:</p><pre class="programlisting">[this] { 
        emit removed(this); 
    }); 
</pre><p>What we did here is to connect the clicked signal to an anonymous inline function, a <code class="literal">lambda</code>. Qt allows signal relaying by connecting a signal to another signal if their signatures match. It's not the case here; the <code class="literal">clicked</code> signal has no parameter and the <code class="literal">removed</code> signal needs a <code class="literal">Task*</code>. A <code class="literal">lambda</code> avoids the declaration of a verbose <code class="literal">slot</code> in <code class="literal">Task</code>. Qt 5 accepts a <code class="literal">lambda</code> instead of a slot in a <code class="literal">connect</code>, and both syntaxes can be used.</p><p>Our <code class="literal">lambda</code> executes a single line of code: <code class="literal">emit removed(this)</code>. <code class="literal">Emit</code> is a Qt macro that will immediately trigger the connected <code class="literal">slot</code> with what we passed in a parameter. As we said earlier, <code class="literal">removed(Task* this)</code> has no function body, its purpose is to notify the registered slot of an event.</p><p>Lambdas are a great addition to C++. They offer a very practical way of defining short functions in your code. Technically, a <code class="literal">lambda</code> is the construction of a closure capable of capturing variables in its scope. The full syntax goes like this:</p><pre class="programlisting">[ capture-list ] ( params ) -&gt; ret { body }</pre><p>Letâs study each part of this statement:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">capture-list</code>: This defines what variables will be visible inside the <code class="literal">lambda</code> scope.</li><li class="listitem"><code class="literal">params</code>: This is the function parameters type list that can be passed to the <code class="literal">lambda</code> scope. There are no parameters in our case, We might have written <code class="literal">[this] () { ... }</code>, but C++11 lets us skip the parentheses altogether.</li><li class="listitem"><code class="literal">ret</code>: This is the return type of the <code class="literal">lambda</code> function. Just like <code class="literal">params</code>, this parameter can be omitted if the return type is <code class="literal">void</code>.</li><li class="listitem"><code class="literal">body</code>: This is obviously your code body where you have access to your <code class="literal">capture-list</code>, and <code class="literal">params</code>, and which must return a variable with a type <code class="literal">ret</code>.</li></ul></div><p>In our example, we captured the <code class="literal">this</code> pointer to be able to:</p><div><ul class="itemizedlist"><li class="listitem">Have a reference on the <code class="literal">removed()</code> function, which is a part of the <code class="literal">Task</code> class. If we did not capture <code class="literal">this</code>, the compiler would have shouted <code class="literal">error: 'this' was not captured for this lambda function emit removed(this);</code>.</li><li class="listitem">Pass <code class="literal">this</code> to the <code class="literal">removed</code> signal; the caller needs to know which task triggered <code class="literal">removed</code>.</li></ul></div><p>The <code class="literal">capture-list</code> relies on standard C++ semantics: capture variables by copy or by reference. Let us say that we wanted to print a log of the constructor parameter <code class="literal">name</code> and we capture it by reference in our <code class="literal">lambda</code>:</p><pre class="programlisting">connect(ui-&gt;removeButton, &amp;QPushButton::clicked, [this, &amp;name] { 
        qDebug() &lt;&lt; "Trying to remove" &lt;&lt; name; 
        this-&gt;emit removed(this); 
    }); 
</pre><p>This code will compile fine. Unfortunately, the runtime will crash with a dazzling segmentation fault when we try to remove a <code class="literal">Task</code>. What happened? As we said, our <code class="literal">lambda</code> is an anonymous function that will be executed when the <code class="literal">clicked()</code> signal has been emitted. We captured the <code class="literal">name</code> reference, but this reference may be <code class="literal">-</code> and is <code class="literal">-</code> invalid once we get out of <code class="literal">Task</code> constructor (more precisely, from the caller scope). The <code class="literal">qDebug()</code> function will then try to display an unreachable code and crash.</p><p>You really want to be careful with what you capture and the context in which your lambda will be executed. In this example, the segmentation fault can be amended by capturing the <code class="literal">name</code> by copy:</p><pre class="programlisting">connect(ui-&gt;removeButton, &amp;QPushButton::clicked, [this, name] { 
        qDebug() &lt;&lt; "Trying to remove" &lt;&lt; name; 
        this-&gt;emit removed(this); 
    }); 
</pre><div><h3 class="title"><a id="tip9"/>Tip</h3><p><strong>C++ Tip
</strong>
</p><div><ul class="itemizedlist"><li class="listitem">You can capture by copy or reference all variables that are reachable in the function where you define your lambda with the syntax [<code class="literal">=</code>] and [<code class="literal">&amp;</code>].</li><li class="listitem">The <code class="literal">this</code> variable is a special case of the capture list. You cannot capture it by reference <code class="literal">[&amp;this]</code> and the compiler will warn you if you are in this situation: <code class="literal">[=, this]</code>. Don't do this. Kittens will die.</li></ul></div></div><p>Our <code class="literal">lambda</code> is passed directly as a parameter to the connect function. In other words, the <code class="literal">lambda</code> is variable. This has many consequences: we can call it, assign it, and return it. To illustrate a "fully formed" <code class="literal">lambda</code>, we can define one that returns a formatted version of the task name. The sole purpose of this snippet is to investigate the <code class="literal">lambda</code> function's machinery. Don't include the following code in your <code class="literal">todo</code> app, your colleagues might call you something like a "functional zealot":</p><pre class="programlisting">connect(ui-&gt;removeButton, &amp;QPushButton::clicked, [this, name] { 
    qDebug() &lt;&lt; "Trying to remove" &lt;&lt; 
        [] (const QString&amp; taskName) -&gt; QString { 
            return "-------- " + taskName.toUpper(); 
    }(name); 
    this-&gt;emit removed(this); 
}); 
</pre><p>Here we did a tricky thing. We called <code class="literal">qDebug()</code>; inside this call we defined a <code class="literal">lambda</code> which is immediately executed. Let's analyze it:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">[]</code>: We performed no capture. The <code class="literal">lambda</code> does not depend on the enclosing function.</li><li class="listitem"><code class="literal">(const Qstring&amp; taskName)</code>: When this lambda is called, it will expect a <code class="literal">QString</code> to work on.</li><li class="listitem"><code class="literal">-&gt; QString</code>: The returned value of the lambda will be a <code class="literal">QString</code>.</li><li class="listitem"><code class="literal">return "------- " + taskName.toUpper()</code>: the body of our <code class="literal">lambda</code>. We return a concatenation of a string and the uppercase version of the parameter <code class="literal">taskName</code>. As you can see, string manipulation becomes a lot easier with Qt.</li><li class="listitem"><code class="literal">(name)</code>: Here comes the catch. Now that the <code class="literal">lambda</code> function is defined, we can call it passing the <code class="literal">name</code> parameter. In a single instruction, we define it and call it. The <code class="literal">QDebug()</code> function will simply print the result.</li></ul></div><p>The real benefit of this <code class="literal">lambda</code> will emerge if we are able to assign it to a variable and call it multiple times. C++ is statically typed, so we must provide the type of our <code class="literal">lambda</code> variable. In the language specification, a <code class="literal">lambda</code> type cannot be explicitly defined. We'll see soon how we can do it with C++11. For now, let's finish our remove feature.</p><p>Task now emits the <code class="literal">removed()</code> signal. This signal has to be consumed by <code class="literal">MainWindow</code>:</p><pre class="programlisting">// in MainWindow.h 
public slots: 
    void addTask(); 
    void removeTask(Task* task); 
 
// In MainWindow.cpp 
void MainWindow::addTask() 
{ 
    ... 
    if (ok &amp;&amp; !name.isEmpty()) { 
        qDebug() &lt;&lt; "Adding new task"; 
        Task* task = new Task(name); 
        connect(task, &amp;Task::removed,  
       this, &amp;MainWindow::removeTask); 
    ... 
    } 
} 
 
void MainWindow::removeTask(Task* task) 
{ 
    mTasks.removeOne(task); 
    ui-&gt;tasksLayout-&gt;removeWidget(task); 
    task-&gt;setParent(0); 
    delete task; 
} 
</pre><p>The <code class="literal">MainWindow::removeTask()</code> must match the signal signature. The connection is made when the task is created. The interesting part comes in the implementation of <code class="literal"> MainWindow::removeTask()</code>.</p><p>The task is first removed from the <code class="literal">mTasks</code> vector. It is then removed from <code class="literal">tasksLayout</code>. Here, <code class="literal">tasksLayout</code> releases its ownership of <code class="literal">task</code> (that is, <code class="literal">tasksLayout</code> ceases to be the <code class="literal">task</code> class's parent).</p><p>So far so good. The next two lines are interesting. The ownership transfer does not completely release the <code class="literal">task</code> class ownership. If we commented these lines, here is how <code class="literal">removeTask()</code> will look:</p><pre class="programlisting">void MainWindow::removeTask(Task* task) 
{ 
    mTasks.removeOne(task); 
    ui-&gt;tasksLayout-&gt;removeWidget(task); 
    // task-&gt;setParent(0); 
    // delete task; 
} 
</pre><p>If you add a log message in <code class="literal">Task</code> destructor and execute the program, this log message will be displayed. Nonetheless, the Qt documentation tells us in <code class="literal">Qlayout::removeWidget</code> part: <em>The ownership of a widget remains the same as when it was added</em>.</p><p>Instead, what really happens is that the <code class="literal">task</code> class's parent becomes <code class="literal">centralWidget</code>, the <code class="literal">tasksLayout</code> class's parent. We want Qt to forget everything about <code class="literal">task</code>, that's why we call <code class="literal">task-&gt;setParent(0)</code>. We can then safely delete it and call it a day.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Simplifying with the auto type and a range-based for loop</h1></div></div></div><p>The final step to a complete CRUD of our tasks is to implement the completed task feature. We'll implement the following:</p><div><ul class="itemizedlist"><li class="listitem">Click on the checkbox to mark the task as completed</li><li class="listitem">Strike the task name</li><li class="listitem">Update the status label in <code class="literal">MainWindow</code></li></ul></div><p>The checkbox click handling follows the same pattern as <code class="literal">removed</code>:</p><pre class="programlisting">// In Task.h 
signals: 
    void removed(Task* task); 
    void statusChanged(Task* task); 
private slots: 
    void checked(bool checked); 
 
// in Task.cpp 
Task::Task(const QString&amp; name, QWidget *parent) : 
        QWidget(parent), 
        ui(new Ui::Task) 
{ 
    ... 
 
    connect(ui-&gt;checkbox, &amp;QCheckBox::toggled,  
    this, &amp;Task::checked); 
} 
 
... 
 
void Task::checked(bool checked) 
{ 
    QFont font(ui-&gt;checkbox-&gt;font()); 
    font.setStrikeOut(checked); 
    ui-&gt;checkbox-&gt;setFont(font); 
    emit statusChanged(this); 
} 
</pre><p>We define a slot <code class="literal">checked(bool checked)</code> that will be connected to the <code class="literal">checkbox::toggled</code> signal. In our <code class="literal">slot checked()</code>, we strike out the <code class="literal">checkbox</code> text according to the <code class="literal">bool checked</code> value. This is done using the <code class="literal">QFont</code> class. We create a copy font from the <code class="literal">checkbox-&gt;font()</code>, modify it, and assign it back to <code class="literal">ui-&gt;checkbox</code>. If the original <code class="literal">font</code> was in bold, with a special size, its appearance would be guaranteed to stay the same.</p><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Play around with the font object in Qt Designer. Select the <code class="literal">checkbox</code> in the <code class="literal">Task.ui</code> file and go to <strong>Properties Editor</strong> | <strong>QWidget</strong> | <strong>font</strong>.</p></div><p>The last instruction notifies <code class="literal">MainWindow</code> that the <code class="literal">Task</code> status has changed. The signal name is <code class="literal">statusChanged</code>, rather than <code class="literal">checkboxChecked</code>, to hide the implementation details of the task. Add the following code in the <code class="literal">MainWindow.h</code> file:</p><pre class="programlisting">// In MainWindow.h 
public: 
    void updateStatus(); 
public slots: 
    void addTask(); 
    void removeTask(Task* task); 
    void taskStatusChanged(Task* task); 
 
// In MainWindow.cpp 
MainWindow::MainWindow(QWidget *parent) : 
    QMainWindow(parent), 
    ui(new Ui::MainWindow), 
    mTasks() 
{ 
    ... 
    updateStatus(); 
    } 
} 
 
void MainWindow::addTask() 
{ 
   ... 
   if (ok &amp;&amp; !name.isEmpty()) { 
       ... 
       connect(task, &amp;Task::removed, this, 
               &amp;MainWindow::removeTask); 
       connect(task, &amp;Task::statusChanged, this, 
               &amp;MainWindow::taskStatusChanged); 
       mTasks.append(task); 
       ui-&gt;tasksLayout-&gt;addWidget(task); 
       updateStatus(); 
   } 
} 
 
void MainWindow::removeTask(Task* task) 
{ 
   ... 
   delete task; 
   updateStatus(); 
} 
 
void MainWindow::taskStatusChanged(Task* /*task*/) 
{ 
    updateStatus(); 
} 
 
void MainWindow::updateStatus() 
{ 
    int completedCount = 0; 
    for(auto t : mTasks)  { 
        if (t-&gt;isCompleted()) { 
            completedCount++; 
        } 
    } 
    int todoCount = mTasks.size() - completedCount; 
 
    ui-&gt;statusLabel-&gt;setText( 
        QString("Status: %1 todo / %2 completed") 
                             .arg(todoCount) 
                             .arg(completedCount)); 
} 
</pre><p>We defined a slot <code class="literal">taskStatusChanged</code>, which is connected when a task is created. The single instruction of this <code class="literal">slot</code> is to call <code class="literal">updateStatus()</code>. This function iterates through the tasks and updates the <code class="literal">statusLabel</code>. The <code class="literal">updateStatus()</code> function is called upon task creation and deletion.</p><p>In <code class="literal">updateStatus()</code>, we meet more new C++11 semantics:</p><pre class="programlisting">for(auto t : mTasks)  { 
    ...  
} 
</pre><p>The <code class="literal">for</code> keyword lets us loop over a range-based container. Because <code class="literal">QVector</code> is an iterable container, we can use it here. The range declaration (<code class="literal">auto t</code>) is the type and variable name that will be assigned at each iteration. The range expression (<code class="literal">mTasks</code>) is simply the container on which the process will be done. Qt provides a custom implementation of the <code class="literal">for</code> (namely <code class="literal">foreach</code>) loop targeted at prior versions of C++; you don't need it anymore.</p><p>The <code class="literal">auto</code> keyword is another great new semantic. The compiler deduces the variable type automatically based on the initializer. It relieves a lot of pain for cryptic iterators such as this:</p><pre class="programlisting">std::vector::const_iterator iterator = mTasks.toStdVector() 
                                           .stdTasks.begin(); 
 
// how many neurones did you save? 
auto autoIter = stdTasks.begin(); 
</pre><p>Since C++14, <code class="literal">auto</code> can even be used for function return types. It's a fabulous tool, but use it sparingly. If you put <code class="literal">auto</code>, the type should be obvious from the signature name/variable name.</p><div><h3 class="title"><a id="tip11"/>Tip</h3><p>The <code class="literal">auto</code> keyword can be combined with <code class="literal">const</code> and references. You can write a for loop like this: <code class="literal">for (const auto &amp; t : mTasks) { ... }</code>.</p></div><p>Remember our half bread <code class="literal">lambda</code>? With all the covered features, we can write:</p><pre class="programlisting">auto prettyName = [] (const QString&amp; taskName) -&gt; QString { 
    return "-------- " + taskName.toUpper(); 
}; 
connect(ui-&gt;removeButton, &amp;QPushButton::clicked,  
    [this, name, prettyName] { 
        qDebug() &lt;&lt; "Trying to remove" &lt;&lt; prettyName(name); 
        this-&gt;emit removed(this); 
}); 
</pre><p>Now that's something beautiful. Combining <code class="literal">auto</code> with <code class="literal">lambda</code> makes very readable code and opens up a world of possibilities.</p><p>The last item to study is the <code class="literal">QString</code> API. We used it in <code class="literal">updateStatus()</code>:</p><pre class="programlisting">ui-&gt;statusLabel-&gt;setText( 
        QString("Status: %1 todo / %2 completed") 
                             .arg(todoCount) 
                             .arg(completedCount)); 
</pre><p>The people behind Qt put a lot of work into making string manipulation bearable in C++. This is a perfect example, where we replace the classic C <code class="literal">sprintf</code> with a more modern and robust API. Arguments are position-based only, no need to specify the type (less error-prone), and the <code class="literal">arg(...)</code> function accepts all kinds of types.</p><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Take some time to skim through the <code class="literal">QString</code> documentation at <a class="ulink" href="http://doc.qt.io/qt-5/qstring.html">http://doc.qt.io/qt-5/qstring.html</a>. It shows how much you can do with this class and you'll see yourself using fewer and fewer examples of <code class="literal">std string</code> or even <code class="literal">cstring</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we created a desktop Qt application from scratch. Qt is well known for its signal/slot mechanism and you must be confident with this paradigm. We also introduced some important C++14 features that will be used all through this book.</p><p>It's now time to discover some <code class="literal">qmake</code> secrets and what is really done when you build your Qt project. In the next chapter, we will also talk about how to create and organize an application with some platform-dependent code that must run on Windows, Mac OS, and Linux.</p></div></body></html>