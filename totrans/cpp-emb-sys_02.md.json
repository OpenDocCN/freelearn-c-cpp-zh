["```cpp\n#define N 20\nint buffer[N];\nfor(int i = 0; i < N; i ++) {\n    printf(\"%d \", buffer[i]);\n} \n```", "```cpp\nstd::array<int, 20> buffer;\nfor(const auto& element : buffer) {\n    printf(\"%d \", element);\n} \n```", "```cpp\nint w_idx = 0;\nfor(int i = 0; i < sizeof(array_a)/sizeof(int); i++) {\n    if(array_a[i] < 10) {\n        array_b[w_idx++] = array_a[i];\n    }\n} \n```", "```cpp\nauto less_than_10 =  [](auto x) -> bool {\n    return x < 10;\n};\nstd::copy_if(std::begin(array_a), std::end(array_a), std::begin(array_b), less_than_10); \n```", "```cpp\n#include <stdio.h>\n#define BUFFER_SIZE 5\ntypedef struct {\nint arr[BUFFER_SIZE]; // Array to store int values directly\nsize_t write_idx;     // Index of the next element to write (push)\nsize_t read_idx;      // Index of the next element to read (pop)\nsize_t count;         // Number of elements in the buffer\n} int_ring_buffer;\nvoid int_ring_buffer_init(int_ring_buffer *rb) {\n  rb->write_idx = 0;\n  rb->read_idx = 0;\n  rb->count = 0;\n}\nvoid int_ring_buffer_push(int_ring_buffer *rb, int value) {\n  rb->arr[rb->write_idx] = value;\n  rb->write_idx = (rb->write_idx + 1) % BUFFER_SIZE;\n  if (rb->count < BUFFER_SIZE) {\n    rb->count++;\n  } else {\n    // Buffer is full, move read_idx forward\n    rb->read_idx = (rb->read_idx + 1) % BUFFER_SIZE;\n  }\n}\nint int_ring_buffer_pop(int_ring_buffer *rb) {\n  if (rb->count == 0) {\n    return 0;\n  }\n  int value = rb->arr[rb->read_idx];\n  rb->read_idx = (rb->read_idx + 1) % BUFFER_SIZE;\n  rb->count--;\n  return value;\n}\nint main() {\n  int_ring_buffer rb;\n  int_ring_buffer_init(&rb);\n  for (int i = 0; i < 10; i++) {\n    int_ring_buffer_push(&rb, i);\n  }\n  while (rb.count > 0) {\n    int value = int_ring_buffer_pop(&rb);\n    printf(\"%d\\n\", value);\n  }\n  return 0;\n} \n```", "```cpp\n#include <stdio.h>\n#include <string.h>\n#define BUFFER_SIZE 20 // Total bytes available in the buffer\ntypedef struct {\nunsigned char data[BUFFER_SIZE]; // Array to store byte values\nsize_t write_idx;                // Index of the next byte to write\nsize_t read_idx;                 // Index of the next byte to read\nsize_t count;     // Number of bytes currently used in the buffer\nsize_t elem_size; // Size of each element in bytes\n} ring_buffer;\nvoid ring_buffer_init(ring_buffer *rb, size_t elem_size) {\n  rb->write_idx = 0;\n  rb->read_idx = 0;\n  rb->count = 0;\n  rb->elem_size = elem_size;\n}\nvoid ring_buffer_push(ring_buffer *rb, void *value) {\n  if (rb->count + rb->elem_size <= BUFFER_SIZE) {\n    rb->count += rb->elem_size;\n  } else {\n    rb->read_idx = (rb->read_idx + rb->elem_size) % BUFFER_SIZE;\n  }\n  memcpy(&rb->data[rb->write_idx], value, rb->elem_size);\n  rb->write_idx = (rb->write_idx + rb->elem_size) % BUFFER_SIZE;\n}\nint ring_buffer_pop(ring_buffer *rb, void *value) {\n  if (rb->count < rb->elem_size) {\n    // Not enough data to pop\nreturn 0;\n  }\n  memcpy(value, &rb->data[rb->read_idx], rb->elem_size);\n  rb->read_idx = (rb->read_idx + rb->elem_size) % BUFFER_SIZE;\n  rb->count -= rb->elem_size;\n  return 1; // Success\n}\nint main() {\n  ring_buffer rb;\n  ring_buffer_init(&rb, sizeof(int)); // Initialize buffer for int values\nfor (int i = 0; i < 10; i++) {\n    int val = i;\n    ring_buffer_push(&rb, &val);\n  }\n  int pop_value;\n  while (ring_buffer_pop(&rb, &pop_value)) {\n    printf(\"%d\\n\", pop_value);\n  }\n  return 0;\n} \n```", "```cpp\n#include <stdio.h>\n// Macro to define a function for summing two numbers\n#define DEFINE_SUM_FUNCTION(TYPE) \\\nTYPE sum_##TYPE(TYPE a, TYPE b) { \\\n    return a + b; \\\n}\n// Define sum functions for int and float\nDEFINE_SUM_FUNCTION(int)\nDEFINE_SUM_FUNCTION(float)\nint main() {\n    int result_int = sum_int(5, 3);\n    printf(\"Sum of integers: %d\\n\", result_int);\n    float result_float = sum_float(3.5f, 2.5f);\n    printf(\"Sum of floats: %.2f\\n\", result_float);\n    return 0;\n} \n```", "```cpp\n#include <stdio.h>\n#include <string.h>\n// Macro to declare ring buffer type and functions for a specific type and size\n#define DECLARE_RING_BUFFER(TYPE, SIZE) \\\ntypedef struct { \\\n    TYPE data[SIZE]; \\\n    size_t write_idx; \\\n    size_t read_idx; \\\n    size_t count; \\\n} ring_buffer_##TYPE##_##SIZE; \\\nvoid ring_buffer_init_##TYPE##_##SIZE(ring_buffer_##TYPE##_##SIZE *rb) { \\\n    rb->write_idx = 0; \\\n    rb->read_idx = 0; \\\n    rb->count = 0; \\\n} \\\nvoid ring_buffer_push_##TYPE##_##SIZE(ring_buffer_##TYPE##_##SIZE *rb, TYPE value) { \\\n    rb->data[rb->write_idx] = value; \\\n    rb->write_idx = (rb->write_idx + 1) % SIZE; \\\n    if (rb->count < SIZE) { \\\n        rb->count++; \\\n    } else { \\\n        rb->read_idx = (rb->read_idx + 1) % SIZE; \\\n    } \\\n} \\\nint ring_buffer_pop_##TYPE##_##SIZE(ring_buffer_##TYPE##_##SIZE *rb, TYPE *value) { \\\n    if (rb->count == 0) { \\\n        return 0; /* Buffer is empty */ \\\n    } \\\n    *value = rb->data[rb->read_idx]; \\\n    rb->read_idx = (rb->read_idx + 1) % SIZE; \\\n    rb->count--; \\\n    return 1; /* Success */ \\\n}\n// Example usage with int type and size 5\nDECLARE_RING_BUFFER(int, 5) // Declare the ring buffer type and functions for integers\nint main() {\n    ring_buffer_int_5 rb;\n    ring_buffer_init_int_5(&rb); // Initialize the ring buffer\n// Push values into the ring buffer\nfor (int i = 0; i < 10; ++i) {\n        ring_buffer_push_int_5(&rb, i);\n    }\n    // Pop values from the ring buffer and print them\nint value;\n    while (ring_buffer_pop_int_5(&rb, &value)) {\n        printf(\"%d\\n\", value);\n    }\n    return 0;\n} \n```", "```cpp\n#include <array>\n#include <cstdio>\ntemplate <class T, std::size_t N> struct ring_buffer {\n  std::array<T, N> arr;\n  std::size_t write_idx = 0; // Index of the next element to write (push)\n  std::size_t read_idx = 0;  // Index of the next element to read (pop)\n  std::size_t count = 0;     // Number of elements in the buffer\nvoid push(T t) {\n    arr.at(write_idx) = t;\n    write_idx = (write_idx + 1) % N;\n    if (count < N) {\n      count++;\n    } else {\n      // buffer is full, move forward read_idx\n      read_idx = (read_idx + 1) % N;\n    }\n  }\n  T pop() {\n    if (count == 0) {\n      // Buffer is empty, return a default-constructed T.\nreturn T{};\n    }\n    T value = arr.at(read_idx);\n    read_idx = (read_idx + 1) % N;\n    --count;\n    return value;\n  }\n  bool is_empty() const { return count == 0; }\n};\nint main() {\n  ring_buffer<int, 5> rb;\n  for (int i = 0; i < 10; ++i) {\n    rb.push(i);\n  }\n  while (!rb.is_empty()) {\n    printf(\"%d\\n\", rb.pop());\n  }\n  return 0;\n} \n```", "```cpp\nconstexpr double pi = 3.14159265359; \n```", "```cpp\n#include <cstdio>\n#define VOLTAGE 3300\n#define CURRENT 1000\nint main () {\n    const float resistance = VOLTAGE / CURRENT;\n    printf(\"resistance = %.2f\\r\\n\", resistance);\n    return 0;\n} \n```", "```cpp\nThe output of this simple program might be surprising:\nresistance = 3.00 \n```", "```cpp\n#include <cstdio>\nconstexpr float voltage = 3300;\nconstexpr float current = 1000;\nint main () {\n    const float resistance = voltage / current;\n    printf(\"resistance = %.2f\\r\\n\", resistance);\n    return 0;\n} \n```", "```cpp\nThis would result in\nresistance = 3.30 \n```", "```cpp\nint square(int a) {\n    return a*a;\n}\nint main () {\n    int ret = square(2);\n    return ret;\n} \n```", "```cpp\nsquare(int):\n        push    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nstr r0, [r7, #4]\n        ldr r3, [r7, #4]\n        mul r3, r3, r3\nmov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr\nmain:\npush    {r7, lr}\n        sub sp, sp, #8\nadd r7, sp, #0\nmovs r0, #2\nbl      square(int)\n        str r0, [r7, #4]\n        ldr r3, [r7, #4]\n        mov r0, r3\nadds r7, r7, #8\nmov sp, r7\npop     {r7, pc} \n```", "```cpp\nconstexpr int square(int a) {\n    return a*a;\n}\nint main() {\n    constexpr int val = square(2);\n    return ret;\n} \n```", "```cpp\nmain:\npush    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nmovs r3, #4\nstr r3, [r7, #4]\n        movs r3, #4\nmov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr \n```", "```cpp\nclass MyClass\n{\n    private:\n         int num;\n    public:\n        MyClass(int t_num):num(t_num){}\n        ~MyClass(){}\n        int getNum() const {\n            return num;\n        }\n};\nint main () {\n   MyClass obj(1);\n   return obj.getNum();\n} \n```", "```cpp\nMyClass::MyClass(int) [base object constructor]:\n        push    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nstr r0, [r7, #4]\n        str r1, [r7]\n        ldr r3, [r7, #4]\n        ldr r2, [r7]\n        str r2, [r3]\n        ldr r3, [r7, #4]\n        mov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr\nMyClass::~MyClass() [base object destructor]:\n        push    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nstr r0, [r7, #4]\n        ldr r3, [r7, #4]\n        mov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr\nMyClass::getNum() const:\n        push    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nstr r0, [r7, #4]\n        ldr r3, [r7, #4]\n        ldr r3, [r3]\n        mov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr\nmain:\npush    {r4, r7, lr}\n        sub sp, sp, #12\nadd r7, sp, #0\nadds r3, r7, #4\nmovs r1, #1\nmov r0, r3\nbl      MyClass::MyClass(int) [complete object constructor]\n        adds r3, r7, #4\nmov r0, r3\nbl      MyClass::getNum() const\n        mov r4, r0\nnop\nadds r3, r7, #4\nmov r0, r3\nbl      MyClass::~MyClass() [complete object destructor]\n        mov r3, r4\nmov r0, r3\nadds r7, r7, #12\nmov sp, r7\npop     {r4, r7, pc} \n```", "```cpp\nMyClass::MyClass(int) [base object constructor]:\n        push    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nstr r0, [r7, #4]\n        str r1, [r7]\n        ldr r3, [r7, #4]\n        ldr r2, [r7]\n        str r2, [r3]\n        ldr r3, [r7, #4]\n        mov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr\nMyClass::getNum() const:\n        push    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nstr r0, [r7, #4]\n        ldr r3, [r7, #4]\n        ldr r3, [r3]\n        mov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr\nmain:\npush    {r7, lr}\n        sub sp, sp, #8\nadd r7, sp, #0\nadds r3, r7, #4\nmovs r1, #1\nmov r0, r3\nbl      MyClass::MyClass(int) [complete object constructor]\n        adds r3, r7, #4\nmov r0, r3\nbl      MyClass::getNum() const\n        mov r3, r0\nnop\nmov r0, r3\nadds r7, r7, #8\nmov sp, r7\npop     {r7, pc} \n```", "```cpp\nstruct MyClass\n{\n    int num;\n};\nint main () {\n   MyClass obj(1);\n\n   return obj.num;\n} \n```", "```cpp\nmain:\npush    {r7}\n        sub sp, sp, #12\nadd r7, sp, #0\nmovs r3, #1\nstr r3, [r7, #4]\n        ldr r3, [r7, #4]\n        mov r0, r3\nadds r7, r7, #12\nmov sp, r7\nldr r7, [sp], #4\nbx lr \n```", "```cpp\nmain:\nmovs r0, #1\nbx lr \n```", "```cpp\n#include <cstdio>\n#include <limits>\nint foo(int x) {\n    int y = x + 1;\n    return y > x;\n}\nint main() {\n    if(foo(std::numeric_limits<int>::max())) {\n        printf(\"X is larger than X + 1\\r\\n\");\n    }\n    else {\n        printf(\"X is NOT larger than X + 1\\. Oh nooo !\\r\\n\");\n    }\n    return 0;\n} \n```", "```cpp\nfoo(int):\n        movs r0, #1\nbx lr\n.LC0:\n.ascii \"X is larger then X + 1\\015\\000\"\nmain:\npush    {r3, lr}\n        movw    r0, #:lower16:.LC0\n        movt r0, #:upper16:.LC0\n        bl      puts\n        movs r0, #0\npop     {r3, pc} \n```", "```cpp\nint main() {\n#ifdef USE_TEMPLATES\n  ring_buffer<int, 10> buffer1;\n  ring_buffer<float, 10> buffer2;\n#else\n  ring_buffer_int buffer1;\n  ring_buffer_float buffer2;\n#endif\nfor (int i = 0; i < 20; i++) {\n    buffer1.push(i);\n    buffer2.push(i + 0.2f);\n  }\n  for (int i = 0; i < 10; i++) {\n    printf(\"%d, %.2f\\r\\n\", buffer1.pop(), buffer2.pop());\n  }\n  return 0;\n} \n```", "```cpp\n#include <cstdio>\nstruct Base {\n    virtual void print () {\n        printf(\"Base\\r\\n\");\n    }\n};\nstruct Derived : public Base {\n    void print () override {\n        printf(\"Derived\\r\\n\");\n    }\n};\nvoid printer (Base &base) {\n    base.print();\n}\nint main() {\n    Base base;\n    Derived derived;\n    printer(base);\n    printer(derived);\n  return 0;\n} \n```", "```cpp\nBase\nDerived \n```", "```cpp\nvoid printer (Base &base) {\n    base.print();\n    if(Derived *derived = dynamic_cast<Derived*>(&base); derived!=nullptr) {\n        printf(\"We found Base using RTTI!\\r\\n\");\n    }\n} \n```", "```cpp\nBase\nDerived\nWe found Base using RTTI! \n```", "```cpp\n#include <cstdio>\nstruct A {\n  A() { printf(\"A is created!\\r\\n\"); }\n  ~A() { printf(\"A is destroyed!\\r\\n\"); }\n};\nstruct B {\n  B() { printf(\"B is created!\\r\\n\"); }\n  ~B() { printf(\"B is destroyed!\\r\\n\"); }\n};\nvoid bar() {\n    B b;\n    throw 0;\n}\nvoid foo() {\n  A a;\n  bar();\n  A a1;\n}\nint main() {\n  try {\n    foo();\n  } catch (int &p) {\n    printf(\"Catching an exception!\\r\\n\");\n  }\n  return 0;\n} \n```", "```cpp\nA is created!\nB is created!\nB is destroyed!\nA is destroyed!\nCatching an exception! \n```"]