<html><head></head><body>
		<div id="_idContainer056">
			<h1 class="chapterNumber">Chapter 04</h1>
			<h1 id="_idParaDest-70" class="chapterTitle" lang="en-GB" xml:lang="en-GB">Process Memory<a id="_idTextAnchor110"/> Structure</h1>
			<p class="normal">In this chapter, we are going to talk about memory and its structure within a process. For a C programmer, memory management is always a crucial topic, and applying its best practices requires a basic knowledge about memory structure. In fact, this is not limited to C. In many programming languages such as C++ or Java, you need to have a fundamental understanding of memory and the way it works; otherwise, you face some serious issues that cannot be easily traced and fixed.</p>
			<p class="normal">You might know that memory management is fully manual in C, and more than that, the programmer is the sole responsible person who allocates memory regions and deallocates them once they're no longer needed.</p>
			<p class="normal">Memory management is different in high-level programming languages such as Java or C#, and it is done partly by the programmer and partly by the underlying language platform, such as <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) in the case of using Java. In these languages, the <a id="_idIndexMarker288"/>programmer only issues memory allocations, but they are not responsible for the deallocations. A component called the <em class="italics">garbage collector</em> does the deallocation and frees up the allocated memory automatically.</p>
			<p class="normal">Since there is no such garbage collector in C and C++, having some dedicated chapters for covering the concepts and issues regarding memory management is essential. That's why we have dedicated this chapter and the next to memory-related concepts, and these chapters together should give you a basic understanding of how memory works in C/C++.</p>
			<p class="normal">Throughout this chapter:</p>
			<ul>
				<li class="list">We start by looking at the typical memory structure of a process. This will help us to discover the anatomy of a process and the way it interacts with the memory.</li>
				<li class="list">We discuss static and dynamic memory layouts.</li>
				<li class="list">We introduce the segments found in the aforementioned memory layouts. We see that some of them reside in the executable object file and the rest are created while the process is loading.</li>
				<li class="list">We introduce the probing tools and commands which can help us to detect the segments and see their content, both inside an object file and deep within a running process.</li>
			</ul>
			<p class="normal">As part of this chapter, we get to know two segments called <em class="italics">Stack</em> and <em class="italics">Heap</em>. They are part of the dynamic memory layout of a process and all the allocations and deallocations happen in these segments. In the following chapter, we will discuss Stack and Heap segments in a greater detail because in fact, they are the segments that a programmer interacts with the most.</p>
			<p class="normal">Let's start this chapter by talking about the <em class="italics">process memory layout</em>. This will give you an overall idea about how the memory of a running process is segmented, and what each segment is used for.</p>
			<h1 id="_idParaDest-71" class="title" lang="en-GB" xml:lang="en-GB">Process memory<a id="_idTextAnchor111"/> layout</h1>
			<p class="normal">Whenever <a id="_idIndexMarker289"/>you run an executable file, the operating system creates a new process. A process is a live and running program that is loaded into the memory and has a unique <strong class="bold">Process Identifier</strong> (<strong class="bold">PID</strong>). The <a id="_idIndexMarker290"/>operating system is the sole responsible entity for spawning and loading new processes.</p>
			<p class="normal">A process remains running until it either exits normally, or the process is given a signal, such as <code class="Code-In-Text--PACKT-">SIGTERM</code>, <code class="Code-In-Text--PACKT-">SIGINT</code>, or <code class="Code-In-Text--PACKT-">SIGKILL</code>, which eventually makes it exit. The <code class="Code-In-Text--PACKT-">SIGTERM</code> and <code class="Code-In-Text--PACKT-">SIGINT</code> signals can be ignored, but <code class="Code-In-Text--PACKT-">SIGKILL</code> will kill the process immediately and forcefully.</p>
			<div>
				<div id="_idContainer049" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">The signals mentioned in the preceding section are explained as follows:</p>
					<p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">SIGTERM</code>: This is the termination signal. It allows the process to clean up.</p>
					<p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">SIGINT</code>: This is the interrupt signal usually sent to the foreground process by pressing <kbd class="Key--PACKT-">Ctrl</kbd> + <kbd class="Key--PACKT-">C</kbd>.</p>
					<p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">SIGKILL</code>: This is the kill signal and it closes the process forcefully without letting it clean up.</p>
				</div>
			</div>
			<p class="normal">When creating a process, one of the first things that operating systems do is allocate a portion of memory dedicated to the process and then apply a predefined memory layout. This predefined memory layout is more or less the same in different operating systems, especially in Unix-like operating systems.</p>
			<p class="normal">In this chapter, we're going to explore the structure of this memory layout, and a number of important and useful terms are introduced.</p>
			<p class="normal">The memory layout of an ordinary process is divided into multiple parts. Each part is called a <em class="italics">segment</em>. Each <a id="_idIndexMarker291"/>segment is a region of memory which has a definite task and it is supposed to store a specific type of data. You can see the following list of segments being part of the <a id="_idIndexMarker292"/>memory layout of a running process:</p>
			<ul>
				<li class="list">Uninitialized data segment or <strong class="bold">Block Started by Symbol</strong> (<strong class="bold">BSS</strong>) segment</li>
				<li class="list">Data segment</li>
				<li class="list">Text segment or Code segment</li>
				<li class="list">Stack segment</li>
				<li class="list">Heap segment</li>
			</ul>
			<p class="normal">In the following sections, we will study each of these segments individually, and we discuss the way they contribute to the execution of a program. In the next chapter, we will focus on Stack and Heap segments and we'll discuss them thoroughly. As part of our quest, let's introduce some tools that help us inspect the memory before going into the specifics of the above segments.</p>
			<h1 id="_idParaDest-72" class="title" lang="en-GB" xml:lang="en-GB">Discovering me<a id="_idTextAnchor112"/>mory structure</h1>
			<p class="normal">Unix-like <a id="_idIndexMarker293"/>operating systems provide a set of tools for inspecting the memory segments of a process. You learn in this section that some of these segments reside within the executable object file, and other segments are created dynamically at runtime, when the process is spawned. </p>
			<p class="normal">As you should already know from the two previous chapters, an executable object file and a process are not the same thing, therefore it is expected to have different tools for inspecting each of them.</p>
			<p class="normal">From the previous chapters, we know that an executable object file contains the machine instructions, and it is produced by the compiler. But a process is a running program spawned by executing an executable object file, consuming a region of the main memory, and the CPU is constantly fetching and executing its instructions.</p>
			<p class="normal">A process is a living entity that is being executed inside the operating system while the executable object file is just a file containing a premade initial layout acting as a basis for spawning future processes. It is true that in the memory layout of a running process, some segments come directly from the base executable object file, and the rest are built dynamically at runtime while the process is being loaded. The former <a id="_idIndexMarker294"/>layout is called the <strong class="bold">static memory layout</strong>, and the <a id="_idIndexMarker295"/>latter is called the <strong class="bold">dynamic memory layout</strong>.</p>
			<p class="normal">Static and dynamic memory layouts both have a predetermined set of segments. The content of the static memory layout is prewritten into the executable object file by the compiler, when compiling the source code. On the other hand, the content of the dynamic memory layout is <a id="_idIndexMarker296"/>written by the process instructions allocating memory for variables and arrays, and modifying them according to the program's logic.</p>
			<p class="normal">With all that said, we can guess the content of the static memory layout either by just looking at the source code or the compiled object file. But this is not that easy regarding the dynamic memory layout as it cannot be determined without running the program. In addition, different runs of the same executable file can lead to different content in the dynamic memory layout. In other words, the dynamic content of a process is unique to that process and it should be investigated while the process is still running.</p>
			<p class="normal">Let's begin with inspecting the static memory layout of a process.</p>
			<h1 id="_idParaDest-73" class="title" lang="en-GB" xml:lang="en-GB">Probing static memo<a id="_idTextAnchor113"/>ry layout</h1>
			<p class="normal">The <a id="_idIndexMarker297"/>tools used for inspecting the static memory layout usually work on the object files. To get some initial insight, we'll start with an example, <em class="italics">example 4.1</em>, which is a minimal C program that doesn't have any variable or logic as part of it:</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-1 [ExtremeC_examples_chapter4_1.c]: A minimal C program</p>
			<p class="normal">First, we need to compile the preceding program. We compile it in Linux using <code class="Code-In-Text--PACKT-">gcc</code>:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter4_1.c -o ex4_1-linux.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-1: Compiling example 4.1 using gcc in Linux</p>
			<p class="normal">After a successful compilation and having the final executable binary linked, we get an executable object file named <code class="Code-In-Text--PACKT-">ex4_1-linux.out</code>. This file contains a predetermined static memory layout that is specific to the Linux operating system, and it will exist in all future processes spawned based on this executable file.</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">size</code> command is the first tool that we want to introduce. It can be used to print the static memory layout of an executable object file. </p>
			<p class="normal">You can see the usage of the <code class="Code-In-Text--PACKT-">size</code> command in order to see the various segments found as part of the static memory layout as follows:</p>
			<p class="snippet shell"><strong class="highlight">$ size ex4_1-linux.out</strong></p>
			<p class="snippet shell">   text    data     bss     dec     hex   filename</p>
			<p class="snippet shell">   1099     544       8    1651     673   ex4_1-linux.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-2: Using the size command to see the static segments of ex4_1-linux.out</p>
			<p class="normal">As you see, we have Text, Data, and BSS segments as part of the static layout. The shown <a id="_idIndexMarker298"/>sizes are in bytes.</p>
			<p class="normal">Now, let's compile the same code, <em class="italics">example 4.1</em>, in a different operating system. We have chosen macOS and we are going to use the <code class="Code-In-Text--PACKT-">clang</code> compiler:</p>
			<p class="snippet shell"><strong class="highlight">$ clang ExtremeC_examples_chapter4_1.c -o ex4_1-macos.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-3: Compiling example 4.1 using clang in macOS</p>
			<p class="normal">Since macOS is a POSIX-compliant operating system just like Linux, and the <code class="Code-In-Text--PACKT-">size</code> command is specified to be part of the POSIX utility programs, macOS should also have the <code class="Code-In-Text--PACKT-">size</code> command. Therefore, we can use the same command to see the static memory segments of <code class="Code-In-Text--PACKT-">ex4_1-macos.out</code>:</p>
			<p class="snippet shell"><strong class="highlight">$ size ex4_1-macos.out</strong></p>
			<p class="snippet shell">__TEXT __DATA  __OBJC  others       dec         hex</p>
			<p class="snippet shell">4096   0       0       4294971392   4294975488  100002000</p>
			<p class="snippet shell"><strong class="highlight">$ size -m ex4_1-macos.out</strong></p>
			<p class="snippet shell">Segment __PAGEZERO: 4294967296</p>
			<p class="snippet shell">Segment __TEXT: 4096</p>
			<p class="snippet shell">    Section __text: 22</p>
			<p class="snippet shell">    Section __unwind_info: 72</p>
			<p class="snippet shell">    total 94</p>
			<p class="snippet shell">Segment __LINKEDIT: 4096</p>
			<p class="snippet shell">total 4294975488</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-4: Using the size command to see the static segments of ex4_1-macos.out</p>
			<p class="normal">In the preceding shell box, we have run the <code class="Code-In-Text--PACKT-">size</code> command twice; the second run gives us more details about the found memory segments. You might have noticed that we have Text and Data segments in macOS, just like Linux, but there is no BSS segment. Note that the BSS segment also exists in macOS, but it is not shown in the <code class="Code-In-Text--PACKT-">size</code> output. Since the BSS segment contains uninitialized global variables, there is no need to allocate some bytes as part of the object file and it is enough to know how many bytes are required for storing those global variables.</p>
			<p class="normal">In the preceding shell boxes, there is an interesting point to note. The size of the Text segment is 1,099 bytes in Linux while it is 4 KB in macOS. It can also be seen that the Data segment for a minimal C program has a non-zero size in Linux, but it is empty in macOS. It is apparent <a id="_idIndexMarker299"/>that the low-level memory details are different on various platforms.</p>
			<p class="normal">Despite these little differences between Linux and macOS, we can see that both platforms have the Text, Data, and BSS segments as part of their static layout. From now on, we gradually explain what each of these segments are used for. In the upcoming sections, we'll discuss each segment separately and we give an example slightly different from <em class="italics">example 4.1</em> for each, in order to see how differently each segment responds to the minor changes in the code.</p>
			<h2 id="_idParaDest-74" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor114"/>BSS segment</h2>
			<p class="normal">We <a id="_idIndexMarker300"/>start with the BSS segment. <strong class="bold">BSS</strong> stands for <strong class="bold">Block Started by Symbol</strong>. Historically, the name was used to denote reserved regions <a id="_idIndexMarker301"/>for uninitialized words. Basically, that's <a id="_idIndexMarker302"/>the purpose that we use the BSS segment for; either uninitialized global variables or global variables set to zero.</p>
			<p class="normal">Let's expand <em class="italics">example 4.1</em> by adding a few uninitialized global variables. You see that uninitialized global variables will contribute to the BSS segment. The following code box demonstrates <em class="italics">example 4.2</em>:</p>
			<p class="snippet code"><strong class="highlight">int global_var1;</strong></p>
			<p class="snippet code"><strong class="highlight">int global_var2;</strong></p>
			<p class="snippet code"><strong class="highlight">int global_var3 = 0;</strong></p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-2 [ExtremeC_examples_chapter4_2.c]: A minimal C program with a few global variables either uninitialized or set to zero</p>
			<p class="normal">The integers <code class="Code-In-Text--PACKT-">global_var1</code>, <code class="Code-In-Text--PACKT-">global_var2</code>, and <code class="Code-In-Text--PACKT-">global_var3</code> are global variables which are uninitialized. For observing the changes made to the resulting executable object file in Linux, in comparison to <em class="italics">example 4.1</em>, we again run the <code class="Code-In-Text--PACKT-">size</code> command:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter4_2.c -o ex4_2-linux.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ size ex4_2-linux.out</strong></p>
			<p class="snippet shell">   text    data     bss     dec     hex   filename</p>
			<p class="snippet shell">   1099     544      16    1659     67b   ex4_2-linux.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-5: Using the size command to see the static segments of ex4_2-linux.out</p>
			<p class="normal">If you compare the preceding output with a similar output from <em class="italics">example 4.1</em>, you will notice that the size of the BSS segment has changed. In other words, declaring global variables that are <em class="italics">not</em> initialized or set to zero will add up to the BSS segment. These special global variables <a id="_idIndexMarker303"/>are part of the static layout and they become <a id="_idIndexMarker304"/>preallocated when a process is loading, and they never get deallocated until the process is alive. In other words, they have a static lifetime.</p>
			<div>
				<div id="_idContainer050" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">Because of design concerns, we usually prefer to use local variables in our algorithms. Having too many global variables can increase the binary size. In addition, keeping sensitive data in the global scope, it can introduce security concerns. Concurrency issues, especially data races, namespace pollution, unknown ownership, and having too many variables in the global scope, are some of the complications that global variables introduce.</p>
				</div>
			</div>
			<p class="normal">Let's compile <em class="italics">example 4.2</em> in macOS and have a look at the output of the <code class="Code-In-Text--PACKT-">size</code> command:</p>
			<p class="snippet shell"><strong class="highlight">$ clang ExtremeC_examples_chapter4_2.c -o ex4_2-macos.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ size ex4_2-macos.out </strong></p>
			<p class="snippet shell">__TEXT __DATA  __OBJC  others       dec         hex</p>
			<p class="snippet shell">4096   4096       0    4294971392   4294979584  100003000</p>
			<p class="snippet shell"><strong class="highlight">$ size -m ex4_2-macos.out</strong></p>
			<p class="snippet shell">Segment __PAGEZERO: 4294967296</p>
			<p class="snippet shell">Segment __TEXT: 4096</p>
			<p class="snippet shell">    Section __text: 22</p>
			<p class="snippet shell">    Section __unwind_info: 72</p>
			<p class="snippet shell">    total 94</p>
			<p class="snippet shell">Segment __DATA: 4096</p>
			<p class="snippet shell">    Section __common: 12</p>
			<p class="snippet shell">    total 12</p>
			<p class="snippet shell">Segment __LINKEDIT: 4096</p>
			<p class="snippet shell">total 4294979584</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-6: Using the size command to see the static segments of ex4_2-macos.out</p>
			<p class="normal">And again, it is different from Linux. In Linux, we had preallocated 8 bytes for the BSS segment, when we had no global variables. In <em class="italics">example 4.2</em>, we added three new uninitialized global variables whose sizes sum up to 12 bytes, and the Linux C compiler expanded the BSS segment by 8 bytes. But in macOS, we still have no BSS segment as part of the <code class="Code-In-Text--PACKT-">size</code>'s output, but the compiler has expanded the <code class="Code-In-Text--PACKT-">data</code> segment from 0 bytes to 4KB, which <a id="_idIndexMarker305"/>is the default page size in macOS. This<a id="_idIndexMarker306"/> means that <code class="Code-In-Text--PACKT-">clang</code> has allocated a new memory page for the <code class="Code-In-Text--PACKT-">data</code> segment inside the layout. Again, this simply shows how much the details of the memory layout can be different in various platforms.</p>
			<div>
				<div id="_idContainer051" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">While allocating the memory, it doesn't matter how many bytes a program needs to allocate. The <em class="italics">allocator</em> always acquires memory in terms of <em class="italics">memory pages</em> until the total allocated size covers the program's need. More information <a id="_idIndexMarker307"/>about the Linux memory allocator can be found here: <a href="https://www.kernel.org/doc/gorman/html/understand/understand009.html"><span class="url">https://www.kernel.org/doc/gorman/html/understand/understand009.html</span></a>.</p>
				</div>
			</div>
			<p class="normal">In <em class="italics">Shell Box 4-6</em>, we have a section named <code class="Code-In-Text--PACKT-">__common</code>, inside the <code class="Code-In-Text--PACKT-">_DATA</code> segment, which is 12 bytes, and it is in fact referring to the BSS segment that is not shown as BSS in the <code class="Code-In-Text--PACKT-">size</code>'s output. It refers to 3 uninitialized global integer variables or 12 bytes (each integer being 4 bytes). It's worth taking note that uninitialized global variables are set to <em class="italics">zero</em> by default. There is no other value that could be imagined for uninitialized variables.</p>
			<p class="normal">Let's now talk about the next segment in the static memory layout; the Data segment.</p>
			<h2 id="_idParaDest-75" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor115"/>Data segment</h2>
			<p class="normal">In <a id="_idIndexMarker308"/>order to show <a id="_idIndexMarker309"/>what type of variables are stored in the Data segment, we are going to declare more global variables, but this time we initialize them with non-zero values. The following example, <em class="italics">example 4.3</em>, expands <em class="italics">example 4.2</em> and adds two new initialized global variables:</p>
			<p class="snippet code">int global_var1;</p>
			<p class="snippet code">int global_var2;</p>
			<p class="snippet code">int global_var3 = 0;</p>
			<p class="snippet code"><strong class="highlight">double global_var4 = 4.5;</strong></p>
			<p class="snippet code"><strong class="highlight">char global_var5 = 'A';</strong></p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-3 [ExtremeC_examples_chapter4_3.c]: A minimal C program with both initialized and uninitialized global variables</p>
			<p class="normal">The <a id="_idIndexMarker310"/>following shell box shows the output of the <code class="Code-In-Text--PACKT-">size</code> command, in <a id="_idIndexMarker311"/>Linux, and for <em class="italics">example 4.3</em>:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter4_3.c -o ex4_3-linux.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ size ex4_3-linux.out</strong></p>
			<p class="snippet shell">   text    data     bss     dec     hex filename</p>
			<p class="snippet shell">   1099     553      20    1672     688 ex4_3-linux.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-7: Using the size command to see the static segments of ex4_3-linux.out</p>
			<p class="normal">We know that the Data segment is used to store the initialized global variables set to a non-zero value. If you compare the output of the <code class="Code-In-Text--PACKT-">size</code> command for <em class="italics">examples 4.2</em> and <em class="italics">4.3</em>, you can easily see that the Data segment is increased by 9 bytes, which is the sum of the sizes of the two newly added global variables (one 8-byte <code class="Code-In-Text--PACKT-">double</code> and one 1-byte <code class="Code-In-Text--PACKT-">char</code>).</p>
			<p class="normal">Let's look at the changes in macOS:</p>
			<p class="snippet shell"><strong class="highlight">$ clang ExtremeC_examples_chapter4_3.c -o ex4_3-macos.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ s</strong><strong class="highlight">ize ex4_3-macos.out </strong></p>
			<p class="snippet shell">__TEXT __DATA  __OBJC  others       dec         hex</p>
			<p class="snippet shell">4096   4096       0    4294971392   4294979584  100003000</p>
			<p class="snippet shell"><strong class="highlight">$ size -m ex4_3-macos.out</strong></p>
			<p class="snippet shell">Segment __PAGEZERO: 4294967296</p>
			<p class="snippet shell">Segment __TEXT: 4096</p>
			<p class="snippet shell">    Section __text: 22</p>
			<p class="snippet shell">    Section __unwind_info: 72</p>
			<p class="snippet shell">    total 94</p>
			<p class="snippet shell">Segment __DATA: 4096</p>
			<p class="snippet shell">    Section __data: 9</p>
			<p class="snippet shell">    Section __common: 12</p>
			<p class="snippet shell">    total 21</p>
			<p class="snippet shell">Segment __LINKEDIT: 4096</p>
			<p class="snippet shell">total 4294979584</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-8: Using the size command to see the static segments of ex4_3-macos.out</p>
			<p class="normal">In the first run, we see no changes since the size of all global variables summed together is still way below 4KB. But in the second run, we see a new section as part of the <code class="Code-In-Text--PACKT-">_DATA</code> segment; the <code class="Code-In-Text--PACKT-">__data</code> section. The memory allocated for this section is 9 bytes, and it is in accordance <a id="_idIndexMarker312"/>with the size of the newly introduced <a id="_idIndexMarker313"/>initialized global variables. And still, we have 12 bytes for uninitialized global variables as we had in <em class="italics">example 4.2</em>, and in macOS.</p>
			<p class="normal">On a further note, the <code class="Code-In-Text--PACKT-">size</code> command only shows the size of the segments, but not their contents. There are other commands, specific to each operating system, that can be used to inspect the content of segments found in an object file. For instance, in Linux, you have <code class="Code-In-Text--PACKT-">readelf</code> and <code class="Code-In-Text--PACKT-">objdump</code> commands in order to see the content of <em class="italics">ELF</em> files. These tools can also be used to probe the static memory layout inside the object files. As part of two previous chapters we explored some of these commands.</p>
			<p class="normal">Other than global variables, we can have some static variables declared inside a function. These variables retain their values while calling the same function multiple times. These variables can be stored either in the Data segment or the BSS segment depending on the platform and whether they are initialized or not. The following code box demonstrates how to declare some static variables within a function:</p>
			<p class="snippet code">void func() {</p>
			<p class="snippet code">  static int i;</p>
			<p class="snippet code">  static int j = 1;</p>
			<p class="snippet code">  ...</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-4: Declaration of two static variables, one initialized and the other one uninitialized</p>
			<p class="normal">As you see in <em class="italics">Code Box 4-4</em>, the <code class="Code-In-Text--PACKT-">i</code> and <code class="Code-In-Text--PACKT-">j</code> variables are static. The <code class="Code-In-Text--PACKT-">i</code> variable is uninitialized and the <code class="Code-In-Text--PACKT-">j</code> variable is initialized with value <code class="Code-In-Text--PACKT-">1</code>. It doesn't matter how many times you enter and leave the <code class="Code-In-Text--PACKT-">func</code> function, these variables keep their most recent values.</p>
			<p class="normal">To elaborate more on how this is done, at runtime, the <code class="Code-In-Text--PACKT-">func</code> function has access to these variables located in either the Data segment or the BSS segment, which has a static lifetime. That's basically why these variables are called <em class="italics">static</em>. We know that the <code class="Code-In-Text--PACKT-">j</code> variable is <a id="_idIndexMarker314"/>located in the Data segment simply <a id="_idIndexMarker315"/>because it has an initial value, and the <code class="Code-In-Text--PACKT-">i</code> variable is supposed to be inside the BSS segment since it is not initialized.</p>
			<p class="normal">Now, we want to introduce the second command to examine the content of the BSS segment. In Linux, the <code class="Code-In-Text--PACKT-">objdump</code> command can be used to print out the content of memory segments found in an object file. This corresponding command in macOS is <code class="Code-In-Text--PACKT-">gobjdump</code> which should be installed first.</p>
			<p class="normal">As part of <em class="italics">example 4.4</em>, we try to examine the resulting executable object file to find the data written to the Data segment as some global variables. The following code box shows the code for <em class="italics">example 4.4</em>:</p>
			<p class="snippet code">int     x = 33;            // 0x00000021</p>
			<p class="snippet code">int     y = 0x12153467;</p>
			<p class="snippet code">char z[6] = "ABCDE";</p>
			<p class="snippet code">int main(int argc, char**argv) {</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-5 [ExtremeC_examples_chapter4_4.c]: Some initialized global variables which should be written to the Data segment</p>
			<p class="normal">The preceding code is easy to follow. It just declares three global variables with some initial values. After compilation, we need to dump the content of the Data segment in order to find the written values. </p>
			<p class="normal">The following commands will demonstrate how to compile and use <code class="Code-In-Text--PACKT-">objdump</code> to see the content of the Data segment:</p>
			<p class="snippet shell"><strong class="highlight">$ <a id="_idTextAnchor116"/>gcc ExtremeC_examples_chapter4_4.c -o ex4_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ objdump -s -j .data ex4_4.out</strong></p>
			<p class="snippet shell">a.out:     file format elf64-x86-64</p>
			<p class="snippet shell">Contents of section .data:</p>
			<p class="snippet shell"> 601020 00000000 00000000 00000000 00000000  ...............</p>
			<p class="snippet shell"> 601030 21000000 67341512 41424344 4500      !....4..ABCDE.</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-9: Using the objdump command to see the content of the Data segment</p>
			<p class="normal">Let's explain how the preceding output, and especially the contents of the section <code class="Code-In-Text--PACKT-">.data</code>, should be read. The first column on the left is the address column. The next four columns are the contents, and each of them is showing <code class="Code-In-Text--PACKT-">4</code> bytes of data. So, in each row, we have the contents of 16 bytes. The last column on the right shows the ASCII representation of the same bytes shown in the middle columns. A dot character means that the <a id="_idIndexMarker316"/>character cannot be shown using alphanumerical <a id="_idIndexMarker317"/>characters. Note that the option <code class="Code-In-Text--PACKT-">-s</code> tells <code class="Code-In-Text--PACKT-">objdump</code> to show the full content of the chosen section and the option <code class="Code-In-Text--PACKT-">-j .data</code> tells it to show the content of the section <code class="Code-In-Text--PACKT-">.data</code>.</p>
			<p class="normal">The first line is 16 bytes filled by zeros. There is no variable stored here, so nothing special for us. The second line shows the contents of the Data segment starting with the address <code class="Code-In-Text--PACKT-">0x601030</code>. The first 4 bytes is the value stored in the <code class="Code-In-Text--PACKT-">x</code> variable found in <em class="italics">example 4.4</em>. The next 4 bytes also contain the value for the <code class="Code-In-Text--PACKT-">y</code> variable. The final 6 bytes are the characters inside the <code class="Code-In-Text--PACKT-">z</code> array. The contents of <code class="Code-In-Text--PACKT-">z</code> can be clearly seen in the last column.</p>
			<p class="normal">If you pay enough attention to the content shown in <em class="italics">Shell Box 4-9</em>, you see that despite the fact that we write 33, in decimal base, as <code class="Code-In-Text--PACKT-">0x00000021</code>, in hexadecimal base it is stored differently in the segment. It is stored as <code class="Code-In-Text--PACKT-">0x21000000</code>. This is also true for the content of the <code class="Code-In-Text--PACKT-">y</code> variable. We have written it as <code class="Code-In-Text--PACKT-">0x12153467</code>, but it is stored differently as <code class="Code-In-Text--PACKT-">0x67341512</code>. It seems that the order of bytes is reversed.</p>
			<p class="normal">The effect explained is because of the <em class="italics">endianness</em> concept. Generally, we have two different types of endianness, <em class="italics">big-endian</em> and <em class="italics">little-endian</em>. The value <code class="Code-In-Text--PACKT-">0x12153467</code> is the big-endian representation for the number <code class="Code-In-Text--PACKT-">0x12153467</code>, as the biggest byte, <code class="Code-In-Text--PACKT-">0x12</code>, comes first. But the value <code class="Code-In-Text--PACKT-">0x67341512</code> is the little-endian representation for the number <code class="Code-In-Text--PACKT-">0x12153467</code>, as the smallest byte, <code class="Code-In-Text--PACKT-">0x67</code>, comes first.</p>
			<p class="normal">No matter what the endianness is, we always read the correct value in C. Endianness is a property of the CPU and with a different CPU you may get a different byte order in your final object files. This is one of the reasons why you cannot run an executable object file on hardware with different endianness.</p>
			<p class="normal">It would be interesting to see the same output on a macOS machine. The following shell box demonstrates how to use the <code class="Code-In-Text--PACKT-">gobjdump</code> command in order to see the content of the Data segment:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc</strong><strong class="highlight"> ExtremeC_examples_chapter4_4.c -o ex4_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gobjdump -s -j .data ex4_4.out</strong></p>
			<p class="snippet shell">a.out:     file format mach-o-x86-64</p>
			<p class="snippet shell">Contents of section .data:</p>
			<p class="snippet shell"> 100001000 21000000 67341512 41424344 4500      !...g4..ABCDE.</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-10: Using the gobjdump command in macOS to see the content of the Data segment</p>
			<p class="normal">It should be read exactly like the Linux output found as part of <em class="italics">Shell Code 4-9</em>. As you see, in macOS, there are no 16-byte zero headers in the data segment. Endianness of the contents <a id="_idIndexMarker318"/>also shows that the binary has been compiled for a little-endian processor. </p>
			<p class="normal">As a <a id="_idIndexMarker319"/>final note in this section, other tools like <code class="Code-In-Text--PACKT-">readelf</code> in Linux and <code class="Code-In-Text--PACKT-">dwarfdump</code> in macOS can be used in order to inspect the content of object files. The binary content of the object files can also be read using tools such as <code class="Code-In-Text--PACKT-">hexdump</code>.</p>
			<p class="normal">In the following section, we will discuss the Text segment and how it can be inspected using <code class="Code-In-Text--PACKT-">objdump</code>.</p>
			<h2 id="_idParaDest-76" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor117"/>Text segment</h2>
			<p class="normal">As <a id="_idIndexMarker320"/>we know from <em class="italics">Chapter 2</em>, <em class="italics">Compilation and Linking</em>, the linker writes the resulting machine-level instructions into the final executable <a id="_idIndexMarker321"/>object file. Since the Text segment, or the Code segment, contains all the machine-level instructions of a program, it should be located in the executable object file, as part of its static memory layout. These instructions are fetched by the processor and get executed at runtime when the process is running.</p>
			<p class="normal">To dive deeper, let's have a look at the Text segment of a real executable object file. For this purpose, we propose a new example. The following code box shows <em class="italics">example 4.5</em>, and as you see, it is just an empty <code class="Code-In-Text--PACKT-">main</code> function:</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-6 [ExtremeC_examples_chapter4_5.c]: A minimal C program</p>
			<p class="normal">We can use the <code class="Code-In-Text--PACKT-">objdump</code> command to dump the various parts of the resulting executable object file. Note that the <code class="Code-In-Text--PACKT-">objdump</code> command is only available in Linux, while other operating systems have their own set of commands to do the same.</p>
			<p class="normal">The <a id="_idIndexMarker322"/>following shell box demonstrates using the <code class="Code-In-Text--PACKT-">objdump</code> command to extract the content of various sections present in the executable <a id="_idIndexMarker323"/>object file resulting from <em class="italics">example 4.5</em>. Note that the output is shortened in order to only show the <code class="Code-In-Text--PACKT-">main</code> function's corresponding section and its assembly instructions:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter4_5.c -o ex4_5.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ objdump -S ex4_5.out</strong></p>
			<p class="snippet shell">ex4_5.out:     file format elf64-x86-64</p>
			<p class="snippet shell">Disassembly of section .init:</p>
			<p class="snippet shell">0000000000400390 &lt;_init&gt;:</p>
			<p class="snippet shell">... truncated.</p>
			<p class="snippet shell">.</p>
			<p class="snippet shell">.</p>
			<p class="snippet shell">Disassembly of section .plt:</p>
			<p class="snippet shell">00000000004003b0 &lt;__libc_start_main@plt-0x10&gt;:</p>
			<p class="snippet shell">... truncated</p>
			<p class="snippet shell">00000000004004d6 &lt;main&gt;:</p>
			<p class="snippet shell">  4004d6:   55                      push   %rbp</p>
			<p class="snippet shell">  4004d7:   48 89 e5                mov    %rsp,%rbp</p>
			<p class="snippet shell">  4004da:   b8 00 00 00 00          mov    $0x0,%eax</p>
			<p class="snippet shell">  4004df:   5d                      pop    %rbp</p>
			<p class="snippet shell">  4004e0:   c3                      retq</p>
			<p class="snippet shell">  4004e1:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</p>
			<p class="snippet shell">  4004e8:   00 00 00</p>
			<p class="snippet shell">  4004eb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</p>
			<p class="snippet shell">00000000004004f0 &lt;__libc_csu_init&gt;:</p>
			<p class="snippet shell">... truncated</p>
			<p class="snippet shell">.</p>
			<p class="snippet shell">.</p>
			<p class="snippet shell">.</p>
			<p class="snippet shell">0000000000400564 &lt;_fini&gt;:</p>
			<p class="snippet shell">... truncated</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-11: Using objdump to show the content of the section corresponding to the main function</p>
			<p class="normal">As you see in the preceding shell box, there are various sections containing machine-level instructions: the <code class="Code-In-Text--PACKT-">.text</code>, <code class="Code-In-Text--PACKT-">.init</code>, and <code class="Code-In-Text--PACKT-">.plt</code> sections and some others, which all together allow a program to become loaded and running. All of these sections are part of the same Text segment found in the static memory layout, inside the executable object file.</p>
			<p class="normal">Our C program, written for <em class="italics">example 4.5</em>, had only one function, the <code class="Code-In-Text--PACKT-">main</code> function, but as you see, the final executable object file has a dozen other functions. </p>
			<p class="normal">The preceding output, seen as part of <em class="italics">Shell Box 4-11</em>, shows that the <code class="Code-In-Text--PACKT-">main</code> function is not the first function <a id="_idIndexMarker324"/>to be called in a C program and there are <a id="_idIndexMarker325"/>logics before and after <code class="Code-In-Text--PACKT-">main</code> that should be executed. As explained in <em class="italics">Chapter 2</em>, <em class="italics">Compilation and Linking</em>, in Linux, these functions are usually borrowed from the <code class="Code-In-Text--PACKT-">glibc</code> library, and they are put together by the linker to form the final executable object file.</p>
			<p class="normal">In the following section, we start to probe the dynamic memory layout of a <a id="_idTextAnchor118"/>process.</p>
			<h1 id="_idParaDest-77" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor119"/>Probing dynamic memory layout</h1>
			<p class="normal">The <a id="_idIndexMarker326"/>dynamic memory layout is actually the runtime memory of a process, and it exists as long as the process is running. When you execute an <a id="_idIndexMarker327"/>executable object file, a program called <em class="italics">loader</em> takes care of the execution. It spawns a new process and it creates the initial memory layout which is supposed to be dynamic. To form this layout, the segments found in the static layout will be copied from the executable object file. More than that, two new segments will also be added to it. Only then can the process proceed and become running.</p>
			<p class="normal">In short, we expect to have five segments in the memory layout of a running process. Three of these segments are directly copied from the static layout found in the executable object file. The two newly added segments are called Stack and Heap segments. These segments are dynamic, and they exist only when the process is running. This means that you cannot find any trace of them as part of the executable object file.</p>
			<p class="normal">In this section, our ultimate goal is to probe the Stack and Heap segments and introduce tools and places in an operating system which can be used for this purpose. From time to time, we might refer to these segments as the process's dynamic memory layout, without considering the other three segments copied from the object file, but you should always remember that the dynamic memory of a process consists of all five segments together.</p>
			<p class="normal">The Stack segment is the <a id="_idIndexMarker328"/>default memory region where we allocate variables from. It is a limited region in terms of size, and you cannot hold big objects in it. In contrast, the Heap <a id="_idIndexMarker329"/>segment is a bigger and adjustable region of memory which can be used to hold big objects and huge arrays. Working with the Heap segment requires its own API which we introduce as part of our discussion.</p>
			<p class="normal">Remember, dynamic memory layout is different from <em class="italics">Dynamic Memory Allocation</em>. You should not mix these two concepts, since they are referring to two different things! As we progress, we'll learn more about different types of memory allocations, especially dynamic memory allocation.</p>
			<p class="normal">The five segments found in the dynamic memory of a process are referring to parts of the main memory that are already <em class="italics">allocated</em>, <em class="italics">dedicated</em>, and <em class="italics">private</em> to a running process. These segments, excluding the Text segment, which is literally static and constant, are dynamic in a sense that their contents are always changing at runtime. That's due to the fact that these segments are constantly being modified by the algorithm that the process is executing.</p>
			<p class="normal">Inspecting the dynamic memory layout of a process requires its own procedure. This implies that we need to have a running process before being able to probe its dynamic memory layout. This requires us to write examples which remain running for a fairly long time in order to keep their dynamic memory in place. Then, we can use our inspection tools to study their dynamic memory structure.</p>
			<p class="normal">In the following section, we give an example on how to probe the structure of dynamic memory.</p>
			<h2 id="_idParaDest-78" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor120"/>Memory mappings</h2>
			<p class="normal">Let's <a id="_idIndexMarker330"/>start with a simple example. <em class="italics">Example 4.6</em> will be running for an indefinite amount of time. This way, we have a process <a id="_idIndexMarker331"/>that never dies, and in the meantime, we can probe its memory structure. And of course, we can <em class="italics">kill</em> it whenever we are done with the inspection. You can find the example in the following code box:</p>
			<p class="snippet code">#include &lt;unistd.h&gt; // Needed for sleep function</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  // Infinite loop</p>
			<p class="snippet code">  while (1) {</p>
			<p class="snippet code">    sleep(1); // Sleep 1 second</p>
			<p class="snippet code">  };</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-6 [ExtremeC_examples_chapter4_6.c]: Example 4.6 used for probing dynamic memory layout</p>
			<p class="normal">As you see, the code is just an infinite loop, which means that the process will run forever. So, we have enough time to inspect the process's memory. Let's first build it.</p>
			<div>
				<div id="_idContainer052" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">unistd.h</code> header is available only on Unix-like operating systems; to be more precise, in POSIX-compliant operating systems. This means that on Microsoft Windows, which is not POSIX-compliant, you have to include the <code class="Code-In-Text--PACKT-">windows.h</code> header instead.</p>
				</div>
			</div>
			<p class="normal">The following shell box shows how to compile the example in Linux:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter4_6.c -o ex4_6.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-12: Compiling example 4.6 in Linux</p>
			<p class="normal">Then, we <a id="_idIndexMarker332"/>run it as follows. In order to use <a id="_idIndexMarker333"/>the same prompt for issuing further commands while the process is running, we should start the process in the background:</p>
			<p class="snippet shell"><strong class="highlight">$ ./ ex4_6.out &amp;</strong></p>
			<p class="snippet shell">[1] 402</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref"> Shell Box 4-13: Running example 4.6 in the background</p>
			<p class="normal">The process is now running in the background. According to the output, the PID of the recently started process is 402, and we will use this PID to kill it in the future. The PID is different every time you run a program; therefore, you'll probably see a different PID on your computer. Note that whenever you run a process in the background, the shell prompt returns immediately, and you can issue further commands.</p>
			<div>
				<div id="_idContainer053" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">If you have the PID (Process ID) of a process, you can easily end it using the <code class="Code-In-Text--PACKT-">kill</code> command. For example, if the PID is 402, the following command will work in Unix-like operating systems: <code class="Code-In-Text--PACKT-">kill -9 402</code>.</p>
				</div>
			</div>
			<p class="normal">The PID is the identifier we use to inspect the memory of a process. Usually, an operating system provides its own specific mechanism to query various properties of a process <a id="_idIndexMarker334"/>based on its PID. But here, we are <a id="_idIndexMarker335"/>only interested in the dynamic memory of a process and we'll use the available mechanism in Linux to find more about the dynamic memory structure of the above running process.</p>
			<p class="normal">On a Linux machine, the information about a process can be found in files under the <code class="Code-In-Text--PACKT-">/proc</code> directory. It uses a <a id="_idIndexMarker336"/>special filesystem called <em class="italics">procfs</em>. This filesystem is not an ordinary filesystem meant for keeping actual files, but it is more of a hierarchical interface to query about various properties of an individual process or the system as a whole.</p>
			<div>
				<div id="_idContainer054" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">procfs is not limited to Linux. It is usually part of Unix-like operating systems, but not all Unix-like operating systems use it. For example, FreeBSD uses this filesystem, but macOS doesn't.</p>
				</div>
			</div>
			<p class="normal">Now, we are going to use procfs to see the memory structure of the running process. The memory of a process consists of a number of <em class="italics">memory mappings</em>. Each memory mapping represents a dedicated region of memory which is mapped to a specific file or segment as part of the process. Shortly, you'll see that both Stack and Heap segments have their own memory mappings in each process.</p>
			<p class="normal">One of the things that you can use procfs for is to observe the current memory mappings of the process. Next, we are going to show this. </p>
			<p class="normal">We know that the process is running with PID 402. Using the <code class="Code-In-Text--PACKT-">ls</code> command, we can see the contents of the <code class="Code-In-Text--PACKT-">/proc/402</code> directory, shown as follows:</p>
			<p class="snippet shell"><strong class="highlight">$ ls -l /proc/402</strong></p>
			<p class="snippet shell">total of 0</p>
			<p class="snippet shell">dr-xr-xr-x  2 root root 0 Jul 15 22:28 attr</p>
			<p class="snippet shell">-rw-r--r--  1 root root 0 Jul 15 22:28 autogroup</p>
			<p class="snippet shell">-r--------  1 root root 0 Jul 15 22:28 auxv</p>
			<p class="snippet shell">-r--r--r--  1 root root 0 Jul 15 22:28 cgroup</p>
			<p class="snippet shell">--w-------  1 root root 0 Jul 15 22:28 clear_refs</p>
			<p class="snippet shell">-r--r--r--  1 root root 0 Jul 15 22:28 cmdline</p>
			<p class="snippet shell">-rw-r--r--  1 root root 0 Jul 15 22:28 comm</p>
			<p class="snippet shell">-rw-r--r--  1 root root 0 Jul 15 22:28 coredump_filter</p>
			<p class="snippet shell">-r--r--r--  1 root root 0 Jul 15 22:28 cpuset</p>
			<p class="snippet shell">lrwxrwxrwx  1 root root 0 Jul 15 22:28 cwd -&gt; /root/codes</p>
			<p class="snippet shell">-r--------  1 root root 0 Jul 15 22:28 environ</p>
			<p class="snippet shell">lrwxrwxrwx  1 root root 0 Jul 15 22:28 exe -&gt; /root/codes/a.out</p>
			<p class="snippet shell">dr-x------  2 root root 0 Jul 15 22:28 fd</p>
			<p class="snippet shell">dr-x------  2 root root 0 Jul 15 22:28 fdinfo</p>
			<p class="snippet shell">-rw-r--r--  1 root root 0 Jul 15 22:28 gid_map</p>
			<p class="snippet shell">-r--------  1 root root 0 Jul 15 22:28 io</p>
			<p class="snippet shell">-r--r--r--  1 root root 0 Jul 15 22:28 limits</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-14: Listing the content of /proc/402</p>
			<p class="normal">As you can see, there are many files and directories under the <code class="Code-In-Text--PACKT-">/proc/402</code> directory. Each of these files and directories corresponds to a specific property of the process. For querying the <a id="_idIndexMarker337"/>memory mappings of the process, we <a id="_idIndexMarker338"/>have to see the contents of the file <code class="Code-In-Text--PACKT-">maps</code> under the PID directory. We use the <code class="Code-In-Text--PACKT-">cat</code> command to dump the contents of the <code class="Code-In-Text--PACKT-">/proc/402/maps</code> file. It can be seen as follows:</p>
			<p class="snippet shell"><strong class="highlight">$ cat /proc/402/maps</strong></p>
			<p class="snippet shell">00400000-00401000 r-xp 00000000 08:01 790655              .../extreme_c/4.6/ex4_6.out</p>
			<p class="snippet shell">00600000-00601000 r--p 00000000 08:01 790655              .../extreme_c/4.6/ex4_6.out</p>
			<p class="snippet shell">00601000-00602000 rw-p 00001000 08:01 790655              .../extreme_c/4.6/ex4_6.out</p>
			<p class="snippet shell">7f4ee16cb000-7f4ee188a000 r-xp 00000000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f4ee188a000-7f4ee1a8a000 ---p 001bf000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f4ee1a8a000-7f4ee1a8e000 r--p 001bf000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f4ee1a8e000-7f4ee1a90000 rw-p 001c3000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f4ee1a90000-7f4ee1a94000 rw-p 00000000 00:00 0</p>
			<p class="snippet shell">7f4ee1a94000-7f4ee1aba000 r-xp 00000000 08:01 787342      /lib/x86_64-linux-gnu/ld-2.23.so</p>
			<p class="snippet shell">7f4ee1cab000-7f4ee1cae000 rw-p 00000000 00:00 0</p>
			<p class="snippet shell">7f4ee1cb7000-7f4ee1cb9000 rw-p 00000000 00:00 0</p>
			<p class="snippet shell">7f4ee1cb9000-7f4ee1cba000 r--p 00025000 08:01 787342      /lib/x86_64-linux-gnu/ld-2.23.so</p>
			<p class="snippet shell">7f4ee1cba000-7f4ee1cbb000 rw-p 00026000 08:01 787342      /lib/x86_64-linux-gnu/ld-2.23.so</p>
			<p class="snippet shell">7f4ee1cbb000-7f4ee1cbc000 rw-p 00000000 00:00 0</p>
			<p class="snippet shell"><strong class="highlight">7ffe94296000-7ffe942b7000 rw-p 00000000 00:00 0           [stack]</strong></p>
			<p class="snippet shell">7ffe943a0000-7ffe943a2000 r--p 00000000 00:00 0           [vvar]</p>
			<p class="snippet shell">7ffe943a2000-7ffe943a4000 r-xp 00000000 00:00 0           [vdso]</p>
			<p class="snippet shell">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0   [vsyscall]</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-15: Dumping the content of /proc/402/maps</p>
			<p class="normal">As you see in <em class="italics">Shell Box 4-15</em>, the result consists of a number of rows. Each row represents a memory mapping that indicates a range of memory addresses (a region) that are <a id="_idIndexMarker339"/>allocated and mapped to a specific file <a id="_idIndexMarker340"/>or segment in the dynamic memory layout of the process. Each mapping has a number of fields separated by one or more spaces. Next, you can find the descriptions of these fields from left to right:</p>
			<ul>
				<li class="list"><strong class="bold">Address range</strong>: These are the start and end addresses of the mapped range. You can <a id="_idIndexMarker341"/>find a file path in front of them if the region is mapped to a file. This is a smart way to map the same loaded shared object file in various processes. We have talked about this as part of <em class="italics">Chapter 3</em>, <em class="italics">Object Files</em>.</li>
				<li class="list"><strong class="bold">Permissions</strong>: This <a id="_idIndexMarker342"/>indicates whether the content can be executed (<code class="Code-In-Text--PACKT-">x</code>), read (<code class="Code-In-Text--PACKT-">r</code>), or modified (<code class="Code-In-Text--PACKT-">w</code>). The region can also be shared (<code class="Code-In-Text--PACKT-">s</code>) by the other processes or be private (<code class="Code-In-Text--PACKT-">p</code>) only to the owning process.</li>
				<li class="list"><strong class="bold">Offset</strong>: If the <a id="_idIndexMarker343"/>region is mapped to a file, this is the offset from the beginning of the file. It is usually 0 if the region is not mapped to a file.</li>
				<li class="list"><strong class="bold">Device</strong>: If the <a id="_idIndexMarker344"/>region is mapped to a file, this would be the device number (in the form of m:n), indicating a device that contains the mapped file. For example, this would be the device number of the hard disk that contains a shared object file.</li>
				<li class="list"><strong class="bold">The inode</strong>: If the <a id="_idIndexMarker345"/>region is mapped to a file, that file should reside on a filesystem. Then, this field would be the inode number of the <a id="_idIndexMarker346"/>file in that filesystem. An <em class="italics">inode</em> is an abstract concept within filesystems such as <em class="italics">ext4</em> which are mostly used in Unix-like operating systems. Each inode can represent both files and directories. Every inode has a number that is used to access its content.</li>
				<li class="list"><strong class="bold">Pathname or description</strong>: If the region is mapped to a file, this would be the path to <a id="_idIndexMarker347"/>that file. Otherwise, it would be left <a id="_idIndexMarker348"/>empty, or it would describe the purpose of the region. For example, <code class="Code-In-Text--PACKT-">[stack]</code> indicates that the region is actually <a id="_idIndexMarker349"/>the Stack segment.</li>
			</ul>
			<p class="normal">The <code class="Code-In-Text--PACKT-">maps</code> file provides even <a id="_idIndexMarker350"/>more useful information regarding the dynamic memory layout of a process. We'll need a new example to properly demonstrate this.</p>
			<h2 id="_idParaDest-79" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor121"/>Stack segment</h2>
			<p class="normal">First, let's <a id="_idIndexMarker351"/>talk more about the Stack segment. The Stack is a crucial <a id="_idIndexMarker352"/>part of the dynamic memory in every process, and it exists in almost all architectures. You have seen it in the memory mappings described as <code class="Code-In-Text--PACKT-">[stack]</code>.</p>
			<p class="normal">Both Stack and Heap segments have dynamic contents which are constantly changing while the process is running. It is not easy to see the dynamic contents of these segments and most of the time you need a debugger such as <code class="Code-In-Text--PACKT-">gdb</code> to go through the memory bytes and read them while a process is running.</p>
			<p class="normal">As pointed out before, the Stack segment is usually limited in size, and it is not a good place to store big objects. If the Stack segment is full, the process cannot make any further function calls since the function call mechanism relies heavily on the functionality of the Stack segment. </p>
			<p class="normal">If the Stack segment of a process becomes full, the process gets terminated by the operating system. <em class="italics">Stack overflow</em> is a famous error that happens when the Stack segment becomes full. We discuss the function call mechanism in future paragraphs.</p>
			<p class="normal">As explained before, the Stack segment is a default memory region that variables are allocated from. Suppose that you've declared a variable inside a function, as follows:</p>
			<p class="snippet code">void func() {</p>
			<p class="snippet code">  // The memory required for the following variable is</p>
			<p class="snippet code">  // allocated from the stack segment.</p>
			<p class="snippet code">  int a; </p>
			<p class="snippet code">  ... </p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-7: Declaring a local variable which has its memory allocated from the Stack segment</p>
			<p class="normal">In the preceding function, while declaring the variable, we have not mentioned anything to let the compiler know which segment the variable should be allocated from. Because of this, the compiler uses the Stack segment by default. The Stack segment is the first place that allocations are made from.</p>
			<p class="normal">As its name implies, it is a <em class="italics">stack</em>. If you declare a local variable, it becomes allocated on top of the Stack segment. When you're leaving the scope of the declared local variable, the compiler <a id="_idIndexMarker353"/>has to pop the local variables <a id="_idIndexMarker354"/>first in order to bring up the local variables declared in the outer scope.</p>
			<div>
				<div id="_idContainer055" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">Stack, in its <a id="_idIndexMarker355"/>abstract form, is a <strong class="bold">First In, Last Out</strong> (<strong class="bold">FILO</strong>) or <strong class="bold">Last In, First Out</strong> (<strong class="bold">LIFO</strong>) data <a id="_idIndexMarker356"/>structure. Regardless of the implementation details, each entry is stored (pushed) on top of the stack, and it will be buried by further entries. One entry cannot be popped out without removing the above entries first.</p>
				</div>
			</div>
			<p class="normal">Variables are not the only entities that are stored in the Stack segment. Whenever you make a function call, a new entry called a <em class="italics">stack frame</em> is placed on top of the Stack segment. Otherwise, you <a id="_idIndexMarker357"/>cannot return to the calling function or return the result back to the caller.</p>
			<p class="normal">Having a healthy stacking mechanism is vital to have a working program. Since the size of the Stack is limited, it is a good practice to declare small variables in it. Also, the Stack shouldn't be filled by too many stack frames as a result of making infinite <em class="italics">recursive</em> calls or too many function calls.</p>
			<p class="normal">From a different perspective, the Stack segment is a region used by you, as a programmer, to keep your data and declare the local variables used in your algorithms, and by the operating system, as the program runner, to keep the data needed for its internal mechanisms to execute your program successfully.</p>
			<p class="normal">In this sense, you should be careful when working with this segment because misusing it or corrupting its data can interrupt the running process or even make it crash. The Heap segment is the memory segment that is only managed by the programmer. We will cover the Heap segment in the next section.</p>
			<p class="normal">It is not easy to see the contents of the Stack segment from outside if we are only using the tools we've introduced for probing the static memory layout. This part of memory contains private <a id="_idIndexMarker358"/>data and can be sensitive. It is also private to the <a id="_idIndexMarker359"/>process, and other processes cannot read or modify it.</p>
			<p class="normal">So, for sailing through the Stack memory, one has to attach something to a process and see the Stack segment through the eyes of that process. This can be done using a <em class="italics">debugger</em> program. A debugger attaches to a process and allows a programmer to control the target process and investigate its memory content. We will use this technique and examine the Stack memory in the following chapter. For now, we leave the Stack segment to discuss more about the Heap segment. We will get back to the Stack in the next chapter.</p>
			<h2 id="_idParaDest-80" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor122"/>Heap segment</h2>
			<p class="normal">The <a id="_idIndexMarker360"/>following example, <em class="italics">example 4.7</em>, shows how memory <a id="_idIndexMarker361"/>mappings can be used to find regions allocated for the Heap segment. It is quite similar to <em class="italics">example 4.6</em>, but it allocates a number of bytes from the Heap segment before entering the infinite loop. </p>
			<p class="normal">Therefore, just like we did for <em class="italics">example 4.6</em>, we can go through the memory mappings of the running process and see which mapping refers to the Heap segment.</p>
			<p class="normal">The following code box contains the code for <em class="italics">example 4.7</em>:</p>
			<p class="snippet code">#include &lt;unistd.h&gt; // Needed for sleep function</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // Needed for malloc function</p>
			<p class="snippet code">#include &lt;stdio.h&gt; // Needed for printf</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  void* ptr = malloc(1024); // Allocate 1KB from heap</p>
			<p class="snippet code">  printf("Address: %p\n", ptr);</p>
			<p class="snippet code">  fflush(stdout); // To force the print</p>
			<p class="snippet code">  // Infinite loop</p>
			<p class="snippet code">  while (1) {</p>
			<p class="snippet code">    sleep(1); // Sleep 1 second</p>
			<p class="snippet code">  };</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-8 [ExtremeC_examples_chapter4_7.c]: Example 4.7 used for probing the Heap segment</p>
			<p class="normal">In the preceding code, we used the <code class="Code-In-Text--PACKT-">malloc</code> function. It's the primary way to allocate extra memory from the Heap segment. It accepts the number of bytes that should be allocated, and it returns a generic pointer.</p>
			<p class="normal">As a reminder, a generic pointer (or a void pointer) contains a memory address but it cannot be <em class="italics">dereferenced</em> and used directly. It should be cast to a specific pointer type before being used.</p>
			<p class="normal">In <em class="italics">example 4.7</em>, we allocate 1024 bytes (or 1KB) before entering the loop. The program <a id="_idIndexMarker362"/>also prints the address of the pointer received from <code class="Code-In-Text--PACKT-">malloc</code> before <a id="_idIndexMarker363"/>starting the loop. Let's compile the example and run it as we did for <em class="italics">example 4.7</em>:</p>
			<p class="snippet shell"><strong class="highlight">$ g++ ExtremeC_examples_chapter4_7.c -o ex4_7.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex4_7.out &amp;</strong></p>
			<p class="snippet shell">[1] 3451</p>
			<p class="snippet shell">Address: 0x19790010</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-16: Compiling and running example 4.7</p>
			<p class="normal">Now, the process is running in the background, and it has obtained the PID 3451. </p>
			<p class="normal">Let's see what memory regions have been mapped for this process by looking at its <code class="Code-In-Text--PACKT-">maps</code> file:</p>
			<p class="snippet shell"><strong class="highlight">$ cat /proc/3451/maps</strong></p>
			<p class="snippet shell">00400000-00401000 r-xp 00000000 00:2f 176521             .../extreme_c/4.7/ex4_7.out</p>
			<p class="snippet shell">00600000-00601000 r--p 00000000 00:2f 176521             .../extreme_c/4.7/ex4_7.out</p>
			<p class="snippet shell">00601000-00602000 rw-p 00001000 00:2f 176521             .../extreme_c/4.7/ex4_7.out</p>
			<p class="snippet shell"><strong class="highlight">01979000-0199a000 rw-p 00000000 00:00 0                  [heap]</strong></p>
			<p class="snippet shell">7f7b32f12000-7f7b330d1000 r-xp 00000000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f7b330d1000-7f7b332d1000 ---p 001bf000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f7b332d1000-7f7b332d5000 r--p 001bf000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f7b332d5000-7f7b332d7000 rw-p 001c3000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so</p>
			<p class="snippet shell">7f7b332d7000-7f7b332db000 rw-p 00000000 00:00 0 </p>
			<p class="snippet shell">7f7b332db000-7f7b33301000 r-xp 00000000 00:2f 27        /lib/x86_64-linux-gnu/ld-2.23.so</p>
			<p class="snippet shell">7f7b334f2000-7f7b334f5000 rw-p 00000000 00:00 0 </p>
			<p class="snippet shell">7f7b334fe000-7f7b33500000 rw-p 00000000 00:00 0 </p>
			<p class="snippet shell">7f7b33500000-7f7b33501000 r--p 00025000 00:2f 27         /lib/x86_64-linux-gnu/ld-2.23.so</p>
			<p class="snippet shell">7f7b33501000-7f7b33502000 rw-p 00026000 00:2f 27         /lib/x86_64-linux-gnu/ld-2.23.so</p>
			<p class="snippet shell">7f7b33502000-7f7b33503000 rw-p 00000000 00:00 0 </p>
			<p class="snippet shell">7ffdd63c2000-7ffdd63e3000 rw-p 00000000 00:00 0          [stack]</p>
			<p class="snippet shell">7ffdd63e7000-7ffdd63ea000 r--p 00000000 00:00 0          [vvar]</p>
			<p class="snippet shell">7ffdd63ea000-7ffdd63ec000 r-xp 00000000 00:00 0          [vdso]</p>
			<p class="snippet shell">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 4-17: Dumping the content of /proc/3451/maps</p>
			<p class="normal">If you look at <em class="italics">Shell Box 4-17</em> carefully, you will see a new mapping which is highlighted, and it is being described by <code class="Code-In-Text--PACKT-">[heap]</code>. This region has been added because of using the <code class="Code-In-Text--PACKT-">malloc</code> function. If you calculate the size of the region, it is <code class="Code-In-Text--PACKT-">0x21000</code> bytes or 132 KB. This means <a id="_idIndexMarker364"/>that to allocate only 1 KB in the code, a region of the <a id="_idIndexMarker365"/>size 132 KB has been allocated. </p>
			<p class="normal">This is usually done in order to prevent further memory allocations when using <code class="Code-In-Text--PACKT-">malloc</code> again in the future. That's simply because the memory allocation from the Heap segment is not cheap and it has both memory and time overheads.</p>
			<p class="normal">If you go back to the code shown in <em class="italics">Code Box 4-8</em>, the address that the <code class="Code-In-Text--PACKT-">ptr</code> pointer is pointing to is also interesting. The Heap's memory mapping, shown in <em class="italics">Shell Box 4-17</em>, is allocated from the address <code class="Code-In-Text--PACKT-">0x01979000</code> to <code class="Code-In-Text--PACKT-">0x0199a000</code>, and the address stored in <code class="Code-In-Text--PACKT-">ptr</code> is <code class="Code-In-Text--PACKT-">0x19790010</code>, which is obviously inside the Heap range, located at an offset of <code class="Code-In-Text--PACKT-">16</code> bytes.</p>
			<p class="normal">The Heap segment can grow to sizes far greater than 132 KB, even to tens of gigabytes, and usually it is use<a id="_idTextAnchor123"/><a id="_idTextAnchor124"/><a id="_idTextAnchor125"/><a id="_idTextAnchor126"/><a id="_idTextAnchor127"/><a id="_idTextAnchor128"/>d for permanent, global, and very big objects such as arrays and bit streams.</p>
			<p class="normal">As pointed out before, allocation and deallocation within the heap segment require a program to call specific functions provided by the C standard. While you can have local variables on top of the Stack segment, and you can use them directly to interact with the memory, the <a id="_idIndexMarker366"/>Heap memory can be accessed <a id="_idIndexMarker367"/>only through pointers, and this is one of the reasons why knowing pointers and being able to work with them is crucial to every C programmer. Let's bring up <em class="italics">example 4.8</em>, which demonstrates how to use pointers to access the Heap space:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;   // For printf function</p>
			<p class="snippet code">#include &lt;stdlib.h&gt;  // For malloc and free function</p>
			<p class="snippet code">void fill(char* ptr) {</p>
			<p class="snippet code">  ptr[0] = 'H';</p>
			<p class="snippet code">  ptr[1] = 'e';</p>
			<p class="snippet code">  ptr[2] = 'l';</p>
			<p class="snippet code">  ptr[3] = 'l';</p>
			<p class="snippet code">  ptr[5] = 0;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  void* gptr = malloc(10 * sizeof(char));</p>
			<p class="snippet code">  char* ptr = (char*)gptr;</p>
			<p class="snippet code">  fill(ptr);</p>
			<p class="snippet code">  printf("%s!\n", ptr);</p>
			<p class="snippet code">  free(ptr);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 4-9 [ExtremeC_examples_chapter4_8.c]: Using pointers to interact with the Heap memory</p>
			<p class="normal">The preceding program allocates 10 bytes from the Heap space using the <code class="Code-In-Text--PACKT-">malloc</code> function. The <code class="Code-In-Text--PACKT-">malloc</code> function receives the number of bytes that should be allocated and returns a generic pointer addressing the first byte of the allocated memory block.</p>
			<p class="normal">For using the returned pointer, we have to cast it to a proper pointer type. Since we are going to use the allocated memory to store some characters, we choose to cast it to a <code class="Code-In-Text--PACKT-">char</code> pointer. The casting is done before calling the <code class="Code-In-Text--PACKT-">fill</code> function.</p>
			<p class="normal">Note that the local pointer variables, <code class="Code-In-Text--PACKT-">gptr</code> and <code class="Code-In-Text--PACKT-">ptr</code>, are allocated from the Stack. These pointers need memory to store their values, and this memory comes from the Stack segment. But the address that they are pointing to is inside the Heap segment. This is the theme when working with Heap memories. You have local pointers which are allocated from the Stack segment, but they are actually pointing to a region allocated from the Heap segment. We show more of these in the following chapter.</p>
			<p class="normal">Note that the <code class="Code-In-Text--PACKT-">ptr</code> pointer inside the <code class="Code-In-Text--PACKT-">fill</code> function is also allocated from the Stack but it is in a different scope, and it is different from the <code class="Code-In-Text--PACKT-">ptr</code> pointer declared in the <code class="Code-In-Text--PACKT-">main</code> function.</p>
			<p class="normal">When it <a id="_idIndexMarker368"/>comes to Heap memory, the program, or actually the <a id="_idIndexMarker369"/>programmer, is responsible for memory allocation. The program is also responsible for deallocation of the memory when it is not needed. Having a piece of allocated Heap memory that is not <em class="italics">reachable</em> is considered a <em class="italics">memory leak</em>. By not being reachable, we mean that there is no pointer that can be used to address that region.</p>
			<p class="normal">Memory leaks are fatal to programs because having an incremental memory leak will eventually use up the whole allowed memory space, and this can kill the process. That's why the program is calling the <code class="Code-In-Text--PACKT-">free</code> function before returning from the <code class="Code-In-Text--PACKT-">main</code> function. The call to the <code class="Code-In-Text--PACKT-">free</code> function will deallocate the acquired Heap memory block, and the program shouldn't use those Heap <a id="_idTextAnchor129"/><a id="_idTextAnchor130"/><a id="_idTextAnchor131"/><a id="_idTextAnchor132"/><a id="_idTextAnchor133"/><a id="_idTextAnchor134"/><a id="_idTextAnchor135"/><a id="_idTextAnchor136"/><a id="_idTextAnchor137"/><a id="_idTextAnchor138"/><a id="_idTextAnchor139"/><a id="_idTextAnchor140"/><a id="_idTextAnchor141"/><a id="_idTextAnchor142"/><a id="_idTextAnchor143"/><a id="_idTextAnchor144"/><a id="_idTextAnchor145"/><a id="_idTextAnchor146"/><a id="_idTextAnchor147"/>addresses anymore.</p>
			<p class="normal">More on Stack and Heap segments will come in the next chapter.</p>
			<h1 id="_idParaDest-81" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor148"/>Summary</h1>
			<p class="normal">Our initial goal in this chapter was to provide an overview of the memory structure of a process in a Unix-like operating system. As we have covered a lot in this chapter, take a minute to read through what we've been through, as you should now feel comfortable in understanding what we have accomplished:</p>
			<ul>
				<li class="list">We described the dynamic memory structure of a running process as well as the static memory structure of an executable object file.</li>
				<li class="list">We observed that the static memory layout is located inside the executable object file and it is broken into pieces which are called segments. We found out that the Text, Data, and BSS segments are part of the static memory layout.</li>
				<li class="list">We saw that the Text segment or Code segment is used to store the machine-level instructions meant to be executed when a new process is spawned out of the current executable object file.</li>
				<li class="list">We saw that the BSS segment is used to store global variables that are either uninitialized or set to zero.</li>
				<li class="list">We explained that the Data segment is used to store initialized global variables.</li>
				<li class="list">We used the <code class="Code-In-Text--PACKT-">size</code> and <code class="Code-In-Text--PACKT-">objdump</code> commands to probe the internals of object files. We can also use object file dumpers like <code class="Code-In-Text--PACKT-">readelf</code> in order to find these segments inside an object file.</li>
				<li class="list">We probed the dynamic memory layout of a process. We saw that all segments are copied from the static memory layout into the dynamic memory of the process. However, there are two new segments in the dynamic memory layout; the Stack segment, and the Heap segment.</li>
				<li class="list">We explained that the Stack segment is the default memory region used for allocations.</li>
				<li class="list">We learned that the local variables are always allocated on top of the Stack region.</li>
				<li class="list">We also observed that the secret behind the function calls lies within the Stack segment and the way it works.</li>
				<li class="list">We saw that we have to use a specific API, or a set of functions, in order to allocate and deallocate Heap memory regions. This API is provided by the C standard library.</li>
				<li class="list">We discussed memory leakage and how it can happen regarding Heap memory regions.</li>
			</ul>
			<p class="normal">The next chapter is about the Stack and Heap segments specifically. It will use the topics we have covered within this chapter, and it will add more to those foundations. More examples will be given, and new probing tools will be introduced; this will complete our discussion regarding memory management in C.</p>
		</div>
</body></html>