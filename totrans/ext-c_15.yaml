- en: Chapter 15
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: Thread Execution
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程执行
- en: 'As we explained in the previous chapter, concurrency can be implemented using
    only one of the *multithreading* or *multi-processing* approaches within a POSIX-compliant
    system. Since these two approaches are such large topics to discuss, they''ve
    been split into four separate chapters in order to give each topic the coverage
    that it needs:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中解释的，在POSIX兼容系统中，可以使用**多线程**或**多进程**方法中的任何一个来实现并发。由于这两个主题都非常广泛，因此它们被分为四个单独的章节，以便为每个主题提供所需的覆盖范围：
- en: '**The multithreading approach** will be discussed in both this chapter and
    *Chapter 16*, *Thread Synchronization*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多线程方法**将在本章和第16章“线程同步”中讨论。'
- en: '**The multi-processing approach** will be covered in *Chapter 17*, *Process
    Execution*, and *Chapter 18*, *Process Synchronization*.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多进程方法**将在第17章“进程执行”和第18章“进程同步”中介绍。'
- en: In this chapter, we're going to look at the anatomy of a thread and the APIs
    that can be used to create and manage threads. In the next chapter, *Chapter 16,
    Thread Synchronization*, we will go through the concurrency control mechanisms
    in a multithreaded environment to study how they are supposed to resolve concurrency-related
    issues.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨线程的结构以及可以用来创建和管理线程的API。在下一章，即第16章“线程同步”中，我们将研究多线程环境中的并发控制机制，以研究它们应该如何解决与并发相关的问题。
- en: Multi-processing is all about the idea of bringing concurrency into software
    by breaking its logic into concurrent processes, which eventually leads to multi-process
    software. Because of the existing differences between multithreading and multi-processing,
    we decided to move the discussion of multi-processing to two separate chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程的概念是将并发引入软件，通过将逻辑分解为并发进程来实现，这最终导致多进程软件。由于多线程和多进程之间存在现有差异，我们决定将多进程的讨论移至两个单独的章节。
- en: In comparison, multithreading, the focus of the first two chapters, is limited
    to a single-process system. This is the most basic fact about threads and is the
    reason why we're focusing on it first.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，多线程，前两章的重点，局限于单进程系统。这是关于线程的最基本事实，也是我们首先关注它的原因。
- en: In the previous chapter, we briefly explained the differences and similarities
    between multithreading and multi-processing. In this chapter, we are going to
    focus on multithreading, coupled with an exploration of the way they should be
    used in order to have several threads of execution running flawlessly in a single
    process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了多线程和多进程之间的差异和相似之处。在本章中，我们将专注于多线程，并探讨它们应该如何使用，以便在单个进程中无缝运行多个执行线程。
- en: 'The following topics are covered in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: We begin by talking about threads. Both *user threads* and *kernel threads*
    are explained in this section, and some of the most important properties of threads
    are discussed. These properties help us to better understand a multithreaded environment.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先讨论线程。本节中解释了**用户线程**和**内核线程**，并讨论了线程的一些最重要的属性。这些属性有助于我们更好地理解多线程环境。
- en: Then we move onto the next section, which is dedicated to basic programming
    using the **POSIX threading** library, or for short, the **pthread** library.
    This library is the main standard library that allows us to develop concurrent
    programs on POSIX systems, but it doesn't mean that non-POSIX-compliant operating
    systems don't support concurrency. For non-compliant operating systems like Microsoft
    Windows, they are still able to provide their own API for developing concurrent
    programs. The POSIX threading library provides support for both threads and processes.
    However, in this chapter, our focus is on the threading part, where we are looking
    at how the pthread library can both be used to create a thread and manage it further.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们进入下一节，该节专门介绍使用**POSIX线程库**进行的基本编程，简称**pthread**库。这个库是主要的标准化库，允许我们在POSIX系统上开发并发程序，但这并不意味着不兼容POSIX的操作系统不支持并发。对于像Microsoft
    Windows这样的不兼容操作系统，它们仍然能够提供自己的API来开发并发程序。POSIX线程库为线程和进程提供支持。然而，在本章中，我们的重点是线程部分，我们将探讨pthread库如何被用来创建线程并进一步管理它。
- en: In a further step, we also demonstrate a race condition together with a data
    race produced in some example C codes that are using the pthread library. This
    develops the basis for continuing our discussion in the next chapter regarding
    *thread synchronization*.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进一步的研究中，我们还演示了在某些使用pthread库的示例C代码中产生的竞态条件和数据竞争。这为我们在下一章继续讨论*线程同步*奠定了基础。
- en: '**Note**:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: To be able to fully grasp the discussions that we are going to have in regard
    to the multithreading approach, it's highly recommended that you complete this
    chapter before moving onto *Chapter 16*, *Thread Synchronization*. This is because
    the themes introduced in this chapter are featured throughout the second part
    of our look into thread synchronization, which will come in the next chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '为了能够完全理解我们将要讨论的多线程方法，强烈建议你在进入第16章*线程同步*之前完成本章。这是因为本章引入的主题贯穿于我们下一章将要探讨的线程同步的第二部分。 '
- en: Before going any further, please bear in mind that we will only be covering
    the basic use of the POSIX threading library in this chapter. It's beyond the
    scope of this book to dive into the multiple and fascinating elements of the POSIX
    threading library and therefore, it is recommended that you take some time to
    explore the pthread library in more detail and gain sufficient practice through
    written examples to enable you to be comfortable with it. The more advanced usage
    of the POSIX threading library will be demonstrated across the remaining chapters
    of this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记住，在本章中，我们只将涵盖POSIX线程库的基本用法。深入探讨POSIX线程库的多个有趣元素超出了本书的范围，因此，建议你花些时间更详细地探索pthread库，并通过书面示例获得足够的实践，以便你能够熟悉它。POSIX线程库的更高级用法将在本书剩余的章节中演示。
- en: For now, though, let's delve deep into the concept of threads by beginning with
    an overview looking at everything we know about them. This is a key element in
    our understanding, as we are going to be introducing the other key concepts that
    we will be learning about in the remaining pages of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，让我们深入探讨线程的概念，从概述我们所知道的一切开始。这是我们理解的关键要素，因为我们将在本章剩余的页面上介绍其他关键概念。
- en: Threads
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: In the previous chapter, we discussed threads as part of the multithreading
    approach that you can use when wanting to write concurrent programs in a POSIX-compliant
    operating system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了线程作为多线程方法的一部分，当你在POSIX兼容的操作系统上编写并发程序时可以使用这种方法。
- en: In this section, you will find a recap on everything you should know about threads.
    We will also bring in some new information that is relevant to topics we will
    discuss later. Remember that all of this information will act as a foundation
    for continuing to develop multithreaded programs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将找到关于线程你应该知道的所有内容的回顾。我们还将引入一些与我们将要讨论的主题相关的新信息。请记住，所有这些信息都将作为继续开发多线程程序的基础。
- en: Every thread is initiated by a process. It will then belong to that process
    forever. It is not possible to have a shared thread or transfer the ownership
    of a thread to another process. Every process has at least one thread that is
    its *main thread*. In a C program, the `main` function is executed as part of
    the main thread.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都是由一个进程初始化的。然后它将永远属于该进程。不可能有一个共享的线程或将线程的所有权转让给另一个进程。每个进程至少有一个线程，即它的*主线程*。在一个C程序中，`main`函数作为主线程的一部分被执行。
- en: All the threads share the same **Process ID** (**PID**). If you use utilities
    like `top` or `htop`, you can easily see the threads are sharing the same process
    ID, and are grouped under it. More than that, all the attributes of the owner
    process are inherited by all of its threads for example, group ID, user ID, current
    working directory, and signal handlers. As an example, the current working directory
    of a thread is the same as its owner process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程共享相同的**进程ID**（**PID**）。如果你使用`top`或`htop`等工具，可以很容易地看到线程共享相同的进程ID，并且被分组在其下。不仅如此，所有线程的属性都继承自其所属进程，例如，组ID、用户ID、当前工作目录和信号处理器。例如，线程的当前工作目录与其所属进程相同。
- en: Every thread has a unique and dedicated **Thread ID** (**TID**). This ID can
    be used to pass signals to that thread or track it while debugging. You will see
    that in POSIX threads, the thread ID is accessible via the `pthread_t` variable.
    In addition, every thread has also a dedicated signal mask that can be used to
    filter out the signals it may receive.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个独特且专用的**线程ID**（**TID**）。这个ID可以用来向该线程传递信号或在进行调试时跟踪它。你将看到在POSIX线程中，线程ID可以通过`pthread_t`变量访问。此外，每个线程还有一个专用的信号屏蔽，可以用来过滤它可能接收到的信号。
- en: All of the threads within the same process have access to all of the *file descriptors*
    opened by other threads in that process. Therefore, all the threads can both read
    or modify the resources behind those file descriptors. This is also true regarding
    *socket descriptors* and opened *sockets*. In upcoming chapters, you'll learn
    more about file descriptors and sockets.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同一进程内的所有线程都可以访问该进程内其他线程打开的所有*文件描述符*。因此，所有线程都可以读取或修改那些文件描述符背后的资源。这也适用于*套接字描述符*和打开的*套接字*。在接下来的章节中，你将了解更多关于文件描述符和套接字的内容。
- en: Threads can use all the techniques used by processes introduced in chapter 14
    to share or transfer a state. Take note of the fact that having a shared state
    in a shared place (like a database) is different from transmitting it on a network
    for example, and this results in two different categories of IPC techniques. We
    will come back to this point in future chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以使用在第14章中介绍的进程的所有技术来共享或传递状态。请注意，在共享位置（如数据库）中共享状态与在网络上传输它（例如）是不同的，这导致了两种不同的IPC技术类别。我们将在未来的章节中回到这一点。
- en: 'Here, you can find a list of methods that can be used by threads to share or
    transfer a state in a POSIX-compliant system:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以找到线程在POSIX兼容系统中可以用来共享或传递状态的列表：
- en: Owner process's memory (Data, Stack, and Heap segments). This method is *only*
    specific to threads and not processes.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所属进程的内存（数据、堆栈和堆段）。这种方法*仅*适用于线程，不适用于进程。
- en: Filesystem.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统。
- en: Memory-mapped files.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存映射文件。
- en: Network (using internet sockets).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络（使用互联网套接字）。
- en: Signal passing between threads.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程间的信号传递。
- en: Shared memory.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存。
- en: POSIX pipes.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX管道。
- en: Unix domain sockets.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix域套接字。
- en: POSIX message queues.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX消息队列。
- en: Environment variables.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量。
- en: To proceed with the thread properties, all of the threads within the same process
    can use the same process's memory space to store and maintain a shared state.
    This is the most common way of sharing a state among a number of threads. The
    Heap segment of the process is usually used for this purpose.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理线程属性时，同一进程内的所有线程可以使用该进程的内存空间来存储和维护共享状态。这是在多个线程之间共享状态最常见的方式。进程的堆段通常用于此目的。
- en: The lifetime of a thread is dependent on the lifetime of its owner process.
    When a process gets *killed* or *terminated*, all the threads belonging to that
    process will also get terminated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的生命周期依赖于其所属进程的生命周期。当一个进程被*杀死*或*终止*时，该进程所属的所有线程也将被终止。
- en: When the main thread ends, the process quits immediately. However, if there
    are other *detached* threads running, the process waits for all of them to be
    finished before getting terminated. Detached threads will be explained while explaining
    the thread creation in POSIX.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当主线程结束时，进程会立即退出。然而，如果有其他*分离*的线程正在运行，进程会等待它们全部完成后再终止。分离线程将在解释POSIX中线程创建时进行说明。
- en: The process that creates a thread can be the kernel process. At the same time,
    it can also be a user process initiated in the user space. If the process is the
    kernel, the thread is called a *kernel-level thread* or simply a *kernel thread*,
    otherwise, the thread is called a *user-level thread*. Kernel threads typically
    execute important logic, and because of this they have higher priorities than
    that of user threads. As an example, a device driver may be using a kernel thread
    to wait for a hardware signal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的进程可以是内核进程。同时，它也可以是在用户空间中启动的用户进程。如果进程是内核，则该线程被称为*内核级线程*或简称为*内核线程*，否则，该线程被称为*用户级线程*。内核线程通常执行重要逻辑，因此它们比用户线程有更高的优先级。例如，设备驱动程序可能使用内核线程来等待硬件信号。
- en: Similar to user threads that have access to the same memory region, kernel threads
    are also able to access the kernel's memory space and, subsequently, all the procedures
    and units within the kernel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与可以访问相同内存区域的用户线程类似，内核线程也能够访问内核的内存空间，从而能够访问内核中的所有过程和单元。
- en: Throughout this book we will be mainly talking about user threads, not kernel
    threads. That's because the required API for working with user threads is provided
    by the POSIX standard. But there is no standard interface for creating and managing
    a kernel thread and they are only specific to each kernel.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将主要讨论用户线程，而不是内核线程。这是因为与用户线程一起工作的API由POSIX标准提供。但是，没有标准接口用于创建和管理内核线程，它们仅针对每个内核特定。
- en: Creating and managing kernel threads is beyond the scope of this book. Thus,
    from this point on, when we are using the term *thread*, we are referring to user
    threads and not kernel threads.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和管理内核线程超出了本书的范围。因此，从现在开始，当我们使用术语*线程*时，我们指的是用户线程，而不是内核线程。
- en: A user cannot create a thread directly. The user needs to spawn a process first,
    as only then can that process's main thread initiate another thread. Note that
    only threads can create threads.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不能直接创建线程。用户需要首先启动一个进程，因为只有进程的主线程才能启动另一个线程。请注意，只有线程可以创建线程。
- en: Regarding the memory layout of threads, every thread has its own Stack memory
    region that can be considered as a private memory region dedicated to that thread.
    In practice, however, it can be accessed by other threads (within the same process)
    when having a pointer addressing it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程的内存布局，每个线程都有自己的栈内存区域，可以视为为该线程专用的私有内存区域。然而，在实践中，当有指针指向它时，其他线程（在同一进程内）也可以访问它。
- en: You should remember that all these Stack regions are part of the same process's
    memory space and can be accessed by any thread within the same process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，所有这些栈区域都是同一进程内存空间的一部分，并且可以被同一进程中的任何线程访问。
- en: Regarding synchronization techniques, the same control mechanisms that are used
    to synchronize processes can be used to synchronize a number of threads. Semaphores,
    mutexes, and condition variables are part of the tools that can be used to synchronize
    threads, as well as processes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于同步技术，用于同步进程的相同控制机制也可以用于同步多个线程。信号量、互斥锁和条件变量是可用于同步线程的工具之一，以及进程。
- en: When its threads are synchronized and no further data race or race condition
    can be observed, a program is usually referred to as a *thread-safe* program.
    Similarly, a library or a set of functions that can be easily used in a multithreaded
    program without introducing any new concurrency issue is called a *thread-safe
    library*. Our goal as programmers is to produce a thread safe piece of code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当其线程同步且没有进一步的数据竞争或竞争条件可以观察到时，程序通常被称为*线程安全*程序。同样，一个库或一组函数，可以轻松地用于多线程程序而不会引入任何新的并发问题，被称为*线程安全库*。作为程序员，我们的目标是生成线程安全的代码。
- en: '**Note**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: In the following link, you can find more information about POSIX threads and
    the properties they share. The following link is about the NTPL implementation
    of the POSIX threading interface. This is dedicated to a Linux environment but
    most of it is applicable to other Unix-like operating systems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中，您可以找到有关POSIX线程及其共享属性的信息。以下链接是关于POSIX线程接口的NTPL实现。这是针对Linux环境的，但其中大部分也适用于其他类Unix操作系统。
- en: http://man7.org/linux/man-pages/man7/pthreads.7.html.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: http://man7.org/linux/man-pages/man7/pthreads.7.html.
- en: In this section we looked at some foundational concepts and properties concerning
    threads in order to better understand the upcoming sections. You will see many
    of these properties in action later as we talk about various multithreaded examples.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了有关线程的一些基础概念和属性，以便更好地理解即将到来的章节。您将在我们讨论各种多线程示例时看到许多这些属性的实际应用。
- en: The next section will introduce you to the first code examples on how to create
    a POSIX thread. The section is going to be simple because it only addresses the
    basics of threading in POSIX. These basics will lead us into more advanced topics
    afterwards.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向您介绍如何创建POSIX线程的第一个代码示例。这一节将会很简单，因为它只涉及POSIX中线程的基本知识。这些基础知识将引导我们进入更高级的主题。
- en: POSIX threads
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX线程
- en: This section is dedicated to the POSIX threading API, better known as the *pthread
    library*. This API is very important because it's the main API used for creating
    and managing the threads in a POSIX-compliant operating system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专门介绍POSIX线程API，也称为*pthread库*。这个API非常重要，因为它是创建和管理POSIX兼容操作系统中的线程的主要API。
- en: 'In non-POSIX-compliant operating systems such as Microsoft Windows, there should
    be another API designed for this purpose and it can be found in the documentation
    of that operating system. For example, in the case of Microsoft Windows, the threading
    API is provided as part of the Windows API, known as the Win32 API. This is the
    link to Microsoft''s documentation regarding [Windows'' threading API: https://docs.microsoft.com/en-us/windows/desktop/procthread/proce](https://docs.microsoft.com/en-us/windows/desktop/procthread/process-and-thread-functions)ss-and-thread-functions.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在非POSIX兼容的操作系统，例如Microsoft Windows中，应该有另一个为这个目的设计的API，并且可以在该操作系统的文档中找到。例如，在Microsoft
    Windows的情况下，线程API作为Windows API的一部分提供，称为Win32 API。这是关于Microsoft的[Windows线程API](https://docs.microsoft.com/en-us/windows/desktop/procthread/proce)的文档链接：[https://docs.microsoft.com/en-us/windows/desktop/procthread/process-and-thread-functions](https://docs.microsoft.com/en-us/windows/desktop/procthread/process-and-thread-functions)。
- en: However, as part of C11, we expect to have a unified API to work with threads.
    In other words, regardless of whether you're writing a program for a POSIX system
    or a non-POSIX system, you should be able to use the same API provided by C11\.
    While this is highly desirable, not much support exists for such universal APIs
    among the various C standard implementations, like glibc, at this point in time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为C11的一部分，我们期望有一个统一的API来处理线程。换句话说，无论你是在为POSIX系统还是非POSIX系统编写程序，你都应该能够使用C11提供的相同API。虽然这是非常理想的，但在当前这个时间点，在各种C标准实现中，如glibc，对这种通用API的支持并不多。
- en: To proceed with the topic, the pthread library is simply a set of *headers*
    and *functions* that can be used to write multithreaded programs in POSIX-compliant
    operating systems. Each operating system has its own implementation for pthread
    library. These implementations could be totally different from what another POSIX-compliant
    operating system have, but at the end of the day, they all expose the same interface
    (API).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续讨论这个主题，pthread库简单地说是一组*头文件*和*函数*，可以用来在POSIX兼容的操作系统上编写多线程程序。每个操作系统都有自己的pthread库实现。这些实现可能与其他POSIX兼容操作系统的实现完全不同，但最终，它们都公开了相同的接口（API）。
- en: One famous example is the **Native POSIX Threading Library**, or **NPTL** for
    short, which is the main implementation of pthread library for the Linux operating
    system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的例子是**原生POSIX线程库**，简称**NPTL**，它是Linux操作系统中pthread库的主要实现。
- en: As described by the pthread API, all threading functionality is available by
    including the header `pthread.h`. There are also some extensions to the pthread
    library that are only available if you include `semaphore.h`. As an example, one
    of the extensions involves operations that are semaphore-specific, for example,
    creating a semaphore, initializing it, destroying it, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如pthread API所述，所有线程功能都通过包含头文件`pthread.h`来提供。还有一些对pthread库的扩展，只有当你包含`semaphore.h`时才可用。例如，其中一个扩展涉及特定于信号量的操作，例如创建信号量、初始化它、销毁它等。
- en: 'The POSIX threading library exposes the following functionalities. They should
    be familiar to you since we have given detailed explanations to them in the previous
    chapters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX线程库公开了以下功能。由于我们在前面的章节中已经对它们进行了详细解释，因此你应该很熟悉：
- en: Thread management, which includes thread creation, joining threads, and detaching
    threads
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程管理，包括线程创建、线程连接和线程分离
- en: Mutexes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁
- en: Semaphores
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号量
- en: Condition variables
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件变量
- en: Various types of locks like spinlocks and recursive locks
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种类型的锁，如自旋锁和递归锁
- en: To explain the preceding functionalities, we must start with the `pthread_`
    prefix. All pthread functions start with this prefix. This is true in all cases
    except for semaphores, which have not been part of the original POSIX threading
    library and have been added later as an extension. In this case, the functions
    will start with the `sem_` prefix.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释前面的功能，我们必须从`pthread_`前缀开始。所有pthread函数都以这个前缀开始。这适用于所有情况，除了信号量，它最初不是POSIX线程库的一部分，后来作为扩展添加。在这种情况下，函数将以`sem_`前缀开始。
- en: In the following sections of this chapter, we will see how to use some of the
    preceding functionalities when writing a multithreaded program. To start with,
    we'll learn how to create a POSIX thread in order to run a code concurrent with
    the main thread. Here, we will learn about the `pthread_create` and `pthread_join`
    functions, which belong to the main API used for *creating* and *joining* threads,
    respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将看到如何在编写多线程程序时使用一些前面的功能。首先，我们将学习如何创建 POSIX 线程以与主线程并发运行。在这里，我们将了解
    `pthread_create` 和 `pthread_join` 函数，它们分别属于用于 *创建* 和 *连接* 线程的主要 API。
- en: Spawning POSIX threads
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 POSIX 线程
- en: Having gone through all the fundamental concepts like interleaving, locks, mutexes,
    and condition variables, in the previous chapters, and introducing the concept
    of POSIX threads in this chapter, it is the time to write some code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经学习了诸如交织、锁、互斥锁和条件变量等基本概念，并在本章介绍了 POSIX 线程的概念，现在是时候编写一些代码了。
- en: 'The first step is to create a POSIX thread. In this section, we are going to
    demonstrate how we can use the POSIX threading API to create new threads within
    a process. Following *example 15.1* describes how to create a thread that performs
    a simple task like printing a string to the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个 POSIX 线程。在本节中，我们将演示如何使用 POSIX 线程 API 在进程内创建新线程。接下来的 *示例 15.1* 描述了如何创建一个执行简单任务（如将字符串打印到输出）的线程：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 15-1 [ExtremeC_examples_chapter15_1.c]: Spawning a new POSIX thread'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 15-1 [ExtremeC_examples_chapter15_1.c]：创建一个新的 POSIX 线程
- en: The example code, seen in *Code Box 15-1*, creates a new POSIX thread. This
    is the first example in this book that has two threads. All previous examples
    were single-threaded, and the code was running within the main thread all the
    time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *代码框 15-1* 中看到的示例代码创建了一个新的 POSIX 线程。这是本书中第一个包含两个线程的示例。所有之前的示例都是单线程的，代码始终在主线程中运行。
- en: 'Let''s explain the code we''ve just looked at. At the top, we have included
    a new header file: `pthread.h`. This is the standard header file that exposes
    all the pthread functionalities. We need this header file so that we can bring
    in the declarations of both `pthread_create` and `pthread_join` functions.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们刚刚看到的代码。在顶部，我们包含了一个新的头文件：`pthread.h`。这是一个标准头文件，它公开了所有 pthread 功能。我们需要这个头文件，以便我们可以引入
    `pthread_create` 和 `pthread_join` 函数的声明。
- en: 'Just before the `main` function, we have declared a new function: `thread_body`.
    This function follows a specific signature. It accepts a `void*` pointer and returns
    another `void*` pointer. As a reminder, `void*` is a generic pointer type that
    can represent any other pointer type, like `int*` or `double*`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数之前，我们声明了一个新的函数：`thread_body`。这个函数遵循一个特定的签名。它接受一个 `void*` 指针并返回另一个
    `void*` 指针。作为一个提醒，`void*` 是一个通用指针类型，可以表示任何其他指针类型，如 `int*` 或 `double*`。
- en: Therefore, this signature is the most general signature that a C function can
    have. This is imposed by the POSIX standard that all functions willing to be the
    *companion function* for a thread (being used as thread logic) should follow this
    generic signature. That's why we have defined the `thread_body` function like
    this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是 C 函数可以拥有的最一般签名。这是由 POSIX 标准强制的，所有希望成为线程（用作线程逻辑）的 *伴随函数* 的函数都应该遵循这个通用签名。这就是为什么我们定义了
    `thread_body` 函数是这样的。
- en: '**Note**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: The `main` function is a part of the main thread's logic. When the main thread
    is created, it executes the `main` function as part of its logic. This means that
    there might be other code that is executed before and after the `main` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数是主线程逻辑的一部分。当主线程被创建时，它作为其逻辑的一部分执行 `main` 函数。这意味着在 `main` 函数之前和之后可能还有其他代码被执行。'
- en: Back to the code, as the first instruction in the `main` function, we have declared
    a variable of type `pthread_t`. This is a thread handle variable, and upon its
    declaration, it doesn't refer to any specific thread. In other words, this variable
    doesn't hold any valid thread ID yet. Only after creating a thread successfully
    does this variable contain a valid handle to the newly created thread.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，作为 `main` 函数中的第一条指令，我们声明了一个类型为 `pthread_t` 的变量。这是一个线程句柄变量，在其声明时，它不指向任何特定的线程。换句话说，这个变量还没有包含任何有效的线程
    ID。只有成功创建了一个线程之后，这个变量才包含对新创建线程的有效句柄。
- en: After creating the thread, the thread handle actually refers to the thread ID
    of the recently created thread. While thread ID is the thread identifier in the
    operating system, the thread handle is the representative of the thread in the
    program. Most of the time, the value stored in the thread handle is the same as
    thread ID. Every thread is able to access its thread ID through obtaining a `pthread_t`
    variable that refers to itself. A thread can use the `pthread_self` function to
    obtain a self-referring handle. We are going to demonstrate the usage of these
    functions in future examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程后，线程句柄实际上指的是新创建线程的线程 ID。虽然线程 ID 是操作系统中的线程标识符，但线程句柄是程序中线程的表示。大多数情况下，存储在线程句柄中的值与线程
    ID 相同。每个线程都能通过获取一个指向自身的 `pthread_t` 变量来访问其线程 ID。一个线程可以使用 `pthread_self` 函数来获取一个自引用的句柄。我们将在未来的示例中演示这些函数的用法。
- en: Thread creation happens when the `pthread_create` function is called. As you
    can see, we have passed the address of the `thread` handle variable to the `pthread_create`
    function in order to have it filled with a proper handle (or thread ID), referring
    to the newly created thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 线程创建发生在调用 `pthread_create` 函数时。如您所见，我们已经将 `thread` 句柄变量的地址传递给 `pthread_create`
    函数，以便将其填充为适当的句柄（或线程 ID），指向新创建的线程。
- en: The second argument determines the thread's attributes. Every thread has some
    attributes like *stack size*, *stack address*, and *detach* state that can be
    configured before spawning the thread.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数确定线程的属性。每个线程都有一些属性，如 *堆栈大小*、*堆栈地址* 和 *分离状态*，可以在创建线程之前进行配置。
- en: We show more examples of how to configure these attributes and how they affect
    the way the threads behave. If a `NULL` is passed as the second argument, it means
    that the new thread should use the default values for its attributes. Therefore,
    in the preceding code, we have created a thread that has attributes with default
    values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示更多如何配置这些属性以及它们如何影响线程行为的示例。如果第二个参数传递了 `NULL`，这意味着新线程应该使用其属性的默认值。因此，在先前的代码中，我们创建了一个具有默认属性值的线程。
- en: The third argument passed to `pthread_create` is a function pointer. This is
    pointing to the thread's *companion function*, which contains the thread's logic.
    In the preceding code, the thread's logic is defined in the `thread_body` function.
    Therefore, its address should be passed in order to get bound to the handle variable
    `thread`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `pthread_create` 的第三个参数是一个函数指针。这个指针指向线程的 *伴随函数*，其中包含了线程的逻辑。在先前的代码中，线程的逻辑是在
    `thread_body` 函数中定义的。因此，应该传递其地址以便将其绑定到句柄变量 `thread` 上。
- en: The fourth and last argument is the input argument for the thread's logic, which
    in our case is `NULL`. This means that we don't want to pass anything to the function.
    Therefore, the parameter `arg` in the `thread_body` function would be `NULL` upon
    the thread's execution. In the examples provided in the next section, we'll look
    at how we can pass a value to this function instead of a `NULL`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个也是最后一个参数是线程逻辑的输入参数，在我们的例子中是 `NULL`。这意味着我们不希望向函数传递任何内容。因此，`thread_body` 函数中的参数
    `arg` 在线程执行时将是 `NULL`。在下一节提供的示例中，我们将看看如何向这个函数传递一个值而不是 `NULL`。
- en: All pthread functions, including `pthread_create`, are supposed to return zero
    upon successful execution. Therefore, if any number other than zero is returned,
    then it means that the function has failed, and an *error number* has been returned.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 pthread 函数，包括 `pthread_create`，在成功执行后都应返回零。因此，如果返回了除零以外的任何数字，则意味着函数已失败，并返回了一个
    *错误号*。
- en: Note that creating a thread using `pthread_create` doesn't mean that the thread's
    logic is being executed immediately. It is a matter of scheduling and cannot be
    predicted when the new thread gains one of the CPU cores and starts its execution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 `pthread_create` 创建线程并不意味着线程的逻辑会立即执行。这是一个调度问题，无法预测新线程何时获得一个 CPU 核心并开始执行。
- en: After creating the thread, we join the newly created thread, but what exactly
    does that mean? As we explained before, each process starts with exactly one thread,
    which is the *main thread*. Except for the main thread, whose parent is the owning
    process, all other threads have a *parent thread*. In a default scenario, if the
    main thread is finished, the process will also be finished. When the process gets
    terminated, all other running or sleeping threads will also get terminated immediately.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建线程后，我们加入新创建的线程，但这究竟意味着什么呢？正如我们之前解释的，每个进程都以一个线程开始，这个线程是*主线程*。除了主线程，其父进程是拥有进程外，所有其他线程都有一个*父线程*。在默认情况下，如果主线程完成，进程也将完成。当进程被终止时，所有其他正在运行或休眠的线程也将立即被终止。
- en: So, if a new thread is created and it hasn't started yet (because it hasn't
    gained the use of the CPU) and in the meantime, the parent process is terminated
    (for whatever reason), the thread will die before even executing its first instruction.
    Therefore, the main thread needs to wait for the second thread to become executed
    and finished by joining it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果创建了一个新线程，它还没有开始运行（因为它还没有获得CPU的使用权），同时，父进程被终止（无论什么原因），线程将在执行第一条指令之前就死亡。因此，主线程需要等待第二个线程通过加入它来执行并完成。
- en: A thread becomes finished only when its companion function returns. In the preceding
    example, the spawned thread becomes finished when the `thread_body` companion
    function returns, and this happens when the function returns `NULL`. When the
    newly spawned thread is finished, the main thread, which was blocked behind calling
    `pthread_join`, is released and can continue, which eventually leads to successful
    termination of the program.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 线程只有在它的伴随函数返回时才完成。在前面的例子中，派生的线程在`thread_body`伴随函数返回时完成，这发生在函数返回`NULL`时。当新派生的线程完成时，被`pthread_join`调用阻塞的主线程被释放并可以继续，这最终导致程序成功终止。
- en: If the main thread didn't join the newly created thread, then it is unlikely
    that the newly spawned thread can be executed at all. As we've explained before,
    this happens due to the fact that the main thread exits even before the spawned
    thread has entered into its execution phase.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主线程没有加入新创建的线程，那么新派生的线程根本不可能被执行。正如我们之前解释的，这是因为主线程在派生线程进入执行阶段之前就已经退出。
- en: We should also remember that creating a thread is not enough to have it executed.
    It may take a while for the created thread to gain access to a CPU core, and through
    this eventually start running. If, in the meantime, the process gets terminated,
    then the newly created thread has no chance of running successfully.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也应该记住，创建一个线程并不足以使其被执行。创建的线程可能需要一段时间才能获得访问CPU核心的权限，并通过这种方式最终开始运行。如果在此时，进程被终止，那么新创建的线程将没有机会成功运行。
- en: 'Now that we''ve talked through the design of the code, *Shell Box 15-1* shows
    the output of running *example 15.1*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了代码的设计，*Shell Box 15-1*显示了运行*example 15.1*的输出：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 15-1: Building and running example 15.1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 15-1：构建和运行示例15.1
- en: As you see in the preceding shell box, we need to add the `-lpthread` option
    to the compilation command. This is done because we need to link our program with
    the existing implementation of the pthread library. In some platforms, like macOS,
    your program might get linked without the `-lpthread` option as well; however,
    it is strongly recommended to use this option while you are linking programs that
    use pthread library. The importance of this advice is to make your *build scripts*
    working on any platform and prevent any cross-compatibility issues while building
    your C projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的shell框中看到的，我们需要在编译命令中添加`-lpthread`选项。这样做是因为我们需要将我们的程序与现有的pthread库实现链接。在某些平台，如macOS，即使没有`-lpthread`选项，你的程序也可能被链接；然而，强烈建议在链接使用pthread库的程序时使用此选项。这条建议的重要性在于确保你的*构建脚本*在任何平台上都能工作，并在构建C项目时防止任何跨兼容性问题。
- en: A thread that can be joined is known as *joinable*. The threads are joinable
    by default. Opposite to joinable threads, we have *detached* threads. Detached
    threads cannot be joined.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被加入的线程被称为*可加入的*。线程默认是可加入的。与可加入线程相反，我们有*分离的*线程。分离的线程不能被加入。
- en: In *example 15.1*, the main thread could detach the newly spawned thread instead
    of joining it. This way, we would have let the process know that it must wait
    for the detached thread to become finished before it can get terminated. Note
    that in this case, the main thread can exit without the parent process being terminated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 15.1* 中，主线程可以分离新产生的线程而不是连接它。这样，我们就让进程知道，它必须等待分离线程完成才能终止。请注意，在这种情况下，主线程可以退出，而父进程不会被终止。
- en: 'In the final code of this section, we want to rewrite the preceding example
    using detached threads. Instead of joining the newly created thread, the main
    thread makes it detached and then exits. This way, the process remains running
    until the second thread finishes, despite the fact that the main thread has already
    exited:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后代码中，我们想要使用分离线程重写前面的示例。而不是连接新创建的线程，主线程将其设置为分离，然后退出。这样，尽管主线程已经退出，但进程仍然会继续运行，直到第二个线程完成：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 15-2 [ExtremeC_examples_chapter15_1_2.c]: Example 15.1 spawning a
    detached thread'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 15-2 [ExtremeC_examples_chapter15_1_2.c]: 示例 15.1 生成分离线程'
- en: The output of the preceding code is exactly the same as the previous code written
    using joinable threads. The only difference is the that way we managed the newly
    created thread.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出与之前使用可连接线程编写的代码完全相同。唯一的区别是我们管理新创建线程的方式。
- en: Right after the creation of the new thread, the main thread has detached it.
    Then following that, the main thread exits. The instruction `pthread_exit(NULL)`
    was necessary in order to let the process know that it should wait for other detached
    threads to be finished. If the threads were not detached, the process would get
    terminated upon the exit of the main thread.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在新线程创建后，主线程立即将其分离。然后，主线程退出。指令 `pthread_exit(NULL)` 是必要的，以便让进程知道它应该等待其他分离线程完成。如果线程没有被分离，进程会在主线程退出时终止。
- en: '**Note**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The *detach state* is one of the thread attributes that can be set before creating
    a new thread in order to have it detached. This is another method to create a
    new detached thread instead of calling `pthread_detach` on a joinable thread.
    The difference is that this way, the newly created thread is detached from the
    start.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*分离状态* 是在创建新线程之前可以设置的一个线程属性，以便使其分离。这是创建新分离线程的另一种方法，而不是在可连接线程上调用 `pthread_detach`。区别在于，这种方式下，新创建的线程从一开始就是分离的。'
- en: In the next section, we're going to introduce our first example demonstrating
    a race condition. We will be using all the functions introduced in this section
    in order to write future examples. Therefore, you'll have a second chance to revisit
    them again in different scenarios.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍我们的第一个示例，演示竞态条件。我们将使用本节中介绍的所有函数来编写未来的示例。因此，你将有机会在不同的场景中再次回顾它们。
- en: Example of race condition
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞态条件示例
- en: For our second example, we're going to look at a more problematic scenario.
    *Example 15.2*, shown in *Code Box 15-3*, shows just how interleavings happen
    and how we cannot reliably predict the final output of the example in practice,
    mainly because of the non-deterministic nature of concurrent systems. The example
    involves a program that creates three threads at almost the same time, and each
    of them prints a different string.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个示例，我们将探讨一个更具挑战性的场景。*示例 15.2*，如 *代码框 15-3* 所示，展示了交织是如何发生的，以及我们在实践中无法可靠地预测示例的最终输出，这主要是因为并发系统的非确定性本质。该示例涉及一个程序，几乎同时创建了三个线程，并且每个线程都打印不同的字符串。
- en: 'The final output of the following code contains the strings printed by three
    different threads but in an unpredictable order. If the invariant constraint (introduced
    in the previous chapter) for the following example was to see the strings in a
    specific order in the output, the following code would have failed at satisfying
    that constraint, mainly because of the unpredictable interleavings. Let''s look
    at the following code box:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的最终输出包含三个不同线程打印的字符串，但顺序不可预测。如果以下示例的不可变约束（在前一章中介绍）是要在输出中看到特定的字符串顺序，那么以下代码将无法满足该约束，主要是因为不可预测的交织。让我们看看以下代码框：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 15-3 [ExtremeC_examples_chapter15_2.c]: Example 15.2 printing three
    different strings to the output'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 15-3 [ExtremeC_examples_chapter15_2.c]: 示例 15.2 向输出打印三个不同的字符串'
- en: The code we've just looked at is very similar to the code written for *example
    15.1*, but it creates three threads instead of the one. In this example, we use
    the same companion function for all three threads.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码与为 *example 15.1* 编写的代码非常相似，但它创建了三个线程而不是一个。在这个例子中，我们为所有三个线程使用相同的伴随函数。
- en: As you can see in the preceding code, we have passed a fourth argument to the
    `pthread_create` function, whereas in our previous example, *15.1*, it was `NULL`.
    These arguments will be accessible by the thread through the generic pointer parameter
    `arg` in the `thread_body` companion function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们向 `pthread_create` 函数传递了第四个参数，而在我们之前的例子 *15.1* 中，它是 `NULL`。这些参数将通过
    `thread_body` 伴随函数中的通用指针参数 `arg` 被线程访问。
- en: Inside the `thread_body` function, the thread casts the generic pointer `arg`
    to a `char*` pointer and prints the string starting at that address using the
    `printf` function. This is how we are able to pass arguments to the threads. Likewise,
    it doesn't matter how big they are since we are only passing a pointer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `thread_body` 函数内部，线程将通用指针 `arg` 强制转换为 `char*` 指针，并使用 `printf` 函数从该地址开始打印字符串。这就是我们能够向线程传递参数的方式。同样，它们的大小并不重要，因为我们只传递一个指针。
- en: If you have multiple values that need to be sent to a thread upon their creation,
    you could use a structure to contain those values and pass a pointer to a structure
    variable filled by the desired values. We will demonstrate to how to do this in
    the next chapter, *Thread Synchronization*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在创建线程时向其发送多个值，你可以使用一个结构来包含这些值，并传递一个指向填充了所需值的结构变量的指针。我们将在下一章的 *线程同步* 中演示如何做到这一点。
- en: '**Note**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The fact that we can pass a pointer to a thread implies that the new threads
    should have access to the same memory region that the main thread has access to.
    However, access is not limited to a specific segment or region in the owning process's
    memory and all threads have full access to the Stack, Heap, Text, and Data segments
    in a process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将指针传递给线程的事实意味着新线程应该能够访问主线程可以访问的相同内存区域。然而，访问并不限于拥有进程内存中的特定段或区域，并且所有线程都可以完全访问进程中的栈、堆、文本和数据段。
- en: If you take *example 15.2* and run it several times, you'll see that the order
    of the printed strings can vary, as each run is expected to print the same strings
    but in a different order.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行 *example 15.2*，你会看到打印的字符串顺序可以变化，因为每次运行都预计会打印相同的字符串，但顺序不同。
- en: '*Shell Box 15-2* shows the compilation and the output of *example 15.2* after
    three consecutive runs:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell Box 15-2* 展示了在连续三次运行后 *example 15.2* 的编译和输出：'
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 15-2: Running example 15.2 three times to observe the existing race
    condition and various interleavings'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 15-2：运行示例 15.2 三次以观察现有的竞态条件和各种交织情况
- en: It is easy to produce the interleavings in which the first and second threads
    print their strings before the third thread, but it would be difficult to produce
    an interleaving in which the third thread prints its string, `Lemon`, as the first
    or second string in the output. However, this will certainly happen, albeit with
    a low probability. You might need to run the example many more times in order
    to produce that interleaving. This may require some patience.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 产生第一个和第二个线程在第三个线程之前打印它们的字符串的交织情况很容易，但要产生第三个线程打印其字符串 `Lemon` 作为输出中的第一个或第二个字符串的交织情况就困难得多。然而，这肯定会发生，尽管概率很低。你可能需要多次运行示例才能产生那种交织。这可能需要一些耐心。
- en: The preceding code is also said to not be thread safe. This is an important
    definition; a multithreaded program is thread safe if, and only if, it has no
    race condition according to the defined invariant constraints. Therefore, since
    the preceding code has a race condition, it is not thread safe. Our job would
    be to make the preceding code thread safe through the use of proper control mechanisms
    that will be introduced in the next chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码也被认为不是线程安全的。这是一个重要的定义；一个多线程程序只有在没有根据定义的不变约束条件出现竞态条件的情况下才是线程安全的。因此，由于上述代码存在竞态条件，它不是线程安全的。我们的任务就是通过使用将在下一章中介绍的正确控制机制来使上述代码成为线程安全的。
- en: 'As you see in the output of the preceding example, we don''t have any interleaving
    between the characters of `Apple` or `Orange`. For example, we don''t see the
    following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例的输出所示，我们并没有在 `Apple` 或 `Orange` 的字符之间看到任何交织。例如，我们没有看到以下输出：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 15-3: An imaginary output that does not happen for the above example'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 15-3号Shell盒：对于上述示例不会发生的想象中的输出
- en: This shows a fact that the `printf` function is *thread safe* and it simply
    means that it doesn't matter how interleavings happen, when one of the threads
    is in the middle of printing a string, `printf` instances in other threads don't
    print anything.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`printf`函数是*线程安全的*，这仅仅意味着无论交织如何发生，当一个线程正在打印字符串时，其他线程中的`printf`实例不会打印任何内容。
- en: In addition, in the preceding code, the `thread_body` companion function was
    run three times in the context of three different threads. In the previous chapters
    and before giving multithreaded examples, all functions were being executed in
    the context of the main thread. From now on, every function call occurs in the
    context of a specific thread (not necessarily the main thread).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在前面给出的代码中，`thread_body`伴随函数在三个不同的线程的上下文中运行了三次。在之前的章节中，以及在给出多线程示例之前，所有函数都是在主线程的上下文中执行的。从现在起，每个函数调用都发生在特定线程的上下文中（不一定是主线程）。
- en: It's not possible for two threads to initiate a single function call. The reason
    is obvious because each function call needs to create a *stack frame* that should
    be put on top of the Stack of just one thread, and two different threads have
    two different Stack regions. Therefore, a function call can only be initiated
    by just one thread. In other words, two threads can call the same function separately
    and it results into two separate function calls, but they cannot share the same
    function call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程无法启动单个函数调用。原因很明显，因为每个函数调用都需要创建一个*栈帧*，这个栈帧应该放在只有一个线程的栈顶上，而两个不同的线程有两个不同的栈区域。因此，函数调用只能由一个线程启动。换句话说，两个线程可以分别调用同一个函数，这会导致两个单独的函数调用，但它们不能共享同一个函数调用。
- en: We should note that the pointer passed to a thread should not be a *dangling
    pointer*. It causes some serious memory issues that are hard to track. As a reminder,
    a dangling pointer points to an address in the memory where there is no allocated
    variable. More specifically, this is the case that at some moment in time; there
    might have been a variable or an array there originally, but as of the time when
    the pointer is about to be used, it's already been freed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，传递给线程的指针不应该是一个*悬空指针*。这会导致一些严重的内存问题，难以追踪。作为提醒，悬空指针指向内存中的一个地址，该地址没有分配的变量。更具体地说，这种情况是，在某个时刻，那里可能原本有一个变量或数组，但到了指针即将被使用的时候，它已经被释放了。
- en: In the preceding code, we passed three literals to each thread. Since the memory
    required for these string literals are allocated from the Data segment and not
    from Heap or Stack segments, their addresses never become freed and the `arg`
    pointers won't become dangling.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向每个线程传递了三个字面量。由于这些字符串字面量所需的内存是从数据段分配的，而不是从堆或栈段分配的，因此它们的地址永远不会被释放，`arg`指针也不会变成悬空。
- en: 'It would be easy to write the preceding code in a way in which the pointers
    become dangling. The following is the same code but with dangling pointers, and you
    will see shortly that it leads to bad memory behaviors:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将前面的代码写成指针悬空的形式。下面是同样的代码，但使用了悬空指针，你很快就会看到这会导致不良的内存行为：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 15-4 [ExtremeC_examples_chapter15_2_1.c]: Example 15.2 with literals
    allocated from the main thread''s Stack region'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码盒15-4 [ExtremeC_examples_chapter15_2_1.c]：从主线程的栈区域分配字面量的15.2示例
- en: The preceding code is almost the same as the code given in *example 15.2*, but
    with two differences.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码几乎与*示例15.2*中给出的代码相同，但有两点不同。
- en: Firstly, the pointers passed to the threads are not pointing to the string literals
    residing in Data segment, instead they point to character arrays allocated from
    the main thread's Stack region. As part of the `main` function, these arrays have
    been declared and in the following lines, they have been populated by some string
    literals.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，传递给线程的指针并不是指向数据段中驻留的字符串字面量，而是指向从主线程的栈区域分配的字符数组。作为`main`函数的一部分，这些数组已经被声明，在接下来的几行中，它们被一些字符串字面量填充。
- en: We need to remember that the string literals still reside in the Data segment,
    but the declared arrays now have the same values as the string literals after
    being populated using the `strcpy` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，字符串字面量仍然驻留在数据段中，但声明后的数组在用`strcpy`函数填充后现在具有与字符串字面量相同的值。
- en: The second difference is regarding how the main thread behaves. In the previous
    code it joined the threads, but in this code, it detaches the threads and exits
    immediately. This will deallocate the arrays declared on top of the main thread's
    Stack, and in some interleavings other threads may try to read those freed regions.
    Therefore, in some interleavings, the pointers passed to the threads can become
    dangling.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是关于主线程的行为。在之前的代码中，它加入了线程，但在这段代码中，它解除了线程并立即退出。这将释放主线程栈上声明的数组，在某些交错中，其他线程可能会尝试读取这些已释放的区域。因此，在某些交错中，传递给线程的指针可能会变成悬空。
- en: '**Note**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Some constraints, like having no crashes, having no dangling pointers, and generally
    having no memory-related issues, can always be thought of as being part of the
    invariant constraints for a program. Therefore, a concurrent system that yields
    a dangling pointer issue in some interleavings is definitely suffering from a
    serious race condition.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一些约束，如没有崩溃、没有悬空指针以及通常没有内存相关的问题，都可以被视为程序的不变约束的一部分。因此，在某些交错中产生悬空指针问题的并发系统肯定存在严重的竞态条件。
- en: To be able to detect the dangling pointers, you need to use a *memory profiler*.
    As a simpler approach, you could run the program several times and wait for a
    crash to happen. However, you are not always fortunate enough to be able to see
    that and we are not lucky to see crashes in this example either.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够检测悬空指针，你需要使用一个*内存分析器*。作为一个更简单的方法，你可以运行程序多次，等待崩溃发生。然而，你并不总是有幸看到这一点，在这个例子中，我们也没有看到崩溃。
- en: To detect bad memory behavior in this example, we are going to use `valgrind`.
    You remember that we introduced this memory profiler in *Chapter 4*, *Process
    Memory Structure*, and *Chapter 5*, *Stack and Heap*, for finding the *memory
    leaks*. Back in this example, we want to use it to find the places where bad memory
    access has happened.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测这个例子中的不良内存行为，我们将使用`valgrind`。你还记得我们在*第4章*、*进程内存结构*和*第5章*、*栈和堆*中介绍了这个内存分析器，用于查找*内存泄漏*。回到这个例子，我们想用它来找到发生不良内存访问的地方。
- en: It's worth remembering that using a dangling pointer, and accessing its content,
    will not necessarily lead to a crash. This is especially true in the preceding
    code, in which the strings are placed on top of the main thread's Stack.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，使用悬空指针并访问其内容，并不一定会导致崩溃。这在之前的代码中尤其如此，其中的字符串被放置在主线程的栈上。
- en: While the other threads are running, the Stack segment remains the same as it
    was when the main thread exited, therefore you can access the strings even though
    the `str1`, `str2`, and `str3` arrays are deallocated while leaving the `main`
    function. In other words, in C or C++, the runtime environment does not check
    if a pointer is dangling or not, it just follows the sequence of statements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他线程运行时，栈段保持与主线程退出时相同，因此即使`str1`、`str2`和`str3`数组在离开`main`函数时被释放，你仍然可以访问这些字符串。换句话说，在C或C++中，运行时环境不会检查指针是否悬空，它只是遵循语句的顺序。
- en: If a pointer is dangling and its underlying memory is changed, then bad things
    like crash or logical errors can happen but as long as the underlying memory is
    *untouched* then using the dangling pointers may not lead to a crash, and this
    is very dangerous and hard to track.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个悬空指针及其底层内存被更改，那么可能会发生像崩溃或逻辑错误这样的坏事，但只要底层内存是*未触及的*，使用悬空指针可能不会导致崩溃，这是非常危险且难以追踪的。
- en: In short, just because you can access a memory region through a dangling pointer,
    that doesn't mean that you are allowed to access that region. This is the reason
    why we need to use a memory profiler like `valgrind` that will report on these
    invalid memory accesses.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，仅仅因为你可以通过悬空指针访问一个内存区域，并不意味着你被允许访问该区域。这就是为什么我们需要使用像`valgrind`这样的内存分析器，它会报告这些无效的内存访问。
- en: In the following shell box, we compile the program and we run it with `valgrind`
    twice. In the first run, nothing bad happens but in the second run, `valgrind`
    reports a bad memory access.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的shell框中，我们编译程序，并使用`valgrind`运行两次。在第一次运行中，没有发生任何坏事，但在第二次运行中，`valgrind`报告了内存访问错误。
- en: '*Shell Box 15-4* shows the first run:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell Box 15-4*显示了第一次运行：'
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 15-4: Running example 15.2 with valgrind for the first time'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 15-4：第一次使用valgrind运行示例15.2
- en: 'In the second run, `valgrind` reports some memory access issues (note that
    the full output will be viewable when you run it, but for purpose of length, we''ve
    refined it.):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次运行中，`valgrind` 报告了一些内存访问问题（注意，当你运行它时，完整的输出将可查看，但为了篇幅考虑，我们已进行了精简）：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 15-5: Running example 15.2 with valgrind for the second time'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 15-5：第二次运行示例 15.2 并使用 valgrind
- en: As you can see, the first run went well, with no memory access issues, even
    though the aforementioned race condition is still clear to us. In the second run,
    however, something goes wrong when one of the threads tries to access the string
    `Orange` pointed to by `str2`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一次运行顺利，没有内存访问问题，尽管上述竞争条件对我们来说仍然很明显。然而，在第二次运行中，当其中一个线程试图访问由 `str2` 指向的字符串
    `Orange` 时，出现了问题。
- en: What this means is that the passed pointer to the second thread has become dangling.
    In the preceding output, you can clearly see that the stack trace points to line
    inside the `thread_body` function where there is the `printf` statement. Note
    that the stack trace actually refers to the `puts` function because our C compiler
    has replaced the `printf` statement with the equivalent `puts` statement. The
    preceding output also shows that the `write` system call is using a pointer named
    `buf` that points to a memory region that *is not initialized or allocated*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着传递给第二个线程的指针已经悬空。在前面的输出中，你可以清楚地看到堆栈跟踪指向 `thread_body` 函数内部的行，那里有 `printf`
    语句。请注意，堆栈跟踪实际上指的是 `puts` 函数，因为我们的 C 编译器已将 `printf` 语句替换为等效的 `puts` 语句。前面的输出还显示，`write`
    系统调用正在使用一个名为 `buf` 的指针，该指针指向一个未初始化或分配的内存区域。
- en: Looking at the preceding example, `valgrind` doesn't conclude whether a pointer
    is dangling or not. It simply reports the invalid memory access.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的例子，`valgrind` 并不结论指针是否悬空。它只是报告无效的内存访问。
- en: Before the error messages regarding the bad memory access, you can see that
    the string `Orange` is printed even though the access for reading it is invalid.
    This just goes to show how easily things can get complicated when we have code
    running in a concurrent fashion.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于不良内存访问的错误信息之前，你可以看到即使读取 `Orange` 的访问是无效的，字符串 `Orange` 仍然被打印出来。这仅仅表明，当我们的代码以并发方式运行时，事情可以多么容易变得复杂。
- en: In this section, we've taken a significant step forward in seeing how easy it
    is to write code that is not thread safe. Moving on, we're now going to demonstrate
    another interesting example that produces a data race. Here, we will see a more
    complex use of the pthread library and its various functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向前迈出了重要的一步，了解了编写不安全的代码是多么容易。接下来，我们将演示另一个有趣的例子，该例子会产生数据竞争。在这里，我们将看到对 pthread
    库及其各种函数的更复杂使用。
- en: Example of data race
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据竞争示例
- en: E*xample 15.3* demonstrates a data race. In previous examples, we didn't have
    a shared state, but in this example, we are going to have a variable shared between
    two threads.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15.3* 展示了数据竞争。在先前的例子中，我们没有共享状态，但在这个例子中，我们将有两个线程之间共享的变量。'
- en: 'The invariant constraint of this example is to protect the *data integrity*
    of the shared state, plus all other obvious constraints, like having no crashes,
    having no bad memory accesses, and so on. In other words, it doesn''t matter how
    the output appears, but a thread must not write new values while the value of
    the shared variable has been changed by the other thread and the writer thread
    doesn''t know the latest value. This is what we mean by "data integrity":'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的不变约束是保护共享状态的数据完整性，以及所有其他明显的约束，如没有崩溃、没有不良内存访问等。换句话说，输出看起来如何无关紧要，但线程在共享变量的值被其他线程更改且写入线程不知道最新值时，不得写入新值。这就是我们所说的“数据完整性”：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 15-5 [ExtremeC_examples_chapter15_3.c]: Example 15.3 with two threads
    operating on a single shared variable'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 15-5 [ExtremeC_examples_chapter15_3.c]：示例 15.3，两个线程操作单个共享变量
- en: The shared state has been declared as the first line in the `main` function.
    In this example, we are dealing with a single integer variable allocated form
    the Stack region of the main thread, but in real applications it can be far more
    complex. The initial value of the integer variable is zero, and each thread contributes
    directly to an increase in its value by writing to its memory location.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 共享状态已在 `main` 函数的第一行声明。在这个例子中，我们处理的是主线程堆栈区域分配的单个整型变量，但在实际应用中可能要复杂得多。整型变量的初始值为零，每个线程通过写入其内存位置直接增加其值。
- en: In this example, there is no local variable that is keeping a copy of the shared
    variable's value in each thread. However, you should be careful about the increment
    operations in threads because they are not *atomic* operations, and therefore
    are subject to experiencing different interleavings. We have explained this thoroughly
    in the previous chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，没有局部变量在每个线程中保留共享变量值的副本。然而，您应该小心线程中的增量操作，因为它们不是*原子*操作，因此可能会经历不同的交错。我们已在上一章中详细解释了这一点。
- en: Each thread is able to change the value of the shared variable by using the
    pointer that it receives inside its companion function through the argument `arg`.
    As you can see in both calls to `pthread_create`, we are passing the address of
    the variable `shared_var` as the fourth argument.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都可以通过在其伴随函数中通过参数`arg`接收到的指针来更改共享变量的值。正如您在两次调用`pthread_create`中可以看到的，我们将变量`shared_var`的地址作为第四个参数传递。
- en: It's worth noting that the pointer never becomes dangling in threads because
    the main thread doesn't exit, and it waits for the threads to finish by joining
    them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，指针在线程中永远不会成为悬垂指针，因为主线程不会退出，它通过连接线程来等待线程完成。
- en: '*Shell Box 15-6* shows us the outputs of multiple runs of the preceding code
    in order to produce different interleavings. Remember that we want data integrity
    to be preserved for the shared variable `shared_var`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell Box 15-6*展示了前面代码多次运行的输出，以产生不同的交错。请记住，我们希望共享变量`shared_var`的数据完整性得到保留。'
- en: 'So, based on the logic defined in `thread_body_1` and `thread_body_2`, we can
    only have `1 3` and `2 3` as the acceptable outputs:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据`thread_body_1`和`thread_body_2`中定义的逻辑，我们只能有`1 3`和`2 3`作为可接受的输出：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 15-6: Multiple runs of example 15.3, in which we eventually see that
    the data integrity of the shared variable is not preserved'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 15-6：示例15.3的多次运行，最终我们看到共享变量的数据完整性没有得到保留
- en: As you can see, the last run reveals that the data integrity condition has not
    been met for the shared variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最后一次运行表明共享变量的数据完整性条件没有得到满足。
- en: In the last run, the first thread, the thread that has `thread_body_1` as its
    companion function, has read the value of the shared variable and it is `0`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次运行中，第一个线程，即具有`thread_body_1`作为其伴随函数的线程，读取了共享变量的值，它是`0`。
- en: The second thread, the thread that has `thread_body_2` as its companion function,
    has also read the shared value and it is `0`. After this point, both threads try
    to increment the value of the shared variable and print it immediately. This is
    a breach of data integrity because when one thread is manipulating a shared state,
    the other thread shouldn't be able to write to it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个线程，即具有`thread_body_2`作为其伴随函数的线程，也读取了共享值，它是`0`。在此之后，两个线程都试图增加共享变量的值并立即打印它。这是对数据完整性的违反，因为当一个线程正在操作共享状态时，另一个线程不应该能够写入它。
- en: As we explained before, we have a clear data race over `shared_var` in this
    example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所解释的，在这个例子中，我们对`shared_var`有明确的数据竞争。
- en: '**Note**:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: When executing *example 15.3* yourself, be patient and wait to see the `1 2`
    output. It might happen after running the executable 100 times! I could have observed
    the data race on both macOS and Linux.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当您自己执行*示例15.3*时，请耐心等待，以查看`1 2`输出。这可能在运行可执行文件100次之后发生！我曾在macOS和Linux上观察到数据竞争。
- en: In order to resolve the preceding data race, we need to use a control mechanism,
    such as a semaphore or a mutex, to synchronize the access to the shared variable.
    In the next chapter, we will introduce a mutex to the preceding code that will
    do that for us.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决前面的数据竞争，我们需要使用控制机制，例如信号量或互斥锁，来同步对共享变量的访问。在下一章中，我们将向前面的代码引入互斥锁，这将为我们完成这项工作。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was our first step towards writing multithreaded programs in C
    using the POSIX threading library. As part of this chapter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们使用POSIX线程库在C中编写多线程程序的第一步。作为本章的一部分：
- en: We went through the basics of the POSIX threading library, which is the main
    tool for writing multithreaded applications in POSIX-compliant systems.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了POSIX线程库的基础知识，这是在POSIX兼容系统中编写多线程应用程序的主要工具。
- en: We explored the various properties of threads and their memory structure.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了线程及其内存结构的各种属性。
- en: We gave some insight about the available mechanisms for threads to communicate
    and share a state.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对线程可用的通信和共享状态的机制提供了一些见解。
- en: We explained that how the memory regions available to all threads within the
    same process are the best way to share data and communicate.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了对于同一进程内所有线程可用的内存区域是共享数据和通信的最佳方式。
- en: We talked about the kernel threads and the user-level threads and how they differ.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了内核线程和用户级线程，以及它们之间的差异。
- en: We explained the joinable and detached threads and how they differ from the
    execution point of view.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了可连接线程和分离线程，以及它们在执行点上的区别。
- en: We demonstrated how to use the `pthread_create` and `pthread_join` functions
    and what arguments they receive.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们演示了如何使用`pthread_create`和`pthread_join`函数以及它们接收的参数。
- en: Examples of a race condition and a data race were demonstrated using actual
    C code, and you saw how using dangling pointer can cause serious memory issues
    and eventually a crash or a logical error might occur.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实际的C代码演示了竞态条件和数据竞争的例子，并展示了如何使用悬垂指针可能导致严重的内存问题，最终可能发生崩溃或逻辑错误。
- en: In the following chapter, we will continue and develop our discussion into multithreading
    by looking at the concurrency-related issues and the available mechanisms to both
    prevent and resolve them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过探讨并发相关问题和可用的机制来防止和解决这些问题，继续并发展我们对多线程的讨论。
