<html><head></head><body>
		<div id="_idContainer045" class="Content">
			<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/><em class="italic">Chapter 3</em>: C++ Strings and SFML Time – Player Input and HUD</h1>
			<p>In this chapter, we will continue with the Timber!! game. We will spend around half of this chapter learning how to manipulate text and display it on the screen, and the other half looking at timing and how a visual time-bar can inform the player about the remaining time and create a sense of urgency in the game.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>Pausing and restarting the game</li>
				<li>C++ Strings</li>
				<li>SFML text and SFML font classes</li>
				<li>Adding a HUD to Timber!!!</li>
				<li>Adding a time-bar to Timber!!!</li>
			</ul>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>Pausing and restarting the game</h1>
			<p>As we work on this game over the next three chapters, the code will obviously get longer and longer. So, now seems like a good time to think ahead and add a little bit more structure to our code. We will add this structure so that we can pause and restart the game.</p>
			<p>We will add code so that, when the game is run for the first time, it will be in a paused state. The player will then be able to press the <em class="italic">Enter</em> key to start the game. Then, the game will run until either the player gets squished or runs out of time. At this point, the game will pause and wait for the player to press <em class="italic">Enter</em> so that they can restart the game.</p>
			<p>Let's step through setting this up a bit at a time.</p>
			<p>First, declare a new <strong class="source-inline">bool</strong> variable called <strong class="source-inline">paused</strong> outside the main game loop and initialize it to <strong class="source-inline">true</strong>:</p>
			<p class="source-code">// Variables to control time itself</p>
			<p class="source-code">Clock clock;</p>
			<p class="source-code"><strong class="bold">// Track whether the game is running</strong></p>
			<p class="source-code"><strong class="bold">bool paused = true;</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p class="source-code">    /*</p>
			<p class="source-code">    ****************************************</p>
			<p class="source-code">    Handle the players input</p>
			<p class="source-code">    ****************************************</p>
			<p class="source-code">    */</p>
			<p>Now, whenever the game is run, we have a <strong class="source-inline">paused</strong> variable that will be <strong class="source-inline">true</strong>.</p>
			<p>Next, we will add another <strong class="source-inline">if</strong> statement where the expression will check whether the <em class="italic">Enter</em> key is currently being pressed. If it is being pressed, it sets <strong class="source-inline">paused</strong> to <strong class="source-inline">false</strong>. Add the following highlighted code just after our other keyboard-handling code:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Handle the players input</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.close();</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">// Start the game</strong></p>
			<p class="source-code"><strong class="bold">if (Keyboard::isKeyPressed(Keyboard::Return))</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    paused = false;	</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>Now, we have a <strong class="source-inline">bool</strong> called <strong class="source-inline">paused</strong> that starts off <strong class="source-inline">true</strong> but changes to <strong class="source-inline">false</strong> when the player presses the <em class="italic">Enter</em> key. At this point, we must make our game loop respond appropriately, based on whatever the current value of <strong class="source-inline">paused</strong> might be.</p>
			<p>This is how we will proceed. We will wrap the entire update part of the code, including the code we wrote in the last chapter for moving the bee and clouds, in an <strong class="source-inline">if</strong> statement.</p>
			<p>In the following code, note that the <strong class="source-inline">if</strong> block will only execute when <strong class="source-inline">paused</strong> is not equal to <strong class="source-inline">true</strong>. Put another way, the game won't move/update when it is paused.</p>
			<p>This is exactly what we want. Look carefully at the place where we added the new <strong class="source-inline">if</strong> statement and its corresponding opening and closing curly braces <strong class="source-inline">{...}</strong>. If they are put in the wrong place, things will not work as expected.</p>
			<p>Add the following highlighted code to wrap the updated part of the code, paying close attention to the context that follows. I have added <strong class="source-inline">...</strong> on a few lines to represent hidden code. Obviously, ... is not real code and should not be added to the game. You can identify where to place the new code (highlighted) at the start and the end by the unhighlighted code surrounding it:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code"><strong class="bold">if (!paused)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code">    // Measure time</p>
			<p class="source-code">                ...</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        </p>
			<p class="source-code">        // Has the cloud reached the right hand edge of the screen?</p>
			<p class="source-code">        if (spriteCloud3.getPosition().x &gt; 1920)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Set it up ready to be a whole new cloud next frame</p>
			<p class="source-code">            cloud3Active = false;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">} // End if(!paused)</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>Note that, when you place the closing curly brace of the new <strong class="source-inline">if</strong> block, Visual Studio neatly adjusts all the indenting to keep the code tidy.</p>
			<p>Now, you can run the game and everything will be static until you press the <em class="italic">Enter</em> key. It is now possible to go about adding features to our game. We just need to remember that, when the player dies or runs out of time, we need to set <strong class="source-inline">paused</strong> to <strong class="source-inline">true</strong>.</p>
			<p>In the previous chapter, we took our first look at C++ Strings. We need to learn a bit more about them so that we can implement the player's HUD.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>C++ Strings</h1>
			<p>In the previous chapter, we briefly mentioned Strings and we learned that a String can hold alphanumeric data – anything from a single character to a whole book. We didn't look at declaring, initializing, or manipulating Strings, so let's do that now.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Declaring Strings</h2>
			<p>Declaring a String variable is simple. It is the same process that we used for other variables in the previous chapter: we state the type, followed by the name:</p>
			<p class="source-code">String levelName;</p>
			<p class="source-code">String playerName;</p>
			<p>Once we have declared a String, we can assign a value to it.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Assigning a value to a String</h2>
			<p>To assign a value to a String, just like regular variables, we simply put the name, followed by the assignment operator, and then the value:</p>
			<p class="source-code">levelName = "DastardlyCave";</p>
			<p class="source-code">playerName = "John Carmack";</p>
			<p>Note that the values need to be enclosed in quotation marks. Just like regular variables, we can also declare and assign values in a single line:</p>
			<p class="source-code">String score = "Score = 0";</p>
			<p class="source-code">String message = "GAME OVER!!";</p>
			<p>In the next section, we will see how we can change the values of our String variables.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Manipulating Strings</h2>
			<p>We can use the <strong class="source-inline">#include &lt;sstream&gt;</strong> directive to give us some extra manipulation options for our Strings. The <strong class="source-inline">sstream</strong> class allows us to "add" some Strings together. When we add Strings together, this is known as <strong class="bold">concatenation</strong>:</p>
			<p class="source-code">String part1 = "Hello ";</p>
			<p class="source-code">String part2 = "World";</p>
			<p class="source-code">sstream ss;</p>
			<p class="source-code">ss&lt;&lt; part1 &lt;&lt; part2;</p>
			<p class="source-code">// ss now holds "Hello World"</p>
			<p>In addition to this, by using <strong class="source-inline">sstream</strong> objects a String variable can even be concatenated with a variable of a different type. The following code starts to reveal how Strings might be useful to us:</p>
			<p class="source-code">String scoreText = "Score = ";</p>
			<p class="source-code">int score = 0;</p>
			<p class="source-code">// Later in the code</p>
			<p class="source-code">score ++;</p>
			<p class="source-code">sstream ss;</p>
			<p class="source-code">ss&lt;&lt;scoreText&lt;&lt; score;</p>
			<p class="source-code">// ss now holds "Score = 1"</p>
			<p>In the preceding code, <strong class="source-inline">ss</strong> is used to join the content of <strong class="source-inline">scoreText</strong> with the value from <strong class="source-inline">score</strong>. Note that although score holds an <strong class="source-inline">int</strong> value, the final value held by <strong class="source-inline">ss</strong> is still a String that holds an equivalent value; in this case, "1".</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">&lt;&lt;</strong> operator is one of the bitwise operators. C++, however, allows you to write your own classes and override what a specific operator does within the context of your class. The <strong class="source-inline">sstream</strong> class has done this to make the <strong class="source-inline">&lt;&lt;</strong> operator wo<a id="_idTextAnchor104"/>rk the way it does. The complexity is hidden in the class. We can use its functionality without worrying about how it works. If you are feeling adventurous, you can read about operator overloading at <a href="http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm">http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm</a>. You don't need any more information in order to continue with the project.</p>
			<p>Now that we know the basics of C++ Strings and how we can use <strong class="source-inline">sstream</strong>, we will look at how we can use some SFML classes to display them on the screen.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>SFML's Text and Font classes</h1>
			<p>Let's talk about the <strong class="source-inline">Text</strong> and <strong class="source-inline">Font</strong> classes using some hypothetical code before we go ahead and add the code to our game.</p>
			<p>The first step in being able to draw text on the screen is to have a font. In <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>, we added a font file to the project folder. Now, we can load the font into an SFML <strong class="source-inline">Font</strong> object, so that it's ready to use.</p>
			<p>The code to do so looks like the following:</p>
			<p class="source-code">Font font;</p>
			<p class="source-code">font.loadFromFile("myfont.ttf");</p>
			<p>In the preceding code, we first declare the <strong class="source-inline">Font</strong> object and then load an actual font file. Note that <strong class="source-inline">myfont.ttf</strong> is a hypothetical font and that we could use any font in the project folder.</p>
			<p>Once we have loaded a font, we need an SFML <strong class="source-inline">Text</strong> object:</p>
			<p class="source-code">Text myText;</p>
			<p>Now, we can configure our <strong class="source-inline">Text</strong> object. This includes the size, the color, the position on-screen, the String that holds the message, and of course the act of associating it with our <strong class="source-inline">font</strong> object:</p>
			<p class="source-code">// Assign the actual message</p>
			<p class="source-code">myText.setString("Press Enter to start!");</p>
			<p class="source-code">// assign a size</p>
			<p class="source-code">myText.setCharacterSize(75);</p>
			<p class="source-code">// Choose a color</p>
			<p class="source-code">myText.setFillColor(Color::White);</p>
			<p class="source-code">// Set the font to our Text object</p>
			<p class="source-code">myText.setFont(font);</p>
			<p>Now that we can create and manipulate String values as well as assign, declare, and initialize SFML <strong class="source-inline">Text</strong> objects, we can move on to the next section, where we will add a HUD to Timber!!!</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Implementing the HUD</h1>
			<p>Now, we know enough about Strings, SFML <strong class="source-inline">Text</strong>, and SFML <strong class="source-inline">Font</strong> to go about implementing the HUD. <strong class="bold">HUD</strong> stands for <strong class="bold">Heads Up Display</strong>. It can be as simple as the score and text messages on the screen or it can include more complex elements such as a time-bar, mini-map, or compass that represents the direction that the player character is facing.</p>
			<p>To get started with the HUD, we need to add another <strong class="source-inline">#include</strong> directive to the top of the code file to add access to the <strong class="source-inline">sstream</strong> class. As we already know, the <strong class="source-inline">sstream</strong> class adds some really useful functionality for combining Strings and other variable types into a String.</p>
			<p>Add the following line of highlighted code:</p>
			<p class="source-code"><strong class="bold">#include &lt;sstream&gt;</strong></p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p>Next, we will set up our SFML <strong class="source-inline">Text</strong> objects: one to hold a message that we will vary to suit the state of the game and one that will hold the score and will need to be regularly updated.</p>
			<p>The code declares the <strong class="source-inline">Text</strong> and <strong class="source-inline">Font</strong> objects, loads the font, assigns the font to the <strong class="source-inline">Text</strong> objects, and then adds the String messages, color, and size. This should look familiar from our discussion in the previous section. In addition, we added a new <strong class="source-inline">int</strong> variable called <strong class="source-inline">score</strong> that we can manipulate so that it holds the player's score.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that, if you chose a different font from <strong class="source-inline">KOMIKAP_.ttf</strong>, back in <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a><em class="italic">, C++, SFML, Visual Studio, and Starting the First Game</em>, you will need to change that part of the code to match the <strong class="source-inline">.ttf</strong> file that you have in the <strong class="source-inline">Visual Studio Stuff/Projects/Timber/fonts</strong> folder.</p>
			<p>By adding the following highlighted code, we will be ready to move on to updating the HUD:</p>
			<p class="source-code">// Track whether the game is running</p>
			<p class="source-code">bool paused = true;</p>
			<p class="source-code"><strong class="bold">// Draw some text</strong></p>
			<p class="source-code"><strong class="bold">int score = 0;</strong></p>
			<p class="source-code"><strong class="bold">Text messageText;</strong></p>
			<p class="source-code"><strong class="bold">Text scoreText;</strong></p>
			<p class="source-code"><strong class="bold">// We need to choose a font</strong></p>
			<p class="source-code"><strong class="bold">Font font;</strong></p>
			<p class="source-code"><strong class="bold">font.loadFromFile("fonts/KOMIKAP_.ttf");</strong></p>
			<p class="source-code"><strong class="bold">// Set the font to our message</strong></p>
			<p class="source-code"><strong class="bold">messageText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setFont(font);</strong></p>
			<p class="source-code"><strong class="bold">// Assign the actual message</strong></p>
			<p class="source-code"><strong class="bold">messageText.setString("Press Enter to start!");</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setString("Score = 0");</strong></p>
			<p class="source-code"><strong class="bold">// Make it really big</strong></p>
			<p class="source-code"><strong class="bold">messageText.setCharacterSize(75);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setCharacterSize(100);</strong></p>
			<p class="source-code"><strong class="bold">// Choose a color</strong></p>
			<p class="source-code"><strong class="bold">messageText.setFillColor(Color::White);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setFillColor(Color::White);</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p class="source-code">    /*</p>
			<p class="source-code">    ****************************************</p>
			<p class="source-code">    Handle the players input</p>
			<p class="source-code">    ****************************************</p>
			<p class="source-code">    */</p>
			<p>In the preceding code we have achieved the following:</p>
			<ul>
				<li>Declared a variable to hold the score</li>
				<li>Declared some SFML <strong class="source-inline">Text</strong> and <strong class="source-inline">Font</strong> objects</li>
				<li>Initialized the <strong class="source-inline">Font</strong> object by loading a font from a file</li>
				<li>Initialized the <strong class="source-inline">Text</strong> objects using the font and some Strings</li>
				<li>Set the size and color of the <strong class="source-inline">Text</strong> objects using the <strong class="source-inline">setCharacterSize</strong> and <strong class="source-inline">setFillColor</strong> functions</li>
			</ul>
			<p>The following snippet of code might look a little convoluted, even complex. It is, however, straightforward when you break it down a bit. Examine and add the new highlighted code. We will go through it after this:</p>
			<p class="source-code">// Choose a color</p>
			<p class="source-code">messageText.setFillColor(Color::White);</p>
			<p class="source-code">scoreText.setFillColor(Color::White);</p>
			<p class="source-code"><strong class="bold">// Position the text</strong></p>
			<p class="source-code"><strong class="bold">FloatRect textRect = messageText.getLocalBounds();</strong></p>
			<p class="source-code"><strong class="bold">messageText.setOrigin(textRect.left +</strong></p>
			<p class="source-code"><strong class="bold">    textRect.width / 2.0f,</strong></p>
			<p class="source-code"><strong class="bold">    textRect.top +</strong></p>
			<p class="source-code"><strong class="bold">    textRect.height / 2.0f);</strong></p>
			<p class="source-code"><strong class="bold">messageText.setPosition(1920 / 2.0f,	1080 / 2.0f);</strong></p>
			<p class="source-code"><strong class="bold">scoreText.setPosition(20, 20);</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p class="source-code">    /*</p>
			<p class="source-code">    ****************************************</p>
			<p class="source-code">    Handle the players input</p>
			<p class="source-code">    ****************************************</p>
			<p class="source-code">    */</p>
			<p>We have two objects of the <strong class="source-inline">Text</strong> type that we will display on the screen. We want to position <strong class="source-inline">scoreText</strong> to the top left with a little bit of padding. This is not a challenge; we simply use <strong class="source-inline">scoreText.setPosition(20, 20)</strong>, which positions it at the top left with 20 pixels of horizontal and vertical padding.</p>
			<p>Positioning <strong class="source-inline">messageText</strong>, however, is not so easy. We want to position it in the exact midpoint of the screen. Initially, this might not seem like a problem, but then we have to remember that the origin of everything we draw is at the top left-hand corner. So, if we simply divide the screen width and height by two and use the results in <strong class="source-inline">mesageText.setPosition...</strong>, then the top left of the text will be in the center of the screen and it will spread out untidily to the right.</p>
			<p>The following is the code under discussion again for convenience:</p>
			<p class="source-code">// Position the text</p>
			<p class="source-code">FloatRect textRect = messageText.getLocalBounds();</p>
			<p class="source-code">messageText.setOrigin(textRect.left +</p>
			<p class="source-code">    textRect.width / 2.0f,</p>
			<p class="source-code">    textRect.top +</p>
			<p class="source-code">    textRect.height / 2.0f);</p>
			<p>What the code does is set the <em class="italic">center</em> of <strong class="source-inline">messageText</strong> to the center of the screen. The rather complex-looking bit of code that we are reviewing repositions the origin of <strong class="source-inline">messageText</strong> to the center of itself. </p>
			<p>In the preceding code, we first declare a new object of the <strong class="source-inline">FloatRect</strong> type called <strong class="source-inline">textRect</strong>. A <strong class="source-inline">FloatRect</strong> object, as its name suggests, holds a rectangle with floating-point coordinates.</p>
			<p>The code then uses the <strong class="source-inline">mesageText.getLocalBounds</strong> function to initialize <strong class="source-inline">textRect</strong> with the coordinates of the rectangle that wraps <strong class="source-inline">messageText</strong>.</p>
			<p>The next line of code, which is spread over four lines as it is quite long, uses the <strong class="source-inline">messageText.setOrigin</strong> function to change the origin (the point that is used to draw at) to the center of <strong class="source-inline">textRect</strong>. Of course, <strong class="source-inline">textRect</strong> holds a rectangle that matches the coordinates that wrap <strong class="source-inline">messageText</strong>. Then, this following line of code executes:</p>
			<p class="source-code">messageText.setPosition(1920 / 2.0f,	1080 / 2.0f);</p>
			<p>Now, <strong class="source-inline">messageText</strong> will be neatly positioned in the exact center of the screen. We will use this code each time we change the text of <strong class="source-inline">messageText</strong> because changing the message changes the size of <strong class="source-inline">messageText</strong>, so its origin will need recalculating.</p>
			<p>Next, we declare an object of the <strong class="source-inline">stringstream</strong> type called <strong class="source-inline">ss</strong>. Note that we use the full name, including the namespace, that is, <strong class="source-inline">std::stringstream</strong>. We could avoid this syntax by adding <strong class="source-inline">using namespace std</strong> to the top of our code file. We aren't going to here, though, because we use it infrequently. Take a look at the following code and add it to the game; then, we can go through it in more detail. Since we only want this code to execute when the game is not paused, be sure to add it with the other code, inside the <strong class="source-inline">if(!paused)</strong> block, as follows:</p>
			<p class="source-code">else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        spriteCloud3.setPosition(</p>
			<p class="source-code">            spriteCloud3.getPosition().x +</p>
			<p class="source-code">            (cloud3Speed * dt.asSeconds()),</p>
			<p class="source-code">            spriteCloud3.getPosition().y);</p>
			<p class="source-code">        // Has the cloud reached the right hand edge of the screen?</p>
			<p class="source-code">        if (spriteCloud3.getPosition().x &gt; 1920)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Set it up ready to be a whole new cloud next frame</p>
			<p class="source-code">            cloud3Active = false;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Update the score text</strong></p>
			<p class="source-code"><strong class="bold">    std::stringstream ss;</strong></p>
			<p class="source-code"><strong class="bold">    ss&lt;&lt; "Score = " &lt;&lt; score;</strong></p>
			<p class="source-code"><strong class="bold">    scoreText.setString(ss.str());</strong></p>
			<p class="source-code">}// End if(!paused)</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>We use <strong class="source-inline">ss</strong> and the special functionality provided by the <strong class="source-inline">&lt;&lt;</strong> operator, which concatenates variables into a <strong class="source-inline">stringstream</strong>. Here, <strong class="source-inline">ss &lt;&lt; "Score = " &lt;&lt; score</strong> has the effect of creating a String with <strong class="source-inline">"Score = "</strong>. Whatever the value of <strong class="source-inline">score</strong> is, is concatenated together. For example, when the game first starts, <strong class="source-inline">score</strong> is equal to zero, so <strong class="source-inline">ss</strong> will hold the <strong class="source-inline">"Score = 0"</strong> value. If <strong class="source-inline">score</strong> ever changes, <strong class="source-inline">ss</strong> will adapt each frame.</p>
			<p>The following line of code simply sets the String contained in <strong class="source-inline">ss</strong> to <strong class="source-inline">scoreText</strong>:</p>
			<p class="source-code">scoreText.setString(ss.str());</p>
			<p>It is now ready to be drawn to the screen.</p>
			<p>This following code draws both <strong class="source-inline">Text</strong> objects (<strong class="source-inline">scoreText</strong> and <strong class="source-inline">messageText</strong>), but the code that draws <strong class="source-inline">messageText</strong> is wrapped in an <strong class="source-inline">if</strong> statement. This <strong class="source-inline">if</strong> statement causes <strong class="source-inline">messageText </strong>to only be drawn when the game is paused.</p>
			<p>Add the following highlighted code:</p>
			<p class="source-code">// Now draw the insect</p>
			<p class="source-code">window.draw(spriteBee);</p>
			<p class="source-code"><strong class="bold">// Draw the score</strong></p>
			<p class="source-code"><strong class="bold">window.draw(scoreText);</strong></p>
			<p class="source-code"><strong class="bold">if (paused)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // Draw our message</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(messageText);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">// Show everything we just drew</p>
			<p class="source-code">window.display();</p>
			<p>We can now run the game and see our HUD being drawn on the screen. You will see the <strong class="bold">Score = 0 </strong>and <strong class="bold">PRESS ENTER TO START</strong> messages. The latter will disappear when you press <em class="italic">Enter</em>:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B14278_03_01.jpg" alt=""/>
				</div>
			</div>
			<p>If you want to see the score updating, add a temporary line of code, <strong class="source-inline">score ++;</strong>, anywhere in the <strong class="source-inline">while(window.isOpen)</strong> loop. If you add this temporary line, you will see the score go up fast, very fast!</p>
			<p>If you added the temporary code, that is, <strong class="source-inline">score ++;</strong>, be sure to delete it before continuing.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Adding a time-bar</h1>
			<p>Since time is a crucial mechanism in the game, it is necessary to keep the player aware of it. They need to know if their allotted six seconds are about to run out. It will give them a sense of urgency as the end of the game draws near and a sense of accomplishment if they perform well enough to maintain or increase their remaining time.</p>
			<p>Drawing the number of seconds remaining on the screen is not easy to read (when concentrating on the branches), nor is it a particularly interesting way to achieve the objective.</p>
			<p>What we need is a time-bar. Our time-bar will be a simple red rectangle that's prominently displayed on the screen. It will start off nice and wide, but rapidly shrink as time runs out. When the player's remaining time reaches zero, the time-bar will be gone completely.</p>
			<p>At the same time as adding the time-bar, we will add the necessary code to keep track of the player's remaining time, and respond when it runs out. Let's go through this step by step.</p>
			<p>Find the <strong class="source-inline">Clock clock;</strong> declaration from earlier and add the highlighted code just after it, as follows:</p>
			<p class="source-code">// Variables to control time itself</p>
			<p class="source-code">Clock clock;</p>
			<p class="source-code"><strong class="bold">// Time bar</strong></p>
			<p class="source-code"><strong class="bold">RectangleShape timeBar;</strong></p>
			<p class="source-code"><strong class="bold">float timeBarStartWidth = 400;</strong></p>
			<p class="source-code"><strong class="bold">float timeBarHeight = 80;</strong></p>
			<p class="source-code"><strong class="bold">timeBar.setSize(Vector2f(timeBarStartWidth, timeBarHeight));</strong></p>
			<p class="source-code"><strong class="bold">timeBar.setFillColor(Color::Red);</strong></p>
			<p class="source-code"><strong class="bold">timeBar.setPosition((1920 / 2) - timeBarStartWidth / 2, 980);</strong></p>
			<p class="source-code"><strong class="bold">Time gameTimeTotal;</strong></p>
			<p class="source-code"><strong class="bold">float timeRemaining = 6.0f;</strong></p>
			<p class="source-code"><strong class="bold">float timeBarWidthPerSecond = timeBarStartWidth / timeRemaining;</strong></p>
			<p class="source-code">// Track whether the game is running</p>
			<p class="source-code">bool paused = true;</p>
			<p>First, we declare an object of the <strong class="source-inline">RectangleShape</strong> type and call it <strong class="source-inline">timeBar</strong>. <strong class="source-inline">RectagleShape</strong> is an SFML class that is perfect for drawing simple rectangles.</p>
			<p>Next, we will add a few <strong class="source-inline">float</strong> variables, <strong class="source-inline">timeBarStartWidth</strong> and <strong class="source-inline">timeBarHeight</strong>. We initialize them to <strong class="source-inline">400</strong> and <strong class="source-inline">80</strong>, respectively. These variables will help us keep track of the size we need to draw <strong class="source-inline">timeBar</strong> at each frame.</p>
			<p>Next, we set the size of <strong class="source-inline">timeBar</strong> using the <strong class="source-inline">timeBar.setSize</strong> function. We don't just pass in our two new <strong class="source-inline">float</strong> variables. First, we create a new object of the <strong class="source-inline">Vector2f</strong> type. What is different here, however, is that we don't give the new object a name. Instead, we simply initialize it with our two float variables and pass it straight in to the <strong class="source-inline">setSize</strong> function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="source-inline">Vector2f</strong> is a class that holds two <strong class="source-inline">float</strong> variables. It also has some other functionality that will be introduced throughout this book.</p>
			<p>After that, we color <strong class="source-inline">timeBar</strong> red by using the <strong class="source-inline">setFillColor</strong> function.</p>
			<p>The last thing we do to <strong class="source-inline">timeBar</strong> in the previous code is set its position. The vertical coordinate is completely straightforward but the way we set the horizontal coordinate is slightly convoluted. Here is the calculation again:</p>
			<p class="source-code">(1920 / 2) - timeBarStartWidth / 2</p>
			<p>First, the code divides 1920 by 2. Then, it divides <strong class="source-inline">timeBarStartWidth</strong> by 2. Finally, it subtracts the latter from the former.</p>
			<p>The result makes <strong class="source-inline">timeBar</strong> sit neatly and centrally, in a horizontal fashion, on the screen.</p>
			<p>The final three lines of code that we are talking about declare a new <strong class="source-inline">Time</strong> object called <strong class="source-inline">gameTimeTotal</strong>, a new <strong class="source-inline">float</strong> called <strong class="source-inline">timeRemaining</strong> that is initialized to <strong class="source-inline">6</strong>, and a curious-sounding <strong class="source-inline">float</strong> named <strong class="source-inline">timeBarWidthPerSecond</strong>, which we will discuss next.</p>
			<p>The <strong class="source-inline">timeBarWidthPerSecond</strong> variable is initialized with <strong class="source-inline">timeBarStartWidth</strong> divided by <strong class="source-inline">timeRemaining</strong>. The result is exactly the amount of pixels that <strong class="source-inline">timeBar</strong> needs to shrink by each second of the game. This will be useful when we resize <strong class="source-inline">timeBar</strong> in each frame.</p>
			<p>Obviously, we need to reset the time remaining each time the player starts a new game. The logical place to do this is when the <em class="italic">Enter</em> key is pressed. We can also set <strong class="source-inline">score</strong> back to zero at the same time. Let's do that now by adding the following highlighted code</p>
			<p class="source-code">// Start the game</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Return))</p>
			<p class="source-code">{</p>
			<p class="source-code">    paused = false;</p>
			<p class="source-code"><strong class="bold">    // Reset the time and the score</strong></p>
			<p class="source-code"><strong class="bold">    score = 0;</strong></p>
			<p class="source-code"><strong class="bold">    timeRemaining = 6;</strong></p>
			<p class="source-code">}</p>
			<p>Now, we must reduce each frame by the amount of time remaining and resize <strong class="source-inline">timeBar</strong> accordingly. Add the following highlighted code to the update section, as shown here:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">if (!paused)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Measure time</p>
			<p class="source-code">    Time dt = clock.restart();</p>
			<p class="source-code"><strong class="bold">    // Subtract from the amount of time remaining</strong></p>
			<p class="source-code"><strong class="bold">    timeRemaining -= dt.asSeconds();</strong></p>
			<p class="source-code"><strong class="bold">    // size up the time bar</strong></p>
			<p class="source-code"><strong class="bold">    timeBar.setSize(Vector2f(timeBarWidthPerSecond *</strong></p>
			<p class="source-code"><strong class="bold">        timeRemaining, timeBarHeight));</strong></p>
			<p class="source-code">    // Set up the bee</p>
			<p class="source-code">    if (!beeActive)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // How fast is the bee</p>
			<p class="source-code">        srand((int)time(0) * 10);</p>
			<p class="source-code">        beeSpeed = (rand() % 200) + 200;</p>
			<p class="source-code">        // How high is the bee</p>
			<p class="source-code">        srand((int)time(0) * 10);</p>
			<p class="source-code">        float height = (rand() % 1350) + 500;</p>
			<p class="source-code">        spriteBee.setPosition(2000, height);</p>
			<p class="source-code">        beeActive = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">        // Move the bee</p>
			<p>First, we subtracted the amount of time the player has left by however long the previous frame took to execute with the following code:</p>
			<p class="source-code">timeRemaining -= dt.asSeconds();</p>
			<p>Then, we adjusted the size of <strong class="source-inline">timeBar</strong> with the following code:</p>
			<p class="source-code">timeBar.setSize(Vector2f(timeBarWidthPerSecond *</p>
			<p class="source-code">        timeRemaining, timeBarHeight));</p>
			<p>The x value of <strong class="source-inline">Vector2F</strong> is initialized with <strong class="source-inline">timebarWidthPerSecond</strong> when multiplied by <strong class="source-inline">timeRemaining</strong>. This produces exactly the right width, relative to how long the player has left. The height remains the same and <strong class="source-inline">timeBarHeight</strong> is used without any manipulation.</p>
			<p>And of course, we must detect when the time has run out. For now, we will simply detect that time has run out, pause the game, and change the text of <strong class="source-inline">messageText</strong>. Later, we will do more work here. Add the following highlighted code right after the previous code we added. We will look at it in more detail later:</p>
			<p class="source-code">// Measure time</p>
			<p class="source-code">Time dt = clock.restart();</p>
			<p class="source-code">// Subtract from the amount of time remaining</p>
			<p class="source-code">timeRemaining -= dt.asSeconds();</p>
			<p class="source-code">// resize up the time bar</p>
			<p class="source-code">timeBar.setSize(Vector2f(timeBarWidthPerSecond *</p>
			<p class="source-code">    timeRemaining, timeBarHeight));</p>
			<p class="source-code"><strong class="bold">if (timeRemaining&lt;= 0.0f) {</strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">    // Pause the game</strong></p>
			<p class="source-code"><strong class="bold">    paused = true;</strong></p>
			<p class="source-code"><strong class="bold">    // Change the message shown to the player</strong></p>
			<p class="source-code"><strong class="bold">    messageText.setString("Out of time!!");</strong></p>
			<p class="source-code"><strong class="bold">    //Reposition the text based on its new size</strong></p>
			<p class="source-code"><strong class="bold">    FloatRect textRect = messageText.getLocalBounds();</strong></p>
			<p class="source-code"><strong class="bold">    messageText.setOrigin(textRect.left +</strong></p>
			<p class="source-code"><strong class="bold">        textRect.width / 2.0f,</strong></p>
			<p class="source-code"><strong class="bold">        textRect.top +</strong></p>
			<p class="source-code"><strong class="bold">        textRect.height / 2.0f);</strong></p>
			<p class="source-code"><strong class="bold">    messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">// Set up the bee</p>
			<p class="source-code">if (!beeActive)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // How fast is the bee</p>
			<p class="source-code">    srand((int)time(0) * 10);</p>
			<p class="source-code">    beeSpeed = (rand() % 200) + 200;</p>
			<p class="source-code">    // How high is the bee</p>
			<p class="source-code">    srand((int)time(0) * 10);</p>
			<p class="source-code">    float height = (rand() % 1350) + 500;</p>
			<p class="source-code">    spriteBee.setPosition(2000, height);</p>
			<p class="source-code">    beeActive = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">    // Move the bee</p>
			<p>Let's step through the previous code:</p>
			<ol>
				<li>First, we test whether time has run out with <strong class="source-inline">if(timeRemaining&lt;= 0.0f).</strong></li>
				<li>Then, we set <strong class="source-inline">paused</strong> to <strong class="source-inline">true</strong>, so this will be the last time the update part of our code is executed (until the player presses <em class="italic">Enter</em> again).</li>
				<li>Then, we change the message of <strong class="source-inline">messageText</strong>, calculate its new center to be set as its origin, and position it in the center of the screen.</li>
			</ol>
			<p>Finally, for this part of the code, we need to draw <strong class="source-inline">timeBar</strong>. There is nothing new in this code that we haven't seen many times before. Just note that we draw <strong class="source-inline">timeBar</strong> after the tree so that it is not partially obscured. Add the following highlighted code to draw the time-bar:</p>
			<p class="source-code">// Draw the score</p>
			<p class="source-code">window.draw(scoreText);</p>
			<p class="source-code"><strong class="bold">// Draw the timebar</strong></p>
			<p class="source-code"><strong class="bold">window.draw(timeBar);</strong></p>
			<p class="source-code">if (paused)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Draw our message</p>
			<p class="source-code">    window.draw(messageText);</p>
			<p class="source-code">}</p>
			<p class="source-code">// Show everything we just drew</p>
			<p class="source-code">window.display();</p>
			<p>Now, you can run the game, press <em class="italic">Enter</em> to start it, and watch the time-bar smoothly disappear down to nothing:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Image85176.jpg" alt=""/>
				</div>
			</div>
			<p>The game then pauses and the <strong class="bold">OUT OF TIME!! </strong>message will appear in the center of the screen:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B14278_03_04.jpg" alt=""/>
				</div>
			</div>
			<p>You can, of course, press <em class="italic">Enter</em> to start the game again and watch it run from the beginning.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>Summary</h1>
			<p>In this chapter, we learned about Strings, SFML <strong class="source-inline">Text</strong>, and SFML <strong class="source-inline">Font</strong>. Between them, they allowed us to draw text to the screen, which provided the player with a HUD. We also used <strong class="source-inline">sstream</strong>, which allows us to concatenate Strings and other variables to display the score.</p>
			<p>We also explored the SFML <strong class="source-inline">RectangleShape</strong> class, which does exactly what its name suggests. We used an object of the <strong class="source-inline">RectangleShape</strong> type and some carefully planned variables to draw a time-bar that visually displays to the player how much time they have left. Once we implement chopping and moving branches that can squash the player, the time-bar will provide visual feedback that will create tension and urgency.</p>
			<p>In the next chapter, we are going to learn about a whole range of new C++ features, including loops, arrays, switching, enumerations, and functions. This will allow us to move tree branches, keep track of their locations, and squash the player.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>FAQ</h1>
			<p>Q) I can foresee that positioning sprites by their top-left corner could sometimes be inconvenient. Is there an alternative?</p>
			<p>A) Fortunately, you can choose what point of a sprite is used as the positioning/origin pixel, just like we did with <strong class="source-inline">messageText</strong>, using the <strong class="source-inline">setOrigin</strong> function.</p>
			<p>Q) The code is getting rather long and I am struggling to keep track of where everything is. How can we fix this?</p>
			<p>A) Yes, I agree. In the next chapter, we will look at the first of a few ways we can organize our code and make it more readable. We will look at this when we learn about writing C++ functions. In addition, we will learn about a new way we can handle multiple objects/variables of the same type (like the clouds) when we learn about C++ arrays.</p>
		</div>
	</body></html>