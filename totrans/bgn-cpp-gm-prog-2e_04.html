<html><head></head><body>
		<div><h1 id="_idParaDest-97"><a id="_idTextAnchor098"/><em class="italic">Chapter 3</em>: C++ Strings and SFML Time – Player Input and HUD</h1>
			<p>In this chapter, we will continue with the Timber!! game. We will spend around half of this chapter learning how to manipulate text and display it on the screen, and the other half looking at timing and how a visual time-bar can inform the player about the remaining time and create a sense of urgency in the game.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>Pausing and restarting the game</li>
				<li>C++ Strings</li>
				<li>SFML text and SFML font classes</li>
				<li>Adding a HUD to Timber!!!</li>
				<li>Adding a time-bar to Timber!!!</li>
			</ul>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>Pausing and restarting the game</h1>
			<p>As we work on this game over the next three chapters, the code will obviously get longer and longer. So, now seems like a good time to think ahead and add a little bit more structure to our code. We will add this structure so that we can pause and restart the game.</p>
			<p>We will add code so that, when the game is run for the first time, it will be in a paused state. The player will then be able to press the <em class="italic">Enter</em> key to start the game. Then, the game will run until either the player gets squished or runs out of time. At this point, the game will pause and wait for the player to press <em class="italic">Enter</em> so that they can restart the game.</p>
			<p>Let's step through setting this up a bit at a time.</p>
			<p>First, declare a new <code>bool</code> variable called <code>paused</code> outside the main game loop and initialize it to <code>true</code>:</p>
			<pre>// Variables to control time itself
Clock clock;
<strong class="bold">// Track whether the game is running</strong>
<strong class="bold">bool paused = true;</strong>
while (window.isOpen())
{
    /*
    ****************************************
    Handle the players input
    ****************************************
    */</pre>
			<p>Now, whenever the game is run, we have a <code>paused</code> variable that will be <code>true</code>.</p>
			<p>Next, we will add another <code>if</code> statement where the expression will check whether the <em class="italic">Enter</em> key is currently being pressed. If it is being pressed, it sets <code>paused</code> to <code>false</code>. Add the following highlighted code just after our other keyboard-handling code:</p>
			<pre>/*
****************************************
Handle the players input
****************************************
*/
if (Keyboard::isKeyPressed(Keyboard::Escape))
{
    window.close();
}
<strong class="bold">// Start the game</strong>
<strong class="bold">if (Keyboard::isKeyPressed(Keyboard::Return))</strong>
<strong class="bold">{</strong>
<strong class="bold">    paused = false;	</strong>
<strong class="bold">}</strong>
/*
****************************************
Update the scene
****************************************
*/</pre>
			<p>Now, we have a <code>bool</code> called <code>paused</code> that starts off <code>true</code> but changes to <code>false</code> when the player presses the <em class="italic">Enter</em> key. At this point, we must make our game loop respond appropriately, based on whatever the current value of <code>paused</code> might be.</p>
			<p>This is how we will proceed. We will wrap the entire update part of the code, including the code we wrote in the last chapter for moving the bee and clouds, in an <code>if</code> statement.</p>
			<p>In the following code, note that the <code>if</code> block will only execute when <code>paused</code> is not equal to <code>true</code>. Put another way, the game won't move/update when it is paused.</p>
			<p>This is exactly what we want. Look carefully at the place where we added the new <code>if</code> statement and its corresponding opening and closing curly braces <code>{...}</code>. If they are put in the wrong place, things will not work as expected.</p>
			<p>Add the following highlighted code to wrap the updated part of the code, paying close attention to the context that follows. I have added <code>...</code> on a few lines to represent hidden code. Obviously, ... is not real code and should not be added to the game. You can identify where to place the new code (highlighted) at the start and the end by the unhighlighted code surrounding it:</p>
			<pre>/*
****************************************
Update the scene
****************************************
*/
<strong class="bold">if (!paused)</strong>
<strong class="bold">{</strong>
    // Measure time
                ...
        ...
        ...
        
        // Has the cloud reached the right hand edge of the screen?
        if (spriteCloud3.getPosition().x &gt; 1920)
        {
            // Set it up ready to be a whole new cloud next frame
            cloud3Active = false;
        }
    }
<strong class="bold">} // End if(!paused)</strong>
/*
****************************************
Draw the scene
****************************************
*/</pre>
			<p>Note that, when you place the closing curly brace of the new <code>if</code> block, Visual Studio neatly adjusts all the indenting to keep the code tidy.</p>
			<p>Now, you can run the game and everything will be static until you press the <em class="italic">Enter</em> key. It is now possible to go about adding features to our game. We just need to remember that, when the player dies or runs out of time, we need to set <code>paused</code> to <code>true</code>.</p>
			<p>In the previous chapter, we took our first look at C++ Strings. We need to learn a bit more about them so that we can implement the player's HUD.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>C++ Strings</h1>
			<p>In the previous chapter, we briefly mentioned Strings and we learned that a String can hold alphanumeric data – anything from a single character to a whole book. We didn't look at declaring, initializing, or manipulating Strings, so let's do that now.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Declaring Strings</h2>
			<p>Declaring a String variable is simple. It is the same process that we used for other variables in the previous chapter: we state the type, followed by the name:</p>
			<pre>String levelName;
String playerName;</pre>
			<p>Once we have declared a String, we can assign a value to it.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Assigning a value to a String</h2>
			<p>To assign a value to a String, just like regular variables, we simply put the name, followed by the assignment operator, and then the value:</p>
			<pre>levelName = "DastardlyCave";
playerName = "John Carmack";</pre>
			<p>Note that the values need to be enclosed in quotation marks. Just like regular variables, we can also declare and assign values in a single line:</p>
			<pre>String score = "Score = 0";
String message = "GAME OVER!!";</pre>
			<p>In the next section, we will see how we can change the values of our String variables.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Manipulating Strings</h2>
			<p>We can use the <code>#include &lt;sstream&gt;</code> directive to give us some extra manipulation options for our Strings. The <code>sstream</code> class allows us to "add" some Strings together. When we add Strings together, this is known as <strong class="bold">concatenation</strong>:</p>
			<pre>String part1 = "Hello ";
String part2 = "World";
sstream ss;
ss&lt;&lt; part1 &lt;&lt; part2;
// ss now holds "Hello World"</pre>
			<p>In addition to this, by using <code>sstream</code> objects a String variable can even be concatenated with a variable of a different type. The following code starts to reveal how Strings might be useful to us:</p>
			<pre>String scoreText = "Score = ";
int score = 0;
// Later in the code
score ++;
sstream ss;
ss&lt;&lt;scoreText&lt;&lt; score;
// ss now holds "Score = 1"</pre>
			<p>In the preceding code, <code>ss</code> is used to join the content of <code>scoreText</code> with the value from <code>score</code>. Note that although score holds an <code>int</code> value, the final value held by <code>ss</code> is still a String that holds an equivalent value; in this case, "1".</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <code>&lt;&lt;</code> operator is one of the bitwise operators. C++, however, allows you to write your own classes and override what a specific operator does within the context of your class. The <code>sstream</code> class has done this to make the <code>&lt;&lt;</code> operator wo<a id="_idTextAnchor104"/>rk the way it does. The complexity is hidden in the class. We can use its functionality without worrying about how it works. If you are feeling adventurous, you can read about operator overloading at <a href="http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm">http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm</a>. You don't need any more information in order to continue with the project.</p>
			<p>Now that we know the basics of C++ Strings and how we can use <code>sstream</code>, we will look at how we can use some SFML classes to display them on the screen.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>SFML's Text and Font classes</h1>
			<p>Let's talk about the <code>Text</code> and <code>Font</code> classes using some hypothetical code before we go ahead and add the code to our game.</p>
			<p>The first step in being able to draw text on the screen is to have a font. In <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>, we added a font file to the project folder. Now, we can load the font into an SFML <code>Font</code> object, so that it's ready to use.</p>
			<p>The code to do so looks like the following:</p>
			<pre>Font font;
font.loadFromFile("myfont.ttf");</pre>
			<p>In the preceding code, we first declare the <code>Font</code> object and then load an actual font file. Note that <code>myfont.ttf</code> is a hypothetical font and that we could use any font in the project folder.</p>
			<p>Once we have loaded a font, we need an SFML <code>Text</code> object:</p>
			<pre>Text myText;</pre>
			<p>Now, we can configure our <code>Text</code> object. This includes the size, the color, the position on-screen, the String that holds the message, and of course the act of associating it with our <code>font</code> object:</p>
			<pre>// Assign the actual message
myText.setString("Press Enter to start!");
// assign a size
myText.setCharacterSize(75);
// Choose a color
myText.setFillColor(Color::White);
// Set the font to our Text object
myText.setFont(font);</pre>
			<p>Now that we can create and manipulate String values as well as assign, declare, and initialize SFML <code>Text</code> objects, we can move on to the next section, where we will add a HUD to Timber!!!</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Implementing the HUD</h1>
			<p>Now, we know enough about Strings, SFML <code>Text</code>, and SFML <code>Font</code> to go about implementing the HUD. <strong class="bold">HUD</strong> stands for <strong class="bold">Heads Up Display</strong>. It can be as simple as the score and text messages on the screen or it can include more complex elements such as a time-bar, mini-map, or compass that represents the direction that the player character is facing.</p>
			<p>To get started with the HUD, we need to add another <code>#include</code> directive to the top of the code file to add access to the <code>sstream</code> class. As we already know, the <code>sstream</code> class adds some really useful functionality for combining Strings and other variable types into a String.</p>
			<p>Add the following line of highlighted code:</p>
			<pre><strong class="bold">#include &lt;sstream&gt;</strong>
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
int main()
{</pre>
			<p>Next, we will set up our SFML <code>Text</code> objects: one to hold a message that we will vary to suit the state of the game and one that will hold the score and will need to be regularly updated.</p>
			<p>The code declares the <code>Text</code> and <code>Font</code> objects, loads the font, assigns the font to the <code>Text</code> objects, and then adds the String messages, color, and size. This should look familiar from our discussion in the previous section. In addition, we added a new <code>int</code> variable called <code>score</code> that we can manipulate so that it holds the player's score.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that, if you chose a different font from <code>KOMIKAP_.ttf</code>, back in <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a><em class="italic">, C++, SFML, Visual Studio, and Starting the First Game</em>, you will need to change that part of the code to match the <code>.ttf</code> file that you have in the <code>Visual Studio Stuff/Projects/Timber/fonts</code> folder.</p>
			<p>By adding the following highlighted code, we will be ready to move on to updating the HUD:</p>
			<pre>// Track whether the game is running
bool paused = true;
<strong class="bold">// Draw some text</strong>
<strong class="bold">int score = 0;</strong>
<strong class="bold">Text messageText;</strong>
<strong class="bold">Text scoreText;</strong>
<strong class="bold">// We need to choose a font</strong>
<strong class="bold">Font font;</strong>
<strong class="bold">font.loadFromFile("fonts/KOMIKAP_.ttf");</strong>
<strong class="bold">// Set the font to our message</strong>
<strong class="bold">messageText.setFont(font);</strong>
<strong class="bold">scoreText.setFont(font);</strong>
<strong class="bold">// Assign the actual message</strong>
<strong class="bold">messageText.setString("Press Enter to start!");</strong>
<strong class="bold">scoreText.setString("Score = 0");</strong>
<strong class="bold">// Make it really big</strong>
<strong class="bold">messageText.setCharacterSize(75);</strong>
<strong class="bold">scoreText.setCharacterSize(100);</strong>
<strong class="bold">// Choose a color</strong>
<strong class="bold">messageText.setFillColor(Color::White);</strong>
<strong class="bold">scoreText.setFillColor(Color::White);</strong>
while (window.isOpen())
{
    /*
    ****************************************
    Handle the players input
    ****************************************
    */</pre>
			<p>In the preceding code we have achieved the following:</p>
			<ul>
				<li>Declared a variable to hold the score</li>
				<li>Declared some SFML <code>Text</code> and <code>Font</code> objects</li>
				<li>Initialized the <code>Font</code> object by loading a font from a file</li>
				<li>Initialized the <code>Text</code> objects using the font and some Strings</li>
				<li>Set the size and color of the <code>Text</code> objects using the <code>setCharacterSize</code> and <code>setFillColor</code> functions</li>
			</ul>
			<p>The following snippet of code might look a little convoluted, even complex. It is, however, straightforward when you break it down a bit. Examine and add the new highlighted code. We will go through it after this:</p>
			<pre>// Choose a color
messageText.setFillColor(Color::White);
scoreText.setFillColor(Color::White);
<strong class="bold">// Position the text</strong>
<strong class="bold">FloatRect textRect = messageText.getLocalBounds();</strong>
<strong class="bold">messageText.setOrigin(textRect.left +</strong>
<strong class="bold">    textRect.width / 2.0f,</strong>
<strong class="bold">    textRect.top +</strong>
<strong class="bold">    textRect.height / 2.0f);</strong>
<strong class="bold">messageText.setPosition(1920 / 2.0f,	1080 / 2.0f);</strong>
<strong class="bold">scoreText.setPosition(20, 20);</strong>
while (window.isOpen())
{
    /*
    ****************************************
    Handle the players input
    ****************************************
    */</pre>
			<p>We have two objects of the <code>Text</code> type that we will display on the screen. We want to position <code>scoreText</code> to the top left with a little bit of padding. This is not a challenge; we simply use <code>scoreText.setPosition(20, 20)</code>, which positions it at the top left with 20 pixels of horizontal and vertical padding.</p>
			<p>Positioning <code>messageText</code>, however, is not so easy. We want to position it in the exact midpoint of the screen. Initially, this might not seem like a problem, but then we have to remember that the origin of everything we draw is at the top left-hand corner. So, if we simply divide the screen width and height by two and use the results in <code>mesageText.setPosition...</code>, then the top left of the text will be in the center of the screen and it will spread out untidily to the right.</p>
			<p>The following is the code under discussion again for convenience:</p>
			<pre>// Position the text
FloatRect textRect = messageText.getLocalBounds();
messageText.setOrigin(textRect.left +
    textRect.width / 2.0f,
    textRect.top +
    textRect.height / 2.0f);</pre>
			<p>What the code does is set the <em class="italic">center</em> of <code>messageText</code> to the center of the screen. The rather complex-looking bit of code that we are reviewing repositions the origin of <code>messageText</code> to the center of itself. </p>
			<p>In the preceding code, we first declare a new object of the <code>FloatRect</code> type called <code>textRect</code>. A <code>FloatRect</code> object, as its name suggests, holds a rectangle with floating-point coordinates.</p>
			<p>The code then uses the <code>mesageText.getLocalBounds</code> function to initialize <code>textRect</code> with the coordinates of the rectangle that wraps <code>messageText</code>.</p>
			<p>The next line of code, which is spread over four lines as it is quite long, uses the <code>messageText.setOrigin</code> function to change the origin (the point that is used to draw at) to the center of <code>textRect</code>. Of course, <code>textRect</code> holds a rectangle that matches the coordinates that wrap <code>messageText</code>. Then, this following line of code executes:</p>
			<pre>messageText.setPosition(1920 / 2.0f,	1080 / 2.0f);</pre>
			<p>Now, <code>messageText</code> will be neatly positioned in the exact center of the screen. We will use this code each time we change the text of <code>messageText</code> because changing the message changes the size of <code>messageText</code>, so its origin will need recalculating.</p>
			<p>Next, we declare an object of the <code>stringstream</code> type called <code>ss</code>. Note that we use the full name, including the namespace, that is, <code>std::stringstream</code>. We could avoid this syntax by adding <code>using namespace std</code> to the top of our code file. We aren't going to here, though, because we use it infrequently. Take a look at the following code and add it to the game; then, we can go through it in more detail. Since we only want this code to execute when the game is not paused, be sure to add it with the other code, inside the <code>if(!paused)</code> block, as follows:</p>
			<pre>else
    {
        spriteCloud3.setPosition(
            spriteCloud3.getPosition().x +
            (cloud3Speed * dt.asSeconds()),
            spriteCloud3.getPosition().y);
        // Has the cloud reached the right hand edge of the screen?
        if (spriteCloud3.getPosition().x &gt; 1920)
        {
            // Set it up ready to be a whole new cloud next frame
            cloud3Active = false;
        }
    }
<strong class="bold">    // Update the score text</strong>
<strong class="bold">    std::stringstream ss;</strong>
<strong class="bold">    ss&lt;&lt; "Score = " &lt;&lt; score;</strong>
<strong class="bold">    scoreText.setString(ss.str());</strong>
}// End if(!paused)
/*
****************************************
Draw the scene
****************************************
*/</pre>
			<p>We use <code>ss</code> and the special functionality provided by the <code>&lt;&lt;</code> operator, which concatenates variables into a <code>stringstream</code>. Here, <code>ss &lt;&lt; "Score = " &lt;&lt; score</code> has the effect of creating a String with <code>"Score = "</code>. Whatever the value of <code>score</code> is, is concatenated together. For example, when the game first starts, <code>score</code> is equal to zero, so <code>ss</code> will hold the <code>"Score = 0"</code> value. If <code>score</code> ever changes, <code>ss</code> will adapt each frame.</p>
			<p>The following line of code simply sets the String contained in <code>ss</code> to <code>scoreText</code>:</p>
			<pre>scoreText.setString(ss.str());</pre>
			<p>It is now ready to be drawn to the screen.</p>
			<p>This following code draws both <code>Text</code> objects (<code>scoreText</code> and <code>messageText</code>), but the code that draws <code>messageText</code> is wrapped in an <code>if</code> statement. This <code>if</code> statement causes <code>messageText </code>to only be drawn when the game is paused.</p>
			<p>Add the following highlighted code:</p>
			<pre>// Now draw the insect
window.draw(spriteBee);
<strong class="bold">// Draw the score</strong>
<strong class="bold">window.draw(scoreText);</strong>
<strong class="bold">if (paused)</strong>
<strong class="bold">{</strong>
<strong class="bold">    // Draw our message</strong>
<strong class="bold">    window.draw(messageText);</strong>
<strong class="bold">}</strong>
// Show everything we just drew
window.display();</pre>
			<p>We can now run the game and see our HUD being drawn on the screen. You will see the <strong class="bold">Score = 0 </strong>and <strong class="bold">PRESS ENTER TO START</strong> messages. The latter will disappear when you press <em class="italic">Enter</em>:</p>
			<div><div><img src="img/B14278_03_01.jpg" alt=""/>
				</div>
			</div>
			<p>If you want to see the score updating, add a temporary line of code, <code>score ++;</code>, anywhere in the <code>while(window.isOpen)</code> loop. If you add this temporary line, you will see the score go up fast, very fast!</p>
			<p>If you added the temporary code, that is, <code>score ++;</code>, be sure to delete it before continuing.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Adding a time-bar</h1>
			<p>Since time is a crucial mechanism in the game, it is necessary to keep the player aware of it. They need to know if their allotted six seconds are about to run out. It will give them a sense of urgency as the end of the game draws near and a sense of accomplishment if they perform well enough to maintain or increase their remaining time.</p>
			<p>Drawing the number of seconds remaining on the screen is not easy to read (when concentrating on the branches), nor is it a particularly interesting way to achieve the objective.</p>
			<p>What we need is a time-bar. Our time-bar will be a simple red rectangle that's prominently displayed on the screen. It will start off nice and wide, but rapidly shrink as time runs out. When the player's remaining time reaches zero, the time-bar will be gone completely.</p>
			<p>At the same time as adding the time-bar, we will add the necessary code to keep track of the player's remaining time, and respond when it runs out. Let's go through this step by step.</p>
			<p>Find the <code>Clock clock;</code> declaration from earlier and add the highlighted code just after it, as follows:</p>
			<pre>// Variables to control time itself
Clock clock;
<strong class="bold">// Time bar</strong>
<strong class="bold">RectangleShape timeBar;</strong>
<strong class="bold">float timeBarStartWidth = 400;</strong>
<strong class="bold">float timeBarHeight = 80;</strong>
<strong class="bold">timeBar.setSize(Vector2f(timeBarStartWidth, timeBarHeight));</strong>
<strong class="bold">timeBar.setFillColor(Color::Red);</strong>
<strong class="bold">timeBar.setPosition((1920 / 2) - timeBarStartWidth / 2, 980);</strong>
<strong class="bold">Time gameTimeTotal;</strong>
<strong class="bold">float timeRemaining = 6.0f;</strong>
<strong class="bold">float timeBarWidthPerSecond = timeBarStartWidth / timeRemaining;</strong>
// Track whether the game is running
bool paused = true;</pre>
			<p>First, we declare an object of the <code>RectangleShape</code> type and call it <code>timeBar</code>. <code>RectagleShape</code> is an SFML class that is perfect for drawing simple rectangles.</p>
			<p>Next, we will add a few <code>float</code> variables, <code>timeBarStartWidth</code> and <code>timeBarHeight</code>. We initialize them to <code>400</code> and <code>80</code>, respectively. These variables will help us keep track of the size we need to draw <code>timeBar</code> at each frame.</p>
			<p>Next, we set the size of <code>timeBar</code> using the <code>timeBar.setSize</code> function. We don't just pass in our two new <code>float</code> variables. First, we create a new object of the <code>Vector2f</code> type. What is different here, however, is that we don't give the new object a name. Instead, we simply initialize it with our two float variables and pass it straight in to the <code>setSize</code> function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><code>Vector2f</code> is a class that holds two <code>float</code> variables. It also has some other functionality that will be introduced throughout this book.</p>
			<p>After that, we color <code>timeBar</code> red by using the <code>setFillColor</code> function.</p>
			<p>The last thing we do to <code>timeBar</code> in the previous code is set its position. The vertical coordinate is completely straightforward but the way we set the horizontal coordinate is slightly convoluted. Here is the calculation again:</p>
			<pre>(1920 / 2) - timeBarStartWidth / 2</pre>
			<p>First, the code divides 1920 by 2. Then, it divides <code>timeBarStartWidth</code> by 2. Finally, it subtracts the latter from the former.</p>
			<p>The result makes <code>timeBar</code> sit neatly and centrally, in a horizontal fashion, on the screen.</p>
			<p>The final three lines of code that we are talking about declare a new <code>Time</code> object called <code>gameTimeTotal</code>, a new <code>float</code> called <code>timeRemaining</code> that is initialized to <code>6</code>, and a curious-sounding <code>float</code> named <code>timeBarWidthPerSecond</code>, which we will discuss next.</p>
			<p>The <code>timeBarWidthPerSecond</code> variable is initialized with <code>timeBarStartWidth</code> divided by <code>timeRemaining</code>. The result is exactly the amount of pixels that <code>timeBar</code> needs to shrink by each second of the game. This will be useful when we resize <code>timeBar</code> in each frame.</p>
			<p>Obviously, we need to reset the time remaining each time the player starts a new game. The logical place to do this is when the <em class="italic">Enter</em> key is pressed. We can also set <code>score</code> back to zero at the same time. Let's do that now by adding the following highlighted code</p>
			<pre>// Start the game
if (Keyboard::isKeyPressed(Keyboard::Return))
{
    paused = false;
<strong class="bold">    // Reset the time and the score</strong>
<strong class="bold">    score = 0;</strong>
<strong class="bold">    timeRemaining = 6;</strong>
}</pre>
			<p>Now, we must reduce each frame by the amount of time remaining and resize <code>timeBar</code> accordingly. Add the following highlighted code to the update section, as shown here:</p>
			<pre>/*
****************************************
Update the scene
****************************************
*/
if (!paused)
{
    // Measure time
    Time dt = clock.restart();
<strong class="bold">    // Subtract from the amount of time remaining</strong>
<strong class="bold">    timeRemaining -= dt.asSeconds();</strong>
<strong class="bold">    // size up the time bar</strong>
<strong class="bold">    timeBar.setSize(Vector2f(timeBarWidthPerSecond *</strong>
<strong class="bold">        timeRemaining, timeBarHeight));</strong>
    // Set up the bee
    if (!beeActive)
    {
        // How fast is the bee
        srand((int)time(0) * 10);
        beeSpeed = (rand() % 200) + 200;
        // How high is the bee
        srand((int)time(0) * 10);
        float height = (rand() % 1350) + 500;
        spriteBee.setPosition(2000, height);
        beeActive = true;
    }
    else
        // Move the bee</pre>
			<p>First, we subtracted the amount of time the player has left by however long the previous frame took to execute with the following code:</p>
			<pre>timeRemaining -= dt.asSeconds();</pre>
			<p>Then, we adjusted the size of <code>timeBar</code> with the following code:</p>
			<pre>timeBar.setSize(Vector2f(timeBarWidthPerSecond *
        timeRemaining, timeBarHeight));</pre>
			<p>The x value of <code>Vector2F</code> is initialized with <code>timebarWidthPerSecond</code> when multiplied by <code>timeRemaining</code>. This produces exactly the right width, relative to how long the player has left. The height remains the same and <code>timeBarHeight</code> is used without any manipulation.</p>
			<p>And of course, we must detect when the time has run out. For now, we will simply detect that time has run out, pause the game, and change the text of <code>messageText</code>. Later, we will do more work here. Add the following highlighted code right after the previous code we added. We will look at it in more detail later:</p>
			<pre>// Measure time
Time dt = clock.restart();
// Subtract from the amount of time remaining
timeRemaining -= dt.asSeconds();
// resize up the time bar
timeBar.setSize(Vector2f(timeBarWidthPerSecond *
    timeRemaining, timeBarHeight));
<strong class="bold">if (timeRemaining&lt;= 0.0f) {</strong>
<strong class="bold">    </strong>
<strong class="bold">    // Pause the game</strong>
<strong class="bold">    paused = true;</strong>
<strong class="bold">    // Change the message shown to the player</strong>
<strong class="bold">    messageText.setString("Out of time!!");</strong>
<strong class="bold">    //Reposition the text based on its new size</strong>
<strong class="bold">    FloatRect textRect = messageText.getLocalBounds();</strong>
<strong class="bold">    messageText.setOrigin(textRect.left +</strong>
<strong class="bold">        textRect.width / 2.0f,</strong>
<strong class="bold">        textRect.top +</strong>
<strong class="bold">        textRect.height / 2.0f);</strong>
<strong class="bold">    messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);</strong>
<strong class="bold">}</strong>
// Set up the bee
if (!beeActive)
{
    // How fast is the bee
    srand((int)time(0) * 10);
    beeSpeed = (rand() % 200) + 200;
    // How high is the bee
    srand((int)time(0) * 10);
    float height = (rand() % 1350) + 500;
    spriteBee.setPosition(2000, height);
    beeActive = true;
}
else
    // Move the bee</pre>
			<p>Let's step through the previous code:</p>
			<ol>
				<li>First, we test whether time has run out with <code>if(timeRemaining&lt;= 0.0f).</code></li>
				<li>Then, we set <code>paused</code> to <code>true</code>, so this will be the last time the update part of our code is executed (until the player presses <em class="italic">Enter</em> again).</li>
				<li>Then, we change the message of <code>messageText</code>, calculate its new center to be set as its origin, and position it in the center of the screen.</li>
			</ol>
			<p>Finally, for this part of the code, we need to draw <code>timeBar</code>. There is nothing new in this code that we haven't seen many times before. Just note that we draw <code>timeBar</code> after the tree so that it is not partially obscured. Add the following highlighted code to draw the time-bar:</p>
			<pre>// Draw the score
window.draw(scoreText);
<strong class="bold">// Draw the timebar</strong>
<strong class="bold">window.draw(timeBar);</strong>
if (paused)
{
    // Draw our message
    window.draw(messageText);
}
// Show everything we just drew
window.display();</pre>
			<p>Now, you can run the game, press <em class="italic">Enter</em> to start it, and watch the time-bar smoothly disappear down to nothing:</p>
			<div><div><img src="img/Image85176.jpg" alt=""/>
				</div>
			</div>
			<p>The game then pauses and the <strong class="bold">OUT OF TIME!! </strong>message will appear in the center of the screen:</p>
			<div><div><img src="img/B14278_03_04.jpg" alt=""/>
				</div>
			</div>
			<p>You can, of course, press <em class="italic">Enter</em> to start the game again and watch it run from the beginning.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>Summary</h1>
			<p>In this chapter, we learned about Strings, SFML <code>Text</code>, and SFML <code>Font</code>. Between them, they allowed us to draw text to the screen, which provided the player with a HUD. We also used <code>sstream</code>, which allows us to concatenate Strings and other variables to display the score.</p>
			<p>We also explored the SFML <code>RectangleShape</code> class, which does exactly what its name suggests. We used an object of the <code>RectangleShape</code> type and some carefully planned variables to draw a time-bar that visually displays to the player how much time they have left. Once we implement chopping and moving branches that can squash the player, the time-bar will provide visual feedback that will create tension and urgency.</p>
			<p>In the next chapter, we are going to learn about a whole range of new C++ features, including loops, arrays, switching, enumerations, and functions. This will allow us to move tree branches, keep track of their locations, and squash the player.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>FAQ</h1>
			<p>Q) I can foresee that positioning sprites by their top-left corner could sometimes be inconvenient. Is there an alternative?</p>
			<p>A) Fortunately, you can choose what point of a sprite is used as the positioning/origin pixel, just like we did with <code>messageText</code>, using the <code>setOrigin</code> function.</p>
			<p>Q) The code is getting rather long and I am struggling to keep track of where everything is. How can we fix this?</p>
			<p>A) Yes, I agree. In the next chapter, we will look at the first of a few ways we can organize our code and make it more readable. We will look at this when we learn about writing C++ functions. In addition, we will learn about a new way we can handle multiple objects/variables of the same type (like the clouds) when we learn about C++ arrays.</p>
		</div>
	</body></html>