<html><head></head><body>
		<div><h1 id="_idParaDest-498" class="chapter-number"><a id="_idTextAnchor498"/>11</h1>
			<h1 id="_idParaDest-499"><a id="_idTextAnchor499"/>Fundamental Algorithms  and Searching</h1>
			<p>This chapter covers some of the most crucial and commonly used C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) algorithms. The chapter equips readers with the knowledge and skills to manipulate and analyze data effectively by focusing on sorting, conditional checks, finding, and searching techniques. Understanding these fundamental algorithms is paramount for developers keen on ensuring efficient and robust applications. The chapter also emphasizes best practices, ensuring code is correct and optimized.</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Sorting</li>
				<li>Checking conditions</li>
				<li>Counting and finding</li>
				<li>Searching and comparison</li>
				<li>Best practices</li>
			</ul>
			<h1 id="_idParaDest-500"><a id="_idTextAnchor500"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-501"><a id="_idTextAnchor501"/>Sorting</h1>
			<p><strong class="bold">Sorting</strong> is a <a id="_idIndexMarker742"/>fundamental concept every programmer encounters, yet it is not just about ordering elements. It’s about optimization, understanding the nature of your data, and selecting the right approach to arrange that data meaningfully. The vast toolkit of the C++ STL has a rich array of sorting algorithms tailored to various scenarios and datasets. But how do you choose? How do you effectively wield these tools for optimal results? Let’s embark on this enlightening journey together.</p>
			<p>To begin with, why do we sort? Sorting makes data aesthetically appealing and paves the way for efficient searching, data analysis, and optimized data structures. Whether it is sorting names in an address book or products by price in an online store, the act of sorting is deeply woven into the fabric of computing.</p>
			<p>The STL provides a<a id="_idIndexMarker743"/> primary sorting function: <code>std::sort</code>. This function is versatile and can sort almost any sequence of elements, from arrays to vectors. Under the hood, <code>std::sort</code> is typically implemented using an introsort, a hybrid sorting algorithm that combines quicksort, heapsort, and insertion sort, ensuring speed and adaptability. Here’s a simple example of <code>std::sort</code>:</p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {5, 3, 8, 1, 4};
std::sort(numbers.begin(), numbers.end());</pre>			<p>But sorting isn’t always about ascending order or numbers. With <code>std::sort</code>, custom comparators allow you to define the order. Imagine you have a list of products and want to sort them by their names in descending order. You can do it in the following manner:</p>
			<pre class="source-code">
std::sort(products.begin(), products.end(), [](const Product&amp; a, const Product&amp; b) {
    return a.name &gt; b.name;
});</pre>			<p>It’s not just about regular sorting. When you have almost sorted data, <code>std::partial_sort</code> comes to the rescue. This function sorts a range so that a particular subrange is sorted. Say you want to find the top three students by their score; <code>std::partial_sort</code> can make this task efficient.</p>
			<p>However, knowing the algorithm is only half the battle; understanding when to use which function is critical. If you aim to sort a list of a million numbers, <code>std::sort</code> is your best friend. But if you’re dealing with a smaller dataset where you must maintain the original order of equal elements, <code>std::stable_sort</code> is a more suitable option.</p>
			<p>There are also niche sorting functions tailored for specific scenarios. For instance, when dealing with large datasets where you’re interested in a subset of sorted data, <code>std::nth_element</code> is a fantastic tool. It rearranges elements such that the element at the nth position is the one that would be in that position in a sorted sequence.</p>
			<p>Selecting the<a id="_idIndexMarker744"/> suitable algorithm also involves understanding the nature of your data. If you have a smaller dataset or a nearly sorted list, insertion sort might be your best bet. On the other hand, for larger datasets, more advanced algorithms such as mergesort or quicksort are more fitting. Knowing the underlying mechanics of these algorithms and their performance metrics helps make informed decisions.</p>
			<p>Sorting in the STL is not just about arranging data but choosing the optimal way. It’s a dance of understanding your data, the nature of your application, and the tools at your disposal. Next, we will learn how to check various conditions on our sorted data.</p>
			<h1 id="_idParaDest-502"><a id="_idTextAnchor502"/>Checking conditions</h1>
			<p>The elegance<a id="_idIndexMarker745"/> of the C++ STL doesn’t just lie in its vast assortment of containers and algorithms. It also resides in its fine-tuned ability to let developers efficiently check and validate data using condition-based operations. With the might of predicate functions, these operations empower programmers to answer questions such as <em class="italic">Does this dataset hold a particular property?</em> and <em class="italic">Are all elements in this </em><em class="italic">range positive?</em></p>
			<p>One of the most intuitive and fundamental operations is <code>std::all_of</code>. With this algorithm, you can check if all elements in a range satisfy a given predicate.  If you had a list of students’ grades, you could use <code>std::all_of</code> to see if all grades were positive (and they should be!).</p>
			<p>By contrast, its counterpart <code>std::none_of</code> checks if none of the elements in a range satisfy a given predicate. Let’s say you’re working with a list of student grades and want to ensure that no one has scored below passing marks. In this case, <code>std::none_of</code> becomes an invaluable asset.</p>
			<p>Rounding up the trio is <code>std::any_of</code>, which checks if at least one element in a sequence meets a specific condition. This becomes particularly handy in scenarios where you’re looking for the existence of a condition, such as finding if any grades are As (&gt;= 90).</p>
			<p>Let’s look at a code example illustrating the usage of <code>std::all_of</code>, <code>std::none_of</code>, and <code>std::any_of</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; grades = {85, 90, 78, 92,
                             88, 76, 95, 89};
  if (std::all_of(grades.begin(), grades.end(),
                  [](int grade) { return grade &gt; 0; })) {
    std::cout &lt;&lt; "All students have positive grades.\n";
  } else {
    std::cout &lt;&lt; "Not all grades are positive.\n";
  }
  if (std::none_of(grades.begin(), grades.end(),
                   [](int grade) { return grade &lt; 80; })) {
    std::cout
        &lt;&lt; "No student has scored below passing marks.\n";
  } else {
    std::cout &lt;&lt; "There are students who scored below "
                 "passing marks.\n";
  }
  if (std::any_of(grades.begin(), grades.end(),
                  [](int grade) { return grade &gt;= 95; })) {
    std::cout &lt;&lt; "There's at least one student with an "
                 "'exceptional' grade.\n";
  } else {
    std::cout
        &lt;&lt; "No student has an 'exceptional' grade.\n";
  }
  return 0;
}</pre>			<p>Here’s the example output:</p>
			<pre class="console">
All students have positive grades.
There are students who scored below passing marks.
There's at least one student with an 'exceptional' grade.</pre>			<p>In this <a id="_idIndexMarker746"/>example, we’ve used a set of student grades as our dataset. We use the described algorithms to check if all grades are positive, if no student scored below passing marks (considered 80 in this case), and if there’s at least one student who achieved an <em class="italic">exceptional</em> grade (90 or above).</p>
			<p>Moving beyond these fundamental checks, there are more specialized algorithms such as <code>std::is_sorted</code>, which, as the name suggests, verifies if a range is sorted. For instance, with a dataset of product prices, this function quickly checks if the sequence is in ascending order, ensuring integrity before performing other operations.</p>
			<p>Another intriguing algorithm is <code>std::is_partitioned</code>. Imagine you have a mixed data collection, and you’ve used some criteria to partition it, such as dividing numbers into even and odd. This algorithm checks if such a partitioning exists in a sequence based on a predicate.</p>
			<p>While these functions offer direct ways to validate data, sometimes the need is more nuanced. Consider the situation where you want to compare two sequences to check if they’re permutations of each other. The STL offers <code>std::is_permutation</code> for this very purpose. Whether it is strings, numbers, or custom objects, this function can ascertain if one sequence is a reordering of another.</p>
			<p>Let’s use a dataset of product <a id="_idIndexMarker747"/>prices to demonstrate the use of <code>std::is_permutation</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;double&gt; prices = {5.99, 10.49, 20.89, 25.55,
                                30.10};
  if (std::is_sorted(prices.begin(), prices.end())) {
    std::cout &lt;&lt; "The product prices are sorted in"
                 "ascending order.\n";
  } else {
    std::cout &lt;&lt; "The product prices are not sorted.\n";
  }
  auto partitionPoint = std::partition(
      prices.begin(), prices.end(),
      [](double price) { return price &lt; 20.0; });
  if (std::is_partitioned(
          prices.begin(), prices.end(),
          [](double price) { return price &lt; 20.0; })) {
    std::cout &lt;&lt; "Prices are partitioned with prices less "
                 "than $20 first.\n";
  } else {
    std::cout &lt;&lt; "Prices are not partitioned based on the "
                 "given criteria.\n";
  }
  std::vector&lt;double&gt; shuffledPrices = {25.55, 5.99, 30.10,
                                        10.49, 20.89};
  // Using std::is_permutation to ascertain if
  // shuffledPrices is a reordering of prices
  if (std::is_permutation(prices.begin(), prices.end(),
                          shuffledPrices.begin())) {
    std::cout
        &lt;&lt; "Sequences are permutations of each other.\n";
  } else {
    std::cout &lt;&lt; "Sequences are not permutations of each "
                 "other.\n";
  }
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker748"/>example output:</p>
			<pre class="console">
The product prices are sorted in ascending order.
Prices are partitioned with prices less than $20 first.
Sequences are permutations of each other.</pre>			<p>In this example, we’ve used the described algorithms on a dataset of product prices. The prices are first checked to see if they’re sorted. Then, they’re partitioned based on a price criterion. Finally, we verify if two sequences of prices are permutations of each other.</p>
			<p>Utilizing these <a id="_idIndexMarker749"/>condition-checking functions isn’t just about invoking them on datasets. True power comes from crafting meaningful predicates. By harnessing the capabilities of lambdas or functor objects, you can design intricate conditions that precisely capture your requirements. Whether checking the validity of user inputs, validating data before processing, or ensuring the sanctity of results post-processing, predicate-based functions are your trusty tools.</p>
			<p>But like any powerful toolkit, these functions must be used judiciously. Over-relying on checks can lead to performance overhead, especially on large datasets. Striking a balance between validation and performance is crucial. Often, understanding the nature of your data and the broader context of the application can guide you in efficiently using these algorithms.</p>
			<p>In wrapping up this exploration of condition-checking algorithms, it is evident that they form an essential part of the STL’s algorithmic suite. They provide a robust foundation upon which more advanced operations can be built. As we journey ahead, you’ll see how these foundational checks intertwine with other algorithms, such as counting and finding, painting a holistic picture of data processing in the captivating world of C++.</p>
			<h1 id="_idParaDest-503"><a id="_idTextAnchor503"/>Counting and finding</h1>
			<p>In the data we deal with daily, managing or validating the data and actively searching, locating, and quantifying specific elements or patterns within it often becomes essential. The STL equips developers with a treasure trove of precise algorithms for counting and finding.</p>
			<p>Let’s start <a id="_idIndexMarker750"/>with the simple yet powerful <code>std::count</code> and its twin <code>std::count_if</code>. While <code>std::count</code> can swiftly tell you how many times a specific value appears in a range, <code>std::count_if</code> takes it up a notch, letting you count occurrences based on a predicate. Imagine you have a collection of student marks and wish to find out how many scored above 90. With <code>std::count_if</code>, it’s a cakewalk, as shown here:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; grades = {85, 90, 78, 92,
                             88, 76, 95, 89};
  const auto exact_count =
      std::count(grades.begin(), grades.end(), 90);
  std::cout &lt;&lt; "Number of students who scored exactly 90:"
            &lt;&lt; exact_count &lt;&lt; "\n";
  const auto above_count =
      std::count_if(grades.begin(), grades.end(),
                    [](int grade) { return grade &gt; 90; });
  std::cout &lt;&lt; "Number of students who scored above 90:"
            &lt;&lt; above_count &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here’s <a id="_idIndexMarker751"/>the example output:</p>
			<pre class="console">
Number of students who scored exactly 90: 1
Number of students who scored above 90: 2</pre>			<p>Here, we have utilized <code>std::count</code> to check the number of students who scored precisely 90 and then employed <code>std::count_if</code> to count the students scoring above 90.</p>
			<p>Beyond just counting, sometimes the goal is to locate a specific element. This is where <code>std::find</code> and <code>std::find_if</code> come into play. In comparison, <code>std::find </code>looks for an exact match, and <code>std::find_if</code> searches based on a predicate. For those times when you’re eager to know the position of the first element that meets a condition, these functions are your go-to.</p>
			<p>Yet, life isn’t always about the first match. Occasionally, it is the last match that matters. In such <a id="_idIndexMarker752"/>scenarios, <code>std::find_end</code> proves invaluable. Especially useful in situations such as locating the last occurrence of a subsequence within a larger sequence, this function ensures you don’t miss out on the nuances in your data.</p>
			<p>Let’s look at a code example using <code>std::list</code> containing a structure of student names and grades. We’ll then use <code>std::find_if</code> and <code>std::find_end</code> to locate students based on their grades, as demonstrated here:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
struct Student {
  std::string name;
  int grade{0};
  Student(std::string n, int g) : name(n), grade(g) {}
};
int main() {
  std::list&lt;Student&gt; students = {
      {"Lisa", 85},   {"Corbin", 92}, {"Aaron", 87},
      {"Daniel", 92}, {"Mandy", 78},  {"Regan", 92},
  };
  auto first_92 = std::find_if(
      students.begin(), students.end(),
      [](const Student &amp;s) { return s.grade == 92; });
  if (first_92 != students.end()) {
    std::cout &lt;&lt; first_92-&gt;name
              &lt;&lt; "was the first to score 92.\n";
  }
  std::list&lt;Student&gt; searchFor = {{"", 92}};
  auto last_92 = std::find_end(
      students.begin(), students.end(), searchFor.begin(),
      searchFor.end(),
      [](const Student &amp;s, const Student &amp;value) {
        return s.grade == value.grade;
      });
  if (last_92 != students.end()) {
    std::cout &lt;&lt; last_92-&gt;name
              &lt;&lt; "was the last to score 92.\n";
  }
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker753"/>example output:</p>
			<pre class="console">
Corbin was the first to score 92.
Regan was the last to score 92.</pre>			<p>In this example, we use <code>std::find_if</code> to find the first student who scored 92. Then, we use <code>std::find_end</code> to find the last student who scored 92. The <code>std::find_end</code> function is a bit tricky in this case because it is meant for finding subsequences, but by providing it with a single-element list (which acts as our <em class="italic">subsequence</em>), we can still use it to find the last occurrence of a particular grade.</p>
			<p>For those <a id="_idIndexMarker754"/>who work with sorted data, STL doesn’t disappoint. With <code>std::lower_bound</code> and <code>std::upper_bound</code>, you can efficiently find the beginning and end of a range of values equal to a given value in a sorted sequence. Furthermore, <code>std::binary_search</code> lets you quickly ascertain if an element exists in the sorted range. Remember, these functions capitalize on the sorted nature of the data, making them considerably faster than their generic counterparts.</p>
			<p>Let’s define a <code>Student</code> structure and use a <code>std::set</code> of <code>Student</code> objects. We’ll modify the comparison operators to sort based on grades as follows:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
struct Student {
  std::string name;
  int grade{0};
  bool operator&lt;(const Student &amp;other) const {
    return grade &lt; other.grade; // Sorting based on grade
  }
};
int main() {
  std::set&lt;Student&gt; students = {
      {"Amanda", 68},  {"Claire", 72}, {"Aaron", 85},
      {"William", 85}, {"April", 92},  {"Bryan", 96},
      {"Chelsea", 98}};
  Student searchStudent{"", 85};
  const auto lb = std::lower_bound(
      students.begin(), students.end(), searchStudent);
  if (lb != students.end() &amp;&amp; lb-&gt;grade == 85) {
    std::cout
        &lt;&lt; lb-&gt;name
        &lt;&lt; " is the first student with a grade of 85.\n";
  }
  const auto ub = std::upper_bound(
      students.begin(), students.end(), searchStudent);
  if (ub != students.end()) {
    std::cout &lt;&lt; ub-&gt;name
              &lt;&lt; " is the next student after the last one "
                 "with a grade of 85, with a grade of "
              &lt;&lt; ub-&gt;grade &lt;&lt; ".\n";
  }
  if (std::binary_search(students.begin(), students.end(),
                         searchStudent)) {
    std::cout &lt;&lt; "There's at least one student with a "
                 "grade of 85.\n";
  } else {
    std::cout &lt;&lt; "No student has scored an 85.\n";
  }
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker755"/>example output:</p>
			<pre class="console">
Aaron is the first student with a grade of 85.
April is the next student after the last one with a grade of 85, with a grade of 92.
There's at least one student with a grade of 85.</pre>			<p>In this example, <code>Student</code> structures are sorted in <code>std::set</code> based on their grades. The names are then used in the output.</p>
			<p>Speaking of speed, the adjacency algorithms – <code>std::adjacent_find</code> being a prime example – allow for the rapid location of consecutive duplicates in a sequence. Imagine a sensor sending data, and you wish to identify if there are back-to-back duplicate readings quickly. This function is your go-to solution.</p>
			<p>Let’s look at an example of a <code>std::list</code> of structures where each entry has a sensor reading (a temperature) and the time it was taken:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
struct SensorData {
  int temperature{0};
  std::chrono::system_clock::time_point timestamp;
};
int main() {
  const auto now = std::chrono::system_clock::now();
  std::list&lt;SensorData&gt; sensorReadings = {
      {72, now - std::chrono::hours(10)},
      {73, now - std::chrono::hours(9)},
      {75, now - std::chrono::hours(8)},
      {75, now - std::chrono::hours(7)},
      {76, now - std::chrono::hours(6)},
      {78, now - std::chrono::hours(5)},
      {78, now - std::chrono::hours(4)},
      {79, now - std::chrono::hours(3)},
      {80, now - std::chrono::hours(2)},
      {81, now - std::chrono::hours(1)}};
  auto it = sensorReadings.begin();
  while (it != sensorReadings.end()) {
    it = std::adjacent_find(
        it, sensorReadings.end(),
        [](const SensorData &amp;a, const SensorData &amp;b) {
          return a.temperature == b.temperature;
        });
    if (it != sensorReadings.end()) {
      int duplicateValue = it-&gt;temperature;
      std::cout &lt;&lt; "Found consecutive duplicate readings "
                   "of value: "
                &lt;&lt; duplicateValue
                &lt;&lt; " taken at the following times:\n";
      while (it != sensorReadings.end() &amp;&amp;
             it-&gt;temperature == duplicateValue) {
        const auto time =
            std::chrono::system_clock::to_time_t(
                it-&gt;timestamp);
        std::cout &lt;&lt; "\t"
                  &lt;&lt; std::put_time(std::localtime(&amp;time),
                                   "%Y-%m-%d %H:%M:%S\n");
        ++it;
      }
    }
  }
  return 0;
}</pre>			<p>In this<a id="_idIndexMarker756"/> example, each <code>SensorData</code> structure contains a temperature and its recorded timestamp. We’re using <code>std::adjacent_find</code> with a custom comparator to check for back-to-back duplicate temperature readings. When we find such a reading, we display the time the reading was taken and the temperature value.</p>
			<p>Here’s the example output:</p>
			<pre class="console">
Found consecutive duplicate readings of value: 75 taken at the following times:
    2099-10-01 03:14:51
    2099-10-01 04:14:51
Found consecutive duplicate readings of value: 78 taken at the following times:
    2099-10-01 06:14:51
    2099-10-01 07:14:51</pre>			<p>As with all tools, understanding when and how to use these algorithms is pivotal. While it might be tempting to employ binary searches frequently due to their speed, they’re only applicable to sorted data. Otherwise, using them might lead to incorrect results. Similarly, while counting occurrences might seem straightforward, using the correct counting function, depending on whether you have a specific value or a condition, can significantly affect your program’s clarity and efficiency.</p>
			<p>Given all of the options for data handling in C++, counting and finding are foundational and complex. They pave the way for more advanced operations, and a mastery over them ensures you’re well on your way to becoming adept at handling even the most complex data scenarios. Given our sorted data, we can expand our toolset further by examining efficient searching and comparison with the STL.</p>
			<h1 id="_idParaDest-504"><a id="_idTextAnchor504"/>Searching and comparison</h1>
			<p>Searching<a id="_idIndexMarker757"/> through data is a common yet crucial operation that most software requires. Whether you’re trying to retrieve specific user details from a database or find a book’s position in a sorted list, a robust search technique is paramount. With<a id="_idIndexMarker758"/> its plethora of algorithms, the STL offers several methods to search through sequences efficiently. Moreover, the library provides intuitive ways to compare sequences and retrieve extreme values, making data analysis more streamlined.</p>
			<p>When working with sorted data, <code>std::binary_search</code> is a power player. It’s a testament to the importance of keeping data sorted wherever feasible. By repeatedly dividing the dataset in half, it locates the desired element, making it an exceptionally speedy tool. However, this is merely a boolean operation; it informs if the element exists, but not where it exists. For that, we lean on <code>std::lower_bound</code> and <code>std::upper_bound</code>. These functions retrieve iterators pointing to the first occurrence and just past the last occurrence of an element. Combining these two can give a range representing all instances of a value in a sorted sequence.</p>
			<p>Yet, not all data is sorted, and not all searches are for exact matches. The STL doesn’t leave you in the lurch. Functions such as <code>std::find</code> and <code>std::find_if</code> shine in these situations, providing flexibility to search based on actual values or predicates.</p>
			<p>After searching, a natural progression is comparing elements. Often, we need to determine if one sequence is lexicographically less than, greater than, or equal to another. This is where <code>std::lexicographical_compare</code> steps in, allowing you to compare two sequences like dictionary ordering. It’s a must-have when working with strings or custom data types, ensuring you can quickly sort and rank data as required.</p>
			<p>Here’s an example to demonstrate the use of <code>std::lexicographical_compare</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;char&gt; seq1 = {'a', 'b', 'c'};
  std::vector&lt;char&gt; seq2 = {'a', 'b', 'd'};
  std::vector&lt;char&gt; seq3 = {'a', 'b', 'c', 'd'};
  if (std::lexicographical_compare(
          seq1.begin(), seq1.end(), seq2.begin(),
          seq2.end())) {
    std::cout &lt;&lt; "Sequence 1 is lexicographically less"
                 "than Sequence 2"
              &lt;&lt; "\n";
  } else {
    std::cout
        &lt;&lt; "Sequence 1 is not lexicographically less"
           "than Sequence 2"
        &lt;&lt; "\n";
  }
  if (std::lexicographical_compare(
          seq1.begin(), seq1.end(), seq3.begin(),
          seq3.end())) {
    std::cout &lt;&lt; "Sequence 1 is lexicographically less"
                 "than Sequence 3"
              &lt;&lt; "\n";
  } else {
    std::cout
        &lt;&lt; "Sequence 1 is not lexicographically less"
           "than Sequence 3"
        &lt;&lt; "\n";
  }
  // For strings
  std::string str1 = "apple";
  std::string str2 = "banana";
  if (std::lexicographical_compare(
          str1.begin(), str1.end(), str2.begin(),
          str2.end())) {
    std::cout &lt;&lt; "String 1 (apple) is lexicographically "
                 "less than String 2 (banana)"
              &lt;&lt; "\n";
  } else {
    std::cout &lt;&lt; "String 1 (apple) is not "
                 "lexicographically less "
                 "than String 2 (banana)"
              &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker759"/>example <a id="_idIndexMarker760"/>output:</p>
			<pre class="console">
Sequence 1 is lexicographically less than Sequence 2
Sequence 1 is lexicographically less than Sequence 3
String 1 (apple) is lexicographically less than String 2 (banana)</pre>			<p>This demonstrates how <code>std::lexicographical_compare</code> can be used to determine the relative ordering of two sequences.</p>
			<p>But what if you’re only <a id="_idIndexMarker761"/>interested in the extremes? Perhaps you want to find the highest score in an exam or the lowest price in a list of products. Here, <code>std::max_element </code>and <code>std::min_element</code> are your stalwarts. They return iterators <a id="_idIndexMarker762"/>pointing to the maximum and minimum elements, respectively. If you’re looking for both, <code>std::minmax_element</code> does the trick, giving you a pair of iterators in one go:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; scores = {85, 93, 78, 90, 96, 82};
  const auto max_it =
      std::max_element(scores.begin(), scores.end());
  if (max_it != scores.end()) {
    std::cout &lt;&lt; "The highest score is: "&lt;&lt; *max_it
              &lt;&lt; "\n";
  }
  const auto min_it =
      std::min_element(scores.begin(), scores.end());
  if (min_it != scores.end()) {
    std::cout &lt;&lt; "The lowest score is: "&lt;&lt; *min_it
              &lt;&lt; "\n";
  }
  const auto minmax =
      std::minmax_element(scores.begin(), scores.end());
  if (minmax.first != scores.end() &amp;&amp;
      minmax.second != scores.end()) {
    std::cout &lt;&lt; "The lowest and highest scores are: "
              &lt;&lt; *minmax.first &lt;&lt; " and " &lt;&lt; *minmax.second
              &lt;&lt; ", respectively.\n";
  }
  std::vector&lt;double&gt; productPrices = {99.99, 79.99, 49.99,
                                       59.99, 89.99};
  // Find the minimum and maximum prices
  auto minmaxPrices = std::minmax_element(
      productPrices.begin(), productPrices.end());
  if (minmaxPrices.first != productPrices.end() &amp;&amp;
      minmaxPrices.second != productPrices.end()) {
    std::cout
        &lt;&lt; "The cheapest and priciest products cost: $"
        &lt;&lt; *minmaxPrices.first &lt;&lt; " and $"
        &lt;&lt; *minmaxPrices.second &lt;&lt; ", respectively.\n";
  }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker763"/>example output:</p>
			<pre class="console">
The highest score is: 96
The lowest score is: 78
The lowest and highest scores are: 78 and 96, respectively.
The cheapest and priciest products cost: $49.99 and $99.99, respectively.</pre>			<p>This demonstrates using <code>std::max_element</code>, <code>std::min_element</code>, and <code>std::minmax_element</code> to find the extreme values in sequences.</p>
			<p>To wrap up, the <a id="_idIndexMarker764"/>power of searching and comparison in STL isn’t just in the breadth of its functions but in its adaptability. With iterators and predicates, these algorithms are remarkably versatile, ensuring you can adapt them to various scenarios. As developers, these tools become extensions of our thinking, guiding us toward efficient and elegant solutions. As we progress further, remember these operations form the foundation for more advanced techniques and best practices, fortifying our capabilities in data handling and algorithmic problem-solving in C++.</p>
			<h1 id="_idParaDest-505"><a id="_idTextAnchor505"/>Best practices</h1>
			<p>The elegance of the C++ STL lies in its vast array of utilities and its potential for optimization. However, merely knowing the algorithms isn’t the endgame. How you use them, combine them, and make subtle decisions can spell the difference between an efficient program and a sluggish one. So, let’s delve into the best practices, ensuring that your forays into STL are correct and performed at peak efficiency:</p>
			<ul>
				<li><code>std::binary_search</code> on a mostly sorted array may be counterproductive when <code>std::find</code> can serve the purpose with less overhead.</li>
				<li><code>std::set</code> and <code>std::map</code>, have inherent advantages in searching and inserting elements. However, they can also lead to pitfalls. Continuously adding elements to such containers may not be efficient, and sometimes, batch insertions followed by a sort operation can be more optimal.</li>
				<li><code>std::vector</code>, using the <code>reserve</code> method, it is crucial to have a fair estimate of the size and reserve the memory upfront. This way, as you call <code>push_back</code> to add elements, the vector does not have to reallocate memory frequently, offering a significant performance boost.</li>
				<li><code>std::count_if</code> and <code>std::find_if</code> allow custom conditions to be set, making them flexible and adaptable to a broader range of scenarios than their non-predicate counterparts. Moreover, lambdas in C++11 and beyond have made using these algorithms even more concise and expressive.</li>
				<li><strong class="bold">Be wary of algorithmic complexity</strong>: While the STL provides tools, it does not change the fundamental nature of algorithms. A linear search will always be linear, and a binary search will be logarithmic. Recognize the complexity of your algorithm and question whether that’s the best for your application’s requirements.</li>
				<li><code>std::array</code>, which are stack-allocated, can be faster to access than their heap-allocated counterparts due to cache locality. However, this comes with the trade-off of fixed sizes. Hence, understanding the memory requirements beforehand can help strike the right balance.</li>
				<li><code>std::vector</code>, can invalidate iterators, leading to undefined behavior.</li>
				<li><strong class="bold">Benchmark and profile</strong>: Assumptions and best practices are starting points, but real performance metrics come from profiling your application. Tools such as gprof, Valgrind, and Celero can be invaluable in highlighting bottlenecks and guiding you toward the right optimizations. These best practices outline how to optimize C++ STL usage, emphasizing the importance of understanding the nature of data, leveraging sorted data structures, avoiding unnecessary memory reallocations, preferring algorithms with predicate versions, being aware of algorithmic complexity, choosing stack over heap allocation when appropriate, using iterators judiciously, and the significance of benchmarking and profiling to identify performance bottlenecks. They underscore that while STL offers powerful utilities, efficient programming depends on how these tools are employed and combined.</li>
			</ul>
			<h1 id="_idParaDest-506"><a id="_idTextAnchor506"/>Summary</h1>
			<p>In this chapter, we have thoroughly examined the core algorithms that operate on STL containers and their role in efficient C++ programming. We began by exploring the essentials of sorting algorithms and understanding how they organize data for better accessibility and performance. We then delved into various methods for checking container conditions and techniques for counting and finding elements, which are vital for data analysis and manipulation.</p>
			<p>This chapter has armed you with strategies for effectively searching and comparing elements. We also focused on best practices that ensure these operations are performed with optimal efficiency and minimal error.</p>
			<p>This knowledge has provided a foundation for implementing complex algorithms and performing data manipulations and everyday tasks in intermediate to advanced C++ development.</p>
			<p>In the next chapter, we will extend our understanding of algorithms further. We will learn about copying and moving semantics within STL containers, <strong class="bold">Return Value Optimization</strong> (<strong class="bold">RVO</strong>), and techniques for filling, generating, removing, and replacing elements. Additionally, we will explore the nuances of swapping and reversing elements and conclude with deduplication and sampling strategies. These topics will contribute to a holistic understanding of data manipulation and transformation.</p>
		</div>
	</body></html>