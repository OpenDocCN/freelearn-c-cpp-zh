<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-498" class="chapter-number"><a id="_idTextAnchor498"/>11</h1>
			<h1 id="_idParaDest-499"><a id="_idTextAnchor499"/>Fundamental Algorithms  and Searching</h1>
			<p>This chapter covers some of the most crucial and commonly used C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) algorithms. The chapter equips readers with the knowledge and skills to manipulate and analyze data effectively by focusing on sorting, conditional checks, finding, and searching techniques. Understanding these fundamental algorithms is paramount for developers keen on ensuring efficient and robust applications. The chapter also emphasizes best practices, ensuring code is correct <span class="No-Break">and optimized.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Sorting</span></li>
				<li><span class="No-Break">Checking conditions</span></li>
				<li>Counting <span class="No-Break">and finding</span></li>
				<li>Searching <span class="No-Break">and comparison</span></li>
				<li><span class="No-Break">Best practices</span></li>
			</ul>
			<h1 id="_idParaDest-500"><a id="_idTextAnchor500"/>Technical requirements</h1>
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-501"><a id="_idTextAnchor501"/>Sorting</h1>
			<p><strong class="bold">Sorting</strong> is a <a id="_idIndexMarker742"/>fundamental concept every programmer encounters, yet it is not just about ordering elements. It’s about optimization, understanding the nature of your data, and selecting the right approach to arrange that data meaningfully. The vast toolkit of the C++ STL has a rich array of sorting algorithms tailored to various scenarios and datasets. But how do you choose? How do you effectively wield these tools for optimal results? Let’s embark on this enlightening <span class="No-Break">journey together.</span></p>
			<p>To begin with, why do we sort? Sorting makes data aesthetically appealing and paves the way for efficient searching, data analysis, and optimized data structures. Whether it is sorting names in an address book or products by price in an online store, the act of sorting is deeply woven into the fabric <span class="No-Break">of computing.</span></p>
			<p>The STL provides a<a id="_idIndexMarker743"/> primary sorting function: <strong class="source-inline">std::sort</strong>. This function is versatile and can sort almost any sequence of elements, from arrays to vectors. Under the hood, <strong class="source-inline">std::sort</strong> is typically implemented using an introsort, a hybrid sorting algorithm that combines quicksort, heapsort, and insertion sort, ensuring speed and adaptability. Here’s a simple example <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::sort</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {5, 3, 8, 1, 4};
std::sort(numbers.begin(), numbers.end());</pre>			<p>But sorting isn’t always about ascending order or numbers. With <strong class="source-inline">std::sort</strong>, custom comparators allow you to define the order. Imagine you have a list of products and want to sort them by their names in descending order. You can do it in the <span class="No-Break">following manner:</span></p>
			<pre class="source-code">
std::sort(products.begin(), products.end(), [](const Product&amp; a, const Product&amp; b) {
    return a.name &gt; b.name;
});</pre>			<p>It’s not just about regular sorting. When you have almost sorted data, <strong class="source-inline">std::partial_sort</strong> comes to the rescue. This function sorts a range so that a particular subrange is sorted. Say you want to find the top three students by their score; <strong class="source-inline">std::partial_sort</strong> can make this <span class="No-Break">task efficient.</span></p>
			<p>However, knowing the algorithm is only half the battle; understanding when to use which function is critical. If you aim to sort a list of a million numbers, <strong class="source-inline">std::sort</strong> is your best friend. But if you’re dealing with a smaller dataset where you must maintain the original order of equal elements, <strong class="source-inline">std::stable_sort</strong> is a more <span class="No-Break">suitable option.</span></p>
			<p>There are also niche sorting functions tailored for specific scenarios. For instance, when dealing with large datasets where you’re interested in a subset of sorted data, <strong class="source-inline">std::nth_element</strong> is a fantastic tool. It rearranges elements such that the element at the nth position is the one that would be in that position in a <span class="No-Break">sorted sequence.</span></p>
			<p>Selecting the<a id="_idIndexMarker744"/> suitable algorithm also involves understanding the nature of your data. If you have a smaller dataset or a nearly sorted list, insertion sort might be your best bet. On the other hand, for larger datasets, more advanced algorithms such as mergesort or quicksort are more fitting. Knowing the underlying mechanics of these algorithms and their performance metrics helps make <span class="No-Break">informed decisions.</span></p>
			<p>Sorting in the STL is not just about arranging data but choosing the optimal way. It’s a dance of understanding your data, the nature of your application, and the tools at your disposal. Next, we will learn how to check various conditions on our <span class="No-Break">sorted data.</span></p>
			<h1 id="_idParaDest-502"><a id="_idTextAnchor502"/>Checking conditions</h1>
			<p>The elegance<a id="_idIndexMarker745"/> of the C++ STL doesn’t just lie in its vast assortment of containers and algorithms. It also resides in its fine-tuned ability to let developers efficiently check and validate data using condition-based operations. With the might of predicate functions, these operations empower programmers to answer questions such as <em class="italic">Does this dataset hold a particular property?</em> and <em class="italic">Are all elements in this </em><span class="No-Break"><em class="italic">range positive?</em></span></p>
			<p>One of the most intuitive and fundamental operations is <strong class="source-inline">std::all_of</strong>. With this algorithm, you can check if all elements in a range satisfy a given predicate.  If you had a list of students’ grades, you could use <strong class="source-inline">std::all_of</strong> to see if all grades were positive (and they <span class="No-Break">should be!).</span></p>
			<p>By contrast, its counterpart <strong class="source-inline">std::none_of</strong> checks if none of the elements in a range satisfy a given predicate. Let’s say you’re working with a list of student grades and want to ensure that no one has scored below passing marks. In this case, <strong class="source-inline">std::none_of</strong> becomes an <span class="No-Break">invaluable asset.</span></p>
			<p>Rounding up the trio is <strong class="source-inline">std::any_of</strong>, which checks if at least one element in a sequence meets a specific condition. This becomes particularly handy in scenarios where you’re looking for the existence of a condition, such as finding if any grades are As (&gt;= <span class="No-Break">90).</span></p>
			<p>Let’s look at a code example illustrating the usage of <strong class="source-inline">std::all_of</strong>, <strong class="source-inline">std::none_of</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">std::any_of</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; grades = {85, 90, 78, 92,
                             88, 76, 95, 89};
  if (std::all_of(grades.begin(), grades.end(),
                  [](int grade) { return grade &gt; 0; })) {
    std::cout &lt;&lt; "All students have positive grades.\n";
  } else {
    std::cout &lt;&lt; "Not all grades are positive.\n";
  }
  if (std::none_of(grades.begin(), grades.end(),
                   [](int grade) { return grade &lt; 80; })) {
    std::cout
        &lt;&lt; "No student has scored below passing marks.\n";
  } else {
    std::cout &lt;&lt; "There are students who scored below "
                 "passing marks.\n";
  }
  if (std::any_of(grades.begin(), grades.end(),
                  [](int grade) { return grade &gt;= 95; })) {
    std::cout &lt;&lt; "There's at least one student with an "
                 "'exceptional' grade.\n";
  } else {
    std::cout
        &lt;&lt; "No student has an 'exceptional' grade.\n";
  }
  return 0;
}</pre>			<p>Here’s the <span class="No-Break">example output:</span></p>
			<pre class="console">
All students have positive grades.
There are students who scored below passing marks.
There's at least one student with an 'exceptional' grade.</pre>			<p>In this <a id="_idIndexMarker746"/>example, we’ve used a set of student grades as our dataset. We use the described algorithms to check if all grades are positive, if no student scored below passing marks (considered 80 in this case), and if there’s at least one student who achieved an <em class="italic">exceptional</em> grade (90 <span class="No-Break">or above).</span></p>
			<p>Moving beyond these fundamental checks, there are more specialized algorithms such as <strong class="source-inline">std::is_sorted</strong>, which, as the name suggests, verifies if a range is sorted. For instance, with a dataset of product prices, this function quickly checks if the sequence is in ascending order, ensuring integrity before performing <span class="No-Break">other operations.</span></p>
			<p>Another intriguing algorithm is <strong class="source-inline">std::is_partitioned</strong>. Imagine you have a mixed data collection, and you’ve used some criteria to partition it, such as dividing numbers into even and odd. This algorithm checks if such a partitioning exists in a sequence based on <span class="No-Break">a predicate.</span></p>
			<p>While these functions offer direct ways to validate data, sometimes the need is more nuanced. Consider the situation where you want to compare two sequences to check if they’re permutations of each other. The STL offers <strong class="source-inline">std::is_permutation</strong> for this very purpose. Whether it is strings, numbers, or custom objects, this function can ascertain if one sequence is a reordering <span class="No-Break">of another.</span></p>
			<p>Let’s use a dataset of product <a id="_idIndexMarker747"/>prices to demonstrate the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::is_permutation</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;double&gt; prices = {5.99, 10.49, 20.89, 25.55,
                                30.10};
  if (std::is_sorted(prices.begin(), prices.end())) {
    std::cout &lt;&lt; "The product prices are sorted in"
                 "ascending order.\n";
  } else {
    std::cout &lt;&lt; "The product prices are not sorted.\n";
  }
  auto partitionPoint = std::partition(
      prices.begin(), prices.end(),
      [](double price) { return price &lt; 20.0; });
  if (std::is_partitioned(
          prices.begin(), prices.end(),
          [](double price) { return price &lt; 20.0; })) {
    std::cout &lt;&lt; "Prices are partitioned with prices less "
                 "than $20 first.\n";
  } else {
    std::cout &lt;&lt; "Prices are not partitioned based on the "
                 "given criteria.\n";
  }
  std::vector&lt;double&gt; shuffledPrices = {25.55, 5.99, 30.10,
                                        10.49, 20.89};
  // Using std::is_permutation to ascertain if
  // shuffledPrices is a reordering of prices
  if (std::is_permutation(prices.begin(), prices.end(),
                          shuffledPrices.begin())) {
    std::cout
        &lt;&lt; "Sequences are permutations of each other.\n";
  } else {
    std::cout &lt;&lt; "Sequences are not permutations of each "
                 "other.\n";
  }
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker748"/><span class="No-Break">example output:</span></p>
			<pre class="console">
The product prices are sorted in ascending order.
Prices are partitioned with prices less than $20 first.
Sequences are permutations of each other.</pre>			<p>In this example, we’ve used the described algorithms on a dataset of product prices. The prices are first checked to see if they’re sorted. Then, they’re partitioned based on a price criterion. Finally, we verify if two sequences of prices are permutations of <span class="No-Break">each other.</span></p>
			<p>Utilizing these <a id="_idIndexMarker749"/>condition-checking functions isn’t just about invoking them on datasets. True power comes from crafting meaningful predicates. By harnessing the capabilities of lambdas or functor objects, you can design intricate conditions that precisely capture your requirements. Whether checking the validity of user inputs, validating data before processing, or ensuring the sanctity of results post-processing, predicate-based functions are your <span class="No-Break">trusty tools.</span></p>
			<p>But like any powerful toolkit, these functions must be used judiciously. Over-relying on checks can lead to performance overhead, especially on large datasets. Striking a balance between validation and performance is crucial. Often, understanding the nature of your data and the broader context of the application can guide you in efficiently using <span class="No-Break">these algorithms.</span></p>
			<p>In wrapping up this exploration of condition-checking algorithms, it is evident that they form an essential part of the STL’s algorithmic suite. They provide a robust foundation upon which more advanced operations can be built. As we journey ahead, you’ll see how these foundational checks intertwine with other algorithms, such as counting and finding, painting a holistic picture of data processing in the captivating world <span class="No-Break">of C++.</span></p>
			<h1 id="_idParaDest-503"><a id="_idTextAnchor503"/>Counting and finding</h1>
			<p>In the data we deal with daily, managing or validating the data and actively searching, locating, and quantifying specific elements or patterns within it often becomes essential. The STL equips developers with a treasure trove of precise algorithms for counting <span class="No-Break">and finding.</span></p>
			<p>Let’s start <a id="_idIndexMarker750"/>with the simple yet powerful <strong class="source-inline">std::count</strong> and its twin <strong class="source-inline">std::count_if</strong>. While <strong class="source-inline">std::count</strong> can swiftly tell you how many times a specific value appears in a range, <strong class="source-inline">std::count_if</strong> takes it up a notch, letting you count occurrences based on a predicate. Imagine you have a collection of student marks and wish to find out how many scored above 90. With <strong class="source-inline">std::count_if</strong>, it’s a cakewalk, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; grades = {85, 90, 78, 92,
                             88, 76, 95, 89};
  const auto exact_count =
      std::count(grades.begin(), grades.end(), 90);
  std::cout &lt;&lt; "Number of students who scored exactly 90:"
            &lt;&lt; exact_count &lt;&lt; "\n";
  const auto above_count =
      std::count_if(grades.begin(), grades.end(),
                    [](int grade) { return grade &gt; 90; });
  std::cout &lt;&lt; "Number of students who scored above 90:"
            &lt;&lt; above_count &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here’s <a id="_idIndexMarker751"/>the <span class="No-Break">example output:</span></p>
			<pre class="console">
Number of students who scored exactly 90: 1
Number of students who scored above 90: 2</pre>			<p>Here, we have utilized <strong class="source-inline">std::count</strong> to check the number of students who scored precisely 90 and then employed <strong class="source-inline">std::count_if</strong> to count the students scoring <span class="No-Break">above 90.</span></p>
			<p>Beyond just counting, sometimes the goal is to locate a specific element. This is where <strong class="source-inline">std::find</strong> and <strong class="source-inline">std::find_if</strong> come into play. In comparison, <strong class="source-inline">std::find </strong>looks for an exact match, and <strong class="source-inline">std::find_if</strong> searches based on a predicate. For those times when you’re eager to know the position of the first element that meets a condition, these functions are <span class="No-Break">your go-to.</span></p>
			<p>Yet, life isn’t always about the first match. Occasionally, it is the last match that matters. In such <a id="_idIndexMarker752"/>scenarios, <strong class="source-inline">std::find_end</strong> proves invaluable. Especially useful in situations such as locating the last occurrence of a subsequence within a larger sequence, this function ensures you don’t miss out on the nuances in <span class="No-Break">your data.</span></p>
			<p>Let’s look at a code example using <strong class="source-inline">std::list</strong> containing a structure of student names and grades. We’ll then use <strong class="source-inline">std::find_if</strong> and <strong class="source-inline">std::find_end</strong> to locate students based on their grades, as <span class="No-Break">demonstrated here:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
struct Student {
  std::string name;
  int grade{0};
  Student(std::string n, int g) : name(n), grade(g) {}
};
int main() {
  std::list&lt;Student&gt; students = {
      {"Lisa", 85},   {"Corbin", 92}, {"Aaron", 87},
      {"Daniel", 92}, {"Mandy", 78},  {"Regan", 92},
  };
  auto first_92 = std::find_if(
      students.begin(), students.end(),
      [](const Student &amp;s) { return s.grade == 92; });
  if (first_92 != students.end()) {
    std::cout &lt;&lt; first_92-&gt;name
              &lt;&lt; "was the first to score 92.\n";
  }
  std::list&lt;Student&gt; searchFor = {{"", 92}};
  auto last_92 = std::find_end(
      students.begin(), students.end(), searchFor.begin(),
      searchFor.end(),
      [](const Student &amp;s, const Student &amp;value) {
        return s.grade == value.grade;
      });
  if (last_92 != students.end()) {
    std::cout &lt;&lt; last_92-&gt;name
              &lt;&lt; "was the last to score 92.\n";
  }
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker753"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Corbin was the first to score 92.
Regan was the last to score 92.</pre>			<p>In this example, we use <strong class="source-inline">std::find_if</strong> to find the first student who scored 92. Then, we use <strong class="source-inline">std::find_end</strong> to find the last student who scored 92. The <strong class="source-inline">std::find_end</strong> function is a bit tricky in this case because it is meant for finding subsequences, but by providing it with a single-element list (which acts as our <em class="italic">subsequence</em>), we can still use it to find the last occurrence of a <span class="No-Break">particular grade.</span></p>
			<p>For those <a id="_idIndexMarker754"/>who work with sorted data, STL doesn’t disappoint. With <strong class="source-inline">std::lower_bound</strong> and <strong class="source-inline">std::upper_bound</strong>, you can efficiently find the beginning and end of a range of values equal to a given value in a sorted sequence. Furthermore, <strong class="source-inline">std::binary_search</strong> lets you quickly ascertain if an element exists in the sorted range. Remember, these functions capitalize on the sorted nature of the data, making them considerably faster than their <span class="No-Break">generic counterparts.</span></p>
			<p>Let’s define a <strong class="source-inline">Student</strong> structure and use a <strong class="source-inline">std::set</strong> of <strong class="source-inline">Student</strong> objects. We’ll modify the comparison operators to sort based on grades <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
struct Student {
  std::string name;
  int grade{0};
  bool operator&lt;(const Student &amp;other) const {
    return grade &lt; other.grade; // Sorting based on grade
  }
};
int main() {
  std::set&lt;Student&gt; students = {
      {"Amanda", 68},  {"Claire", 72}, {"Aaron", 85},
      {"William", 85}, {"April", 92},  {"Bryan", 96},
      {"Chelsea", 98}};
  Student searchStudent{"", 85};
  const auto lb = std::lower_bound(
      students.begin(), students.end(), searchStudent);
  if (lb != students.end() &amp;&amp; lb-&gt;grade == 85) {
    std::cout
        &lt;&lt; lb-&gt;name
        &lt;&lt; " is the first student with a grade of 85.\n";
  }
  const auto ub = std::upper_bound(
      students.begin(), students.end(), searchStudent);
  if (ub != students.end()) {
    std::cout &lt;&lt; ub-&gt;name
              &lt;&lt; " is the next student after the last one "
                 "with a grade of 85, with a grade of "
              &lt;&lt; ub-&gt;grade &lt;&lt; ".\n";
  }
  if (std::binary_search(students.begin(), students.end(),
                         searchStudent)) {
    std::cout &lt;&lt; "There's at least one student with a "
                 "grade of 85.\n";
  } else {
    std::cout &lt;&lt; "No student has scored an 85.\n";
  }
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker755"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Aaron is the first student with a grade of 85.
April is the next student after the last one with a grade of 85, with a grade of 92.
There's at least one student with a grade of 85.</pre>			<p>In this example, <strong class="source-inline">Student</strong> structures are sorted in <strong class="source-inline">std::set</strong> based on their grades. The names are then used in <span class="No-Break">the output.</span></p>
			<p>Speaking of speed, the adjacency algorithms – <strong class="source-inline">std::adjacent_find</strong> being a prime example – allow for the rapid location of consecutive duplicates in a sequence. Imagine a sensor sending data, and you wish to identify if there are back-to-back duplicate readings quickly. This function is your <span class="No-Break">go-to solution.</span></p>
			<p>Let’s look at an example of a <strong class="source-inline">std::list</strong> of structures where each entry has a sensor reading (a temperature) and the time it <span class="No-Break">was taken:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
struct SensorData {
  int temperature{0};
  std::chrono::system_clock::time_point timestamp;
};
int main() {
  const auto now = std::chrono::system_clock::now();
  std::list&lt;SensorData&gt; sensorReadings = {
      {72, now - std::chrono::hours(10)},
      {73, now - std::chrono::hours(9)},
      {75, now - std::chrono::hours(8)},
      {75, now - std::chrono::hours(7)},
      {76, now - std::chrono::hours(6)},
      {78, now - std::chrono::hours(5)},
      {78, now - std::chrono::hours(4)},
      {79, now - std::chrono::hours(3)},
      {80, now - std::chrono::hours(2)},
      {81, now - std::chrono::hours(1)}};
  auto it = sensorReadings.begin();
  while (it != sensorReadings.end()) {
    it = std::adjacent_find(
        it, sensorReadings.end(),
        [](const SensorData &amp;a, const SensorData &amp;b) {
          return a.temperature == b.temperature;
        });
    if (it != sensorReadings.end()) {
      int duplicateValue = it-&gt;temperature;
      std::cout &lt;&lt; "Found consecutive duplicate readings "
                   "of value: "
                &lt;&lt; duplicateValue
                &lt;&lt; " taken at the following times:\n";
      while (it != sensorReadings.end() &amp;&amp;
             it-&gt;temperature == duplicateValue) {
        const auto time =
            std::chrono::system_clock::to_time_t(
                it-&gt;timestamp);
        std::cout &lt;&lt; "\t"
                  &lt;&lt; std::put_time(std::localtime(&amp;time),
                                   "%Y-%m-%d %H:%M:%S\n");
        ++it;
      }
    }
  }
  return 0;
}</pre>			<p>In this<a id="_idIndexMarker756"/> example, each <strong class="source-inline">SensorData</strong> structure contains a temperature and its recorded timestamp. We’re using <strong class="source-inline">std::adjacent_find</strong> with a custom comparator to check for back-to-back duplicate temperature readings. When we find such a reading, we display the time the reading was taken and the <span class="No-Break">temperature value.</span></p>
			<p>Here’s the <span class="No-Break">example output:</span></p>
			<pre class="console">
Found consecutive duplicate readings of value: 75 taken at the following times:
    2099-10-01 03:14:51
    2099-10-01 04:14:51
Found consecutive duplicate readings of value: 78 taken at the following times:
    2099-10-01 06:14:51
    2099-10-01 07:14:51</pre>			<p>As with all tools, understanding when and how to use these algorithms is pivotal. While it might be tempting to employ binary searches frequently due to their speed, they’re only applicable to sorted data. Otherwise, using them might lead to incorrect results. Similarly, while counting occurrences might seem straightforward, using the correct counting function, depending on whether you have a specific value or a condition, can significantly affect your program’s clarity <span class="No-Break">and efficiency.</span></p>
			<p>Given all of the options for data handling in C++, counting and finding are foundational and complex. They pave the way for more advanced operations, and a mastery over them ensures you’re well on your way to becoming adept at handling even the most complex data scenarios. Given our sorted data, we can expand our toolset further by examining efficient searching and comparison with <span class="No-Break">the STL.</span></p>
			<h1 id="_idParaDest-504"><a id="_idTextAnchor504"/>Searching and comparison</h1>
			<p>Searching<a id="_idIndexMarker757"/> through data is a common yet crucial operation that most software requires. Whether you’re trying to retrieve specific user details from a database or find a book’s position in a sorted list, a robust search technique is paramount. With<a id="_idIndexMarker758"/> its plethora of algorithms, the STL offers several methods to search through sequences efficiently. Moreover, the library provides intuitive ways to compare sequences and retrieve extreme values, making data analysis <span class="No-Break">more streamlined.</span></p>
			<p>When working with sorted data, <strong class="source-inline">std::binary_search</strong> is a power player. It’s a testament to the importance of keeping data sorted wherever feasible. By repeatedly dividing the dataset in half, it locates the desired element, making it an exceptionally speedy tool. However, this is merely a boolean operation; it informs if the element exists, but not where it exists. For that, we lean on <strong class="source-inline">std::lower_bound</strong> and <strong class="source-inline">std::upper_bound</strong>. These functions retrieve iterators pointing to the first occurrence and just past the last occurrence of an element. Combining these two can give a range representing all instances of a value in a <span class="No-Break">sorted sequence.</span></p>
			<p>Yet, not all data is sorted, and not all searches are for exact matches. The STL doesn’t leave you in the lurch. Functions such as <strong class="source-inline">std::find</strong> and <strong class="source-inline">std::find_if</strong> shine in these situations, providing flexibility to search based on actual values <span class="No-Break">or predicates.</span></p>
			<p>After searching, a natural progression is comparing elements. Often, we need to determine if one sequence is lexicographically less than, greater than, or equal to another. This is where <strong class="source-inline">std::lexicographical_compare</strong> steps in, allowing you to compare two sequences like dictionary ordering. It’s a must-have when working with strings or custom data types, ensuring you can quickly sort and rank data <span class="No-Break">as required.</span></p>
			<p>Here’s an example to demonstrate the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::lexicographical_compare</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;char&gt; seq1 = {'a', 'b', 'c'};
  std::vector&lt;char&gt; seq2 = {'a', 'b', 'd'};
  std::vector&lt;char&gt; seq3 = {'a', 'b', 'c', 'd'};
  if (std::lexicographical_compare(
          seq1.begin(), seq1.end(), seq2.begin(),
          seq2.end())) {
    std::cout &lt;&lt; "Sequence 1 is lexicographically less"
                 "than Sequence 2"
              &lt;&lt; "\n";
  } else {
    std::cout
        &lt;&lt; "Sequence 1 is not lexicographically less"
           "than Sequence 2"
        &lt;&lt; "\n";
  }
  if (std::lexicographical_compare(
          seq1.begin(), seq1.end(), seq3.begin(),
          seq3.end())) {
    std::cout &lt;&lt; "Sequence 1 is lexicographically less"
                 "than Sequence 3"
              &lt;&lt; "\n";
  } else {
    std::cout
        &lt;&lt; "Sequence 1 is not lexicographically less"
           "than Sequence 3"
        &lt;&lt; "\n";
  }
  // For strings
  std::string str1 = "apple";
  std::string str2 = "banana";
  if (std::lexicographical_compare(
          str1.begin(), str1.end(), str2.begin(),
          str2.end())) {
    std::cout &lt;&lt; "String 1 (apple) is lexicographically "
                 "less than String 2 (banana)"
              &lt;&lt; "\n";
  } else {
    std::cout &lt;&lt; "String 1 (apple) is not "
                 "lexicographically less "
                 "than String 2 (banana)"
              &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker759"/><span class="No-Break">example </span><span class="No-Break"><a id="_idIndexMarker760"/></span><span class="No-Break">output:</span></p>
			<pre class="console">
Sequence 1 is lexicographically less than Sequence 2
Sequence 1 is lexicographically less than Sequence 3
String 1 (apple) is lexicographically less than String 2 (banana)</pre>			<p>This demonstrates how <strong class="source-inline">std::lexicographical_compare</strong> can be used to determine the relative ordering of <span class="No-Break">two sequences.</span></p>
			<p>But what if you’re only <a id="_idIndexMarker761"/>interested in the extremes? Perhaps you want to find the highest score in an exam or the lowest price in a list of products. Here, <strong class="source-inline">std::max_element </strong>and <strong class="source-inline">std::min_element</strong> are your stalwarts. They return iterators <a id="_idIndexMarker762"/>pointing to the maximum and minimum elements, respectively. If you’re looking for both, <strong class="source-inline">std::minmax_element</strong> does the trick, giving you a pair of iterators in <span class="No-Break">one go:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; scores = {85, 93, 78, 90, 96, 82};
  const auto max_it =
      std::max_element(scores.begin(), scores.end());
  if (max_it != scores.end()) {
    std::cout &lt;&lt; "The highest score is: "&lt;&lt; *max_it
              &lt;&lt; "\n";
  }
  const auto min_it =
      std::min_element(scores.begin(), scores.end());
  if (min_it != scores.end()) {
    std::cout &lt;&lt; "The lowest score is: "&lt;&lt; *min_it
              &lt;&lt; "\n";
  }
  const auto minmax =
      std::minmax_element(scores.begin(), scores.end());
  if (minmax.first != scores.end() &amp;&amp;
      minmax.second != scores.end()) {
    std::cout &lt;&lt; "The lowest and highest scores are: "
              &lt;&lt; *minmax.first &lt;&lt; " and " &lt;&lt; *minmax.second
              &lt;&lt; ", respectively.\n";
  }
  std::vector&lt;double&gt; productPrices = {99.99, 79.99, 49.99,
                                       59.99, 89.99};
  // Find the minimum and maximum prices
  auto minmaxPrices = std::minmax_element(
      productPrices.begin(), productPrices.end());
  if (minmaxPrices.first != productPrices.end() &amp;&amp;
      minmaxPrices.second != productPrices.end()) {
    std::cout
        &lt;&lt; "The cheapest and priciest products cost: $"
        &lt;&lt; *minmaxPrices.first &lt;&lt; " and $"
        &lt;&lt; *minmaxPrices.second &lt;&lt; ", respectively.\n";
  }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker763"/><span class="No-Break">example output:</span></p>
			<pre class="console">
The highest score is: 96
The lowest score is: 78
The lowest and highest scores are: 78 and 96, respectively.
The cheapest and priciest products cost: $49.99 and $99.99, respectively.</pre>			<p>This demonstrates using <strong class="source-inline">std::max_element</strong>, <strong class="source-inline">std::min_element</strong>, and <strong class="source-inline">std::minmax_element</strong> to find the extreme values <span class="No-Break">in sequences.</span></p>
			<p>To wrap up, the <a id="_idIndexMarker764"/>power of searching and comparison in STL isn’t just in the breadth of its functions but in its adaptability. With iterators and predicates, these algorithms are remarkably versatile, ensuring you can adapt them to various scenarios. As developers, these tools become extensions of our thinking, guiding us toward efficient and elegant solutions. As we progress further, remember these operations form the foundation for more advanced techniques and best practices, fortifying our capabilities in data handling and algorithmic problem-solving <span class="No-Break">in C++.</span></p>
			<h1 id="_idParaDest-505"><a id="_idTextAnchor505"/>Best practices</h1>
			<p>The elegance of the C++ STL lies in its vast array of utilities and its potential for optimization. However, merely knowing the algorithms isn’t the endgame. How you use them, combine them, and make subtle decisions can spell the difference between an efficient program and a sluggish one. So, let’s delve into the best practices, ensuring that your forays into STL are correct and performed at <span class="No-Break">peak efficiency:</span></p>
			<ul>
				<li><strong class="bold">Know your data</strong>: Before choosing any algorithm, you need to assess the nature of your data. Is it mostly sorted or completely random? Is it sparse or densely populated? The answers to these questions can dictate the choice of algorithm. For instance, using <strong class="source-inline">std::binary_search</strong> on a mostly sorted array may be counterproductive when <strong class="source-inline">std::find</strong> can serve the purpose with <span class="No-Break">less overhead.</span></li>
				<li><strong class="bold">Leverage the sorted nature of your data structures</strong>: On the topic of sorted data, always leverage the sorted nature of your data structures wherever possible. Sorted data structures, such as <strong class="source-inline">std::set</strong> and <strong class="source-inline">std::map</strong>, have inherent advantages in searching and inserting elements. However, they can also lead to pitfalls. Continuously adding elements to such containers may not be efficient, and sometimes, batch insertions followed by a sort operation can be <span class="No-Break">more optimal.</span></li>
				<li><strong class="bold">Avoid needless reallocations</strong>: Memory reallocation is one of the most expensive operations regarding time performance. When working with containers such as <strong class="source-inline">std::vector</strong>, using the <strong class="source-inline">reserve</strong> method, it is crucial to have a fair estimate of the size and reserve the memory upfront. This way, as you call <strong class="source-inline">push_back</strong> to add elements, the vector does not have to reallocate memory frequently, offering a significant <span class="No-Break">performance boost.</span></li>
				<li><strong class="bold">Prefer algorithms with predicate versions</strong>: Algorithms such as <strong class="source-inline">std::count_if</strong> and <strong class="source-inline">std::find_if</strong> allow custom conditions to be set, making them flexible and adaptable to a broader range of scenarios than their non-predicate counterparts. Moreover, lambdas in C++11 and beyond have made using these algorithms even more concise <span class="No-Break">and expressive.</span></li>
				<li><strong class="bold">Be wary of algorithmic complexity</strong>: While the STL provides tools, it does not change the fundamental nature of algorithms. A linear search will always be linear, and a binary search will be logarithmic. Recognize the complexity of your algorithm and question whether that’s the best for your <span class="No-Break">application’s requirements.</span></li>
				<li><strong class="bold">Opt for stack over heap allocation</strong>: Opt for stack over heap allocation when feasible in terms of memory performance. Containers such as <strong class="source-inline">std::array</strong>, which are stack-allocated, can be faster to access than their heap-allocated counterparts due to cache locality. However, this comes with the trade-off of fixed sizes. Hence, understanding the memory requirements beforehand can help strike the <span class="No-Break">right balance.</span></li>
				<li><strong class="bold">Iterators are your friends</strong>: Iterators are your friends, but they can also be your downfall if not used carefully. Always ensure that the iterators you use are valid. Operations such as insertion and deletion, especially in containers such as <strong class="source-inline">std::vector</strong>, can invalidate iterators, leading to <span class="No-Break">undefined behavior.</span></li>
				<li><strong class="bold">Benchmark and profile</strong>: Assumptions and best practices are starting points, but real performance metrics come from profiling your application. Tools such as gprof, Valgrind, and Celero can be invaluable in highlighting bottlenecks and guiding you toward the right optimizations. These best practices outline how to optimize C++ STL usage, emphasizing the importance of understanding the nature of data, leveraging sorted data structures, avoiding unnecessary memory reallocations, preferring algorithms with predicate versions, being aware of algorithmic complexity, choosing stack over heap allocation when appropriate, using iterators judiciously, and the significance of benchmarking and profiling to identify performance bottlenecks. They underscore that while STL offers powerful utilities, efficient programming depends on how these tools are employed <span class="No-Break">and combined.</span></li>
			</ul>
			<h1 id="_idParaDest-506"><a id="_idTextAnchor506"/>Summary</h1>
			<p>In this chapter, we have thoroughly examined the core algorithms that operate on STL containers and their role in efficient C++ programming. We began by exploring the essentials of sorting algorithms and understanding how they organize data for better accessibility and performance. We then delved into various methods for checking container conditions and techniques for counting and finding elements, which are vital for data analysis <span class="No-Break">and manipulation.</span></p>
			<p>This chapter has armed you with strategies for effectively searching and comparing elements. We also focused on best practices that ensure these operations are performed with optimal efficiency and <span class="No-Break">minimal error.</span></p>
			<p>This knowledge has provided a foundation for implementing complex algorithms and performing data manipulations and everyday tasks in intermediate to advanced <span class="No-Break">C++ development.</span></p>
			<p>In the next chapter, we will extend our understanding of algorithms further. We will learn about copying and moving semantics within STL containers, <strong class="bold">Return Value Optimization</strong> (<strong class="bold">RVO</strong>), and techniques for filling, generating, removing, and replacing elements. Additionally, we will explore the nuances of swapping and reversing elements and conclude with deduplication and sampling strategies. These topics will contribute to a holistic understanding of data manipulation <span class="No-Break">and transformation.</span></p>
		</div>
	</body></html>