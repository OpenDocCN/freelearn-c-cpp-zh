<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to Qt</h1>
                </header>
            
            <article>
                
<p>In this chapter<span>,</span> you will learn <span>what Qt is and how it evolved. We will describe the structure of the Qt framework and the differences between its versions. Finally, you will learn how to decide which Qt licensing scheme is right for your projects</span><span>.</span></p>
<p>The main topics covered in this chapter are:</p>
<ul>
<li>Qt history</li>
<li>Supported platforms</li>
<li>Structure of the Qt framework</li>
<li>Qt versions</li>
<li>Qt licenses</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A journey through time</h1>
                </header>
            
            <article>
                
<p>The development of Qt started in 1991 by two Norwegians—Eirik Chambe-Eng and Haavard Nord<span>—</span>who were looking to create a cross-platform GUI programming toolkit. The first commercial client of Trolltech (the company that created the Qt toolkit) was the European Space Agency. The commercial use of Qt helped Trolltech sustain further development. At that time, Qt was available for two platforms—Unix/X11 and Windows<span>—</span>however, developing with Qt for Windows required buying a proprietary license, which was a significant drawback in porting the existing Unix/Qt applications.</p>
<p>A major step forward was the release of Qt Version 3.0 in 2001, which saw the initial support for Mac as well as an option to use Qt for Unix and Mac under a liberal GPL license. Still, Qt for Windows was only available under a paid license. Nevertheless, at that time, Qt had support for all the important players in the market—Windows, Mac, and Unix desktops, with Trolltech's mainstream product and Qt for embedded Linux.</p>
<p>In 2005, Qt 4.0 was released, which was a real breakthrough for a number of reasons. First, the Qt API was completely redesigned, which made it cleaner and more coherent. Unfortunately, at the same time, it made the existing Qt-based code incompatible with 4.0, and many applications needed to be rewritten from scratch or required much effort to be adapted to the new API. It was a difficult decision, but from the time perspective, we can see it was worth it. Difficulties caused by changes in the API were well countered by the fact that Qt for Windows was finally released under GPL. Many optimizations were introduced that made Qt significantly faster. Lastly, Qt, which was a single library until now, was divided into a number of modules. This allowed programmers to only link to the functionality that they used in their applications, reducing the memory footprint and the dependencies of their software.</p>
<p>In 2008, Trolltech was sold to Nokia, which at that time was looking for a software framework to help it expand and replace its Symbian platform in the future. The Qt community became divided; some people were thrilled, others were worried after seeing Qt's development get transferred to Nokia. Either way, new funds were pumped into Qt, speeding up its progress and opening it for mobile platforms—Symbian and then Maemo and MeeGo.</p>
<p>For Nokia, Qt was not considered a product of its own, but rather a tool. Therefore, Nokia decided to introduce Qt to more developers by adding a very liberal <strong>Lesser General Public License</strong> (<strong>LGPL</strong>) that allowed the usage of the framework for both open and closed source development.</p>
<p>Bringing Qt to new platforms and less powerful hardware required a new approach to create user interfaces and to make them more lightweight, fluid, and attractive. Nokia engineers working on Qt came up with a new declarative language to develop such interfaces—the <strong>Qt Modeling Language</strong> (<strong>QML</strong>) and a Qt runtime for it called <strong>Qt Quick</strong>.</p>
<p>The latter became the primary focus of the further development of Qt, practically stalling all non-mobile-related work, channeling all efforts to make Qt Quick faster, easier, and more widespread. Qt 4 was already in the market for seven years, and it became obvious that another major version of Qt had to be released. It was decided to bring more engineers to Qt by allowing anyone to contribute to the project. The Qt Project founded by Nokia in 2011 provided an infrastructure for code review and introduced an open governance model, allowing outside developers to participate in decision making.</p>
<p>Nokia did not manage to finish working on Qt 5.0. As a result of an unexpected turnover of Nokia toward different technology in 2011, the Qt division was sold in mid 2012 to the Finnish company Digia that managed to complete the effort and release Qt 5.0, a completely restructured framework, in December of the same year. While Qt 5.0 introduced a lot of new features, it was mostly compatible with Qt 4 and allowed developers to seamlessly migrate to the new major version.</p>
<p>In 2014, Digia formed the Qt Company that is now responsible for Qt development, commercialization, and licensing. All Qt-related web resources scattered across Qt Project and Digia websites were eventually unified at <a href="https://www.qt.io/">https://www.qt.io/</a>. Qt continues to receive bug fixes, new features, and new platform support. This book is based on Qt 5.9, which was released in 2017.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The cross-platform programming</h1>
                </header>
            
            <article>
                
<p>Qt is an application-programming framework that is used to develop cross-platform applications. What this means is that software written for one platform can be ported and executed on another platform with little or no effort. This is obtained by limiting the application source code to a set of calls to routines and libraries available to all the supported platforms, and by delegating all tasks that may differ between platforms (such as drawing on the screen and accessing system data or hardware) to Qt. This effectively creates a layered environment (as shown in the following diagram), where Qt hides all platform-dependent aspects from the application code:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/38e091d7-0475-4051-9142-4d9fc1c14a04.png" style="width:12.92em;height:7.75em;" width="479" height="286"/></div>
<p>Of course, at times, we need to use some functionality that Qt doesn't provide. In such situations, it is important to use a conditional compilation for platform-specific code. Qt provides a wide set of macros specifying the current platform. We will return to this topic in <a href="ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml" target="_blank">Chapter 6</a>, <em>Qt Core Essentials</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supported platforms</h1>
                </header>
            
            <article>
                
<p>The framework is available for a number of platforms, ranging from classical desktop environments through embedded systems to mobile devices. Qt 5.9 supports the following platforms: </p>
<ul>
<li>Desktop platforms: Windows, Linux, and macOS</li>
<li>Mobile platforms: UWP<span>, Android</span>, and iOS</li>
<li>Embedded platforms: VxWorks, INTEGRITY, QNX, and Embedded Linux</li>
</ul>
<p><span>It is likely that the list of supported platforms will change in future Qt </span>versions. You should refer to the <span class="packt_screen">Supported Platforms</span> documentation page for your Qt version for detailed information about supported versions of operating systems and compilers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GUI scalability</h1>
                </header>
            
            <article>
                
<p>For the most part of the history of desktop application development, specifying sizes of GUI elements in pixels was the common practice. While most operating systems had <strong>dots per inch</strong> (<strong>DPI</strong>) settings and APIs for taking it into account for a long time, the majority of existing displays had approximately the same DPI, so applications without high DPI support were common.</p>
<p>The situation changed when high-DPI displays became more common in the market—most notably in mobile phones and tablets, but also in laptops and desktops. Now, even if you only target desktop platforms, you should think about supporting different DPI settings. When you target mobile devices, this becomes mandatory.</p>
<p>If you are using Qt Widgets or Qt Quick, you often don't need to specify pixel sizes at all. Standard widgets and controls will use fonts, margins, and offsets defined by the style. If layouts are used, Qt will determine positions and sizes of all GUI items automatically. Avoid specifying constant sizes for GUI elements when possible. You may use sizes related to sizes of other GUI elements, the window, or the screen. Qt also provides an API for querying screen DPI, GUI style metrics, and font metrics, which should help to determine the optimal size for the current device.</p>
<p>On macOS and iOS, Qt Widgets and Qt Quick applications are scaled automatically using a virtual coordinate system. Pixel values in the application remain the same, but the GUI will scale according to the DPI of the current display. For example, if the pixel ratio is set to 2 (a common value for retina displays), creating a widget with 100 "pixels" width will produce a widget with 200 physical pixels. That means that the application doesn't have to be highly aware of DPI variations. However, this scaling does not apply to OpenGL, which always uses physical pixels.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Qt versions</h1>
                </header>
            
            <article>
                
<p>Each Qt version number (for example, 5.9.2) consists of major, minor, and patch components. Qt pays special attention to forwards and backwards compatibility between different versions. Small changes which are both forwards and backwards compatible (typically bug fixes without changing any API) are indicated by changing only the patch version. New minor versions usually bring in new API and features, so they are not forwards compatible. However, all minor versions are backwards binary and source compatible. This means that if you're transitioning to a newer minor version (for example, from 5.8 to 5.9), you should always be able to rebuild your project without changes. You can even transition to a new minor version without rebuilding, by only updating shared Qt libraries (or letting the package manager of the OS do that). Major releases indicate big changes and may break backwards compatibility. However, the latest major release (5.0) was mostly source compatible with the previous version.</p>
<p>Qt declares <strong>Long Term Support</strong> (<strong>LTS</strong>) for certain versions. LTS versions receive patch-level releases with bug fixes and security fixes for three years. Commercial support is available for even longer periods. Current LTS releases at the time of writing are 5.6 and 5.9.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Structure of Qt framework</h1>
                </header>
            
            <article>
                
<p>As Qt expanded over time, its structure evolved. At first, it was just a single library, then a set of libraries. When it became harder to maintain and update for the growing number of platforms that it supported, a decision was made to split the framework into much smaller modules contained in two module groups—Qt Essentials and Qt Add-ons. A major decision relating to the split was that each module could now have its own independent release schedule.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Qt Essentials</h1>
                </header>
            
            <article>
                
<p>The Essentials group contains modules that are mandatory to implement for every supported platform. This implies that if you are implementing your system using modules from this group only, you can be sure that it can be easily ported to any other platform that Qt supports. The most important relations between Qt Essentials modules are shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/79abeacb-c7bb-4486-a20e-de558d8e5e3b.png" style="width:24.08em;height:9.17em;" width="384" height="145"/></div>
<p>Some of the modules are explained as follows:</p>
<ul>
<li>The <strong>Qt Core</strong> module contains the most basic Qt functionality that all other modules rely on. It provides support for event processing, meta-objects, data I/O, text processing, and threading. It also brings a number of frameworks, such as the Animation framework, the State Machine framework, and the Plugin framework.</li>
<li>The <strong>Qt GUI</strong> module provides basic cross-platform support to build user interfaces. It contains the common functionality required by more high-level GUI modules (Qt Widgets and Qt Quick). Qt GUI contains classes that are used to manipulate windows that can be rendered using either the raster engine or OpenGL. Qt supports desktop OpenGL as well as OpenGL ES 1.1 and 2.0.</li>
<li><strong>Qt Widgets</strong> extends the GUI module with the ability to create a user interface using widgets, such as buttons, edit boxes, labels, data views, dialog boxes, menus, and toolbars, which are arranged using a special layout engine. Qt Widgets utilizes Qt's event system to handle input events in a cross-platform way. This module also contains the implementation of an object-oriented 2D graphics canvas called Graphics View.</li>
<li><strong>Qt Quick</strong> is an extension of Qt GUI, which provides a means to create lightweight fluid user interfaces using QML. It is described in more detail later in this chapter, as well as in <a href="b81d9c47-58fa-49dd-931a-864c7be05840.xhtml">Chapter 11</a><em>, Introduction to Qt Quick</em><span>.</span></li>
</ul>
<ul>
<li><strong>Qt QML</strong> is an implementation of the QML language used in Qt Quick. It also provides API to integrate custom C++ types into QML's JavaScript engine and to integrate QML code with C++.</li>
<li><strong>Qt Network</strong> brings support for IPv4 and IPv6 networking using TCP and UDP. It also contains HTTP, HTTPS, FTP clients, and it extends support for DNS lookups.</li>
<li><strong>Qt Multimedia</strong> allows programmers to access audio and video hardware (including cameras and FM radio) to record and play multimedia content. It also features 3D positional audio support.</li>
<li><strong>Qt SQL</strong> brings a framework that is used to manipulate SQL databases in an abstract way.</li>
</ul>
<div class="packt_tip">There are also other modules in this group, but we will not focus on them in this book. If you want to learn more about them, you can look them up in the Qt reference manual.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Qt Add-ons</h1>
                </header>
            
            <article>
                
<p>This group contains modules that are optional for any platform. This means that if a particular functionality is not available on some platform or there is nobody willing to spend time working on this functionality for a platform, it will not prevent Qt from supporting this platform. We'll mention some of the most important modules here:</p>
<ul>
<li><span><strong>Qt Concurrent</strong>: This handles multi-threaded processing</span></li>
<li><strong>Qt 3D</strong><span>: This provides high-level OpenGL building blocks</span></li>
<li><span><strong>Qt Gamepad</strong>: This enables applications to support gamepad hardware</span></li>
<li><span><strong>Qt D-Bus</strong>: This allows your application to communicate with others via the D-Bus mechanism</span></li>
<li><span><strong>Qt XML Patterns</strong>: This helps us to access XML data</span></li>
</ul>
<p>Many other modules are also available, but we will not cover them here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">qmake</h1>
                </header>
            
            <article>
                
<p>Some Qt features require additional build steps during the compilation and linking of the project. For example, <strong>Meta-Object Compiler</strong> (<strong>moc</strong>), <strong>User Interface Compiler</strong> (<strong>uic</strong>), and <strong>Resource Compiler</strong> (<strong>rcc</strong>) may need to be executed to handle Qt's C++ extensions and features. For convenience, Qt provides the <strong>qmake</strong> executable that manages your Qt project and generates files required for building it on the current platform (such as Makefile for the make utility). qmake reads the project's configuration from a project file with the <kbd>.pro</kbd> extension. Qt Creator (the IDE that comes with Qt) automatically creates and updates that file, but it can be edited manually to alter the build process.</p>
<p>Alternatively, CMake can be used to organize and build the project. Qt provides CMake plugins for performing all the necessary build actions. Qt Creator also has fairly good support for CMake projects. CMake is more advanced and powerful than qmake, but it's probably not needed for projects with a simple build process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modern C++ standards</h1>
                </header>
            
            <article>
                
<p>You can use modern C++ in your Qt projects. Qt's build tool (qmake) allows you to specify the C++ standard you want to target. Qt itself introduces an improved and extended API by using new C++ features when possible. For example, it uses ref-qualified member functions and introduces methods accepting initializer lists and rvalue references. It also introduces new macros that help you deal with compilers that may or may not support new standards. </p>
<p>If you use a recent C++ revision, you have to pay attention to the compiler versions you use across the target platforms because older compilers may not support the new standard. <span>In this book, we will assume C++11 support, as it is widely available already. Thus, we'll </span><span>use C++11 features in our code, such as range-based <kbd>for</kbd> loops, scoped enumerations, and lambda expressions. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Choosing the right license</h1>
                </header>
            
            <article>
                
<p>Qt is available under two different licensing schemes—you can choose between a commercial license and an open source one. We will discuss both here to make it easier for you to choose. If you have any doubts regarding whether a particular licensing scheme applies to your use case, you better consult a professional lawyer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An open source license</h1>
                </header>
            
            <article>
                
<p>The advantage of open source licenses is that we don't have to pay anyone to use Qt; however, the downside is that there are some limitations imposed on how it can be used.</p>
<p>When choosing the open source edition, we have to choose between GPL 3.0 and LGPL 3. Since LGPL is more liberal, in this chapter we will focus on it. Choosing LGPL allows you to use Qt to implement systems that are either open source or closed source—you don't have to reveal the sources of your application to anyone if you don't want to.</p>
<p>However, there are a number of restrictions you need to be aware of:</p>
<ul>
<li>Any modifications that you make to Qt itself need to be made public, for example, by distributing source code patches alongside your application binary.</li>
<li>LGPL requires that users of your application must be able to replace Qt libraries that you provide them with other libraries with the same functionality (for example, a different version of Qt). This usually means that you have to dynamically link your application against Qt so that the user can simply replace Qt libraries with his own. You should be aware that such substitutions can decrease the security of your system; thus, if you need it to be very secure, open source may not be the option for you.</li>
<li>LGPL is incompatible with a number of licenses, especially proprietary ones, so it is possible that you won't be able to use Qt with some commercial components.</li>
</ul>
<p>Some Qt modules may have different licensing restrictions. For example, Qt Charts, Qt Data Visualization, and Qt Virtual Keyboard modules are not available under LGPL and can only be used under GPL or the commercial license.</p>
<p>The open source edition of Qt can be downloaded directly from <a href="https://www.qt.io">https://www.qt.io</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A commercial license</h1>
                </header>
            
            <article>
                
<p>Most of the restrictions are lifted if you decide to buy a commercial license for Qt. This allows you to keep the entire source code a secret, including any changes you may want to incorporate into Qt. You can freely link your application statically against Qt, which means fewer dependencies, a smaller deployment bundle size, and a faster startup. It also increases the security of your application, as end users cannot inject their own code into the application by replacing a dynamically loaded library with their own.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about the architecture of Qt. We saw how it evolved over time and we had a brief overview of what it looks like now. Qt is a complex framework and we will not manage to cover it all, as some parts of its functionality are more important for game programming than others that you can learn on your own in case you ever need them. Now that you know what Qt is, we can proceed with the next chapter, where you will learn how to install Qt on to your development machine.</p>


            </article>

            
        </section>
    </div>



  </body></html>