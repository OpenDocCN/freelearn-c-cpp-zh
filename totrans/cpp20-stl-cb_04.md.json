["```cpp\nstd::vector<int> v;\n```", "```cpp\nstd::vector<int>::iterator v_it;\n```", "```cpp\nstd::vector<std::vector<int, std::string>> v;\n```", "```cpp\nstd::vector<std::vector<int, std::string>>::iterator v_it;\n```", "```cpp\nfor(auto v_it = v.begin(); v_it != v.end(); ++v_it) {\n    cout << *v_it << '\\n';\n}\n```", "```cpp\nconst int a[]{ 1, 2, 3, 4, 5 };\nsize_t count{ sizeof(a) / sizeof(int) };\nfor(const int* p = a; count > 0; ++p, --count) {\n    cout << *p << '\\n';\n}\n```", "```cpp\nconst int a[]{ 1, 2, 3, 4, 5 };\nfor(auto e : a) {\n    cout << e << '\\n';\n}\n```", "```cpp\nstd::vector<int> v{ 1, 2, 3, 4, 5 };\nfor(auto e : v) {\n    cout << e << '\\n';\n}\n```", "```cpp\n{\n    auto begin_it{ std::begin(container) };\n    auto end_it{ std::end(container) };\n    for ( ; begin_it != end_it; ++begin_it) {\n        auto e{ *begin_it };\n        cout << e << '\\n';\n    } \n}\n```", "```cpp\nconst int arr[]{ 1, 2, 3, 4, 5 };\nfor(auto e : arr) {\n    cout << format(\"{} \", e);\n}\n```", "```cpp\n1 2 3 4 5\n```", "```cpp\ntemplate<typename T>\nrequires std::random_access_iterator<typename T::iterator>\nvoid printc(const T & c) {\n        for(auto e : c) {\n        cout << format(\"{} \", e);\n    }\n    cout << '\\n';\n    cout << format(\"element 0: {}\\n\", c[0]);\n}\n```", "```cpp\nint main()\n{\n    list<int> c{ 1, 2, 3, 4, 5 };\n    printc(c);       \n}\n```", "```cpp\nerror: no matching function for call to 'printc(std::__cxx11::list<int>&)'\n   27 |     printc(c);\n      |     ~~~~~~^~~\nnote: candidate: 'template<class T>  requires  random_access_iterator<typename T::iterator> void printc(const T&)'\n   16 | void printc(const T & c) {\n      |      ^~~~~~\nnote:   template argument deduction/substitution failed:\nnote: constraints not satisfied\n```", "```cpp\nint main()\n{\n    vector<int> c{ 1, 2, 3, 4, 5 };\n    printc(c);       \n}\n```", "```cpp\n$ ./working\n1 2 3 4 5\nelement 0: 1\n```", "```cpp\n    template<typename T>\n    class Seq {\n        T start_{};\n        T end_{};\n    public:\n        Seq(T start, T end) : start_{start}, end_{end} {}\n        iterator<T> begin() const {\n            return iterator{start_};\n        }\n        iterator<T> end() const { return iterator{end_}; }\n    };\n    ```", "```cpp\n    public:\n        Seq(T start, T end) : start_{ start }, end_{ end } {}\n        class iterator {\n            T value_{};\n        public:\n            explicit iterator(T position = 0)\n                : value_{position} {}\n            T operator*() const { return value_; }\n            iterator& operator++() {\n                ++value_;\n                return *this;\n            }\n            bool operator!=(const iterator& other) const {\n                return value_ != other.value_;\n            }\n        };\n    ```", "```cpp\n    int main()\n    {\n        Seq<int> r{ 100, 110 };\n        for (auto v : r) {\n            cout << format(\"{} \", v);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n$ ./seq\n100 101 102 103 104 105 106 107 108 109\n```", "```cpp\n{\n    auto begin_it{ std::begin(container) };\n    auto end_it{ std::end(container) };\n    for ( ; begin_it != end_it; ++begin_it) {\n        auto v{ *begin_it };\n        cout << v << '\\n';\n    } \n}\n```", "```cpp\nSeq(T start, T end) : start_{ start }, end_{ end } {}\niterator begin() const { return iterator{start_}; }\niterator end() const { return iterator{end_}; }\n```", "```cpp\nclass iterator {\n    T value_{};\n```", "```cpp\n    T operator*() const { return value_; }\n    iterator& operator++() {\n        ++value_;\n        return *this;\n    }\n    bool operator!=(const iterator& other) const {\n        return value_ != other.value_;\n    }\n```", "```cpp\nSeq<int> r{ 100, 110 };\nfor (auto v : r) {\n    cout << format(\"{} \", v);\n}\n```", "```cpp\nSeq<int>::iterator it = r.begin();\n```", "```cpp\nSeq<int> r{ 100, 110 };\nauto [min_it, max_it] = minmax_element(r.begin(), r.end());\ncout << format(\"{} - {}\\n\", *min_it, *max_it);\n```", "```cpp\n    bool operator==(const iterator& other) const {\n        return value_ == other.value_;\n    }\n    ```", "```cpp\nNo type named 'value_type' in 'std::iterator_traits<Seq<int>::iterator>'\n```", "```cpp\n    public:\n        using iterator_concept  = std::forward_iterator_tag;\n        using iterator_category = \n          std::forward_iterator_tag;\n        using value_type        = std::remove_cv_t<T>;\n        using difference_type   = std::ptrdiff_t;\n        using pointer           = const T*;\n        using reference         = const T&;\n    ```", "```cpp\nusing iterator_concept  = std::forward_iterator_tag;\nusing iterator_category = std::forward_iterator_tag;\n```", "```cpp\nusing value_type        = std::remove_cv_t<T>;\nusing difference_type   = std::ptrdiff_t;\nusing pointer           = const T*;\nusing reference         = const T&;\n```", "```cpp\ntemplate<typename T>\nrequires std::forward_iterator<typename T::iterator>\nvoid printc(const T & c) {\n    for(auto v : c) {\n        cout << format(\"{} \", v);\n    }\n    cout << '\\n';\n}\n```", "```cpp\nauto [min_it, max_it] = ranges::minmax_element(r);\n```", "```cpp\nstatic_assert(ranges::forward_range<Seq<int>>);\n```", "```cpp\n    void printc(const auto & v, const string_view s = \"\") {\n        if(s.size()) cout << format(\"{}: \", s);\n        for(auto e : v) cout << format(\"{} \", e);\n        cout << '\\n';\n    }\n    ```", "```cpp\n    int main() {\n        deque<int> d1{ 1, 2, 3, 4, 5 };\n        deque<int> d2(d1.size());\n        copy(d1.begin(), d1.end(), d2.begin());\n        printc(d1);\n        printc(d2, \"d2 after copy\"); \n    }\n    ```", "```cpp\n1 2 3 4 5\nd2 after copy: 1 2 3 4 5\n```", "```cpp\n    copy(d1.begin(), d1.end(), back_inserter(d2));\n    printc(d2, \"d2 after back_inserter\");\n    ```", "```cpp\nd2 after back_inserter: 1 2 3 4 5 1 2 3 4 5\n```", "```cpp\n    deque<int> d3{ 47, 73, 114, 138, 54 };\n    copy(d3.begin(), d3.end(), front_inserter(d2));\n    printc(d2, \"d2 after front_inserter\");\n    ```", "```cpp\nd2 after front_inserter: 54 138 114 73 47 1 2 3 4 5 1 2 3 4 5\n```", "```cpp\n    auto it2{ d2.begin() + 2};\n    copy(d1.begin(), d1.end(), inserter(d2, it2));\n    printc(d2, \"d2 after middle insert\");\n    ```", "```cpp\nd2 after middle insert: 54 138 1 2 3 4 5 114 73 47 ...\n```", "```cpp\n    cout << \"ostream_iterator: \";\n    copy(d1.begin(), d1.end(), ostream_iterator<int>(cout));\n    cout << '\\n';\n    ```", "```cpp\nostream_iterator: 12345\n```", "```cpp\n    vector<string> vs{};\n    copy(istream_iterator<string>(cin), \n        istream_iterator<string>(),\n        back_inserter(vs));\n    printc(vs, \"vs2\");\n    ```", "```cpp\n$ ./working < five-words.txt\nvs2: this is not a haiku\n```", "```cpp\n    for(auto it = d1.rbegin(); it != d1.rend(); ++it) {\n        cout << format(\"{} \", *it);\n    }\n    cout << '\\n';\n    ```", "```cpp\n5 4 3 2 1\n```", "```cpp\ncopy(d1.begin(), d1.end(), back_inserter(d2));\n```", "```cpp\nauto it = istream_adapter<string>(cin);\nauto it_end = istream_adapter<string>();  // creates sentinel\n```", "```cpp\nfor(auto it = istream_iterator<string>(cin);\n        it != istream_iterator<string>();\n        ++it) {\n    cout << format(\"{} \", *it);\n}\ncout << '\\n';\n```", "```cpp\n$ ./working < five-words.txt\nthis is not a haiku\n```", "```cpp\n    void printc(const auto & v, const string_view s = \"\") {\n        if(s.size()) cout << format(\"{}: \", s);\n        for(auto e : v) cout << format(\"{} \", e);\n        cout << '\\n';\n    }\n    ```", "```cpp\n    class fib_generator {\n        using fib_t = unsigned long;\n        fib_t stop_{};\n        fib_t count_ { 0 };\n        fib_t a_ { 0 };\n        fib_t b_ { 1 };\n    ```", "```cpp\n        constexpr void do_fib() {\n            const fib_t old_b = b_;\n            b_ += a_;\n            a_  = old_b;\n        }\n    ```", "```cpp\n    public:\n        explicit fib_generator(fib_t stop = 0) : stop_{ stop } {}\n    ```", "```cpp\n        fib_t operator*() const { return b_; }\n        constexpr fib_generator& operator++() {\n            do_fib();\n            ++count_;\n            return *this;\n        }\n        fib_generator operator++(int) {\n            auto temp{ *this };\n            ++*this;\n            return temp; \n        }\n        bool operator!=(const fib_generator &o) const {\n            return count_ != o.count_; \n        }\n        bool operator==(const fib_generator&o) const { \n            return count_ == o.count_; \n        }\n        const fib_generator& begin() const { return *this; }\n        const fib_generator end() const { \n            auto sentinel = fib_generator();\n            sentinel.count_ = stop_;\n            return sentinel;\n        }\n        fib_t size() { return stop_; }\n    };\n    ```", "```cpp\n    int main() {\n        printc(fib_generator(10));\n    }\n    ```", "```cpp\n    1 1 2 3 5 8 13 21 34 55\n    ```", "```cpp\nfib_generator {\npublic:\n    fib_t operator*() const;\n    constexpr fib_generator& operator++();\n    fib_generator operator++(int);\n    bool operator!=(const fib_generator &o) const;\n    bool operator==(const fib_generator&o) const;\n    const fib_generator& begin() const;\n    const fib_generator end() const;\n};\n```", "```cpp\nconstexpr void do_fib() {\n    const fib_t old_b = b_;\n    b_ += a_;\n    a_  = old_b;\n}\n```", "```cpp\nfib_t operator*() const { return b_; }\n```", "```cpp\nconst fib_generator end() const { \n    auto sentinel = fib_generator();\n    sentinel.count_ = stop_;\n    return sentinel;\n}\n```", "```cpp\nbool operator==(const fib_generator&o) const { \n    return count_ == o.count_; \n}\n```", "```cpp\npublic:\n    using iterator_concept  = std::forward_iterator_tag;\n    using iterator_category = std::forward_iterator_tag;\n    using value_type        = std::remove_cv_t<fib_t>;\n    using difference_type   = std::ptrdiff_t;\n    using pointer           = const fib_t*;\n    using reference         = const fib_t&;\n```", "```cpp\nfib_generator fib(10);\nauto x = ranges::views::transform(fib, \n    [](unsigned long x){ return x * x; });\nprintc(x, \"squared:\");\n```", "```cpp\nsquared:: 1 1 4 9 25 64 169 441 1156 3025\n```", "```cpp\n    void printc(const auto & c, const string_view s = \"\") {\n        if(s.size()) cout << format(\"{}: \", s);\n        for(auto e : c) cout << format(\"{} \", e);\n        cout << '\\n';\n    }\n    ```", "```cpp\n    int main() {\n        int array[]{ 1, 2, 3, 4, 5 };\n        printc(array, \"c-array\");\n    }\n    ```", "```cpp\nc-array: 1 2 3 4 5\n```", "```cpp\n    auto it = std::begin(array);\n    auto end_it = std::end(array);\n    while (it != end_it) {\n        cout << format(\"{} \", *it++);\n    }\n    ```", "```cpp\n1 2 3 4 5\n```", "```cpp\n    auto it = std::rbegin(array);\n    auto end_it = std::rend(array);\n    while (it != end_it) {\n        cout << format(\"{} \", *it++);\n    }\n    ```", "```cpp\n5 4 3 2 1\n```", "```cpp\n    void printr(const auto & c, const string_view s = \"\") {\n        if(s.size()) cout << format(\"{}: \", s);\n        auto rbegin = std::rbegin(c);\n        auto rend = std::rend(c);\n        for(auto it = rbegin; it != rend; ++it) {\n            cout << format(\"{} \", *it);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\nprintr(array, \"rev c-array\");\n```", "```cpp\nrev c-array: 5 4 3 2 1\n```", "```cpp\n    vector<int> v{ 1, 2, 3, 4, 5 };\n    printc(v, \"vector\");\n    printr(v, \"rev vector\");\n    ```", "```cpp\nvector: 1 2 3 4 5\nrev vector: 5 4 3 2 1\n```", "```cpp\nvector<int> v;\nit = v.rbegin();\nit_end = v.rend();\n```", "```cpp\nstd::string s = \"string\";\n```", "```cpp\nfor (char c : \"string\") {\n    std::cout << format(\"{:02x} \", c);\n}\n```", "```cpp\n73 74 72 69 6e 67 00\n```", "```cpp\n    using sentinel_t = const char;\n    constexpr sentinel_t nullchar = '\\0';\n    ```", "```cpp\n    class cstr_it {\n        const char *s{};\n    public:\n        explicit cstr_it(const char *str) : s{str} {}\n        char operator*() const { return *s; }\n        cstr_it& operator++() {\n            ++s;\n            return *this;\n        }\n        bool operator!=(sentinel_t) const {\n            return s != nullptr && *s != nullchar;\n        }\n        cstr_it begin() const { return *this; }\n        sentinel_t end() const { return nullchar; }\n    };\n    ```", "```cpp\n    void print_cstr(const char * s) {\n        cout << format(\"{}: \", s);\n        for (char c : cstr_it(s)) {\n            std::cout << format(\"{:02x} \", c);\n        }\n        std::cout << '\\n';\n    }\n    ```", "```cpp\n    int main() {\n        const char carray[]{\"array\"};\n        print_cstr(carray);\n        const char * cstr{\"c-string\"};\n        print_cstr(cstr);\n    }\n    ```", "```cpp\narray: 61 72 72 61 79\nc-string: 63 2d 73 74 72 69 6e 67\n```", "```cpp\nsentinel_t end() const { return nullchar; }\n```", "```cpp\nbool operator!=(sentinel_t) const {\n    return s != nullptr && *s != nullchar;\n}\n```", "```cpp\n    int main()\n    {\n        vector<std::string> vec_a {\"Bob\", \"John\", \"Joni\"};\n        vector<std::string> vec_b {\"Dylan\", \"Williams\", \n            \"Mitchell\"};\n        cout << \"zipped: \";\n        for(auto [a, b] : zip_iterator(vec_a, vec_b)) {\n            cout << format(\"[{}, {}] \", a, b);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\nzipped: [Bob, Dylan] [John, Williams] [Joni, Mitchell]\n```", "```cpp\n    template<typename T>\n    class zip_iterator {\n        using val_t = typename T::value_type;\n        using ret_t = std::pair<val_t, val_t>;\n        using it_t = typename T::iterator;\n    ```", "```cpp\n    it_t ita_{};\n    it_t itb_{};\n    // for begin() and end() objects\n    it_t ita_begin_{};\n    it_t itb_begin_{};\n    it_t ita_end_{};\n    it_t itb_end_{};\n    ```", "```cpp\n    // private constructor for begin() and end() objects\n    zip_iterator(it_t ita, it_t itb) : ita_{ita}, itb_{itb} {}\n    ```", "```cpp\n    public:\n        using iterator_concept  = \n          std::forward_iterator_tag;\n        using iterator_category = \n          std::forward_iterator_tag;\n        using value_type        = std::pair<val_t, val_t>;\n        using difference_type   = long int;\n        using pointer           = const val_t*;\n        using reference         = const val_t&;\n    ```", "```cpp\n    zip_iterator(T& a, T& b) : \n        ita_{a.begin()},\n        itb_{b.begin()},\n        ita_begin_{ita_},\n        itb_begin_{itb_},\n        ita_end_{a.end()},\n        itb_end_{b.end()}\n    {}\n    ```", "```cpp\n    zip_iterator& operator++() {\n        ++ita_;\n        ++itb_;\n        return *this;\n    }\n    bool operator==(const zip_iterator& o) const {\n        return ita_ == o.ita_ || itb_ == o.itb_;\n    }\n    bool operator!=(const zip_iterator& o) const {\n        return !operator==(o);\n    }\n    ret_t operator*() const {\n        return { *ita_, *itb_ };\n    }\n    ```", "```cpp\n    zip_iterator begin() const\n        { return zip_iterator(ita_begin_, itb_begin_); }\n    zip_iterator end() const\n        { return zip_iterator(ita_end_, itb_end_); }\n    ```", "```cpp\n    int main()\n    {\n        vector<std::string> vec_a {\"Bob\", \"John\", \"Joni\"};\n        vector<std::string> vec_b {\"Dylan\", \"Williams\", \n            \"Mitchell\"};\n        cout << \"vec_a: \";\n        for(auto e : vec_a) cout << format(\"{} \", e);\n        cout << '\\n';\n        cout << \"vec_b: \";\n        for(auto e : vec_b) cout << format(\"{} \", e);\n        cout << '\\n';\n        cout << \"zipped: \";\n        for(auto [a, b] : zip_iterator(vec_a, vec_b)) {\n            cout << format(\"[{}, {}] \", a, b);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n    vec_a: Bob John Joni\n    vec_b: Dylan Williams Mitchell\n    zipped: [Bob, Dylan] [John, Williams] [Joni, Mitchell]\n    ```", "```cpp\nzip_iterator(T& a, T& b) : \n    ita_{a.begin()},\n    itb_{b.begin()},\n    ita_begin_{ita_},\n    itb_begin_{itb_},\n    ita_end_{a.end()},\n    itb_end_{b.end()}\n{}\n```", "```cpp\nit_t ita_{};\nit_t itb_{};\n// for begin() and end() objects\nit_t ita_begin_{};\nit_t itb_begin_{};\nit_t ita_end_{};\nit_t itb_end_{};\n```", "```cpp\nusing val_t = typename T::value_type;\nusing ret_t = std::pair<val_t, val_t>;\nusing it_t = typename T::iterator;\n```", "```cpp\nzip_iterator begin() const\n  { return zip_iterator(ita_begin_, itb_begin_); }\nzip_iterator end() const\n  { return zip_iterator(ita_end_, itb_end_); }\n```", "```cpp\n// private constructor for begin() and end() objects\nzip_iterator(it_t ita, it_t itb) : ita_{ita}, itb_{itb} {}\n```", "```cpp\nzip_iterator& operator++() {\n    ++ita_;\n    ++itb_;\n    return *this;\n}\nbool operator==(const zip_iterator& o) const {\n    return ita_ == o.ita_ || itb_ == o.itb_;\n}\nbool operator!=(const zip_iterator& o) const {\n    return !operator==(o);\n}\n```", "```cpp\nret_t operator*() const {\n    return { *ita_, *itb_ };\n}\n```", "```cpp\nmap<string, string> name_map{};\nfor(auto [a, b] : zip_iterator(vec_a, vec_b)) {\n    name_map.try_emplace(a, b);\n}\ncout << \"name_map: \";\nfor(auto [a, b] : name_map) {\n    cout << format(\"[{}, {}] \", a, b);\n}\ncout << '\\n';\n```", "```cpp\nname_map: [Bob, Dylan] [John, Williams] [Joni, Mitchell]\n```", "```cpp\n    template<typename T>\n    class Container {\n        std::unique_ptr<T[]> c_{};\n        size_t n_elements_{};\n    ```", "```cpp\n    Container(initializer_list<T> l) : n_elements_{l.size()} {\n        c_ = std::make_unique<T[]>(n_elements_);\n        size_t index{0};\n        for(T e : l) {\n            c_[index++] = e;\n        }\n    }\n    ```", "```cpp\n    Container(size_t sz) : n_elements_{sz} {\n        c_ = std::make_unique<T[]>(n_elements_);\n    }\n    ```", "```cpp\n    size_t size() const {\n        return n_elements_;\n    }\n    ```", "```cpp\n    const T& operator[](const size_t index) const {\n        return c_[index];\n    }\n    ```", "```cpp\n    T& at(const size_t index) const {\n        if(index > n_elements_ - 1) {\n            throw std::out_of_range(\n                \"Container::at(): index out of range\"\n            );\n        }\n        return c_[index];\n    }\n    ```", "```cpp\n    iterator begin() const { return iterator(c_.get()); }\n    iterator end() const { \n        return iterator(c_.get() + n_elements_); \n    }\n    ```", "```cpp\n    class iterator {\n        T* ptr_;\n    ```", "```cpp\n    iterator(T* ptr = nullptr) : ptr_{ptr} {}\n    ```", "```cpp\n    const auto operator<=>(const iterator& o) const {\n        return ptr_ <=> o.ptr_;\n    }\n    ```", "```cpp\n    iterator operator+(const size_t n) const {\n        return iterator(ptr_ + n);\n    }\n    // non-member operator (n + it)\n    friend const iterator operator+(\n            const size_t n, const iterator& o) {\n        return iterator(o.ptr_ + n);\n    }\n    ```", "```cpp\n    const iterator operator-(const size_t n) {\n        return iterator(ptr_ - n);\n    }\n    const size_t operator-(const iterator& o) {\n        return ptr_ - o.ptr_;\n    }\n    ```", "```cpp\n    Container<string> x{\"one\", \"two\", \"three\", \"four\", \"five\", \n        \"six\", \"seven\", \"eight\", \"nine\", \"ten\" };\n    cout << format(\"Container x size: {}\\n\", x.size());\n    ```", "```cpp\nContainer x size: 10\n```", "```cpp\n    puts(\"Container x:\");\n    for(auto e : x) {\n        cout << format(\"{} \", e);\n    }\n    cout << '\\n';\n    ```", "```cpp\nContainer x:\none two three four five six seven eight nine ten\n```", "```cpp\n    puts(\"direct access elements:\");\n    cout << format(\"element at(5): {}\\n\", x.at(5));\n    cout << format(\"element [5]: {}\\n\", x[5]);\n    cout << format(\"element begin + 5: {}\\n\",\n        *(x.begin() + 5));\n    cout << format(\"element 5 + begin: {}\\n\",\n        *(5 + x.begin()));\n    cout << format(\"element begin += 5: {}\\n\",\n        *(x.begin() += 5));\n    ```", "```cpp\ndirect access elements:\nelement at(5): six\nelement [5]: six\nelement begin + 5: six\nelement 5 + begin: six\nelement begin += 5: six\n```", "```cpp\n    puts(\"views pipe reverse:\");\n    auto result = x | views::reverse;\n    for(auto v : result) cout << format(\"{} \", v);\n    cout << '\\n';\n    ```", "```cpp\nviews pipe reverse:\nten nine eight seven six five four three two one\n```", "```cpp\n    Container<string> y(x.size());\n    cout << format(\"Container y size: {}\\n\", y.size());\n    for(auto e : y) {\n        cout << format(\"[{}] \", e);\n    }\n    cout << '\\n';\n    ```", "```cpp\nContainer y size: 10\n[] [] [] [] [] [] [] [] [] []\n```"]