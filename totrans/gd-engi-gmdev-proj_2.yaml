- en: Coin Dash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first project will guide you through making your first Godot Engine project.
    You will learn how the Godot editor works, how to structure a project, and how
    to build a small 2D game.
  prefs: []
  type: TYPE_NORMAL
- en: Why 2D? In a nutshell, 3D games are much more complex than 2D ones, while many
    of the underlying game engine features you'll need to know are the same. You should
    stick to 2D until you have a good understanding of Godot's game development process.
    At that point, the jump to 3D will be much easier. You'll get an introduction
    to 3D in this book's fifth and final project.
  prefs: []
  type: TYPE_NORMAL
- en: Important—don't skip this chapter, even if you aren't a complete newcomer to
    game development. While you may already understand many of the underlying concepts,
    this project will introduce a number of fundamental Godot features and design
    paradigms that you'll need to know going forward. You'll build on these concepts
    as you develop more complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game in this chapter is called **Coin Dash**. Your character must move
    around the screen, collecting as many coins as possible while racing against the
    clock. When you''re finished, the game will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb31cc37-3e97-4f1a-b439-ab4ae34ba914.png)'
  prefs: []
  type: TYPE_IMG
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launch Godot and create a new project, making sure to use the `Create Folder`
    button to ensure that this project's files will be kept separate from other projects.
    You can download a Zip file of the art and sounds (collectively known as *assets*)
    for the game here, [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip this file in your new project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you will make three independent scenes: `Player`, `Coin`,
    and `HUD`, which will all be combined into the game''s `Main` scene. In a larger
    project, it might be useful to make separate folders to hold each scene''s assets
    and scripts, but for this relatively small game, you can save your scenes and
    scripts in the root folder, which is referred to as `res://` (**res** is short
    for **resource**). All resources in your project will be located relative to the
    `res://` folder. You can see your project folders in the FileSystem dock in the
    upper-left corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da01d068-22d9-4154-865b-55d2b5d56653.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, the images for the coin would be located in `res://assets/coin/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This game will use portrait mode, so you need to adjust the size of the game
    window. Click on the Project menu and select Project Settings, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68340ddf-2879-4c4e-8de4-50d11c604ca6.png)'
  prefs: []
  type: TYPE_IMG
- en: Look for the Display/Window section and set Width to `480` and Height to `720`.
    Also in this section, set the Stretch/Mode to `2D` and the Aspect to `keep`. This
    will ensure that if the user resizes the game window, everything will scale appropriately
    and not become stretched or deformed. If you like, you can also uncheck the box
    for Resizable, to prevent the window from being resized entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors and 2D coordinate systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note: This section is a very brief overview of 2D coordinate systems and does
    not delve very deeply into vector math. It is intended as a high-level overview
    of how such topics apply to game development in Godot. Vector math is an essential
    tool in game development, so if you need a broader understanding of the topic,
    see Khan Academy''s Linear Algebra series ([https://www.khanacademy.org/math/linear-algebra](https://www.khanacademy.org/math/linear-algebra)).'
  prefs: []
  type: TYPE_NORMAL
- en: When working in 2D, you'll be using Cartesian coordinates to identify locations
    in space. A particular position in 2D space is written as a pair of values, such
    as `(4,3)`, representing the position along the *x* and *y* axes, respectively.
    Any position in the 2D plane can be described in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2D space, Godot follows the common computer graphics practice of orienting
    the *x* axis to the right, and the *y *axis down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca915bf3-623f-40ae-82ae-82e955469657.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're new to computer graphics or game development, it might seem odd that
    the positive y axis points downwards instead of upwards, as you likely learned
    in math class. However, this orientation is very common in computer graphics applications.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also think of the position `(4, 3)` as an *offset* from the `(0, 0)`
    point, or *origin*. Imagine an arrow pointing from the origin to the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39c80d8b-3a07-4d97-b2e7-6cd3bcf9a018.png)'
  prefs: []
  type: TYPE_IMG
- en: This arrow is a *vector*. It represents a great deal of useful information including
    the point's location, *(4, 3)*, its length, *m,* and its angle from the *x*-axis, *θ*.
    Altogether, this is a *position vector*, in other words, it describes a position
    in space. Vectors can also represent movement, acceleration, or any other quantity
    that has an *x* and a *y* component.
  prefs: []
  type: TYPE_NORMAL
- en: In Godot, vectors (`Vector2` for 2D or `Vector3` for 3D) are widely used, and
    you'll use them in the course of building the projects in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector coordinates in Godot are *floating point *numbers, not *integers*. This
    means a `Vector2` could have a fractional value, such as `(1.5, 1.5)`. Since objects
    can't be drawn at half pixels, this can cause visual problems for pixel art games
    where you want to ensure that all the pixels of the textures are drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, open Project *|* Project Settings and find the Rendering*/*Quality
    section in the sidebar and enable Use Pixel Snap, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ed78c29-4592-4b3e-9bc8-bfe5ffa7231e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're using 2D pixel art in your game, it's a good idea to always enable
    this setting when you start your project. This setting has no effect in 3D games.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 – Player scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first scene you'll make defines the Player object. One of the benefits of
    creating a separate player scene is that you can test it independently, even before
    you've created the other parts of the game. This separation of game objects will
    become more and more helpful as your projects grow in size and complexity. Keeping
    individual game objects separate from each other makes them easier to troubleshoot,
    modify, and even replace entirely without affecting other parts of the game. It
    also makes your player reusable—you can drop the player scene into an entirely
    different game and it will work just the same.
  prefs: []
  type: TYPE_NORMAL
- en: The player scene will display your character and its animations, respond to
    user input by moving the character accordingly, and detect collisions with other
    objects in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by clicking the Add/Create a New Node button and selecting an `Area2D`.
    Then, click on its name and change it to `Player`. Click Scene | Save Scene to
    save the scene. This is the scene''s *root* or top-level node. You''ll add more
    functionality to the `Player` by adding children to this node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3d3a922-aed8-4e71-9ff9-49fdc5914bf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before adding any children, it''s a good idea to make sure you don''t accidentally
    move or resize them by clicking on them. Select the `Player` node and click the
    icon next to the lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fd87149-4a24-4032-b6b6-e3f773902c5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The tooltip will say Make sure the object's children are not selectable, as
    shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to always do this when creating a new scene. If a body's collision
    shape or sprite becomes offset or scaled, it can cause unexpected errors and be
    difficult to fix. With this option, the node and all of its children will always
    move together.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `Area2D`, you can detect when other objects overlap or run into the player,
    but `Area2D` doesn''t have an appearance on its own, so click on the `Player`
    node and add an `AnimatedSprite` node as a child. The `AnimatedSprite` will handle
    the appearance and animations for your player. Note that there is a warning symbol
    next to the node. An `AnimatedSprite` requires a `SpriteFrames` resource, which
    contains the animation(s) it can display. To create one, find the Frame*s* property
    in the Inspector and click <null> | New SpriteFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdf18587-9141-4140-b1f5-9012ae14abed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in the same location, click <SpriteFrames> to open the SpriteFrames panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35433857-e4e5-468f-b5f9-21dfac5677c4.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left is a list of animations. Click the default one and rename it to
    `run`. Then, click the **Add** button and create a second animation named `idle`
    and a third named `hurt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the FileSystem dock on the left, find the `run`, `idle`, and `hurt` player
    images and drag them into the corresponding animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecbd50f8-2381-442f-b78f-bad1617e3805.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each animation has a default speed setting of 5 frames per second. This is
    a little too slow, so click on each of the animations and set the Speed (FPS)
    setting to 8\. In the Inspector, check On next to the Playing property and choose
    an Animation to see the animations in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d0c491a-0a37-4e6c-8496-3ede2e5c2bec.png)'
  prefs: []
  type: TYPE_IMG
- en: Later, you'll write code to select between these animations, depending on what
    the player is doing. But first, you need to finish setting up the player's nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Collision shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `Area2D`, or one of the other collision objects in Godot, it needs
    to have a shape defined, or it can't detect collisions. A collision shape defines
    the region that the object occupies and is used to detect overlaps and/or collisions.
    Shapes are defined by `Shape2D`, and include rectangles, circles, polygons, and
    other types of shapes.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, when you need to add a shape to an area or physics body, you
    can add a `CollisionShape2D` as a child. You then select the type of shape you
    want and you can edit its size in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `CollisionShape2D` as a child of `Player` (make sure you don''t add it
    as a child of the `AnimatedSprite`). This will allow you to determine the player''s
    *hitbox*, or the bounds of its collision area. In the Inspector, next to Shape,
    click <null> and choose New RectangleShape2D. Adjust the shape''s size to cover
    the sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a8ef3be-7d4e-43b1-82c9-a4ae34e73e1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Be careful not to scale the shape's outline! Only use the size handles (red)
    to adjust the shape! Collisions will not work properly with a scaled collision
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the collision shape is not centered on the sprite.
    That is because the sprites themselves are not centered vertically. We can fix
    this by adding a small offset to the `AnimatedSprite`. Click on the node and look
    for the Offset property in the Inspector. Set it to `(0, -5)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re finished, your `Player` scene should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a4017f4-dd2b-42b2-87cd-bd432721e916.png)'
  prefs: []
  type: TYPE_IMG
- en: Scripting the Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you''re ready to add a script. Scripts allow you to add additional functionality
    that isn''t provided by the built-in nodes. Click the `Player` node and click
    the **Add Script** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad8eb48-bfa9-4178-9e96-22ed50cb2717.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Script Settings window, you can leave the default settings as they are.
    If you''ve remembered to save the scene (see the preceding screenshot), the script
    will automatically be named to match the scene''s name. Click Create and you''ll
    be taken to the script window. Your script will contain some default comments
    and hints. You can remove the comments (lines starting with `#`). Refer to the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of every script will describe what type of node it is attached
    to. Next, you''ll define your class variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `export` keyword on the `speed` variable allows you to set its value
    in the Inspector, as well as letting the Inspector know what type of data the
    variable should contain. This can be very handy for values that you want to be
    able to adjust, just like you adjust a node''s built-in properties. Click on the **`Player`**
    node and set the Speed property to 350, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75818a32-be07-40e7-8d2a-b20764a4a2ab.png)'
  prefs: []
  type: TYPE_IMG
- en: '`velocity` will contain the character''s current movement speed and direction,
    and `screensize` will be used to set the limits of the player''s movement. Later,
    the game''s main scene will set this variable, but for now you will set it manually
    so you can test.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, you''ll use the `_process()` function to define what the player will
    do. The `_process()` function is called on every frame, so you''ll use it to update
    elements of your game that you expect to be changing often. You need the player
    to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for keyboard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move in the given direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play the appropriate animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, you need to check the inputs. For this game, you have four directional
    inputs to check (the four arrow keys). Input actions are defined in the project
    settings under the Input Map tab. In this tab, you can define custom events and
    assign different keys, mouse actions, or other inputs to them. By default, Godot
    has events assigned to the keyboard arrows, so you can use them for this project.
  prefs: []
  type: TYPE_NORMAL
- en: You can detect whether an input is pressed using `Input.is_action_pressed()`,
    which returns `true` if the key is held down and `false` if it is not. Combining
    the states of all four buttons will give you the resultant direction of movement. For
    example, if you hold `right` and `down` at the same time, the resulting velocity
    vector will be `(1, 1)`. In this case, since we’re adding a horizontal and a vertical
    movement together, the player would move *faster* than if they just moved horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent that by *normalizing* the velocity, which means setting its length
    to **1**, then multiplying it by the desired speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By grouping all of this code together in a `get_input()` function, you make
    it easier to change things later. For example, you could decide to change to an
    analog joystick or other type of controller. Call this function from `_process()`
    and then change the player''s `position` by the resulting `velocity`. To prevent
    the player from leaving the screen, you can use the `clamp()` function to limit
    the position to a minimum and maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Click Play the Edited Scene (*F6*) and confirm that you can move the player
    around the screen in all directions.
  prefs: []
  type: TYPE_NORMAL
- en: About delta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `_process()` function includes a parameter called `delta` that is then multiplied
    by the velocity. What is `delta`?
  prefs: []
  type: TYPE_NORMAL
- en: The game engine attempts to run at a consistent 60 frames per second. However,
    this can change due to computer slowdowns, either in Godot or from the computer
    itself. If the frame rate is not consistent, then it will affect the movement
    of your game objects. For example, consider an object set to move `10` pixels
    every frame. If everything is running smoothly, this will translate to moving
    `600` pixels in one second. However, if some of those frames take longer, then
    there may only have been 50 frames in that second, so the object only moved `500`
    pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Godot, like most game engines and frameworks, solves this by passing you `delta`,
    which is the elapsed time since the previous frame. Most of the time, this will
    be around `0.016` s (or around 16 milliseconds). If you then take your desired
    speed (`600` px/s) and multiply by delta, you will get a movement of exactly `10`.
    If, however, the `delta` increased to `0.3`, then the object will be moved `18`
    pixels. Overall, the movement speed remains consistent and independent of the
    frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: As a side benefit, you can express your movement in units of px/s rather than
    px/frame, which is easier to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the player can move, you need to change which animation the `AnimatedSprite`
    is playing based on whether it is moving or standing still. The art for the `run`
    animation faces to the right, which means it should be flipped horizontally (using
    the Flip H property) for movement to the left. Add this to the end of your `_process()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this code takes a little shortcut. `flip_h` is a Boolean property,
    which means it can be `true` or `false`. A Boolean value is also the result of
    a comparison like `<`. Because of this, we can set the property equal to the result
    of the comparison. This one line is equivalent to writing it out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Play the scene again and check that the animations are correct in each case.
    Make sure Playing is set to On in the `AnimatedSprite` so that the animations
    will play.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and Ending the Player's Movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the game starts, the main scene will need to inform the player that the
    game has begun. Add the `start()` function as follows, which the main scene will
    use to set the player''s starting animation and position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `die()` function will be called when the player hits an obstacle or runs
    out of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting `set_process(false)` causes the `_process()` function to no longer be
    called for this node. That way, when the player has died, they can't still be
    moved by key input.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player should detect when it hits a coin or an obstacle, but you haven't
    made them do so yet. That's OK, because you can use Godot's *signal* functionality
    to make it work. Signals are a way for nodes to send out messages that other nodes
    can detect and react to. Many nodes have built-in signals to alert you when a
    body collides, for example, or when a button is pressed. You can also define custom
    signals for your own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are used by *connecting* them to the node(s) that you want to listen
    and respond to. This connection can be made in the Inspector or in the code. Later
    in the project, you'll learn how to connect signals in both ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the top of the script (after `extends Area2D`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'These define custom signals that your player will *emit* (send out) when they
    touch a coin or an obstacle. The touches will be detected by the `Area2D` itself.
    Select the `Player` node and click the Node tab next to the Inspector to see the
    list of signals the player can emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9185835-315c-4d67-a59e-bc74f7a578de.png)'
  prefs: []
  type: TYPE_IMG
- en: Note your custom signals are there as well. Since the other objects will also
    be `Area2D` nodes, you want the `area_entered()` signal. Select it and click Connect.
    Click Connect on the Connecting Signal window—you don't need to change any of
    those settings. Godot will automatically create a new function called `_on_Player_area_entered()`
    in your script.
  prefs: []
  type: TYPE_NORMAL
- en: When connecting a signal, instead of having Godot create a function for you,
    you can also give the name of an existing function that you want to link the signal
    to. Toggle the Make Function switch to Off if you don't want Godot to create the
    function for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When another `Area2D` is detected, it will be passed in to the function (using
    the `area` variable). The coin object will have a `pickup()` function that defines
    the coin's behavior when picked up (playing an animation or sound, for example).
    When you create the coins and obstacles, you'll assign them to the appropriate *group*
    so they can be detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, here is the complete player script so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Part 2 – Coin scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you'll make the coins for the player to collect. This will be
    a separate scene describing all of the properties and behavior of a single coin.
    Once saved, the main scene will load the coin scene and create multiple *instances*
    (that is, copies) of it.
  prefs: []
  type: TYPE_NORMAL
- en: Node setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click Scene | New Scene and add the following nodes. Don''t forget to set the
    children to not be selected, like you did with the `Player` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Area2D` (named `Coin`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnimatedSprite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionShape2D`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to save the scene once you've added the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the `AnimatedSprite` like you did in the Player scene. This time, you
    only have one animation: a shine/sparkle effect that makes the coin look less
    flat and boring. Add all the frames and set the Speed (FPS) to `12`. The images
    are a little too large, so set the Scale of `AnimatedSprite` to (`0.5`, `0.5`). In
    the `CollisionShape2D`, use a `CircleShape2D` and size it to cover the coin image.
    Don''t forget: never use the scale handles when sizing a collision shape. The
    circle shape has a single handle that adjusts the circle''s radius.'
  prefs: []
  type: TYPE_NORMAL
- en: Using groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Groups provide a tagging system for nodes, allowing you to identify similar
    nodes. A node can belong to any number of groups. You need to ensure that all
    coins will be in a group called `coins` for the player script to react correctly
    to touching the coin. Select the `Coin` node and click the Node tab (the same
    tab where you found the signals) and choose Groups. Type `coins` in the box and
    click Add, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a78fbbfd-ccbd-4839-94e7-93c779802cb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, add a script to the `Coin` node. If you choose Empty in the Template
    setting, Godot will create an empty script without any comments or suggestions.
    The code for the coin''s script is much shorter than the code for the player''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `pickup()` function is called by the player script and tells the coin what
    to do when it's been collected. `queue_free()` is Godot's node removal method.
    It safely removes the node from the tree and deletes it from memory along with
    all of its children. Later, you'll add a visual effect here, but for now the coin
    disappearing is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: '`queue_free()` doesn''t delete the object immediately, but rather adds it to
    a queue to be deleted at the end of the current frame. This is safer than immediately
    deleting the node, because other code running in the game may still need the node
    to exist. By waiting until the end of the frame, Godot can be sure that all code
    that may access the node has completed and the node can be removed safely.'
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Main scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Main` scene is what ties all the pieces of the game together. It will manage
    the player, the coins, the timer, and the other pieces of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Node setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new scene and add a node named `Main`. To add the player to the scene,
    click the Instance button and select your saved `Player.tscn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a92b792-40d0-4f3b-8a08-8b6d320bb361.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, add the following nodes as children of **`Main`**, naming them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextureRect` (named `Background`)—for the background image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node` (named `CoinContainer`)—to hold all the coins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Position2D` (named `PlayerStart`)—to mark the starting position of the `Player`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timer` (named `GameTimer`)—to track the time limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure `Background` is the first child node. Nodes are drawn in the order
    shown, so the background will be *behind* the player in this case. Add an image
    to the `Background` node by dragging the `grass.png` image from the `assets` folder
    into the Texture property. Change the Stretch Mode to Tile and then click Layout |
    Full Rect to size the frame to the size of the screen, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5db2311-3858-4d2d-9f68-b541cd25c73e.png)'
  prefs: []
  type: TYPE_IMG
- en: Set the Position of the `PlayerStart` node to (`240`, `350`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your scene layout should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f386340e-6416-47c7-9bab-04ffc829f3e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Main script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a script to the `Main` node (use the Empty template) and add the following
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Coin` and `Playtime` properties will now appear in the Inspector when you
    click on `Main`. Drag `Coin.tscn` from the FileSystem panel and drop it in the
    `Coin` property. Set `Playtime` to `30` (this is the amount of time the game will
    last). The remaining variables will be used later in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, add the `_ready()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In GDScript, you can use `$` to refer to a particular node by name. This allows
    you to find the size of the screen and assign it to the player's `screensize`
    variable. `hide()` makes the player start out invisible (you'll make them appear
    when the game actually starts).
  prefs: []
  type: TYPE_NORMAL
- en: In the `$` notation, the node name is relative to the node running the script.
    For example, `$Node1/Node2` would refer to a node (`Node2`) that is the child
    of `Node1`, which itself is a child of the currently running script. Godot's autocomplete
    will suggest node names from the tree as you type. Note that if the node's name
    contains spaces, you must put quote marks around it, for example, `$"My Node"`.
  prefs: []
  type: TYPE_NORMAL
- en: You must use `randomize()` if you want your sequence of "random" numbers to
    be different every time you run the scene. Technically speaking, this selects
    a random *seed* for the random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, the `new_game()` function will initialize everything for a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In addition to setting the variables to their starting values, this function
    calls the Player's `start()` function to ensure it moves to the proper starting
    location. The game timer is started, which will count down the remaining time
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need a function that will create a number of coins based on the current
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this function, you create a number of *instances* of the `Coin` object (in
    code this time, rather than by clicking the Instance a Scene button), and add
    it as a child of the `CoinContainer`. Whenever you instance a new node, it must
    be added to the tree using `add_child()`. Finally, you pick a random location
    for the coin to appear in. You'll call this function at the start of every level,
    generating more coins each time.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, you'll want `new_game()` to be called when the player clicks the
    start button. For now, to test if everything is working, add `new_game()` to the
    end of your `_ready()` function and click Play the Project (*F5*). When you are
    prompted to choose a main scene, choose `Main.tscn`. Now, whenever you play the
    project, the `Main` scene will be started.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should see your player and five coins appear on the screen.
    When the player touches a coin, it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for remaining coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main script needs to detect whether the player has picked up all of the
    coins. Since the coins are all children of `CoinCointainer`, you can use `get_child_count()` on
    this node to find out how many coins remain. Put this in the `_process()` function
    so that it will be checked every frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If no more coins remain, then the player advances to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4 – User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece your game needs is a **user interface** (**UI**). This is an
    interface to display information that the player needs to see during gameplay.
    In games, this is also referred to as a **Heads-Up Display** (**HUD**), because
    the information appears as an overlay on top of the game view. You'll also use
    this scene to display a start button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HUD will display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time remaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message, such as Game Over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A start button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new scene and add a `CanvasLayer` node named `HUD`. A `CanvasLayer`
    node allows you to draw your UI elements on a layer above the rest of the game,
    so that the information it displays doesn't get covered up by any game elements
    like the player or the coins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Godot provides a wide variety of UI elements that may be used to create anything
    from indicators such as health bars to complex interfaces such as inventories.
    In fact, the Godot editor that you are using to make this game is built in Godot
    using these elements. The basic nodes for UI elements are extended from `Control`,
    and appear with green icons in the node list. To create your UI, you''ll use various `Control` nodes
    to position, format, and display information. Here is what the `HUD` will look
    like when complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/411c8887-5143-479b-beb0-4d946750ecf9.png)'
  prefs: []
  type: TYPE_IMG
- en: Anchors and margins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control nodes have a position and size, but they also have properties called
    **anchors** and **margins**. Anchors define the origin, or the reference point,
    for the edges of the node, relative to the parent container. Margins represent
    the distance from the control node's edge to its corresponding anchor. Margins
    update automatically when you move or resize a control node.
  prefs: []
  type: TYPE_NORMAL
- en: Message label
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a `Label` node to the scene and change its name to `MessageLabel`**.** This
    label will display the game's title, as well as Game Over when the game ends.
    This label should be centered on the game screen. You could drag it with the mouse,
    but to place UI elements precisely, you should use the Anchor properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select View | Show Helpers to display pins that will help you see the anchor
    positions, then click on the Layout menu and select HCenter Wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f5b428f-6302-4511-aaf7-e91d1bbd08c4.png)'
  prefs: []
  type: TYPE_IMG
- en: The `MessageLabel` now spans the width of the screen and is centered vertically.
    The Text property in the Inspector sets what text the label displays. Set it to
    Coin Dash! and set Align and Valign to Center.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default font for `Label` nodes is very small, so the next step is to assign
    a custom font. Scroll down to the Custom Fonts section in the Inspector and select New
    DynamicFont, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d7b544c-402b-47e6-8d68-cf565dce4e12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on DynamicFont and you can adjust the font settings. From the FileSystem
    dock, drag the `Kenney Bold.ttf` font and drop it in the Font Dataproperty. Set Sizeto **`48`**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97adefb7-88eb-42d6-864c-a437a821ff03.png)'
  prefs: []
  type: TYPE_IMG
- en: Score and time display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The top of the `HUD` will display the player's score and the time remaining
    on the clock. Both of these will be `Label` nodes, arranged at opposite sides
    of the game screen. Rather than position them separately, you'll use a `Container`
    node to manage their positions.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI containers automatically arrange the positions of their child `Control` nodes
    (including other `Containers`). You can use them to add padding around elements,
    center them, or arrange elements in rows or columns. Each type of `Container`
    has special properties that control how they arrange their children. You can see
    these properties in the Custom Constants section of the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that containers *automatically* arrange their children. If you move
    or resize a Control that's inside a `Container` node, you'll find it snaps back
    to its original position. You can manually arrange controls *or* arrange them
    with a container, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the score and time labels, add a **`MarginContainer`** node to the **`HUD`.**
    Use the Layout menu to set the anchors to Top Wide. In the Custom Constants section,
    set Margin Right, Margin Top, and Margin Left to `10`. This will add some padding
    so that the text isn't against the edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Since the score and time labels will use the same font settings as the `MessageLabel`,
    it will save time if you duplicate it. Click on `MessageLabel` and press *Ctrl*
    + *D* (*Cmd* + *D* on macOS) twice to create two duplicate labels. Drag them both
    and drop them on the `MarginContainer` to make them its children. Name one `ScoreLabel`
    and the other `TimeLabel` and set the Text property to `0` for both. Set Align
    to Left for `ScoreLabel` and Right for **`TimeLabel`.**
  prefs: []
  type: TYPE_NORMAL
- en: Updating UI via GDScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a script to the `HUD` node. This script will update the UI elements when
    their properties need to change, updating the score text whenever a coin is collected,
    for example. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main` scene''s script will call these functions to update the display
    whenever there is a change in value. For the `MessageLabel`, you also need a timer
    to make it disappear after a brief period. Add a `Timer` node and change its name
    to `MessageTimer`**. **In the Inspector, set its Wait Time to `2` seconds and
    check the box to set One Shot to On. This ensures that, when started, the timer
    will only run once, rather than repeating. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, you display the message and start the timer. To hide the
    message, connect the `timeout()` signal of `MessageTimer` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a `Button` node and change its name to `StartButton`**. **This button will
    be displayed before the game starts, and when clicked, it will hide itself and
    send a signal to the `Main` scene to start the game. Set the Text property to
    Start and change the custom font like you did with the **`MessageLabel`.** In
    the Layout menu, choose Center Bottom. This will put the button at the very bottom
    of the screen, so move it up a little bit either by pressing the *Up* arrow key
    or by editing the margins and setting Top to `-150` and Bottom to `-50`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a button is clicked, a signal is sent out. In the Node tab for the `StartButton`,
    connect the `pressed()` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `HUD` emits the `start_game` signal to notify `Main` that it's time to start
    a new game.
  prefs: []
  type: TYPE_NORMAL
- en: Game over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final task for your UI is to react to the game ending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this function, you need the Game Over message to be displayed for two seconds
    and then disappear, which is what `show_message()` does. However, you also want
    to show the start button once the message has disappeared. The `yield()` function
    pauses execution of the function until the given node (`MessageTimer`) emits a
    given signal (`timeout`). Once the signal is received, the function continues,
    returning you to the initial state so that you can play again.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the HUD to Main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you need to set up the communication between the `Main` scene and the
    `HUD`. Add an instance of the `HUD` scene to the `Main` scene. In the `Main` scene,
    connect the `timeout()` signal of `GameTimer` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every time the `GameTimer` times out (every second), the remaining time is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, connect the `pickup()` and `hurt()` signals of the `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Several things need to happen when the game ends, so add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function halts the game, and also loops through the coins and removes any
    that are remaining, as well as calling the HUD's `show_game_over()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `StartButton` needs to activate the `new_game()` function. Click
    on the `HUD` instance and select its `new_game()` signal. In the signal connection
    dialog, click Make Function to Off and in the Method In Node field, type `new_game`.
    This will connect the signal to the existing function rather than creating a new
    one. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11c6a09e-56be-439d-ab35-d6e382bac764.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remove `new_game()` from the `_ready()` function and add these two lines to
    the `new_game()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can play the game! Confirm that all the parts are working as intended:
    the score, the countdown, the game ending and restarting, and so on. If you find
    a piece that''s not working, go back and check the step where you created it,
    as well as the step(s) where it was connected to the rest of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Part 5 – Finishing up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created a working game, but it still could be made to feel a little
    more exciting. Game developers use the term *juice* to describe the things that
    make the game feel good to play. Juice can include things like sound, visual effects,
    or any other addition that adds to the player's enjoyment, without necessarily
    changing the nature of the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll add some small *juicy* features to finish up the game.
  prefs: []
  type: TYPE_NORMAL
- en: Visual effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you pick up the coins, they just disappear, which is not very appealing.
    Adding a visual effect will make it much more satisfying to collect lots of coins.
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding a `Tween` node to the `Coin` scene.
  prefs: []
  type: TYPE_NORMAL
- en: What is a tween?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **tween** is a way to interpolate (change gradually) some value over time
    (from a start value to an end value) using a particular function. For example,
    you might choose a function that steadily changes the value or one that starts
    slow but ramps up in speed. Tweening is also sometimes referred to as *easing*.
  prefs: []
  type: TYPE_NORMAL
- en: When using a `Tween` node in Godot, you can assign it to alter one or more properties
    of a node. In this case, you're going to increase the `Scale` of the coin and
    also cause it to fade out using the Modulate property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to the `_ready()` function of `Coin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `interpolate_property()` function causes the `Tween` to change a node''s
    property. There are seven parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The node to affect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property to alter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property's starting value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property's ending value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration (in seconds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tween should start playing when the player picks up the coin. Replace `queue_free()`
    in the `pickup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Setting `monitoring` to `false` ensures that the `area_enter()` signal won't
    be emitted if the player touches the coin during the tween animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the coin should be deleted when the animation finishes, so connect
    the `Tween` node''s `tween_completed()` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run the game, you should see the coins growing larger when they''re
    picked up. This is good, but tweens are even more effective when applied to multiple
    properties at once. You can add another `interpolate_property()`, this time to
    change the sprite''s opacity. This is done by altering the `modulate` property,
    which is a `Color` object, and changing its alpha channel from `1` (opaque) to
    `0` (transparent). Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound is one of the most important but often neglected pieces of game design.
    Good sound design can add a huge amount of juice to your game for a very small
    amount of effort. Sounds can give the player feedback, connect them emotionally
    to the characters, or even be a part of the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: For this game, you're going to add three sound effects. In the `Main` scene,
    add three `AudioStreamPlayer` nodes and name them `CoinSound`, `LevelSound`, and
    `EndSound`. Drag each sound from the `audio` folder (you can find it under `assets`
    in the FileSystem dock) into the corresponding Stream property of each node.
  prefs: []
  type: TYPE_NORMAL
- en: To play a sound, you call the `play()` function on it. Add `$CoinSound.play()` to
    the `_on_Player_pickup()` function, `$EndSound.play()` to the `game_over()` function,
    and `$LevelSound.play()` to the `spawn_coins()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Powerups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many possibilities for objects that give the player a small advantage
    or powerup. In this section, you'll add a powerup item that gives the player a
    small time bonus when collected. It will appear occasionally for a short time,
    then disappear.
  prefs: []
  type: TYPE_NORMAL
- en: The new scene will be very similar to the `Coin` scene you already created,
    so click on your `Coin` scene and choose Scene | Save Scene As and save it as
    `Powerup.tscn`. Change the name of the root node to Powerup and remove the script
    by clicking the clear script button: ![](img/339a2688-7234-4719-ad21-aab4c86419c9.png).
    You should also disconnect the `area_entered` signal (you'll reconnect it later).
    In the Groups tab, remove the coins group by clicking the delete button (it looks
    like a trash can) and adding it to a new group called `powerups` instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AnimatedSprite`, change the images from the coin to the powerup, which
    you can find in the `res://assets/pow/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Click to add a new script and copy the code from the `Coin.gd` script. Change
    the name of `_on_Coin_area_entered` to `_on_Powerup_area_entered` and connect
    the `area_entered` signal to it again. Remember, this function name will automatically
    be chosen by the signal connect window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a `Timer` node named `Lifetime`. This will limit the amount of time
    the object remains on the screen. Set its Wait Time to `2` and both One Shot and
    Autostart to `On`. Connect its timeout signal so that it can be removed at the
    end of the time period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, go to your Main scene and add another `Timer` node called `PowerupTimer`.
    Set its One Shot property to On. There is also a `Powerup.wav` sound in the `audio`
    folder you can add with another `AudioStreamPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `timeout` signal and add the following code to spawn a `Powerup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Powerup` scene needs to be linked by adding a variable, then dragging
    the scene into the property in the Inspector, as you did earlier with the `Coin`
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The powerups should appear unpredictably, so the wait time of the `PowerupTimer`
    needs to be set whenever you begin a new level. Add this to the `_process()` function
    after the new coins are spawned with `spawn_coins()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you will have powerups appearing, the last step is to give the player
    some bonus time when one is collected. Currently, the player script assumes anything
    it runs into is either a coin or an obstacle. Change the code in `Player.gd` to
    check for what kind of object has been hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that now you''re emitting the pickup signal with an additional argument
    naming the type of object. The corresponding function in `Main.gd` can now be
    changed to accept that argument and use the `match` statement to decide what action
    to take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `match` statement is a useful alternative to `if` statements, especially
    when you have a large number of possible values to test.
  prefs: []
  type: TYPE_NORMAL
- en: Try running the game and collecting the powerup. Make sure the sound plays and
    the timer increases by five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Coin animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you created the `Coin` scene, you added an `AnimatedSprite`, but it isn't
    playing yet. The coin animation displays a *shimmer* effect traveling across the
    face of the coin. If all the coins display this at the same time, it will look
    too regular, so each coin needs a small random delay in its animation.
  prefs: []
  type: TYPE_NORMAL
- en: First, click on the `AnimatedSprite` and then on the *Frames* resource. Make
    sure Loop is set to Off and that Speed is set to `12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Timer` node to the `Coin` scene, and add this code to `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, connect the `timeout()` signal from the `Timer` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Try running the game and watching for the coins to animate. It's a nice visual
    effect for a very small amount of effort. You'll notice a lot of effects like
    this in professional games. Though very subtle, the visual appeal makes for a
    much more pleasing experience.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `Powerup` object has a similar animation that you can add in the
    same manner.
  prefs: []
  type: TYPE_NORMAL
- en: Obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the game can be made a bit more challenging by introducing an obstacle
    that the player must avoid. Touching the obstacle will end the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new scene for the cactus and add the following nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Area2D` (named `Cactus`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionShape2D`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag the cactus texture from the FileSystem dock to the Texture property of
    the `Sprite`. Add a `RectangleShape2D` to the collision shape and size it so that
    it covers the image. Remember when you added `if area.is_in_group("obstacles")` to
    the player script? Add the `Cactus` body to the `obstacles` group using the Node
    tab (next to Inspector).
  prefs: []
  type: TYPE_NORMAL
- en: Now, add a `Cactus` instance to the `Main` scene and move it to a location in
    the upper half of the screen (away from where the player spawns). Play the game
    and see what happens when you run into the cactus.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have spotted a problem: coins can spawn behind the cactus, making them
    impossible to pick up. When the coin is placed, it needs to move if it detects
    that it''s overlapping the obstacle. Connect the coin''s `area_entered()` signal
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you've added the preceding `Powerup` object, you'll need to do the same for
    its `area_entered` signal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of Godot Engine by creating a basic
    2D game. You set up the project and created multiple scenes, worked with sprites
    and animations, captured user input, used *signals* to communicate with events,
    and created a UI using **Control** nodes. The things you learned here are important
    skills that you'll use in any Godot project.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, look through the project. Do you understand
    what each node is doing? Are there any bits of code that you don't understand?
    If so, go back and review that section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, feel free to experiment with the game and change things around. One of
    the best ways to get a good feel for what different parts of the game are doing
    is to change them and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll explore more of Godot's features and learn how to
    use more node types by building a more complex game.
  prefs: []
  type: TYPE_NORMAL
