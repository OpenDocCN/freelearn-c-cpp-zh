["```cpp\n#include \"adc.h\"\n#define GPIOAEN        (1U<<0)\n#define ADC1EN        (1U<<8)\n#define ADC_CH1        (1U<<0)\n#define ADC_SEQ_LEN_1  0x00\n#define CR2_ADCON    (1U<<0)\n#define CR2_CONT          (1U<<1)\n#define CR2_SWSTART     (1U<<30)\n#define SR_EOC         (1U<<1)\nvoid pa1_adc_init(void)\n{\n    /****Configure the ADC GPIO Pin**/\n    /*Enable clock access to GPIOA*/\n    RCC->AHB1ENR |= GPIOAEN;\n    /*Set PA1 mode to analog mode*/\n    GPIOA->MODER |=(1U<<2);\n    GPIOA->MODER |=(1U<<3);\n    /****Configure the ADC Module**/\n    /*Enable clock access to the ADC module*/\n    RCC->APB2ENR |=ADC1EN;\n    /*Set conversion sequence start*/\n    ADC1->SQR3 = ADC_CH1;\n    /*Set conversion sequence length*/\n    ADC1->SQR1 = ADC_SEQ_LEN_1;\n    /*Enable ADC module*/\n    ADC1->CR2 |=CR2_ADCON;\n}\nvoid start_conversion(void)\n{\n    /*Enable continuous conversion*/\n    ADC1->CR2 |=CR2_CONT;\n    /*Start ADC conversion*/\n    ADC1->CR2 |=CR2_SWSTART;\n}\nuint32_t adc_read(void)\n{\n    /*Wait for conversion to be complete*/\n    while(!(ADC1->SR & SR_EOC)){}\n    /*Read converted value*/\n    return (ADC1->DR);\n}\n```", "```cpp\n#define GPIOAEN        (1U<<0)\n#define ADC1EN        (1U<<8)\n#define ADC_CH1        (1U<<0)\n#define ADC_SEQ_LEN_1  0x00\n#define CR2_ADCON     (1U<<0)\n#define CR2_CONT     (1U<<1)\n#define CR2_SWSTART      (1U<<30)\n#define SR_EOC          (1U<<1)\n```", "```cpp\n/* Enable clock access to GPIOA */\n RCC->AHB1ENR |= GPIOAEN;\n```", "```cpp\n/* Set PA1 mode to analog mode */\n    GPIOA->MODER |= (1U<<2);\n    GPIOA->MODER |= (1U<<3);\n```", "```cpp\n/* Enable clock access to the ADC module */\nRCC->APB2ENR |= ADC1EN;\n```", "```cpp\n/* Set conversion sequence start */\n ADC1->SQR3 = ADC_CH1;\n```", "```cpp\n/* Set conversion sequence length */\nADC1->SQR1 = ADC_SEQ_LEN_1;\n```", "```cpp\n/* Enable ADC module */\nADC1->CR2 |= CR2_ADCON;\n```", "```cpp\n/* Enable continuous conversion */\nADC1->CR2 |= CR2_CONT;\n```", "```cpp\n/* Start ADC conversion */\n ADC1->CR2 |= CR2_SWSTART;\n```", "```cpp\n/* Wait for conversion to be complete */\nwhile (!(ADC1->SR & SR_EOC)) {}\n```", "```cpp\n/* Read converted value */\nreturn (ADC1->DR);\n```", "```cpp\n#ifndef ADC_H__\n#define ADC_H__\n#include <stdint.h>\n#include \"stm32f4xx.h\"\nvoid pa1_adc_init(void);\nvoid start_conversion(void);\nuint32_t adc_read(void);\nadc.c, making them callable from other files.\n\t\t\tLet’s move on to the `main.c` file. Update your `main.c` file, like so:\n\n```", "```cpp\n\n\t\t\tLet’s break it down:\n\n\t\t\t\t*   **Including** **header files**:\n\n    ```", "```cpp\n\n    Let’s take a closer look:\n\n    *   `#include <stdio.h>`: This includes the standard input/output library, which provides the `printf()` function for printing the sensor values\n    *   `#include \"adc.h\"`: This includes the header file for the ADC functions, ensuring that the `pa1_adc_init`, `start_conversion`, and `adc_read` functions from our `adc.c` file are available\n    *   `#include \"uart.h\"`: This includes the header file for the UART functions we developed in the previous chapter, ensuring that the `uart_init` function is available\t\t\t\t*   **Global** **variable declaration**:\n\n    ```", "```cpp\n\n    This declares a global variable to store the ADC value that’s read from the sensor.\n\n    \t\t\t\t*   **Main function**:\n\n    ```", "```cpp\n\n    This line initializes the UART peripheral, allowing us to print the sensor value:\n\n    ```", "```cpp\n\n    This line initializes the ADC:\n\n    ```", "```cpp\n\n    This line starts the ADC conversion process.\n\n    \t\t\t\t*   **Infinite loop**:\n\n    ```", "```cpp\n\n    This line prints the sensor value to the terminal or console using the UART. The `\\r\\n` part at the end of the string ensures that the printed value starts on a new line each time.\n\n\t\t\tWe are now ready to test the project.\n\t\t\tTesting the project\n\t\t\tTo test your project, you must connect your sensor or a potentiometer to the development board. Follow these steps:\n\n\t\t\t\t1.  **Connect** **a sensor**:\n    *   **Signal pin**: Connect the signal pin of your sensor to **PA1**.\n    *   **GND pin**: Connect the GND pin of the sensor to one of the GND pins on the development board.\n    *   **VCC pin**: Connect the VCC pin to either the 3.3V or 5V pin on the development board. Ensure you verify the required voltage from your sensor’s documentation as different sensors may need either 3.3V or 5V.\n\t\t\t\t2.  **Use** **a potentiometer**:\n    *   If a sensor is not available, you can use a potentiometer instead. A potentiometer is an adjustable resistor that’s used to vary the voltage. It has three terminals: two fixed and one variable (wiper).\n    *   **Middle terminal**: Connect the middle terminal (wiper) of the potentiometer to PA1.\n    *   **Left terminal**: Connect the left terminal to 3.3V.\n    *   **Right terminal**: Connect the right terminal to GND.\n\n    See *Figure 11**.4* for the connection diagram:\n\n\t\t\t![Figure 11.5: Potentiometer connection](img/B21914_11_5.jpg)\n\n\t\t\tFigure 11.5: Potentiometer connection\n\t\t\tAs you turn the knob of the potentiometer, the resistance between the middle terminal and the fixed terminals (3.3V and GND) will change, which, in turn, changes the voltage output at the middle terminal. This varying voltage will be measured by the ADC.\n\n\t\t\t\t1.  **Run** **the project**:\n    *   Build and run the project on the development board.\n    *   Open **RealTerm** or another serial terminal program and select the appropriate port and baud rate.\n    *   You should see the sensor values being printed in real time on the terminal. As you turn the potentiometer knob, the displayed value should change, reflecting the varying output voltage.\n\n\t\t\tSummary\n\t\t\tIn this chapter, we explored the ADC, a vital peripheral in embedded systems that enables microcontrollers to interface with the analog world. We started with an overview of the analog-to-digital conversion process, highlighting its importance and discussing key specifications such as resolution, step size, and VREF.\n\t\t\tThen, we delved into the STM32F411 microcontroller’s ADC peripheral, examining its capabilities and the relevant registers required for ADC operations. This included an overview of key ADC registers, such as `ADC_CR1`, `ADC_CR2`, `ADC_SQRx`, `ADC_SR`, and `ADC_DR`, as well as important ADC flags, such as EOC, JEOC, AWD, OVR, and STRT.\n\t\t\tThis chapter also explained the different ADC modes, including single conversion mode, continuous conversion mode, scan mode, discontinuous mode, and injected conversion mode. Each mode was explained with practical use cases to illustrate their applications.\n\t\t\tNext, we examined how multiplexing allows the ADC to switch between multiple input signals, enabling the microcontroller to handle multiple analog inputs efficiently.\n\t\t\tFinally, we applied the theoretical concepts by developing a bare-metal ADC driver. This involved configuring a GPIO pin for ADC input, configuring the ADC module, starting conversions, and reading the ADC values.\n\t\t\tIn the next chapter, we will focus on the **Serial Peripheral Interface** (**SPI**), another commonly used communication protocol known for its speed and efficiency in embedded systems.\n\n```"]