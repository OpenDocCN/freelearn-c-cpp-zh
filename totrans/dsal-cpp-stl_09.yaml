- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Container Adaptor Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container adaptors, as their name suggests, adapt underlying containers to provide
    specific interfaces and functionalities. Think of them as a way to enhance or
    modify an existing container so that it serves a different purpose without having
    to reinvent the wheel. They wrap around base containers and provide a distinct
    set of member functions, imbuing them with behavior that can be useful in various
    programming scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides references for the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::stack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::queue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::priority_queue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multiset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: std::stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::stack` is a data structure that represents a stack, a `std::deque`, `std::vector`,
    and `std::list`, providing a simple and easy-to-use interface for working with
    stacks. You can push elements onto the top of the stack, pop elements from the
    top, and access the top element without accessing elements at other positions.
    `std::stack` is commonly used for tasks that require a stack-like behavior, such
    as tracking function call sequences, parsing expressions, and managing temporary
    data. It provides a convenient way to manage data to ensure the most recently
    added element is the first to be removed.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::stack` is a container adapter that’s designed to provide a LIFO data
    structure. It operates on top of another container, such as `std::vector`, `std::deque`,
    or `std::list`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s particularly suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When a LIFO behavior is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you only need to access the most recently added element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When insertions and deletions happen solely at one end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose `std::stack` when you require a simple interface to manage data in a
    LIFO manner. For more flexible operations, consider its underlying container.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expression evaluations and parsing**: An example of this is evaluating postfix
    expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backtracking algorithms**: An example of this is performing depth-first search
    in graphs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undo operations in software**: Maintaining a history of user actions to revert
    them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `std::stack` is a container adaptor, its algorithmic performance is dependent
    on the underlying container implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion (****push)**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion (****pop)**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access (****top)**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Directly tied to the underlying container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::stack` behaves like its underlying container does. For instance, if `std::vector`
    is the base, resizing might involve reallocation, doubling its memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most STL containers, `std::stack` isn’t thread-safe for write operations.
    External synchronization is necessary for concurrent writes or a combination of
    reads and writes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::queue` and `std::priority_queue` are other adapters in the STL, serving
    **first-in, first-out** (**FIFO**) behaviors and priority-driven access, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting and searching are not inherently suited for `std::stack`. You might
    have to transfer elements to a different container to sort or search.
  prefs: []
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::stack` is designed to offer three special member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push`: Pushes an element onto the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`: Removes (pops) an element from the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`: Gets the value of the top element in the stack without removing it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the raw underlying containers, `std::stack` offers a restricted
    interface tailored for LIFO operations.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Direct interactions with STL algorithms are limited due to the lack of iterator
    support. For algorithmic operations, consider the underlying container directly.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attempting operations on an empty stack, such as `pop` or `top`, doesn’t throw
    but leads to undefined behavior. Ensure the stack isn’t empty before such operations.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the behavior of `std::stack` can’t be altered much, using custom allocators
    or selecting a specific underlying container can influence performance and storage
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows an example demonstrating the use of `std::stack`.
    This example implements a function to evaluate **Reverse Polish Notation** (**RPN**)
    expressions, a postfix mathematical notation. Using a stack is a natural fit for
    this type of problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `std::stack` to manage operands and evaluate the RPN expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operands are pushed onto the stack. When an operator is encountered, the necessary
    number of operands (usually two) are popped from the stack. Next, the operation
    is performed. Finally, the result is pushed back onto the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the expression is valid at the end of the evaluation, there should be precisely
    one number on the stack: the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function handles possible errors, such as an invalid RPN expression or division
    by zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a typical use of `std::stack` as it showcases the LIFO nature of the
    data structure and its principle operations (`push`, `pop`, and `top`).
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintain a LIFO discipline**: A stack is designed for LIFO operations. Avoid
    manipulating the underlying container directly to access anything other than the
    top element. Bypassing the LIFO logic compromises the purpose and integrity of
    using a stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top()` or `pop()`, always validate if the stack is empty using the `empty()`
    function. Accessing or popping from an empty stack leads to undefined behavior
    and potential runtime errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stack` uses `std::deque` as its container, which typically provides efficient
    push and pop operations. While you can customize this with containers such as
    `std::vector` or `std::list`, be aware of their respective performance and memory
    characteristics. For instance, while `std::vector` might have occasional resizing
    overheads, `std::list` has per-element overheads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stack` itself does not guarantee thread safety. If you’re accessing or
    modifying a stack from multiple threads, employ proper synchronization mechanisms,
    such as `std::mutex`, to prevent data races and maintain consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stack` interface restricts you to the top element, the underlying container
    might not. Directly using the underlying container can provide broader access
    and introduce errors if you’re not cautious.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` to construct the element directly within the stack. This can reduce
    the need for temporary objects and potential copy/move operations, leading to
    more efficient and concise code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception safety**: Certain operations might provide basic or strong exception
    safety, depending on the underlying container. Awareness of these guarantees is
    essential, especially if your application requires a certain level of exception
    safety.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stack` doesn’t expose capacity or reservation mechanisms directly, the
    underlying container, especially if it’s `std::vector`, might have such behaviors.
    If you’re confident about the stack’s growth patterns, consider using an appropriate
    underlying container and managing its capacity for optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto`, be explicitly aware of your stack’s type. This includes the type of
    elements it holds and the underlying container. This clarity ensures you remain
    informed about the stack’s performance characteristics and limitations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector<bool>`, using `std::stack<bool>` with certain underlying containers
    can have unexpected behaviors or inefficiencies due to container specializations.
    If you need a stack of Boolean values, consider alternatives or be well-informed
    about the specific container’s behavior with Boolean types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::queue` represents a FIFO data structure. It is implemented as an adapter
    class and is typically based on other underlying containers, such as `std::deque`
    or `std::list`. `std::queue` provides a straightforward interface for working
    with queues, allowing you to enqueue (push) elements at the back and dequeue (pop)
    elements from the front. It is commonly used in C++ for situations where data
    needs to be processed in the order it was added, such as task scheduling, breadth-first
    traversal of graphs or trees, and managing work items in multi-threaded programs.
    `std::queue` ensures that the element in the queue that is the longest is the
    first to be dequeued, making it a useful tool for managing ordered data processing.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::queue` is a container adapter that’s built on top of another container
    such as `std::deque`, `std::list`, or `std::vector`. Its primary purpose is to
    provide FIFO data access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s especially suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When sequential access is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When elements are to be processed in their insertion order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If searching, sorting, or random access is a primary concern, `std::queue` might
    not be the optimal choice.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task scheduling**: Manage tasks in the order they arrive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data serialization**: Ensure data is processed in the order it’s received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree Traversal:** Breadth-first traversal of graphs or trees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `std::queue` is a container adaptor, its algorithmic performance depends
    on the underlying container implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion (****push)**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion (****pop)**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access (front and** **back)**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Depends on the underlying container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance characteristics derive mainly from the base container, which
    is typically `std::deque`.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Its memory behavior depends on the underlying container. For instance, if you’re
    using `std::deque`, it manages blocks of memory and can grow both ends.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reads and writes aren’t inherently thread-safe. External synchronization, such
    as mutexes, is necessary if concurrent access is required.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::priority_queue` is another adapter that provides access to the top-most
    element based on a priority, not insertion order.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting and searching does not apply to `std::queue`. `std::queue` is designed
    for FIFO access. Sorting or random searching would require manual iteration through
    the underlying container, which is suboptimal and defies the purpose of a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Its primary operations include `push()`, `pop()`, `front()`, and `back()`. `size()`
    and `empty()` are used for size checks and emptiness.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::stack`, which offers LIFO access, `std::queue` ensures FIFO
    behavior. If random access is required, then `std::vector` might be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Direct interaction with most STL algorithms is limited due to the lack of iterators.
    If algorithmic operations are needed, you’d typically work on the underlying container
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exceptions that are thrown depend on the operations of the underlying container.
    However, accessing elements from an empty queue (using `front()` or `back()`)
    can lead to undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory management can be customized by choosing an appropriate underlying container
    and possibly using custom allocators.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One everyday use case for `std::queue` is implementing a `std::queue`. Here
    is a basic BFS implementation on an undirected graph that uses an adjacency list
    representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following points explain the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Graph` class uses an adjacency list (`adjList`) to represent the graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BFS traversal starts from a given vertex, marks it as visited, and then
    explores its neighbors. Neighbors are added to the queue and processed in the
    order they are encountered (FIFO order), ensuring a breadth-first traversal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As vertices are visited, they are marked in the visited vector to ensure they’re
    not processed multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The BFS function uses the primary operations of `std::queue: push` to add vertices
    to the queue, `front` to inspect the next vertex to be processed, and `pop` to
    remove it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintain a FIFO discipline**: A queue is inherently designed for FIFO operations.
    Attempting to use it for other purposes, such as random access or stack operations
    with LIFO order, can lead to suboptimal designs and complexities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::queue` does not expose direct iterators. If you need to iterate over
    the elements, consider if a queue is the proper data structure for your needs
    or if the underlying container should be accessed directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`front()` or `back()`, always check if the queue is empty using the `empty()`
    function. This prevents undefined behavior that could arise from trying to access
    elements in an empty queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::queue` is `std::deque`, but you can use others, such as `std::list`.
    Each container has its characteristics, trade-offs, and memory overhead. For example,
    while `std::list` offers efficient insertions and deletions, its memory overhead
    per element is higher than `std::deque`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mutex`, to avoid data races and inconsistencies. The operations on `std::queue`
    itself are not inherently thread-safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` container (though this is rare for a queue). This can be a performance
    concern in real-time or performance-critical applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` to construct the element directly within the queue. This can lead
    to more efficient code as it avoids temporary object creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, `std::queue` doesn’t have capacity-related member functions.
    Without explicit knowledge or control, do not make assumptions about the underlying
    container’s size or capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::deque` provides strong exception safety for its operations, ensuring
    data isn’t corrupted during exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be cautious with type aliases**: If you’re using type aliases or auto-typing,
    be sure you know the exact type of your queue, especially if you’re working with
    queues of different underlying containers in the same code base. This ensures
    you don’t mistakenly assume a different container type’s characteristics or performance
    trade-offs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::priority_queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::priority_queue` is an adapter container built on top of a random-access
    container type, primarily `std::vector`. Its core strength revolves around the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Always having the highest priority element at the top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring efficient insertion and retrieval of the top element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It shines in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When priority-based access is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When insertions are random but access always targets the element of the highest
    importance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In scenarios where order is not a concern or insertion order matters more than
    access priority, `std::priority_queue` might not be the ideal choice.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::priority_queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Job scheduling**: Assigning jobs based on their urgency or priority'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pathfinding algorithms**: An example of such an algorithm is Dijkstra’s algorithm,
    where nodes with the shortest tentative distance are processed first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulation systems**: For events that should be processed based on priority
    rather than sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `std::priority_queue` is a container adaptor, its algorithmic performance
    depends on the underlying container implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(log n)*, as the element is placed in its suitable position
    based on its priority'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(log n)* for the top element as the queue restructures itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(1)* to the top element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Moderate, contingent on the underlying container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that when using `std::vector` as the underlying container, additional memory
    overheads might appear when it resizes.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is inherently dependent on the underlying container. With `std::vector`,
    memory reallocation might happen upon reaching capacity. Allocators can be utilized
    for customization.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent access requires caution. Multiple reads are safe, but simultaneous
    reads or writes demand external synchronization mechanisms, such as mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want a container that ensures sequence preservation, you might consider
    `std::queue`. If an associative container with key-value pairs and inherent ordering
    is needed, `std::map` or `std::set` might be more apt.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting does not apply to `std::priority_queue`. Direct access to the top priority
    element for searching is *O(1)*. However, searching for other elements is not
    straightforward and isn’t the primary intent of this container.
  prefs: []
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond the basics (`push`, `pop`, `top`), explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Directly constructs an element within the priority queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: Retrieves the number of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap`: Exchanges the contents of two priority queues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to `std::queue`, which respects FIFO ordering, `std::priority_queue`
    always ensures the highest priority element is accessible. Compared with `std::set`,
    the latter allows ordered access to all elements, while the former focuses on
    priority.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the lack of iterators, most STL algorithms can’t interact directly with
    `std::priority_queue`. However, it naturally aligns with user-defined algorithms
    that focus on the highest-priority elements, such as those that use `push()` and
    `pop()`.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throwing can occur during underlying container operations, such as memory allocation.
    Exception safety often aligns with that of the underlying container.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some customization options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Allocators**: Customize memory allocation using custom allocators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparators**: Modify the priority logic using custom comparator functions,
    allowing for a custom definition of *priority*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::priority_queue` is often used in scenarios where elements need to be
    processed based on their priorities. One of the most common examples of using
    `std::priority_queue` is implementing Dijkstra’s shortest path algorithm for weighted
    graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of implementing Dijkstra’s algorithm with
    `std::priority_queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following happens in this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `WeightedGraph` class uses an adjacency list to represent the graph, where
    each list element is a pair representing the neighboring vertex and the weight
    of the edge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dijkstra` function calculates the shortest distance from a given vertex
    to all other vertices in the graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::priority_queue` is used to select the next vertex with the shortest known
    distance to process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distances to vertices are updated based on the currently processed vertex and
    its neighbors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the algorithm progresses, `priority_queue` ensures that vertices are processed
    in increasing order of their known shortest distances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::priority_queue` provides an efficient way to always process the
    vertex with the smallest known distance in Dijkstra’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::priority_queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::priority_queue` is to efficiently access the highest-priority element,
    not to provide ordered access to all its elements. Do not assume you can access
    the elements in a fully sorted order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom priority rules**: If the default comparison logic doesn’t meet your
    needs, always provide a custom comparator. This ensures that the queue maintains
    elements according to your specific priority rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::priority_queue` uses `std::vector` as its underlying container. While
    this is often suitable, switching to containers such as `std::deque` or `std::list`
    can influence performance. Choose the container that aligns with your specific
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check for emptiness**: Before trying to access the top element or perform
    a pop operation, always verify that the queue isn’t empty. This prevents undefined
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid underlying container manipulation**: Directly manipulating the underlying
    container can disrupt the integrity of the priority queue. Avoid this to ensure
    that the priority order remains consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` method over `push`. This provides more efficient in-place construction
    and can save on unnecessary copies or moves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::priority_queue` is not inherently thread-safe. If you need to access
    or modify it across multiple threads, ensure you use appropriate synchronization
    mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Awareness of internal sorting**: While it’s tempting to think of the priority
    queue as always holding a sorted list of elements, remember that it only ensures
    that the top-most element is the highest priority. The internal order of other
    elements is not guaranteed to be sorted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::priority_queue` does not provide iterators to its elements. This design
    intentionally keeps users from inadvertently breaking the queue’s priority invariants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size considerations**: Be mindful of the size and capacity of the underlying
    container, especially if you’re dealing with large datasets. Periodically checking
    and managing capacity can help in optimizing memory usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these best practices, you can ensure that you use `std::priority_queue`
    in a manner that is efficient and consistent with its design intentions.
  prefs: []
  type: TYPE_NORMAL
- en: std::flat_set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::flat_set` is a sorted associative container that’s designed to store
    a collection of unique elements in a sorted order. What sets `std::flat_set` apart
    from other associative containers, such as `std::set`, is that it is implemented
    as a flat container, often based on a sorted `std::vector` container. This means
    that elements are stored contiguously in memory, leading to optimal memory usage
    and faster iteration times compared to traditional tree-based associative containers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_set` maintains its elements in a sorted order, allowing for efficient
    searching, insertion, and deletion operations, while also providing similar functionality
    and interface to other set-like containers in the C++ STL. It is especially useful
    when you need the advantages of both sorted storage and efficient memory management.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_set` is a container that represents an associative set stored in
    a sorted flat array. It merges the benefits of a `std::vector` container (such
    as cache-friendliness) with those of a `std::set` container (such as ordered storage).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::flat_set` in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need ordered data with set properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When memory allocation overhead is a concern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to leverage cache locality advantages similar to those of `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to perform many insertions and deletions, other set types, such
    as `std::set`, may be more suitable due to their tree-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::flat_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_set` container and sorting it can be efficient'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` container can be notably faster than tree-based sets for smaller
    sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` can be advantageous'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `std::flat_set` is a container adaptor, its algorithmic performance depends
    on the underlying container implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(n)* since shifting may be required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(n)* for the same reasons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(log n)* for lookup using binary search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Less than tree-based structures due to fewer memory allocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trade-off is the speed of lookups versus the cost of insertion and deletion,
    especially as the set grows.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_set` uses a contiguous block of memory (similar to `std::vector`).
    Reallocations occur when this block is exhausted. You can influence the allocation
    strategy using custom allocators.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most STL containers, concurrent reads are safe, but writes or mixed
    operations necessitate external synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_map` is a cousin of `std::flat_set` that stores key-value pairs
    in a flat structure. It offers similar performance characteristics and uses.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Inherent to the container and usually *O(n* *log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(log n)* due to binary search on sorted data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the typical set functions (`insert`, `erase`, `find`), consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reserve`: Allocates memory in anticipation of insertions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capacity`: Returns the current allocation size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to `std::set`, `std::flat_set` offers better cache locality but
    can become inefficient with frequent insertions/deletions in large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL algorithms that require random-access iterators, such as `std::sort()`,
    can be applied directly. However, remember that `std::flat_set` maintains its
    sorted order, so sorting manually is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Misusing iterators or exceeding capacity can cause exceptions. Many operations
    provide strong exception safety, ensuring container consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_set` permits custom allocators, allowing for refined memory control.
    You can also supply custom comparators for specialized sorting.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::flat_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_set` is best suited for use cases where the set is built once and
    queried multiple times. If your application demands frequent insertions and deletions,
    a traditional tree-based `std::set` container might be more appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` over other set implementations is its continuous memory layout,
    making it cache-friendly. This can lead to significant performance improvements
    for smaller datasets or when the data can fit into the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` containers and need to merge them, consider inserting all elements
    into a single container first, then sort and make the entire collection unique.
    This approach is often more efficient than merging sorted sets element by element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reserve` method is advisable if you have a reasonable estimate of the number
    of elements you’ll be inserting. This can minimize memory reallocations and enhance
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` container, which is tree-based and can handle such modifications
    more gracefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` maintains its elements in a sorted order, it’s crucial to avoid
    manually sorting the container. Adding elements to a `std::flat_set` container
    will keep them in order based on the provided comparator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` offers member functions such as `find` for efficient searching,
    they are optimized for its internal structure. Using these member functions is
    generally more efficient than applying generic algorithms. If you ever need to
    use algorithms, ensure they are designed for sorted sequences, such as `std::lower_bound`
    or `std::upper_bound`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` is `std::less`. However, if your data requires custom sorting
    logic, ensure you provide a custom comparator during the set’s construction. Remember,
    this comparator should give a strict weak ordering to maintain the set’s properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` provides. If your use case has such patterns, evaluate if other
    containers might be more suitable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set`, modifying elements (for example, through iterators) in a `std::flat_set`
    container without ensuring the order can lead to undefined behavior. Always confirm
    that the sorted order is maintained post modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_set` works well with algorithms that have been optimized for random-access
    iterators. However, be cautious with algorithms that modify the order or content
    as they can violate the set’s properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::flat_map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::flat_map` is a sorted associative container that combines the features
    of a map and a flat container. Similar to `std::map`, it allows you to store key-value
    pairs, and the keys are unique and ordered. However, unlike `std::map`, which
    is typically implemented as a balanced binary search tree, `std::flat_map` is
    implemented as a flat container, often based on a sorted `std::vector` container.
    This means that `std::flat_map` offers efficient memory usage and faster iteration
    times than traditional tree-based associative containers such as `std::map`. Elements
    in a `std::flat_map` container are stored contiguously in memory, which can lead
    to better cache locality and improved performance for certain use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_map` provides functionality and interface similar to `std::map`,
    allowing you to perform operations such as insertion, deletion, and searching
    while maintaining the elements in a sorted order. It’s beneficial when you need
    both the advantages of sorted storage and the benefits of a flat container.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_map` is a container that pairs together keys and values, functioning
    as an associative array. The following reasons set it apart from other map containers:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses a vector-like structure, granting advantages in cache locality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This contiguous memory layout fosters improved lookup times in some scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its niche lies in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When the map is mainly built once and then often queried
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When iteration speed and cache locality take precedence over insertion/deletion
    speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a sorted map representation is essential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you foresee frequent modifications post-initialization, consider using `std::map`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::flat_map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration data**: Storing configuration key-value pairs loaded once at
    startup but queried frequently during application runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spatial indexing**: In graphics or game development, quick iteration and
    retrieval are more critical than frequent modifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data serialization**: For datasets that require sorting and occasional lookups
    but aren’t modified regularly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Insertion**: *O(n)* due to the underlying vector structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(n)* because elements may need to be shifted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(log n)* due to binary search on the sorted array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally, this is low, but it can escalate if the reserved
    capacity isn’t utilized efficiently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_map`, like `std::vector`, may reallocate when its capacity is surpassed.
    It’s wise to employ `reserve` if you can predict the eventual size. Allocators
    can provide control over memory management behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While concurrent reads are safe, writes or a mixture of both necessitate external
    synchronization – for example, using mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For unordered associative containers, the STL offers `std::unordered_map`. If
    a balanced tree structure with ordered keys is preferred, then `std::map` is your
    go-to.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Inherent to its structure, it always maintains order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(log n)* due to binary search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Common members such as `insert`, `find`, and `erase` are present. However,
    you should also explore the following gems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Directly constructs elements in place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` and `upper_bound`: These provide efficient range searches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`at`: Provides direct access to values by key with bounds-checking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_map` excels in iteration and lookup performance, especially for
    smaller datasets. However, if frequent modifications dominate your use case, you
    might lean toward `std::map`.'
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to its random-access nature, `std::flat_map` pairs well with STL algorithms
    that thrive on such iterators. However, any algorithm that disrupts the key order
    should be approached cautiously.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceeding capacity or accessing out-of-bounds keys might trigger exceptions.
    Many operations offer strong exception safety, preserving map states if exceptions
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_map` allows for custom allocators, and you can specify a custom
    comparator during construction to dictate the key order.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s explore the best practices of using `std::flat_map:`
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_map` for frequent insertions and deletions due to the high cost.
    For such cases, consider alternatives, such as `std::map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key modifications**: Do not alter keys directly using iterators. This disrupts
    the sorted order of the map. If keys need to be modified, consider erasing the
    old key-value pair and inserting a new one to ensure order maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reserve()` to reduce the frequency of memory reallocations, enhancing performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` to construct key-value pairs in place efficiently, maximizing performance
    and avoiding unnecessary temporary object creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` may offer better performance profiles in such scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: Ensure thread safety during multi-threaded access. Concurrent
    reads are generally safe, but writing or mixed read-write operations require external
    synchronization, such as mutexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_map`. It offers superior cache locality and efficient lookups, especially
    when the map is mainly queried post-initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_map`, be cautious of operations that may disrupt this order. Always
    validate the order after any modifications to ensure the container’s integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` and `upper_bound` for efficient range-based queries, leveraging
    the container’s sorted characteristics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::less`) works for many scenarios, `std::flat_map` allows you to specify
    custom comparators during instantiation, tailoring the key order to specific needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::flat_multiset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::flat_multiset` is a container that was introduced in the C++ STL that’s
    designed to store elements in a sorted order. Unlike `std::multiset`, which is
    typically implemented as a red-black tree, `std::flat_multiset` stores its elements
    in a contiguous memory block, similar to a `std::vector` container. This design
    choice offers improved cache performance due to data locality, making it efficient
    for scenarios where the container is not frequently modified after being filled.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Std::flat_multiset` is a container that stores elements in a sorted array,
    similar to `std::flat_set`, but allows for multiple occurrences of equivalent
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This container offers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient lookup times thanks to its sorted nature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved cache locality and predictability in memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s especially suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When duplicates are permissible and you need sorted access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When cache locality is prioritized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the dataset’s size is relatively stable post-initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, other containers might be more appropriate when frequent insertions
    or deletions become the norm.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::flat_multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Historical records**: Storing repeated events in chronological order, such
    as transaction logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency counter**: Counting occurrences of elements when order and access
    speed are vital'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorted buffers**: Temporary storage during processing, where the order is
    crucial, and duplicates are expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `std::flat_multiset` is a container adaptor, its algorithmic performance
    depends on the underlying container implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(n)* since maintaining order may necessitate element shifting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(n)* due to the possibility of shifting to fill gaps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(log n)* for lookups owing to binary search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, but the lack of tree structures minimizes memory overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_multiset` manages memory in chunks. Pre-allocating memory using
    `reserve()` can prevent frequent reallocations. Custom allocators can further
    modify allocation behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simultaneous reads are safe. However, concurrent modifications or simultaneous
    reads and writes need external synchronization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::flat_multiset` stores multiple instances of an element, `std::flat_set`
    is its unique element counterpart. For hash-based approaches, you might want to
    look at `std::unordered_multiset`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_multiset` maintains order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: Efficient *O(log n)* due to binary searching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_multiset` offers much the same interface as its underlying type.
    Here are some especially useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`equal_range`: Returns range of equivalent elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Efficiently counts the occurrences of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace`: Constructs elements directly in place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::multiset`, `std::flat_multiset` offers a better cache locality
    but may suffer from frequent modifications. It excels in read-heavy scenarios
    post-initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being sorted, `std::flat_multiset` resonates well with binary search-based algorithms.
    However, those that shuffle or reorder might not be ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attempting to access out-of-bounds or mismanaging memory can lead to exceptions.
    Generally, operations are exception-safe, ensuring the container remains consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_multiset` supports custom allocators, allowing for memory allocation
    fine-tuning. Moreover, custom comparators can adjust the sorting behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::flat_multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_multiset` primarily in scenarios where the set size stabilizes post-initialization.
    Frequent insertions or deletions will lead to inefficiencies due to the need to
    maintain a sorted order, often leading to element shifting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset`, the iterators for `std::flat_multiset` can become invalidated
    post-modification, especially those that change the container’s size. Always reassess
    iterator validity after altering the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multiset` container, employ `reserve()` to allocate sufficient memory
    upfront. This prevents recurrent and costly reallocations. While reserving space
    for anticipated growth is important, over-reservation can lead to unnecessary
    memory consumption. Aim for a balance between the two.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multiset` is more suitable than `std::flat_set`. It retains all
    instances of an element, whereas the latter only keeps unique entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::list` or `std::multiset` might offer more efficiency for such operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace()` to construct elements directly within the set. This can eliminate
    unnecessary temporary constructions and copies, particularly for complex data
    types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multiset` is safe. Writing operations, whether they’re insertions,
    deletions, or modifications, require synchronization in a multi-threaded environment
    to ensure data integrity and prevent data races.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multiset` pairs well with STL algorithms that benefit from sorted
    datasets, such as `std::lower_bound` or `std::upper_bound`. However, remember
    that algorithms that alter the order or introduce elements might invalidate this
    inherent sorting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multiset` to control its ordering behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception safety**: Be aware of operations that can throw exceptions, such
    as memory allocation failures. Ensuring exception-safe code will prevent data
    inconsistencies and potential memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::flat_multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::flat_multimap` is a container adapter that combines the characteristics
    of associative and sequence containers. It stores key-value pairs, similar to
    `std::multimap`, but with a significant distinction: the elements are stored in
    a flat, contiguous memory space, akin to a `std::vector` container. This storage
    approach enhances cache performance due to improved data locality, which is especially
    beneficial for read-intensive operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Std::flat_multimap` is a container within the STL that’s optimized for fast
    associative lookups. Its distinguishing features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage in a sorted contiguous block of memory, akin to `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows multiple key-value pairs with identical keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is most suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When cache locality and associative lookups are both desired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the dataset stabilizes post-initialization since it’s not optimized for
    frequent insertions or deletions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick `std::flat_multimap` over other containers when the advantages of flat
    storage and allowance for key duplicity align with your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::flat_multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web browser history**: Storing URLs with timestamps. Multiple entries (timestamps)
    can exist for the same URL (key).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Word frequency counter**: When words in a piece of text can have multiple
    meanings and you want to store each meaning alongside its count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event scheduler**: To maintain events (values) that occur at specific times
    (keys), where multiple events might happen at the same timestamp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `std::flat_multimap` is a container adaptor, its algorithmic performance
    depends on the underlying container implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(n)* due to potential element shifting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(n)* due to maintaining order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(log n)* due to binary search on a sorted array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Relatively low with advantages in cache locality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trade-off lies in enjoying faster lookups at the cost of slower insertions
    and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_multimap` manages memory akin to `std::vector`. The `reserve()`
    function can anticipate and allocate memory for growth. Custom allocators can
    further tailor memory behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads are safe. However, writes or mixed read-writes require synchronization
    mechanisms such as mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a container without duplicate key allowance, there’s `std::flat_map`. For
    unsorted and bucketed storage, you might want to consider `std::unordered_multimap`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Inherent to the container and managed internally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(log n)* due to binary search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the standard functions (`insert`, `erase`, `find`), explore the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`equal_range`: Returns bounds of all entries matching a key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace`: Directly constructs key-value pairs inside the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::multimap`, `std::flat_multimap` offers better cache locality
    but slower modifications. When juxtaposed with `std::unordered_multimap`, it trades
    faster lookups for inherent sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::flat_multimap` is beneficial with algorithms such as `std::lower_bound`
    and `std::upper_bound` due to its sorted nature. However, be cautious with algorithms
    that modify order or introduce elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Key insertions or lookups won’t throw, but be wary of memory allocation failures,
    especially during insertions, which can cause exceptions. Exception safety is
    prioritized, with many operations offering strong guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While custom allocators are permitted, `std::flat_multimap` relies on its internal
    sorting mechanism. Thus, custom comparators are essential to define key order.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::flat_multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flat_multimap` when the use case involves continuous or frequent insertions
    and deletions. Due to the container’s linear nature, such operations can be costly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap` only supports input, output, forward, and bidirectional
    iterators. It does not provide random-access iterators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key data type considerations**: Prefer concise and lightweight data types
    for keys. Using large custom data types can exacerbate the costs of element shifting
    during insertions and deletions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap`, leverage the `reserve()` function. Pre-allocating memory
    can mitigate expensive reallocations and copying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` method for in-situ construction of key-value pairs. This can be more
    efficient than creating and inserting an entry separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` or `std::unordered_multimap`. These containers might offer
    better performance for such scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap`. Concurrent reads are typically safe but write operations
    can lead to race conditions without proper synchronization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap` retains its internal ordering based on your specific requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap`, binary search algorithms, such as `std::lower_bound`
    and `std::upper_bound`, can be used efficiently for operations such as range queries
    or finding specific keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap` offer strong exception guarantees, ensuring that the container
    remains consistent, even if an operation throws an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap`, use member functions such as `equal_range` to handle
    and process all entries associated with a specific key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::flat_multimap` using member functions such as `capacity()` and `size()`.
    If excess reserved space isn’t being utilized, consider using `shrink_to_fit()`
    to release this memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
