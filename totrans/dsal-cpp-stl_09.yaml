- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Advanced Container Adaptor Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级容器适配器使用
- en: Container adaptors, as their name suggests, adapt underlying containers to provide
    specific interfaces and functionalities. Think of them as a way to enhance or
    modify an existing container so that it serves a different purpose without having
    to reinvent the wheel. They wrap around base containers and provide a distinct
    set of member functions, imbuing them with behavior that can be useful in various
    programming scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适配器，正如其名称所示，将底层容器适配以提供特定的接口和功能。可以将它们视为一种增强或修改现有容器的方法，使其服务于不同的目的，而无需重新发明轮子。它们围绕基容器，提供一组独特的成员函数，赋予它们在各种编程场景中可能有用的行为。
- en: 'This chapter provides references for the following containers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了以下容器的参考：
- en: '`std::stack`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stack`'
- en: '`std::queue`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::queue`'
- en: '`std::priority_queue`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue`'
- en: '`std::flat_set`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set`'
- en: '`std::flat_map`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_map`'
- en: '`std::flat_multiset`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multiset`'
- en: '`std::flat_multimap`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multimap`'
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: std::stack
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::stack
- en: '`std::stack` is a data structure that represents a stack, a `std::deque`, `std::vector`,
    and `std::list`, providing a simple and easy-to-use interface for working with
    stacks. You can push elements onto the top of the stack, pop elements from the
    top, and access the top element without accessing elements at other positions.
    `std::stack` is commonly used for tasks that require a stack-like behavior, such
    as tracking function call sequences, parsing expressions, and managing temporary
    data. It provides a convenient way to manage data to ensure the most recently
    added element is the first to be removed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack`是一种表示栈的数据结构，它是一个`std::deque`、`std::vector`和`std::list`，提供了一个简单且易于使用的接口来处理栈。你可以将元素推送到栈顶，从栈顶弹出元素，并访问栈顶元素而无需访问其他位置的元素。`std::stack`通常用于需要类似栈的行为的任务，例如跟踪函数调用序列、解析表达式和管理临时数据。它提供了一种方便的方式来管理数据，以确保最近添加的元素是第一个被移除的。'
- en: Purpose and suitability
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::stack` is a container adapter that’s designed to provide a LIFO data
    structure. It operates on top of another container, such as `std::vector`, `std::deque`,
    or `std::list`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack`是一个容器适配器，旨在提供LIFO数据结构。它基于另一个容器操作，例如`std::vector`、`std::deque`或`std::list`。'
- en: 'It’s particularly suitable in the following scenarios:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下场景中特别适用：
- en: When a LIFO behavior is needed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要LIFO行为时
- en: When you only need to access the most recently added element
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只需要访问最近添加的元素时
- en: When insertions and deletions happen solely at one end
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入和删除仅发生在一边时
- en: Choose `std::stack` when you require a simple interface to manage data in a
    LIFO manner. For more flexible operations, consider its underlying container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个简单的接口来以LIFO方式管理数据时，请选择`std::stack`。对于更灵活的操作，请考虑其底层容器。
- en: Ideal use cases
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::stack`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::stack`的理想用例：
- en: '**Expression evaluations and parsing**: An example of this is evaluating postfix
    expressions'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式评估和解析**：例如，评估后缀表达式'
- en: '**Backtracking algorithms**: An example of this is performing depth-first search
    in graphs'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回溯算法**：例如，在图中执行深度优先搜索'
- en: '**Undo operations in software**: Maintaining a history of user actions to revert
    them'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销操作在软件中**：维护用户操作的历史记录以撤销它们'
- en: Performance
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Since `std::stack` is a container adaptor, its algorithmic performance is dependent
    on the underlying container implementation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::stack`是一个容器适配器，其算法性能取决于底层容器的实现：
- en: '**Insertion (****push)**: *O(1)*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入（****push）**：*O(1)*'
- en: '**Deletion (****pop)**: *O(1)*'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除（****pop）**：*O(1)*'
- en: '**Access (****top)**: *O(1)*'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问（****top）**：*O(1)*'
- en: '**Memory overhead**: Directly tied to the underlying container'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：直接与底层容器相关'
- en: Memory management
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::stack` behaves like its underlying container does. For instance, if `std::vector`
    is the base, resizing might involve reallocation, doubling its memory.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack`的行为与其底层容器类似。例如，如果底层是`std::vector`，则调整大小可能涉及重新分配，将其内存加倍。'
- en: Thread safety
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Like most STL containers, `std::stack` isn’t thread-safe for write operations.
    External synchronization is necessary for concurrent writes or a combination of
    reads and writes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 STL 容器一样，`std::stack` 在写操作上不是线程安全的。对于并发写入或读写组合，需要外部同步。
- en: Extensions and variants
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::queue` and `std::priority_queue` are other adapters in the STL, serving
    **first-in, first-out** (**FIFO**) behaviors and priority-driven access, respectively.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::queue` 和 `std::priority_queue` 是 STL 中的其他适配器，分别提供 **先进先出**（**FIFO**）行为和基于优先级的访问。'
- en: Sorting and searching complexity
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度
- en: Sorting and searching are not inherently suited for `std::stack`. You might
    have to transfer elements to a different container to sort or search.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索本身并不适合 `std::stack`。你可能需要将元素转移到不同的容器中进行排序或搜索。
- en: Special interface and member functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: '`std::stack` is designed to offer three special member functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack` 设计为提供三个特殊成员函数：'
- en: '`push`: Pushes an element onto the top of the stack'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`：将一个元素推入栈顶'
- en: '`pop`: Removes (pops) an element from the top of the stack'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`：从栈顶移除（弹出）一个元素'
- en: '`top`: Gets the value of the top element in the stack without removing it'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`：获取栈顶元素的值，而不移除它'
- en: Comparisons
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to the raw underlying containers, `std::stack` offers a restricted
    interface tailored for LIFO operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始底层容器相比，`std::stack` 提供了一个针对 LIFO 操作定制的受限接口。
- en: Interactions with algorithms
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Direct interactions with STL algorithms are limited due to the lack of iterator
    support. For algorithmic operations, consider the underlying container directly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏迭代器支持，与 STL 算法的直接交互有限。对于算法操作，请直接考虑底层容器。
- en: Exceptions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Attempting operations on an empty stack, such as `pop` or `top`, doesn’t throw
    but leads to undefined behavior. Ensure the stack isn’t empty before such operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在空栈上尝试操作，如 `pop` 或 `top`，不会抛出异常，但会导致未定义的行为。在执行此类操作之前，请确保栈不为空。
- en: Customization
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: While the behavior of `std::stack` can’t be altered much, using custom allocators
    or selecting a specific underlying container can influence performance and storage
    characteristics.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::stack` 的行为无法改变太多，但使用自定义分配器或选择特定的底层容器可以影响性能和存储特性。
- en: Example
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'The following code shows an example demonstrating the use of `std::stack`.
    This example implements a function to evaluate **Reverse Polish Notation** (**RPN**)
    expressions, a postfix mathematical notation. Using a stack is a natural fit for
    this type of problem:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用 `std::stack` 的示例。此示例实现了一个函数来评估 **逆波兰表示法**（**RPN**），一种后缀数学表示法。使用栈是此类问题的自然选择：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the example output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例输出：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, the following occurs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，发生以下情况：
- en: We use `std::stack` to manage operands and evaluate the RPN expression.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `std::stack` 来管理操作数并评估逆波兰表达式（RPN）。
- en: Operands are pushed onto the stack. When an operator is encountered, the necessary
    number of operands (usually two) are popped from the stack. Next, the operation
    is performed. Finally, the result is pushed back onto the stack.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数被推入栈中。当遇到运算符时，从栈中弹出必要的操作数（通常是两个）。然后执行操作。最后，将结果推回栈中。
- en: 'If the expression is valid at the end of the evaluation, there should be precisely
    one number on the stack: the result.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式在评估结束时有效，栈中应该恰好有一个数字：结果。
- en: The function handles possible errors, such as an invalid RPN expression or division
    by zero.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数处理可能出现的错误，例如无效的 RPN 表达式或除以零。
- en: This is a typical use of `std::stack` as it showcases the LIFO nature of the
    data structure and its principle operations (`push`, `pop`, and `top`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 `std::stack` 的典型使用，因为它展示了数据结构的 LIFO（后进先出）特性和其基本操作（`push`、`pop` 和 `top`）。
- en: Best practices
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::stack`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::stack` 的最佳实践：
- en: '**Maintain a LIFO discipline**: A stack is designed for LIFO operations. Avoid
    manipulating the underlying container directly to access anything other than the
    top element. Bypassing the LIFO logic compromises the purpose and integrity of
    using a stack.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持 LIFO 规律**：栈是为 LIFO 操作设计的。避免直接操作底层容器以访问除了栈顶元素之外的其他元素。绕过 LIFO 逻辑会损害使用栈的目的和完整性。'
- en: '`top()` or `pop()`, always validate if the stack is empty using the `empty()`
    function. Accessing or popping from an empty stack leads to undefined behavior
    and potential runtime errors.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行`top()`或`pop()`操作之前，始终使用`empty()`函数验证栈是否为空。从空栈访问或弹出会导致未定义行为和潜在的运行时错误。
- en: '`std::stack` uses `std::deque` as its container, which typically provides efficient
    push and pop operations. While you can customize this with containers such as
    `std::vector` or `std::list`, be aware of their respective performance and memory
    characteristics. For instance, while `std::vector` might have occasional resizing
    overheads, `std::list` has per-element overheads.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stack`使用`std::deque`作为其容器，这通常提供高效的推入和弹出操作。虽然你可以使用容器如`std::vector`或`std::list`来自定义它，但请注意它们各自的性能和内存特性。例如，虽然`std::vector`可能会有偶尔的调整大小开销，但`std::list`具有每个元素的额外开销。'
- en: '`std::stack` itself does not guarantee thread safety. If you’re accessing or
    modifying a stack from multiple threads, employ proper synchronization mechanisms,
    such as `std::mutex`, to prevent data races and maintain consistency.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stack`本身不保证线程安全性。如果你从多个线程访问或修改栈，请使用适当的同步机制，如`std::mutex`，以防止数据竞争并保持一致性。'
- en: '`std::stack` interface restricts you to the top element, the underlying container
    might not. Directly using the underlying container can provide broader access
    and introduce errors if you’re not cautious.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stack`接口限制你只能访问栈顶元素，底层容器可能不限制。直接使用底层容器可以提供更广泛的数据访问，但如果不小心，可能会引入错误。'
- en: '`emplace` to construct the element directly within the stack. This can reduce
    the need for temporary objects and potential copy/move operations, leading to
    more efficient and concise code.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`emplace`直接在栈内构建元素。这可以减少对临时对象的需求以及潜在的复制/移动操作，从而提高代码的效率和简洁性。
- en: '**Exception safety**: Certain operations might provide basic or strong exception
    safety, depending on the underlying container. Awareness of these guarantees is
    essential, especially if your application requires a certain level of exception
    safety.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常安全性**：某些操作可能提供基本或强异常安全性，这取决于底层容器。了解这些保证是至关重要的，特别是如果你的应用程序需要一定级别的异常安全性。'
- en: '`std::stack` doesn’t expose capacity or reservation mechanisms directly, the
    underlying container, especially if it’s `std::vector`, might have such behaviors.
    If you’re confident about the stack’s growth patterns, consider using an appropriate
    underlying container and managing its capacity for optimization.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stack`不直接暴露容量或预留机制，底层容器（尤其是如果它是`std::vector`）可能具有这种行为。如果你对栈的增长模式有信心，请考虑使用适当的底层容器并管理其容量以进行优化。'
- en: '`auto`, be explicitly aware of your stack’s type. This includes the type of
    elements it holds and the underlying container. This clarity ensures you remain
    informed about the stack’s performance characteristics and limitations.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`，请明确了解你的栈的类型。这包括它持有的元素类型和底层容器。这种清晰度确保你始终了解栈的性能特性和限制。'
- en: '`std::vector<bool>`, using `std::stack<bool>` with certain underlying containers
    can have unexpected behaviors or inefficiencies due to container specializations.
    If you need a stack of Boolean values, consider alternatives or be well-informed
    about the specific container’s behavior with Boolean types.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`，使用带有特定底层容器的`std::stack<bool>`可能会由于容器特殊化而产生意外的行为或不效率。如果你需要一个布尔值的栈，请考虑替代方案或充分了解特定容器对布尔类型的处理行为。'
- en: std::queue
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::queue`'
- en: '`std::queue` represents a FIFO data structure. It is implemented as an adapter
    class and is typically based on other underlying containers, such as `std::deque`
    or `std::list`. `std::queue` provides a straightforward interface for working
    with queues, allowing you to enqueue (push) elements at the back and dequeue (pop)
    elements from the front. It is commonly used in C++ for situations where data
    needs to be processed in the order it was added, such as task scheduling, breadth-first
    traversal of graphs or trees, and managing work items in multi-threaded programs.
    `std::queue` ensures that the element in the queue that is the longest is the
    first to be dequeued, making it a useful tool for managing ordered data processing.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::queue` 表示一个 FIFO 数据结构。它作为适配器类实现，通常基于其他底层容器，如 `std::deque` 或 `std::list`。`std::queue`
    提供了一个简单的接口来处理队列，允许您在队列末尾（push）插入元素，并从队列前端（pop）删除元素。它在 C++ 中常用，例如在需要按添加顺序处理数据的场景中，如任务调度、图的广度优先遍历或树，以及在多线程程序中管理工作项。`std::queue`
    确保队列中最长的元素是第一个被删除的，这使得它成为管理有序数据处理的有用工具。'
- en: Purpose and suitability
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::queue` is a container adapter that’s built on top of another container
    such as `std::deque`, `std::list`, or `std::vector`. Its primary purpose is to
    provide FIFO data access.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::queue` 是一个容器适配器，它建立在另一个容器（如 `std::deque`、`std::list` 或 `std::vector`）之上。其主要目的是提供
    FIFO 数据访问。'
- en: 'It’s especially suitable in the following scenarios:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别适合以下场景：
- en: When sequential access is needed
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要顺序访问时
- en: When elements are to be processed in their insertion order
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素需要按插入顺序处理时
- en: If searching, sorting, or random access is a primary concern, `std::queue` might
    not be the optimal choice.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索、排序或随机访问是主要关注点，`std::queue` 可能不是最佳选择。
- en: Ideal use cases
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想的使用场景
- en: 'The following are some of the ideal use cases for `std::queue`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::queue` 的理想使用场景：
- en: '**Task scheduling**: Manage tasks in the order they arrive'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务调度**：按任务到达的顺序管理任务'
- en: '**Data serialization**: Ensure data is processed in the order it’s received'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据序列化**：确保数据按接收顺序处理'
- en: '**Tree Traversal:** Breadth-first traversal of graphs or trees'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树遍历**：图的广度优先遍历或树的遍历'
- en: Performance
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Since `std::queue` is a container adaptor, its algorithmic performance depends
    on the underlying container implementation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::queue` 是一个容器适配器，其算法性能取决于底层容器的实现：
- en: '**Insertion (****push)**: *O(1)*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入（**push**）**：*O(1)*'
- en: '**Deletion (****pop)**: *O(1)*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除（**pop**）**：*O(1)*'
- en: '**Access (front and** **back)**: *O(1)*'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问（前和后）**：*O(1)*'
- en: '**Memory overhead**: Depends on the underlying container'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：取决于底层容器'
- en: The performance characteristics derive mainly from the base container, which
    is typically `std::deque`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 性能特征主要来自基本容器，通常是 `std::deque`。
- en: Memory management
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Its memory behavior depends on the underlying container. For instance, if you’re
    using `std::deque`, it manages blocks of memory and can grow both ends.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它的内存行为取决于底层容器。例如，如果您正在使用 `std::deque`，它管理内存块并且可以在两端增长。
- en: Thread safety
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Reads and writes aren’t inherently thread-safe. External synchronization, such
    as mutexes, is necessary if concurrent access is required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入本身不是线程安全的。如果需要并发访问，则必须使用外部同步，例如互斥锁。
- en: Extensions and variants
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::priority_queue` is another adapter that provides access to the top-most
    element based on a priority, not insertion order.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue` 是另一个适配器，它根据优先级而不是插入顺序提供对最高元素的访问。'
- en: Sorting and searching complexity
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: Sorting and searching does not apply to `std::queue`. `std::queue` is designed
    for FIFO access. Sorting or random searching would require manual iteration through
    the underlying container, which is suboptimal and defies the purpose of a queue.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索不适用于 `std::queue`。`std::queue` 是为 FIFO 访问设计的。排序或随机搜索需要手动遍历底层容器，这既不高效，也违背了队列的目的。
- en: Special interface and member functions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: Its primary operations include `push()`, `pop()`, `front()`, and `back()`. `size()`
    and `empty()` are used for size checks and emptiness.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要操作包括 `push()`、`pop()`、`front()` 和 `back()`。`size()` 和 `empty()` 用于大小检查和空检查。
- en: Comparisons
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Compared to `std::stack`, which offers LIFO access, `std::queue` ensures FIFO
    behavior. If random access is required, then `std::vector` might be more appropriate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与提供 LIFO 访问的 `std::stack` 相比，`std::queue` 确保了 FIFO 行为。如果需要随机访问，那么 `std::vector`
    可能更合适。
- en: Interactions with algorithms
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Direct interaction with most STL algorithms is limited due to the lack of iterators.
    If algorithmic operations are needed, you’d typically work on the underlying container
    directly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏迭代器，与大多数 STL 算法的直接交互有限。如果需要算法操作，你通常会直接在底层容器上工作。
- en: Exceptions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: The exceptions that are thrown depend on the operations of the underlying container.
    However, accessing elements from an empty queue (using `front()` or `back()`)
    can lead to undefined behavior.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出的异常取决于底层容器的操作。然而，从空队列中访问元素（使用 `front()` 或 `back()`）可能会导致未定义的行为。
- en: Customization
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: Memory management can be customized by choosing an appropriate underlying container
    and possibly using custom allocators.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择适当的底层容器，并可能使用自定义分配器，可以定制内存管理。
- en: Example
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'One everyday use case for `std::queue` is implementing a `std::queue`. Here
    is a basic BFS implementation on an undirected graph that uses an adjacency list
    representation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::queue` 的一个日常用例是实现 `std::queue`。以下是一个在无向图上使用邻接表表示的基本 BFS 实现示例：'
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the example output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following points explain the code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点解释了代码：
- en: The `Graph` class uses an adjacency list (`adjList`) to represent the graph.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Graph` 类使用邻接表（`adjList`）来表示图。'
- en: The BFS traversal starts from a given vertex, marks it as visited, and then
    explores its neighbors. Neighbors are added to the queue and processed in the
    order they are encountered (FIFO order), ensuring a breadth-first traversal.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BFS 遍历从给定的顶点开始，将其标记为已访问，然后探索其邻居。邻居被添加到队列中，并按它们遇到的顺序（FIFO顺序）进行处理，确保广度优先遍历。
- en: As vertices are visited, they are marked in the visited vector to ensure they’re
    not processed multiple times.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着顶点的访问，它们在访问向量中被标记，以确保它们不会被多次处理。
- en: 'The BFS function uses the primary operations of `std::queue: push` to add vertices
    to the queue, `front` to inspect the next vertex to be processed, and `pop` to
    remove it.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BFS 函数使用 `std::queue` 的主要操作：`push` 将顶点添加到队列中，`front` 检查下一个要处理的顶点，`pop` 移除它。
- en: Best practices
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::queue`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::queue` 的最佳实践：
- en: '**Maintain a FIFO discipline**: A queue is inherently designed for FIFO operations.
    Attempting to use it for other purposes, such as random access or stack operations
    with LIFO order, can lead to suboptimal designs and complexities.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持FIFO纪律**：队列天生就是为了FIFO操作设计的。尝试将其用于其他目的，如随机访问或使用LIFO顺序的栈操作，可能会导致次优设计和复杂性。'
- en: '`std::queue` does not expose direct iterators. If you need to iterate over
    the elements, consider if a queue is the proper data structure for your needs
    or if the underlying container should be accessed directly.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::queue` 不直接暴露迭代器。如果你需要遍历元素，考虑队列是否适合你的需求，或者是否应该直接访问底层容器。'
- en: '`front()` or `back()`, always check if the queue is empty using the `empty()`
    function. This prevents undefined behavior that could arise from trying to access
    elements in an empty queue.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `front()` 或 `back()` 时，始终使用 `empty()` 函数检查队列是否为空。这可以防止尝试访问空队列中的元素时可能出现的未定义行为。
- en: '`std::queue` is `std::deque`, but you can use others, such as `std::list`.
    Each container has its characteristics, trade-offs, and memory overhead. For example,
    while `std::list` offers efficient insertions and deletions, its memory overhead
    per element is higher than `std::deque`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::queue` 实际上是 `std::deque`，但你可以使用其他容器，例如 `std::list`。每个容器都有其特性、权衡和内存开销。例如，虽然
    `std::list` 提供了高效的插入和删除操作，但其每个元素的内存开销比 `std::deque` 高。'
- en: '`std::mutex`, to avoid data races and inconsistencies. The operations on `std::queue`
    itself are not inherently thread-safe.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::mutex` 来避免数据竞争和不一致性。对 `std::queue` 本身的操作不是天生线程安全的。
- en: '`std::vector` container (though this is rare for a queue). This can be a performance
    concern in real-time or performance-critical applications.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 容器（尽管对于队列来说这很少见）。这在实时或性能关键的应用程序中可能会引起性能问题。'
- en: '`emplace` to construct the element directly within the queue. This can lead
    to more efficient code as it avoids temporary object creation.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emplace` 在队列中直接构建元素。这可以导致更高效的代码，因为它避免了临时对象的创建。
- en: '`std::vector`, `std::queue` doesn’t have capacity-related member functions.
    Without explicit knowledge or control, do not make assumptions about the underlying
    container’s size or capacity.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`，`std::queue` 没有与容量相关的成员函数。在没有明确知识或控制的情况下，不要对底层容器的大小或容量做出假设。'
- en: '`std::deque` provides strong exception safety for its operations, ensuring
    data isn’t corrupted during exceptions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::deque`为其操作提供了强大的异常安全性，确保在异常期间数据不会被损坏。'
- en: '**Be cautious with type aliases**: If you’re using type aliases or auto-typing,
    be sure you know the exact type of your queue, especially if you’re working with
    queues of different underlying containers in the same code base. This ensures
    you don’t mistakenly assume a different container type’s characteristics or performance
    trade-offs.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小心使用类型别名**：如果你正在使用类型别名或自动类型推导，确保你知道队列的确切类型，特别是如果你在同一代码库中处理不同底层容器的队列时。这确保你不会错误地假设不同容器类型的特性或性能权衡。'
- en: std::priority_queue
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::priority_queue`'
- en: Purpose and suitability
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::priority_queue` is an adapter container built on top of a random-access
    container type, primarily `std::vector`. Its core strength revolves around the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue`是一个基于随机访问容器类型（主要是`std::vector`）构建的适配器容器。其核心优势围绕以下方面：'
- en: Always having the highest priority element at the top
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是保持最高优先级元素在顶部
- en: Ensuring efficient insertion and retrieval of the top element
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保高效地插入和检索最高元素
- en: 'It shines in the following scenarios:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下场景中表现出色：
- en: When priority-based access is required
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要基于优先级的访问时
- en: When insertions are random but access always targets the element of the highest
    importance
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入是随机的，但访问总是针对最高重要性的元素时
- en: In scenarios where order is not a concern or insertion order matters more than
    access priority, `std::priority_queue` might not be the ideal choice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序不是关键因素，或者插入顺序比访问优先级更重要的情况下，`std::priority_queue`可能不是最佳选择。
- en: Ideal use cases
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想使用场景
- en: 'The following are some of the ideal use cases for `std::priority_queue`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::priority_queue`的理想使用场景：
- en: '**Job scheduling**: Assigning jobs based on their urgency or priority'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作调度**：根据紧急程度或优先级分配工作'
- en: '**Pathfinding algorithms**: An example of such an algorithm is Dijkstra’s algorithm,
    where nodes with the shortest tentative distance are processed first'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径查找算法**：这类算法的一个例子是Dijkstra算法，其中首先处理具有最短试探距离的节点'
- en: '**Simulation systems**: For events that should be processed based on priority
    rather than sequence'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟系统**：对于应根据优先级而不是顺序处理的事件'
- en: Performance
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Since `std::priority_queue` is a container adaptor, its algorithmic performance
    depends on the underlying container implementation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::priority_queue`是一个容器适配器，其算法性能取决于底层容器实现：
- en: '**Insertion**: *O(log n)*, as the element is placed in its suitable position
    based on its priority'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：*O(log n)*，因为元素根据其优先级放置在其合适的位置'
- en: '**Deletion**: *O(log n)* for the top element as the queue restructures itself'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：最高元素为*O(log n)*，因为队列在重新结构化自身'
- en: '**Access**: *O(1)* to the top element'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：最高元素为*O(1)*'
- en: '**Memory overhead**: Moderate, contingent on the underlying container'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：中等，取决于底层容器'
- en: Note that when using `std::vector` as the underlying container, additional memory
    overheads might appear when it resizes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用`std::vector`作为底层容器时，在调整大小过程中可能会出现额外的内存开销。
- en: Memory management
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: This is inherently dependent on the underlying container. With `std::vector`,
    memory reallocation might happen upon reaching capacity. Allocators can be utilized
    for customization.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上取决于底层容器。使用`std::vector`时，在达到容量时可能会发生内存重新分配。可以使用分配器进行定制。
- en: Thread safety
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent access requires caution. Multiple reads are safe, but simultaneous
    reads or writes demand external synchronization mechanisms, such as mutexes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 并发访问需要谨慎。多个读取是安全的，但同时读取或写入需要外部同步机制，例如互斥锁。
- en: Extensions and variants
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: If you want a container that ensures sequence preservation, you might consider
    `std::queue`. If an associative container with key-value pairs and inherent ordering
    is needed, `std::map` or `std::set` might be more apt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个确保序列保持的容器，你可能会考虑`std::queue`。如果你需要一个具有键值对和固有排序的关联容器，`std::map`或`std::set`可能更合适。
- en: Sorting and searching complexity
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: Sorting does not apply to `std::priority_queue`. Direct access to the top priority
    element for searching is *O(1)*. However, searching for other elements is not
    straightforward and isn’t the primary intent of this container.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 排序不适用于`std::priority_queue`。直接访问最高优先级元素进行搜索是*O(1)*。然而，搜索其他元素并不直接，也不是这个容器的主要目的。
- en: Special interface and member functions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Beyond the basics (`push`, `pop`, `top`), explore the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本操作（`push`、`pop`、`top`）之外，探索以下内容：
- en: '`emplace`: Directly constructs an element within the priority queue'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：直接在优先队列内构建一个元素'
- en: '`size`: Retrieves the number of elements'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：检索元素数量'
- en: '`swap`: Exchanges the contents of two priority queues'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`：交换两个优先队列的内容'
- en: Comparisons
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: In contrast to `std::queue`, which respects FIFO ordering, `std::priority_queue`
    always ensures the highest priority element is accessible. Compared with `std::set`,
    the latter allows ordered access to all elements, while the former focuses on
    priority.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与尊重FIFO排序的`std::queue`相比，`std::priority_queue`始终确保可以访问最高优先级元素。与允许有序访问所有元素的`std::set`相比，前者专注于优先级。
- en: Interactions with algorithms
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Given the lack of iterators, most STL algorithms can’t interact directly with
    `std::priority_queue`. However, it naturally aligns with user-defined algorithms
    that focus on the highest-priority elements, such as those that use `push()` and
    `pop()`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏迭代器，大多数STL算法不能直接与`std::priority_queue`交互。然而，它自然与关注最高优先级元素的用户定义算法相吻合，例如使用`push()`和`pop()`的算法。
- en: Exceptions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Throwing can occur during underlying container operations, such as memory allocation.
    Exception safety often aligns with that of the underlying container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常可能发生在底层容器操作期间，例如内存分配。异常安全性通常与底层容器的异常安全性相一致。
- en: Customization
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: 'Here are some customization options:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些自定义选项：
- en: '**Allocators**: Customize memory allocation using custom allocators'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配器**：使用自定义分配器自定义内存分配'
- en: '**Comparators**: Modify the priority logic using custom comparator functions,
    allowing for a custom definition of *priority*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较器**：使用自定义比较函数修改优先级逻辑，允许自定义*优先级*的定义'
- en: Example
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::priority_queue` is often used in scenarios where elements need to be
    processed based on their priorities. One of the most common examples of using
    `std::priority_queue` is implementing Dijkstra’s shortest path algorithm for weighted
    graphs.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue`常用于需要根据其优先级处理元素的场景。使用`std::priority_queue`的最常见示例之一是实现加权图的Dijkstra最短路径算法。'
- en: 'The following code shows an example of implementing Dijkstra’s algorithm with
    `std::priority_queue`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用`std::priority_queue`实现Dijkstra算法的示例：
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the example output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following happens in this implementation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中发生以下情况：
- en: The `WeightedGraph` class uses an adjacency list to represent the graph, where
    each list element is a pair representing the neighboring vertex and the weight
    of the edge.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeightedGraph`类使用邻接表来表示图，其中每个列表元素都是一个表示相邻顶点和边权重的对。'
- en: The `dijkstra` function calculates the shortest distance from a given vertex
    to all other vertices in the graph.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dijkstra`函数计算图中的给定顶点到所有其他顶点的最短距离。'
- en: '`std::priority_queue` is used to select the next vertex with the shortest known
    distance to process.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue`用于选择具有已知最短距离的最小顶点进行处理。'
- en: Distances to vertices are updated based on the currently processed vertex and
    its neighbors.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于当前处理的顶点和其邻居，更新到顶点的距离。
- en: As the algorithm progresses, `priority_queue` ensures that vertices are processed
    in increasing order of their known shortest distances.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着算法的进行，`priority_queue`确保顶点按其已知最短距离的递增顺序进行处理。
- en: Using `std::priority_queue` provides an efficient way to always process the
    vertex with the smallest known distance in Dijkstra’s algorithm.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::priority_queue`为Dijkstra算法中始终处理具有已知最小距离的顶点提供了一种高效的方法。
- en: Best practices
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::priority_queue`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::priority_queue`的最佳实践：
- en: '`std::priority_queue` is to efficiently access the highest-priority element,
    not to provide ordered access to all its elements. Do not assume you can access
    the elements in a fully sorted order.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue`用于高效访问最高优先级元素，而不是提供所有元素的有序访问。不要假设您可以按完全排序的顺序访问元素。'
- en: '**Custom priority rules**: If the default comparison logic doesn’t meet your
    needs, always provide a custom comparator. This ensures that the queue maintains
    elements according to your specific priority rules.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义优先级规则**：如果默认的比较逻辑不符合您的需求，请始终提供自定义比较器。这确保队列根据您特定的优先级规则维护元素。'
- en: '`std::priority_queue` uses `std::vector` as its underlying container. While
    this is often suitable, switching to containers such as `std::deque` or `std::list`
    can influence performance. Choose the container that aligns with your specific
    requirements.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue` 使用 `std::vector` 作为其底层容器。虽然这通常很合适，但切换到如 `std::deque`
    或 `std::list` 这样的容器可能会影响性能。选择与你的具体要求相匹配的容器。'
- en: '**Check for emptiness**: Before trying to access the top element or perform
    a pop operation, always verify that the queue isn’t empty. This prevents undefined
    behavior.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查是否为空**：在尝试访问顶部元素或执行弹出操作之前，始终验证队列不为空。这可以防止未定义的行为。'
- en: '**Avoid underlying container manipulation**: Directly manipulating the underlying
    container can disrupt the integrity of the priority queue. Avoid this to ensure
    that the priority order remains consistent.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免底层容器操作**：直接操作底层容器可能会破坏优先队列的完整性。避免这样做以确保优先级顺序保持一致。'
- en: '`emplace` method over `push`. This provides more efficient in-place construction
    and can save on unnecessary copies or moves.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emplace` 方法而不是 `push`。这提供了更高效的就地构造，并且可以节省不必要的复制或移动。
- en: '`std::priority_queue` is not inherently thread-safe. If you need to access
    or modify it across multiple threads, ensure you use appropriate synchronization
    mechanisms.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue` 本身不是线程安全的。如果你需要在多个线程中访问或修改它，请确保使用适当的同步机制。'
- en: '**Awareness of internal sorting**: While it’s tempting to think of the priority
    queue as always holding a sorted list of elements, remember that it only ensures
    that the top-most element is the highest priority. The internal order of other
    elements is not guaranteed to be sorted.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意内部排序**：虽然将优先队列视为始终持有排序元素列表很诱人，但请记住，它仅确保最顶端的元素具有最高优先级。其他元素的内部顺序不保证排序。'
- en: '`std::priority_queue` does not provide iterators to its elements. This design
    intentionally keeps users from inadvertently breaking the queue’s priority invariants.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::priority_queue` 不提供其元素的迭代器。这种设计有意让用户避免意外破坏队列的优先级不变性。'
- en: '**Size considerations**: Be mindful of the size and capacity of the underlying
    container, especially if you’re dealing with large datasets. Periodically checking
    and managing capacity can help in optimizing memory usage.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小考虑**：注意底层容器的尺寸和容量，尤其是当你处理大量数据集时。定期检查和管理容量可以帮助优化内存使用。'
- en: By following these best practices, you can ensure that you use `std::priority_queue`
    in a manner that is efficient and consistent with its design intentions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，你可以确保以高效且与其设计意图一致的方式使用 `std::priority_queue`。
- en: std::flat_set
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::flat_set
- en: '`std::flat_set` is a sorted associative container that’s designed to store
    a collection of unique elements in a sorted order. What sets `std::flat_set` apart
    from other associative containers, such as `std::set`, is that it is implemented
    as a flat container, often based on a sorted `std::vector` container. This means
    that elements are stored contiguously in memory, leading to optimal memory usage
    and faster iteration times compared to traditional tree-based associative containers.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_set` 是一个排序的关联容器，旨在以排序顺序存储唯一元素的集合。与其他关联容器（如 `std::set`）相比，`std::flat_set`
    的特点是它实现为一个扁平容器，通常基于排序的 `std::vector` 容器。这意味着元素在内存中连续存储，与传统的基于树的关联容器相比，具有最优的内存使用和更快的迭代时间。'
- en: '`std::flat_set` maintains its elements in a sorted order, allowing for efficient
    searching, insertion, and deletion operations, while also providing similar functionality
    and interface to other set-like containers in the C++ STL. It is especially useful
    when you need the advantages of both sorted storage and efficient memory management.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_set` 维护其元素在一个有序顺序中，允许进行高效的搜索、插入和删除操作，同时提供与其他 C++ STL 中类似容器（如集合）的功能和接口。它在需要排序存储和高效内存管理优势时特别有用。'
- en: Purpose and suitability
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::flat_set` is a container that represents an associative set stored in
    a sorted flat array. It merges the benefits of a `std::vector` container (such
    as cache-friendliness) with those of a `std::set` container (such as ordered storage).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_set` 是一个表示存储在排序扁平数组中的关联集合的容器。它结合了 `std::vector` 容器（如缓存友好性）和 `std::set`
    容器（如有序存储）的优点。'
- en: 'Use `std::flat_set` in the following scenarios:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下场景中使用 `std::flat_set`：
- en: When you need ordered data with set properties
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要具有集合属性的有序数据时
- en: When memory allocation overhead is a concern
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当内存分配开销是一个关注点时
- en: When you want to leverage cache locality advantages similar to those of `std::vector`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想利用与 `std::vector` 类似的缓存局部性优势时
- en: If you need to perform many insertions and deletions, other set types, such
    as `std::set`, may be more suitable due to their tree-based implementation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要执行许多插入和删除操作，其他集合类型，如 `std::set`，可能更适合，因为它们的实现基于树。
- en: Ideal use cases
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想使用场景
- en: 'The following are some of the ideal use cases for `std::flat_set`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::flat_set` 的理想使用场景：
- en: '`std::flat_set` container and sorting it can be efficient'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 容器和对其进行排序可以很高效'
- en: '`std::flat_set` container can be notably faster than tree-based sets for smaller
    sizes'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 容器对于较小的尺寸可以明显快于基于树的集合'
- en: '`std::flat_set` can be advantageous'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 可以具有优势'
- en: Performance
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Since `std::flat_set` is a container adaptor, its algorithmic performance depends
    on the underlying container implementation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::flat_set` 是一个容器适配器，其算法性能取决于底层容器的实现：
- en: '**Insertion**: *O(n)* since shifting may be required'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：*O(n)*，因为可能需要移动'
- en: '**Deletion**: *O(n)* for the same reasons'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：*O(n)*，原因相同'
- en: '**Access**: *O(log n)* for lookup using binary search'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：使用二分搜索进行查找的 *O(log n)*'
- en: '**Memory overhead**: Less than tree-based structures due to fewer memory allocations'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于内存分配较少，少于基于树的结构'
- en: The trade-off is the speed of lookups versus the cost of insertion and deletion,
    especially as the set grows.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 代价是查找速度与插入和删除成本的权衡，尤其是在集合增长时。
- en: Memory management
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::flat_set` uses a contiguous block of memory (similar to `std::vector`).
    Reallocations occur when this block is exhausted. You can influence the allocation
    strategy using custom allocators.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_set` 使用一段连续的内存块（类似于 `std::vector`）。当这块内存耗尽时会发生重新分配。你可以使用自定义分配器来影响分配策略。'
- en: Thread safety
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: As with most STL containers, concurrent reads are safe, but writes or mixed
    operations necessitate external synchronization.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 STL 容器一样，并发读取是安全的，但写入或混合操作需要外部同步。
- en: Extensions and variants
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::flat_map` is a cousin of `std::flat_set` that stores key-value pairs
    in a flat structure. It offers similar performance characteristics and uses.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map` 是 `std::flat_set` 的一个近亲，它在一个扁平结构中存储键值对。它提供了类似的表现特性和用途。'
- en: Sorting and searching complexity
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它的排序和搜索复杂度如下：
- en: '**Sorting**: Inherent to the container and usually *O(n* *log n)*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：固有的容器操作，通常为 *O(n log n)*'
- en: '**Searching**: *O(log n)* due to binary search on sorted data'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于对排序数据进行二分搜索，*O(log n)*'
- en: Special interface and member functions
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Apart from the typical set functions (`insert`, `erase`, `find`), consider
    the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了典型的集合函数（`insert`、`erase`、`find`）之外，请考虑以下内容：
- en: '`reserve`: Allocates memory in anticipation of insertions'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserve`：为了预期插入操作而分配内存'
- en: '`capacity`: Returns the current allocation size'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capacity`：返回当前的分配大小'
- en: Comparisons
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: In contrast to `std::set`, `std::flat_set` offers better cache locality but
    can become inefficient with frequent insertions/deletions in large datasets.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::set` 相比，`std::flat_set` 提供更好的缓存局部性，但在大型数据集中频繁的插入/删除操作中可能会变得低效。
- en: Interactions with algorithms
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: STL algorithms that require random-access iterators, such as `std::sort()`,
    can be applied directly. However, remember that `std::flat_set` maintains its
    sorted order, so sorting manually is redundant.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 需要随机访问迭代器的 STL 算法，如 `std::sort()`，可以直接应用。然而，请记住 `std::flat_set` 维持其排序顺序，因此手动排序是多余的。
- en: Exceptions
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Misusing iterators or exceeding capacity can cause exceptions. Many operations
    provide strong exception safety, ensuring container consistency.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 错误使用迭代器或超出容量可能导致异常。许多操作提供了强大的异常安全性，确保容器的一致性。
- en: Customization
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: '`std::flat_set` permits custom allocators, allowing for refined memory control.
    You can also supply custom comparators for specialized sorting.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_set` 允许使用自定义分配器，从而实现精细的内存控制。你也可以提供自定义比较器以进行专门的排序。'
- en: Best practices
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::flat_set`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::flat_set` 的最佳实践：
- en: '`std::flat_set` is best suited for use cases where the set is built once and
    queried multiple times. If your application demands frequent insertions and deletions,
    a traditional tree-based `std::set` container might be more appropriate.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 最适合于一旦构建就多次查询的用例。如果你的应用程序需要频繁的插入和删除，传统的基于树的 `std::set` 容器可能更合适。'
- en: '`std::flat_set` over other set implementations is its continuous memory layout,
    making it cache-friendly. This can lead to significant performance improvements
    for smaller datasets or when the data can fit into the cache.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 相比其他集合实现的优势在于其连续的内存布局，这使得它对缓存友好。这可以导致对于小数据集或数据可以放入缓存的情况，性能有显著提升。'
- en: '`std::flat_set` containers and need to merge them, consider inserting all elements
    into a single container first, then sort and make the entire collection unique.
    This approach is often more efficient than merging sorted sets element by element.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要合并 `std::flat_set` 容器，考虑首先将所有元素插入到一个容器中，然后排序并使整个集合唯一。这种方法通常比逐个元素合并排序集合更有效。
- en: '`reserve` method is advisable if you have a reasonable estimate of the number
    of elements you’ll be inserting. This can minimize memory reallocations and enhance
    performance.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个合理的元素插入数量估计，建议使用 `reserve` 方法。这可以最小化内存重新分配并提高性能。
- en: '`std::set` container, which is tree-based and can handle such modifications
    more gracefully.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set` 容器，它是基于树的，可以更优雅地处理此类修改。'
- en: '`std::flat_set` maintains its elements in a sorted order, it’s crucial to avoid
    manually sorting the container. Adding elements to a `std::flat_set` container
    will keep them in order based on the provided comparator.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 维护其元素在一个排序顺序中，避免手动对容器进行排序至关重要。向 `std::flat_set` 容器中添加元素将根据提供的比较器保持它们的顺序。'
- en: '`std::flat_set` offers member functions such as `find` for efficient searching,
    they are optimized for its internal structure. Using these member functions is
    generally more efficient than applying generic algorithms. If you ever need to
    use algorithms, ensure they are designed for sorted sequences, such as `std::lower_bound`
    or `std::upper_bound`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 提供了如 `find` 等成员函数，用于高效搜索，它们针对其内部结构进行了优化。使用这些成员函数通常比应用泛型算法更有效。如果你需要使用算法，确保它们是为排序序列设计的，例如
    `std::lower_bound` 或 `std::upper_bound`。'
- en: '`std::flat_set` is `std::less`. However, if your data requires custom sorting
    logic, ensure you provide a custom comparator during the set’s construction. Remember,
    this comparator should give a strict weak ordering to maintain the set’s properties.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 的默认比较器是 `std::less`。然而，如果你的数据需要自定义排序逻辑，确保在集合构建时提供自定义比较器。记住，这个比较器应该提供严格的弱顺序以保持集合的性质。'
- en: '`std::flat_set` provides. If your use case has such patterns, evaluate if other
    containers might be more suitable.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 提供。如果你的用例有这种模式，评估其他容器可能更适合。'
- en: '`std::set`, modifying elements (for example, through iterators) in a `std::flat_set`
    container without ensuring the order can lead to undefined behavior. Always confirm
    that the sorted order is maintained post modifications.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `std::flat_set` 容器中修改元素（例如，通过迭代器）而不确保顺序，可能会导致未定义的行为。始终确认修改后排序顺序保持不变。
- en: '`std::flat_set` works well with algorithms that have been optimized for random-access
    iterators. However, be cautious with algorithms that modify the order or content
    as they can violate the set’s properties.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_set` 与经过优化的随机访问迭代器的算法配合良好。然而，对于修改顺序或内容的算法要小心，因为它们可能会违反集合的性质。'
- en: std::flat_map
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::flat_map
- en: '`std::flat_map` is a sorted associative container that combines the features
    of a map and a flat container. Similar to `std::map`, it allows you to store key-value
    pairs, and the keys are unique and ordered. However, unlike `std::map`, which
    is typically implemented as a balanced binary search tree, `std::flat_map` is
    implemented as a flat container, often based on a sorted `std::vector` container.
    This means that `std::flat_map` offers efficient memory usage and faster iteration
    times than traditional tree-based associative containers such as `std::map`. Elements
    in a `std::flat_map` container are stored contiguously in memory, which can lead
    to better cache locality and improved performance for certain use cases.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map` 是一个排序的关联容器，它结合了 map 和 flat 容器的特性。类似于 `std::map`，它允许你存储键值对，键是唯一的且有序的。然而，与通常作为平衡二叉搜索树实现的
    `std::map` 不同，`std::flat_map` 是一个 flat 容器，通常基于一个排序的 `std::vector` 容器。这意味着 `std::flat_map`
    提供了比传统的基于树的关联容器（如 `std::map`）更高效的内存使用和更快的迭代时间。`std::flat_map` 容器中的元素在内存中连续存储，这可能导致更好的缓存局部性和针对某些用例的性能提升。'
- en: '`std::flat_map` provides functionality and interface similar to `std::map`,
    allowing you to perform operations such as insertion, deletion, and searching
    while maintaining the elements in a sorted order. It’s beneficial when you need
    both the advantages of sorted storage and the benefits of a flat container.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map`提供了类似于`std::map`的功能和接口，允许你在保持元素排序顺序的同时执行插入、删除和搜索等操作。当你需要排序存储的优势和平坦容器的优势时，它是有益的。'
- en: Purpose and suitability
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::flat_map` is a container that pairs together keys and values, functioning
    as an associative array. The following reasons set it apart from other map containers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map`是一个将键和值配对的容器，作为关联数组使用。以下原因使其与其他映射容器区分开来：'
- en: It uses a vector-like structure, granting advantages in cache locality.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用类似向量的结构，提供了缓存局部性的优势。
- en: This contiguous memory layout fosters improved lookup times in some scenarios.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种连续的内存布局在某些场景中促进了改进的查找时间。
- en: 'Its niche lies in the following scenarios:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它的利基市场在于以下场景：
- en: When the map is mainly built once and then often queried
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当映射主要是在构建一次然后经常查询时
- en: When iteration speed and cache locality take precedence over insertion/deletion
    speed
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代速度和缓存局部性比插入/删除速度更重要时
- en: When a sorted map representation is essential
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当排序的映射表示至关重要时
- en: If you foresee frequent modifications post-initialization, consider using `std::map`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预见初始化后频繁的修改，考虑使用`std::map`。
- en: Ideal use cases
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::flat_map`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::flat_map`的理想用例：
- en: '**Configuration data**: Storing configuration key-value pairs loaded once at
    startup but queried frequently during application runtime'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置数据**：存储在启动时加载一次但在应用程序运行时频繁查询的配置键值对'
- en: '**Spatial indexing**: In graphics or game development, quick iteration and
    retrieval are more critical than frequent modifications'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间索引**：在图形或游戏开发中，快速迭代和检索比频繁修改更重要'
- en: '**Data serialization**: For datasets that require sorting and occasional lookups
    but aren’t modified regularly'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据序列化**：对于需要排序和偶尔查找但不是经常修改的数据集'
- en: Performance
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: '**Insertion**: *O(n)* due to the underlying vector structure'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：由于底层向量结构，为*O(n)*'
- en: '**Deletion**: *O(n)* because elements may need to be shifted'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：由于可能需要移动元素，为*O(n)*'
- en: '**Access**: *O(log n)* due to binary search on the sorted array'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：由于对排序数组进行二分搜索，为*O(log n)*'
- en: '**Memory overhead**: Generally, this is low, but it can escalate if the reserved
    capacity isn’t utilized efficiently'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：通常，这很低，但如果预留容量未有效利用，则可能会增加'
- en: Memory management
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::flat_map`, like `std::vector`, may reallocate when its capacity is surpassed.
    It’s wise to employ `reserve` if you can predict the eventual size. Allocators
    can provide control over memory management behaviors.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map`，像`std::vector`一样，当其容量超过时可能会重新分配。如果你可以预测最终的大小，使用`reserve`是明智的。分配器可以提供对内存管理行为的控制。'
- en: Thread safety
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: While concurrent reads are safe, writes or a mixture of both necessitate external
    synchronization – for example, using mutexes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并发读取是安全的，但写入或两者的组合需要外部同步——例如，使用互斥锁。
- en: Extensions and variants
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: For unordered associative containers, the STL offers `std::unordered_map`. If
    a balanced tree structure with ordered keys is preferred, then `std::map` is your
    go-to.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无序关联容器，STL提供了`std::unordered_map`。如果你更喜欢具有有序键的平衡树结构，那么`std::map`是你的首选。
- en: Sorting and searching complexity
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 它的排序和搜索复杂度如下：
- en: '**Sorting**: Inherent to its structure, it always maintains order'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：由于其结构固有，它始终保持有序'
- en: '**Searching**: *O(log n)* due to binary search'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于二分搜索，为*O(log n)*'
- en: Interface and member functions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和成员函数
- en: 'Common members such as `insert`, `find`, and `erase` are present. However,
    you should also explore the following gems:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 常见成员如`insert`、`find`和`erase`都存在。但是，你也应该探索以下珍宝：
- en: '`emplace`: Directly constructs elements in place'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`: 直接在原地构建元素'
- en: '`lower_bound` and `upper_bound`: These provide efficient range searches'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower_bound`和`upper_bound`：这些提供了有效的范围搜索'
- en: '`at`: Provides direct access to values by key with bounds-checking'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`: 通过键提供带边界检查的直接访问值'
- en: Comparisons
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: '`std::flat_map` excels in iteration and lookup performance, especially for
    smaller datasets. However, if frequent modifications dominate your use case, you
    might lean toward `std::map`.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map` 在迭代和查找性能方面表现出色，尤其是在较小的数据集上。然而，如果频繁的修改主导了您的用例，您可能会倾向于 `std::map`。'
- en: Interactions with algorithms
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Due to its random-access nature, `std::flat_map` pairs well with STL algorithms
    that thrive on such iterators. However, any algorithm that disrupts the key order
    should be approached cautiously.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其随机访问特性，`std::flat_map` 与在迭代器上茁壮成长的 STL 算法配合良好。然而，任何破坏键顺序的算法都应谨慎处理。
- en: Exceptions
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Exceeding capacity or accessing out-of-bounds keys might trigger exceptions.
    Many operations offer strong exception safety, preserving map states if exceptions
    arise.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 超出容量或访问越界键可能会触发异常。许多操作提供了强大的异常安全性，在出现异常时保留映射状态。
- en: Customization
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: '`std::flat_map` allows for custom allocators, and you can specify a custom
    comparator during construction to dictate the key order.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_map` 允许自定义分配器，您可以在构造时指定自定义比较器以指定键顺序。'
- en: Best practices
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Let’s explore the best practices of using `std::flat_map:`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::flat_map` 的最佳实践：
- en: '`std::flat_map` for frequent insertions and deletions due to the high cost.
    For such cases, consider alternatives, such as `std::map`.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于插入和删除的高成本，`std::flat_map` 适用于频繁的插入和删除。对于此类情况，请考虑替代方案，例如 `std::map`。
- en: '**Key modifications**: Do not alter keys directly using iterators. This disrupts
    the sorted order of the map. If keys need to be modified, consider erasing the
    old key-value pair and inserting a new one to ensure order maintenance.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键修改**：不要直接使用迭代器修改键。这会破坏映射的排序顺序。如果需要修改键，请考虑删除旧键值对并插入一个新的，以确保顺序维护。'
- en: '`reserve()` to reduce the frequency of memory reallocations, enhancing performance.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `reserve()` 减少内存重新分配的频率，提高性能。
- en: '`emplace` to construct key-value pairs in place efficiently, maximizing performance
    and avoiding unnecessary temporary object creation.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emplace` 在原地高效地构建键值对，最大化性能并避免不必要的临时对象创建。
- en: '`std::map` may offer better performance profiles in such scenarios.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此类场景中，`std::map` 可能会提供更好的性能指标。
- en: '**Concurrency**: Ensure thread safety during multi-threaded access. Concurrent
    reads are generally safe, but writing or mixed read-write operations require external
    synchronization, such as mutexes.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：确保在多线程访问期间线程安全。并发读取通常是安全的，但写入或混合读写操作需要外部同步，例如互斥锁。'
- en: '`std::flat_map`. It offers superior cache locality and efficient lookups, especially
    when the map is mainly queried post-initialization.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_map`。它提供了优越的缓存局部性和高效的查找，尤其是在映射主要在初始化后查询时。'
- en: '`std::flat_map`, be cautious of operations that may disrupt this order. Always
    validate the order after any modifications to ensure the container’s integrity.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_map`，在操作可能破坏此顺序时要小心。在修改后始终验证顺序以确保容器的完整性。'
- en: '`lower_bound` and `upper_bound` for efficient range-based queries, leveraging
    the container’s sorted characteristics.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lower_bound` 和 `upper_bound` 进行高效的基于范围的查询，利用容器的排序特性。
- en: '`std::less`) works for many scenarios, `std::flat_map` allows you to specify
    custom comparators during instantiation, tailoring the key order to specific needs.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::less`) 在许多场景下适用，`std::flat_map` 允许在实例化期间指定自定义比较器，以根据特定需求定制键顺序。'
- en: std::flat_multiset
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::flat_multiset
- en: '`std::flat_multiset` is a container that was introduced in the C++ STL that’s
    designed to store elements in a sorted order. Unlike `std::multiset`, which is
    typically implemented as a red-black tree, `std::flat_multiset` stores its elements
    in a contiguous memory block, similar to a `std::vector` container. This design
    choice offers improved cache performance due to data locality, making it efficient
    for scenarios where the container is not frequently modified after being filled.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 是在 C++ STL 中引入的容器，旨在按排序顺序存储元素。与通常作为红黑树实现的 `std::multiset`
    不同，`std::flat_multiset` 将其元素存储在连续的内存块中，类似于 `std::vector` 容器。这种设计选择由于数据局部性而提供了改进的缓存性能，使其在容器在填充后不经常修改的情况下效率更高。'
- en: Purpose and suitability
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`Std::flat_multiset` is a container that stores elements in a sorted array,
    similar to `std::flat_set`, but allows for multiple occurrences of equivalent
    elements.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Std::flat_multiset` 是一个存储元素在排序数组中的容器，类似于 `std::flat_set`，但允许出现多个等效元素。'
- en: 'This container offers the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器提供以下功能：
- en: Efficient lookup times thanks to its sorted nature
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其排序特性，具有高效的查找时间
- en: Improved cache locality and predictability in memory usage
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善了缓存局部性和内存使用的可预测性
- en: 'It’s especially suitable in the following scenarios:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下场景中尤其适用：
- en: When duplicates are permissible and you need sorted access
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当允许重复且需要排序访问时
- en: When cache locality is prioritized
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当优先考虑缓存局部性时
- en: When the dataset’s size is relatively stable post-initialization
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化后，数据集的大小相对稳定
- en: However, other containers might be more appropriate when frequent insertions
    or deletions become the norm.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当频繁的插入或删除成为常态时，其他容器可能更合适。
- en: Ideal use cases
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想的使用场景
- en: 'The following are some of the ideal use cases for `std::flat_multiset`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::flat_multiset` 的理想使用场景：
- en: '**Historical records**: Storing repeated events in chronological order, such
    as transaction logs'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史记录**：按时间顺序存储重复事件，例如交易日志'
- en: '**Frequency counter**: Counting occurrences of elements when order and access
    speed are vital'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率计数器**：当顺序和访问速度至关重要时，计算元素出现的次数'
- en: '**Sorted buffers**: Temporary storage during processing, where the order is
    crucial, and duplicates are expected'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序缓冲区**：处理过程中的临时存储，其中顺序至关重要，且预期会有重复'
- en: Performance
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Since `std::flat_multiset` is a container adaptor, its algorithmic performance
    depends on the underlying container implementation:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::flat_multiset` 是一个容器适配器，其算法性能取决于底层容器的实现：
- en: '**Insertion**: *O(n)* since maintaining order may necessitate element shifting'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：由于维护顺序可能需要元素移动，所以是 *O(n)*'
- en: '**Deletion**: *O(n)* due to the possibility of shifting to fill gaps'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：由于可能需要移动以填充间隙，所以是 *O(n)*'
- en: '**Access**: *O(log n)* for lookups owing to binary search'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：由于二分搜索，查找效率为 *O(log n)*'
- en: '`std::vector`, but the lack of tree structures minimizes memory overhead'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`，但缺乏树结构最小化了内存开销'
- en: Memory management
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::flat_multiset` manages memory in chunks. Pre-allocating memory using
    `reserve()` can prevent frequent reallocations. Custom allocators can further
    modify allocation behavior.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 以块的形式管理内存。使用 `reserve()` 预分配内存可以防止频繁的重新分配。自定义分配器可以进一步修改分配行为。'
- en: Thread safety
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Simultaneous reads are safe. However, concurrent modifications or simultaneous
    reads and writes need external synchronization mechanisms.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 同时读取是安全的。然而，并发修改或同时读取和写入需要外部同步机制。
- en: Extensions and variants
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: While `std::flat_multiset` stores multiple instances of an element, `std::flat_set`
    is its unique element counterpart. For hash-based approaches, you might want to
    look at `std::unordered_multiset`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::flat_multiset` 存储一个元素的多个实例，但 `std::flat_set` 是其唯一元素对应物。对于基于哈希的方法，你可能想看看
    `std::unordered_multiset`。
- en: Sorting and searching complexity
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它的排序和搜索复杂度如下：
- en: '`std::flat_multiset` maintains order'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 维护顺序'
- en: '**Searching**: Efficient *O(log n)* due to binary searching'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于二分搜索，效率为 *O(log n)*'
- en: Special interface and member functions
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: '`std::flat_multiset` offers much the same interface as its underlying type.
    Here are some especially useful functions:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 提供了与底层类型几乎相同的接口。以下是一些特别有用的函数：'
- en: '`equal_range`: Returns range of equivalent elements'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range`：返回等效元素的区间'
- en: '`count`: Efficiently counts the occurrences of an element'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：高效地计算元素出现的次数'
- en: '`emplace`: Constructs elements directly in place'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：直接在原地构造元素'
- en: Comparisons
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to `std::multiset`, `std::flat_multiset` offers a better cache locality
    but may suffer from frequent modifications. It excels in read-heavy scenarios
    post-initialization.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::multiset` 相比，`std::flat_multiset` 提供了更好的缓存局部性，但可能因频繁修改而受到影响。初始化后，它在读密集型场景中表现出色。
- en: Interactions with algorithms
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Being sorted, `std::flat_multiset` resonates well with binary search-based algorithms.
    However, those that shuffle or reorder might not be ideal.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于是排序的，`std::flat_multiset` 与基于二分搜索的算法非常协调。然而，那些打乱或重新排序的算法可能并不理想。
- en: Exceptions
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Attempting to access out-of-bounds or mismanaging memory can lead to exceptions.
    Generally, operations are exception-safe, ensuring the container remains consistent.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问越界或管理内存不当可能导致异常。通常，操作是异常安全的，确保容器保持一致性。
- en: Customization
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: '`std::flat_multiset` supports custom allocators, allowing for memory allocation
    fine-tuning. Moreover, custom comparators can adjust the sorting behavior.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 支持自定义分配器，允许对内存分配进行微调。此外，自定义比较器可以调整排序行为。'
- en: Best practices
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::flat_multiset`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::flat_multiset` 的最佳实践：
- en: '`std::flat_multiset` primarily in scenarios where the set size stabilizes post-initialization.
    Frequent insertions or deletions will lead to inefficiencies due to the need to
    maintain a sorted order, often leading to element shifting.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 主要适用于初始化后集合大小稳定的场景。频繁的插入或删除会导致由于需要维护排序顺序而导致的效率低下，通常会导致元素移动。'
- en: '`std::multiset`, the iterators for `std::flat_multiset` can become invalidated
    post-modification, especially those that change the container’s size. Always reassess
    iterator validity after altering the container.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset`，`std::flat_multiset` 的迭代器在修改后可能会失效，尤其是那些改变容器大小的操作。在修改容器后，始终重新评估迭代器的有效性。'
- en: '`std::flat_multiset` container, employ `reserve()` to allocate sufficient memory
    upfront. This prevents recurrent and costly reallocations. While reserving space
    for anticipated growth is important, over-reservation can lead to unnecessary
    memory consumption. Aim for a balance between the two.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `std::flat_multiset` 容器中，使用 `reserve()` 在一开始就分配足够的内存。这可以防止重复和昂贵的重新分配。虽然为预期的增长预留空间很重要，但过度预留会导致不必要的内存消耗。在两者之间寻求平衡。
- en: '`std::flat_multiset` is more suitable than `std::flat_set`. It retains all
    instances of an element, whereas the latter only keeps unique entries.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 比起 `std::flat_set` 更为合适。它保留了一个元素的所有实例，而后者只保留唯一条目。'
- en: '`std::list` or `std::multiset` might offer more efficiency for such operations.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::list` 或 `std::multiset` 可能会为这类操作提供更高的效率。'
- en: '`emplace()` to construct elements directly within the set. This can eliminate
    unnecessary temporary constructions and copies, particularly for complex data
    types.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emplace()` 在集合内直接构造元素。这可以消除不必要的临时构造和复制，特别是对于复杂的数据类型。
- en: '`std::flat_multiset` is safe. Writing operations, whether they’re insertions,
    deletions, or modifications, require synchronization in a multi-threaded environment
    to ensure data integrity and prevent data races.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 是安全的。写入操作，无论是插入、删除还是修改，在多线程环境中都需要同步，以确保数据完整性和防止数据竞争。'
- en: '`std::flat_multiset` pairs well with STL algorithms that benefit from sorted
    datasets, such as `std::lower_bound` or `std::upper_bound`. However, remember
    that algorithms that alter the order or introduce elements might invalidate this
    inherent sorting.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multiset` 与受益于排序数据集的 STL 算法配合良好，例如 `std::lower_bound` 或 `std::upper_bound`。然而，请记住，改变顺序或引入元素的算法可能会使这种固有的排序失效。'
- en: '`std::flat_multiset` to control its ordering behavior.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::flat_multiset` 来控制其排序行为。
- en: '**Exception safety**: Be aware of operations that can throw exceptions, such
    as memory allocation failures. Ensuring exception-safe code will prevent data
    inconsistencies and potential memory leaks.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常安全性**：注意可能抛出异常的操作，例如内存分配失败。确保异常安全代码将防止数据不一致和潜在的内存泄漏。'
- en: std::flat_multimap
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::flat_multimap
- en: '`std::flat_multimap` is a container adapter that combines the characteristics
    of associative and sequence containers. It stores key-value pairs, similar to
    `std::multimap`, but with a significant distinction: the elements are stored in
    a flat, contiguous memory space, akin to a `std::vector` container. This storage
    approach enhances cache performance due to improved data locality, which is especially
    beneficial for read-intensive operations.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_multimap` 是一个结合了关联和序列容器特性的容器适配器。它存储键值对，类似于 `std::multimap`，但有一个显著的区别：元素存储在一个平坦的、连续的内存空间中，类似于
    `std::vector` 容器。这种存储方法由于提高了数据局部性而增强了缓存性能，这对于读取密集型操作特别有益。'
- en: Purpose and suitability
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`Std::flat_multimap` is a container within the STL that’s optimized for fast
    associative lookups. Its distinguishing features include the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Std::flat_multimap` 是 STL 中的一个容器，针对快速关联查找进行了优化。其显著特点包括以下内容：'
- en: Storage in a sorted contiguous block of memory, akin to `std::vector`
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在类似 `std::vector` 的有序连续内存块中
- en: Allows multiple key-value pairs with identical keys
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许存在具有相同键的多个键值对
- en: 'It is most suitable in the following scenarios:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下场景中最为合适：
- en: When cache locality and associative lookups are both desired
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要缓存局部性和关联查找时
- en: When the dataset stabilizes post-initialization since it’s not optimized for
    frequent insertions or deletions
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始化后数据集稳定时，因为它不是为频繁的插入或删除而优化的
- en: Pick `std::flat_multimap` over other containers when the advantages of flat
    storage and allowance for key duplicity align with your use case.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当扁平存储和允许键重复的优势与你的使用场景相匹配时，选择`std::flat_multimap`而不是其他容器。
- en: Ideal use cases
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想使用场景
- en: 'The following are some of the ideal use cases for `std::flat_multimap`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::flat_multimap`的理想使用场景：
- en: '**Web browser history**: Storing URLs with timestamps. Multiple entries (timestamps)
    can exist for the same URL (key).'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web浏览器历史记录**：存储带有时间戳的URL。对于同一URL（键）可以存在多个条目（时间戳）。'
- en: '**Word frequency counter**: When words in a piece of text can have multiple
    meanings and you want to store each meaning alongside its count.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**词频计数器**：当文本中的单词可以有多个含义，并且你想要存储每个含义及其计数时。'
- en: '**Event scheduler**: To maintain events (values) that occur at specific times
    (keys), where multiple events might happen at the same timestamp.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件调度器**：用于维护在特定时间（键）发生的事件（值），其中可能在同一时间戳发生多个事件。'
- en: Performance
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Since `std::flat_multimap` is a container adaptor, its algorithmic performance
    depends on the underlying container implementation:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::flat_multimap`是一个容器适配器，其算法性能取决于底层容器的实现：
- en: '**Insertion**: *O(n)* due to potential element shifting'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：由于可能需要元素移动，为*O(n)*'
- en: '**Deletion**: *O(n)* due to maintaining order'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：由于维护顺序，为*O(n)*'
- en: '**Access**: *O(log n)* due to binary search on a sorted array'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：由于在排序数组上进行二分搜索，为*O(log n)*'
- en: '**Memory overhead**: Relatively low with advantages in cache locality'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：相对较低，具有缓存局部性的优势'
- en: The trade-off lies in enjoying faster lookups at the cost of slower insertions
    and deletions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 代价在于在查找更快的同时，插入和删除会变慢。
- en: Memory management
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::flat_multimap` manages memory akin to `std::vector`. The `reserve()`
    function can anticipate and allocate memory for growth. Custom allocators can
    further tailor memory behaviors.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::flat_multimap`管理内存的方式类似于`std::vector`。`reserve()`函数可以预测并分配增长所需的内存。自定义分配器可以进一步调整内存行为。'
- en: Thread safety
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全性
- en: Concurrent reads are safe. However, writes or mixed read-writes require synchronization
    mechanisms such as mutexes.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，写入或混合读写需要同步机制，如互斥锁。
- en: Extensions and variants
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: For a container without duplicate key allowance, there’s `std::flat_map`. For
    unsorted and bucketed storage, you might want to consider `std::unordered_multimap`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不允许重复键的容器，有`std::flat_map`。对于未排序和分桶存储，你可能想考虑`std::unordered_multimap`。
- en: Sorting and searching complexity
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 其排序和搜索复杂度如下所述：
- en: '**Sorting**: Inherent to the container and managed internally'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：是容器固有的，由内部管理'
- en: '**Searching**: *O(log n)* due to binary search'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于二分搜索，为*O(log n)*'
- en: Interface and member functions
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和成员函数
- en: 'Apart from the standard functions (`insert`, `erase`, `find`), explore the
    following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准函数（`insert`、`erase`、`find`）之外，探索以下内容：
- en: '`equal_range`: Returns bounds of all entries matching a key'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range`：返回匹配键的所有条目的界限'
- en: '`emplace`: Directly constructs key-value pairs inside the map'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：直接在映射内构建键值对'
- en: Comparisons
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Compared to `std::multimap`, `std::flat_multimap` offers better cache locality
    but slower modifications. When juxtaposed with `std::unordered_multimap`, it trades
    faster lookups for inherent sorting.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::multimap`相比，`std::flat_multimap`提供了更好的缓存局部性，但修改较慢。与`std::unordered_multimap`相比，它以更快的查找速度换取了固有的排序。
- en: Interactions with algorithms
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: '`std::flat_multimap` is beneficial with algorithms such as `std::lower_bound`
    and `std::upper_bound` due to its sorted nature. However, be cautious with algorithms
    that modify order or introduce elements.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其排序特性，`std::flat_multimap`与`std::lower_bound`和`std::upper_bound`等算法结合使用时很有益。然而，对于修改顺序或引入元素的算法要小心。
- en: Exceptions
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Key insertions or lookups won’t throw, but be wary of memory allocation failures,
    especially during insertions, which can cause exceptions. Exception safety is
    prioritized, with many operations offering strong guarantees.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 键插入或查找不会抛出异常，但要注意内存分配失败，尤其是在插入期间，这可能导致异常。异常安全性是优先考虑的，许多操作提供了强有力的保证。
- en: Customization
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: While custom allocators are permitted, `std::flat_multimap` relies on its internal
    sorting mechanism. Thus, custom comparators are essential to define key order.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然允许使用自定义分配器，但 `std::flat_multimap` 依赖于其内部排序机制。因此，定义键顺序的自定义比较器是必不可少的。
- en: Best practices
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::flat_multimap`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::flat_multimap` 的最佳实践：
- en: '`std::flat_multimap` when the use case involves continuous or frequent insertions
    and deletions. Due to the container’s linear nature, such operations can be costly.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用例涉及连续或频繁的插入和删除时，使用 `std::flat_multimap`。由于容器的线性特性，此类操作可能成本高昂。
- en: '`std::flat_multimap` only supports input, output, forward, and bidirectional
    iterators. It does not provide random-access iterators.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multimap` 只支持输入、输出、前向和双向迭代器。它不提供随机访问迭代器。'
- en: '**Key data type considerations**: Prefer concise and lightweight data types
    for keys. Using large custom data types can exacerbate the costs of element shifting
    during insertions and deletions.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键数据类型考虑**：对于键，优先选择简洁和轻量级的数据类型。使用大型自定义数据类型可能会加剧插入和删除时元素移动的成本。'
- en: '`std::flat_multimap`, leverage the `reserve()` function. Pre-allocating memory
    can mitigate expensive reallocations and copying.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `std::flat_multimap` 的 `reserve()` 函数。预分配内存可以减轻昂贵的重新分配和复制。
- en: '`emplace` method for in-situ construction of key-value pairs. This can be more
    efficient than creating and inserting an entry separately.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `emplace` 方法就地构建键值对。这比分别创建和插入条目更有效。
- en: '`std::multimap` or `std::unordered_multimap`. These containers might offer
    better performance for such scenarios.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 或 `std::unordered_multimap`。这些容器在类似场景下可能提供更好的性能。'
- en: '`std::flat_multimap`. Concurrent reads are typically safe but write operations
    can lead to race conditions without proper synchronization.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multimap`。并发读取通常是安全的，但如果没有适当的同步，写操作可能导致竞争条件。'
- en: '`std::flat_multimap` retains its internal ordering based on your specific requirements.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multimap` 保留其内部排序，以满足您的特定要求。'
- en: '`std::flat_multimap`, binary search algorithms, such as `std::lower_bound`
    and `std::upper_bound`, can be used efficiently for operations such as range queries
    or finding specific keys.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multimap`，可以使用二分搜索算法，如 `std::lower_bound` 和 `std::upper_bound`，来有效地执行范围查询或查找特定键的操作。'
- en: '`std::flat_multimap` offer strong exception guarantees, ensuring that the container
    remains consistent, even if an operation throws an exception.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flat_multimap` 提供强大的异常保证，确保即使操作抛出异常，容器也能保持一致性。'
- en: '`std::flat_multimap`, use member functions such as `equal_range` to handle
    and process all entries associated with a specific key.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::flat_multimap` 的成员函数，如 `equal_range`，来处理和加工与特定键相关联的所有条目。
- en: '`std::flat_multimap` using member functions such as `capacity()` and `size()`.
    If excess reserved space isn’t being utilized, consider using `shrink_to_fit()`
    to release this memory.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::flat_multimap` 的成员函数，如 `capacity()` 和 `size()`。如果未使用额外的预留空间，考虑使用 `shrink_to_fit()`
    释放此内存。
