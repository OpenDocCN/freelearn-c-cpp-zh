# 最佳实践

与每个软件项目一样，都会存在一些常见问题和陷阱。在嵌入式开发中，硬件方面被加入其中，从而产生一系列独特的问题。从资源管理问题到中断故障以及由硬件问题引起的奇怪行为，本附录将向您展示如何预防和处理这些问题中的许多。此外，它还展示了各种优化方法和需要注意的事项。在本附录中，我们将涵盖以下主题：

+   优化嵌入式代码的安全方法

+   如何避免和修复各种常见的软件和硬件相关的问题

+   认识到硬件世界的缺陷以及如何将其整合到设计中

# 所有精心制定的计划

与任何项目一样，预期设计和实际功能之间不可避免地存在分歧。即使有最好的规划和丰富的经验，也总会存在不可预见或未注意到的问题。你能做的最好的事情就是尽可能做好准备。

第一步是获取目标平台的所有可用信息，了解可用的工具，并制定一个坚实的开发和测试计划。我们已经在本书中讨论了许多这些方面。

在本附录中，我们将总结一些最佳实践，这应该有助于您避免一些更常见的问题。

# 与硬件协同工作

每个目标平台都有其独特的特性和特点。这很大程度上归因于该平台的发展历史。对于 AVR 这样的平台，由于其由单一公司（Atmel）在多年内开发，因此相当一致，不同芯片之间以及用于该平台的各种工具之间都相当一致。

ESP8266（以及在一定程度上其继任者 ESP32）这样的平台从未被设计成通用的 MCU 系统，这在它的相当简略和碎片化的软件生态系统中表现得尤为明显。尽管过去几年中情况有所改善，各种框架和开源工具平滑了最粗糙的地方，但这是一个容易因为缺乏文档、工具问题以及缺乏片上调试而犯错的平台。

ARM MCU（Cortex-M）由众多制造商以令人眼花缭乱的配置生产。尽管编程这些 MCU 通常相当一致，但使用 OpenOCD 等工具时，每个 MCU 添加的外设通常在制造商之间差异很大，我们将在下一节中探讨这一点。

最后，ARM SoC 及其类似产品发现自己处于与 ARM MCU 类似的位置，但架构更为复杂，外设比其 MCU 兄弟少得多。因此，ARM SoC 添加了一个复杂的初始化程序，需要综合的引导加载程序，这也是为什么大多数人选择使用现成的 Linux 映像或类似产品来为 SoC 开发，而不是为它开发。

在这里，没有真正正确或错误答案。大多数都取决于项目需要什么，但了解你工作的硬件平台有一个良好的概述是至关重要的。

# 外设的复杂世界

对于 ARM MCU 来说，一个非常有意思的现实是，它们有不同的、通常是不兼容的外设，映射到内存空间中高度不同的区域。最糟糕的是定时器外设，它们具有各种复杂性，通常能够在 GPIO 引脚上生成任何所需的输出信号，包括 PWM，同时还可以作为基于中断的定时器来控制固件执行。

配置定时器外围设备和类似复杂的外设不是一件容易的事情。同样，使用内置 MAC 与外部 PHY（以太网物理接口）需要深入了解才能知道如何配置它们。在这里，阅读数据手册和应用笔记是必不可少的。

依赖于 ST 的 CubeMX 软件等工具自动生成的代码，对于 STM32 系列的 ARM MCU 来说，可能会导致你与无法正常工作的代码搏斗，因为你忘记在 CubeMX 编辑器中勾选一些框，因为你没有意识到这些选项是用来做什么的。

使用这样的自动生成工具，或者制造商提供的高级库，并没有什么问题，因为它们可以显著简化生活。然而，接受由此决策带来的风险是至关重要的，因为这需要信任提供的代码是正确的，或者花费时间验证它确实是正确的。

为了使不同 MCU 和 SoC 之间外围设备的用法不那么令人困惑，必须在某处添加一层抽象，以便代码的可移植性。关键是要确保这确实使生活变得更简单，而不仅仅是增加另一个可能破坏当前项目或未来项目的潜在问题。

# 了解你的工具

在进行嵌入式项目工作时，你必须知道目标平台上有哪些工具以及它们是如何工作的。这包括通过 JTAG 或其他接口编程 MCU，开始芯片调试会话，以及芯片调试的限制。在使用工具之前阅读手册或文档，并了解其他开发者使用这些工具的经验，这些都是值得的。

我们在之前的章节中讨论了这些工具中的许多，包括 MCU 和 SoC 平台，以及如何在将 MCU 设计闪存到目标硬件之前验证 MCU 设计。

# 选择异步方法

许多硬件设备和操作需要时间才能完成。因此，使用中断和定时器选择异步操作而不是阻塞操作是有意义的。

在进行裸机编程时，您可能会倾向于使用一个循环，其中包含中断例程和定时器，允许您响应和轮询事件。如果以完全异步的方式编程，主循环将有效地处理任务，同时中断处理程序更新需要处理的数据。

即使在 SoC 平台上，使用异步方法也是一个好主意，因为诸如网络操作和其他 I/O 操作可能比预期的要长。有处理未完成操作的方法是另一个出现的问题。

# 阅读数据表

尤其对于 MCU 来说，数据表为我们提供了大量有关硬件工作方式的有价值信息，例如如何配置内部系统时钟，各个外设如何工作，以及可用的寄存器和它们的含义。

即使您使用的是现成的板而不是定制硬件系统，了解底层硬件也是值得的，即使只是粗略地阅读了 MCU 或 SoC 的数据表。

# 保持中断处理程序简短

中断的本质决定了它会中断处理器的常规执行，转而切换到中断处理程序。我们在中断处理程序代码中花费的任何微秒，都是我们无法运行其他例程或处理其他中断的微秒。

为了防止由此产生的问题，中断处理程序（ISRs）应尽可能短，理想情况下是在结束 ISR 并恢复正常操作之前，以快速和安全的方式仅更新单个值。

# 8 位意味着 8 位

毫不奇怪，在 8 位 MCU 上使用 16 位和 32 位整数相当慢。这是因为系统必须对相同的整数值执行多次操作，因为它一次只能将其中的 8 位放入寄存器。

同样，在无浮点单元（FPU）的系统上使用浮点变量意味着这些操作非常适合将系统速度降低到极慢，因为仅支持整数的处理器难以跟上旨在模拟浮点操作的指令流。

# 不要重新发明轮子

如果存在一个质量好且适用于您的目标平台和项目许可的库或框架，请使用它而不是编写自己的实现。

维护一个常用代码片段和示例库作为参考，不仅对自己，也对其他团队成员来说都很有帮助。记住在哪里可以找到某个功能的示例，比记住该功能的精确实现细节要容易得多。

# 在优化之前要三思

优化代码的技巧是，您永远不应该在没有完全理解您提出的更改将产生什么影响的情况下尝试这样做。仅仅有一种感觉或模糊的想法认为这可能是个好主意是不够的。

虽然带有完整操作系统的基于 SoC 的平台通常会给你更多的灵活性，但对于 MCU 平台来说，了解添加单个关键字或使用不同的数据结构来存储一些信息意味着什么至关重要。

这里最糟糕的事情是假设你在 SBC 和桌面系统上使用的优化对 MCU 平台会有类似的效果。由于修改后的哈佛架构以及 AVR 等平台的各种怪癖，这些优化很可能会适得其反，或者如果你运气好，可能只是无效。

在这里，为(MCU)平台提供的应用笔记有助于理解如何优化硬件。这里的关键信息是在进行优化之前先进行研究，就像一个人在考虑项目设计之前不会开始编写代码一样。

# 需求是不可选的

在没有为项目制定明确需求的情况下编写嵌入式软件，就像在没有明确房屋应该有多少房间、窗户和门应该在哪里、管道和电线应该怎么走的情况下开始建造一栋新房子一样。

虽然你可以完全开始编写工作代码，并在很短的时间内制作出一个功能原型，但现实是，这些原型通常在没有充分考虑产品生命周期或未来几年需要不断修补固件以添加原始固件代码从未设计过的功能的情况下投入生产。

在完成产品必须满足的需求后，这些需求随后被转化为一个架构（应用程序的整体结构），然后转化为设计（将要实现的内容）。设计随后转化为实际的代码。

这种方法的优点是，你不仅需要回答很多关于*为什么*以某种特定方式执行某事的问题，它还会生成大量的文档，一旦项目完成，这些文档就可以实际使用。

此外，在嵌入式项目中，拥有完整的需求可以节省大量的金钱和时间，因为它允许一个人在不需要花费更多钱购买比所需更强大的芯片“以防万一”的情况下，为项目选择正确的 MCU 或 SoC。它还可以防止在项目中途出现的尴尬发现，其中某个“被遗忘”的功能突然需要改变硬件设计。

# 文档可以救命

程序员不喜欢编写文档，因此将他们编写的代码称为*自文档化代码*已经成为一种流行的笑话。现实是，如果没有对设计要求、架构概述、设计计划和 API 文档的明确文档，你将冒着项目的未来风险，以及依赖软件正常运行的同事和最终用户的风险。

在开始编写第一行代码之前遵循程序和完成所有无聊的文书工作可能看起来像是一种完全的打击。不幸的是，现实是，如果没有这种努力，这些知识将永远锁在项目开发者的脑海中，这会使得固件集成到嵌入式项目的其余部分变得复杂，并且使得未来的维护，尤其是如果转移到不同的团队，成为一个令人畏惧的前景。

简单的事实是，没有代码是自我文档化的，即使它是，也没有硬件工程师会浏览数千行代码来弄清楚当 MCU 发生特定输入条件时，在特定的 GPIO 引脚上发出了什么样的信号。

# 测试代码意味着试图破坏它

编写测试时常见的错误是编写你期望会工作的测试场景。这是忽略了重点。虽然一个特定的解析例程在接收到格式完美的数据时做了它应该做的事情，这在现实生活中并不很有帮助。

虽然你可以获得完美的数据，但你同样有可能在代码中得到完全损坏甚至垃圾数据。目标是确保无论你对输入数据做了什么可怕的事情，它都不会对系统的其余部分产生负面影响。

所有输入都应该经过验证和合理性检查。如果有什么地方看起来不对劲，应该拒绝它，而不是让它后来在代码的其他部分引起问题。

# 摘要

在这个附录中，我们回顾了在嵌入式软件设计过程中可能遇到的一些常见问题和陷阱。

现在读者应该知道项目中存在哪些阶段，以及记录项目每一步的原因。
