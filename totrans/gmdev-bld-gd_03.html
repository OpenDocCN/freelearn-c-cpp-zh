<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-42"><a id="_idTextAnchor042"/>3</h1>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>Adding and Creating Textures</h1>
<p>In a typical 3D workflow, one of the most common properties you would add to a material is texture. A <strong class="bold">texture</strong> is an image file that is responsible for the textured look of a model so surfaces <a id="_idIndexMarker092"/>don’t show just flat colors. Although objects you come across in real life have a perceived color, they also have a characteristic look that is defined by this property in 3D applications. For example, both a flower and a sandy surface may have a yellow color, but you know a flower’s petal would look smoother, whereas grains of sand would look gritty.</p>
<p>Most day-to-day objects have wear and tear. Look around and you’ll see that most surfaces will either have chipped paint, a slight deformation, or some scratches. Imagine the barrel you designed in the first two chapters has been in use for some time. It’d naturally have a few scratches on the metal rings. You can only go so far by applying colors to your materials and altering the roughness values. If you want to achieve a more realistic look, you’ve got to apply textures to your models.</p>
<p>Some 3D professionals only focus and gain expertise on certain domains. Texturing is one of these domains besides modeling, lighting, and animation. Typically, a texturing specialist will employ the help of classic image editing applications such as <em class="italic">Adobe Photoshop</em>, <em class="italic">GIMP</em>, and so on to create textures. Then, the artist will bring these textures into Blender so that they can be applied to surfaces. If you are not skilled in creating textures from scratch, you will learn in this chapter how you can still rely on existing textures out there created by other artists. </p>
<p>Preparing and using textures with the aforementioned workflow often sounds static because you need access to the source file of these textures. Luckily, there is a dynamic way to create your own textures within Blender, so you don’t have to go back and forth between Blender and other software. </p>
<p>This is not a “one is better than the other” situation because each method has its own place and merits. You’ll get to know new parts of Blender to facilitate both methods so you can make an informed decision about which texturing method to use. To that end, we are going to cover the following list of topics:</p>
<ul>
<li>Understanding UVs and texture coordinates</li>
<li>Using the UV Editor</li>
<li>Importing and applying a texture</li>
<li>Creating textures procedurally</li>
<li>Exporting your textures</li>
</ul>
<p>By the end of this chapter, you’ll have learned how to prepare your models for texturing, apply available textures, and create your own textures dynamically. The practice you’ll gain in this chapter will give you insight into choosing the right method of texturing for your projects.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Technical requirements</h1>
<p>This book’s GitHub repo (<a href="https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot">https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot</a>) will have a <code>Chapter 3</code> folder with <code>Start</code> and <code>Finish</code> folders in it for you to compare your work with as you go. These folders also contain other dependencies such as the texture files necessary to follow and complete the exercises.</p>
<p>Although you worked on a barrel in the previous chapters, we’ll only use the standard Blender objects, such as a cube and a plane, to keep things simple so you can focus on the texturing workflow. </p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Understanding UVs and texture coordinates</h1>
<p>While you are modeling, you are altering the coordinates of the vertices of a model. Thus, you are working with spatial coordinates. To apply a texture over your model, you need to work in a different <a id="_idIndexMarker093"/>kind of coordinate system that is called <strong class="bold">texture coordinates</strong> or <strong class="bold">UVs</strong>. Let’s see how <a id="_idIndexMarker094"/>these two terms relate to each other.</p>
<p>The spatial coordinate system is often described with the <strong class="bold">XYZ</strong> acronym since we often use X, Y, and Z axes to define the position of 3D objects. Similarly, <strong class="bold">UV</strong> is another acronym but it is used in the texturing workflow; the letters U and V were picked to describe the texture coordinate system. So, UV doesn’t really stand for ultraviolet. </p>
<p>The process that maps UV coordinates to XYZ coordinates is called <strong class="bold">UV unwrapping</strong>. Via this method, you tell <a id="_idIndexMarker095"/>Blender how a graphic file is mapped to XYZ coordinates. If unwrapping <a id="_idIndexMarker096"/>sounds counterintuitive, you could try to reverse the process in your mind. What kind of texture would you need so that if you wrapped it around your 3D model, it would fit perfectly? Let’s analyze the following figure where a graphic file that is painted with a checkerboard texture is applied to a standard cube:</p>
<div><div><img alt="Figure 3.1 – A 2D checkerboard texture wrapping a 3D object " height="717" src="img/Figure_3.01_B17473.jpg" width="1382"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – A 2D checkerboard texture wrapping a 3D object</p>
<p>In <em class="italic">Figure 3.1</em>, you see a cube with a checkerboard texture on the left. In the middle part, you see the cube as if gift wrap is being peeled off. Finally, the cube is fully unwrapped on the right side; its texture is laid flat. The texture file is actually all of the checkerboard parts, and it exists as a 2D graphic file. </p>
<p>The reason we are using words such as unwrapping and 2D graphic files is because we are simulating a real-life 3D object on a flat screen. In reality, that cube would occupy a space, have a volume, and it would be full of the material it was made of. For example, a cube that might be a child’s toy made of wood. Or, it might be a six-sided die, most likely made of acrylic. If you cut into it, you’d see the material. </p>
<p>To change the nature of the problem from a 3D volume problem to a 2D graphics problem, you need a <a id="_idIndexMarker097"/>new tool. You’ve been working with Blender’s default interface, which is conveniently set up to edit XYZ coordinates. For editing UVs, you need the <strong class="bold">UV Editor</strong>, which you will discover in the following section. </p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Using the UV Editor</h1>
<p>Blender comes with <a id="_idIndexMarker098"/>preset workspaces so you can focus on a particular workflow. So far, you’ve been in the <strong class="bold">Layout</strong> workspace. You can see it as the active tab just under the header of the application, next to the <strong class="bold">Help</strong> menu. You should create a new file and switch to the <strong class="bold">UV Editing</strong> workspace by clicking the appropriate tab. <em class="italic">Figure 3.2</em> is what you’ll see when you are in the <strong class="bold">UV Editing</strong> workspace.</p>
<div><div><img alt="Figure 3.2 – UV Editing is one of many default workspaces in Blender " height="865" src="img/Figure_3.02_B17473.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – UV Editing is one of many default workspaces in Blender</p>
<p>In the <strong class="bold">UV Editing</strong> workspace, the application will mainly be divided into two sections: the left side, which is called <strong class="bold">UV Editor</strong>, shows a bunch of squares laid out on a flat surface, and the right side shows the default cube. The black dots you see in <strong class="bold">UV Editor</strong> are actually the vertices of the cube in <strong class="bold">3D Viewport</strong>. You might notice that if you counted the dots in <strong class="bold">UV Editor</strong>, they don’t add up to the number of vertices the cube has. There are more points in <strong class="bold">UV Editor</strong> because some of those points will eventually merge once those squares in <strong class="bold">UV Editor</strong> are folded around the edges and wrapped around your 3D object.</p>
<p>At this point, all of the vertices of the cube should be selected for you by Blender. However, if you happen <a id="_idIndexMarker099"/>to select a vertex of the cube, you’ll see that the squares in <strong class="bold">UV Editor</strong> will disappear. That’s because we haven’t turned on the <strong class="bold">sync</strong> mode yet. At the top-left corner of <strong class="bold">UV Editor</strong>, you’ll see a button with an icon that looks like two diagonal arrows going in opposite directions. If you have that button pressed, you’ll notice that selecting the vertices in either view will synchronize. </p>
<p>When you add a new cube, Blender unwraps that cube by default. The general layout of the vertices in <strong class="bold">UV Editor</strong> resembles a T shape, like what you saw in <em class="italic">Figure 3.1</em>. Similar to <strong class="bold">3D Viewport</strong>, the vertices in <strong class="bold">UV Editor</strong> will form edges and faces, but it’s all 2D in <strong class="bold">UV Editor</strong>. As mentioned earlier, we have converted the 3D-ness of the model to a 2D representation so we can work with graphics files.</p>
<p><strong class="bold">UV Editor</strong> is where you can see how the points in the editor map or correlate to a texture file. To do that, we need to bring a texture file as follows:</p>
<ol>
<li>Open the <code>Chapter 3</code> folder.</li>
<li>Open the <code>Start</code> folder.</li>
<li>Drag and drop <code>pips.png</code> into the <strong class="bold">UV Editor</strong> area.</li>
</ol>
<p>If you open that PNG file in your computer’s default image viewing application, you’ll notice that it has transparent parts. Its dimensions of 1024x1024 are not fully painted. It just happens that the file’s non-transparent areas come right under the faces in <strong class="bold">UV Editor</strong>, therefore the faces in <strong class="bold">3D Viewport</strong>. </p>
<p class="callout-heading">Powers of two</p>
<p class="callout">Sooner or later, you’ll notice that most texture files come in certain standard dimensions such as 512, 1024, 2048, and so on. Although these files don’t have to be square, which means you could actually have 256x512 as dimensions, it’d still pay off to keep either dimension in powers of two. This is due to algorithms that are employed by GPUs so that they run more efficiently.</p>
<p>So far, we have taken advantage of Blender’s default UV layout for a cube and have seen how UV faces can <a id="_idIndexMarker100"/>overlap with the texture file we have been previewing in <strong class="bold">UV Editor</strong>. However, if you enable <strong class="bold">Material Preview</strong> in <strong class="bold">3D Viewport</strong>, you won’t see the die texture applied to the cube. That’s because we haven’t yet told Blender to use the die texture in the material assigned to the cube. Let’s do that in the following section. </p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Importing and applying a texture</h1>
<p>When you've dragged <a id="_idIndexMarker101"/>the texture file into <strong class="bold">UV Editor</strong>, you have effectively <a id="_idIndexMarker102"/>imported it, but, in reality, the material for the cube doesn’t know how to use that texture yet. That being said, the material has all of the information it needs to map 3D vertices to 2D texture coordinates thanks to <strong class="bold">UV Editor</strong>. It just needs to be told which texture to apply to the cube. </p>
<p>To accomplish this, we’ll switch to a new workspace so we can connect textures with materials. Also, we’ll import another texture using a different method and assign it to the cube’s material to showcase how you can use the same UV information with different texture files.</p>
<p>Just like when you switched to the <strong class="bold">UV Editing</strong> workspace, it’s now time to switch to a different workspace for convenience. The sixth workspace, labeled as <strong class="bold">Shading</strong>, is the one you are looking for. We’ll do our work in the lower half of the new workspace, which looks like <a id="_idIndexMarker103"/>a grid; it’s called the <strong class="bold">Shader Editor</strong>. The upper part is still the same old <strong class="bold">3D Viewport</strong>, but <strong class="bold">Material Preview</strong> is automatically turned on so you can see your changes reflect immediately. So, the <strong class="bold">Shading</strong> workspace should look similar to what you see in <em class="italic">Figure 3.3</em>.</p>
<div><div><img alt="Figure 3.3 – Shading is one of many convenient workspaces set up for you " height="809" src="img/Figure_3.03_B17473.jpg" width="1375"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Shading is one of many convenient workspaces set up for you</p>
<p>As you discovered in <a href="B17473_02.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Materials and Shaders</em>, Blender files come with a default <a id="_idIndexMarker104"/>material. We’ll modify that default material to understand the <a id="_idIndexMarker105"/>texture workflow. The <strong class="bold">Shader Editor</strong> area is already populated with two entities that make up the material as follows:</p>
<ul>
<li><strong class="bold">Principled BSDF</strong> (<strong class="bold">Principled</strong> in short form)</li>
<li><strong class="bold">Material Output</strong></li>
</ul>
<p>These are called nodes. The node on the left, <strong class="bold">Principled</strong>, holds the properties you already saw in the previous chapter. A lot of these properties have little circles on the left side. These circles, which are called sockets, can connect to other nodes’ sockets. We don’t have enough nodes to create meaningful connections yet but we will soon. </p>
<p>Speaking of connectivity, <strong class="bold">Principled</strong> has an output that is connected to the <strong class="bold">Material Output</strong> node. If you hold your mouse down on the <strong class="bold">Surface</strong> input of <strong class="bold">Material Output</strong> and drag the connection away, you’ll eventually break the connection between those two nodes. Then, the cube will look black since there is no surface information. Try to reconnect those nodes by dragging the <strong class="bold">BSDF</strong> output to the <strong class="bold">Surface</strong> input. The default gray color will be reestablished.</p>
<p class="callout-heading">Nodes vs code</p>
<p class="callout">In the previous <a id="_idIndexMarker106"/>chapter, you were told that shaders are lines of code that <a id="_idIndexMarker107"/>instruct the GPU what to display. When you use nodes in <strong class="bold">Shader Editor</strong>, you are actually writing code, but you are coding visually. As the order of lines is important in conventional programming, the nodes and the connections coming in and out of the nodes are also important. However, visual programming is easier to conceptualize.</p>
<p>When we were modeling the barrel in <a href="B17473_01.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Low-Poly Models</em>, we needed to add <a id="_idIndexMarker108"/>3D objects to the scene. We did that by pressing <em class="italic">Shift + A</em>. We’ll do <a id="_idIndexMarker109"/>something similar. In this case, we’ll add new nodes to <strong class="bold">Shader Editor</strong>. Blender is context-sensitive, which means the same shortcuts will yield similar results if your mouse is over different workspaces, areas, and interfaces. If you press <em class="italic">Shift + A</em> over <strong class="bold">Shader Editor</strong>, you’ll see a list come up and show entities that are relevant to <strong class="bold">Shader Editor</strong>.</p>
<p>When this pop-up menu opens, it’s positioned exactly so that the mouse cursor is right over the <strong class="bold">Search</strong> button. To add a texture node, perform the following steps:</p>
<ol>
<li value="1">Click <strong class="bold">Search</strong> in the <strong class="bold">Add</strong> menu.</li>
<li>Type <code>Image</code> with your keyboard.</li>
<li>Select <strong class="bold">Image Texture</strong> in the filtered results.</li>
<li>Click anywhere near the other nodes.</li>
</ol>
<p>This will introduce an <strong class="bold">Image Texture</strong> node to <strong class="bold">Shader Editor</strong>, just as you see in the following figure:</p>
<div><div><img alt="Figure 3.4 – An Image Texture node in Shader Editor " height="771" src="img/Figure_3.04_B17473.jpg" width="1376"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – An Image Texture node in Shader Editor</p>
<p>You have already imported the <code>pips.png</code> file when you were working with <strong class="bold">UV Editor</strong>, so there is no <a id="_idIndexMarker110"/>need to import that file again. We’ll just recall it. As usual, the <a id="_idIndexMarker111"/>button to the left of the <strong class="bold">New</strong> button in the <strong class="bold">Image Texture</strong> node will bring up a list; select <strong class="bold">pips.png</strong> from that list. Then, attach the <strong class="bold">Color</strong> output of <strong class="bold">Image Texture</strong> to the <strong class="bold">Base Color</strong> input of <strong class="bold">Principled</strong>. This will apply the texture to the cube’s faces. Voilà, the default cube now looks like a six-sided die as seen in <em class="italic">Figure 3.5</em>:</p>
<div><div><img alt="Figure 3.5 – The texture file is applied to the model via its material " height="812" src="img/Figure_3.05_B17473.jpg" width="1376"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The texture file is applied to the model via its material</p>
<p>A six-sided die has pips, usually marked with a variable number of circles on each side. What if you wanted to have a different looking six-sided die, with the numbers represented by Roman numerals? To import and apply a new texture, perform the following steps:</p>
<ol>
<li value="1">Create a new <strong class="bold">Image Texture</strong> node with the help of <em class="italic">Shift+A</em>.</li>
<li>Click the <strong class="bold">Open</strong> button.</li>
<li>Select <code>roman.png</code> in this chapter’s <code>Start</code> folder.</li>
<li>Connect this <strong class="bold">Image Texture</strong> node's <strong class="bold">Color</strong> to the <strong class="bold">Principled</strong> node’s <strong class="bold">Base Color</strong>.</li>
</ol>
<p>Since the texture <a id="_idIndexMarker112"/>coordinates are already mapped in <strong class="bold">UV Editor</strong>, you can easily <a id="_idIndexMarker113"/>swap textures that have similar shapes with different designs.</p>
<p>When you work with more complex models, you’ve got more work to do in adjusting the UVs; as long as the <a id="_idIndexMarker114"/>UV coordinates are aligned with the right parts of the texture, you’re <a id="_idIndexMarker115"/>good. However, imagine a different scenario. How would you go about modeling surfaces that look like they are showing a repeating pattern with slight deviations? In the following section, we’ll look into a different texture workflow.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Creating textures procedurally</h1>
<p>The word “<strong class="bold">procedural</strong>” has been used a lot in recent years, especially in the video game industry, to <a id="_idIndexMarker116"/>describe different things. Although one might say everything we have done so far is following a certain procedure, the word means something else in our context. When we imported the texture file in the preceding section, it was already designed for us. In other terms, it was a static file. The word “procedural,” on the other hand, is a fancy word that means dynamic. </p>
<p>In a dynamic or procedural texturing workflow, the goal is to expose certain parameters of the texture so that the texture can be changed on the fly, instead of going back to a graphic editing application. Since it’s all dynamic, you won’t have to import graphic files, and you’ll be able to change aspects of the final texture. For example, if the six-sided die was using a procedural texture, it’d be like changing the color and/or the size of the pips.</p>
<p>Procedural textures have another benefit besides their dynamism. Static texture files would need you to <a id="_idIndexMarker117"/>do the prior UV work so that the vertices would be aligned with the parts of the texture. In a procedural workflow, the pattern in the texture might be seamless, so you don’t need to worry about the UVs. Seamless, in our context, means that the pattern repeats in a perfect way to wrap around the model.</p>
<p>We’ll create a procedural lava texture as you see in <em class="italic">Figure 3.6</em> in Blender so you can change its parameters to have a different looking texture.</p>
<div><div><img alt="Figure 3.6 – Hot lava flowing through solidified crust " height="843" src="img/Figure_3.06_B17473.jpg" width="1377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Hot lava flowing through solidified crust</p>
<p>In a new Blender scene, after <a id="_idIndexMarker118"/>deleting the default cube, perform the following steps:</p>
<ol>
<li value="1">Add a <strong class="bold">Plane</strong>.</li>
<li>Switch to the <strong class="bold">Shading</strong> workspace.</li>
<li>Bring up the default <strong class="bold">Material</strong> or create a new one.</li>
<li>Rename the material if you desire.</li>
</ol>
<p>Nothing new or exciting so far, but we’ll utilize the following five new nodes very soon:</p>
<ul>
<li><strong class="bold">Noise Texture</strong>: Perlin <a id="_idIndexMarker119"/>noise is a mix of black and white values that are mixed together in a gradual way, so the result looks like a soup of grayscale values. Blender’s noise texture is similar to Perlin, but the <a id="_idIndexMarker120"/>values are not grayscale; they come with random colors.</li>
<li><strong class="bold">Bump</strong>: It is used to <a id="_idIndexMarker121"/>simulate height fluctuations so surfaces could look bumpy.</li>
<li><strong class="bold">Color Ramp</strong>: Another <a id="_idIndexMarker122"/>name for this node would have been color mapper, but since it’s using a gradient, the word “ramp” implies that the transition is smooth.</li>
<li><strong class="bold">Emission</strong>: Under <a id="_idIndexMarker123"/>normal light, hot objects have a glowing effect. This shader would help you simulate a hot piece of steel coming out of an oven or a bright lightbulb. </li>
<li><strong class="bold">Mix Shader</strong>: It’s a shader <a id="_idIndexMarker124"/>that mixes two shaders to create a combined shader.</li>
</ul>
<p>Before we move on to how to mix and match the preceding list of nodes, which kind of look like <a id="_idIndexMarker125"/>a recipe’s ingredients, here is a little bit of explanation as to why they were chosen. When you want to create your own procedural textures, a similar process might help you pick the nodes that are helpful instead of making wild guesses about which nodes to select. Also, after the explanation, try to imagine which one will connect to which. So, here we go.</p>
<p><strong class="bold">Noise Texture</strong> is quite literally a texture that comes with some noise; the color variation in this noise texture is used in the <strong class="bold">Bump</strong> node to simulate different heights. So, <strong class="bold">Noise Texture</strong> is like the data and the <strong class="bold">Bump</strong> node is its visual representation in a sense. Then comes <strong class="bold">Color Ramp</strong>, shown as <strong class="bold">ColorRamp</strong>, which assigns color information to different height values. If you've ever seen a miniature landscape, it’s like painting hilltops white because of snow and the lower areas with different shades of green depending on the elevation.</p>
<p>Hence, the first three nodes are taking care of most of the work for simulating elevation. Let’s assume this lava texture is portraying a recent formation, so we are not after just displaying cooled-down lava. We would like to see steaming hot, glowing lava in between the blackened and dried-out lava. So, we’ll need an <strong class="bold">Emission</strong> shader for that. Finally, since the elevation is its own thing and we are adding the emission part, we’ll need <strong class="bold">Mix Shader</strong> to combine both.</p>
<p>While working with nodes, you can drag and drop the nodes to arrange a cleaner layout <a id="_idIndexMarker126"/>for yourself to make sense of what’s going on. Without further ado, let’s continue.</p>
<ol>
<li value="5">Add the aforementioned five nodes.</li>
<li>Connect as follows:<ul><li><strong class="bold">Noise Texture</strong>’s <strong class="bold">Color</strong> to <strong class="bold">Bump</strong>’s <strong class="bold">Height</strong></li>
<li><strong class="bold">Noise Texture</strong>’s <strong class="bold">Fac</strong> to <strong class="bold">ColorRamp</strong>’s <strong class="bold">Fac</strong></li>
<li><strong class="bold">Bump</strong>’s <strong class="bold">Normal</strong> to <strong class="bold">Principled BSDF</strong>’s <strong class="bold">Normal</strong></li>
<li><strong class="bold">ColorRamp</strong>’s <strong class="bold">Color</strong> to <strong class="bold">Mix Shader</strong>’s <strong class="bold">Fac</strong></li>
<li><strong class="bold">Principled BSDF</strong>’s <strong class="bold">BSDF</strong> to <strong class="bold">Mix Shader</strong>’s first input <strong class="bold">Shader</strong></li>
<li><strong class="bold">Emission Shader</strong>’s <strong class="bold">Emission</strong> to <strong class="bold">Mix Shader</strong>’s second input <strong class="bold">Shader</strong></li>
<li><strong class="bold">Mix Shader</strong>’s <strong class="bold">Shader</strong> output to <strong class="bold">Material Output</strong>’s <strong class="bold">Surface</strong></li>
</ul></li>
</ol>
<p>There is no left or right direction when it comes to connecting nodes. Some people consider a group of nodes as a unit and arrange them close to each other. So, sometimes, the last output node from that group connects almost vertically to another group of nodes. That being said, having a general flow of left to right would fit the preceding instructions. Whichever way you arrange your nodes, the layout might resemble what you see in <em class="italic">Figure 3.7</em>.</p>
<div><div><img alt="Figure 3.7 – Lava texture’s node arrangement " height="826" src="img/Figure_3.07_B17473.jpg" width="1376"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Lava texture’s node arrangement</p>
<p>Let’s look at the <a id="_idIndexMarker127"/>values these nodes will have by following the original order of the node list as much as possible. </p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Noise Texture</h2>
<p>For <strong class="bold">Noise Texture</strong>, the <a id="_idIndexMarker128"/>following values were used:</p>
<ul>
<li><strong class="bold">Type</strong> defines the <a id="_idIndexMarker129"/>dimensions that are used in the creation of the noise, which involves complex operations. It’s used in more advanced cases, so we’ll leave the default <strong class="bold">3D</strong> value.</li>
<li>The <strong class="bold">Scale</strong> property works more like a zoom factor. Too low, and you are closer to the noisy surface. Too high, and you are seeing a larger portion of the noisy landscape as if you are climbing up in an airplane. In this case, we set <strong class="bold">Scale</strong> to <strong class="bold">3.0</strong>.</li>
<li>The <strong class="bold">Detail</strong> property is self-explanatory. Although having a lower value will certainly result in a muddy look, having a higher number beyond a certain value won’t add much to the quality. It will simply increase the calculation time. A value of <strong class="bold">8.0</strong> is chosen in our case.</li>
<li><strong class="bold">Roughness</strong> is not the same concept you saw in <a href="B17473_02.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Materials and Shaders</em>. That one affected the reflective properties of a surface. This one is about how rough the edges are, in a sense. In other words, how roughly the noise values are blending into each other, and a value of <strong class="bold">0.5</strong> is enough.</li>
<li>The <strong class="bold">Distortion</strong> property <a id="_idIndexMarker130"/>creates swirls and wavy patterns. Perhaps a <a id="_idIndexMarker131"/>little might be necessary for a flowing lava look. You could experiment with it, but beyond a certain value when there is too much distortion, things will look too fragmented. So, <strong class="bold">0.2</strong> is good enough.</li>
</ul>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Bump</h2>
<p>This node will use <a id="_idIndexMarker132"/>the data provided by <strong class="bold">Noise Texture</strong> so it can represent different <a id="_idIndexMarker133"/>color values as different height values. This is why the <strong class="bold">Height</strong> input was connected to the <strong class="bold">Color</strong> output since there can’t be just one height value for the whole surface, so we had to feed it a set of colors. </p>
<p>Leaving the <strong class="bold">Invert</strong> setting unchecked, the following are the other values used:</p>
<ul>
<li>The <strong class="bold">Strength</strong> value determines the effect of the mapping between color values and the final bumps. It works like a percentage since the values can be anywhere between <em class="italic">0.0</em> and <em class="italic">1.0</em>. We’ll leave it at <strong class="bold">1.0</strong>.</li>
<li>The <strong class="bold">Distance</strong> property is a multiplier of some sort. It works in conjunction with the <strong class="bold">Strength</strong> property. Setting either one of them to <em class="italic">0</em> will result in a totally flat surface. Perhaps the best way to describe this property is that it keeps the details set in <strong class="bold">Noise Texture</strong>. Any value closer to <em class="italic">1.0</em> will show a washed-out surface, whereas higher values will fill in more details. Thus, a value of <strong class="bold">3.0</strong> will yield a detailed enough result.</li>
</ul>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Emission</h2>
<p>This is a very simple <a id="_idIndexMarker134"/>node and it’s responsible for making surfaces <a id="_idIndexMarker135"/>look glowing. We’ll discover lights in <a href="B17473_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Adjusting Cameras and Lights</em>, but if you want your objects to act like they are emitting or radiating light, then you can use this node. Examples might be a piece of hot iron or fluorescent lightbulbs; in our case, lava. </p>
<p>Since this is such a simple node, we have only the following two properties:</p>
<ul>
<li>The self-explanatory <strong class="bold">Color</strong> property is for picking which color the surface will emit. For hot lava, you can switch to the <strong class="bold">Hex</strong> values on the interface and choose <strong class="bold">FF8400</strong>. </li>
<li>The <strong class="bold">Strength</strong> value, which is <strong class="bold">100.0</strong> in our case, defines the intensity of the emission. This is a unit measured in Watts so you can be scientific about it, but picking arbitrary values for visual fidelity works most of the time too. </li>
</ul>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>ColorRamp</h2>
<p>The <strong class="bold">ColorRamp</strong> node is used <a id="_idIndexMarker136"/>for mapping input values to colors with the <a id="_idIndexMarker137"/>help of a gradient that works like a threshold. The description is deceptively simple, but there is a lot going on under the hood. So, let’s unpack it.</p>
<p>Most of the time, you’ll be connecting both the input and output sockets of a node to other nodes. However, there are times when it is totally acceptable to use only one type of socket. For example, in the <strong class="bold">Emission</strong> shader, you didn’t have to use the input sockets to define the <strong class="bold">Color</strong> and <strong class="bold">Strength</strong> values. Instead, you handpicked their values. So, the node acts like a source of information.</p>
<p>Then, there are some nodes where it makes much more sense to connect the input socket to another node’s output socket. <strong class="bold">ColorRamp</strong> is one of those nodes, and it works like a modifier by factoring in incoming values. <strong class="bold">Noise Texture</strong>’s data will be a factor (Fac for short) in creating a lava surface, so we connect the two <strong class="bold">Fac</strong> sockets.</p>
<p>Once the data is factored in, we need a system to process it. This is done via the gradient in the <strong class="bold">ColorRamp</strong> node. The concept of a gradient might sound weird at first. If you were to connect the <strong class="bold">Color</strong> of <strong class="bold">Noise Texture</strong> directly to <strong class="bold">Material Output</strong>, you’d see that there are smaller and larger zones of colors. If you do that, remember to undo it so that the nodes are connected correctly once again. We need a way to turn these flat but colored zones to elevation.</p>
<p>The gradient is going to help us define which zones are higher or lower so we can assign the appropriate color to different elevations later. In essence, the gradient is a tool to define and blend in those zones with the help of color stops. By default, there are two color stops, but you <a id="_idIndexMarker138"/>can use the plus and minus buttons above the gradient to add <a id="_idIndexMarker139"/>and remove more color stops. These stops have a square shape with a little triangle right above them. It is possible to drag these stops, which will change the zone transitions we mentioned earlier. </p>
<p>When you have a lot of stops, it’s sometimes difficult to click and drag them, so use <strong class="bold">active color stop</strong> to step between them. When you add a fresh <strong class="bold">ColorRamp</strong> node, the active stop is marked as <strong class="bold">0</strong> and it is to the left of the label that says <strong class="bold">Pos</strong>, which indicates the position of the active stop. Both the active stop and the position fields show necessary UI elements for you to change the values once you hover; also, you can click and enter a value. So, by using the active color stop and <strong class="bold">Pos</strong>, you can mark exactly where the color stops are going to be if you don’t want to drag them around. </p>
<p>Last but not least, there is a color picker right above the <strong class="bold">Fac</strong> socket. You can use that to set the color for the active stop. </p>
<p>Since this is not a straightforward node, we could benefit from some visual aid. <em class="italic">Figure 3.8</em> is a zoomed-in look at the <strong class="bold">ColorRamp</strong> node. </p>
<div><div><img alt="Figure 3.8 – A close-up look at the ColorRamp node " height="814" src="img/Figure_3.8_B17473.jpg" width="1454"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – A close-up look at the ColorRamp node</p>
<p>The preceding figure should help you see what we have talked about so far. Also, just like you are able to zoom in and out with your mouse’s scroll functionality in the 3D view, you can <a id="_idIndexMarker140"/>do so in <strong class="bold">Shader Editor</strong>. It will help you see some of the <a id="_idIndexMarker141"/>properties’ names and values more clearly.</p>
<p>Now, it’s time to use all of this information and mark our transitions; you’ll be interacting with all of the elements just presented. To that end, perform the following steps: </p>
<ol>
<li value="1">Use the plus/minus buttons to have four color stops.</li>
<li>Set <code>0</code>, then do as follows:<ol><li>Set <code>0.45</code>.</li>
<li>Set color in the <code>000000</code>. </li>
</ol></li>
<li>Set <code>1</code>, then do as follows:<ol><li>Set <code>0.53</code>.</li>
<li>Set color in the <code>FFFFFF</code>. </li>
</ol></li>
<li>Set <code>2</code>, then do as follows:<ol><li>Set <code>0.94</code>.</li>
<li>Set color in the <code>FFFFFF</code>.</li>
</ol></li>
<li>Set <code>3</code>, then do as follows:<ol><li>Set <code>1.00</code>.</li>
<li>Set color in the <code>636363</code>. </li>
</ol></li>
</ol>
<p>Notice that we are only picking grayscale values. In a real landscape, higher areas will be cooler lava, and the lower areas will be hot pools of lava. So, to represent that idea, we are picking dark and white colors. Usually, the whiter something is, the hotter it is. The proximity of the stops to each other determines how smooth or sharp the transitions are. </p>
<p>Although we have <a id="_idIndexMarker142"/>been working with the <strong class="bold">ColorRamp</strong> node, the colors for our <a id="_idIndexMarker143"/>lava texture will be defined in the <strong class="bold">Principled BSDF</strong> and <strong class="bold">Emission</strong> shaders and will be combined in <strong class="bold">Mix Shader</strong>. For the time being, we have utilized the data from <strong class="bold">Noise Texture</strong> and transformed that data with the help of a gradient and its carefully chosen values. We’ll revisit the factor concept again in the <em class="italic">Mix Shader</em> section, but before that, let’s visit our trusty friend <strong class="bold">Principled BSDF</strong>. </p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Principled BSDF</h2>
<p>We actually saw this node in <a href="B17473_02.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Materials and Shaders</em>, but it was displayed as part <a id="_idIndexMarker144"/>of the <strong class="bold">Material Properties</strong> interface. When you <a id="_idIndexMarker145"/>create a new material, it uses this shader by default. It combines a great deal of other shaders in its body. For example, it has an emission socket, but since we can’t do both the hot and cool part of the lava formation in one go, we are using a separate <strong class="bold">Emission</strong> shader. </p>
<p>We’ll leave most options unchanged, but the following are the non-default values chosen for this exercise:</p>
<ul>
<li><code>4A4A4A</code> as the value in the <strong class="bold">Hex</strong> section of the color interface.</li>
<li>The <code>0.2</code>.</li>
<li><code>0.2</code> in this exercise.</li>
</ul>
<p>You can refer to <em class="italic">Figure 2.5</em> in <a href="B17473_02.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Materials and Shaders</em>, and read the explanation <a id="_idIndexMarker146"/>in the <em class="italic">Discovering Shaders</em> section for a refresher <a id="_idIndexMarker147"/>in understanding how multiple properties work together and affect the final look.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Mix Shader</h2>
<p>It blends one shader <a id="_idIndexMarker148"/>into another determined by the value in <strong class="bold">Factor</strong>. For <a id="_idIndexMarker149"/>the <strong class="bold">Factor</strong> socket’s value, if you pick <strong class="bold">0.0</strong>, the first shader will be used entirely. If you choose <strong class="bold">1.0</strong>, it means that the second shader will be utilized. </p>
<p>The range of decimal values is between 0 and 1 but it’s hard to know what to choose since we can’t just arbitrarily determine how much of which shader to use. This is why we connected the <strong class="bold">Color</strong> output from <strong class="bold">ColorRamp</strong> as a factor so that the fluctuation in <strong class="bold">Noise Texture</strong> would trickle down and affect this node. The effect is cascading. In other words, every single pixel that’s going to be painted either dark (for dried lava) or orange (for hot lava) should be decided based on where <strong class="bold">ColorRamp</strong> thinks it belongs in <strong class="bold">Noise Texture</strong>. Thus, the color stops act like thresholds and this is all factored in, in <strong class="bold">Mix Shader</strong>.</p>
<p>Once all of the nodes have been set and attached, feel free to play with the values in all of them, especially <strong class="bold">ColorRamp</strong>. You’ll notice that the hot lava parts are sort of cooler at the shore, and denser and brighter in the middle. Try to approach the color stops close to each other and see how these hot zones in the lava pools change.</p>
<p>Creating this kind of texture using conventional image editing applications such as <em class="italic">Adobe Photoshop</em> might have been possible, but those applications are layer-based and it’s not always easy to keep things non-destructive. The power you have with a node-based approach <a id="_idIndexMarker150"/>is quick iterations. One thing for sure is you don’t have to <a id="_idIndexMarker151"/>reimport your texture to see the changes. It’s all happening live in front of your eyes.</p>
<p>However, at the end of the day, since you are developing a game, you’ll have to export your texture so the game engine of your choice can use it. In the following and final section, we’ll see how we can export our lava texture to the file system.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>Exporting your textures</h1>
<p>In later <a id="_idIndexMarker152"/>chapters, when we get close to working with Godot Engine, we’ll look into asset and project management in more detail. However, after all the hard work we have done with the lava material, it’s now time to learn how to export the texture.</p>
<p>We’ll do a few interesting but necessary things in this section to export our texture. First, we’ll change Blender’s rendering engine. Then, we’ll add an <strong class="bold">Image Texture</strong> node in the middle of our material without connecting it to anything. Weird, right? Blender works mysteriously sometimes.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Changing the rendering engine</h2>
<p>We have been using the default <strong class="bold">Eevee</strong> rendering engine so far. <strong class="bold">Eevee</strong> is a real-time rendering engine <a id="_idIndexMarker153"/>that gives you really fast results. Most game <a id="_idIndexMarker154"/>engines have their own internal real-time rendering engines that are responsible for calculating lights and shadows. So, <strong class="bold">Eevee</strong> is a good way to simulate in Blender what you’ll most <a id="_idIndexMarker155"/>likely experience when you export your assets to a game engine. However, the speed and convenience come with a few penalties.</p>
<p>Blender has another engine that is called <strong class="bold">Cycles</strong>. <strong class="bold">Cycles</strong> is a very accurate but slow rendering engine <a id="_idIndexMarker156"/>compared to <strong class="bold">Eevee</strong>. <strong class="bold">Cycles</strong>’ accuracy is due to the fact that it tackles advanced lighting calculations, which leads to quality results such as showing reflective and transparent surfaces much better, displaying more accurate shadows, and even creating volumetric effects such as haze and fog. The following is a link to an article <a id="_idIndexMarker157"/>that demonstrates both engines’ capabilities and differences with use cases: <a href="https://cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-of-real-time-rendering">https://cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-of-real-time-rendering</a>.</p>
<p>In this book, we are not covering advanced enough topics that would require us to make a hard decision between <strong class="bold">Eevee</strong> and <strong class="bold">Cycles</strong>. So, <strong class="bold">Eevee</strong> has been fine for our purposes. However, when <a id="_idIndexMarker158"/>you work with procedural textures, there is no way, at <a id="_idIndexMarker159"/>least with the version of Blender we’re using, for <strong class="bold">Eevee</strong> to export the lava texture. We’ll have to switch to the <strong class="bold">Cycles</strong> engine. Luckily, it’s done just with the click of a button.</p>
<p>In the <strong class="bold">Properties</strong> panel on the right, the second tab from the top, which looks like the preview display of <a id="_idIndexMarker160"/>a DSLR camera, is going to open <strong class="bold">Render Properties</strong>. The <a id="_idIndexMarker161"/>drop-down list at the top will show <strong class="bold">Eevee</strong>; let’s change that to <strong class="bold">Cycles</strong>. Also, if you have a decent graphics card, you might want to change the third dropdown, <strong class="bold">Device</strong>, value to <strong class="bold">GPU compute</strong> so that your graphic card can do the heavy lifting instead of your good old CPU.</p>
<p>Looking down in that long list of properties, you’ll see a panel with the header <strong class="bold">Bake</strong>. If you expand the header, you’ll see a <strong class="bold">Bake</strong> button. We’ll click that button soon, but we need to prepare what we’ll bake first.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Baking a texture File</h2>
<p>When we worked with the cube and die textures, we used an <strong class="bold">Image Texture</strong> node to bind an existing image <a id="_idIndexMarker162"/>from the file system. Our situation is different when the texture is procedural since this has been happening live in the memory. We need to figure out a way to bake this information into a file. Since there is no such file, we need to pretend that we have one, as follows:</p>
<ol>
<li value="1">Add an <strong class="bold">Image Texture</strong> node.</li>
<li>Click the <strong class="bold">New</strong> button.</li>
<li>Type <code>lava</code> in the name section.</li>
<li>Click the <strong class="bold">OK</strong> button.</li>
</ol>
<p>We won’t be connecting <code>lava</code> will be packaged with the material. Blender will make an educated guess and will bake the procedural texture parts into this image.</p>
<p>Now is the time to hit that <strong class="bold">Bake</strong> button in <strong class="bold">Render Properties</strong>. A progress bar at the bottom will indicate that Blender is doing its thing. Once the process is finished, the bottom-left corner of the <strong class="bold">Shading</strong> workspace will fill with the lava texture. That little section that displays the baked texture is called <strong class="bold">Image Editor</strong>. </p>
<p>If you look at the baked image, you’ll notice that some details are lost. The pool of hot lava has warmer and cooler spots in <code>1.0</code>. </p>
<p>In the <code>lava.png</code> in your file system. This file can now be imported into a new Blender file and used in an <code>pips.png</code> to a cube. </p>
<p>Mission accomplished. If you chose the same values as those written in this chapter, you should have the procedural lava texture you see in <em class="italic">Figure 3.6</em>. Additionally, you have created a static version of it. Let’s summarize what else has been accomplished in this chapter.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Summary</h1>
<p>This chapter started off with a brief discussion about what textures are and why they might be needed. To recap, if you are fine with models that have just the color info on their surface, you are done as soon as the modeling and material application process is finished. If you think you need to show distinctive qualities on your models’ surfaces, you need to utilize textures.</p>
<p>To that end, you discovered how a new coordinate system—one that involves mapping spatial coordinates to texture coordinates via a method called UV unwrapping—might be necessary. Once the UV unwrapping is done, you can apply and swap different textures to your 3D models since the mapping from 2D to 3D is established.</p>
<p>Although creating textures with image editing applications is quite possible, you also know how to create textures procedurally in Blender. This is a powerful method, especially when it comes to surfaces that are hard to UV unwrap, such as landscapes. </p>
<p>Last but not least, you learned how to change the rendering engine to be able to export your procedural texture to your file system. Although this file is static and can no longer be updated automatically (unless you overwrite it with a new export, of course), you have the benefit of sharing the file easily. </p>
<p>You’ve been using Blender’s interface and your mouse to move around the scene and rotate the view to have a better look at your models, materials, and so on. In the following chapter, you’ll learn how to work with Camera and Light objects to create a composition where you can arrange objects in your scene under the best light conditions possible.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Further reading</h1>
<p>To read more about what each shader node does, you can refer to the official documentation at the following link: <a href="https://docs.blender.org/manual/en/2.93/render/shader_nodes/">https://docs.blender.org/manual/en/2.93/render/shader_nodes/</a>.</p>
<p>For further practice, imagine where else the method for the lava texture could be used. Perhaps, with carefully planned values and more color variations, the hot lava might be rust, and the cool lava might be paint?</p>
<p>If you are curious and would like to investigate different software out there capable of producing procedural textures, you can give <em class="italic">Adobe Substance Designer</em> a try. It’s a powerful program dedicated solely to creating textures. Not all of the nodes are labeled the same, but there are a lot of similar nodes to Blender’s. In fact, if you practice your skills there and look at other people’s creations, you might gain insight into creating such textures in Blender. </p>
</div>
<div><div></div>
</div>
</div>
</body></html>