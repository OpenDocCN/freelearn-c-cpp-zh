- en: Tips for Creating a Well-Abstracted Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建良好抽象架构的技巧
- en: Throughout this book, simple examples of minimal complexity have been provided.
    Our focus has been to keep the code clear and readable to illustrate the particular
    **real-time operating system** (**RTOS**) concepts being addressed and keep the
    interactions with hardware as easily understood as possible. However, in the real
    world, the best code bases for long-term development are those that allow developers
    to move quickly with great flexibility and determination to meet targets. This
    chapter provides suggestions on how to go about architecting, creating, growing,
    and maintaining a code base that will be flexible enough for long-term use. We'll
    be exploring these concepts with real code by cleaning up some of the code developed
    in earlier chapters through the addition of flexibility and better portability
    to different hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们提供了简单且复杂度最低的示例。我们的重点是保持代码清晰易读，以说明正在处理的特定**实时操作系统**（**RTOS**）概念，并尽可能使与硬件的交互易于理解。然而，在现实世界中，最适合长期开发的代码库是那些允许开发者快速灵活且坚定地达成目标的代码库。本章提供了关于如何构建、创建、扩展和维护一个足够灵活的代码库的建议，以便长期使用。我们将通过清理早期章节中开发的一些代码，并增加灵活性和更好的可移植性到不同的硬件，来探索这些概念。
- en: This chapter is valuable to anyone interested in reusing code across multiple
    projects. While the concepts presented here are by no means original, they are
    focused solely on firmware in embedded systems. The concepts covered are applicable
    to bare-metal systems, as well as highly reusable RTOS task-based systems. By
    following the guidelines here, you'll be able to create a flexible code base that
    adapts to many different projects, regardless of what hardware it happens to be
    running on. Another side effect (or direct intention) of architecting a code base
    in this manner is extremely testable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对任何对在多个项目中重用代码感兴趣的人都有价值。虽然这里提出的概念绝对不是原创的，但它们仅关注嵌入式系统中的固件。所涵盖的概念适用于裸机系统，以及高度可重用的基于RTOS的任务系统。通过遵循这里的指南，您将能够创建一个灵活的代码库，它能够适应许多不同的项目，无论它运行在什么硬件上。以这种方式构建代码库的另一个副作用（或直接意图）是代码的可测试性极高。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding abstraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象
- en: Writing reusable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可重用代码
- en: Organizing source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织源代码
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the code introduced in this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中介绍的代码，您需要以下内容：
- en: A Nucleo F767 development board
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767开发板
- en: A micro-USB cable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型USB线
- en: STM32CubeIDE and source code (instructions in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml),
    *Selecting an IDE*, under the *Setting up our IDE* section)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE和源代码（[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE*部分下的*设置我们的IDE*说明）
- en: SEGGER J-Link, Ozone, and SystemView (instructions in [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER J-Link、Ozone和SystemView（[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*中的说明）
- en: All source code for this chapter is available at [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_12](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_12).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码可在[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_12](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_12)找到。
- en: Understanding abstraction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象
- en: If our goal is to create a code base that will be usable for a long time, we
    need flexibility. Source code (just like product feature sets and business tactics)
    isn't chiseled out of rock—it tends to morph into different forms over time. If
    our source code is to be flexible, it needs to be able to morph and adapt. Only
    then will it be able to provide a solid foundation for implementing different
    feature sets of a product (or entire product lines) as the business landscape
    driving its development changes. Abstraction is a core tenet of flexibility.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是创建一个可以长期使用的代码库，我们需要灵活性。源代码（就像产品功能集和商业策略一样）并不是从石头上雕刻出来的——它往往会随着时间的推移而改变形态。如果我们的源代码要具有灵活性，它需要能够改变和适应。只有这样，它才能为实施产品（或整个产品线）的不同功能集提供一个坚实的基础，因为推动其发展的商业环境在变化。抽象是灵活性的核心原则。
- en: 'In our context, abstraction means representing a single instance of a complex
    implementation with a representation that can be applied to many different instances.
    For example, let''s take another look at an earlier example from [Chapter 1](39404421-bf7a-4283-bf78-c396818be4b4.xhtml),
    *Introducing Real-Time Systems*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，抽象意味着用一个可以应用于许多不同实例的表示来表示复杂实现的单个实例。例如，让我们再次看看[第1章](39404421-bf7a-4283-bf78-c396818be4b4.xhtml)中的另一个早期例子，“实时系统简介”：
- en: '![](img/b20cbc53-cee9-43a5-90d9-baab6fd2a939.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b20cbc53-cee9-43a5-90d9-baab6fd2a939.png)'
- en: The diagram itself is an abstract representation of the hardware required for
    a closed-loop control system. The exact part numbers of the ADC, driver circuitry,
    and **microcontroller unit** (**MCU**) aren't shown in the diagram; they could
    be almost anything.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该图本身是闭环控制系统所需硬件的抽象表示。图中没有显示ADC、驱动电路和**微控制器单元**（**MCU**）的确切部件编号；它们可以是任何东西。
- en: 'There are at least two primary reasons for using abstractions when creating
    a flexible code base:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建灵活的代码库时使用抽象至少有两个主要原因：
- en: Grasping an abstraction is fast.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象很快。
- en: Abstractions provide flexibility.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象提供了灵活性。
- en: Grasping an abstraction is fast
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象很快
- en: Understanding a well-written abstraction in code is similar to understanding
    a simple flow chart. Just as you don't need to understand every interconnect and
    resistor value when observing a flowchart (versus a schematic), reading through
    a well-commented header file of an abstraction provides nearly all of the information
    required to use any of the underlying implementations. There is no need to get
    buried under the details and idiosyncrasies of each implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码中写得好的抽象与理解简单的流程图相似。正如你在观察流程图（而不是原理图）时不需要理解每个互连和电阻值一样，阅读一个抽象的、注释良好的头文件几乎可以提供使用任何底层实现所需的所有信息。没有必要陷入每个实现的细节和特性中。
- en: This limited bird's-eye view means that future developers are more likely to
    *consume* the code since it is presented in a well-defined, well-documented, and
    consistent manner. The overall knowledge and time required to grasp an abstraction
    is much less than that required if implementing the same functionality from scratch.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有限的鸟瞰图意味着未来的开发者更有可能*消费*代码，因为它是以定义良好、文档齐全和一致的方式呈现的。掌握抽象所需的总知识和时间比从头开始实现相同功能所需的时间要少得多。
- en: An example with abstraction
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有抽象的例子
- en: 'If you saw a call to the following function call, you would probably have a
    fair chance at guessing what the function did, even without any proper comments:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了以下函数调用的调用，你很可能有机会猜出这个函数的功能，即使没有任何适当的注释：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is fairly self-explanatory—we're reading ADC values and storing
    them in 3 different buffers. If all of our calls to get ADC readings use the same `ReadAdcValue()`
    calling convention and descriptively name the ADC channel, understanding the code
    is fast and easy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当自解释——我们在读取ADC值并将它们存储在3个不同的缓冲区中。如果我们所有的获取ADC读数的调用都使用相同的`ReadAdcValue()`调用约定并描述性地命名ADC通道，理解代码就快而简单。
- en: An example without abstraction
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有抽象的例子
- en: 'On the flip side, imagine that instead you were given the following lines of
    code (they are functionally equivalent to the preceding code):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，想象一下，如果你被给出了以下代码行（它们在功能上与前面的代码等效）：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This immediately raises several questions, such as what the arguments being
    passed into `adc_avg()` and `HAL_ADC_GetValue()` are. At a minimum, we''d likely
    need to track down the relevant function prototypes and read through them:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即引发了一些问题，比如传递给`adc_avg()`和`HAL_ADC_GetValue()`的参数是什么。至少，我们可能需要找到相关的函数原型并阅读它们：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'OK, so `adc_avg()` takes an ADC channel as the first parameter and the number
    of samples to average as the second parameter—passing `1` to the second parameter
    provides a single reading. Now, what about this other call to `HAL_ADC_GetValue(adc2_ch0_h)`?
    We''d better go find the prototype for it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以`adc_avg()`将ADC通道作为第一个参数，将平均样本数作为第二个参数——将`1`传递给第二个参数提供单个读取。那么，关于对`HAL_ADC_GetValue(adc2_ch0_h)`的另一个调用呢？我们最好去找它的原型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It turns out `adc2_ch0_h` is a handle—probably to channel `0` on the ADC2 STM32
    peripheral... now, where's that schematic... is everything wired properly? Should
    channel `0` really be stored in `bufferZ`? That seems a little odd...
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明`adc2_ch0_h`是一个句柄——可能是指ADC2 STM32外设上的通道`0`...现在，那个原理图在哪里...所有线路都连接正确吗？通道`0`真的应该存储在`bufferZ`中吗？这似乎有点奇怪...
- en: OK, so this might be a *bit* contrived, but if you've been coding long enough,
    you've likely seen far worse. The takeaway here is that the consistency provided
    by a good abstraction makes reading code faster and easier than attempting to
    track down and understand the details of each specific implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这可能会有些牵强，但如果你编程时间足够长，你可能已经看到了更糟糕的情况。这里的要点是，一个好的抽象提供的一致性使得阅读代码比试图追踪和理解每个特定实现的细节要快得多和容易得多。
- en: Abstractions provide flexibility
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象提供灵活性
- en: 'Since a proper abstraction isn''t directly tied to an implementation, creating
    an abstraction for functionality provides flexibility in the way the functionality
    is implemented, even though the interface to that functionality is consistent.
    In the following figure, there are five different physical implementations of
    an ADC value—all represented by the same, simple abstraction, which is `int32_t
    ReadAdcValue( void );`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '由于适当的抽象并没有直接与实现绑定，因此为功能创建抽象提供了在实现方式上的灵活性，尽管该功能的接口是一致的。在下面的图中，有五种不同的ADC值物理实现——都由相同的简单抽象表示，即`int32_t
    ReadAdcValue(void);`:'
- en: '![](img/caae5a5d-4f82-468f-a0c5-a006adb7209e.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caae5a5d-4f82-468f-a0c5-a006adb7209e.png)'
- en: Although the function call remains consistent, there can be drastically different
    implementations of the ADC. In this diagram alone, there are five different ways
    for an ADC to provide data through the `ReadAdcValue` function. The ADC could
    be sitting on a local communication bus, such as I2C, SPI, or UART. It could be
    an internal ADC that is present on the MCU itself. Alternatively, the ADC reading
    may be coming from a remote node of an external network. Since there is a consistent,
    abstract interface, the underlying implementation isn't all that significant.
    A consumer of the interface doesn't need to be concerned with all of the details
    required to configure the ADC, collect the reading, and so on; the ADC only needs
    to make a call to `ReadAdcValue` to access the most up-to-date reading.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数调用保持一致，但ADC的实现可能会有很大的不同。仅在这个图中，就有五种不同的方式让ADC通过`ReadAdcValue`函数提供数据。ADC可能位于本地通信总线（如I2C、SPI或UART）上。它可能是一个存在于MCU本身的内部ADC。或者，ADC读取可能来自外部网络的远程节点。由于存在一致的抽象接口，底层实现并不那么重要。接口的消费者不需要关心配置ADC、收集读取等所需的所有细节；ADC只需要调用`ReadAdcValue`来访问最新的读取。
- en: There are, of course, many considerations to be made here, such as how recent
    the reading is, how quickly it must be collected, the resolution and scaling of
    the underlying reading, and so on. These types of details need to be provided
    by each provider and consumer that is implementing an abstraction. Naturally,
    there are cases where this level of abstraction is not appropriate for various
    reasons, which need to be evaluated on a case-by-case basis. If, for example,
    an algorithm needs to be run each time a new reading is taken, having it blindly
    poll `ReadAdValue` asynchronously won't work reliably.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里需要考虑很多因素，例如阅读的时效性、收集速度的快慢、底层阅读的分辨率和缩放等。这些细节需要由每个实现抽象的提供者和消费者提供。自然，由于各种原因，这个层次的抽象在某些情况下可能不合适，这需要根据具体情况逐一评估。例如，如果每次读取新的数据时都需要运行一个算法，那么盲目地异步轮询`ReadAdValue`是不可靠的。
- en: There are many examples of abstraction in the real world. Let's say you're a
    developer in an organization that makes many different products that all incorporate
    similar core components. For example, if you're designing a family of process
    controllers, you'll likely be interfacing with ADCs, DACs, and communication stacks.
    Each controller may have a slightly different user-facing feature set, but the
    underlying core components could be shared. Drivers for the ADCs, DACs, and algorithms
    can all share common code. By sharing common code across multiple products, developers
    only need to invest their time into writing common code once. As the customer-facing
    feature sets change over time, individual components may be replaced as needed,
    as long as they are loosely coupled to one another. Even the underlying MCU doesn't
    need to be the same, provided its hardware is sufficiently abstracted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界中有很多抽象的例子。假设你是一家制造许多不同产品的组织的开发者，这些产品都包含类似的核心组件。例如，如果你正在设计一个过程控制器系列，你很可能会与ADC、DAC和通信堆栈进行交互。每个控制器可能都有略微不同的用户界面功能集，但底层核心组件可以共享。ADC、DAC和算法的驱动程序都可以共享通用代码。通过在多个产品之间共享通用代码，开发者只需编写一次通用代码。随着时间的推移，客户界面功能集发生变化时，可以根据需要替换个别组件，只要它们之间是松散耦合的。即使底层的MCU不需要相同，只要其硬件足够抽象，也是如此。
- en: Let's take a closer look at the ADC in a controller as a specific example. The
    simplest way for a control algorithm to use ADC readings is to take raw readings
    from the device and use them directly. To reduce the number of source files, the
    drivers for the ADC, communication peripheral, and algorithm *could* all be combined
    into a single source file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以控制器中的ADC为例，更深入地了解一下。控制算法使用ADC读数的最简单方法是从设备中获取原始读数并直接使用它们。为了减少源文件的数量，ADC、通信外设和算法的驱动程序*可以*被合并到一个源文件中。
- en: Note that for precision applications, there are many issues with using raw readings
    directly, even without worrying about code elegance and abstraction. Ensuring
    consistent scaling and offsets and providing a flexible amount of resolution are
    all easier when code does not interface to the raw units (ADC counts) directly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于精度应用，即使不考虑代码的优雅性和抽象，直接使用原始读数也存在许多问题。确保一致的缩放和偏移以及提供灵活的分辨率都更容易，当代码不直接与原始单位（ADC计数）接口时。
- en: 'When code space and RAM are at a premium, or a quick and dirty  one-off, or
    a proof of concept are all that is desired, this approach might be acceptable.
    The resulting architecture might look something like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码空间和RAM非常宝贵，或者只需要一个快速且简单的单次使用，或者只需要一个概念验证时，这种方法可能是可接受的。结果架构可能看起来像以下这样：
- en: '![](img/d45447e5-da94-4c21-8ca4-0246d88c8294.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d45447e5-da94-4c21-8ca4-0246d88c8294.png)'
- en: 'A few things should jump out when looking at this architecture:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个架构时，应该有几个要点跳出来：
- en: The `algorithm.c` file is coupled with both the MCU and a specific ADC on a
    specific bus.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algorithm.c` 文件与特定总线上特定MCU和特定ADC紧密耦合。'
- en: If either the MCU or the ADC changes, a new version of `algorithm.c` will need
    to be created.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果MCU或ADC中的任何一个发生变化，都需要创建一个新的 `algorithm.c` 版本。
- en: The visual similarity between the links to the MCU and ADC ICs look very much
    like chains. This is not an accident. Code like this tightly binds whatever algorithm
    is inside `algorithm.c` to the underlying hardware in a way that is very inflexible.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MCU和ADC IC链接之间的视觉相似性非常像链条。这不是偶然的。这种代码将 `algorithm.c` 内部的任何算法与底层硬件紧密绑定，这种方式非常不灵活。
- en: 'There are also a few side effects that might not be as obvious:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些副作用可能不那么明显：
- en: '`algorithm.c` will be very difficult (maybe even impossible) to run independently
    of the hardware. This makes it very hard to test the algorithm in isolation. It
    also makes it very difficult to test all of the corner cases and error conditions
    that only occur when something goes wrong in the hardware.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algorithm.c` 将非常难以（可能甚至不可能）独立于硬件运行。这使得在隔离状态下测试算法变得非常困难。这也使得测试所有仅在硬件出现问题时才会出现的边缘情况和错误条件变得非常困难。'
- en: The immediate, useful life of `algorithm.c` will be limited to this single MCU
    and specific ADC. To add support for additional MCUs or ADC ICs, `#define` functions
    will need to be used; otherwise, the entire file will need to be copied and modified.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algorithm.c` 的直接有用寿命将限制在这个单个MCU和特定ADC上。要支持额外的MCU或ADC IC，需要使用 `#define` 函数；否则，整个文件需要复制并修改。'
- en: 'On the other hand, `algorithm.c` could be written so it doesn''t rely directly
    on the underlying hardware. Instead, it could rely on an abstract interface to
    the ADC. In this case, our architecture looks more like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`algorithm.c`可以编写成不直接依赖于底层硬件。相反，它可以依赖于 ADC 的抽象接口。在这种情况下，我们的架构看起来更像这样：
- en: '![](img/600d8f23-0a45-4f92-9130-1852ad7f10e0.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/600d8f23-0a45-4f92-9130-1852ad7f10e0.png)'
- en: 'The core points to observe in this variation are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中需要观察的核心要点如下：
- en: '`algorithm.c` has no direct reliance on any specific hardware configuration.
    Different ADCs and MCUs can be used interchangeably, assuming they correctly implement
    the interface required. This means it could move to an entirely different platform
    and be used as is, without modification.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algorithm.c`不直接依赖于任何特定的硬件配置。不同的 ADC 和 MCU 可以互换使用，前提是它们正确实现了所需的接口。这意味着它可以移动到完全不同的平台，并且无需修改即可使用。'
- en: The chains have been replaced by ropes, which *tie *together abstractions with
    their underlying implementations, rather than tightly bind `algorithm.c` to the
    underlying hardware.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链条已被绳索取代，这些绳索将抽象与其底层实现*绑定*在一起，而不是将`algorithm.c`紧密绑定到底层硬件。
- en: Only the implementations are tightly bound to the hardware.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有实现与硬件紧密绑定。
- en: 'Less obvious points that are also worth mentioning are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些不那么明显但同样值得提到的要点如下：
- en: '`ADC Driver` isn''t *completely *coupled to the hardware. While this particular
    driver will probably only support a single ADC, the ADC hardware itself won''t
    be necessary for getting the code to work. The hardware can be imitated by simulating
    SPI traffic. This allows testing the ADC driver independently of the underlying
    hardware.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC 驱动器`并非完全耦合到硬件。虽然这个特定的驱动器可能只支持单个 ADC，但 ADC 硬件本身对于使代码工作并非必需。可以通过模拟 SPI 流量来模拟硬件。这允许独立于底层硬件测试
    ADC 驱动器。'
- en: Both `SPI Driver` and `ADC Driver` can be used in other applications without
    rewriting them. This is a really big advantage to writing reusable code; it is
    flexible enough to repurpose with no additional work (or side effects).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPI 驱动器`和`ADC 驱动器`可以在其他应用中使用而无需重新编写。这对于编写可重用代码来说是一个很大的优势；它足够灵活，可以重新利用而无需额外的工作（或副作用）。'
- en: Now that we have a few examples of abstraction covered, let's consider why using
    abstractions may be important for projects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了一些抽象的例子，让我们考虑为什么使用抽象对于项目可能很重要。
- en: Why abstraction is important
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象为什么重要
- en: 'It is important to ensure your architecture is using abstractions if the following
    points apply:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下要点适用，确保您的架构正在使用抽象非常重要：
- en: Common components will be reused in other projects.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用组件将在其他项目中重用。
- en: Portability to different hardware is desirable.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植到不同硬件是可取的。
- en: Code will be unit tested.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将进行单元测试。
- en: Teams will be working in parallel
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队将并行工作
- en: 'For projects that are part of a larger code base, all four of the preceding
    points are generally desirable, since they all contribute to decreased time to
    market in the medium term. They also lead to decreased long-term maintenance costs
    for the code base:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于是更大代码库一部分的项目，上述四个点通常都是可取的，因为它们都促进了中期上市时间的减少。它们还导致代码库的长期维护成本降低：
- en: It is easier to create quality documentation once for the abstraction, rather
    than to thoroughly document every intricate piece of spaghetti code that reimplements
    the same functionality in a slightly different way.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于抽象，一次性创建高质量的文档比彻底记录每一块复杂的意大利面代码要容易得多，这些代码以略有不同的方式重新实现了相同的功能。
- en: Abstractions provide ways of cleanly decoupling hardware from many of the other
    interfaces used in a project.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象提供了将硬件从项目中使用的许多其他接口中干净地解耦的方法。
- en: Abstracting hardware interfaces makes unit testing code much easier (allowing
    programmers to run unit tests on their development machine, instead of on the
    target hardware).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象硬件接口使得单元测试代码更容易（允许程序员在他们的开发机器上而不是在目标硬件上运行单元测试）。
- en: Unit tests are similar to a type of documentation that's always up to date (if
    they are run regularly). They provide a source of truth for what the code is intended
    to do. They also provide a safety net when making changes or providing new implementations,
    ensuring nothing has been forgotten or inadvertently changed.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试类似于一种始终更新的文档类型（如果它们定期运行）。它们提供了代码意图做什么的真相来源。它们还在进行更改或提供新实现时提供了一个安全网，确保没有忘记或意外更改任何内容。
- en: Consistent abstractions lead to code bases that are more quickly understood
    by new team members. Each project in a code base is slightly more familiar than
    the last one since there's a large amount of commonality and consistency between
    them.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致的抽象使得代码库更容易被新团队成员快速理解。代码库中的每个项目都比上一个项目稍微熟悉一些，因为它们之间有很大的共同性和一致性。
- en: Loosely coupled code is easier to change. The mental burden for understanding
    a well-encapsulated module is much lower than trying to understand a sprawling
    implementation spanning multiple portions of a project. Changes to the well-encapsulated
    module are more likely to be made correctly and without side effects (especially
    when unit testing is employed).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合的代码更容易修改。理解一个良好封装的模块的心理负担远低于尝试理解跨越项目多个部分的庞大实现。对良好封装的模块的修改更有可能正确进行且没有副作用（尤其是在使用单元测试的情况下）。
- en: 'When abstractions are not used, the following symptoms commonly occur:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当不使用抽象时，以下症状通常会发生：
- en: New developers have a hard time making changes since each change has a ripple
    effect.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新开发者很难进行修改，因为每次修改都会产生连锁反应。
- en: It takes new developers a long time to understand a piece of code well enough
    to be comfortable changing it.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新开发者需要很长时间才能足够理解一段代码，以便能够舒适地对其进行修改。
- en: Parallel development is very difficult.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行开发非常困难。
- en: Code is tightly coupled to a specific hardware platform.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码紧密耦合到特定的硬件平台。
- en: For a real-world example where abstraction is required, we don't need to look
    any further than FreeRTOS itself. FreeRTOS wraps all of the device-specific functionality
    in two files, `port.c` and `portmacros.h`. To add support to a new hardware platform,
    only these files need to be created/modified. All of the other files that make
    up FreeRTOS have only a single copy, shared across dozens of ports for different
    hardware platforms. Libraries such as FatFs, lwIP, and many others also make use
    of hardware abstractions; it is the only way they can reasonably provide support
    for a large range of hardware.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要抽象的真实世界示例，我们不需要再往远处看，FreeRTOS本身就是一个例子。FreeRTOS将所有设备特定的功能封装在两个文件中，`port.c`和`portmacros.h`。为了支持新的硬件平台，只需要创建/修改这些文件。FreeRTOS的其他所有文件都只有一个副本，跨数十个不同硬件平台的端口共享。像FatFs、lwIP以及许多其他库也使用了硬件抽象；这是它们能够合理地为大量硬件提供支持的唯一方式。
- en: Recognizing opportunities to reuse code
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别代码复用的机会
- en: 'There is no absolute rule to follow when determining whether formalized abstractions
    should be used (if abstractions are not already present). However, there are some
    hints, which are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定是否应该使用形式化的抽象（如果抽象尚未存在）时没有绝对规则可循。然而，有一些提示，如下所示：
- en: '**If you''re writing code that can be used by more than one project**: Interfacing
    with the underlying hardware should be done through an abstraction (the ADC driver
    and algorithm in the preceding section are examples of this).  Otherwise, the
    code will be tied to the specific piece of hardware it was written for.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果你正在编写可以被多个项目使用的代码**：应该通过抽象（前述章节中的ADC驱动程序和算法就是此类抽象的例子）与底层硬件进行接口。否则，代码将绑定到为其编写的特定硬件上。'
- en: '**If your code interacts with a vendor-specific API**: Creating a light abstraction
    layer above it will reduce vendor lock-in. After interfaces are commonly used
    and set up, you''ll start to gravitate toward making vendor-specific APIs conform
    to your code base, which makes trying out different implementations quick and
    easy. It also insulates the bulk of your code from changes the vendor might make
    to the API over time.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果你的代码与特定供应商的API交互**：在其上方创建一个轻量级的抽象层将减少供应商锁定。在接口被普遍使用并设置之后，你将开始倾向于使特定供应商的API符合你的代码库，这使得尝试不同的实现变得快速且简单。这也有助于保护你的大部分代码免受供应商随时间对API所做的更改的影响。'
- en: '**If the module is in the center of the stack and interacts with other sub-modules**:
    Using formalized interfaces will reduce the coupling to the other modules, making
    it easier to replace them in the future.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果模块位于堆栈中心并与其他子模块交互**：使用形式化的接口将减少与其他模块的耦合，使得将来替换它们变得更容易。'
- en: One common misconception around code reuse is that creating a copy of code is
    the same as reusing the code. If a copy of the code has been created, it is effectively
    not being reused—let's look at why.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码复用的一个常见误解是，创建代码的副本与复用代码是相同的。如果已经创建了代码的副本，实际上它并没有被复用——让我们看看原因。
- en: Avoiding the copy-paste-modify trap
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复制粘贴修改陷阱
- en: So, we've got a piece of code that has been proven to work well and we have
    a new project coming up. How should we go about creating the new project—just
    copy the working project and start making changes? After all, if the code is being
    copied, it is being reused, right? Creating copies of a code base like this can
    inadvertently create a mountain of technical debt over time. The problem isn't
    the act of copying and modifying the code, it is trying to maintain all of the
    copies over time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一段经过验证的代码表现良好，而且我们有一个新的项目即将启动。我们应该如何创建这个新项目——只是复制工作项目并开始修改？毕竟，如果代码被复制，它就被重用了，对吧？随着时间的推移，创建这样的代码库副本可能会无意中积累大量的技术债务。问题不在于复制和修改代码的行为，而在于试图维护所有副本。
- en: 'Here''s a look at what a monolithic architecture for `algorithm.c` might look
    like over the course of six projects. Let''s assume that that actual algorithm
    is intended to be identical across all six projects:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是查看`algorithm.c`在六个项目中的单体架构可能的样子。假设实际算法在所有六个项目中都是相同的：
- en: '![](img/81931152-a848-4cbb-a4df-c611fce7ed0a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81931152-a848-4cbb-a4df-c611fce7ed0a.png)'
- en: 'Here are some of the main points in the diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是图中的一些主要点：
- en: It is impossible to tell whether the actual algorithm being used is the same
    since there are six copies of the file.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于有六个文件副本，所以无法判断实际使用的算法是否相同。
- en: In some cases, `algorithm.c` is implemented with different hardware. Since these
    changes were made in `algorithm.c`, it is isn't easily tell whether or not the
    algorithm implemented is actually the same without examining each file in detail.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，`algorithm.c`是用不同的硬件实现的。由于这些更改是在`algorithm.c`中进行的，所以很难不详细检查每个文件就判断所实现的算法是否真正相同。
- en: 'Now, let''s take a look at the *drawbacks* to copy-paste-modify in our example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们示例中复制粘贴修改的*缺点*：
- en: If `Algo` has a bug, it will need to be fixed in six different places.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Algo`存在错误，它需要在六个不同的地方进行修复。
- en: Testing a potential fix for `Algo` will need to be validated separately for
    each project. The only way to tell if a fix corrected the bug is probably by testing
    on actual hardware "in-system"; this is probably a very time-intensive task and
    it is potentially technically difficult to hit all of the edge cases.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`Algo`的潜在修复需要为每个项目单独验证。唯一能够判断修复是否纠正了错误的方法可能是在实际硬件“系统内”进行测试；这可能是一个非常耗时的工作，并且可能技术上难以覆盖所有边缘情况。
- en: The forked `Algo` function will likely morph over time (possibly inadvertently);
    this will further complicate maintenance because examining the differences between
    implementations will be even more difficult.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分叉的`Algo`函数可能会随着时间的推移而发生变化（可能是无意中）；这将进一步使维护复杂化，因为检查实现之间的差异将变得更加困难。
- en: Bugs are harder to find, understand, and fix because of all of the slight differences
    between the six projects.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于六个项目之间存在细微的差异，错误更难找到、理解和修复。
- en: Creating project 7 may come with a high degree of uncertainty (it is hard to
    tell exactly which features of `Algo` will be brought in, which intricacies/bugs
    from the `SPI` or `ADC` drivers will follow, and so on).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目7可能会伴随着很高的不确定性（很难确切地说`Algo`将引入哪些特性，`SPI`或`ADC`驱动程序将带来哪些复杂性/错误，等等）。
- en: If `MCU1` goes obsolete, porting `algorithm.c` will need to happen four separate
    times.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`MCU1`变得过时，`algorithm.c`的移植需要发生四次。
- en: 'All of these duplicates can be avoided by creating consistent reusable abstractions
    for the common components:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些重复都可以通过为通用组件创建一致的、可重用的抽象来避免：
- en: Each common component needs to have a consistent *interface*.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个通用组件都需要有一个一致的*接口*。
- en: Any code that is meant to be reused uses the *interface* rather than the *implementation
    (*`Algo` would use an ADC interface).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何打算重用的代码都应该使用*接口*而不是*实现（`Algo`将使用ADC接口）*。
- en: Common drivers, interfaces, and middleware should only have one copy.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用驱动程序、接口和中间件应该只有一个副本。
- en: Implementations are provided by the use of **board support packages** (**BSPs**),
    which provide an implementation for required interfaces.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用**板级支持包**（**BSPs**）提供实现，这些包为所需的接口提供实现。
- en: 'If the same algorithm were designed using the preceding guidelines, we might
    have something that looks more like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用前面的指南设计相同的算法，我们可能会有更类似于以下的样子：
- en: '![](img/23f33de7-3134-4344-902e-d9579e703b55.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23f33de7-3134-4344-902e-d9579e703b55.png)'
- en: 'Here are some of the main points in the diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是图中的一些主要点：
- en: There is only one copy of `algorithm.c`—it is immediately obvious that the algorithm
    used is identical across all six projects.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algorithm.c`只有一个副本——很明显，在所有六个项目中使用的算法是相同的。'
- en: Even though there are six projects, there are only four BSP folders—`BSP1` has
    been reused across three projects.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管有六个项目，但只有四个BSP文件夹——`BSP1`在三个项目中已被重用。
- en: An `ADC` interface is specified in a common location (Interfaces).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC`接口在公共位置（接口）中指定。'
- en: BSPs define an implementation of ADC, which is tied to specific hardware. These
    implementations are used by `main.c` and passed to `algorithm.c`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSP定义了ADC的实现，它与特定硬件相关联。这些实现被`main.c`使用，并传递给`algorithm.c`。
- en: The `ADC` interface, which is referenced by `Algo`, rather than a specific implementation.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Algo`引用的是`ADC`接口，而不是特定的实现。'
- en: There is only one copy of the `I2C` and `SPI` drivers for `MCU1` and `MCU2`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCU1`和`MCU2`的`I2C`和`SPI`驱动程序只有一个副本。'
- en: There is only one copy of the driver for the SPI-based ADC.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于SPI的ADC的驱动程序只有一个副本。
- en: There is only one copy of the driver for the I2C-based ADC.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于I2C的ADC的驱动程序只有一个副本。
- en: 'Reused code has the following advantages:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重用代码有以下优点：
- en: If `Algo` has a bug, it will only need to be fixed in one place.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Algo`存在错误，它只需要在一个地方修复。
- en: Although final integration testing for `Algo` will still need to be performed
    in-system with real hardware (but probably only needs to be performed on the four
    BSP's, rather than all six projects), the bulk of the testing and development
    can be done by mocking the ADC interface, which is fast and simple.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管最终集成测试`Algo`仍然需要在系统内使用真实硬件（但可能只需要在四个BSP上进行，而不是所有六个项目），但大部分的测试和开发可以通过模拟ADC接口来完成，这既快又简单。
- en: It is impossible for `Algo` to morph over time since there is only one copy.
    It will always be trivial to see whether or not the algorithm used is different
    between projects.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于只有一个副本，`Algo`不可能随着时间的推移而发生变化。是否在项目之间使用了不同的算法总是很容易看出。
- en: Bugs are easier to find, understand, and fix due to the decreased interdependencies
    of the dependencies. A bug in `Algo` is guaranteed to show up in all six projects
    (since there is only one copy). However, it is less likely to occur, since testing `Algo`
    during development was easier, thanks to the interface.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于依赖项之间的相互依赖性降低，错误更容易被发现、理解和修复。`Algo`中的错误保证会在所有六个项目中出现（因为只有一个副本）。然而，由于在开发过程中测试`Algo`更容易，所以它出现的可能性较小，这得益于接口。
- en: Creating project 7 is likely to be fast and efficient with a high degree of
    certainty due to all of the consistency across the other six projects.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其他六个项目的一致性，创建项目7可能会非常快速和高效，具有很高的确定性。
- en: If `MCU1` goes obsolete, porting `algorithm.c` isn't even necessary since it
    has no direct dependency on an MCU—only the `ADC` interface. Instead, a different
    BSP will need to be selected/developed.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`MCU1`过时，由于它没有直接依赖于MCU——只有`ADC`接口，因此甚至不需要移植`algorithm.c`。相反，需要选择/开发不同的BSP。
- en: One exception to copy-paste-modify is *extremely* low-level code that needs
    to be written to support similar but different hardware. This is typically the
    driver-level code that directly interfaces with MCU peripheral hardware registers.
    When two MCU families share the same peripherals with only minor differences,
    it can be tempting to try and develop common code to implement them both, but
    this is often more confusing for everyone (both the original author and the maintenance
    developers).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要编写以支持类似但不同的硬件的极低级别代码，复制粘贴修改是一个例外。这通常是直接与MCU外围硬件寄存器接口的驱动级代码。当两个MCU系列共享相同的外围设备，只有细微差别时，尝试开发通用代码以实现它们可能会很有吸引力，但这通常会让每个人（包括原始作者和维护开发者）感到更加困惑。
- en: In these cases, it can be quite time-intensive and error-prone to force an existing
    piece of code to support a different piece of hardware, especially as the code
    ages and more hardware platforms are added. Eventually, if the code base becomes
    old enough, a new hardware target will vary significantly enough that it will
    no longer be remotely viable to incorporate those changes into the existing low-level
    code. As long as the low-level drivers are conforming to the same interface, they
    will still hold quite a bit of value in the long term. Keeping this low-level
    code easily understood and bug-free is the highest priority, followed by conforming
    to a consistent interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，强制现有代码支持不同的硬件可能会非常耗时且容易出错，尤其是随着代码的陈旧和更多硬件平台的增加。最终，如果代码库足够老，新的硬件目标将会有显著的变化，以至于将那些更改纳入现有的底层代码将不再可行。只要底层驱动程序符合相同的接口，它们在长期内仍然具有相当大的价值。保持这种底层代码易于理解和无错误是最高的优先级，其次是符合一致的接口。
- en: Now that we have a good idea of what abstraction is, let's take a closer look
    at some real-world examples of how to write code that can be easily reused.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对抽象有了很好的理解，让我们更深入地看看一些现实世界的例子，了解如何编写易于重用的代码。
- en: Writing reusable code
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可重用代码
- en: When you are first getting started with creating abstractions, it can be difficult
    to know exactly what should be abstracted versus what should be used directly.
    To make code fully reusable, a module should only perform one function and reference
    interfaces for the other pieces of functionality. Any hardware-specific calls
    must go through interfaces, rather than deal with the hardware directly. This
    is true for accessing actual hardware (such as specific pins) and also MCU-specific
    APIs (such as STM32 HAL).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始创建抽象时，可能很难确切知道应该抽象什么，以及应该直接使用什么。为了使代码完全可重用，模块应只执行一个功能并引用其他功能部分的接口。任何特定于硬件的调用都必须通过接口进行，而不是直接处理硬件。这适用于访问实际硬件（如特定引脚）以及
    MCU 特定的 API（如 STM32 HAL）。
- en: Writing reusable drivers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可重用驱动程序
- en: 'There are a few different levels of drivers that are fairly common in embedded
    development. MCU peripheral drivers are the drivers used to provide a convenient
    API to hardware included on the MCU. These types of drivers were developed in
    [Chapter 10](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml), *Drivers and ISRs*.
    Another commonly used driver is a driver for a specific IC, which is what was
    alluded to in the preceding ADC example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式开发中，存在几种不同级别的驱动程序，它们相当常见。MCU 外设驱动程序是用于为 MCU 上包含的硬件提供便利 API 的驱动程序。这些类型的驱动程序在[第
    10 章](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml)，*驱动程序和中断服务例程*中进行了开发。另一种常用的驱动程序是针对特定
    IC 的驱动程序，这在先前的 ADC 示例中有所提及：
- en: '![](img/7835c57e-ba6e-49f5-8136-64be3b84944e.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7835c57e-ba6e-49f5-8136-64be3b84944e.png)'
- en: Peripheral drivers sit immediately above the hardware. IC drivers sit above
    (and often use) peripheral drivers in the stack. If an IC driver is meant to work
    across multiple MCUs, it must use interfaces that are completely agnostic to the
    underlying MCU hardware. For example, STM32 HAL can be thought of as a type of
    peripheral driver, but it does not provide MCU-independent abstractions for the
    peripherals. In order to create IC drivers that are portable across MCUs, they
    must only access MCU-independent interfaces.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 外设驱动程序位于硬件之上。IC 驱动程序位于堆栈中的外设驱动程序之上（并且通常使用它们）。如果一个 IC 驱动程序旨在跨多个 MCU 工作，它必须使用对底层
    MCU 硬件完全无知的接口。例如，STM32 HAL 可以被视为一种外设驱动程序，但它不提供针对外设的 MCU 独立抽象。为了创建跨 MCU 可移植的 IC
    驱动程序，它们必须只访问 MCU 独立接口。
- en: Developing an LED interface
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 LED 接口
- en: To illustrate the initial concept in detail, let's take a look at a simple driver
    that we've been using since the first examples introduced in this book—an LED
    driver. A simplified version of an interface to drive the LEDs on our Nucleo board
    has been used since the very first examples in earlier chapters. This interface
    is located at `BSP\Nucleo_F767ZI_GPIO.c/h`***.*** This code fully abstracted the
    LEDs from the underlying hardware with a struct named `LED`. The `LED` struct
    has two function pointers: `On` and `Off`. As expected, the intention of these
    two functions is to turn an LED on and off. The beauty of this is that the calling
    code doesn't need to be concerned with the implementation of the LED at all. Each
    LED could have a completely different hardware interface. It might require positive
    or negative logic to drive an external transistor or be on a serial bus of some
    sort. The LED could even be on a remote panel requiring **remote procedure calls**
    (**RPCs**) to another board entirely. However, regardless of how the LED is turned
    on and off, the interface remains the same.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明初始概念，让我们看看一个简单的驱动程序，自从本书中引入的第一个示例以来我们就一直在使用它——一个 LED 驱动程序。从早期章节中的第一个示例开始，我们就使用了简化版的驱动
    Nucleo 板上 LED 的接口。这个接口位于 `BSP\Nucleo_F767ZI_GPIO.c/h`***.***。这段代码通过名为 `LED` 的结构体完全抽象了
    LED 与底层硬件的关系。`LED` 结构体有两个函数指针：`On` 和 `Off`。正如预期的那样，这两个函数的目的是打开和关闭 LED。这种做法的美丽之处在于，调用代码根本不需要关心
    LED 的实现。每个 LED 可能都有完全不同的硬件接口。它可能需要正逻辑或负逻辑来驱动外部晶体管，或者位于某种类型的串行总线上。LED 甚至可能位于一个远程面板上，需要通过
    **远程过程调用** (**RPCs**) 到另一个完全不同的板。然而，无论 LED 是如何打开和关闭的，接口都是相同的。
- en: To try and keep things simple, `Nucleo_F767ZI_GPIO.c/h` defined the LED struct
    in the header file. As we move through this current example, we'll extract the
    interface definition from the header file, making it completely standalone, requiring
    no external dependencies. The lack of dependencies will guarantee that we can
    move the new interface definition to entirely different platforms, without requiring
    any code specific to a particular MCU at all.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽量保持简单，`Nucleo_F767ZI_GPIO.c/h` 在头文件中定义了 LED 结构体。随着我们通过这个当前示例的进展，我们将从头文件中提取接口定义，使其完全独立，不需要任何外部依赖。没有依赖将保证我们可以将新的接口定义移动到完全不同的平台，而无需任何特定于特定
    MCU 的代码。
- en: Our new, independent LED interface will be called `iLED`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的、独立的 LED 接口将被称为 `iLED`。
- en: The lowercase "i" is a convention used by some C++ programmers to indicate a
    class that only contains virtual functions, which is effectively an interface
    definition. Since we're only dealing with C in this book (not C++), we'll stick
    to structs and function pointers to provide the necessary decoupling. The methods
    outlined here are conceptually similar to pure virtual classes in C++.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 小写 "i" 是一些 C++ 程序员用来表示只包含虚拟函数的类的一种约定，这实际上是一个接口定义。由于我们在这本书中只处理 C（不是 C++），我们将坚持使用结构体和函数指针来提供必要的解耦。这里概述的方法在概念上类似于
    C++ 中的纯虚类。
- en: 'The interface is defined in the new `Interfaces***/***iLed.h` file; the core
    of the contents is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义在新的 `Interfaces***/***iLed.h` 文件中；内容的核心如下：
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s break down exactly what is going on in the preceding definition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体分析一下前面的定义中正在发生的事情：
- en: We create a new type:`iLedFunc`. Now, `typedef void (*iLedFunc)(void);` defines
    the `iLedFunc` type as a function pointer to a function that takes no arguments
    and returns nothing.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的类型：`iLedFunc`。现在，`typedef void (*iLedFunc)(void);` 将 `iLedFunc` 类型定义为指向一个不接受任何参数且不返回任何内容的函数的函数指针。
- en: The `iLed` struct is defined as any other struct—we can now create instances
    of this struct. We're defining a struct so it is convenient to bundle together
    all of the function pointers and pass a reference to the structs around it.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iLed` 结构体被定义为任何其他结构体——我们现在可以创建这个结构体的实例。我们定义一个结构体是为了方便将所有的函数指针捆绑在一起，并传递对周围结构体的引用。'
- en: Each `iLedFunc` member is defined as `const` so it can only be set once at the
    time of definition. This protects us (or other developers) from accidentally overwriting
    the value of the function pointer (which can be potentially disastrous). The compiler
    will catch any attempts to write to the `On` or `Off` function pointers and throw
    an error.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `iLedFunc` 成员都被定义为 `const`，因此它只能在定义时设置一次。这保护了我们（或其他开发者）免受意外覆盖函数指针值（这可能是灾难性的）的风险。编译器将捕获对
    `On` 或 `Off` 函数指针的任何写入尝试，并抛出错误。
- en: It is extremely important that the header file defining the interface includes
    as few dependencies as possible to keep it as loosely coupled as possible. The
    more dependencies this file has, the less future flexibility there will be.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保定义接口的头文件尽可能少地包含依赖项非常重要，以保持其尽可能松散耦合。这个文件包含的依赖项越多，未来的灵活性就越小。
- en: That does it for the interface definition. There is no functionality provided
    by the preceding code; it only defined an interface. In order to create an implementation
    of the `iLed` interface, we'll need two more files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义到此结束。前面的代码没有提供任何功能；它只定义了一个接口。为了创建 `iLed` 接口的实现，我们还需要两个额外的文件。
- en: 'The following is an excerpt from `ledImplementation.h`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `ledImplementation.h` 的摘录：
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This header file brings in the `iLed.h` interface definition and declares three
    instances of `iLed`, which are `BlueLed`, `GreenLed`, and `RedLed`. These implementations
    of the `iLed` interface can be used by any piece of code that includes `ledImplementation.h`***.  ***The `extern`
    keyword ensures only one copy is ever created, regardless of how many different
    code modules use `ledImplementation.h`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此头文件引入了 `iLed.h` 接口定义并声明了三个 `iLed` 实例，分别是 `BlueLed`、`GreenLed` 和 `RedLed`。这些
    `iLed` 接口的实现可以被任何包含 `ledImplementation.h` 的代码片段使用***。***`extern` 关键字确保无论多少不同的代码模块使用
    `ledImplementation.h`，都只会创建一个副本。
- en: Next, we need to provide definitions for the `iLed` instances; this is done
    in `ledImplementation.c`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为 `iLed` 实例提供定义；这是在 `ledImplementation.c` 中完成的。
- en: 'Only the code for `GreenLed` is shown here. The `BlueLed` and `RedLed` implementations
    only differ in the GPIO pin they set:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只展示了 `GreenLed` 的代码。`BlueLed` 和 `RedLed` 的实现仅在它们设置的 GPIO 引脚上有所不同：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Breaking it down, we can observe the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 分解来看，我们可以观察到以下内容：
- en: '`GreenOn` defines an inline function that turns on the green LED on our Nucleo
    development board. It takes no parameters and returns nothing, so it can be used
    as `iLedFunc`, as defined in the previous code.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GreenOn` 定义了一个内联函数，用于在 Nucleo 开发板上打开绿色 LED。它不接受任何参数也不返回任何内容，因此它可以作为 `iLedFunc`
    使用，如前述代码中定义的那样。'
- en: '`GreenOff` defines an inline function that turns off the green LED on our Nucleo
    development board. It is can also be used as `iLedFunc`.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GreenOff` 定义了一个内联函数，用于在 Nucleo 开发板上关闭绿色 LED。它也可以用作 `iLedFunc`。'
- en: An instance of `iLed` is created and named `GreenLed`. The `iLedFunc` function
    pointers `GreenOn` and `GreenOff` are passed in during initialization. The order
    of the functions defined in `iLed` is critical. Since `On` is defined in the `iLed`
    struct first, the first function pointer passed in (`GreenOn`) will be assigned
    to `On`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个名为 `GreenLed` 的 `iLed` 实例。在初始化期间传递了 `iLedFunc` 函数指针 `GreenOn` 和 `GreenOff`。`iLed`
    中定义的函数顺序至关重要。由于 `On` 在 `iLed` 结构体中首先定义，因此传递的第一个函数指针（`GreenOn`）将被分配给 `On`。
- en: The only code that relies on specific hardware so far is `ledImplementation.c`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一依赖于特定硬件的代码是 `ledImplementation.c`。
- en: A pointer to `GreenLed` can now be passed to different pieces of code that only
    bring in `iLed.h`—they won't be tied to `HAL_GPIO_WritePin` in any way. An example
    of this is `hardwareAgnosticLedDriver.c/h`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将指向 `GreenLed` 的指针传递给不同的代码片段，这些代码片段仅引入 `iLed.h`——它们不会以任何方式绑定到 `HAL_GPIO_WritePin`。一个例子是
    `hardwareAgnosticLedDriver.c/h`。
- en: 'The following is an excerpt from `hardwareAgnosticLedDriver.h`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `hardwareAgnosticLedDriver.h` 的摘录：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only `include` function required by this hardware-agnostic driver is `iLed.h`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此硬件无关驱动程序所需的唯一 `include` 函数是 `iLed.h`。
- en: For `hardwareAgnosticLedDriver.h` to be truly hardware agnostic, it must not
    include any hardware-specific files. It must only access hardware through hardware-independent
    interfaces, such as `iLed`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `hardwareAgnosticLedDriver.h` 真正实现硬件无关，它不能包含任何特定硬件的文件。它必须仅通过硬件无关的接口访问硬件，例如
    `iLed`。
- en: 'The following is a trivial example that simply turns a single LED on or off.
    The excerpt is from `hardwareAgnosticLedDriver.c`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，它只是简单地打开或关闭单个 LED。摘录来自 `hardwareAgnosticLedDriver.c`：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Breaking it down, we can observe the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分解来看，我们可以观察到以下内容：
- en: '`doLedStuff` takes in a pointer to a variable of the `iLed` type as a parameter.
    This allows any implementation of the `iLed` interface to be passed in `doLedStuff`,
    which provides complete flexibility in how the `On` and `Off` functions are implemented
    without tying `hardwareAgnosticLedDriver` to any specific hardware.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doLedStuff` 接收一个指向 `iLed` 类型变量的指针作为参数。这允许将 `iLed` 接口的任何实现传递给 `doLedStuff`，从而在实现
    `On` 和 `Off` 函数时提供完全的灵活性，而不会将 `hardwareAgnosticLedDriver` 绑定到任何特定硬件。'
- en: If your interface definition supports leaving out functionality by setting pointers
    to `NULL`, they will need to be checked to ensure they are not set to `NULL`.
    Depending on the design, these checks might not be necessary since the values
    for `On` and `Off` are only able to be set during initialization.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的接口定义支持通过设置指针为`NULL`来省略功能，那么它们需要被检查以确保它们没有被设置为`NULL`。根据设计，这些检查可能不是必需的，因为`On`和`Off`的值只能在初始化期间设置。
- en: The actual implementations of `On` and `Off` are called by using the `LedPtr`
    pointer and calling them like any other function.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`LedPtr`指针并像调用任何其他函数一样调用它们来调用`On`和`Off`的实际实现。
- en: 'A full example using `doLedStuff` is found in `mainLedAbstraction.c`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`doLedStuff`的完整示例可以在`mainLedAbstraction.c`中找到：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Breaking it down, we can observe the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 分解来看，我们可以观察到以下内容：
- en: The implementations for `GreenLed`, `RedLed`, and `BlueLed` are brought in by
    including `ledImplementation.h`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GreenLed`、`RedLed`和`BlueLed`的实现是通过包含`ledImplementation.h`引入的。'
- en: '`doLedStuff` is brought in by including `hardwareAgnosticLedDriver.h`.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doLedStuff`是通过包含`hardwareAgnosticLedDriver.h`引入的。'
- en: We provide the implementation for `doLedStuff` by passing in a pointer to the
    desired instance of `iLed`. In this example, we're toggling each of the green,
    red, and blue LEDs on the development board by passing the `GreenLed`, `RedLed`,
    and `BlueLed` implementations to `doLedStuff`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过传递指向所需`iLed`实例的指针来提供`doLedStuff`的实现。在这个例子中，我们通过将`GreenLed`、`RedLed`和`BlueLed`实现传递给`doLedStuff`来切换开发板上的每个绿色、红色和蓝色LED。
- en: This example simply toggled the single LEDs, but the complexity is arbitrary. By
    having well-defined interfaces, tasks can be created that take in pointers to
    instances of the interface. The tasks can be reused across multiple projects without
    touching them all—only a new implementation of the interface needs to be created
    when support for new hardware is required. When there is a considerable amount
    of code implemented by the hardware-agnostic task, this can dramatically decrease
    the total amount of time spent on the project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例只是简单地切换单个LED，但复杂性是任意的。通过拥有定义良好的接口，可以创建接受接口实例指针的任务。这些任务可以在多个项目中重用，而无需修改它们的所有内容——当需要支持新的硬件时，只需创建接口的新实现即可。当硬件无关的任务实现了相当数量的代码时，这可以显著减少项目所花费的总时间。
- en: Let's take a look at a simple example of passing instances of interfaces into
    tasks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单示例，将接口的实例传递到任务中。
- en: Reusing code containing tasks
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用包含任务的代码
- en: RTOS tasks are among the best suited for reuse because (when well-written) they
    offer single-purpose functionality that can be easily prioritized against the
    other functions the system must perform. In order for them to be easily reused
    in the long term, they need to have as few direct ties to the underlying platform
    as possible. Using interfaces as described previously works extremely well for
    this purpose since the interface fully encapsulates the desired functionality
    while decoupling it from the underlying implementation. To further ease the setup
    of the FreeRTOS task, the creation of the task can be wrapped inside an initialization
    function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: RTOS任务非常适合重用，因为（当编写得很好时）它们提供单一功能的功能，可以很容易地与其他系统必须执行的功能进行优先级排序。为了使它们能够长期轻松重用，它们需要尽可能少地直接与底层平台相关联。使用前面描述的接口对于这个目的非常有效，因为接口完全封装了所需的功能，同时将其与底层实现解耦。为了进一步简化FreeRTOS任务的设置，任务的创建可以封装在初始化函数中。
- en: '`mainLedTask.c` uses `ledTask.c/h` to show an example of this. The following
    excerpt is from `ledTask.h`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainLedTask.c`使用`ledTask.c/h`来展示这个示例。以下摘录来自`ledTask.h`：'
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A few significant notes on this simple header file are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个简单头文件的一些重要说明如下：
- en: The only files included are those required for FreeRTOS and `iLed.h`, none of
    which are directly dependent on any specific hardware implementation.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只包含必要的文件，即用于FreeRTOS和`iLed.h`的文件，这些文件都不直接依赖于任何特定的硬件实现。
- en: The priority of the task is brought in as an argument of the initialization
    function. This is important for flexibility because over time, LED tasks are likely
    to require different priorities relative to the rest of the system.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务优先级作为初始化函数的参数引入。这对于灵活性很重要，因为随着时间的推移，LED任务可能需要相对于系统其他功能的不同的优先级。
- en: '`StackSize` is also parameterized—this is required because, depending on the
    underlying implementation of `LedPtr`, the resulting task may need to use different
    amounts of stack space.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackSize`也是参数化的——这是必需的，因为根据`LedPtr`的底层实现，生成的任务可能需要使用不同数量的堆栈空间。'
- en: '`LedTaskInit` returns `TaskHandle_t`, which can be used by the calling code
    to control or delete the resulting task.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LedTaskInit`返回`TaskHandle_t`，调用代码可以使用它来控制或删除生成的任务。'
- en: '`ledTask.c` contains the definition of `LedTaskInit`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledTask.c`包含`LedTaskInit`的定义：'
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This initialization function performs the same functions as what we''ve typically
    seen in `main`, but now, it is neatly encapsulated into a single file, which can
    be used across multiple projects. Functions taken care of by `LedTaskInit` include
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化函数执行与我们在`main`中通常看到的功能相同，但现在，它被整洁地封装到一个单独的文件中，可以在多个项目中使用。由`LedTaskInit`处理的函数包括以下内容：
- en: Checking that `LedPtr` is not `NULL`.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`LedPtr`是否不是`NULL`。
- en: Creating a task that runs the `ledTask` function and passing `LedPtr` to it,
    which provides a specific implementation of the `iLed` interface for that `ledTask` instance. `ledTask`
    is created with the specified `Priority` task and `StackSize`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个运行`ledTask`函数的任务，并将`LedPtr`传递给它，这为该`ledTask`实例提供了`iLed`接口的特定实现。`ledTask`使用指定的`Priority`任务和`StackSize`创建。
- en: Verifying whether it has been created successfully before `LedTaskInit` returns
    the handle to the task that was created.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`LedTaskInit`返回创建的任务句柄之前，验证它是否已成功创建。
- en: '`ledTask.c` also contains the actual code for `ledTask`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledTask.c`也包含`ledTask`的实际代码：'
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, `LedPtr` needs to be cast from `void*` into `iLed*`. After this cast,
    we are able to call the functions of our `iLed` interface. The underlying hardware
    calls will depend on the implementation of `LedPtr`. This is also the reason for
    allowing a `StackSize` variable during initialization—`LedPtr` may have a more
    complex implementation in some cases, which could require a larger stack.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`LedPtr`需要从`void*`转换为`iLed*`。在此转换之后，我们能够调用我们的`iLed`接口的函数。底层硬件调用将取决于`LedPtr`的实现。这也是允许在初始化期间有`StackSize`变量的原因——在某些情况下，`LedPtr`可能有更复杂的实现，这可能需要更大的堆栈。
- en: Thanks to `LedTaskInit`, creating tasks that map the `LedPtr` implementations
    into the task is extremely easy.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`LedTaskInit`，将`LedPtr`实现映射到任务中的任务创建变得极其简单。
- en: 'The following is an excerpt from `mainLedTask.c`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`mainLedTask.c`摘录的内容：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`GreenLed`, `BlueLed`, and `RedLed` are passed into `LedTaskInit` to create
    three independent tasks with varying priorities and potentially different stack
    sizes. All of the hardware-specific code has been kept out of `ledTask.c/h`. When
    this technique is used for complex tasks, significant time savings and increased
    confidence can be realized. Along the lines of increasing confidence in the code
    we write, let''s take a quick look at exactly how providing an abstracted interface
    makes testing tasks easier.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreenLed`、`BlueLed`和`RedLed`被传递到`LedTaskInit`以创建三个具有不同优先级和可能不同堆栈大小的独立任务。所有特定于硬件的代码都已被保留在`ledTask.c/h`之外。当使用此技术处理复杂任务时，可以实现显著的时间节省和信心增加。沿着增加我们编写的代码的信心这一方向，让我们快速看一下提供抽象接口是如何使测试任务变得更容易的。'
- en: Testing flexible code
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试灵活的代码
- en: Since the `iLed` interface isn't directly reliant on any hardware, it is extremely
    easy to push alternative implementations to `ledTask`. Rather than passing in
    one of the actual hardware implementations for `iLed`, we could pass in anything
    we like to either `LedTaskInit` (for integration-level tests) or `ledTask` (for
    unit tests). The implementations, in these cases, would likely set variables in
    the testing environment when called. For example, `On` could set a Boolean to `TRUE`
    when called and `Off` could set the same Boolean to `FALSE`. These types of tests
    can be used to verify the logic of the task, without requiring any hardware at
    all, provided a compiler and an alternative environment is set up on the development
    machine. FreeRTOS ports exist for desktop OSes that allow testing relative priorities
    of tasks (without any real-time guarantees). Specific timing dependencies aren't
    able to be tested this way, but it does allow developers to gain a considerable
    amount of confidence in the middle layers of code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`iLed`接口不直接依赖于任何硬件，因此将其替代实现推送到`ledTask`非常容易。我们不必传递`iLed`的实际硬件实现之一，而可以传递任何我们喜欢的内容到`LedTaskInit`（用于集成级测试）或`ledTask`（用于单元测试）。在这些情况下，实现可能会在调用时设置测试环境中的变量。例如，`On`在调用时可以将布尔值设置为`TRUE`，而`Off`可以将相同的布尔值设置为`FALSE`。这些类型的测试可以用来验证任务逻辑，而无需任何硬件，前提是在开发机上设置了编译器和替代环境。FreeRTOS端口存在于桌面操作系统上，允许测试任务的相对优先级（没有实时保证）。这种方式无法测试特定的时序依赖，但它确实允许开发者对代码的中间层有相当大的信心。
- en: See the *Further reading* section for articles that cover unit testing in more
    detail.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*进一步阅读*部分，了解更详细地介绍单元测试的文章。
- en: Now that we have an idea of how to write reusable code, we need to make sure
    it is being stored in a way that allows it to be used across multiple projects
    without creating unnecessary copies or creating strange inter-project dependencies.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何编写可重用的代码，我们需要确保它以允许在多个项目中使用的方式存储，而不会创建不必要的副本或产生奇怪的跨项目依赖。
- en: Organizing source code
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织源代码
- en: A well-organized source tree is extremely important if a code base is intended
    to evolve and grow over time. If projects are meant to live in isolation as atomic
    entities that never interact with one another, there is little reason to have
    a strategy when it comes to source control; but if code reuse is a goal, then
    having a clear idea of how specific projects should fit together with common code
    is a must.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码库打算随着时间的推移而演变和增长，一个良好的源代码树就极其重要。如果项目打算作为原子实体独立存在，彼此之间从不交互，那么在源代码控制方面制定策略就几乎没有理由；但如果代码重用是一个目标，那么明确了解特定项目应该如何与通用代码结合在一起是必须的。
- en: Choosing locations for source files
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择源文件的位置
- en: 'Any piece of code that is likely to be used in more than the original project
    where it is first created should live in a common location (not tied to a specific
    project). Even if the code started out as being specific to one particular project,
    it should be moved as soon as it is used by more than one project. Pieces of common
    code will be different for each team, but will likely include the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可能被用于最初创建它的项目之外的代码都应该位于一个通用位置（不与特定项目绑定）。即使代码最初是针对特定项目编写的，一旦被多个项目使用，就应该尽快将其移动。通用代码的片段对每个团队来说都可能不同，但可能包括以下内容：
- en: '**BSPs**: There are often multiple pieces of firmware created for each board.
    The BSP folder in the code base for this book doesn''t have any subfolders (mainly
    because there, the code only supports a single platform). If this book supported
    multiple platforms, the BSP folder would likely contain a `Nucleo_F767` subfolder.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**板级支持包（BSPs）**：通常为每个板创建多个固件。本书代码库中的BSP文件夹没有子文件夹（主要是因为在那里，代码只支持单个平台）。如果本书支持多个平台，BSP文件夹可能会包含一个`Nucleo_F767`子文件夹。'
- en: '**In-house common code**:This can include custom domain-specific algorithms
    or drivers for ICs that are commonly used across multiple products or projects.
    Any code here should be able to be well-abstracted and used across multiple MCUs.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部通用代码**：这可以包括针对特定领域定制的算法或用于多个产品或项目间常用的集成电路（IC）的驱动程序。这里的任何代码都应该能够很好地抽象化，并在多个微控制器（MCU）上使用。'
- en: '**Third-party common code**:If multiple projects include source code from a
    third party, it belongs in a central location. Items such as FreeRTOS and any
    other middleware can be kept in this central location.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方通用代码**：如果多个项目包含第三方源代码，它们应该放在一个中心位置。例如FreeRTOS和其他中间件可以保存在这个中心位置。'
- en: '**MCU-specific code**:Each MCU family should ideally have its own folder. This
    will likely include things such as STM32 HAL and any custom peripheral drivers
    developed for that MCU. Ideally, most of the code referenced in these MCU-specific
    directories will be done so through common interfaces (shown in the ADC example
    at the beginning of the chapter).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MCU特定代码**：每个MCU系列理想情况下应该有自己的文件夹。这可能会包括STM32 HAL以及为该MCU开发的任何自定义外设驱动程序。理想情况下，这些MCU特定目录中引用的大多数代码将通过通用接口（如本章开头ADC示例中所示）来完成。'
- en: '**Interface definitions**:If interfaces are used extensively, having all of
    them in one place is extremely convenient.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口定义**：如果广泛使用接口，将它们全部放在一个地方非常方便。'
- en: '**Project folders**:Each project will likely have its own folder (sometimes
    containing sub-projects). Ideally, projects won''t reference code in other projects—only
    code that is housed in the common areas. If projects start to have inter-dependencies,
    take a step back and evaluate why, and whether or not it makes sense to move those
    dependencies to a common location.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目文件夹**：每个项目可能都有自己的文件夹（有时包含子项目）。理想情况下，项目不会引用其他项目的代码——只有保存在公共区域的代码。如果项目开始有相互依赖性，退一步评估原因，并判断是否将那些依赖移动到公共位置是有意义的。'
- en: The specific folder structure will likely be dependent on your team's version
    control system and branching strategy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的文件夹结构可能会依赖于你的团队版本控制系统和分支策略。
- en: Dealing with changes
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应对变化
- en: One of the biggest drawbacks to having code that is common to many projects
    is the implications of a change. Directory structure changes can be some of the
    most challenging to deal with, especially if there are a large number of projects.
    Although painful, this type of refactoring is often necessary over time as teams'
    needs and strategies change. Performing regular check-ins and tagging your repository
    should be all that is necessary to provide confidence that directory restructuring
    changes, while painstaking, aren't particularly dangerous.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有众多项目中通用的代码的一个最大的缺点是变化的含义。目录结构的变化可能是最具挑战性的，特别是如果有很多项目。尽管痛苦，但随着团队需求和策略的变化，这种重构通常在一段时间后是必要的。进行定期检查和标记你的仓库应该就足够了，以确保目录重构变化虽然费时，但并不特别危险。
- en: 'If you''re coming from a high-level language and hear the word *interface,*
    you might immediately think of something that is set in stone from the first time
    it is used. Although it is generally good to keep interfaces consistent, there
    is a bit of latitude to change them (especially when first starting out). Internal
    interfaces in this specific use case are considerably more forgiving than a public
    API for a couple of reasons:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自高级语言，并听到“接口”这个词，你可能会立即想到第一次使用时就固定下来的东西。尽管保持接口一致性通常是好的，但有一些灵活性来更改它们（尤其是在刚开始时）。在这个特定用例中，内部接口比公共API更具宽容性，原因有几个：
- en: Nearly all of the low-level MCU-based applications are going to have compile-time
    checks against a given *interface.* There are no dynamically loaded libraries
    that will mysteriously cease to work properly at runtime if an interface changes
    over time—(most) errors will be caught at compile time.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有基于低级MCU的应用都将对给定的 *接口* 进行编译时检查。没有动态加载的库会在接口随时间变化时神秘地停止正常工作——（大多数）错误将在编译时被发现。
- en: These interfaces are generally internal with full visibility of where they are
    used, which makes it possible to evaluate the impact of potential changes.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些接口通常是内部的，具有对其使用位置的完全可见性，这使得评估潜在变化的影响成为可能。
- en: Changes to individual files (such as a shared algorithm) are also a common source
    of concern. The best advice here is to evaluate whether or not what you are changing
    is still providing the same functionality or whether it should be an extension
    or entirely new. Sometimes, working with projects in a vacuum doesn't force us
    to make these decisions explicitly, but as soon as that piece of code is shared
    across many projects, the stakes are higher.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对单个文件（如共享算法）的更改也是常见的关注点。在这里最好的建议是评估你所做的更改是否仍然提供相同的功能，或者它应该是一个扩展或全新的功能。有时，在孤立的项目中工作不会强迫我们明确地做出这些决定，但一旦那块代码被多个项目共享，风险就更高了。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should have a good understanding of why code
    reuse is important and also how to achieve it. We've looked at the details of
    using abstraction in an embedded environment and created fully hardware-agnostic
    interfaces that increase the flexibility of code. We also learned how to use these
    interfaces in conjunction with tasks to increase code reuse across projects. Finally,
    we touched on some aspects of storing shared source code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你应该对代码重用为什么重要以及如何实现它有一个很好的理解。我们探讨了在嵌入式环境中使用抽象的细节，并创建了完全硬件无关的接口，这些接口增加了代码的灵活性。我们还学习了如何结合任务使用这些接口来增加项目间的代码重用。最后，我们简要讨论了存储共享源代码的一些方面。
- en: At this point, you should have enough knowledge to start thinking about how
    to apply these principles to your own code base and projects. As your code base
    starts to have more common code that is reused between projects, you'll begin
    to reap the benefits of a shared code base, such as fewer bugs, more maintainable
    code, and decreased development time. Remember, it takes practice to become good
    at creating reusable code with abstract interfaces. Not all implementations need
    to move to fully reused components at the same time, either—but it is important
    to start the journey.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有足够的知识来开始思考如何将这些原则应用到自己的代码库和项目中。随着你的代码库开始拥有更多在项目间重用的公共代码，你将开始享受到共享代码库的好处，如更少的错误、更易于维护的代码和缩短的开发时间。记住，要擅长创建具有抽象接口的可重用代码需要实践。并不是所有的实现都需要同时迁移到完全可重用的组件，但开始这段旅程是很重要的。
- en: Now that we have some background of abstraction, in the next chapter, we'll
    continue to build flexible architectures by looking more deeply at how queues
    can be used to provide loosely coupled architectures.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对抽象有了背景知识，在下一章中，我们将通过更深入地研究队列如何用于提供松散耦合的架构来继续构建灵活的架构。
- en: Questions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to use to test your knowledge
    on this chapter''s material. You will find the answers in the *Assessments* section
    of the appendix:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结时，这里有一份问题列表，供你用来测试你对本章材料的理解。你将在附录的*评估*部分找到答案：
- en: 'Creating abstractions is only something that can be done using a full desktop
    OS:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建抽象只是一种可以使用完整桌面操作系统来完成的事情：
- en: 'True'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Only object-oriented code such as C++ can benefit from well-defined interfaces:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有面向对象的代码，如C++，才能从定义良好的接口中受益：
- en: 'True'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: Four examples of why abstraction is important were given. Name one.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了四个关于抽象重要性的例子。请说出其中一个。
- en: 'Copying code into a new project is the best way to reuse it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码复制到新项目中是重用代码的最佳方式：
- en: 'True'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Tasks are extremely specific; they cannot be reused between projects:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务非常具体；它们不能在项目之间重用：
- en: 'True'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For an in-depth discussion about multi-layer drivers, see TinyOS TEP101, which
    uses a layered approach to drivers. The interface approach described in this chapter
    fits quite well with the TinyOS HPL, HAL, and HIL approach:[
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解多层驱动程序，请参阅TinyOS TEP101，它使用分层方法来处理驱动程序。本章中描述的接口方法与TinyOS HPL、HAL和HIL方法非常契合：[
- en: https://github.com/tinyos/tinyos-main/blob/master/doc/txt/tep101.txt](https://github.com/tinyos/tinyos-main/blob/master/doc/txt/tep101.txt)
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/tinyos/tinyos-main/blob/master/doc/txt/tep101.txt](https://github.com/tinyos/tinyos-main/blob/master/doc/txt/tep101.txt)'
- en: 'Here are some more additional resources that should help you out:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些额外的资源，应该会对你有所帮助：
- en: '[https://embeddedartistry.com/blog/2019/08/05/practical-decoupling-techniques-applied-to-a-c-based-radio-driver/](https://embeddedartistry.com/blog/2019/08/05/practical-decoupling-techniques-applied-to-a-c-based-radio-driver/)'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://embeddedartistry.com/blog/2019/08/05/practical-decoupling-techniques-applied-to-a-c-based-radio-driver/](https://embeddedartistry.com/blog/2019/08/05/practical-decoupling-techniques-applied-to-a-c-based-radio-driver/)'
- en: '[https://embeddedartistry.com/blog/2020/01/27/leveraging-our-build-systems-to-support-portability/](https://embeddedartistry.com/blog/2020/01/27/leveraging-our-build-systems-to-support-portability/)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用我们的构建系统支持可移植性](https://embeddedartistry.com/blog/2020/01/27/leveraging-our-build-systems-to-support-portability/)'
- en: '[https://embeddedartistry.com/blog/2020/01/20/prototyping-for-portability-lightweight-architectural-strategies/](https://embeddedartistry.com/blog/2020/01/20/prototyping-for-portability-lightweight-architectural-strategies/)'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为可移植性进行原型设计 - 轻量级架构策略](https://embeddedartistry.com/blog/2020/01/20/prototyping-for-portability-lightweight-architectural-strategies/)'
- en: '[https://blog.wingman-sw.com/archives/282 - Unit Testing RTOS dependent code-
    RTOS Test Double](https://blog.wingman-sw.com/archives/282)'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[单元测试RTOS依赖代码 - RTOS测试双倍](https://blog.wingman-sw.com/archives/282)'
