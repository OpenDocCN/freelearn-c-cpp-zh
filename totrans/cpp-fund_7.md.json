["```cpp\n    #include <iostream>\n    ```", "```cpp\n    unsigned i = 1;\n    ```", "```cpp\n    while ( i < 100){ }\n    ```", "```cpp\n    if (i%7 == 0) {\n       std::cout << i << std::endl;\n    }\n    ```", "```cpp\n    i++;\n    ```", "```cpp\n    7\n    14\n    21\n    28\n    ...\n    98\n    ```", "```cpp\n    #include <iostream>\n    ```", "```cpp\n    int main()\n    {\n      int foo[3][3];\n    ```", "```cpp\n    for (int x= 0; x < 3; x++){\n      for (int y = 0; y < 3; y++){\n      }\n    }\n    ```", "```cpp\n    foo[x][y] = x + y;\n    ```", "```cpp\n    for (int x = 0; x < 3; x++){\n       for (int y = 0; y < 3; y++){\n          std::cout << “foo[“ << x << “][“ << y << “]: “ << foo[x][y] << std::endl;\n       }\n    }\n    ```", "```cpp\n    foo[0][0]: 0\n    foo[0][1]: 1\n    foo[0][2]: 2\n    foo[1][0]: 1\n    foo[1][1]: 2\n    foo[1][2]: 3\n    foo[2][0]: 2\n    foo[2][1]: 3\n    foo[2][2]: 4\n    ```", "```cpp\n    #include <iostream>\n    ```", "```cpp\n    void byreference_age_in_5_years(int& age) {\n      if (age >= 18) {\n        std::cout << “Congratulations! You are eligible to vote for your nation.” << std::endl;\n        return;\n    ```", "```cpp\n      } else{\n        int reqAge = 18;\n        int yearsToGo = reqAge-age;\n        std::cout << “No worries, just “<< yearsToGo << “ more years to go.” << std::endl;\n      }\n    }\n    ```", "```cpp\n    int main() {\n        int age;\n        std::cout << “Please enter your age:”;\n        std::cin >> age;\n        byreference_age_in_5_years(age);\n    }\n    ```", "```cpp\n    int sum(int a, int b)\n    {\n      return a + b\n    }\n    ```", "```cpp\n    int& getMaxOf(std::array<int, 10>& array1, std::array<int, 10>& array2, int index) {\n      if (array1[index] >= array2[index]) {\n        return array1[index];\n      } else {\n        return array2[index];\n      }\n    }\n    ```", "```cpp\n    #include <iostream>\n    using namespace std;\n    ```", "```cpp\n    namespace LamborghiniCar\n    {\n      int output(){\n        std::cout << “Congratulations! You deserve the Lamborghini.” << std::endl;\n        return NULL;\n      }\n    }\n    ```", "```cpp\n    namespace PorscheCar\n    {\n      int output(){\n        std::cout << “Congratulations! You deserve the Porsche.” << std::endl; \n        return NULL;\n      }\n    }\n    ```", "```cpp\nint main()\n{\n  int magicNumber;\n  std::cout << “Select a magic number (1 or 2) to win your dream car: “;\n  std::cin >> magicNumber;\n```", "```cpp\n      if (magicNumber == 1){\n        std::cout << LamborghiniCar::output() << std::endl;\n      } else if(magicNumber == 2){\n        std::cout << PorscheCar::output() << std::endl;\n      }else{\n        std::cout << “Please type the correct magic number.” << std::endl;\n      }\n    }\n    ```", "```cpp\n    #include <mathlib.h>\n    #include <array>\n    #include <iostream>\n    ```", "```cpp\n    const float ENEMY_VIEW_RADIUS_METERS = 5;\n    ```", "```cpp\n    int main() {\n        std::array<float, 3> enemy1_location = {2, 2 ,0};\n        std::array<float, 3> enemy2_location = {2, 4 ,0};\n    ```", "```cpp\n        float enemy_distance = johnny::mathlib::distance(enemy1_location, enemy2_location);\n        float distance_from_center = johnny::mathlib::distance(enemy1_location);\n    ```", "```cpp\n        using johnny::mathlib::circumference;\n        float view_circumference_for_enemy = circumference(ENEMY_VIEW_RADIUS_METERS);\n    ```", "```cpp\n        float total_distance = johnny::mathlib::total_walking_distance({\n            enemy1_location,\n            {2, 3, 0}, // y += 1\n            {2, 3, 3}, // z += 3\n            {5, 3, 3}, // x += 3\n            {8, 3, 3}, // x += 3\n            {8, 3, 2}, // z -= 1\n            {2, 3, 2}, // x -= 6\n            {2, 3, 1}, // z -= 1\n            {2, 3, 0}, // z -= 1\n            enemy2_location\n        });\n    ```", "```cpp\n        std::cout << “The two enemies are “ << enemy_distance << “m apart and can see for a circumference of “\n                  << view_circumference_for_enemy << “m. To go to from one to the other they need to walk “\n                  << total_distance << “m.”;\n    }\n    ```", "```cpp\n    class Coordinates {\n      private:\n        float latitude;\n        float longitude;\n    };\n    ```", "```cpp\n    class Coordinates {\n      private:\n        float latitude;\n        float longitude;\n      public:\n        void set_latitude(float value){}\n        void set_longitude(float value){}\n        float get_latitude(){}\n        float get_longitude(){}\n    };\n    ```", "```cpp\n    class Coordinates {\n      private:\n        float latitude;\n        float longitude;\n      public:\n        void set_latitude(float value){ latitude = value; }\n        void set_longitude(float value){ longitude = value; }\n        float get_latitude(){ return latitude; }\n        float get_longitude(){ return longitude; }\n    };\n    ```", "```cpp\n    #include <iostream>\n    int main() {\n      Coordinates washington_dc;\n      std::cout << “Object named washington_dc of type Coordinates created.” << std::endl;\n\n      washington_dc.set_latitude(38.8951);\n      washington_dc.set_longitude(-77.0364);\n      std::cout << “Object’s latitude and longitude set.” << std::endl;\n\n      std::cout << “Washington DC has a latitude of “ \n      << washington_dc.get_latitude() \n      << “ and longitude of “ << washington_dc.get_longitude() << std::endl;\n    }\n    ```", "```cpp\n    class Coordinates {\n      private:\n        float _latitude;\n        float _longitude;\n    };\n    ```", "```cpp\n    class Coordinates {\n      public:\n        Coordinates(float latitude, float longitude) \n        : _latitude(latitude), _longitude(longitude) {}\n      private:\n        int _latitude;\n        int _longitude;\n    };\n    ```", "```cpp\n    #include <iostream>\n    int main() {\n      Coordinates washington_dc(38.8951, -77.0364);\n      std::cout << “Object named washington_dc of type Coordinates created.” \n      << std::endl;\n\n      std::cout << “Washington DC has a latitude of “ \n      << washington_dc.get_latitude() \n      << “ and longitude of “ << washington_dc.get_longitude() \n      << std::endl;\n    }\n    ```", "```cpp\n    class managed_array {\n      public:\n        explicit managed_array(size_t size) {\n          array = new int[size];\n          std::cout << “Array of size “ << size << “ created.” << std::endl;\n        }\n      ~managed_array() {\n        delete[] array;\n        std::cout << “Array deleted.” << std::endl;\n      }\n      private:\n        int *array;\n    };\n    ```", "```cpp\n    int main() {\n        managed_array m(10);\n    }\n    ```", "```cpp\n    Array of size 10 created.\n    Array deleted.\n    ```", "```cpp\n    class Apple\n    {\n      private:\n        Apple() {}\n        // do nothing\n    };\n    ```", "```cpp\n    #include <iostream>\n    class AppleTree\n    {\n      public:\n        Apple createFruit(){\n          Apple apple;\n          std::cout << “apple created!” << std::endl;\n          return apple;\n        }\n    };\n    ```", "```cpp\n    class Apple\n    {\n      friend class AppleTree;\n      private:\n        Apple() {}\n        // do nothing\n    }\n    ```", "```cpp\n    int main() {\n      AppleTree tree;\n      Apple apple = tree.createFruit();\n    }\n    ```", "```cpp\n    apple created!\n    ```", "```cpp\n    class Point\n    {\n      public:\n        bool operator< (const Point &other){\n          return x < other.x || (x == other.x && y < other.y);\n        }\n      int x;\n      int y;\n    };\n    ```", "```cpp\n    #include <iostream>\n    int main() {\n      Point p_1, p_2;\n      p_1.x = 1;\n      p_1.y = 2;\n      p_2.x = 2; \n      p_2.y = 1;\n      std::cout << std::boolalpha << (p_1 < p_2) << std::endl;\n    }\n    ```", "```cpp\n    class AddX {\n      public:\n        AddX(int x) : x(x) {}\n      private:\n        int x;\n    };\n    ```", "```cpp\n    class AddX {\n      public:\n        AddX(int x) : x(x) {}\n        int operator() (int y) { return x + y; }\n      private:\n        int x;\n    };\n    ```", "```cpp\n    int main() {\n      AddX add_five(5);\n      std::cout << add_five(4) << std::endl;\n    }\n    ```", "```cpp\n    9\n    ```", "```cpp\n    #include <iostream>\n    #include <connection.h>\n    #include <useraccount.h>\n    ```", "```cpp\n    template<typename Object, typename Connection>\n    void writeObjectToConnection(Connection& con, const Object& obj) {\n        std::array<char, 100> data = Object::serialize(obj);\n        con.writeNext(data);\n    }\n    ```", "```cpp\n    template<typename Object, typename Connection>\n    Object readObjectFromConnection(Connection& con) {\n        std::array<char, 100> data = con.readNext();\n        return Object::deserialize(data);\n    }\n    ```", "```cpp\n    std::cout << “serialize first user account” << std::endl;\n    UserAccount firstAccount;\n    TcpConnection tcpConnection;\n    writeObjectToConnection(tcpConnection, firstAccount);\n    UserAccount transmittedFirstAccount = readObjectFromConnection<UserAccount>(tcpConnection);\n    ```", "```cpp\n    std::cout << “serialize second user account” << std::endl;\n    UserAccount secondAccount;\n    UdpConnection udpConnection;\n    writeObjectToConnection(udpConnection, secondAccount);\n    UserAccount transmittedSecondAccount = readObjectFromConnection<UserAccount>(udpConnection);\n    ```", "```cpp\n    serialize first user account\n    the user account has been serialized\n    the data has been written\n    the data has been read\n    the user account has been deserialized\n    serialize second user account\n    the user account has been serialized\n    the data has been written\n    the data has been read\n    the user account has been deserialized\n    ```", "```cpp\n    #include <currency.h>\n    #include <iostream>\n    ```", "```cpp\n    template<typename Currency>\n    class Account {\n      public:\n        Account(Currency amount) : balance(amount) {}\n        Currency getBalance() const {\n            return balance;\n        }\n      private:\n        Currency balance;\n    };\n    ```", "```cpp\n    template<typename OtherCurrency>\n    void addToBalance(OtherCurrency amount) {\n        balance.d_value += to<Currency>(amount).d_value;\n    }\n    ```", "```cpp\n    Account<GBP> gbpAccount(GBP(1000));\n    // Add different currencies\n    std::cout << “Balance: “ << gbpAccount.getBalance().d_value << “ (GBP)” << std::endl;\n    gbpAccount.addToBalance(EUR(100));\n    std::cout << “+100 (EUR)” << std::endl;\n    std::cout << “Balance: “ << gbpAccount.getBalance().d_value << “ (GBP)” << std::endl;\n    ```", "```cpp\n    Balance: 1000 (GBP)\n    +100 (EUR)\n    Balance: 1089 (GBP)\n    ```", "```cpp\n    #include <array>\n    template<typename T, int R, int C>\n    class Matrix {\n      // We store row_1, row_2, ..., row_C\n      std::array<T, R*C> data;\n      public:\n        Matrix() : data({}) {}\n        Matrix(std::array<T, R*C> initialValues) : data(initialValues) {}\n    };\n    ```", "```cpp\n    T& get(int row, int col) {\n      if (row >= R || col >= C) {\n        std::abort();\n      }\n      return data[row*C + col];\n    }\n    ```", "```cpp\n    template<typename T, size_t R, size_t C>\n    std::ostream& operator<<(std::ostream& os, Matrix<T, R, C> matrix) {\n        os << ‘\\n’;\n        for(int r=0; r < R; r++) {\n            for(int c=0; c < C; c++) {\n                os << matrix.get(r, c) << ‘ ‘;\n            }\n            os << “\\n”;\n        }\n        return os;\n    }\n    ```", "```cpp\n    Matrix<int, 3, 2> matrix({\n      1, 2,\n      3, 4,\n      5, 6\n    });\n    std::cout << “Initial matrix:” << matrix << std::endl;\n    matrix.get(1, 1) = 7;\n    std::cout << “Modified matrix:” << matrix << std::endl;\n    ```", "```cpp\n    Initial matrix:\n    1 2 \n    3 4 \n    5 6 \n    Modified matrix:\n    1 2 \n    3 7 \n    5 6\n    ```", "```cpp\n    std::array<T, R> multiply(const std::array<T, C>& vector){\n        std::array<T, R> result = {};\n        for(size_t r = 0; r < R; r++) {\n          for(size_t c = 0; c < C; c++) {\n            result[r] += get(r, c) * vector[c];\n          }\n        }\n        return result;\n    }\n    ```", "```cpp\n    std::array<int, 2> vector = {8, 9};\n    std::array<int, 3> result = matrix.multiply(vector);\n    std::cout << “Result of multiplication: [“ << result[0] << “, “\n      << result[1] << “, “ << result[2] << “]” << std::endl;\n    ```", "```cpp\n    Result of multiplication: [26, 87, 94]\n    ```", "```cpp\n    #include <functional>\n    ```", "```cpp\n    template<int R, int C, typename T = int, typename Multiply=std::multiplies<T> >\n    class Matrix {\n      std::array<T, R*C> data;\n      Multiply multiplier;\n      public:\n        Matrix() : data({}), multiplier() {}\n        Matrix(std::array<T, R*C> initialValues) : data(initialValues), multiplier() {}\n    };\n    ```", "```cpp\n    std::array<T, R> multiply(const std::array<T, C>& vector) {\n        std::array<T, R> result = {};\n        for(int r = 0; r < R; r++) {\n            for(int c = 0; c < C; c++) {\n                result[r] += multiplier(get(r, c), vector[c]);\n            }\n        }\n        return result;\n    }\n    ```", "```cpp\n    // Create a matrix of int, with the ‘plus’ operation by default\n    Matrix<3, 2, int, std::plus<int>> matrixAdd({\n        1, 2,\n        3, 4,\n        5, 6\n    });\n    std::array<int, 2> vector = {8, 9};\n    // This will call std::plus when doing the multiplication\n    std::array<int, 3> result = matrixAdd.multiply(vector);\n    std::cout << “Result of multiplication(with +): [“ << result[0] << “, “\n              << result[1] << “, “ << result[2] << “]” << std::endl;\n    ```", "```cpp\n    Result of multiplication(with +): [20, 24, 28]\n    ```", "```cpp\n    template<typename Action, typename Parameter>\n    void execute_on_user_cart(UserIdentifier user, Action action, Parameter&& parameter) {\n        if(isLoggedIn(user)) {\n            Cart cart = getUserCart(user);\n            action(cart, std::forward<Parameter>(parameter));\n        } else {\n            std::cout << “The user is not logged in” << std::endl;\n        }\n    }\n    ```", "```cpp\n    Item toothbrush{1023};\n    Item toothpaste{1024};\n    UserIdentifier loggedInUser{0};\n    std::cout << “Adding items if the user is logged in” << std::endl;\n    execute_on_user_cart(loggedInUser, addItems, std::vector<Item>({toothbrush, toothpaste}));\n    UserIdentifier loggedOutUser{1};\n    std::cout << “Removing item if the user is logged in” << std::endl;\n    execute_on_user_cart(loggedOutUser, removeItem, toothbrush);\n    ```", "```cpp\n    Adding items if the user is logged in\n    Items added\n    Removing item if the user is logged in\n    The user is not logged in\n    ```", "```cpp\n    template<typename Action, typename... Parameters>\n    void execute_on_user_cart(UserIdentifier user, Action action, Parameters&&... parameters) {\n        if(isLoggedIn(user)) {\n            Cart cart = getUserCart(user);\n            action(cart, std::forward<Parameters>(parameters)...);\n        } else {\n            std::cout << “The user is not logged in” << std::endl;\n        }\n    }\n    ```", "```cpp\n    Item toothbrush{1023};\n    Item apples{1024};\n    UserIdentifier loggedInUser{0};\n    std::cout << “Replace items if the user is logged in” << std::endl;\n    execute_on_user_cart(loggedInUser, replaceItem, toothbrush, apples);\n    UserIdentifier loggedOutUser{1};\n    std::cout << “Replace item if the user is logged in” << std::endl;\n    execute_on_user_cart(loggedOutUser, removeItem, toothbrush);\n    ```", "```cpp\n    Replace items if the user is logged in\n    Replacing item\n    Item removed\n    Items added\n    Replace item if the user is logged in\n    The user is not logged in\n    ```", "```cpp\n    #include <array>\n    ```", "```cpp\n    array<int,10> balances;\n    ```", "```cpp\n    for (int i=0; i < balances.size(); ++i) \n    {\n      balances[i] = 0;\n    }\n    ```", "```cpp\n    balances.front() += 100;\n    balances.back() += 100;\n    ```", "```cpp\n    #include <vector>\n    ```", "```cpp\n    std::vector<int> balances;\n    balances.reserve(100);\n    ```", "```cpp\n    for (int i=0; i<100; ++i) \n    {\n      balances.push_back(500);\n    }\n    ```", "```cpp\n    #include <map>\n    #include <string>\n    ```", "```cpp\n    std::map<std::string, int> balances;\n    ```", "```cpp\n    balances.insert(std::make_pair(“Alice”,50));\n    balances.insert(std::make_pair(“Bob”, 50));\n    balances.insert(std::make_pair(“Charlie”, 50));\n    ```", "```cpp\n    auto donaldAccountPos = balances.find(“Donald”);\n    bool hasAccount = (donaldAccountPos !=  balances.end());\n    std::cout << “Donald has an account: “ << hasAccount << std::endl;\n    ```", "```cpp\n    auto alicePosition = balances.find(“Alice”);\n    std::cout << “Alice balance is: “ << alicePosition->second << std::endl;\n    ```", "```cpp\n    #include <stack>\n    ```", "```cpp\n    std::stack<RegistrationForm> registrationForms;\n    ```", "```cpp\n    stack.push(form);\n    std::cout << “Pushed form for user “ << form.userName << std::endl;\n    ```", "```cpp\n    while(not stack.empty()) {\n      processRegistration(stack.top());\n      stack.pop();\n    }\n    ```", "```cpp\n    int main(){\n      std::stack<RegistrationForm> registrationForms;\n      storeRegistrationForm(registrationForms, RegistrationForm{“Alice”});\n      storeRegistrationForm(registrationForms, RegistrationForm{“Bob”});\n      storeRegistrationForm(registrationForms, RegistrationForm{“Charlie”});\n      endOfDayRegistrationProcessing(registrationForms);\n    }\n    ```", "```cpp\n    #include <variant>\n    ```", "```cpp\n    class Airplane {\n      std::variant<AtGate, Taxi, Flying> state;\n      public:\n        Airplane(int gate) : state(AtGate{gate}) {\n          std::cout << “At gate “ << gate << std::endl;\n        }\n    };\n    ```", "```cpp\n    void startTaxi(int lane, int numPassengers) {\n        if (not std::holds_alternative<AtGate>(state)) {\n            std::cout << “Not at gate: the plane cannot start taxi to lane “ << lane << std::endl;\n            return;\n        }\n        std::cout << “Taxing to lane “ << lane << std::endl;\n        state = Taxi{lane, numPassengers};   \n    }\n    ```", "```cpp\n    void takeOff(float speed) {\n        if (not std::holds_alternative<Taxi>(state)) {\n            std::cout << “Not at lane: the plane cannot take off with speed “ << speed << std::endl;\n            return;\n        }\n        std::cout << “Taking off at speed “ << speed << std::endl;\n        state = Flying{speed}; \n    }\n    ```", "```cpp\n    class AirplaneStateVisitor {\n      public:\n        void operator()(const AtGate& atGate) {\n           std::cout << “AtGate: “ << atGate.gate << std::endl;\n        }\n      void operator()(const Taxi& taxi) {\n        std::cout << “Taxi: lane “ << taxi.lane << “ with “ << taxi.numPassengers << “ passengers” << std::endl;\n      }\n      void operator()(const Flying& flying) {\n        std::cout << “Flaying: speed “ << flying.speed << std::endl;\n      }\n    };\n    ```", "```cpp\n    void currentStatus() {\n        AirplaneStateVisitor visitor;\n        std::visit(visitor, state);\n    }\n    ```", "```cpp\n    int main()\n    {\n        Airplane airplane(52);\n        airplane.currentStatus();\n        airplane.startTaxi(12, 250);\n        airplane.currentStatus();\n        airplane.startTaxi(13, 250);\n        airplane.currentStatus();\n        airplane.takeOff(800);\n        airplane.currentStatus();\n        airplane.takeOff(900);\n    }\n    ```", "```cpp\n    class Character {\n      public:\n        void moveTo(Position newPosition) {\n          position = newPosition;\n          std::cout << “Moved to position “ << newPosition.positionIdentifier << std::endl;\n        }\n      private:\n        Position position;\n    };\n    ```", "```cpp\n    struct Position {\n      // Fields to describe the position go here\n      std::string positionIdentifier;\n    };\n    ```", "```cpp\n    // Hero inherits publicly from Character: it has\n    // all the public member of the Character class.\n    class Hero : public Character {\n    };\n    // Enemy inherits publicly from Character, like Hero\n    class Enemy : public Character {\n    };\n    ```", "```cpp\n    class Spell {\n    public:\n        Spell(std::string name) : d_name(name) {}\n        std::string name() const {\n            return d_name;\n        }\n    private:\n        std::string d_name;\n    };\n    ```", "```cpp\n    public:\n        void cast(Spell spell) {\n            // Cast the spell\n            std::cout << “Casting spell “ << spell.name() << std::endl;\n        }\n    ```", "```cpp\n    public:\n        void swingSword() {\n            // Swing the sword\n            std::cout << “Swinging sword” << std::endl;\n        }\n    ```", "```cpp\n    int main()\n    {\n        Position position{“Enemy castle”};\n        Hero hero;\n        Enemy enemy;\n        // We call moveTo on Hero, which calls the method inherited\n        // from the Character class\n        hero.moveTo(position);\n        enemy.moveTo(position);\n        // We can still use the Hero and Enemy methods\n        hero.cast(Spell(“fireball”));\n        enemy.swingSword();\n    }\n    ```", "```cpp\n    class Employee {\n      public:\n        virtual int getBaseSalary() const { return 100; }\n        virtual int getBonus(const Deparment& dep) const {\n          if (dep.hasReachedTarget()) {\n          }\n          return 0;\n        }\n    ```", "```cpp\n        int getTotalComp(const Deparment& dep) {\n\n        }\n    };\n    ```", "```cpp\n    class Manager : public Employee {\n      public:\n        virtual int getBaseSalary() const override { return 150; }\n        virtual int getBonus(const Deparment& dep) const override {\n          if (dep.hasReachedTarget()) {\n            int additionalDeparmentEarnings = dep.effectiveEarning() - dep.espectedEarning();\n            return 0.2 * getBaseSalary() + 0.01 * additionalDeparmentEarnings;\n          }\n          return 0;\n        }\n    };\n    ```", "```cpp\n    class Department {\n      public:\n        bool hasReachedTarget() const {return true;}\n        int espectedEarning() const {return 1000;}\n        int effectiveEarning() const {return 1100;}\n    };\n    ```", "```cpp\n    int main()\n    {\n      Department dep;\n      Employee employee;\n      Manager manager;\n      std::cout << “Employee: “ << employee.getTotalComp(dep) << “. Manager: “ << manager.getTotalComp(dep) << std::endl;\n    }\n    ```", "```cpp\n    struct UserProfile {};\n    struct UserId {};\n    class UserProfileStorage {\n      public:\n        virtual UserProfile getUserProfile(const UserId& id) const = 0;\n\n        virtual ~UserProfileStorage() = default;\n      protected:\n        UserProfileStorage() = default;\n        UserProfileStorage(const UserProfileStorage&) = default;\n        UserProfileStorage& operator=(const UserProfileStorage&) = default;\n    };\n    ```", "```cpp\n    class UserProfileCache : public UserProfileStorage {\n      public:\n        UserProfile getUserProfile(const UserId& id) const override { \n        std::cout << “Getting the user profile from the cache” << std::endl;\n        return UserProfile(); }\n    };\n    void exampleOfUsage(const UserProfileStorage& storage) {\n        UserId user;\n        std::cout << “About to retrieve the user profile from the storage” <<std::endl;\n        UserProfile userProfile = storage.getUserProfile(user);\n    }\n    ```", "```cpp\n    int main()\n    {\n      UserProfileCache cache;\n      exampleOfUsage (cache);\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <memory>\n    #include <userprofile_activity18.h>\n    class UserProfileStorageFactory {\n    public:\n        std::unique_ptr<UserProfileStorage> create() const {\n            return std::make_unique<UserProfileCache>();\n        }\n    }; \n    ```", "```cpp\n    void getUserProfile(const UserProfileStorageFactory& storageFactory) {\n      std::unique_ptr<UserProfileStorage> storage = storageFactory.create();\n      UserId user;\n      storage->getUserProfile(user);\n      // The storage is automatically destroyed\n    }\n    ```", "```cpp\n    int main()\n    {\n      UserProfileStorageFactory factory;\n      getUserProfile(factory);\n    ```", "```cpp\n    #include <future>\n    struct DatabaseConnection {};\n    ```", "```cpp\n    void updateOrderList(DatabaseConnection&) {}\n    void scheduleOrderProcessing(DatabaseConnection&) {}\n    ```", "```cpp\n    /* We need to get a copy of the shared_ptr so it stays alive until this function finishes */\n    void updateWithConnection(std::shared_ptr<DatabaseConnection> connection) {\n        updateOrderList(*connection);\n    }\n    ```", "```cpp\n    /* We need to get a copy of the shared_ptr so it stays alive until this function finishes. */\n    void scheduleWithConnection(std::shared_ptr<DatabaseConnection> connection) {\n        scheduleOrderProcessing(*connection);\n    }\n    ```", "```cpp\n    int main()\n    {\n        std::shared_ptr<DatabaseConnection> connection = std::make_shared<DatabaseConnection>();\n        std::async(std::launch::async, updateWithConnection, connection);\n        std::async(std::launch::async, scheduleWithConnection, connection);\n    }\n    ```"]