["```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nint main()\n{\n    int x = 10;\n    int *p = new int;   // allocate memory for ptr variable\n    *p = 20;            // dereference and assign value \n    int &refInt1 = x;  // reference to an integer\n    int &refInt2 = *p; // also a reference to an integer\n    cout << x << \" \" << *p << \" \";\n    cout << refInt1 << \" \" << refInt2 << endl;\n    x++;      // updates x and refInt1\n    (*p)++;   // updates *p and refInt2\n    cout << x << \" \" << *p << \" \";\n    cout << refInt1 << \" \" << refInt2 << endl;\n    refInt1++;    // updates refInt1 and x\n    refInt2++;    // updates refInt2 and *p\n    cout << x << \" \" << *p << \" \";\n    cout << refInt1 << \" \" << refInt2 << endl;\n    delete p;       // relinquish p's memory\n    return 0;\n}\n```", "```cpp\n10 20 10 20\n11 21 11 21\n12 22 12 22\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nusing std::string;\nclass Student    // very simple class – we will add to it \n{                // in our next chapter\npublic:\n    string name;\n    float gpa;\n};\nint main()\n{\n    Student s1;\n    Student &sRef = s1;  // establish a reference to s1\n    s1.name = \"Katje Katz\";   // fill in the data\n    s1.gpa = 3.75;\n    cout << s1.name << \" has GPA: \" << s1.gpa << endl; \n    cout << sRef.name << \" has GPA: \" << sRef.gpa << endl; \n    sRef.name = \"George Katz\";  // change the data\n    sRef.gpa = 3.25;\n    cout << s1.name << \" has GPA: \" << s1.gpa << endl; \n    cout << sRef.name << \" has GPA: \" << sRef.gpa << endl; \n    return 0;\n}\n```", "```cpp\nKatje Katz has GPA: 3.75\nKatje Katz has GPA: 3.75\nGeorge Katz has GPA: 3.25\nGeorge Katz has GPA: 3.25\n```", "```cpp\nvoid AddOne(int &arg)   // These two fns. are overloaded\n{\n    arg++;\n}\nvoid AddOne(int *arg)   // Overloaded function definition\n{\n    (*arg)++;\n}\nvoid Display(int &arg)  // Function parameter establishes \n                       // a reference to arg\n{\n    cout << arg << \" \" << flush;\n}\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::flush;\nvoid AddOne(int &);    // function prototypes\nvoid AddOne(int *);\nvoid Display(int &);\nint main()\n{\n    int x = 10, *y = nullptr;\n    y = new int;    // allocate y's memory\n    *y = 15;        // dereference y to assign a value\n    Display(x);\n    Display(*y);\n\n    AddOne(x);    // calls ref. version (with an object) \n    AddOne(*y);   // also calls reference version \n    Display(x);   // Based on prototype, we see we are \n    Display(*y);  // passing by ref. Without prototype, \n                  // we may have guessed it was by value.\n    AddOne(&x);   // calls pointer version\n    AddOne(y);    // also calls pointer version\n    Display(x);\n    Display(*y);\n    delete y;     // relinquish y's memory\n    return 0;\n}\n```", "```cpp\n10 15 11 16 12 17\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nint &CreateId();  // function prototype\n\nint main()    \n{\n    int &id1 = CreateId();  // reference established\n    int &id2 = CreateId();\n    cout << \"Id1: \" << id1 << \" Id2: \" << id2 << endl;\n    delete &id1; // Here, '&' is address-of, not reference\n    delete &id2; // to calculate address to pass delete()\n    return 0;  // It is unusual to delete in fashion shown,\n}          // using the addr. of a ref. Also, deleting in \n           // a diff. scope than alloc. can be error prone\nint &CreateId()   // Function returns a reference to an int\n{\n    static int count = 100;  // initialize with first id \n    int *memory = new int;\n    *memory = count++;  // use count as id, then increment\n    return *memory;\n}\n```", "```cpp\nId1: 100 Id2: 101\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nint main()\n{\n   int x = 5;\n   const int &refInt = x;\n   cout << x << \" \" << refInt << endl;\n   // refInt = 6;  // Illegal -- refInt is const \n   x = 7;   // we can inadvertently change refInt\n   cout << x << \" \" << refInt << endl;\n   return 0;\n}\n```", "```cpp\n5 5\n7 7\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\nstruct collection\n{\n    int x;\n    float y;\n};\nvoid Update(collection &);   // function prototypes\nvoid Print(const collection &);\nint main()\n{\n    collection collect1, *collect2 = nullptr;\n    collect2 = new collection;  // allocate mem. from heap\n    Update(collect1);  // a ref to the object is passed\n    Update(*collect2); // same here: *collect2 is an object\n    Print(collect1);  \n    Print(*collect2);\n    delete collect2;   // delete heap memory\n    return 0;\n}\nvoid Update(collection &c)\n{\n    cout << \"Enter <int> and <float> members: \";\n    cin >> c.x >> c.y;\n}\n\nvoid Print(const collection &c)\n{\n    cout << \"x member: \" << c.x;\n    cout << \"   y member: \" << c.y << endl;\n}\n```", "```cpp\nEnter x and y members: 33 23.77\nEnter x and y members: 10 12.11\nx member: 33   y member: 23.77\nx member: 10   y member: 12.11\n```", "```cpp\n#include <iostream>   \nusing std::cout;\nusing std::endl;\nint main()\n{\n    int *ptr = new int;\n    *ptr = 20;\n    int *&refPtr = ptr;  // establish a reference to a ptr\n    cout << *ptr << \" \" << *refPtr << endl; \n    delete ptr;\n    return 0;\n}\n```", "```cpp\n20 20\n```"]