- en: Render Passes and Framebuffers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染通道和帧缓冲区
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Specifying attachment descriptions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定附件描述
- en: Specifying subpass descriptions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定子通道描述
- en: Specifying dependencies between subpasses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定子通道之间的依赖关系
- en: Creating a render pass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建渲染通道
- en: Creating a framebuffer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个帧缓冲区
- en: Preparing a render pass for geometry rendering and postprocess subpasses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备用于几何渲染和后处理子通道的渲染通道
- en: Preparing a render pass and a framebuffer with color and depth attachments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备带有颜色和深度附件的渲染通道和帧缓冲区
- en: Beginning a render pass
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个渲染通道
- en: Progressing to the next subpass
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转进下一个子通道
- en: Ending a render pass
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束渲染通道
- en: Destroying a framebuffer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁帧缓冲区
- en: Destroying a render pass
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁渲染通道
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In Vulkan, drawing commands are organized into render passes. A render pass
    is a collection of subpasses that describes how image resources (color, depth/stencil,
    and input attachments) are used: what their layouts are and how these layouts
    should be transitioned between subpasses, when we render into attachments or when
    we read data from them, if their contents are needed after the render pass, or
    if their usage is limited only to the scope of a render pass.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，绘图命令被组织到渲染通道中。渲染通道是一组子通道的集合，它描述了图像资源（颜色、深度/模板、输入附件）的使用：它们的布局是什么，以及这些布局如何在子通道之间转换，当我们向附件中渲染或从它们读取数据时，如果它们的内
    容在渲染通道后还需要，或者如果它们的用途仅限于渲染通道的范围。
- en: The aforementioned data stored in render passes is just a general description,
    or a metadata. The actual resources involved in the rendering process are specified
    with framebuffers. Through them, we define which image views are used for which
    rendering attachments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染通道中存储的上述数据只是一个一般描述，或者说是元数据。实际参与渲染过程的资源是通过帧缓冲区指定的。通过它们，我们定义了哪些图像视图用于哪些渲染附件。
- en: We need to prepare all this information in advance, before we can issue (record)
    rendering commands. With that knowledge, drivers can greatly optimize the drawing
    process, limit the amount of memory needed for the rendering, or even use a very
    fast cache for some of the attachments, improving the performance even more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在发出（记录）渲染命令之前提前准备所有这些信息。有了这些知识，驱动程序可以大大优化绘图过程，限制渲染所需的内存量，或者甚至为某些附件使用非常快速的缓存，从而进一步提高性能。
- en: In this chapter, we will learn how to organize drawing operations into a set
    of render passes and subpasses, which are required to draw anything with Vulkan.
    We will also learn how to prepare a description of render target attachments used
    during rendering (drawing) and how to create framebuffers, which define actual
    image views that will be used as these attachments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将绘图操作组织成一系列渲染通道和子通道，这是使用 Vulkan 绘制任何内容所必需的。我们还将学习如何准备在渲染（绘图）过程中使用的渲染目标附件的描述以及如何创建帧缓冲区，这些帧缓冲区定义了将用作这些附件的实际图像视图。
- en: Specifying attachments descriptions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定附件描述
- en: A render pass represents a set of resources (images) called attachments, which
    are used during rendering operations. These are divided into color, depth/stencil,
    input, or resolve attachments. Before we can create a render pass, we need to
    describe all the attachments used in it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道代表一组称为附件的资源（图像），这些资源在渲染操作期间使用。这些分为颜色、深度/模板、输入或解析附件。在我们能够创建渲染通道之前，我们需要描述其中使用的所有附件。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a vector with elements of type `VkAttachmentDescription`. Call the vector
    `attachments_descriptions`. For each attachment used in a render pass, add an
    element to the `attachments_descriptions` vector and use the following values
    for its members:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `VkAttachmentDescription` 的向量。将向量命名为 `attachments_descriptions`。对于渲染通道中使用的每个附件，向
    `attachments_descriptions` 向量中添加一个元素，并使用以下值为其成员：
- en: '`0` value for `flags`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 对 `flags` 的值'
- en: The selected format of a given attachment for `format`
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定附件的 `format` 所选格式
- en: The number of per pixel samples for `samples`
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples` 的每像素样本数'
- en: For `loadOp`, specify the type of operation that should be performed on an attachment's
    contents when a render pass is started--a `VK_ATTACHMENT_LOAD_OP_CLEAR` value
    if the attachment contents should be cleared, a `VK_ATTACHMENT_LOAD_OP_LOAD` value
    if its current contents should be preserved or a `VK_ATTACHMENT_LOAD_OP_DONT_CARE`
    value if we intend to overwrite the whole attachment by ourselves and we don't
    care about its current contents (this parameter is used for color attachments
    or for the depth aspect of depth/stencil attachments.)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`loadOp`，指定在渲染过程开始时应在附件内容上执行的操作类型--如果附件内容应该被清除，则使用`VK_ATTACHMENT_LOAD_OP_CLEAR`值；如果其当前内容应该被保留，则使用`VK_ATTACHMENT_LOAD_OP_LOAD`值；如果打算自己覆盖整个附件并且不关心其当前内容，则使用`VK_ATTACHMENT_LOAD_OP_DONT_CARE`值（此参数用于颜色附件或深度/模板附件的深度方面）。
- en: For `storeOp`, specify how an attachment's contents should be treated after
    the render pass--use a `VK_ATTACHMENT_STORE_OP_STORE` value if they should be
    preserved or a `VK_ATTACHMENT_STORE_OP_DONT_CARE` value if we don't need the contents
    after the rendering (this parameter is used for color attachments or for the depth
    aspect of depth/stencil attachments)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`storeOp`，指定在渲染过程结束后如何处理附件的内容--如果应该保留，则使用`VK_ATTACHMENT_STORE_OP_STORE`值；如果渲染后不需要内容，则使用`VK_ATTACHMENT_STORE_OP_DONT_CARE`值（此参数用于颜色附件或深度/模板附件的深度方面）。
- en: Specify how the stencil aspect (component) of an attachment should be treated
    at the beginning of a render pass for `stencilLoadOp` (the same as for the `loadOp`
    member but for a stencil aspect of depth/stencil attachments)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定在渲染过程开始时，附件的模板（组件）应该如何处理，对于`stencilLoadOp`（与`loadOp`成员相同，但用于深度/模板附件的模板方面）
- en: Specify how the stencil aspect (component) of an attachment should be treated
    after a render pass for `stencilStoreOp` (the same as for the `storeOp` but for
    a stencil aspect of depth/stencil attachments)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定在渲染过程结束后，附件的模板（组件）应该如何处理，对于`stencilStoreOp`（与`storeOp`相同，但用于深度/模板附件的模板方面）
- en: Specify what layout image will have when a render pass begins for `initialLayout`
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定渲染过程开始时图像将具有的布局，对于`initialLayout`
- en: Specify the layout to which image should be automatically transitioned to after
    a render pass for `finalLayout`
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定图像在渲染过程结束后应自动过渡到的布局，对于`finalLayout`
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we create a render pass, we have to create an array of attachment descriptions.
    This a general list of all the attachments used in a render pass. Indices into
    this array are then used for the subpass descriptions (refer to the *Specifying
    subpass descriptions* recipe). Similarly, when we create a framebuffer and specify
    exactly what image resource should be used for each attachment, we define a list
    where each element corresponds to the element of the attachment descriptions array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建渲染过程时，我们必须创建一个附件描述数组。这是一个渲染过程中使用的所有附件的通用列表。然后，此数组中的索引用于子过程描述（参考*指定子过程描述*配方）。同样，当我们创建帧缓冲区并指定每个附件应使用的确切图像资源时，我们定义了一个列表，其中每个元素对应于附件描述数组中的元素。
- en: 'Usually, when we draw a geometry, we render it into at least one color attachment.
    Probably, we also want a depth test to be enabled, so we need a depth attachment
    too. Attachment descriptions for such a common scenario are presented here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们绘制几何体时，我们至少将其渲染到一个颜色附件中。可能我们还想启用深度测试，因此还需要一个深度附件。此类常见场景的附件描述如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we specify two attachments: one with a `R8G8B8A8_UNORM`
    and the other with a `D16_UNORM` format. Both attachments should be cleared at
    the beginning of a render pass (similarly to calling the OpenGL''s `glClear()`
    function at the beginning of a frame). We also want to keep the contents of the
    first attachment, when the render pass is finished, but we don''t need the contents
    of the second attachment. For both, we also specify an `UNDEFINED` initial layout.
    An `UNDEFINED` layout can always be used for an initial/old layout--it means that
    we don''t need images content when a memory barrier is set up.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们指定了两个附件：一个使用`R8G8B8A8_UNORM`格式，另一个使用`D16_UNORM`格式。在渲染过程的开始时，这两个附件都应该被清除（类似于在帧开始时调用OpenGL的`glClear()`函数）。我们还想在渲染过程完成后保留第一个附件的内容，但不需要第二个附件的内容。对于两者，我们也指定了一个`UNDEFINED`初始布局。`UNDEFINED`布局始终可以用于初始/旧布局--这意味着当设置内存屏障时，我们不需要图像内容。
- en: The value for the final layout depends on how we intend to use an image after
    the render pass. If we are rendering directly into a swapchain image and we want
    to display it on screen, we should use a `PRESENT_SRC` layout (as shown previously).
    For a depth attachment, if we don't intend to use a depth component after the
    render pass (which usually is true), we should set the same layout value as specified
    in the last subpass of a render pass.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终布局的值取决于我们打算在渲染通道之后如何使用图像。如果我们直接将渲染到交换链图像，并且希望在屏幕上显示它，我们应该使用`PRESENT_SRC`布局（如之前所示）。对于深度附件，如果我们不打算在渲染通道之后使用深度组件（这通常是真的），我们应该设置与渲染通道的最后一个子通道中指定的相同布局值。
- en: It's also possible that a render pass does not use any attachments. In such
    a case, we don't need to specify attachment descriptions, but such a situation
    is rare.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能渲染通道不使用任何附件。在这种情况下，我们不需要指定附件描述，但这种情况很少见。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying subpass descriptions*'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a render pass*'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: '*Preparing a render pass and a framebuffer with color and depth attachments*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备渲染通道和具有颜色和深度附件的帧缓冲区*'
- en: Specifying subpass descriptions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定子通道描述
- en: Operations performed in a render pass are grouped into subpasses. Each subpass
    represents a stage or a phase of our rendering commands in which a subset of render
    pass's attachments are used (into which we render or from which we read data).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染通道中执行的操作被分组到子通道中。每个子通道代表我们渲染命令的一个阶段或一个阶段，其中使用渲染通道附件的一个子集（我们将数据渲染到其中或从中读取数据）。
- en: A render pass always requires at least one subpass that is automatically started
    when we begin a render pass. And for each subpass, we need to prepare a description.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道始终需要至少一个子通道，当开始一个渲染通道时，它会自动启动。对于每个子通道，我们需要准备一个描述。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To lower the number of parameters required to prepare for each subpass, a custom
    structure type is introduced for this recipe. It is a simplified version of a
    `VkSubpassDescription` structure defined in the Vulkan header. It has the following
    definition:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降低为每个子通道准备所需的参数数量，为此配方引入了一个自定义结构类型。它是Vulkan头文件中定义的`VkSubpassDescription`结构的一个简化版本。它具有以下定义：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `PipelineType` member defines a type of a pipeline (graphics or compute,
    though only graphics pipelines are supported inside render passes at this point)
    that will be used during the subpass. `InputAttachments` is a collection of attachments
    from which we will read data during the subpass. `ColorAttachments` specifies
    all attachments that will be used as color attachments (into which we will render
    during the subpass). `ResolveAttachments` specifies which color attachments should
    be resolved (changed from a multisampled image to a non-multisampled/single sampled
    image) at the end of the subpass. `DepthStencilAttachment`, if used, specifies
    which attachment is used as a depth and/or stencil attachment during the subpass.
    `PreserveAttachments` is a set of attachments that are not used in the subpass
    but whose contents must be preserved during the whole subpass.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`PipelineType`成员定义了在子通道期间将使用的管道类型（图形或计算，尽管目前渲染通道内部仅支持图形管道）。`InputAttachments`是我们将在子通道期间读取数据的附件集合。`ColorAttachments`指定所有将用作颜色附件的附件（我们将在此期间将其渲染）。`ResolveAttachments`指定在子通道结束时应该解析哪些颜色附件（从多采样图像更改为非多采样/单采样图像）。如果使用`DepthStencilAttachment`，则指定在子通道期间用作深度和/或模板附件的附件。`PreserveAttachments`是一组在子通道中未使用但必须在整个子通道期间保留内容的附件。'
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a vector variable of type `std::vector<VkSubpassDescription>` named
    `subpass_descriptions`. For each subpass defined in a render pass, add an element
    to the `subpass_descriptions` vector and use the following values for its members:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`subpass_descriptions`的`std::vector<VkSubpassDescription>`类型的向量变量。对于在渲染通道中定义的每个子通道，向`subpass_descriptions`向量添加一个元素，并使用以下值为其成员：
- en: '`0` value for `flags`'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的`0`值'
- en: '`VK_PIPELINE_BIND_POINT_GRAPHICS` value for `pipelineBindPoint` (currently
    only graphics pipelines are supported inside render passes)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipelineBindPoint`的`VK_PIPELINE_BIND_POINT_GRAPHICS`值（目前渲染通道内部仅支持图形管道）'
- en: The number of input attachments used in the subpass for `inputAttachmentCount`
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子通道中使用的输入附件数量为`inputAttachmentCount`
- en: 'A pointer to the first element of an array with parameters of input attachments
    (or a `nullptr` value if no input attachments are used in the subpass) for `pInputAttachments`;
    use the following values for each member of the `pInputAttachments` array:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向具有输入附件参数的数组中第一个元素的指针（如果子通行中没有使用输入附件，则为`nullptr`值）用于`pInputAttachments`；对于`pInputAttachments`数组的每个成员，使用以下值：
- en: Index of the attachment in the list of all render pass attachments for `attachment`
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附件在所有渲染通行附件列表中的索引`attachment`。
- en: A layout given image should be automatically transitioned to at the beginning
    of the subpass for `layout`
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在子通行开始时自动将给定的图像布局转换为`layout`。
- en: The number of color attachments used in the subpass for `colorAttachmentCount`
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子通行中使用的颜色附件数量`colorAttachmentCount`。
- en: A pointer to the first element of the array with parameters of the subpass's
    color attachments (or a `nullptr` value if no color attachments are used in the
    subpass) for `pColorAttachments`; for each member of the array, specify values
    as described in points 4a and 4b.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向具有子通行颜色附件参数的数组中第一个元素的指针（如果子通行中没有使用颜色附件，则为`nullptr`值）用于`pColorAttachments`；对于数组的每个成员，指定如第4a点和第4b点所述的值。
- en: If any of the color attachments should be resolved (changed from multisampled
    to single-sampled) for `pResolveAttachments,` specify a pointer to the first element
    of the array with same number of elements as `pColorAttachments` or use a `nullptr`
    value if no color attachments need to be resolved; each member of the `pResolveAttachments`
    array corresponds to the color attachment at the same index and specifies to which
    attachment a given color attachment should be resolved at the end of the subpass;
    for each member of the array use specified values as described in points 4a and
    4b; use a `VK_ATTACHMENT_UNUSED` value for the attachment index if the given color
    attachment should not be resolved.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何颜色附件应该被解析（从多采样变为单采样）对于`pResolveAttachments`，指定与`pColorAttachments`具有相同元素数量的数组中第一个元素的指针，或者如果不需要解析任何颜色附件，则使用`nullptr`值；`pResolveAttachments`数组的每个成员对应于相同索引的颜色附件，并指定在子通行结束时给定颜色附件应解析到的附件；对于数组的每个成员，使用如第4a点和第4b点所述的指定值；如果给定的颜色附件不应解析，则使用`VK_ATTACHMENT_UNUSED`值作为附件索引。
- en: For `pDepthStencilAttachment` provide a pointer to the variable of type `VkAttachmentReference`
    if a depth/stencil attachment is used (or a `nullptr` value if no depth/stencil
    attachment is used in the subpass); for members of this variable, specify values
    as described in points 4a and 4b
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`pDepthStencilAttachment`，如果使用了深度/模板附件，则提供一个指向类型为`VkAttachmentReference`的变量的指针（如果子通行中没有使用深度/模板附件，则为`nullptr`值）；对于此变量的成员，指定如第4a点和第4b点所述的值。
- en: The number of attachments that are not used but whose contents should be preserved
    for `preserveAttachmentCount`.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应保留内容的未使用附件数量`preserveAttachmentCount`。
- en: A pointer to the first element of an array with indices of attachments whose
    contents should be preserved in the subpass (or a `nullptr` value if there are
    no attachments to be preserved) for `pPreserveAttachments`.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向数组中第一个元素的指针，该数组包含应保留内容的附件索引（如果没有附件需要保留，则为`nullptr`值）用于`pPreserveAttachments`。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Vulkan render passes must have at least one subpass. Subpass parameters are
    defined in an array of `VkSubpassDescription` elements. Each such element describes
    how attachments are used in a corresponding subpass. There are separate lists
    of input, color, resolve, and preserved attachments and a single entry for depth/stencil
    attachments. Each of these members may be empty (or null). In this case, attachments
    of a corresponding type are not used in a subpass.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan渲染通行必须至少有一个子通行。子通行参数定义在一个`VkSubpassDescription`元素数组中。每个这样的元素描述了在相应的子通行中如何使用附件。有单独的输入、颜色、解析和保留附件列表，以及深度/模板附件的单个条目。这些成员可能为空（或null）。在这种情况下，对应类型的附件在子通行中不被使用。
- en: Each entry in one of the lists just described is a reference to the list of
    all attachments specified for a render pass in attachment descriptions (refer
    to the *Specifying attachments descriptions* recipe). Additionally, each entry
    specifies a layout in which an image should be during a subpass. Transitions to
    specified layouts are performed automatically by the driver.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的列表中的每个条目都是对在附件描述中为渲染通行指定的所有附件列表的引用（参见图*指定附件描述*）。此外，每个条目指定了一个图像在子通行期间应处于的布局。到指定布局的转换由驱动程序自动执行。
- en: 'Here is a code sample that uses a custom structure of a `SubpassParameters`
    type to specify a subpass definition:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用自定义的`SubpassParameters`类型结构的代码示例，用于指定子通道定义：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And here is a code sample defining one subpass that corresponds to an example
    with one color attachment: a depth/stencil attachment:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个定义一个与具有一个颜色附加项的示例相对应的子通道的代码示例：一个深度/模板附加项：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First we specify a `depth_stencil_attachment` variable for a description of
    a depth/stencil attachment. For a depth data, the second attachment from the list
    of attachment descriptions is used; that's why we specify a value of `1` for its
    index (refer to the *Specifying attachment descriptions* recipe). And as we want
    to render into this attachment, we provide a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`
    value for its layout (the driver will automatically perform a transition, if needed).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为描述深度/模板附加的`depth_stencil_attachment`变量指定一个值。对于深度数据，使用附加描述列表中的第二个附加项；这就是为什么我们为其索引指定了`1`的值（参考*指定附加描述*配方）。并且因为我们想渲染到这个附加项，所以我们为其布局提供了`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`的值（驱动程序将自动执行转换，如果需要的话）。
- en: In the example, we use just one color attachment. It is the first attachment
    from the list of attachment descriptions, so we use a `0` value for its index.
    When we render into a color attachment, we should specify a `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
    value for its layout.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们只使用一个颜色附加项。它是附加描述列表中的第一个附加项，因此我们为其索引使用`0`的值。当我们渲染到颜色附加项时，我们应该为其布局指定`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`的值。
- en: One last thing--as we want to render a geometry, we need to use a graphics pipeline.
    This is done through a `VK_PIPELINE_BIND_POINT_GRAPHICS` value provided for a
    `PipelineType` member.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点——因为我们想渲染几何图形，我们需要使用图形管道。这是通过为`PipelineType`成员提供一个`VK_PIPELINE_BIND_POINT_GRAPHICS`值来完成的。
- en: As we don't use input attachments and we don't want to resolve any color attachments,
    their corresponding vectors are empty.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用输入附加项，并且我们不希望解析任何颜色附加项，因此它们对应的向量是空的。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying attachment descriptions*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附加描述*'
- en: '*Creating a render pass*'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: '*Preparing a render pass for geometry rendering and postprocess subpasses*'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备用于几何渲染和后处理子通道的渲染通道*'
- en: '*Preparing a render pass and a framebuffer with color and depth attachments*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备带有颜色和深度附加的渲染通道和帧缓冲区*'
- en: Specifying dependencies between subpasses
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定子通道之间的依赖关系
- en: When operations in a given subpass depend on the results of operations in one
    of the earlier subpasses in the same render pass, we need to specify subpass dependencies.
    This is also required if there are dependencies between operations recorded within
    a render pass and those performed before it, or between operations that are executed
    after a render pass and those performed within the render pass. It is also possible
    to define dependencies within a single subpass.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定子通道中的操作依赖于同一渲染通道中较早子通道中的操作的结果时，我们需要指定子通道依赖。如果记录在渲染通道内的操作与之前执行的操作之间或执行在渲染通道之后的操作与在渲染通道内执行的操作之间存在依赖关系，这也需要。也可以在单个子通道内定义依赖关系。
- en: Defining subpass dependencies is similar to setting up memory barriers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义子通道依赖类似于设置内存屏障。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a variable of type `std::vector<VkSubpassDependency>` named `subpass_dependencies`.
    For each dependency, add a new element to the `subpass_dependencies` vector and
    use the following values for its members:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`subpass_dependencies`的`std::vector<VkSubpassDependency>`类型的变量。对于每个依赖项，向`subpass_dependencies`向量添加一个新元素，并为其成员使用以下值：
- en: The index of a subpass from which ("producing") operations should be finished
    before the second set of ("consuming") operations (or a `VK_SUBPASS_EXTERNAL`
    value for commands before the render pass) for `srcSubpass`
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`srcSubpass`，在第二组（“消耗”）操作之前（或对于渲染通道之前的`VK_SUBPASS_EXTERNAL`值）应该完成（“产生”）操作的子通道的索引
- en: The index of a subpass whose operations depend on the previous set of commands
    (or a `VK_SUBPASS_EXTERNAL` value for operations after the render pass) for `dstSubpass`
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`dstSubpass`，依赖于之前命令集（或渲染通道之后的`VK_SUBPASS_EXTERNAL`值）的操作的子通道的索引
- en: The set of pipeline stages which produce the result read by the "consuming"
    commands for `srcStageMask`
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成由`srcStageMask`的“消耗”命令读取结果的管道阶段集合
- en: The set of pipeline stages which depend on the data generated by the "producing"
    commands for `dstStageMask`
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于`dstStageMask`的“生产”命令生成的数据的管道阶段集合
- en: The types of memory operations that occurred for the "producing" commands for
    `srcAccessMask`
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`srcAccessMask`的“生产”命令发生的记忆操作类型
- en: The types of memory operations that will be performed in "consuming" commands
    for `dstAccessMask`
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`dstAccessMask`的“消费”命令中将要执行的记忆操作类型
- en: For `dependencyFlags`, use a `VK_DEPENDENCY_BY_REGION_BIT` value if the dependency
    is defined by region--it means that operations generating data for a given memory
    region must finish before operations reading data from the same region can be
    executed; if this flag is not specified, dependency is global, which means that
    data for the whole image must be generated before "consuming" commands can be
    executed.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`dependencyFlags`，如果依赖关系由区域定义，则使用`VK_DEPENDENCY_BY_REGION_BIT`值——这意味着为给定内存区域生成数据的操作必须在从同一区域读取数据的操作可以执行之前完成；如果没有指定此标志，则依赖关系是全局的，这意味着必须先生成整个图像的数据，然后才能执行“消费”命令。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Specifying dependencies between subpasses (or between subpasses and commands
    before or after a render pass) is very similar to setting an image memory barrier
    and serves a similar purpose. We do this when we want to specify that commands
    from one subpass (or commands after the render pass) depend on results of operations
    performed in another subpass (or on commands executed before the render pass).
    We don't need to set up dependencies for the layout transitions--these are performed
    automatically based on the information provided for the render pass attachment
    and subpass descriptions. What's more, when we specify different attachment layouts
    for different subpasses, but in both subpasses the given attachment is used only
    for reading, we also don't need to specify a dependency.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 指定子阶段之间的依赖关系（或子阶段与渲染通道之前或之后的命令之间的依赖关系）与设置图像内存屏障非常相似，并且具有类似的目的。我们在想要指定一个子阶段的命令（或渲染通道之后的命令）依赖于另一个子阶段（或渲染通道之前执行的命令）的操作结果时这样做。我们不需要设置布局转换的依赖关系——这些是基于渲染通道附件和子阶段描述提供的信息自动执行的。更重要的是，当我们为不同的子阶段指定不同的附件布局，但在两个子阶段中，给定的附件都仅用于读取时，我们也不需要指定依赖关系。
- en: Subpass dependencies are also required when we want to set up image memory barriers
    inside a render pass. Without specifying a so-called "self-dependency" (the source
    and destination subpass have the same index), we can't do that. However, if we
    define such a dependency for a given subpass, we can record a memory barrier in
    it. In other situations, the source subpass index must be lower than the target
    subpass index (excluding a `VK_SUBPASS_EXTERNAL` value).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在渲染通道内设置图像内存屏障时，也需要子阶段依赖关系。如果没有指定所谓的“自依赖关系”（源子阶段和目标子阶段的索引相同），我们无法做到这一点。然而，如果我们为给定的子阶段定义了这样的依赖关系，我们可以在其中记录一个内存屏障。在其他情况下，源子阶段索引必须低于目标子阶段索引（不包括`VK_SUBPASS_EXTERNAL`值）。
- en: 'There follows an example in which we prepare a dependency between two subpasses--the
    first draws geometry into color and depth attachments, and the second uses color
    data for postprocessing (it reads from the color attachment):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，其中我们准备两个子阶段之间的依赖关系——第一个将几何体绘制到颜色和深度附件中，第二个使用颜色数据进行后处理（它从颜色附件中读取）：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The aforementioned dependency is set between the first and second subpasses
    (indices with values of 0 and 1). Writes to the color attachment are performed
    in the `COLOR_ATTACHMENT_OUTPUT` stage. Postprocessing is done in a fragment shader
    and this stage is defined as a "consuming" stage. When we draw a geometry, we
    perform writes to a color attachment (access mask with value of `COLOR_ATTACHMENT_WRITE`).
    Then the color attachment is used as an input attachment and in the postprocess
    subpass we read from it (so we use an access mask with a value of `INPUT_ATTACHMENT_READ`).
    As we don't need to read data from other parts of an image, we can specify dependency
    by-region (a fragment stores a color value at given coordinates in the first subpass
    and the same value is read in the next subpass by a fragment with the same coordinates).
    When we do this, we should not assume that regions are larger than the single
    pixel, because the size of a region may be different on various hardware platforms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述依赖关系设置在第一个和第二个子通道之间（索引值为 0 和 1）。对颜色附件的写入操作在 `COLOR_ATTACHMENT_OUTPUT` 阶段执行。后处理在片段着色器中完成，此阶段被定义为“消耗”阶段。当我们绘制几何体时，我们对颜色附件执行写入操作（访问掩码的值为
    `COLOR_ATTACHMENT_WRITE`）。然后颜色附件被用作输入附件，在后处理子通道中我们从它读取（因此我们使用一个值为 `INPUT_ATTACHMENT_READ`
    的访问掩码）。由于我们不需要从图像的其他部分读取数据，我们可以通过区域指定依赖关系（一个片段在第一个子通道中存储给定坐标的颜色值，下一个子通道中具有相同坐标的片段读取相同的值）。当我们这样做时，我们不应假设区域大于单个像素，因为区域的大小可能在不同的硬件平台上不同。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中以下配方：
- en: '*Specifying attachment descriptions*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Specifying subpass descriptions*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a render pass*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Preparing a render pass for geometry rendering and postprocess subpasses*'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备几何体渲染和后处理子通道的渲染通道*'
- en: Creating a render pass
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建渲染通道
- en: Rendering (drawing a geometry) can only be performed inside render passes. When
    we also want to perform other operations such as image postprocessing or preparing
    geometry and light prepass data, we need to order these operations into subpasses.
    For this, we specify descriptions of all the required attachments, all subpasses
    into which operations are grouped, and the necessary dependencies between those
    operations. When this data is prepared, we can create a render pass.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染（绘制几何体）只能在渲染通道内执行。当我们还想要执行其他操作，例如图像后处理或准备几何体和光照预通道数据时，我们需要将这些操作排序到子通道中。为此，我们指定所有必需的附件描述、所有将操作分组到其中的子通道，以及这些操作之间必要的依赖关系。当这些数据准备就绪后，我们可以创建一个渲染通道。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To lower the number of parameters that need to be provided, in this recipe,
    we use a custom structure of type `SubpassParameters` (refer to the *Specifying
    subpass descriptions* recipe).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少需要提供的参数数量，在本配方中，我们使用一个自定义的 `SubpassParameters` 类型结构（参考 *指定子通道描述* 配方）。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a variable of type `std::vector<VkAttachmentDescription>` named `attachments_descriptions,`
    in which we specify descriptions of all render pass attachments (refer to the
    *Specifying attachment descriptions* recipe).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `attachments_descriptions` 的 `std::vector<VkAttachmentDescription>` 类型的变量，在其中指定所有渲染通道附件的描述（参考
    *指定附件描述* 配方）。
- en: Prepare a variable of type `std::vector<VkSubpassDescription>` named `subpass_descriptions`
    and use it to define descriptions of subpasses (refer to the *Specifying subpass
    descriptions* recipe).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `subpass_descriptions` 的 `std::vector<VkSubpassDescription>` 类型的变量，并使用它来定义子通道的描述（参考
    *指定子通道描述* 配方）。
- en: Create a variable of type `std::vector<VkSubpassDependency>` named `subpass_dependencies`.
    Add a new member to this vector for each dependency that needs to be defined in
    the render pass (refer to the *Specifying dependencies between subpasses* recipe).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `subpass_dependencies` 的 `std::vector<VkSubpassDependency>` 类型的变量。为渲染通道中需要定义的每个依赖关系向此向量添加一个新成员（参考
    *指定子通道之间的依赖关系* 配方）。
- en: 'Create a variable of type `VkRenderPassCreateInfo` named `render_pass_create_info`
    and initialize its member with the following values:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `render_pass_create_info` 的 `VkRenderPassCreateInfo` 类型的变量，并使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO` value for `sType`'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType` 的值为 `VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO`'
- en: '`nullptr` value for `pNext`'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: '`0` value for `flags`'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的值为 `0`'
- en: The number of elements in the `attachments_descriptions` vector for `attachmentCount`
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachments_descriptions` 向量中 `attachmentCount` 元素的个数'
- en: A pointer to the first element of the `attachments_descriptions` vector (or
    a `nullptr` value if it is empty) for `pAttachments`
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachments_descriptions` 向量第一个元素的指针（如果为空，则为 `nullptr`）用于 `pAttachments`'
- en: The number of elements in the `subpass_descriptions` vector for `subpassCount`
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subpass_descriptions` 向量中 `subpassCount` 的元素数量'
- en: A pointer to the first element of the `subpass_descriptions` vector for `pSubpasses`
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subpass_descriptions` 向量第一个元素的指针用于 `pSubpasses`'
- en: The number of elements in the `subpass_dependencies` vector for `dependencyCount`
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subpass_dependencies` 向量中 `dependencyCount` 的元素数量'
- en: A pointer to the first element of the `subpass_dependencies` vector (or a `nullptr`
    value if it is empty) for `pDependencies`
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subpass_dependencies` 向量第一个元素的指针（如果为空，则为 `nullptr`）用于 `pDependencies`'
- en: Take the handle of a logical device for which the render pass should be created.
    Store it in a variable of type `VkDevice` named `logical_device`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应创建渲染通道的逻辑设备的句柄。将其存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Create a variable of type `VkRenderPass` named `render_pass` in which the handle
    of the created render pass will be stored.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `render_pass` 的 `VkRenderPass` 类型变量中创建一个变量，其中将存储创建的渲染通道的句柄。
- en: Call `vkCreateRenderPass( logical_device, &render_pass_create_info, nullptr,
    &render_pass )`. For the call, provide the `logical_device` variable, a pointer
    to the `render_pass_create_info` variable, a `nullptr` value, and a pointer to
    the `render_pass` variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateRenderPass(logical_device, &render_pass_create_info, nullptr, &render_pass)`。对于调用，提供
    `logical_device` 变量、`render_pass_create_info` 变量的指针、一个 `nullptr` 值以及 `render_pass`
    变量的指针。
- en: Make sure the call was successful by checking if it returned a `VK_SUCCESS`
    value.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查是否返回了 `VK_SUCCESS` 值来确保调用成功。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A render pass defines general information about how attachments are used by
    operations performed in all its subpasses. This allows the driver to optimize
    work and improve the performance of our application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道定义了所有子通道中操作使用附件的通用信息。这允许驱动程序优化工作并提高我们应用程序的性能。
- en: '![](img/image_06_001.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_001.png)'
- en: 'The most important parts of a render pass creation is a preparation of data--descriptions
    of all the used attachments and subpasses and a specification of dependencies
    between subpasses (refer to the *Specifying attachment descriptions*, *Specifying
    subpass descriptions,* and *Specifying dependencies between subpasses* recipes
    in this chapter). These steps can be presented in short as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道创建最重要的部分是数据准备——所有使用附件和子通道的描述以及子通道之间依赖关系的指定（参考本章中的 *指定附件描述*、*指定子通道描述* 和 *指定子通道之间的依赖关系*
    章节中的食谱）。以下步骤可以简要表示如下：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This data is then used when we specify parameter for a function creating a
    render pass:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当指定创建渲染通道函数的参数时使用这些数据：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But for the drawing operations to be performed correctly, the render pass is
    not enough as it only specifies how operations are ordered into subpasses and
    how attachments are used. There is no information about what images are used for
    these attachments. Such information about specific resources used for all defined
    attachments is stored in framebuffers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了正确执行绘图操作，渲染通道是不够的，因为它只指定了操作如何按顺序进入子通道以及如何使用附件。没有关于用于这些附件的图像的信息。关于所有定义的附件使用的特定资源的信息存储在帧缓冲区中。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying attachment descriptions*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Specifying subpass descriptions*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Specifying dependencies between subpasses*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道之间的依赖关系*'
- en: '*Creating a framebuffer*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: '*Beginning a render pass*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: '*Progressing to the next subpass*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推进到下一个子通道*'
- en: '*Ending a render pass*'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束渲染通道*'
- en: '*Destroying a render pass*'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁渲染通道*'
- en: Creating a framebuffer
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帧缓冲区
- en: Framebuffers are used along with render passes. They specify what image resources
    should be used for corresponding attachments defined in a render pass. They also
    define the size of a renderable area. That's why when we want to record drawing
    operations, we not only need to create a render pass, but also a framebuffer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区与渲染通道一起使用。它们指定了在渲染通道中定义的相应附件应使用哪些图像资源。它们还定义了可渲染区域的大小。这就是为什么当我们想要记录绘图操作时，我们不仅需要创建渲染通道，还需要创建帧缓冲区。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a render pass that should be compatible with the framebuffer
    and use it to initialize a variable of type `VkRenderPass` named `render_pass`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应与帧缓冲区兼容的渲染通道句柄，并使用它初始化一个名为 `render_pass` 的 `VkRenderPass` 类型变量。
- en: Prepare a list of image view handles that represent the images' subresources,
    which should be used for the render pass attachments. Store all the prepared image
    views in a variable of type `std::vector<VkImageView>` named `attachments`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个表示图像子资源的图像视图句柄列表，这些子资源应用于渲染通道附件。将所有准备好的图像视图存储在名为 `attachments` 的 `std::vector<VkImageView>`
    类型变量中。
- en: 'Create a variable of type `VkFramebufferCreateInfo` named `framebuffer_create_info`.
    Use the following values to initialize its members:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `framebuffer_create_info` 的 `VkFramebufferCreateInfo` 类型变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO` value for `sType`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: '`0` value for `flags`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 值用于 `flags`'
- en: '`render_pass` variable for `renderPass`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_pass` 变量用于 `renderPass`'
- en: The number of elements in the `attachments` vector for `attachmentCount`
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachments` 向量中的元素数量用于 `attachmentCount`'
- en: A pointer to the first element of the `attachments` vector (or a `nullptr` value
    if it is empty) for `pAttachments`
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `attachments` 向量第一个元素的指针（如果为空，则为 `nullptr` 值）用于 `pAttachments`
- en: The selected width of a renderable area for `width`
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `width` 选择可渲染区域的宽度
- en: The selected framebuffer's height for `height`
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择帧缓冲区的高度用于 `height`
- en: The number of framebuffer layers for `layers`
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layers` 的帧缓冲区层数'
- en: Take the handle of a logical device for which the framebuffer should be created
    and store in a variable of type `VkDevice` named `logical_device`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用于创建并存储在名为 `logical_device` 的 `VkDevice` 类型变量中的帧缓冲区句柄。
- en: Create a variable of type `VkFramebuffer` named `framebuffer` that will be initialized
    with a handle of a created framebuffer.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `framebuffer` 的 `VkFramebuffer` 类型变量，它将使用创建的帧缓冲区的句柄进行初始化。
- en: Call `vkCreateFramebuffer( logical_device, &framebuffer_create_info, nullptr,
    &framebuffer )` for which we provide the `logical_device` variable, a pointer
    to the `framebuffer_create_info` variable, a `nullptr` value, and a pointer to
    the `framebuffer` variable.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateFramebuffer( logical_device, &framebuffer_create_info, nullptr,
    &framebuffer )`，我们提供 `logical_device` 变量、`framebuffer_create_info` 变量的指针、一个 `nullptr`
    值和一个指向 `framebuffer` 变量的指针。
- en: Make sure the framebuffer was properly created by checking if the call returned
    a `VK_SUCCESS` value.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保帧缓冲区已正确创建，通过检查调用是否返回了 `VK_SUCCESS` 值。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Framebuffers are always created in conjunction with render passes. They define
    specific image subresources that should be used for attachments specified in render
    passes, so both of these object types should correspond to each other.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区总是与渲染通道一起创建。它们定义了应用于渲染通道中指定附件的特定图像子资源，因此这两个对象类型应相互对应。
- en: '![](img/image_06_002.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_002.png)'
- en: When we create a framebuffer, we provide a render pass object with which we
    can use the given framebuffer. However, we are not limited to using it only with
    the specified render pass. We can use the framebuffer also with all render passes
    that are compatible with the one provided.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建帧缓冲区时，我们提供一个渲染通道对象，我们可以使用该对象使用给定的帧缓冲区。然而，我们不仅限于仅与指定的渲染通道一起使用它。我们还可以使用与提供的渲染通道兼容的所有渲染通道。
- en: What are compatible render passes? First, they must have the same number of
    subpasses. And each subpass must have a compatible set of input, color, resolve,
    and depth/stencil attachments. This means that formats and the number of samples
    of corresponding attachments must be the same. However, it is possible for the
    attachments to have different initial, subpasses and final layouts and different
    load and store operations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容的渲染通道是什么？首先，它们必须具有相同数量的子通道。每个子通道必须具有兼容的输入、颜色、解析和深度/模板附件集合。这意味着相应的附件的格式和样本数必须相同。然而，附件可以具有不同的初始、子通道和最终布局以及不同的加载和存储操作。
- en: Apart from that, framebuffers also define the size of a renderable area--the
    dimensions into which all rendering will be confined. However, what we need to
    remember is that it is up to us to make sure that the pixels/fragments outside
    of the specified range are not modified. For this purpose, we need to specify
    the appropriate parameters (viewport and scissor test) during the pipeline creation
    or when setting corresponding dynamic states (refer to the *Preparing viewport
    and scissor test state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines* and to the *Setting a dynamic viewport and scissors
    state* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command
    Recording and Drawing*).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，帧缓冲区还定义了可渲染区域的尺寸--所有渲染都将被限制的维度。然而，我们需要记住的是，确保指定范围之外的像素/片段不被修改的责任在我们身上。为此，我们需要在管道创建期间或设置相应的动态状态时指定适当的参数（视口和裁剪测试）（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中的*准备视口和裁剪测试状态*食谱，以及[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*设置动态视口和裁剪状态*食谱）。
- en: We must ensure that rendering occurs only in the dimensions specified during
    the framebuffer creation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保渲染只发生在在帧缓冲区创建期间指定的维度内。
- en: When we begin a render pass in a command buffer and use the given framebuffer,
    we also need to make sure that the images' subresources specified in that framebuffer
    are not used for any other purpose. In other words, if we use a given portion
    of an image as a framebuffer attachment, we can't use it in any other way during
    the render pass.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在命令缓冲区中开始一个渲染通道并使用给定的帧缓冲区时，我们还需要确保在该帧缓冲区中指定的图像子资源不用于任何其他目的。换句话说，如果我们将图像的某个部分用作帧缓冲区附件，那么在渲染通道期间我们不能以任何其他方式使用它。
- en: Image subresources specified for render pass attachments cannot be used for
    any other (non-attachment) purpose between the beginning and the end of the render
    pass.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为渲染通道附件指定的图像子资源不能在渲染通道的开始和结束之间用于任何其他（非附件）目的。
- en: 'Here is a code sample responsible for creating a framebuffer:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个负责创建帧缓冲区的代码示例：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看以下食谱：
- en: '*Creating an image*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像*'
- en: '*Creating an image view*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个图像视图*'
- en: 'The following recipes in this chapter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying attachment descriptions*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Creating a framebuffer*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个帧缓冲区*'
- en: Preparing a render pass for geometry rendering and postprocess subpasses
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备几何渲染和后处理子通道的渲染通道
- en: When developing applications such as games or CAD tools there are often situations
    in which we need to draw a geometry and then, when the whole scene is rendered,
    we apply additional image effects called postprocessing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏或CAD工具等应用程序时，我们经常需要先绘制几何图形，然后在整个场景渲染完毕后，应用称为后处理的附加图像效果。
- en: In this sample recipe, we will see how to prepare a render pass in which we
    will have two subpasses. The first subpass renders into two attachments--color
    and depth. The second subpass reads data from the first color attachment and renders
    into another color attachment--a swapchain image that can be presented (displayed
    on screen) after the render pass.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例食谱中，我们将看到如何准备一个渲染通道，其中我们将有两个子通道。第一个子通道渲染到两个附件中--颜色和深度。第二个子通道从第一个颜色附件中读取数据并渲染到另一个颜色附件中--一个可以在渲染通道之后呈现（显示在屏幕上）的交换链图像。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To lower the number of parameters that need to be provided, in this recipe we
    use a custom structure of type `SubpassParameters` (refer to the *Specifying subpass
    descriptions* recipe).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少需要提供的参数数量，在这个食谱中我们使用一个自定义的结构体类型`SubpassParameters`（参考*指定子通道描述*食谱）。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a variable of type `std::vector<VkAttachmentDescription>` named `attachments_descriptions`.
    Add an element to the `attachments_descriptions` vector that describes the first
    color attachment. Initialize it with the following values:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`attachments_descriptions`的类型为`std::vector<VkAttachmentDescription>`的变量。向`attachments_descriptions`向量添加一个元素，描述第一个颜色附件。使用以下值初始化它：
- en: '`0` value for `flags`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的`0`值'
- en: '`VK_FORMAT_R8G8B8A8_UNORM` value for `format`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`的`VK_FORMAT_R8G8B8A8_UNORM`值'
- en: '`VK_SAMPLE_COUNT_1_BIT` value for `samples`'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples`的`VK_SAMPLE_COUNT_1_BIT`值'
- en: '`VK_ATTACHMENT_LOAD_OP_CLEAR` value for `loadOp`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadOp`的`VK_ATTACHMENT_LOAD_OP_CLEAR`值'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `storeOp`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storeOp` 的 `VK_ATTACHMENT_STORE_OP_DONT_CARE` 值'
- en: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` value for `stencilLoadOp`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencilLoadOp` 的 `VK_ATTACHMENT_LOAD_OP_DONT_CARE` 值'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `stencilStoreOp`'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencilStoreOp` 的 `VK_ATTACHMENT_STORE_OP_DONT_CARE` 值'
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout` 的 `VK_IMAGE_LAYOUT_UNDEFINED` 值'
- en: '`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value for `finalLayout`'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalLayout` 的 `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` 值'
- en: 'Add another element to the `attachments_descriptions` vector that specifies
    the depth/stencil attachment. Use the following values to initialize its members:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `attachments_descriptions` 向量中添加另一个元素，指定深度/模板附件。使用以下值初始化其成员：
- en: '`0` value for `flags`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值'
- en: '`VK_FORMAT_D16_UNORM` value for `format`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的 `VK_FORMAT_D16_UNORM` 值'
- en: '`VK_SAMPLE_COUNT_1_BIT` value for `samples`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples` 的 `VK_SAMPLE_COUNT_1_BIT` 值'
- en: '`VK_ATTACHMENT_LOAD_OP_CLEAR`  value for `loadOp`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadOp` 的 `VK_ATTACHMENT_LOAD_OP_CLEAR` 值'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `storeOp`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storeOp` 的 `VK_ATTACHMENT_STORE_OP_DONT_CARE` 值'
- en: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` value for `stencilLoadOp`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencilLoadOp` 的 `VK_ATTACHMENT_LOAD_OP_DONT_CARE` 值'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `stencilStoreOp`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencilStoreOp` 的 `VK_ATTACHMENT_STORE_OP_DONT_CARE` 值'
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout` 的 `VK_IMAGE_LAYOUT_UNDEFINED` 值'
- en: '`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` value for `finalLayout`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalLayout` 的 `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` 值'
- en: 'Add a third element to the `attachments_descriptions` vector. This time it
    will specify another color attachment. Initialize it with the following values:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `attachments_descriptions` 向量中添加第三个元素。这次它将指定另一个颜色附件。使用以下值初始化它：
- en: '`0` value for `flags`'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值'
- en: '`VK_FORMAT_R8G8B8A8_UNORM` value for `format`'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的 `VK_FORMAT_R8G8B8A8_UNORM` 值'
- en: '`VK_SAMPLE_COUNT_1_BIT` value for `samples`'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples` 的 `VK_SAMPLE_COUNT_1_BIT` 值'
- en: '`VK_ATTACHMENT_LOAD_OP_CLEAR` value for `loadOp`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadOp` 的 `VK_ATTACHMENT_LOAD_OP_CLEAR` 值'
- en: '`VK_ATTACHMENT_STORE_OP_STORE` value for `storeOp`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storeOp` 的 `VK_ATTACHMENT_STORE_OP_STORE` 值'
- en: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` value for `stencilLoadOp`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencilLoadOp` 的 `VK_ATTACHMENT_LOAD_OP_DONT_CARE` 值'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `stencilStoreOp`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stencilStoreOp` 的 `VK_ATTACHMENT_STORE_OP_DONT_CARE` 值'
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout` 的 `VK_IMAGE_LAYOUT_UNDEFINED` 值'
- en: '`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` value for `finalLayout`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalLayout` 的 `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` 值'
- en: 'Create a variable of type `VkAttachmentReference` named `depth_stencil_attachment`
    and initialize it with the following values:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `depth_stencil_attachment` 的 `VkAttachmentReference` 类型的变量，并使用以下值初始化它：
- en: '`1` value for `attachment`'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachment` 的 `1` 值'
- en: '`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` value for `layout`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout` 的 `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` 值'
- en: 'Create a variable of type `std::vector<SubpassParameters>` named `subpass_parameters`
    and add one element with the following values to this vector:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `subpass_parameters` 的 `std::vector<SubpassParameters>` 类型的变量，并向此向量添加一个具有以下值的元素：
- en: '`VK_PIPELINE_BIND_POINT_GRAPHICS` value for `PipelineType`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PipelineType` 的 `VK_PIPELINE_BIND_POINT_GRAPHICS` 值'
- en: An empty vector for `InputAttachments`
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `InputAttachments` 的空向量
- en: 'A vector with one element and the following values for `ColorAttachments`:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorAttachments` 的一个元素和一个以下值的向量：'
- en: '`0` value for `attachment`'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachment` 的 `0` 值'
- en: '`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` value for `layout`'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout` 的 `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` 值'
- en: An empty vector for `ResolveAttachments`
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `ResolveAttachments` 的空向量
- en: A pointer to the `depth_stencil_attachment` variable for `DepthStencilAttachment`
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DepthStencilAttachment` 的 `depth_stencil_attachment` 变量的指针'
- en: An empty vector for `PreserveAttachments`
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `PreserveAttachments` 的空向量
- en: 'Add the second element to the `subpass_parameters` that describes the second
    subpass. Initialize its member using the following values:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `subpass_parameters` 中添加第二个元素，描述第二个子通道。使用以下值初始化其成员：
- en: '`VK_PIPELINE_BIND_POINT_GRAPHICS` value for `PipelineType`'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PipelineType` 的 `VK_PIPELINE_BIND_POINT_GRAPHICS` 值'
- en: 'A vector with one element with the following values for `InputAttachments`:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputAttachments` 的一个元素和一个以下值的向量：'
- en: '`0` value for `attachment`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachment` 的 `0` 值'
- en: '`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value for `layout`'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout` 的 `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` 值'
- en: 'A vector with one element with the following values for `ColorAttachments`:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorAttachments` 的一个元素和一个以下值的向量：'
- en: '`2` value for `attachment`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachment` 的 `2` 值'
- en: '`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` value for `layout`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout` 的 `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` 值'
- en: An empty vector for `ResolveAttachments`
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `ResolveAttachments` 的空向量
- en: '`nullptr` value for `DepthStencilAttachment`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DepthStencilAttachment` 的 `nullptr` 值'
- en: An empty vector for `PreserveAttachments`
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `PreserveAttachments` 的空向量
- en: 'Create a variable of type `std::vector<VkSubpassDependency>` named `subpass_dependencies`
    with a single element that uses the following values for its members:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `subpass_dependencies` 的 `std::vector<VkSubpassDependency>` 类型的变量，它只有一个元素，其成员使用以下值：
- en: '`0` value for `srcSubpass`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcSubpass` 的 `0` 值'
- en: '`1` value for `dstSubpass`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstSubpass` 的 `1` 值'
- en: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `srcStageMask`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcStageMask` 的 `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` 值'
- en: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` value for `dstStageMask`'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstStageMask` 的 `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` 值'
- en: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `srcAccessMask`'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcAccessMask` 的 `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` 值'
- en: '`VK_ACCESS_INPUT_ATTACHMENT_READ_BIT` value for `dstAccessMask`'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstAccessMask` 的 `VK_ACCESS_INPUT_ATTACHMENT_READ_BIT` 值'
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencyFlags` 的 `VK_DEPENDENCY_BY_REGION_BIT` 值'
- en: Create the render pass using `attachments_descriptions`, `subpass_parameters`
    and `subpass_dependencies` variables. Store its handle in a variable of type `VkRenderPass`
    named `render_pass` (refer to the *Creating a render pass* recipe in this chapter).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `attachments_descriptions`、`subpass_parameters` 和 `subpass_dependencies`
    变量创建渲染通道。将句柄存储在名为 `render_pass` 的 `VkRenderPass` 类型的变量中（参考本章中的 *创建渲染通道* 配方）。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we create a render pass with the three attachments. They are
    specified as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个包含三个附件的渲染通道。它们被指定如下：
- en: '[PRE8]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First there is a color attachment into which we render in the first subpass
    and from which we read in the second subpass. The second attachment is used for
    a depth data; and the third is another color attachment into which we render in
    the second subpass. As we don't need the contents of the first and second attachments
    after the render pass (we need the contents of the first attachment only in the
    second subpass), we specify a `VK_ATTACHMENT_STORE_OP_DONT_CARE` value for their
    store operations. We also don't need their contents at the beginning of the render
    pass, so we specify an `UNDEFINED` initial layout. We also clear all three attachments.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先有一个颜色附件，我们在第一个子阶段向其中渲染，并在第二个子阶段从中读取。第二个附件用于深度数据；第三个是另一个颜色附件，我们在第二个子阶段向其中渲染。由于我们不需要在渲染通道之后第一个和第二个附件的内容（我们只需要在第二个子阶段中第一个附件的内容），所以我们为它们的存储操作指定了
    `VK_ATTACHMENT_STORE_OP_DONT_CARE` 值。我们也不需要在渲染通道开始时需要它们的内容，所以我们指定了一个 `UNDEFINED`
    初始布局。我们还清除了所有三个附件。
- en: 'Next we define two subpasses:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义两个子阶段：
- en: '[PRE9]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first subpass uses a color attachment and a depth attachment. The second
    subpass reads from the first attachment (used here as an input attachment) and
    renders into the third attachment.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个子阶段使用颜色附件和深度附件。第二个子阶段从第一个附件（在此用作输入附件）读取，并将渲染到第三个附件中。
- en: 'The last thing is to define a dependency between two subpasses for the first
    attachment, which is once a color attachment (we write data to it) and once an
    input attachment (we read data from it). After that we can create the render pass
    like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义两个子阶段之间第一个附件的依赖关系，该附件最初是颜色附件（我们向其中写入数据），然后是输入附件（我们从其中读取数据）。之后，我们可以像这样创建渲染通道：
- en: '[PRE10]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying attachment descriptions*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Specifying subpass descriptions*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子阶段描述*'
- en: '*Specifying dependencies between subpasses*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子阶段之间的依赖关系*'
- en: '*Creating a render pass*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: Preparing a render pass and a framebuffer with color and depth attachments
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备带有颜色和深度附件的渲染通道和帧缓冲区
- en: Rendering a 3D scene usually involves not only a color attachment, but also
    a depth attachment used for depth testing (we want further objects to be occluded
    by the objects closer to the camera).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染3D场景通常不仅涉及颜色附件，还涉及用于深度测试的深度附件（我们希望远离相机的对象被靠近相机的对象遮挡）。
- en: In this sample recipe, we will see how to create images for color and depth
    data and a render pass with a single subpass that renders into color and depth
    attachments. We will also create a framebuffer that will use both images for the
    render pass attachments.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例配方中，我们将看到如何创建用于颜色和深度数据的图像，以及一个具有单个子阶段的渲染通道，该子阶段将渲染到颜色和深度附件中。我们还将创建一个帧缓冲区，该帧缓冲区将使用这两个图像作为渲染通道的附件。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As in earlier recipes from this chapter, in this recipe we will use a custom
    structure of type `SubpassParameters` (refer to the *Specifying subpass descriptions*
    recipe).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中较早的配方一样，在这个配方中，我们将使用类型为 `SubpassParameters` 的自定义结构（参考 *指定子阶段描述* 配方）。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a 2D image and image view for it with a `VK_FORMAT_R8G8B8A8_UNORM` format,
    `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT` usage and a `VK_IMAGE_ASPECT_COLOR_BIT`
    aspect. Choose the rest of the image's parameters. Store the created handles in
    variables of type `VkImage` named `color_image`, of type `VkDeviceMemory` named
    `color_image_memory_object,` and of type `VkImageView` named `color_image_view`
    (refer to the *Creating a 2D image and view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 `VK_FORMAT_R8G8B8A8_UNORM` 格式、`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
    VK_IMAGE_USAGE_SAMPLED_BIT` 用法和 `VK_IMAGE_ASPECT_COLOR_BIT` 方面的 2D 图像及其视图。选择图像的其余参数。将创建的句柄存储在名为
    `color_image` 的 `VkImage` 类型的变量中，名为 `color_image_memory_object` 的 `VkDeviceMemory`
    类型的变量中，以及名为 `color_image_view` 的 `VkImageView` 类型的变量中（参考第 4 章 [Creating a 2D image
    and view](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml) 中的配方，*资源和内存*）。
- en: Create a second 2D image and image view for it with a `VK_FORMAT_D16_UNORM`
    format, `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT`
    usage, `VK_IMAGE_ASPECT_DEPTH_BIT` aspect, and the same size as the image whose
    handle is stored in the `color_image` variable. Choose the rest of the image's
    parameters. Store the created handles in variables of type `VkImage` named `depth_image`,
    of type `VkDeviceMemory` named `depth_image_memory_object,` and of type `VkImageView`
    named `depth_image_view` (refer to the *Creating a 2D image and view* recipe from
    [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 `VK_FORMAT_D16_UNORM` 格式、`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
    | VK_IMAGE_USAGE_SAMPLED_BIT` 用法、`VK_IMAGE_ASPECT_DEPTH_BIT` 方面和与存储在 `color_image`
    变量中的图像相同大小的第二个 2D 图像及其视图。选择图像的其余参数。将创建的句柄存储在名为 `depth_image` 的 `VkImage` 类型的变量中，名为
    `depth_image_memory_object` 的 `VkDeviceMemory` 类型的变量中，以及名为 `depth_image_view`
    的 `VkImageView` 类型的变量中（参考第 4 章 [Creating a 2D image and view](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)
    中的配方，*资源和内存*）。
- en: 'Create a variable of type `std::vector<VkAttachmentDescription>` named `attachments_descriptions`
    and add two elements to the vector. Initialize the first element with the following
    values:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `attachments_descriptions` 的 `std::vector<VkAttachmentDescription>` 类型的变量，并向该向量添加两个元素。使用以下值初始化第一个元素：
- en: '`0` value for `flags`'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 的值用于 `flags`'
- en: '`VK_FORMAT_R8G8B8A8_UNORM` value for `format`'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_R8G8B8A8_UNORM` 的值用于 `format`'
- en: '`VK_SAMPLE_COUNT_1_BIT` value for `samples`'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SAMPLE_COUNT_1_BIT` 的值用于 `samples`'
- en: '`VK_ATTACHMENT_LOAD_OP_CLEAR` value for `loadOp`'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_LOAD_OP_CLEAR` 的值用于 `loadOp`'
- en: '`VK_ATTACHMENT_STORE_OP_STORE` value for `storeOp`'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_STORE_OP_STORE` 的值用于 `storeOp`'
- en: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` value for `stencilLoadOp`'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` 的值用于 `stencilLoadOp`'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `stencilStoreOp`'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` 的值用于 `stencilStoreOp`'
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_UNDEFINED` 的值用于 `initialLayout`'
- en: '`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value for `finalLayout`'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` 的值用于 `finalLayout`'
- en: 'Use these values to initialize members of the second element of the `attachments_descriptions`
    vector:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些值初始化 `attachments_descriptions` 向量第二个元素的成员：
- en: '`0` value for `flags`'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 的值用于 `flags`'
- en: '`VK_FORMAT_D16_UNORM` value for `format`'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_FORMAT_D16_UNORM` 的值用于 `format`'
- en: '`VK_SAMPLE_COUNT_1_BIT` value for `samples`'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SAMPLE_COUNT_1_BIT` 的值用于 `samples`'
- en: '`VK_ATTACHMENT_LOAD_OP_CLEAR` value for `loadOp`'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_LOAD_OP_CLEAR` 的值用于 `loadOp`'
- en: '`VK_ATTACHMENT_STORE_OP_STORE` value for `storeOp`'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_STORE_OP_STORE` 的值用于 `storeOp`'
- en: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` value for `stencilLoadOp`'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_LOAD_OP_DONT_CARE` 的值用于 `stencilLoadOp`'
- en: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` value for `stencilStoreOp`'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ATTACHMENT_STORE_OP_DONT_CARE` 的值用于 `stencilStoreOp`'
- en: '`VK_IMAGE_LAYOUT_UNDEFINED` value for `initialLayout`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_UNDEFINED` 的值用于 `initialLayout`'
- en: '`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` value for `finalLayout`'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` 的值用于 `finalLayout`'
- en: 'Create a variable of type `VkAttachmentReference` named `depth_stencil_attachment`
    and initialize it using the following values:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `depth_stencil_attachment` 的 `VkAttachmentReference` 类型的变量，并使用以下值进行初始化：
- en: '`1` value for `attachment`'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 的值用于 `attachment`'
- en: '`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` value for `layout`'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` 的值用于 `layout`'
- en: 'Create a vector of type `std::vector<SubpassParameters>` named `subpass_parameters`.
    Add a single element to this vector and use the following values to initialize
    it:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `subpass_parameters` 的 `std::vector<SubpassParameters>` 类型的向量。向该向量添加一个元素，并使用以下值进行初始化：
- en: '`VK_PIPELINE_BIND_POINT_GRAPHICS` value for `PipelineType`'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_BIND_POINT_GRAPHICS` 的值用于 `PipelineType`'
- en: An empty vector for `InputAttachments`
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputAttachments` 的一个空向量'
- en: 'A vector with just one element with these values for `ColorAttachments`:'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只有一个元素的向量，这些值用于 `ColorAttachments`：
- en: '`0` value for `attachment`'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`的值用于`attachment`'
- en: '`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` value for `layout`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`的值用于`layout`'
- en: An empty vector for `ResolveAttachments`
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空的向量用于`ResolveAttachments`
- en: A pointer to the `depth_stencil_attachment` variable for `DepthStencilAttachment`
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`depth_stencil_attachment`变量的指针，用于`DepthStencilAttachment`
- en: An empty vector for `PreserveAttachments`
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空的向量用于`PreserveAttachments`
- en: 'Create a vector of type `std::vector<VkSubpassDependency>` named `subpass_dependencies`
    with a single element initialized using these values:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`subpass_dependencies`的`std::vector<VkSubpassDependency>`类型的向量，使用这些值初始化单个元素：
- en: '`0` value for `srcSubpass`'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`的值用于`srcSubpass`'
- en: '`VK_SUBPASS_EXTERNAL` value for `dstSubpass`'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SUBPASS_EXTERNAL`的值用于`dstSubpass`'
- en: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `srcStageMask`'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`的值用于`srcStageMask`'
- en: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` value for `dstStageMask`'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT`的值用于`dstStageMask`'
- en: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `srcAccessMask`'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`的值用于`srcAccessMask`'
- en: '`VK_ACCESS_SHADER_READ_BIT` value for `dstAccessMask`'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_SHADER_READ_BIT`的值用于`dstAccessMask`'
- en: '`0` value for `dependencyFlags`'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`的值用于`dependencyFlags`'
- en: Create a render pass using `attachments_descriptions`, `subpass_parameters`
    and `subpass_dependencies` vectors. Store the created render pass handle in a
    variable of type `VkRenderPass` named `render_pass` (refer to the *Creating a
    render pass* recipe in this chapter).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`attachments_descriptions`、`subpass_parameters`和`subpass_dependencies`向量创建一个名为`render_pass`的`VkRenderPass`类型的变量。将创建的渲染通道句柄存储在名为`render_pass`的变量中（参考本章中的*创建渲染通道*配方）。
- en: Create a framebuffer using the `render_pass` variable and the `color_image_view`
    variable for its first attachment and the `depth_image_view` variable for the
    second attachment. Specify the same dimensions as used for the `color_image` and
    `depth_image` variables. Store the created framebuffer handle in a variable of
    type `VkFramebuffer` named `framebuffer`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`render_pass`变量和`color_image_view`变量作为其第一个附件，以及`depth_image_view`变量作为第二个附件创建一个帧缓冲区。指定与`color_image`和`depth_image`变量相同的维度。将创建的帧缓冲区句柄存储在名为`framebuffer`的`VkFramebuffer`类型的变量中。
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this sample recipe, we want to render into two images--one for color data,
    and another for the depth data. We imply that after the render pass they will
    be used as textures (we will sample them in shaders in another render pass); that''s
    why they are created with `COLOR_ATTACHMENT` / `DEPTH_STENCIL_ATTACHMENT` usages
    (so we can render into them) and `SAMPLED` usage (so they both can be sampled
    from in shaders):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例配方中，我们希望将渲染到两个图像中——一个用于颜色数据，另一个用于深度数据。我们暗示在渲染通道之后它们将被用作纹理（我们将在另一个渲染通道的着色器中采样它们）；这就是为什么它们被创建为`COLOR_ATTACHMENT`
    / `DEPTH_STENCIL_ATTACHMENT`用法（以便我们可以将渲染到它们中）和`SAMPLED`用法（以便它们都可以在着色器中被采样）：
- en: '[PRE11]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next we specify two attachments for the render pass. They are both cleared
    at the beginning of the render pass and their contents are preserved after the
    render pass:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定渲染通道的两个附件。它们都在渲染通道的开始时清除，并在渲染通道之后保留其内容：
- en: '[PRE12]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to define a single subpass. It uses the first attachment for
    color writes and the second attachment for depth/stencil data:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个单独的子通道。它使用第一个附件进行颜色写入，第二个附件进行深度/模板数据：
- en: '[PRE13]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we define a dependency between the subpass and the commands that will
    be performed after the render pass. This is required, because we don''t want other
    commands to start reading our images before their contents are fully written in
    the render pass. We also create the render pass and a framebuffer:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义子通道与渲染通道之后将执行的命令之间的依赖关系。这是必需的，因为我们不希望其他命令在渲染通道的内容完全写入之前开始读取我们的图像。我们还创建了渲染通道和帧缓冲区：
- en: '[PRE14]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipe:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看以下配方：
- en: '*Creating a 2D image and view*'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建二维图像和视图*'
- en: 'The following recipes in this chapter:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying attachment descriptions*'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定附件描述*'
- en: '*Specifying subpass descriptions*'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Specifying dependencies between subpasses*'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道之间的依赖关系*'
- en: '*Creating a render pass*'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: Beginning a render pass
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始渲染通道
- en: When we have created a render pass and a framebuffer and we are ready to start
    recording commands needed to render a geometry, we must record an operation that
    begins the render pass. This also automatically starts its first subpass.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个渲染通道和帧缓冲区，并且准备开始记录渲染几何形状所需的命令时，我们必须记录一个开始渲染通道的操作。这也会自动开始其第一个子通道。
- en: How to do it...
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer stored in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在类型为 `VkCommandBuffer` 的变量 `command_buffer` 中的命令缓冲区句柄。确保命令缓冲区处于记录状态。
- en: Use the handle of the render pass to initialize a variable of type `VkRenderPass`
    named `render_pass`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用渲染通道的句柄初始化一个类型为 `VkRenderPass` 的变量 `render_pass`。
- en: Take the framebuffer that is compatible with the `render_pass`. Store its handle
    in a variable of type `VkFramebuffer` named `framebuffer`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与 `render_pass` 兼容的帧缓冲区，并将其句柄存储在类型为 `VkFramebuffer` 的变量 `framebuffer` 中。
- en: Specify the dimensions of the render area into which rendering will be confined
    during the render pass. This area cannot be larger than the size specified for
    the framebuffer. Store the dimensions in a variable of type `VkRect2D` named `render_area`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定渲染通道期间渲染将被限制的渲染区域的尺寸。此区域不能大于帧缓冲区指定的尺寸。将尺寸存储在类型为 `VkRect2D` 的变量 `render_area`
    中。
- en: Create a variable of type `std::vector<VkClearValue>` named `clear_values` with
    the number of elements equal to the number of attachments in the render pass.
    For each render pass attachment that uses a clear `loadOp`, provide the corresponding
    clear value at the same index as the attachment index.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `std::vector<VkClearValue>` 的变量，命名为 `clear_values`，其元素数量等于渲染通道中附件的数量。对于每个使用清除
    `loadOp` 的渲染通道附件，提供与附件索引相同的索引处的相应清除值。
- en: Prepare a variable of type `VkSubpassContents` named `subpass_contents` describing
    how operations in the first subpass are recorded. Use a `VK_SUBPASS_CONTENTS_INLINE`
    value if commands are recorded directly and no secondary command buffer will be
    executed, or a `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS` value to specify
    that commands for the subpass are stored in the secondary command buffer and only
    executing a secondary command buffer command will be used (refer to the *Executing
    a secondary command buffer inside a primary command buffer* recipe from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个类型为 `VkSubpassContents` 的变量 `subpass_contents`，描述第一个子通道中操作的记录方式。如果命令直接记录且没有执行二级命令缓冲区，则使用
    `VK_SUBPASS_CONTENTS_INLINE` 值；或使用 `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`
    值来指定子通道的命令存储在二级命令缓冲区中，并且仅使用执行二级命令缓冲区命令（参考第 9 章 *执行主命令缓冲区内的二级命令缓冲区* 的配方，*命令记录和绘制*）。
- en: 'Create a variable of type `VkRenderPassBeginInfo` named `render_pass_begin_info`
    and initialize its members using these values:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `VkRenderPassBeginInfo` 的变量，命名为 `render_pass_begin_info`，并使用这些值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO` value for `sType`'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`'
- en: '`render_pass` variable for `renderPass`'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_pass` 变量用于 `renderPass`'
- en: '`framebuffer` variable for `framebuffer`'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`framebuffer` 变量用于 `framebuffer`'
- en: '`render_area` variable for `renderArea`'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_area` 变量用于 `renderArea`'
- en: Number of elements in the `clear_values` vector for `clearValueCount`
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear_values` 向量中的元素数量用于 `clearValueCount`'
- en: Pointer to the first element of the `clear_values` vector (or a `nullptr` value
    if it is empty) for `pClearValues`
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear_values` 向量第一个元素的指针（如果为空，则为 `nullptr` 值）用于 `pClearValues`'
- en: Call `vkCmdBeginRenderPass( command_buffer, &render_pass_begin_info, subpass_contents
    )`, providing the `command_buffer` variable, pointer to the `render_pass_begin_info`
    variable and the `subpass_contents` variable.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdBeginRenderPass(command_buffer, &render_pass_begin_info, subpass_contents)`，提供
    `command_buffer` 变量、`render_pass_begin_info` 变量的指针和 `subpass_contents` 变量。
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Starting a render pass automatically starts its first subpass. Before this
    is done, all attachments, for which a clear `loadOp` was specified, are cleared--filled
    with a single color. Values used for clearing (and the rest of the parameters
    required to start a render pass) are specified in a variable of type `VkRenderPassBeginInfo`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 开始渲染通道会自动开始其第一个子通道。在此操作完成之前，所有指定了清除 `loadOp` 的附件都会被清除--填充为单一颜色。用于清除的值（以及启动渲染通道所需的其他参数）在类型为
    `VkRenderPassBeginInfo` 的变量中指定：
- en: '[PRE15]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An array with clearing values must have at least as many elements so they can
    correspond to attachments from the start to the last cleared attachment (the attachment
    with the greatest index that is being cleared). It is safer to have the same number
    of clear values as there are attachments in the render pass, but we only need
    to provide values for the cleared ones. If no attachments are cleared, we can
    provide a `nullptr` value for the clear values array.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 清除值的数组必须有至少与从开始到最后清除的附件（正在清除的具有最大索引的附件）对应的元素。最好有与渲染通道中附件数量相同的清除值，但我们只需要为清除的提供值。如果没有附件被清除，我们可以为清除值数组提供一个`nullptr`值。
- en: When we start a render pass, we also need to provide the dimensions of the render
    area. It can be as large as the dimensions of the framebuffer, but can be smaller.
    It is up to us to make sure that the rendering will be confined to the specified
    area, or the pixels outside of this range may become undefined.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始渲染通道时，我们还需要提供渲染区域的尺寸。它可以与帧缓冲区的尺寸一样大，但可以更小。确保渲染被限制在指定的区域取决于我们，或者此范围之外的像素可能成为未定义的。
- en: 'To begin the render pass we need to call:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始渲染通道，我们需要调用：
- en: '[PRE16]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipe:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中，查看以下配方：
- en: '*Executing a secondary command buffer inside a primary command buffer*'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在主命令缓冲区内部执行二级命令缓冲区*'
- en: 'The following recipes in this chapter:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a render pass*'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: Progressing to the next subpass
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入下一个子通道
- en: Commands that are recorded inside a render pass are divided into subpasses.
    When a set of commands from a given subpass is already recorded and we want to
    record commands for another subpass, we need to switch (or progress) to the next
    subpass.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染通道内记录的命令被分为子通道。当给定子通道的一组命令已经记录，而我们想要记录另一个子通道的命令时，我们需要切换（或进入）下一个子通道。
- en: How to do it...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer that's being recorded and store it in a
    variable of type `VkCommandBuffer` named `command_buffer`. Make sure the operation
    of beginning a render pass was already recorded in the `command_buffer`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取正在记录的命令缓冲区的句柄，并将其存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。确保开始渲染通道的操作已经记录在`command_buffer`中。
- en: 'Specify how subpass commands are recorded: directly or through a secondary
    command buffer. Store the appropriate value in a variable of type `VkSubpassContents`
    named `subpass_contents` (refer to the *Beginning a render pass* recipe).'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定子通道命令的记录方式：直接或通过二级命令缓冲区。将适当的值存储在名为`subpass_contents`的`VkSubpassContents`类型变量中（参考*开始渲染通道*配方）。
- en: Call `vkCmdNextSubpass( command_buffer, subpass_contents )`. For the call, provide
    the `command_buffer` and `subpass_contents` variables.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdNextSubpass(command_buffer, subpass_contents)`。对于调用，提供`command_buffer`和`subpass_contents`变量。
- en: How it works...
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Progressing to the next subpass switches from the current to the next subpass
    in the same render pass. During this operation appropriate layout transitions
    are performed and memory and execution dependencies are introduced (similar to
    those in memory barriers). All this is performed automatically by the driver,
    if needed, so the attachments in the new subpass can be used in the way specified
    during the render pass creation. Moving to the next subpass also performs multisample
    resolve operations on specified color attachments.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 进入下一个子通道会将当前渲染通道切换到下一个子通道。在此操作过程中，将执行适当的布局转换，并引入内存和执行依赖（类似于内存屏障）。所有这些操作都由驱动程序自动执行，如果需要，以便新子通道中的附件可以按照在渲染通道创建期间指定的方式使用。进入下一个子通道还会对指定的颜色附件执行多采样解析操作。
- en: Commands in the subpass can be recorded directly, by inlining them in the command
    buffer, or indirectly by executing a secondary command buffer.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 子通道中的命令可以直接记录，通过在命令缓冲区中内联它们，或者间接通过执行二级命令缓冲区。
- en: 'To record an operation that switches from one subpass to another, we need to
    call a single function:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录从一个子通道切换到另一个子通道的操作，我们需要调用一个单一函数：
- en: '[PRE17]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying subpass descriptions*'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a render pass*'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Beginning a render pass*'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: '*Ending a render pass*'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束渲染通道*'
- en: Ending a render pass
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束渲染通道
- en: When all commands from all subpasses are already recorded, we need to end (stop
    or finish) a render pass.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有子通道的所有命令都已记录时，我们需要结束（停止或完成）渲染通道。
- en: How to do it...
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in a recording state and
    that the operation of beginning a render pass was already recorded in it.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出命令缓冲区的句柄并将其存储在名为`command_buffer`的`VkCommandBuffer`类型变量中。确保命令缓冲区处于记录状态，并且开始渲染通道的操作已经记录在其中。
- en: Call `vkCmdEndRenderPass( command_buffer )` for which provide the `command_buffer`
    variable.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCmdEndRenderPass( command_buffer )`，并提供`command_buffer`变量。
- en: How it works...
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To end a render pass, we need to call a single function:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束渲染通道，我们需要调用一个单一函数：
- en: '[PRE18]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Recording this function in a command buffer performs multiple operations. Execution
    and memory dependencies are introduced (like the ones in memory barriers) and
    image layout transitions are performed--images are transitioned from layouts specified
    for the last subpass to the value of a final layout (refer to the *Specifying
    attachment descriptions* recipe). Also multisample resolving is performed on color
    attachments for which resolving was specified in the last subpass. Additionally,
    for attachments whose contents should be preserved after the render pass, attachment
    data may be transferred from the cache to the image's memory.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令缓冲区中记录此函数执行多个操作。引入执行和内存依赖（如内存屏障中的那些）并执行图像布局转换——图像从为最后一个子通道指定的布局转换到最后布局的值（参考*指定附件描述*食谱）。此外，对于在最后一个子通道中指定了解决的彩色附件，执行多采样解决。另外，对于在渲染通道之后应保留内容的附件，可能将附件数据从缓存传输到图像的内存中。
- en: See also
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying subpass descriptions*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a render pass*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Beginning a render pass*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: '*Progressing to the next subpass*'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推进到下一个子通道*'
- en: Destroying a framebuffer
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁帧缓冲区
- en: When a framebuffer is no longer used by the pending commands and we don't need
    it anymore, we can destroy it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当帧缓冲区不再被挂起的命令使用，并且我们不再需要它时，我们可以销毁它。
- en: How to do it...
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Initialize a variable of type `VkDevice` named `logical_device` with the handle
    of a logical device on which the framebuffer was created.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建帧缓冲区的逻辑设备的句柄初始化一个名为`logical_device`的`VkDevice`类型变量。
- en: Take the framebuffer's handle and store it in a variable of type `VkFramebuffer`
    named `framebuffer`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出帧缓冲区的句柄并将其存储在名为`framebuffer`的`VkFramebuffer`类型变量中。
- en: 'Make the following call: `vkDestroyFramebuffer( logical_device, framebuffer,
    nullptr )`, for which we provide the `logical_device` and `framebuffer` variables
    and a `nullptr` value.'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下调用：`vkDestroyFramebuffer( logical_device, framebuffer, nullptr )`，其中我们提供`logical_device`和`framebuffer`变量以及一个`nullptr`值。
- en: For safety reasons, store a `VK_NULL_HANDLE` value in the `framebuffer` variable.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于安全原因，在`framebuffer`变量中存储`VK_NULL_HANDLE`值。
- en: How it works...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The framebuffer is destroyed with the `vkDestroyFramebuffer()` function call.
    However, before we can destroy it, we must make sure that commands referencing
    the given framebuffer are no longer executed on the hardware.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vkDestroyFramebuffer()`函数调用销毁帧缓冲区。然而，在我们能够销毁它之前，我们必须确保不再在硬件上执行引用给定帧缓冲区的命令。
- en: 'The following code destroys a framebuffer:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码销毁了一个帧缓冲区：
- en: '[PRE19]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipe in this chapter:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a framebuffer*'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: Destroying a render pass
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁渲染通道
- en: If a render pass is not needed and it is not used anymore by commands submitted
    to the hardware, we can destroy it.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果渲染通道不再需要，并且它不再被提交到硬件的命令使用，我们可以销毁它。
- en: How to do it...
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the handle of a logical device, on which the render pass was created, to
    initialize a variable of type `VkDevice` named `logical_device`.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建渲染通道的逻辑设备的句柄来初始化一个名为`logical_device`的`VkDevice`类型变量。
- en: Store the handle of the render pass that should be destroyed in a variable of
    type `VkRenderPass` named `render_pass`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应销毁的渲染通道的句柄存储在名为`render_pass`的`VkRenderPass`类型变量中。
- en: Call `vkDestroyRenderPass( logical_device, render_pass, nullptr )` and provide
    the `logical_device` and `render_pass` variables and a `nullptr` value.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyRenderPass( logical_device, render_pass, nullptr )` 并提供 `logical_device`
    和 `render_pass` 变量以及一个 `nullptr` 值。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `render_pass` variable.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于安全原因，将 `VK_NULL_HANDLE` 值分配给 `render_pass` 变量。
- en: How it works...
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Destroying a render pass is performed with just a single function call like
    this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 删除渲染通道只需一个函数调用，如下所示：
- en: '[PRE20]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipe in this chapter:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a render pass*'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
