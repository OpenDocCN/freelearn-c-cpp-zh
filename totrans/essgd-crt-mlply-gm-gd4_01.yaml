- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Setting up a Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置服务器
- en: Welcome to *The Essential Guide to Creating Multiplayer Games with Godot 4.0*.
    In this hands-on book, you are going to learn the core concepts used to create
    online multiplayer games using the Godot Engine 4.0 Network API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 *《使用Godot 4.0创建多人游戏必备指南》*。在这本实践手册中，你将学习用于使用Godot Engine 4.0网络API创建在线多人游戏的核心概念。
- en: Firstly, we are going to understand some fundamental aspects of how computers
    communicate through a network and the main protocols, including which ones are
    more relevant for making online multiplayer games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将了解一些关于计算机通过网络进行通信的基本方面以及主要协议，包括哪些对于制作在线多人游戏更为相关。
- en: After that, we will understand how Godot Engine 4.0 uses and provides both low-
    and high-level implementations for networking using its network API. We’ll understand
    some core classes that we can use to pass data around to multiple computers on
    the same network. And then we’ll focus on the high-level API known as `ENetMultiplayerPeer`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将了解Godot Engine 4.0如何使用并提供其网络API的低级和高级实现。我们将了解一些核心类，我们可以使用这些类在同一个网络上的多台计算机之间传递数据。然后我们将关注称为`ENetMultiplayerPeer`的高级API。
- en: 'With the fundamentals in place, we’ll use the knowledge we just learned to
    turn local gameplay features into online gameplay features. To do that, we will
    develop five game projects:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础知识到位后，我们将利用我们刚刚学到的知识将本地游戏功能转换为在线游戏功能。为此，我们将开发五个游戏项目：
- en: An online quiz game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线问答游戏
- en: Checkers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查器
- en: Pong
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乒乓球
- en: A co-op platformer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合作平台游戏
- en: A top-down adventure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 俯视冒险游戏
- en: Then, we’ll learn some techniques we can use to improve our players’ experience
    by optimizing how their game sends, receives, and processes network data. We’ll
    understand that we don’t need constant updates and that we can do most of the
    gameplay with small bits of data and let the clients’ computers fill the gaps
    on their own.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将学习一些技术，我们可以使用这些技术通过优化游戏发送、接收和处理网络数据的方式来提高玩家的体验。我们将了解我们不需要持续更新，我们可以用小块数据完成大部分游戏玩法，并让客户端的计算机自行填补空白。
- en: Throughout each chapter, you’re going to do a role play of a network engineer
    working for a fictional, independent game development studio. In each chapter,
    you will apply your recently learned knowledge to a fictional problem presented
    by your studio’s peers. You’ll focus on the network aspect of each project they
    present, so you don’t waste your precious time trying to understand unnecessary
    aspects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，你将扮演一个为虚构的独立游戏开发工作室工作的网络工程师。在每一章中，你将应用你最近学到的知识来解决工作室同伴提出的虚构问题。你将专注于他们展示的每个项目的网络方面，这样你就不会浪费宝贵的时间去理解不必要的方面。
- en: 'In this chapter, you are going to learn the most important aspect of establishing
    a network of computers: to connect them all together. You’ll see how this process
    happens, the reason for doing this, what’s required to establish this connection,
    and how we can do that using the API that Godot Engine provides.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习建立计算机网络的最重要的方面：将它们全部连接起来。你将了解这个过程是如何发生的，为什么要这样做，建立这种连接需要什么，以及我们如何使用Godot引擎提供的API来实现这一点。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Introduction to a network
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络简介
- en: Understanding the Godot Engine Network API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Godot引擎网络API
- en: Setting up the client side
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置客户端
- en: Setting up the server side
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务器端
- en: Making your first handshake
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作你的第一个握手
- en: By the end of the chapter, you’ll have a client and server version of an application
    that establishes the connection of two or more computers. This is the very core
    of everything that we are going to see throughout the book, and with that knowledge,
    you’ll understand how you can start making computers communicate within a network,
    which is exactly what you need to do in online multiplayer games.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个应用程序的客户端和服务器版本，该应用程序建立了两台或多台计算机之间的连接。这是我们将在整本书中看到的一切的核心，有了这些知识，你将了解如何开始让计算机在网络中通信，这正是你在在线多人游戏中需要做的。
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Godot Engine has its own standalone text editor, which is what we are going
    to use to code all our practical lessons.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Godot引擎有自己的独立文本编辑器，这就是我们将用它来编写所有实践课程的代码。
- en: 'As mentioned earlier, in this book you will do a role play of a network engineer
    of a fictional indie game studio. So, we will provide pre-made projects with all
    the non-network-related work ready. You can find them in the book’s GitHub repository:
    [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这本书中，你将扮演一个虚构独立游戏工作室的网络工程师。因此，我们将提供所有非网络相关工作的预制作项目。你可以在本书的GitHub仓库中找到它们：[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)。
- en: With the project properly added to your Godot Engine’s project manager, open
    the project and move on to the `res://01.setting-up-a-server` folder. Here, you'll
    find what you need to follow this chapter (later part).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在将项目正确添加到你的Godot引擎项目管理器后，打开项目并转到`res://01.setting-up-a-server`文件夹。在这里，你可以找到你需要遵循本章（后续部分）的内容。
- en: Introduction to a network
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络简介
- en: Making a network of connected computers is quite a task. In this chapter, we’ll
    understand the core concepts of online networks. We’ll also cover how Godot Engine
    provides solutions to each of the problems we may face in our quest to make online
    multiplayer games.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个连接的计算机网络是一项相当艰巨的任务。在本章中，我们将了解在线网络的核心概念。我们还将介绍Godot引擎如何为我们可能面临的每个问题提供解决方案，以制作在线多人游戏。
- en: A **network** is a collection of interconnected devices that communicate with
    each other. In this communication, these devices exchange information and share
    resources with each other. You can have a local network, such as in a house or
    office, or a global network, such as the internet. The idea is the same.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络**是一组相互连接的设备，它们相互通信。在这些通信中，这些设备交换信息并相互共享资源。你可以有一个本地网络，比如在家庭或办公室中，或者一个全球网络，比如互联网。这个想法是相同的。'
- en: For these devices to communicate they need to perform what we call a **handshake**.
    A handshake is how one device recognizes another device and establishes their
    communication protocols. This way, they know what they can request, what they
    expect to get, and what they need to send to one another.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些设备能够通信，它们需要执行我们所说的**握手**。握手是设备识别另一设备并建立它们的通信协议的方式。这样，它们就知道它们可以请求什么，期望得到什么，以及需要向对方发送什么。
- en: A handshake begins with one device sending a message to another device. We call
    this message a *handshake request*. The devices use this message to start the
    handshake process. The one that sent the request waits for a message from the
    one that received it. We call this second message a *handshake response*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 握手开始于一个设备向另一个设备发送消息。我们称这个消息为*握手请求*。设备使用这个消息来启动握手过程。发送请求的设备等待接收方的消息。我们称这个第二个消息为*握手响应*。
- en: '![Figure 1.1 – The handshake procedure](img/Figure_01.01_B18527.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 握手过程](img/Figure_01.01_B18527.jpg)'
- en: Figure 1.1 – The handshake procedure
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 握手过程
- en: When the requested device sends the confirmation through the handshake response,
    they establish their communication. After that, the devices start exchanging data.
    This wraps up the handshake process. We usually call the device that requests
    data the *client*. As for the one that provides data, we call it the *server*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求的设备通过握手响应发送确认时，它们建立了它们的通信。之后，设备开始交换数据。这标志着握手过程的结束。我们通常称请求数据的设备为*客户端*。至于提供数据的设备，我们称它为*服务器*。
- en: Note that we use these names for the very first interaction. After this first
    interaction, it is common that these roles change. In that sense, communication
    is *dynamic*. The server may request data from the client, and the client may
    provide data to the server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们第一次交互时使用这些名称。在这第一次交互之后，这些角色发生变化是很常见的。从这个意义上说，沟通是*动态的*。服务器可能从客户端请求数据，而客户端可能向服务器提供数据。
- en: 'In this chapter, we are going to make our first handshake using the Godot Engine
    Network API. We’ll also create and synchronize players’ data across the network.
    So, hold tight, as you’ll learn the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Godot引擎网络API进行我们的第一次握手。我们还将创建和同步网络上的玩家数据。所以，请系好安全带，因为你将学习以下内容：
- en: What the ENet library is and why we use it for games
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ENet库是什么以及为什么我们在游戏中使用它
- en: How we can make a handshake using the `ENetMultiplayerPeer` class
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`ENetMultiplayerPeer`类进行握手
- en: For that, you’ll create a Godot project that lists connected players and allows
    them to edit and sync a line of text. It’s a simple but elegant project that covers
    the basics of setting up an online multiplayer environment in Godot Engine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你将创建一个 Godot 项目，该项目列出已连接的玩家并允许他们编辑和同步一行文本。这是一个简单而优雅的项目，涵盖了在 Godot 引擎中设置在线多人环境的基础。
- en: Understanding the ENetMultiplayerPeer class
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ENetMultiplayerPeer 类
- en: One of the Godot Engine Network API’s core features is the `ENetMultiplayerPeer`
    class. By using this class, we can perform a handshake between our game server
    and clients.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎网络 API 的核心特性之一是 `ENetMultiplayerPeer` 类。通过使用这个类，我们可以在我们的游戏服务器和客户端之间执行握手。
- en: The `ENetMultiplayerPeer` class is a high-level implementation of the ENet library.
    Let’s understand this library and why we use it in online multiplayer games.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENetMultiplayerPeer` 类是 ENet 库的高级实现。让我们了解这个库以及为什么我们在在线多人游戏中使用它。'
- en: What is the ENet library?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENet 库是什么？
- en: '**ENet** is a lightweight, open source networking library that is widely used
    in the game development industry. It is designed to be a high-performance, reliable,
    and easy-to-use library for creating multiplayer games and other networked applications.
    One advantage of the ENet library is that it’s cross-platform and written in **C**.
    So, it’s efficient with a small footprint and low overhead.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**ENet**是一个轻量级、开源的网络库，在游戏开发行业中广泛使用。它被设计成一个高性能、可靠且易于使用的库，用于创建多人游戏和其他网络应用。ENet
    库的一个优点是它是跨平台的，用 **C** 语言编写。因此，它具有小体积和低开销。'
- en: The library provides a simple and easy-to-use API that makes it easy for developers
    to create and manage network connections, send and receive packets, and handle
    network events such as disconnections and packet loss.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了一个简单且易于使用的 API，使得开发者能够轻松创建和管理网络连接，发送和接收数据包，并处理网络事件，如断开连接和数据包丢失。
- en: '**Packets**, in this context, are small units of data that servers and clients
    transmit over the network. We use them to transmit information such as game state,
    player input, and other types of data between different devices on the network.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，**数据包**是服务器和客户端在网络中传输的小数据单元。我们使用它们在网络上不同设备之间传输诸如游戏状态、玩家输入和其他类型的数据。
- en: The ENet library offers support for multiple channels that allow us to easily
    create multiple streams of data, such as voice and video, within a single connection.
    This is excellent for many multiplayer games.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ENet 库提供了对多个通道的支持，使我们能够轻松地在单个连接中创建多个数据流，如语音和视频。这对于许多多人游戏来说是非常出色的。
- en: Another reason to use ENet in multiplayer games is its easy-to-use networking
    library that is based on the UDP protocol. This is a good chance to understand
    one of the main network protocols, so let’s do it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中使用 ENet 的另一个原因是它易于使用的基于 UDP 协议的网络库。这是一个了解主要网络协议之一的好机会，让我们来做这件事。
- en: What is the UDP protocol?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP 协议是什么？
- en: The **UDP protocol** is a connectionless protocol that is well suited for real-time,
    high-bandwidth applications such as online gaming. This is because it has low
    latency and is able to handle high throughput. Just so we are on the same page,
    in the world of network terms, latency refers to the time between the transmission
    and receiving of data through the network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP 协议**是一种无连接协议，非常适合实时、高带宽的应用，如在线游戏。这是因为它具有低延迟并能处理高吞吐量。为了保持一致，在网络术语的世界里，延迟指的是数据通过网络传输和接收的时间。'
- en: 'For instance, it’s very common to talk about lag in online multiplayer games:
    the time between the player performing an action and the game reacting to it.
    The next figure illustrates how latency works and is calculated:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在在线多人游戏中谈论延迟是非常常见的：玩家执行动作和游戏对其做出反应之间的时间。下一图展示了延迟是如何工作以及如何计算的：
- en: '![Figure 1.2 – Visual demonstration of latency](img/Figure_01.02_B18527.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 延迟的视觉演示](img/Figure_01.02_B18527.jpg)'
- en: Figure 1.2 – Visual demonstration of latency
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 延迟的视觉演示
- en: It’s basically how much time it takes for data to cross the network, be properly
    handled by the server, and to provide a response to the client.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是指数据穿越网络、由服务器正确处理并向客户端提供响应所需的时间。
- en: 'Throughput refers to how much data we can send through a given network route
    within a time period before it gets overwhelmed. For instance, this is a fundamental
    concept when we talk about **DDoS attacks**, where hackers overwhelm the server
    with an immense number of unsolved requests, preventing other clients from accessing
    the service. In the following figure, you can see a visual representation of the
    throughput concept:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽是指在一定时间内，我们可以通过给定的网络路由发送多少数据，在它被淹没之前。例如，当我们谈论**DDoS攻击**时，这是一个基本概念，黑客通过大量的未解决请求淹没服务器，阻止其他客户端访问服务。在以下图中，你可以看到带宽概念的视觉表示：
- en: '![Figure 1.3 – Visual demonstration of throughput](img/Figure_01.03_B18527.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 带宽的视觉演示](img/Figure_01.03_B18527.jpg)'
- en: Figure 1.3 – Visual demonstration of throughput
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 带宽的视觉演示
- en: 'The bandwidth is how big the available channel of communication in the network
    is. You can think of it as a pipe that streams data. A bigger pipe allows a lot
    of data, and big data, to be transmitted at any given time, while a small pipe
    may not even allow any data, of any size, to be transmitted. You can see this
    concept illustrated in the following figure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽是指网络中可用通信通道的大小。你可以将其想象为一个传输数据的管道。更大的管道允许在任意给定时间内传输大量数据，而较小的管道可能甚至不允许传输任何大小数据。你可以在以下图中看到这一概念的解释：
- en: '![Figure 1.4 – Visual demonstration of bandwidth](img/Figure_01.04_B18527.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 带宽的视觉演示](img/Figure_01.04_B18527.jpg)'
- en: Figure 1.4 – Visual demonstration of bandwidth
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 带宽的视觉演示
- en: Unlike the more commonly used **Transmission Control Protocol** (**TCP**), **User
    Datagram Protocol** (**UDP**) does not establish a dedicated connection between
    two devices before transmitting data. Instead, it simply sends packets of data
    to a specified destination address without ensuring that the packets have been
    received or acknowledged.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与更常用的**传输控制协议**（**TCP**）不同，**用户数据报协议**（**UDP**）在传输数据之前并不在两个设备之间建立专用连接。相反，它只是将数据包发送到指定的目标地址，而不确保数据包已被接收或确认。
- en: Sounds… bad, right? But it’s quite the opposite.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来…很糟糕，对吧？但实际上恰恰相反。
- en: This lack of reliability is often seen as a drawback of UDP, but in the context
    of online multiplayer games, it can actually be an advantage. In games, where
    responsiveness and low latency are critical, the overhead of establishing and
    maintaining a connection can be a significant bottleneck.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏可靠性通常被视为UDP的缺点，但在在线多人游戏的环境中，这实际上可以是一个优势。在游戏中，响应速度和低延迟至关重要，建立和维护连接的开销可能是一个重要的瓶颈。
- en: By not requiring a dedicated connection, UDP allows for faster and more efficient
    transmission of data. Additionally, since UDP does not require the receiver to
    acknowledge receipt of packets, it is less affected by network congestion or delays,
    which can be critical for maintaining a stable and responsive connection in a
    high-bandwidth, high-latency environment such as online gaming.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP不需要专用连接，因此允许更快、更有效地传输数据。此外，由于UDP不需要接收方确认接收数据包，因此它受网络拥塞或延迟的影响较小，这在维护高带宽、高延迟环境（如在线游戏）中的稳定和响应性连接时可能至关重要。
- en: Furthermore, the lack of reliability of UDP can actually be beneficial in the
    context of online multiplayer games. In games, where a small amount of packet
    loss or delay can have a large impact on the players’ experience, it’s important
    that the game can adapt to these types of network conditions. By not providing
    guarantees on packet delivery, UDP allows the game to handle packet loss and delay
    in a way that is most appropriate for the specific game and its mechanics.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，UDP的不可靠性在在线多人游戏的环境中实际上可能是有益的。在游戏中，即使是一小部分数据包丢失或延迟也可能对玩家的体验产生重大影响，因此游戏能够适应这些类型的网络条件非常重要。通过不提供数据包投递的保证，UDP允许游戏以最适合特定游戏及其机制的方式处理数据包丢失和延迟。
- en: Think about the following situation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况。
- en: We establish a connection. In this connection, we update all players in the
    network about all other player avatars’ positions in the world. This way, everyone
    shares the same world state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立连接。在这个连接中，我们向网络中的所有玩家更新关于其他玩家角色在世界中的位置。这样，每个人共享相同的世界状态。
- en: If we use a TCP protocol, everyone will have to wait for every other player
    to send their position and confirm that they have received every change in every
    other player’s position, while also trying to maintain the correct chronological
    order in which the positions have changed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用TCP协议，每个人都必须等待每个其他玩家发送他们的位置并确认他们已经收到了每个其他玩家位置的变化，同时还要尝试保持位置变化的正确时间顺序。
- en: So, in this example, if a player moves five units to the left and sends 15 packets
    with all the movement data, including being idle, all other players must confirm
    that they have received all those 15 packets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，如果一个玩家向左移动五个单位并发送了包含所有移动数据的15个数据包，包括空闲状态，所有其他玩家都必须确认他们已经收到了这15个数据包。
- en: 'Using UDP, players can ignore every update but the latest one, which is the
    only relevant piece of information in real-time experience: what is the game-world
    state *now*? It doesn’t matter how it gets to this point; it only matters that
    it is there at this very moment.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP，玩家可以忽略除最新更新之外的所有更新，这是实时体验中唯一相关的信息：现在游戏世界的状态是什么？它如何到达这个点并不重要；重要的是它就在这个时刻。
- en: We are going to see that this causes some trouble as well. But we can create
    methods and understand techniques to mitigate those issues. We are going to talk
    about that in further chapters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这也会带来一些麻烦。但我们可以创建方法并理解技术来减轻这些问题。我们将在后续章节中讨论这一点。
- en: How does this connection happen?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这连接是如何发生的？
- en: 'To establish a UDP connection, we need two core things:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立UDP连接，我们需要两个核心要素：
- en: The IP address of the peers, mainly the server
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同伴的IP地址，主要是服务器
- en: The port over which they will exchange data
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们将交换数据的端口
- en: For test purposes, on all our projects we are going to use the `localhost` IP
    address. This is a shortcut to your local IP address mask. An IP address is like
    a house or apartment address. It is the exact location to which a given packet
    should be delivered and represents the address of the computer in the network.
    A port is essentially a specific channel in which the host allows a given communication
    to be established; we’ll use the `9999` as our default port. There’s nothing special
    about this one; it’s just an arbitrary pick.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，在我们所有的项目中，我们将使用`localhost` IP地址。这是到你的本地IP地址掩码的快捷方式。IP地址就像一个房子或公寓的地址。它是给定数据包应该送达的确切位置，代表了计算机在网络中的地址。端口基本上是主机允许建立给定通信的特定通道；我们将使用`9999`作为我们的默认端口。这没有什么特别之处；它只是一个任意的选择。
- en: With this in mind, let’s see for the first time the `ENetMultiplayerPeer` class
    in action. As you can imagine, this setup requires a two-sided approach. We need
    to set up a game architecture for our server and a different architecture for
    our client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们第一次看看`ENetMultiplayerPeer`类的实际应用。正如你可以想象的，这种设置需要双方面的方法。我们需要为我们的服务器设置一个游戏架构，并为客户端设置不同的架构。
- en: Let’s start with the server architecture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器架构开始。
- en: Creating the server
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建服务器
- en: 'The `ENetMultiplayerPeer` class in the Godot Engine provides a convenient way
    to create and manage network connections for online multiplayer games. One of
    the most important methods of this class is the `create_server()` method, which
    is used to create a new server that can accept connections from clients. This
    method is simple to use and, besides having five arguments, it only requires one
    to get started:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Godot引擎中的`ENetMultiplayerPeer`类提供了一个方便的方式来创建和管理在线多人游戏的网络连接。这个类最重要的方法之一是`create_server()`方法，它用于创建一个新的服务器，该服务器可以接受来自客户端的连接。此方法使用简单，除了有五个参数外，它只需要一个参数就可以开始：
- en: The first argument of the `ENetMultiplayerPeer.create_server()` method is the
    port on which the server will listen for incoming connections. This is the port
    number that clients will use to connect to the server. For example, if you want
    the server to listen on port `9999`, you would call `ENetMultiplayerPeer.create_server(9999)`.
    This is the only mandatory argument to call this method.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENetMultiplayerPeer.create_server()`方法的第一个参数是服务器将监听传入连接的端口。这是客户端将用于连接服务器的端口号。例如，如果你想服务器在端口`9999`上监听，你会调用`ENetMultiplayerPeer.create_server(9999)`。这是调用此方法的唯一必需参数。'
- en: The second argument is `max_clients`, which is the maximum number of clients
    that the server will allow to connect at the same time. This argument is optional,
    and if not specified, the server will allow up to 4,095 clients to connect.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是 `max_clients`，这是服务器允许同时连接的最大客户端数。此参数是可选的，如果没有指定，服务器将允许最多 4,095 个客户端连接。
- en: The third argument is `max_channels`, which is the maximum number of channels
    we allow the server to use per client. Channels are used to separate different
    types of data, such as voice and video, and are useful for creating multiple streams
    of data within a single connection. This argument is optional, and if not specified,
    the server will allow an unlimited number of channels.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是 `max_channels`，这是服务器允许每个客户端使用的最大通道数。通道用于分离不同类型的数据，例如语音和视频，并且对于在单个连接中创建多个数据流非常有用。此参数是可选的，如果没有指定，服务器将允许无限数量的通道。
- en: The fourth argument is `in_bandwidth`, which is the maximum incoming bandwidth
    that the server will allow per client. This argument is optional, and if not specified,
    the server will allow unlimited incoming bandwidth.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是 `in_bandwidth`，这是服务器允许每个客户端的最大入带宽。此参数是可选的，如果没有指定，服务器将允许无限入带宽。
- en: The fifth argument is `out_bandwidth`, which is the maximum outgoing bandwidth
    that the server will allow per client. This argument is optional, and if not specified,
    the server will allow unlimited outgoing bandwidth.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数是 `out_bandwidth`，这是服务器允许每个客户端的最大出带宽。此参数是可选的，如果没有指定，服务器将允许无限出带宽。
- en: 'Let’s create our server in Godot Engine. Open up the project provided in the
    GitHub link given previously. After opening the project, execute the following
    steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Godot Engine 中创建我们的服务器。打开之前提供的 GitHub 链接中的项目。打开项目后，执行以下步骤：
- en: Create a new scene and use a `Node` instance as the root.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景并使用 `Node` 实例作为根节点。
- en: Attach a new `Server.gd`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `Server.gd` 文件。
- en: Save the scene and open the script.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并打开脚本。
- en: 'Define a constant called `PORT` and set it to our default port number so the
    server can listen to it:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `PORT` 的常量并将其设置为我们的默认端口号，以便服务器可以监听它：
- en: '[PRE0]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new `ENetMultiplayerPeer` using the `new()` constructor. Let’s store
    it in a variable called `peer`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `new()` 构造函数创建一个新的 `ENetMultiplayerPeer`。让我们将其存储在一个名为 `peer` 的变量中：
- en: '[PRE1]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `_ready()` function, call the `create_server()` method on the `peer`
    variable, passing in the `PORT` constant as an argument:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ready()` 函数中，调用 `peer` 变量的 `create_server()` 方法，并将 `PORT` 常量作为参数传入：
- en: '[PRE2]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still in the `_ready()` callback, assign the `peer` variable to the built-in
    `multiplayer` member variable of this node:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `_ready()` 回调中，将 `peer` 变量分配给此节点内置的 `multiplayer` 成员变量：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Connect the `peer_connected` signal of the `multiplayer` variable to a function
    called `_on_peer_connected`. We’ll create this callback method next:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `multiplayer` 变量的 `peer_connected` 信号连接到名为 `_on_peer_connected` 的函数。我们将在下面创建此回调方法：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new method called `_on_peer_connected()`, which should receive `peer_id`
    as the argument:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `_on_peer_connected()` 的新方法，它应该接收 `peer_id` 作为参数：
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `_on_peer_connected()` function, use `print()` to print the passed `peer_id`
    argument on the console:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_on_peer_connected()` 函数中，使用 `print()` 在控制台上打印传递的 `peer_id` 参数：
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The complete script should look like this:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的脚本应该看起来像这样：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s important to note that this script uses the built-in `multiplayer` member
    variable that every `Node` instance has on Godot Engine 4.0 Network API, which
    is an instance of the `MultiplayerAPI` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，此脚本使用了 Godot Engine 4.0 网络 API 中每个 `Node` 实例都有的内置 `multiplayer` 成员变量，它是一个
    `MultiplayerAPI` 类的实例。
- en: 'Done: we have our server ready. Told you it would be simple!'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成：我们的服务器已经准备好了。我告诉过你，这会很简单！
- en: Creating the client
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建客户端
- en: Next up, let’s create our client. The process is quite similar. The major difference
    is that the client needs the server IP address to find it on the network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的客户端。过程相当相似。主要区别是客户端需要服务器的 IP 地址才能在网络中找到它。
- en: 'We use the `ENetMultiplayerPeer.create_client()` method to connect a client
    to a server. This method is very simple to use and requires only two arguments
    to work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ENetMultiplayerPeer.create_client()` 方法将客户端连接到服务器。此方法非常简单易用，并且只需要两个参数即可工作：
- en: The first argument of the `create_client()` method is the address of the server.
    This can be either the server’s IP or hostname. For instance, if you want the
    client to connect to a server with the IP address `192.168.1.1`, you would call
    `create_client("192.168.1.1")`. But to make things simpler, we’ll use `"localhost"`,
    which is a shortcut to our own IP address mask.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_client()` 方法的第一个参数是服务器的地址。这可以是服务器的 IP 地址或主机名。例如，如果您想客户端连接到 IP 地址为 `192.168.1.1`
    的服务器，您将调用 `create_client("192.168.1.1")`。但为了简化，我们将使用 `"localhost"`，这是指向我们自己的 IP
    地址掩码的快捷方式。'
- en: The second argument of the `create_client()` method is the port on which the
    server is listening for incoming connections. This is the port number that the
    client will use to connect to the server. For example, if the server is listening
    on port `9999`, you would call `create_client("192.168.1.1", 9999)`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_client()` 方法的第二个参数是服务器监听传入连接的端口。这是客户端将用于连接到服务器的端口号。例如，如果服务器正在监听端口 `9999`，您将调用
    `create_client("192.168.1.1", 9999)`。'
- en: The third argument of the `create_client()` method is `channel_count`, which
    is the number of channels that the client will use to communicate with the server.
    Channels are used to separate different types of data, such as voice and video,
    and are useful for creating multiple streams of data within a single connection.
    This argument is optional, and if not specified, the client will use a default
    value of `1` channel.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_client()` 方法的第三个参数是 `channel_count`，这是客户端将用于与服务器通信的通道数。通道用于分离不同类型的数据，例如语音和视频，并在单个连接内创建多个数据流非常有用。此参数是可选的，如果未指定，客户端将使用默认值
    `1` 个通道。'
- en: The fourth argument of the `create_client()` method is `in_bandwidth`, which
    is the maximum incoming bandwidth that the client will allow per connection. This
    argument is optional, and if not specified, the client will use a default value
    of `0`, allowing an unlimited incoming bandwidth.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_client()` 方法的第四个参数是 `in_bandwidth`，这是客户端在每个连接中允许的最大传入带宽。此参数是可选的，如果未指定，客户端将使用默认值
    `0`，允许无限的传入带宽。'
- en: The fifth argument of the `create_client()` method is `out_bandwidth`, which
    is the maximum outgoing bandwidth that the client will allow per connection. This
    argument is optional, and if not specified, the client will use a default value
    of `0`, allowing an unlimited outgoing bandwidth.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_client()` 方法的第五个参数是 `out_bandwidth`，这是客户端在每个连接中允许的最大传出带宽。此参数是可选的，如果未指定，客户端将使用默认值
    `0`，允许无限的传出带宽。'
- en: The sixth argument of the `create_client()` method is `local_port`, which is
    the local port that the client will bind to. This argument is optional, and if
    not specified, the client will use a default value of `0`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_client()` 方法的第六个参数是 `local_port`，这是客户端将绑定到的本地端口。此参数是可选的，如果未指定，客户端将使用默认值
    `0`。'
- en: 'Now, let’s see how we can create the *client* side of this connection so it
    can connect with our *server* and establish their handshake:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何创建连接的 *客户端* 部分，以便它可以连接到我们的 *服务器* 并建立握手：
- en: Create a new scene and add a `Node` instance as the root.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个 `Node` 实例作为根节点。
- en: Attach a new script to it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的脚本附加到它上面。
- en: Save the script as `Client.gd`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 `Client.gd`。
- en: 'In the script, define a constant called `ADDRESS` and set it to the server’s
    IP. In this case, we are going to use `"localhost"`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中定义一个名为 `ADDRESS` 的常量，并将其设置为服务器的 IP 地址。在这种情况下，我们将使用 `"localhost"`：
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a constant called `PORT` and set it to be our default port number. It’s
    very important that this matches the number we used in `Server.gd`, otherwise
    these peers won’t be able to find each other:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `PORT` 的常量，并将其设置为默认端口号。确保这个数字与我们在 `Server.gd` 中使用的数字相匹配非常重要，否则这些对等体将无法找到彼此：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new `ENetMultiplayerPeer` using the `new()` constructor and store
    it in a variable called `peer`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `new()` 构造函数创建一个新的 `ENetMultiplayerPeer` 并将其存储在名为 `peer` 的变量中：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `_ready()` callback, call the `create_client()` method on the `peer`
    variable, passing in the `ADDRESS` and `PORT` constants as arguments:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ready()` 回调中，调用 `peer` 变量上的 `create_client()` 方法，传入 `ADDRESS` 和 `PORT` 常量作为参数：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Assign the `peer` variable to the built-in `multiplayer` member variable of
    the node:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `peer` 变量分配给节点的内置 `multiplayer` 成员变量：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The complete script should look like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的脚本应该看起来像这样：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Alright, we have our server and our client ready. Now, how do we test them?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的服务器和客户端已经准备好了。现在，我们该如何测试它们呢？
- en: Testing our handshake
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的握手
- en: 'Godot Engine 4.0 has a useful feature for debugging: the ability to open multiple
    independent instances of the game. This feature allows us to test different scenes
    at the same time, making the debugging process much easier and faster.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎 4.0 拥有一个有用的调试功能：能够打开多个独立的游戏实例。这个功能允许我们同时测试不同的场景，使调试过程更加容易和快速。
- en: To open multiple instances of the game, we need to select one option from up
    to four options in the **Debug** | **Run Multiple** **Instances** menu.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开多个游戏实例，我们需要在 **Debug** | **Run Multiple Instances** 菜单中的最多四个选项中选择一个。
- en: '![Figure 1.5 – The Run Multiple Instances menu](img/Figure_01.05_B18527.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 运行多个实例菜单](img/Figure_01.05_B18527.jpg)'
- en: Figure 1.5 – The Run Multiple Instances menu
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 运行多个实例菜单
- en: Then, as soon as we press the **Run Project** or **Run Current Scene** button,
    Godot will launch the instances we’ve set previously. Let’s stick with two instances
    for this project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们按下 **Run Project** 或 **Run Current Scene** 按钮时，Godot 将启动我们之前设置的实例。让我们在这个项目中坚持使用两个实例。
- en: This feature is incredibly useful for testing online multiplayer games, as it
    allows us to open a server and a client in the same run. But, as you can see,
    it’s not very straightforward. When we run the project, it actually opens two
    instances of the same scene.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能对于测试在线多人游戏非常有用，因为它允许我们在同一运行中打开服务器和客户端。但是，正如你所看到的，它并不直接。当我们运行项目时，它实际上打开了同一场景的两个实例。
- en: 'Let’s create a minimal menu where we can select whether we are a client or
    a server:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个最小的菜单，我们可以选择我们是客户端还是服务器：
- en: Create a new scene and use `Control` as the root and name it `MainMenu`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，使用 `Control` 作为根节点并将其命名为 `MainMenu`。
- en: Add a `Label` node as a child of the root node.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Label` 节点作为根节点的子节点添加。
- en: Add two `Button` nodes as children of the root node.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个 `Button` 节点作为根节点的子节点添加。
- en: 'Give the first `Button` the name `ClientButton` and the second one `ServerButton`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个 `Button` 命名为 `ClientButton`，第二个命名为 `ServerButton`：
- en: '![Figure 1.6 – MainMenu’s Scene tree structure](img/Figure_01.06_B18527.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – `MainMenu` 的场景树结构](img/Figure_01.06_B18527.jpg)'
- en: Figure 1.6 – MainMenu’s Scene tree structure
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – `MainMenu` 的场景树结构
- en: Set the `Button` nodes’ `text` properties to **I’m a client** and **I’m a server**
    respectively and position them side by side in the middle of the screen.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Button` 节点的 `text` 属性分别设置为 **I’m a client** 和 **I’m a server** 并将它们并排放置在屏幕中间。
- en: Set the `Label` node’s `text` property to **Are you a…** and position it in
    the middle of the screen.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Label` 节点的 `text` 属性设置为 **Are you a…** 并将其放置在屏幕中间。
- en: '![Figure 1.7 – MainMenu’s scene UI](img/Figure_01.07_B18527.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – `MainMenu` 的场景 UI](img/Figure_01.07_B18527.jpg)'
- en: Figure 1.7 – MainMenu’s scene UI
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – `MainMenu` 的场景 UI
- en: Attach a new `MainMenu` node and open it.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `MainMenu` 节点并打开它。
- en: Connect the `_on_client_button_pressed`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接 `_on_client_button_pressed`。
- en: '![Figure 1.8 – ClientButton’s pressed signal connection](img/Figure_01.08_B18527.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – ClientButton 的按下信号连接](img/Figure_01.08_B18527.jpg)'
- en: Figure 1.8 – ClientButton’s pressed signal connection
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – ClientButton 的按下信号连接
- en: Connect the pressed signal of the `_on_server_button_pressed`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接 `_on_server_button_pressed` 的按下信号。
- en: 'In the `_on_client_button_pressed()` callback, let’s call the `change_scene_to_file()`
    method on the `get_tree()` instance, passing in `"res://Client.tscn"` as the argument:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_on_client_button_pressed()` 回调中，让我们在 `get_tree()` 实例上调用 `change_scene_to_file()`
    方法，传入 `"res://Client.tscn"` 作为参数：
- en: '[PRE14]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `_on_server_button_pressed()` callback, do the same as before, passing
    `"``res://Server.tscn"` instead.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_on_server_button_pressed()` 回调中，与之前相同，传入 `"res://Server.tscn"` 代替。
- en: 'The complete script should look like this:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的脚本应该看起来像这样：
- en: '[PRE15]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let’s make sure we save the scene before we test it. After that, all we
    need to do is hit the **Run Current Scene** button and watch the scene come to
    life. All the hard work has been done, and now all that’s left is to appreciate
    the results.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保在测试之前保存场景。之后，我们只需要点击 **Run Current Scene** 按钮并观察场景变得生动。所有艰苦的工作都已经完成，现在我们只需要欣赏结果。
- en: Once we have the two debug instances running, we need to pick one to be the
    server first. For that, we can press `Server.tscn` scene and start listening for
    incoming connections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有两个调试实例正在运行，我们需要先选择一个作为服务器。为此，我们可以按下 `Server.tscn` 场景并开始监听传入的连接。
- en: Then, in the other instance, we need to press `Client.tscn` scene and try to
    connect to the server. If everything goes as expected, we should get `peer_id`
    printed in the console of the server instance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个实例中，我们需要按下`Client.tscn`场景并尝试连接到服务器。如果一切如预期进行，我们应该在服务器实例的控制台中看到打印出的`peer_id`。
- en: This means that the client and the server have successfully established a connection
    and are now ready to start exchanging messages. Congratulations, you’ve just created
    your first handshake!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端和服务器已经成功建立了连接，现在可以开始交换消息了。恭喜你，你刚刚创建了你第一个握手！
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the fundamentals of network connections, which
    is to establish the connection through a procedure known as the handshake.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了网络连接的基础，即通过称为握手的程序建立连接。
- en: The handshake ensures that two computers recognize each other in a network and
    establish the protocols of this communication. This is important to understand,
    as it is the core of all our further endeavors. Without this at our disposal,
    our players and our server would be disconnected. One would be sending data to
    the void, while the other would be infinitely waiting for something to arrive.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 握手确保两台计算机在网络中相互识别并建立这种通信的协议。这一点非常重要，因为这是我们所有进一步努力的基石。如果没有这个，我们的玩家和服务器将会断开连接。一个将会向虚空发送数据，而另一个将会无限期地等待某物到来。
- en: Talking about sending data, now that we have our computers connected and open
    to receive and send data back and forth, it’s time to see how to do that. Throughout
    this chapter, you saw how you can properly establish a connection using the ENet
    library and how Godot Engine provides a high-level approach to handshaking, to
    the point that we can barely see if there was an actual handshake or not.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 说到发送数据，既然我们的计算机已经连接并开放以接收和发送数据，现在是时候看看如何做到这一点了。在本章中，你看到了如何使用ENet库正确建立连接，以及Godot引擎如何提供高级别的握手方法，以至于我们几乎看不到是否真的发生了握手。
- en: In the next chapter, we are going to use the UDP protocol to also establish
    a connection between client and server. But this time, we are going to dig a bit
    further and actually send data both from the client to the server and the other
    way around.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用UDP协议来在客户端和服务器之间建立连接。但这一次，我们将进一步挖掘，并实际上从客户端向服务器发送数据，以及反过来。
- en: It’s important to use the UDP protocol to understand what might be happening
    under the hood when we finally start to get used to the Godot Engine `ENetMultiplayer`
    API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP协议来理解当我们最终开始习惯Godot引擎的`ENetMultiplayer` API时，底层可能发生的事情是非常重要的。
- en: Now let’s see the dirty and messy world of low-level data transmission in the
    next chapter, so we can understand later how much easier our lives are made with
    the new high-level network API!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看下一章中低级数据传输的混乱世界，这样我们就可以理解，有了新的高级网络API，我们的生活将变得多么容易！
