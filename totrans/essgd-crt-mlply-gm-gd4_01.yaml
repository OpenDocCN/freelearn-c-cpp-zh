- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *The Essential Guide to Creating Multiplayer Games with Godot 4.0*.
    In this hands-on book, you are going to learn the core concepts used to create
    online multiplayer games using the Godot Engine 4.0 Network API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we are going to understand some fundamental aspects of how computers
    communicate through a network and the main protocols, including which ones are
    more relevant for making online multiplayer games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will understand how Godot Engine 4.0 uses and provides both low-
    and high-level implementations for networking using its network API. We’ll understand
    some core classes that we can use to pass data around to multiple computers on
    the same network. And then we’ll focus on the high-level API known as `ENetMultiplayerPeer`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'With the fundamentals in place, we’ll use the knowledge we just learned to
    turn local gameplay features into online gameplay features. To do that, we will
    develop five game projects:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: An online quiz game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pong
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A co-op platformer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A top-down adventure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we’ll learn some techniques we can use to improve our players’ experience
    by optimizing how their game sends, receives, and processes network data. We’ll
    understand that we don’t need constant updates and that we can do most of the
    gameplay with small bits of data and let the clients’ computers fill the gaps
    on their own.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Throughout each chapter, you’re going to do a role play of a network engineer
    working for a fictional, independent game development studio. In each chapter,
    you will apply your recently learned knowledge to a fictional problem presented
    by your studio’s peers. You’ll focus on the network aspect of each project they
    present, so you don’t waste your precious time trying to understand unnecessary
    aspects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you are going to learn the most important aspect of establishing
    a network of computers: to connect them all together. You’ll see how this process
    happens, the reason for doing this, what’s required to establish this connection,
    and how we can do that using the API that Godot Engine provides.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to a network
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Godot Engine Network API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the client side
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the server side
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your first handshake
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have a client and server version of an application
    that establishes the connection of two or more computers. This is the very core
    of everything that we are going to see throughout the book, and with that knowledge,
    you’ll understand how you can start making computers communicate within a network,
    which is exactly what you need to do in online multiplayer games.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Godot Engine has its own standalone text editor, which is what we are going
    to use to code all our practical lessons.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, in this book you will do a role play of a network engineer
    of a fictional indie game studio. So, we will provide pre-made projects with all
    the non-network-related work ready. You can find them in the book’s GitHub repository:
    [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: With the project properly added to your Godot Engine’s project manager, open
    the project and move on to the `res://01.setting-up-a-server` folder. Here, you'll
    find what you need to follow this chapter (later part).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to a network
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a network of connected computers is quite a task. In this chapter, we’ll
    understand the core concepts of online networks. We’ll also cover how Godot Engine
    provides solutions to each of the problems we may face in our quest to make online
    multiplayer games.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A **network** is a collection of interconnected devices that communicate with
    each other. In this communication, these devices exchange information and share
    resources with each other. You can have a local network, such as in a house or
    office, or a global network, such as the internet. The idea is the same.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: For these devices to communicate they need to perform what we call a **handshake**.
    A handshake is how one device recognizes another device and establishes their
    communication protocols. This way, they know what they can request, what they
    expect to get, and what they need to send to one another.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: A handshake begins with one device sending a message to another device. We call
    this message a *handshake request*. The devices use this message to start the
    handshake process. The one that sent the request waits for a message from the
    one that received it. We call this second message a *handshake response*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The handshake procedure](img/Figure_01.01_B18527.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The handshake procedure
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: When the requested device sends the confirmation through the handshake response,
    they establish their communication. After that, the devices start exchanging data.
    This wraps up the handshake process. We usually call the device that requests
    data the *client*. As for the one that provides data, we call it the *server*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use these names for the very first interaction. After this first
    interaction, it is common that these roles change. In that sense, communication
    is *dynamic*. The server may request data from the client, and the client may
    provide data to the server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to make our first handshake using the Godot Engine
    Network API. We’ll also create and synchronize players’ data across the network.
    So, hold tight, as you’ll learn the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: What the ENet library is and why we use it for games
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can make a handshake using the `ENetMultiplayerPeer` class
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For that, you’ll create a Godot project that lists connected players and allows
    them to edit and sync a line of text. It’s a simple but elegant project that covers
    the basics of setting up an online multiplayer environment in Godot Engine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ENetMultiplayerPeer class
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the Godot Engine Network API’s core features is the `ENetMultiplayerPeer`
    class. By using this class, we can perform a handshake between our game server
    and clients.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The `ENetMultiplayerPeer` class is a high-level implementation of the ENet library.
    Let’s understand this library and why we use it in online multiplayer games.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: What is the ENet library?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ENet** is a lightweight, open source networking library that is widely used
    in the game development industry. It is designed to be a high-performance, reliable,
    and easy-to-use library for creating multiplayer games and other networked applications.
    One advantage of the ENet library is that it’s cross-platform and written in **C**.
    So, it’s efficient with a small footprint and low overhead.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The library provides a simple and easy-to-use API that makes it easy for developers
    to create and manage network connections, send and receive packets, and handle
    network events such as disconnections and packet loss.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Packets**, in this context, are small units of data that servers and clients
    transmit over the network. We use them to transmit information such as game state,
    player input, and other types of data between different devices on the network.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The ENet library offers support for multiple channels that allow us to easily
    create multiple streams of data, such as voice and video, within a single connection.
    This is excellent for many multiplayer games.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use ENet in multiplayer games is its easy-to-use networking
    library that is based on the UDP protocol. This is a good chance to understand
    one of the main network protocols, so let’s do it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: What is the UDP protocol?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **UDP protocol** is a connectionless protocol that is well suited for real-time,
    high-bandwidth applications such as online gaming. This is because it has low
    latency and is able to handle high throughput. Just so we are on the same page,
    in the world of network terms, latency refers to the time between the transmission
    and receiving of data through the network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, it’s very common to talk about lag in online multiplayer games:
    the time between the player performing an action and the game reacting to it.
    The next figure illustrates how latency works and is calculated:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Visual demonstration of latency](img/Figure_01.02_B18527.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Visual demonstration of latency
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: It’s basically how much time it takes for data to cross the network, be properly
    handled by the server, and to provide a response to the client.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughput refers to how much data we can send through a given network route
    within a time period before it gets overwhelmed. For instance, this is a fundamental
    concept when we talk about **DDoS attacks**, where hackers overwhelm the server
    with an immense number of unsolved requests, preventing other clients from accessing
    the service. In the following figure, you can see a visual representation of the
    throughput concept:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Visual demonstration of throughput](img/Figure_01.03_B18527.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Visual demonstration of throughput
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The bandwidth is how big the available channel of communication in the network
    is. You can think of it as a pipe that streams data. A bigger pipe allows a lot
    of data, and big data, to be transmitted at any given time, while a small pipe
    may not even allow any data, of any size, to be transmitted. You can see this
    concept illustrated in the following figure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Visual demonstration of bandwidth](img/Figure_01.04_B18527.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Visual demonstration of bandwidth
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the more commonly used **Transmission Control Protocol** (**TCP**), **User
    Datagram Protocol** (**UDP**) does not establish a dedicated connection between
    two devices before transmitting data. Instead, it simply sends packets of data
    to a specified destination address without ensuring that the packets have been
    received or acknowledged.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Sounds… bad, right? But it’s quite the opposite.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: This lack of reliability is often seen as a drawback of UDP, but in the context
    of online multiplayer games, it can actually be an advantage. In games, where
    responsiveness and low latency are critical, the overhead of establishing and
    maintaining a connection can be a significant bottleneck.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: By not requiring a dedicated connection, UDP allows for faster and more efficient
    transmission of data. Additionally, since UDP does not require the receiver to
    acknowledge receipt of packets, it is less affected by network congestion or delays,
    which can be critical for maintaining a stable and responsive connection in a
    high-bandwidth, high-latency environment such as online gaming.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the lack of reliability of UDP can actually be beneficial in the
    context of online multiplayer games. In games, where a small amount of packet
    loss or delay can have a large impact on the players’ experience, it’s important
    that the game can adapt to these types of network conditions. By not providing
    guarantees on packet delivery, UDP allows the game to handle packet loss and delay
    in a way that is most appropriate for the specific game and its mechanics.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Think about the following situation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: We establish a connection. In this connection, we update all players in the
    network about all other player avatars’ positions in the world. This way, everyone
    shares the same world state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: If we use a TCP protocol, everyone will have to wait for every other player
    to send their position and confirm that they have received every change in every
    other player’s position, while also trying to maintain the correct chronological
    order in which the positions have changed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: So, in this example, if a player moves five units to the left and sends 15 packets
    with all the movement data, including being idle, all other players must confirm
    that they have received all those 15 packets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Using UDP, players can ignore every update but the latest one, which is the
    only relevant piece of information in real-time experience: what is the game-world
    state *now*? It doesn’t matter how it gets to this point; it only matters that
    it is there at this very moment.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: We are going to see that this causes some trouble as well. But we can create
    methods and understand techniques to mitigate those issues. We are going to talk
    about that in further chapters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How does this connection happen?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To establish a UDP connection, we need two core things:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the peers, mainly the server
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port over which they will exchange data
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For test purposes, on all our projects we are going to use the `localhost` IP
    address. This is a shortcut to your local IP address mask. An IP address is like
    a house or apartment address. It is the exact location to which a given packet
    should be delivered and represents the address of the computer in the network.
    A port is essentially a specific channel in which the host allows a given communication
    to be established; we’ll use the `9999` as our default port. There’s nothing special
    about this one; it’s just an arbitrary pick.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s see for the first time the `ENetMultiplayerPeer` class
    in action. As you can imagine, this setup requires a two-sided approach. We need
    to set up a game architecture for our server and a different architecture for
    our client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the server architecture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Creating the server
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ENetMultiplayerPeer` class in the Godot Engine provides a convenient way
    to create and manage network connections for online multiplayer games. One of
    the most important methods of this class is the `create_server()` method, which
    is used to create a new server that can accept connections from clients. This
    method is simple to use and, besides having five arguments, it only requires one
    to get started:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of the `ENetMultiplayerPeer.create_server()` method is the
    port on which the server will listen for incoming connections. This is the port
    number that clients will use to connect to the server. For example, if you want
    the server to listen on port `9999`, you would call `ENetMultiplayerPeer.create_server(9999)`.
    This is the only mandatory argument to call this method.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is `max_clients`, which is the maximum number of clients
    that the server will allow to connect at the same time. This argument is optional,
    and if not specified, the server will allow up to 4,095 clients to connect.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third argument is `max_channels`, which is the maximum number of channels
    we allow the server to use per client. Channels are used to separate different
    types of data, such as voice and video, and are useful for creating multiple streams
    of data within a single connection. This argument is optional, and if not specified,
    the server will allow an unlimited number of channels.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth argument is `in_bandwidth`, which is the maximum incoming bandwidth
    that the server will allow per client. This argument is optional, and if not specified,
    the server will allow unlimited incoming bandwidth.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth argument is `out_bandwidth`, which is the maximum outgoing bandwidth
    that the server will allow per client. This argument is optional, and if not specified,
    the server will allow unlimited outgoing bandwidth.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create our server in Godot Engine. Open up the project provided in the
    GitHub link given previously. After opening the project, execute the following
    steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and use a `Node` instance as the root.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a new `Server.gd`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene and open the script.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a constant called `PORT` and set it to our default port number so the
    server can listen to it:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new `ENetMultiplayerPeer` using the `new()` constructor. Let’s store
    it in a variable called `peer`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `_ready()` function, call the `create_server()` method on the `peer`
    variable, passing in the `PORT` constant as an argument:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still in the `_ready()` callback, assign the `peer` variable to the built-in
    `multiplayer` member variable of this node:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Connect the `peer_connected` signal of the `multiplayer` variable to a function
    called `_on_peer_connected`. We’ll create this callback method next:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new method called `_on_peer_connected()`, which should receive `peer_id`
    as the argument:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `_on_peer_connected()` function, use `print()` to print the passed `peer_id`
    argument on the console:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The complete script should look like this:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s important to note that this script uses the built-in `multiplayer` member
    variable that every `Node` instance has on Godot Engine 4.0 Network API, which
    is an instance of the `MultiplayerAPI` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Done: we have our server ready. Told you it would be simple!'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Creating the client
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next up, let’s create our client. The process is quite similar. The major difference
    is that the client needs the server IP address to find it on the network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `ENetMultiplayerPeer.create_client()` method to connect a client
    to a server. This method is very simple to use and requires only two arguments
    to work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of the `create_client()` method is the address of the server.
    This can be either the server’s IP or hostname. For instance, if you want the
    client to connect to a server with the IP address `192.168.1.1`, you would call
    `create_client("192.168.1.1")`. But to make things simpler, we’ll use `"localhost"`,
    which is a shortcut to our own IP address mask.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument of the `create_client()` method is the port on which the
    server is listening for incoming connections. This is the port number that the
    client will use to connect to the server. For example, if the server is listening
    on port `9999`, you would call `create_client("192.168.1.1", 9999)`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third argument of the `create_client()` method is `channel_count`, which
    is the number of channels that the client will use to communicate with the server.
    Channels are used to separate different types of data, such as voice and video,
    and are useful for creating multiple streams of data within a single connection.
    This argument is optional, and if not specified, the client will use a default
    value of `1` channel.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth argument of the `create_client()` method is `in_bandwidth`, which
    is the maximum incoming bandwidth that the client will allow per connection. This
    argument is optional, and if not specified, the client will use a default value
    of `0`, allowing an unlimited incoming bandwidth.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth argument of the `create_client()` method is `out_bandwidth`, which
    is the maximum outgoing bandwidth that the client will allow per connection. This
    argument is optional, and if not specified, the client will use a default value
    of `0`, allowing an unlimited outgoing bandwidth.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sixth argument of the `create_client()` method is `local_port`, which is
    the local port that the client will bind to. This argument is optional, and if
    not specified, the client will use a default value of `0`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s see how we can create the *client* side of this connection so it
    can connect with our *server* and establish their handshake:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and add a `Node` instance as the root.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a new script to it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script as `Client.gd`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the script, define a constant called `ADDRESS` and set it to the server’s
    IP. In this case, we are going to use `"localhost"`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a constant called `PORT` and set it to be our default port number. It’s
    very important that this matches the number we used in `Server.gd`, otherwise
    these peers won’t be able to find each other:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new `ENetMultiplayerPeer` using the `new()` constructor and store
    it in a variable called `peer`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `_ready()` callback, call the `create_client()` method on the `peer`
    variable, passing in the `ADDRESS` and `PORT` constants as arguments:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Assign the `peer` variable to the built-in `multiplayer` member variable of
    the node:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The complete script should look like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Alright, we have our server and our client ready. Now, how do we test them?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Testing our handshake
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Godot Engine 4.0 has a useful feature for debugging: the ability to open multiple
    independent instances of the game. This feature allows us to test different scenes
    at the same time, making the debugging process much easier and faster.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: To open multiple instances of the game, we need to select one option from up
    to four options in the **Debug** | **Run Multiple** **Instances** menu.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – The Run Multiple Instances menu](img/Figure_01.05_B18527.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – The Run Multiple Instances menu
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Then, as soon as we press the **Run Project** or **Run Current Scene** button,
    Godot will launch the instances we’ve set previously. Let’s stick with two instances
    for this project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This feature is incredibly useful for testing online multiplayer games, as it
    allows us to open a server and a client in the same run. But, as you can see,
    it’s not very straightforward. When we run the project, it actually opens two
    instances of the same scene.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a minimal menu where we can select whether we are a client or
    a server:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and use `Control` as the root and name it `MainMenu`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Label` node as a child of the root node.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two `Button` nodes as children of the root node.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the first `Button` the name `ClientButton` and the second one `ServerButton`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – MainMenu’s Scene tree structure](img/Figure_01.06_B18527.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – MainMenu’s Scene tree structure
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Button` nodes’ `text` properties to **I’m a client** and **I’m a server**
    respectively and position them side by side in the middle of the screen.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Label` node’s `text` property to **Are you a…** and position it in
    the middle of the screen.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.7 – MainMenu’s scene UI](img/Figure_01.07_B18527.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – MainMenu’s scene UI
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Attach a new `MainMenu` node and open it.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `_on_client_button_pressed`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.8 – ClientButton’s pressed signal connection](img/Figure_01.08_B18527.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – ClientButton’s pressed signal connection
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Connect the pressed signal of the `_on_server_button_pressed`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `_on_client_button_pressed()` callback, let’s call the `change_scene_to_file()`
    method on the `get_tree()` instance, passing in `"res://Client.tscn"` as the argument:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `_on_server_button_pressed()` callback, do the same as before, passing
    `"``res://Server.tscn"` instead.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete script should look like this:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let’s make sure we save the scene before we test it. After that, all we
    need to do is hit the **Run Current Scene** button and watch the scene come to
    life. All the hard work has been done, and now all that’s left is to appreciate
    the results.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the two debug instances running, we need to pick one to be the
    server first. For that, we can press `Server.tscn` scene and start listening for
    incoming connections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the other instance, we need to press `Client.tscn` scene and try to
    connect to the server. If everything goes as expected, we should get `peer_id`
    printed in the console of the server instance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个实例中，我们需要按下`Client.tscn`场景并尝试连接到服务器。如果一切如预期进行，我们应该在服务器实例的控制台中看到打印出的`peer_id`。
- en: This means that the client and the server have successfully established a connection
    and are now ready to start exchanging messages. Congratulations, you’ve just created
    your first handshake!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端和服务器已经成功建立了连接，现在可以开始交换消息了。恭喜你，你刚刚创建了你第一个握手！
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the fundamentals of network connections, which
    is to establish the connection through a procedure known as the handshake.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了网络连接的基础，即通过称为握手的程序建立连接。
- en: The handshake ensures that two computers recognize each other in a network and
    establish the protocols of this communication. This is important to understand,
    as it is the core of all our further endeavors. Without this at our disposal,
    our players and our server would be disconnected. One would be sending data to
    the void, while the other would be infinitely waiting for something to arrive.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 握手确保两台计算机在网络中相互识别并建立这种通信的协议。这一点非常重要，因为这是我们所有进一步努力的基石。如果没有这个，我们的玩家和服务器将会断开连接。一个将会向虚空发送数据，而另一个将会无限期地等待某物到来。
- en: Talking about sending data, now that we have our computers connected and open
    to receive and send data back and forth, it’s time to see how to do that. Throughout
    this chapter, you saw how you can properly establish a connection using the ENet
    library and how Godot Engine provides a high-level approach to handshaking, to
    the point that we can barely see if there was an actual handshake or not.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 说到发送数据，既然我们的计算机已经连接并开放以接收和发送数据，现在是时候看看如何做到这一点了。在本章中，你看到了如何使用ENet库正确建立连接，以及Godot引擎如何提供高级别的握手方法，以至于我们几乎看不到是否真的发生了握手。
- en: In the next chapter, we are going to use the UDP protocol to also establish
    a connection between client and server. But this time, we are going to dig a bit
    further and actually send data both from the client to the server and the other
    way around.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用UDP协议来在客户端和服务器之间建立连接。但这一次，我们将进一步挖掘，并实际上从客户端向服务器发送数据，以及反过来。
- en: It’s important to use the UDP protocol to understand what might be happening
    under the hood when we finally start to get used to the Godot Engine `ENetMultiplayer`
    API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP协议来理解当我们最终开始习惯Godot引擎的`ENetMultiplayer` API时，底层可能发生的事情是非常重要的。
- en: Now let’s see the dirty and messy world of low-level data transmission in the
    next chapter, so we can understand later how much easier our lives are made with
    the new high-level network API!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看下一章中低级数据传输的混乱世界，这样我们就可以理解，有了新的高级网络API，我们的生活将变得多么容易！
