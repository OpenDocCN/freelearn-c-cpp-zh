# 前言

这本实践指南将为您提供将实时操作系统（RTOS）在微控制器单元（MCU）上启动和运行所需的最重要功能知识。如果您对使用实际硬件的动手示例学习如何实现 RTOS 应用感兴趣，并讨论常见的性能与开发时间权衡，那么您就来到了正确的位置！

我们将使用 FreeRTOS 内核实现代码，使用流行的 STM32 ARM MCU 和低成本的 STM Nucleo 开发板进行操作，并使用 SEGGER 调试工具进行代码调试/分析。本书中使用的所有工具都已被选择，因为它们对业余爱好者或刚开始的专业人士来说易于获取，同时也因为它们在现实世界的专业团队中的普及。通过阅读本书并完成示例，您获得的知识和经验将直接应用于实际开发环境。

# 本书面向对象

RTOS 编程不是初学者的主题，绝对不是学习嵌入式系统的正确起点。如果您对 MCU 或 C 语言一无所知，那么您最好先从基础知识开始，并在深入研究这个更高级的主题之前获得一些实际操作经验。

那么，谁将从阅读本书中受益最大？

**专业程序员**：您一直在裸机（无操作系统）上进行编程，并希望通过学习如何使用实时操作系统（RTOS）来满足严格的时序要求、平衡并发操作以及创建模块化代码来提高您的微控制器（MCU）编程技能。

**对“亲自动手”感兴趣的学生**：您一直在学习理论、听讲座和编写实验室练习代码，但现在您正在寻找一本完整的指南，帮助您开始接触并与之互动的实物。

**转向更高级主题的创客**：您已经编写了一些草图或脚本，但您正在寻找下一个挑战。也许您想从头开始创建一个基于 MCU 的全系统 – 这里的信息将帮助您在编程方面走上正轨。您甚至还会得到一些关于在选择项目 MCU 时应该寻找什么的提示。

# 本书涵盖内容

本书共分为四个部分，包含 17 章。如果您已经熟悉其中的一些内容，不需要从头到尾阅读本书。例如，如果您已经熟悉基本 RTOS 概念和实时系统，可以自由跳转到第四章，*选择合适的 MCU*。以下是本书包含的章节简要描述：

第一章，*介绍实时系统*，是对实时操作系统（RTOS）是什么以及何时以及为什么使用它的简单介绍。还讨论了基于 MCU 的 RTOS 的硬件和软件替代方案。

第二章，*理解 RTOS 任务*，提供了超级循环与 RTOS 任务之间的比较，包括使用这两种方法实现并行操作的各种方式。

第三章，*任务信号和通信机制*，是对更多 RTOS 概念的简要介绍，包含大量图表。本章以及第二章*理解 RTOS 任务*，应作为参考和快速复习概念和术语的有用资源，以防万一需要。

第四章，*选择合适的 MCU*，帮助你了解在选择 MCU 时应考虑哪些因素。在了解硬件和固件之间的相互依赖性之后，我们探讨了为什么硬件和固件工程师都参与系统设计如此重要。

第五章，*选择 IDE*，介绍了并讨论了各种类型的**集成开发环境**（**IDE**），包括为什么你可能决定选择一个而不是另一个（或者一个都不选）。如何设置 STM32CubeIDE 和导入示例代码的说明也包含在此处。

第六章，*实时系统调试工具*，涵盖了调试嵌入式系统的工具，包括本书剩余部分我们将使用的调试工具——SEGGER Ozone 和 SEGGER SystemView 可视化软件。如何使用 Ozone 和 SystemView 的说明也包含在此处。还包括基于硬件的测试设备以及一些对嵌入式系统开发工作流程有用的工具。

第七章，*FreeRTOS 调度器*，教授你使用 FreeRTOS 创建任务的各种方法以及如何排除启动故障。你将了解任务状态以及性能优化的不同方式。

第八章，*保护数据和同步任务*，涵盖了使用信号量进行任务同步以及使用互斥锁进行数据保护，以及如何避免竞争条件和优先级反转。还涵盖了软件定时器。

第九章，*任务间通信*，探讨了在任务之间传递信息的不同方法，提供了使用队列通过值和引用传递信息的不同示例，讨论了两种方法的优点和考虑因素。我们还将了解一种轻量级任务间通信机制，即直接任务通知，包括任务通知和队列的比较。

第十章，*驱动程序和中断服务例程*，深入探讨了如何使用各种 FreeRTOS 原语（包括信号量、队列和流缓冲区）实现高效的驱动程序的一些详细示例。我们还将探讨如何结合 MCU 硬件（如 DMA）使用 FreeRTOS，以提供极高效的驱动程序实现。本章直接与 MCU 的外设寄存器以及 STM32 HAL 代码一起工作。

第十一章，*在任务间共享硬件外设*，教你如何创建可以在多个任务中安全使用并共享硬件资源的驱动程序。我们将调整 STM 提供的 USB CDC 实现，使其更易于用户使用和更高效，通过互斥锁和队列包装，使其可以在多个任务中安全使用。

第十二章，*创建良好抽象架构的技巧*，涵盖了代码的可重用性、灵活性和硬件可移植性，着眼于创建使你的工作更轻松的抽象。还提供了一些关于源代码组织以帮助促进重用的建议。

第十三章，*使用队列创建松散耦合*，是书中涵盖的所有概念的总结。它包括一个完整的示例，展示了用于创建正确抽象的端到端应用的松散耦合架构。我们将使用之前开发的 USB CDC 虚拟通信端口以及 LED 抽象，使用命令队列创建一个松散耦合、完全可重用的 LED 序列器。这个嵌入式应用程序可以通过一个用 Python 编写的跨平台 UI 从 PC 上控制。

第十四章，*选择 RTOS API*，继续我们关于高级架构的讨论，探讨可用于访问 FreeRTOS 功能的三种不同的 API：本机 FreeRTOS API、ARM 的 CMSIS-RTOS 和 POSIX。讨论主题包括对可用功能的比较以及为什么你可能选择其中之一用于不同的项目。

第十五章，*FreeRTOS 内存管理*，仔细研究了 FreeRTOS 中内存管理的几种不同选项。我们将探讨静态分配与动态分配，以及使用**内存保护单元**（**MPU**）。

第十六章，*多处理器和多核系统*，教您多处理器和多核系统为何被用于各种原因——了解它们是什么以及如何让系统的不同部分进行通信。

第十七章，*故障排除技巧和下一步行动*，涵盖了系统故障排除的技巧，包括如何避免堆栈溢出以及如何故障排除挂起的系统。还提供了一些下一步行动的建议。

# 为了充分利用本书

为了使本书中的示例尽可能容易地为非常广泛的人群工作，已经做出了所有努力。为了充分利用本书（通过完成示例），您需要以下硬件：

+   具有互联网访问的 Windows、macOS 或 Linux PC

+   STM32 Nucleo-F767ZI 开发板

+   两条 Micro-USB 线。

+   跳线—20 到 22 AWG (~0.65 mm)实心线。

不同工具的详细设置说明包含在各章节中。

**如果您使用的是本书的数字版，我们建议您自己输入代码或通过 GitHub 仓库（下一节中提供链接）访问代码。这样做将帮助您避免与代码的复制和粘贴相关的任何潜在错误。**

由于本书针对的是编程低级嵌入式系统，我们将使用 C 作为首选语言。假设您对微控制器有一定的了解，以及阅读数据表的能力。如果您对 C 语言（或 C++）有很好的理解，那么您应该能够轻松阅读本书——不需要先前的 RTOS 知识。由于我们将与嵌入式系统中的 MCU 一起工作，偶尔也会讨论硬件方面的内容，主要涉及 MCU 和开发板的功能。这些主题将详细说明，以便即使硬件知识有限的人也能轻松理解。您应该能够舒适地与处理开发硬件互动，尽管不需要实际的汇编。

# 下载示例代码文件。

您可以从[`github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers`](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers)的账户下载本书的示例代码文件。如果您在其他地方购买了此书，您可以访问[www.packtpub.com/support](https://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com)登录或注册。

1.  选择“支持”标签。

1.  点击“代码下载”。

1.  在搜索框中输入书籍名称，并遵循屏幕上的说明。

文件下载完成后，请确保您使用最新版本解压缩或提取文件夹，例如：

+   Windows 的 WinRAR/7-Zip

+   Mac 的 Zipeg/iZip/UnRarX

+   7-Zip/PeaZip for Linux

本书的相关代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers`](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers)。如果代码有更新，它将在现有的 GitHub 仓库中更新。

我们还有其他来自我们丰富图书和视频目录的代码包，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。查看它们吧！

# 下载彩色图像

我们还提供了一份包含本书中使用的截图/图表的彩色图像的 PDF 文件。您可以从这里下载：[`www.packtpub.com/sites/default/files/downloads/9781838826734_ColorImages.pdf`](http://www.packtpub.com/sites/default/files/downloads/9781838826734_ColorImages.pdf)。

# 使用的约定

本书使用了多种文本约定。

`CodeInText`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例："`func1()` 负责读取传感器的值并将其存储在

`sensorReadings`数组"

代码块设置如下：

```cpp
void func1( int16_t calOffset)
{
int16_t tempValue;
tempValue = readSensor();
tempValue = tempValue + calOffset;
sensorReadings[0] = tempValue;
}
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```cpp
/* ADC Config */
hnucleo_Adc.Instance = NUCLEO_ADCx;
/* (ClockPrescaler must not exceed 36MHz) */
hnucleo_Adc.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4;
hnucleo_Adc.Init.Resolution = ADC_RESOLUTION12b;
hnucleo_Adc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hnucleo_Adc.Init.ContinuousConvMode = DISABLE;
hnucleo_Adc.Init.DiscontinuousConvMode = DISABLE;
```

**粗体**：表示新术语、重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词在文本中如下所示。以下是一个示例：“从管理面板中选择 System info。”

警告或重要注意事项如下所示。

技巧和窍门如下所示。

# 联系我们

我们始终欢迎读者的反馈。

**总体反馈**：如果您对本书的任何方面有任何疑问，请在邮件主题中提及书名，并通过`customercare@packtpub.com`给我们发送邮件。

**勘误**：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们将不胜感激，如果您能向我们报告这一点。请访问[www.packtpub.com/support/errata](https://www.packtpub.com/support/errata)，选择您的书，点击勘误提交表单链接，并输入详细信息。

**盗版**：如果您在互联网上以任何形式发现我们作品的非法副本，如果您能提供位置地址或网站名称，我们将不胜感激。请通过`copyright@packt.com`与我们联系，并提供材料的链接。

**如果您有兴趣成为作者**：如果您在某个主题上具有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

# 评论

请留下您的评价。一旦您阅读并使用过这本书，为何不在购买它的网站上留下评价呢？潜在读者可以查看并使用您的客观意见来做出购买决定，我们 Packt 可以了解您对我们产品的看法，而我们的作者也可以看到他们对书籍的反馈。谢谢！

如需了解 Packt 的更多信息，请访问 [packt.com](http://www.packt.com/).
