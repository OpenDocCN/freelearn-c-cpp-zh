<html><head></head><body>
		<div class="Content" id="_idContainer043">
			<h1 id="_idParaDest-148"><em class="italics"><a id="_idTextAnchor160"/>Chapter 5</em></h1>
		</div>
		<div class="Content" id="_idContainer044">
			<h1 id="_idParaDest-149"><a id="_idTextAnchor161"/>Standard Library Containers and Algorithms</h1>
		</div>
		<div class="Content" id="_idContainer045">
			<h2>Chapter Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Explain what iterators are</li>
				<li class="bullets">Demonstrate the use of sequential containers, container adaptors, and associative containers</li>
				<li class="bullets">Understand and use unconventional containers</li>
				<li class="bullets">Explain cases of iterator invalidation</li>
				<li class="bullets"><a id="_idTextAnchor162"/>Discover algorithms implemented in the standard library</li>
				<li class="bullets"><a id="_idTextAnchor163"/>Use user-defined operations on algorithms with lambda expressions</li>
			</ul>
		</div>
		<div class="Content" id="_idContainer073">
			<h2 id="_idParaDest-150"><a id="_idTextAnchor164"/><a id="_idTextAnchor165"/>Introduction</h2>
			<p>The core of C++ is its <strong class="keyword">Standard Template Library</strong> (<strong class="keyword">STL</strong>), which represents a set of important data structures and algorithms that facilitates the programmer's task and improves code efficiency.</p>
			<p>The components of the STL are parametric so that they can be reused and combined in different ways. The STL is mainly made up of container classes, iterators, and algorithms.</p>
			<p>Containers are used to store collections of elements of a certain type. Usually, the type of the container is a template parameter, which allows the same container class to support arbitrary elements. There are several container classes, each of them with different characteristics and features.</p>
			<p>Iterators are used to traverse the elements of a container. Iterators offer the programmer a simple and common interface to access containers of a different type.</p>
			<p>Iterators are similar to raw pointers, which can also iterate through elements using the increment and the decrement operators, or can access a specific element using the de-reference (<strong class="inline">*</strong>) operator.</p>
			<p>Algorithms are used to perform standard operations on the elements stored in the containers. They use iterators to traverse the collections, since their interface is common to all the containers, so that the algorithm can be agnostic about the container it's operating on.</p>
			<p>Algorithms treat functions as parameters that are provided by the programmer in order to be more flexible in the operation that's being performed. It is common to see an algorithm applied to a container of objects of a user-defined type. This algorithm, to execute correctly, needs to know how to treat the object in detail. For this reason, the programmer provides a function to the algorithm to specify the operations to be executed on the objects.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor166"/>Sequence Containers</h2>
			<p><strong class="bold">Sequence containers,</strong> sometimes referred to as <strong class="keyword">sequential containers</strong>, are a particular class of containers where the order in which their elements are stored is decided by the <em class="italics">programmer</em> rather than by the values of the elements. Every element has a certain position that is independent of its value.</p>
			<p>The STL contains five sequence container classes:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 5.1: Table representing the sequence container class and their description" src="image/C11557_05_01.jpg"/>
				</div>
			</div>
			<h6>Figure 5.1: Table presenting the sequence container classes and their descriptions</h6>
			<h3 id="_idParaDest-152">A<a id="_idTextAnchor167"/>rray</h3>
			<p>The array container is a fixed-size data structure of contiguous elements. It recalls the static array that we saw in <em class="italics">Chapter 1</em>, <em class="italics">Getting Started</em>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 5.2: Array elements are stored in contiguous memory" src="image/C11557_05_02.jpg"/>
				</div>
			</div>
			<h6>Figure 5.2: Array elements are stored in contiguous memory</h6>
			<p>An array's size needs to be specified at compile time. Once defined, the size of the array <em class="italics">cannot be changed</em>. </p>
			<p>When an array is created, the <strong class="inline">size</strong> elements it contains are initialized next to each other in memory. While elements cannot be added or removed, their values can be modified. </p>
			<p>Arrays can be randomly accessed using the access operator with the corresponding element's index. To access an element at a given position, we can use the operator <strong class="inline">[]</strong> or the <strong class="inline">at()</strong> member function. The former does not perform any range checks, while the latter throws an exception if the index is out of range. Moreover, the first and the last element can be accessed using the <strong class="inline">front()</strong> and <strong class="inline">back()</strong> member functions. </p>
			<p>These operations are fast: since the elements are contiguous, we can compute the position in memory of an element given its position in the array, and access that directly.</p>
			<p>Th<a id="_idTextAnchor168"/>e size of the array can be obtained using the <strong class="inline">size()</strong> member function. Whether the container is empty can be checked using the <strong class="inline">empty()</strong> function, which returns <em class="italics">true</em> if <strong class="inline">size()</strong> is zero.</p>
			<p>Th<a id="_idTextAnchor169"/>e array class is defined in the <strong class="inline">&lt;array&gt;</strong> header file, which has to be included before usage.</p>
			<h3 id="_idParaDest-153"><a id="_idTextAnchor170"/>Vector</h3>
			<p>The vector container is a data structure of contiguous elements whose size can be dynamically modified: it does not require to specify its size at creation time:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 5.3: Vector elements are contiguous, and their size can grow dynamically" src="image/C11557_05_03.jpg"/>
				</div>
			</div>
			<h6>Figure 5.3: Vector elements are contiguous, and their size can grow dynamically</h6>
			<p>The<a id="_idTextAnchor171"/> <strong class="inline">vector</strong> class is defined in the <strong class="inline">&lt;vector&gt;</strong> header file.</p>
			<p>A vector stores the elements it contains in a single section of memory. Usually, the section of memory has enough space for more elements than the number of elements stored in the vector. When a new element is added to the vector, if there is enough space in the section of memory, the element is added after the last element in the vector. If there isn't enough space, the vector gets a new, bigger section of memory and copies all the existing elements into the new section of memory, then it deletes the old section of memory. To us, it will seem like the size of the section of memory has increased:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 5.4: Memory allocation of vectors" src="image/C11557_05_04.jpg"/>
				</div>
			</div>
			<h6>Figure 5.4: Memory allocation of vectors</h6>
			<p>When the vector is created, it is empty. </p>
			<p>Most of the interface is similar to the array's, but with a few differences.</p>
			<p>Elem<a id="_idTextAnchor172"/>ents can be appended using the <strong class="inline">push_back()</strong> function or inserted at a generic position using the <strong class="inline">insert()</strong> function. The last element can be removed using <strong class="inline">pop_back()</strong> or at a generic position using the <strong class="inline">erase()</strong> function.</p>
			<p>Appe<a id="_idTextAnchor173"/>nding or deleting the last element is fast, while inserting or removing other elements of the vector is considered slow, as it requires moving all the elements to make space for the new element or to keep all the elements contiguous:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 5.5: Elements being moved during insertions or deletions inside a vector" src="image/C11557_05_05.jpg"/>
				</div>
			</div>
			<h6>Figure 5.5: Elements being moved during insertions or deletions inside a vector</h6>
			<p>Vecto<a id="_idTextAnchor174"/>rs, just like arrays, allow efficient access of elements at random positions. A vector's size is also retrieved with the <strong class="inline">size()</strong> member function, but this should not be confused with <strong class="inline">capacity()</strong>. The former is the actual number of elements in the vector, and the latter returns the maximum number of elements that can be inserted in the current section of memory.</p>
			<p>For example, in the preceding diagram, initially, the array had a size of 4 and a capacity of 8. So, even when an element had to be moved to the right, the vector's capacity did not change, as we never had to get a new, bigger section of memory to store the elements.</p>
			<p>The o<a id="_idTextAnchor175"/>peration of getting a new section of memory is called reallocation. Since reallocation is considered an expensive operation, it is possible to <em class="italics">reserve</em> enough memory for a given number of elements by enlarging a vector's capacity using the <strong class="inline">reserve()</strong> member function. The vector's capacity can also be reduced to fit the number of elements using the <strong class="inline">shrink_to_fit()</strong> function in order to release memory that is not needed anymore.</p>
			<h4>Note</h4>
			<p class="callout">Vector is the most commonly used container for a sequence of elements and is often the best one performance-wise.</p>
			<p>Let's<a id="_idTextAnchor176"/> look at the following example to understand how <strong class="inline">vector::front()</strong> and <strong class="inline">vector::back()</strong> work in C++:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">// Import the vector library</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::vector&lt;int&gt; myvector;</p>
			<p class="snippet">  myvector.push_back(100);</p>
			<p class="snippet">  // Both front and back of vector contains a value 100</p>
			<p class="snippet">  myvector.push_back(10);</p>
			<p class="snippet">  // Now, the back of the vector holds 10 as a value, the front holds 100</p>
			<p class="snippet">  myvector.front() -= myvector.back();</p>
			<p class="snippet">  // We subtracted front value with back</p>
			<p class="snippet">std::cout &lt;&lt; "Front of the vector: " &lt;&lt; myvector.front() &lt;&lt; std::endl;</p>
			<p class="snippet">std::cout &lt;&lt; "Back of the vector: " &lt;&lt; myvector.back() &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Front of the vector: 90</p>
			<p class="snippet">Back of the vector: 10</p>
			<h3 id="_idParaDest-154"><a id="_idTextAnchor177"/>Deque</h3>
			<p>The <em class="italics">deque</em> container (pronounced <em class="italics">deck)</em> is short for "double-ended queue." Like <em class="italics">vector</em>, it allows for fast, direct access of deque elements and fast insertion and deletion at the back. Unlike <em class="italics">vector</em>, it also allows for fast insertion and deletion at the front of the deque:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 5.6: Deque elements can be added and removed at the start and the end" src="image/C11557_05_06.jpg"/>
				</div>
			</div>
			<h6>Figure<a id="_idTextAnchor178"/> 5.6: Deque elements can be added and removed at the start and the end</h6>
			<p>The <strong class="inline">de<a id="_idTextAnchor179"/>que</strong> class is defined in the <strong class="inline">&lt;deque&gt;</strong> header file.</p>
			<p><em class="italics">Deque</em> generally requires more memory than <em class="italics">vector</em>, and <em class="italics">vector</em> is more performant for accessing the elements and <strong class="inline">push_back</strong>, so unless it is required to insert at the front, <em class="italics">vector</em> is usually preferred.</p>
			<h3 id="_idParaDest-155"><a id="_idTextAnchor180"/>List</h3>
			<p>The list container is a data structure of nonadjacent elements that can be dynamically grown:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 5.7: List elements are stored in different sections of memory, and have connecting links " src="image/C11557_05_07.jpg"/>
				</div>
			</div>
			<h6>Figure 5.7: List elements are stored in different sections of memory, and have connecting links </h6>
			<p>The <strong class="inline">lis<a id="_idTextAnchor181"/>t</strong> class is defined in the <strong class="inline">&lt;list&gt;</strong> header file. </p>
			<p>Each element in the list has its memory segment and a link to its predecessor and its successor. The structure containing the element, which is the link to its predecessor and to its successor, is called a <strong class="bold">node</strong>.</p>
			<p>When an element is inserted in a list, the predecessor node needs to be updated so that its successor link points to the new element. Similarly, the successor node needs to be updated so that its predecessor link points to the new element:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 5.8: C is to be inserted between A and B. A's successor and B's predecessor link must be updated to point to C (orange). C's link to the predecessor and successor are updated to points A and B (green)" src="image/C11557_05_08.jpg"/>
				</div>
			</div>
			<h6>Figure 5.8: C is to be inserted between A and B. A's successor and B's predecessor link must be updated to point to C (orange). C's link to the predecessor and successor are updated to points A and B (green)</h6>
			<p>When an element is removed from the list, we need to update the successor link of the predecessor node to point to the successor of the removed node. Similarly, the predecessor link of the successor node needs to be updated to point to the predecessor of the removed node.</p>
			<p>In the preceding diagram, if we were to remove <strong class="bold">C</strong>, we would have to update <strong class="bold">A</strong>'s successor to point to <strong class="bold">C</strong>'s successor (<strong class="bold">B</strong>), and <strong class="bold">B</strong>'s predecessor to point to <strong class="bold">C</strong>'s predecessor (<strong class="bold">A</strong>).</p>
			<p>Unlike vectors, lists do not provide random access. Elements are accessed by linearly following the chain of elements: starting from the first, we can follow the successor link to find the next node, or from the last node we can follow the predecessor link to find the previous node, until we reach the element we are interested into. </p>
			<p>The advantage of <strong class="inline">list</strong> is that insertion and removal are fast at any position, if we already know the node at which we want to insert or remove. The disadvantage of this is that getting to a specific node is slow.</p>
			<p>The interface is similar to a vector, except that lists don't provide <strong class="inline">operator[]</strong>.</p>
			<h3 id="_idParaDest-156"><a id="_idTextAnchor182"/>Forward-List</h3>
			<p>The <strong class="inline">forward_list</strong> container is similar to the list container, with the difference that its nodes only have the link to the successor. For this reason, it is not possible to iterate over a <strong class="inline">forward_list</strong> in backward order:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 5.9: Forward-list elements are like List, but only have one-way connecting links" src="image/C11557_05_09.jpg"/>
				</div>
			</div>
			<h6>Figure 5.9: Forward-list elements are like List elements, but only have one-way connecting links</h6>
			<p>As usual<a id="_idTextAnchor183"/><a id="_idTextAnchor184"/>, the <strong class="inline">forward_list</strong> class is defined in the <strong class="inline">&lt;forward_list&gt;</strong> header file.</p>
			<p>The <strong class="inline">forwa<a id="_idTextAnchor185"/>rd_list</strong> class does not even provide <strong class="inline">push_back()</strong> or <strong class="inline">size()</strong>. Inserting an element is done using <strong class="inline">insert_after()</strong>, which is a variation of the <strong class="inline">insert()</strong> function, where the new element is inserted after the provided position. The same idea applies to element removal, which is done through <strong class="inline">erase_after()</strong>, which removes the element after the provided position.</p>
			<h3 id="_idParaDest-157"><a id="_idTextAnchor186"/>Providing Initial Values to Sequence Containers</h3>
			<p>All the sequence containers we have looked at are empty when they are first created.</p>
			<p>When we want to create a container containing some elements, it can be repetitive to call the <strong class="inline">push_back()</strong> or <strong class="inline">insert()</strong> functions repeatedly for each element.</p>
			<p>Fortunately, all the containers can be initialized with a sequence of elements when they are created.</p>
			<p>The sequence must be provided in curly brackets, and the elements need to be comma-separated. This is called an initializer list:</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    // initialize the vector with 3 numbers</p>
			<p class="snippet">    std::vector&lt;int&gt; numbers = {1, 2, 3};</p>
			<p class="snippet">}</p>
			<p>This works for any of the containers we have seen in this chapter.</p>
			<h3 id="_idParaDest-158"><a id="_idTextAnchor187"/>Activity 19: Storing User Accounts</h3>
			<p>We want to store the account balance, stored as an <strong class="inline">int</strong> instance, for 10 users. The account balance starts with 0. We then want to increase the balance of the first and last user by 100.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li>Include the header for the <strong class="inline">array</strong> class.</li>
				<li>Declare an integer array of ten elements.</li>
				<li>Initialize the array using the <strong class="inline">for</strong> loop. The <strong class="inline">size()</strong> operator to evaluate the size of the array and the <strong class="inline">operator[]</strong> to access every position of the array.</li>
				<li>Update the value for the first and last user.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 304.</p></li>
			</ol>
			<p>Now let’s do the same using a vector:</p>
			<ol>
				<li value="1">Include the <strong class="bold">vector</strong> header.</li>
				<li>Declare a vector of integer type and reserve memory to store 100 users with resize it to be able to contain 10 users.</li>
				<li>Use a for loop to initialize the vector.</li>
			</ol>
			<p>With this activity, we learned how we can store an arbitrary number of accounts.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor188"/>Associative Containers</h2>
			<p><strong class="bold">Associative containers</strong> are containers that allow for the fast lookup of elements. Additionally, the elements are always kept in a sorted order. The order is determined by the value of the element and a comparison function. The comparison function is called a <em class="italics">comparator</em>, and by default this is the <strong class="inline">operator&lt;</strong>, although the user can supply a <strong class="inline">Functor</strong> (function object) as a parameter to specify how the elements should be compared. The <strong class="inline">&lt;functional&gt;</strong> header contains many such objects that can be used to sort the associative containers, like <strong class="inline">std::less</strong> or <strong class="inline">std::less</strong>.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 5.10: Table representing associative containers and its description" src="image/C11557_05_10.jpg"/>
				</div>
			</div>
			<h6>Figure 5.10: Table presenting associative containers and their descriptions</h6>
			<p>Typically, associative containers are implemented as variations of binary trees, providing fast element lookup by exploiting the logarithmic complexity of the underlying structure.</p>
			<h3 id="_idParaDest-160"><a id="_idTextAnchor189"/>Set and Multiset</h3>
			<p>A <strong class="keyword">Set</strong> is a container that contains a unique group of sorted elements. A <strong class="keyword">Multiset</strong> is similar to <em class="italics">Set</em>, but it allows duplicate elements:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 5.11: Set and Multiset store a sorted group of elements" src="image/C11557_05_11.jpg"/>
				</div>
			</div>
			<h6>Figure 5.11: Set and Multiset store a sorted group of elements</h6>
			<p>Set and multiset have <strong class="inline">size()</strong> and <strong class="inline">empty()</strong> function members to check how many elements are contained and whether any elements are contained.</p>
			<p>Insertion and removal is done through the <strong class="inline">insert()</strong> and <strong class="inline">erase()</strong> functions. Because the order of the elements is determined by the <em class="italics">comparator</em>, they do not take a position argument like they do for sequential containers. Both insertion and removal are fast.</p>
			<p>Since sets are optimized for element lookup, they provide special search functions. The <strong class="inline">find()</strong> function returns the position of the first element equal to the provided value, or the position past the end of the set when the element is not found. When we look for an element with <strong class="inline">find</strong>, we should always compare it with the result of calling <strong class="inline">end()</strong> on the container to check whether the element was found.</p>
			<p>Let's examine the following code:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;set&gt;</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">    std::set&lt;int&gt; numbers;</p>
			<p class="snippet">    numbers.insert(10);</p>
			<p class="snippet">    if (numbers.find(10) != numbers.end()) {</p>
			<p class="snippet">        std::cout &lt;&lt; "10 is in numbers" &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>Finally, <strong class="inline">count()</strong> returns the number of elements equal to the value provided.</p>
			<p>The <strong class="inline">set</strong> and <strong class="inline">multiset</strong> classes are defined in the <strong class="inline">&lt;set&gt;</strong> header file.</p>
			<p>Example of a set with a custom comparator:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;set&gt;</p>
			<p class="snippet">#include &lt;functional&gt;</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">    std::set&lt;int&gt; ascending = {5,3,4,2,1};</p>
			<p class="snippet">    std::cout &lt;&lt; "Ascending numbers:";</p>
			<p class="snippet">    for(int number : ascending) {</p>
			<p class="snippet">        std::cout &lt;&lt; " " &lt;&lt; number;</p>
			<p class="snippet">    }</p>
			<p class="snippet">    std::cout &lt;&lt; std::endl;</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::set&lt;int, std::greater&lt;int&gt;&gt; descending = {5,3,4,2,1};</p>
			<p class="snippet">    std::cout &lt;&lt; "Descending numbers:";</p>
			<p class="snippet">    for(int number : descending) {</p>
			<p class="snippet">        std::cout &lt;&lt; " " &lt;&lt; number;</p>
			<p class="snippet">    }</p>
			<p class="snippet">    std::cout &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p>Output:</p>
			<p>Ascending numbers: 1 2 3 4 5</p>
			<p>Descending numbers: 5 4 3 2 1</p>
			<h3 id="_idParaDest-161"><a id="_idTextAnchor190"/>Map and Multimap</h3>
			<p><strong class="bold">Map</strong> and <strong class="bold">multimap</strong> are containers that manage <strong class="keyword">key/value</strong> pairs as elements. The elements are sorted automatically according to the provided comparator and applied to the <em class="italics">key</em>: the <em class="italics">value</em> does not influence the order of the elements:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 5.12: Map and multimap store a sorted group of keys, which is associated to a value" src="image/C11557_05_12.jpg"/>
				</div>
			</div>
			<h6>Figure 5.12: Map and multimap store a sorted group of keys, which is associated to a value</h6>
			<p>Map allows you to associate a single value to a key, while multimap allows you to associate multiple values to the same key.</p>
			<p>The <strong class="inline">map</strong> and <strong class="inline">multimap</strong> classes are defined in the <strong class="inline">&lt;map&gt;</strong> header file.</p>
			<p>To insert values into a map, we can call <strong class="inline">insert()</strong>, providing a <strong class="keyword">pair</strong> containing the key and the value. Later in this chapter, we will see more about pairs. The function also returns a pair, containing the position at which the element was inserted, and a Boolean set to <strong class="inline">true</strong> if the element was inserted, or <strong class="inline">false</strong> if an element with the same key already exists.</p>
			<p>Once values are inserted into the map, there are several ways to look up a key/value pair in a map.</p>
			<p>Similar to set, map provides a <strong class="inline">find()</strong> function, which looks for a key in the map and returns the position of the key/value pair if it exists, or the same result of calling <strong class="inline">end()</strong>.</p>
			<p>From the position, we can access the key with <strong class="inline">position-&gt;first</strong> and the value with <strong class="inline">position-&gt;second</strong>:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;string&gt;</p>
			<p class="snippet">#include &lt;map&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::map&lt;int, std::string&gt; map;</p>
			<p class="snippet">    map.insert(std::make_pair(1, "some text"));</p>
			<p class="snippet">    auto position = map.find(1);</p>
			<p class="snippet">    if (position != map.end() ) {</p>
			<p class="snippet">        std::cout &lt;&lt; "Found! The key is " &lt;&lt; position-&gt;first &lt;&lt; ", the value is " &lt;&lt; position-&gt;second &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>An alternative to accessing a value from a key is to use <strong class="inline">at()</strong>, which takes a key and returns the associated value.</p>
			<p>If there is no associated value, <strong class="inline">at()</strong> will throw an exception.</p>
			<p>A last alternative to get the value associated with a key is to use <strong class="inline">operator[]</strong>.</p>
			<p>The <strong class="inline">operator[]</strong> returns the value associated with a key, and if the key is not present, it inserts a new key/value pair with the provided key, and a default value for the value. Because <strong class="inline">operator[]</strong> could modify the map by inserting into it, it cannot be used on a <em class="italics">const</em> map:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;map&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::map&lt;int, int&gt; map;</p>
			<p class="snippet">    std::cout &lt;&lt; "We ask for a key which does not exists: it is default inserted: " &lt;&lt; map[10] &lt;&lt; std::endl;</p>
			<p class="snippet">    map.at(10) += 100;</p>
			<p class="snippet">    std::cout &lt;&lt; "Now the value is present: " &lt;&lt; map.find(10)-&gt;second &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<h3 id="_idParaDest-162"><a id="_idTextAnchor191"/>Activity 20: Retrieving a User's Balance from their Given Username</h3>
			<p>We'd like to be able to quickly retrieve the balance of a user given their username.</p>
			<p>To quickly retrieve the balance from the username, we store the balance inside a map, using the name of the user as a key.</p>
			<p>The name of the user is of type <strong class="inline">std::string</strong>, while the balance is an <strong class="inline">int</strong>. Add the balance for the users <strong class="inline">Alice</strong>, <strong class="inline">Bob</strong>, and <strong class="inline">Charlie</strong> with a balance of 50 each. Then, check whether the user <strong class="inline">Donald</strong> has a balance.</p>
			<p>Finally, print the account balance of <strong class="inline">Alice</strong>:</p>
			<ol>
				<li value="1">Include the header file for the <strong class="inline">map</strong> class and the header for <strong class="inline">string</strong>:<p class="snippet">#include &lt;string&gt;</p><p class="snippet">#include &lt;map&gt;</p><p class="snippet">#include &lt;string&gt;</p></li>
				<li>Create a map with the key being <strong class="inline">std::string</strong> and the value being <strong class="inline">int</strong>.</li>
				<li>Insert the balances of the users inside the map by using <strong class="inline">insert</strong> and <strong class="inline">std::make_pair</strong>. The first argument is the <strong class="inline">key</strong>, while the second one is the <strong class="inline">value</strong>:<p class="snippet">balances.insert(std::make_pair("Alice",50));</p></li>
				<li>Use the <strong class="inline">find</strong> function, providing the name of the user to find the position of the account in the map. Compare it with <strong class="inline">end()</strong> to check whether a position was found.</li>
				<li>Now, look for the account of Alice. We know Alice has an account, so there is no need to check whether we found a valid position. We can print the value of the account using <strong class="inline">-&gt;second</strong><span class="Subtle-Emphasis">:</span><p class="snippet">auto alicePosition = balances.find("Alice");</p><p class="snippet">std::cout &lt;&lt; "Alice balance is: " &lt;&lt; alicePosition-&gt;second &lt;&lt; std::endl;</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 305.</p></li>
			</ol>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor192"/>Unordered Containers</h2>
			<p><strong class="bold">Unordered associative containers</strong> differ from associative containers in that the elements have no defined order. Visually, unordered containers are often imagined as bags of elements. Because the elements are not sorted, unordered containers do not accept a comparator object to provide an order to the elements. On the other hand, all the unordered containers depend on a hash function. </p>
			<p>he user can provide a <strong class="inline">Functor</strong> (function object) as a parameter to specify how the keys should be hashed:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 5.13: Table representing unordered container and its description" src="image/C11557_05_13.jpg"/>
				</div>
			</div>
			<h6>Figure 5.13: Table presenting unordered containers and their descriptions</h6>
			<p>Typically, unordered containers are implemented as <strong class="bold">hash tables</strong>. The position in the array is determined using the hash function, which given a value returns the position at which it should be stored. Ideally, most of the elements will be mapped into different positions, but the hash function can potentially return the same position for different elements. This is called a <em class="italics">collision</em>. This problem is solved by using linked lists to chain elements that map into the same position, so that multiple elements can be stored in the same position. Because there might be multiple elements at the same position, the position is often called <strong class="keyword">bucket</strong>.</p>
			<p>Implementing unordered containers using a hash table allows us to find an element with a specific value in constant time complexity, which translates to an even faster lookup when compared to associative containers:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 5.14: When an element is added to the set, its hash is computed to decide in which bucket the element should be added. The elements inside a bucket are stored in a list." src="image/C11557_05_14.jpg"/>
				</div>
			</div>
			<h6>Figure 5.14: W<a id="_idTextAnchor193"/>hen an element is added to the set, its hash is computed to decide in which bucket the element should be added. The elements inside a bucket are stored as nodes of a list.</h6>
			<p>When a key/value pair is added to the map, the hash of the key is computed to decide in which bucket the key/value pair should be added:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 5.15: Representation of storing the bucket elements in a list." src="image/C11557_05_15.jpg"/>
				</div>
			</div>
			<h6>Figure 5.15: Representation of computing the bucket of an element from the key, and storing the key/value pair as nodes in a list.</h6>
			<p>Unordered associative containers and ordered associative containers provide the same functionalities, and the explanations in the previous section apply to the unordered associative containers as well. Unordered associative containers can be used to get better performances when the order of the elements is not important.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor194"/>Container Adaptors</h2>
			<p>Additional container classes that are provided by the STL library are container adaptors. Container adaptors provide constrained access policies on top of the containers we have looked at in this chapter.</p>
			<p>Container adaptors have a template parameter that the user can provide to specify the type of container to wrap:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="" src="image/Image18089.jpg"/>
				</div>
			</div>
			<h6>Figure 5.16: Table presenting container adaptors and their descriptions</h6>
			<h3 id="_idParaDest-165"><a id="_idTextAnchor195"/>Stack</h3>
			<p>The stack container implements the LIFO access policy, where the elements are virtually stacked one on the top of the other so that the last inserted element is always on top. Elements can only be read or removed from the top, so the last inserted element is the first that gets removed. A stack is implemented using a sequence container class internally, which is used to store all the elements and emulate the stack behavior.</p>
			<p>The access pattern of the stack data structure happens mainly through three core member functions: <strong class="inline">push()</strong>, <strong class="inline">top()</strong>, and <strong class="inline">pop()</strong>. The <strong class="inline">push()</strong> function is used to insert an element into the stack, <strong class="inline">top()</strong> used to access the element on top of the stack, and <strong class="inline">pop()</strong> is used to remove the top element.</p>
			<p>The <strong class="inline">stack</strong> class is defined in the <strong class="inline">&lt;stack&gt;</strong> header file.</p>
			<h3 id="_idParaDest-166"><a id="_idTextAnchor196"/>Queue</h3>
			<p>The <strong class="inline">queue</strong> class implements the FIFO access policy, where the elements are enqueued one after the other, so that elements inserted before are ahead of elements inserted after. Elements are inserted at the end of the queue and removed at the start.</p>
			<p>The interface of the queue data structure is composed of the <strong class="inline">push()</strong>, <strong class="inline">front()</strong>, <strong class="inline">back()</strong>, and <strong class="inline">pop()</strong> member functions.</p>
			<p>The <strong class="inline">push()</strong> function is used to insert an element into the <strong class="inline">queue()</strong>; <strong class="inline">front()</strong> and <strong class="inline">back()</strong> return the next and last elements of the queue, respectively; the <strong class="inline">pop()</strong> is used to remove the next element from the queue.</p>
			<p>The <strong class="inline">queue</strong> class is defined in the <strong class="inline">&lt;queue&gt;</strong> header file.</p>
			<h3 id="_idParaDest-167"><a id="_idTextAnchor197"/>Priority Queue</h3>
			<p>Finally, the priority queue is a queue where the elements are accessed according to their priority, in descending order (highest priority first).</p>
			<p>The interface is similar to the normal queue, where <strong class="inline">push()</strong> inserts a new element and <strong class="inline">top()</strong> and <strong class="inline">pop()</strong> access and remove the next element. The difference is in the way the next element is determined. Rather than being the first inserted element, it is the element that has the highest priority.</p>
			<p>By default, the priority of the elements is computed by comparing the elements with the <strong class="inline">operator&lt;</strong>, so that an element that is less than another comes after it. A user-defined sorting criterion can be provided to specify how to sort the elements by priority in regard to their priority in the queue.</p>
			<p>The priority queue class is also defined in the <strong class="inline">&lt;queue&gt;</strong> header file.</p>
			<h3 id="_idParaDest-168"><a id="_idTextAnchor198"/>Activity 21: Processing User Registration in Order</h3>
			<p>When a user registers to our website, we need to process the registration form at the end of the day.</p>
			<p>We want to process the registration in <span class="Subtle-Emphasis">reverse</span> order of registration:</p>
			<ol>
				<li value="1">Assume that the class for the registration form is already provided:<p class="snippet">struct RegistrationForm {</p><p class="snippet">    std::string userName;</p><p class="snippet">};</p></li>
				<li>Create a <strong class="inline">stack</strong> to store the users.</li>
				<li>We want to store the user registration form when the user registers, as well as process the registration at the end of the day. The function for processing the form is provided:<p class="snippet">void processRegistration(RegistrationForm form) {</p><p class="snippet">    std::cout &lt;&lt; "Processing form for user: " &lt;&lt; form.userName &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
				<li>Additionally, there are already two functions that are called when a user registers.</li>
				<li>Fill the code inside the following two functions to store the user form and process it:<p class="snippet">void storeRegistrationForm(std::stack&lt;RegistrationForm&gt;&amp; stack, RegistrationForm form) {</p><p class="snippet">}</p><p class="snippet">void endOfDayRegistrationProcessing(std::stack&lt;RegistrationForm&gt;&amp; stack) {</p><p class="snippet">}</p></li>
			</ol>
			<p>We'll see that the registration forms are processed in reverse order as the users are registered.</p>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found at page 306.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor199"/>Unconventional Containers</h2>
			<p>Up until now, we've seen containers that are used to store groups of elements of the same type.</p>
			<p>The C++ standard defines some other types that can contain types but offer a different set of functionalities from the containers we saw previously.</p>
			<p>These types are as follows:</p>
			<ol>
				<li value="1">String</li>
				<li>Pair and tuple</li>
				<li>Optional</li>
				<li>Variant</li>
			</ol>
			<h3 id="_idParaDest-170"><a id="_idTextAnchor200"/>Strings</h3>
			<p>A string is a data structure that's used to manipulate mutable sequences of contiguous characters. The C++ string classes are STL containers: they behave similarly to <em class="italics">vectors</em>, but provide additional functionalities that ease the programmer to perform common operations of sequences of characters easily.</p>
			<p>There exist several string implementations in the standard library that are useful for different lengths of character sets, such as <strong class="inline">string</strong>, <strong class="inline">wstring</strong>, <strong class="inline">u16string</strong>, and <strong class="inline">u32string</strong>. All of them are a specialization of the <strong class="inline">basic_string</strong> base class and they all have the same interface.</p>
			<p>The most commonly used type is <strong class="inline">std::string</strong>.</p>
			<p>All types and functions for strings are deﬁned in the <strong class="inline">&lt;string&gt;</strong> header file.</p>
			<p>A string can be converted into a <em class="italics">null-terminating string</em>, which is an array of characters that terminate with the special null character (represented with '<strong class="inline">\0</strong>') via the use of the <strong class="inline">data()</strong> or <strong class="inline">c_str()</strong> functions. Null-terminating strings, also called <em class="italics">C-strings</em>, are the way to represent sequences of character in the C language and they are often used when the program needs to interoperate with a C library; they are represented with the <strong class="inline">const char *</strong> type and are the type of the <em class="italics">literal strings</em> in our programs.</p>
			<h3 id="_idParaDest-171"><a id="_idTextAnchor201"/>Exercise 12: Demonstrating Working Mechanism of the <strong class="inline">c_str()</strong> Function</h3>
			<p>Let's examine the following code to understand how the <strong class="inline">c_str()</strong> function works:</p>
			<ol>
				<li value="1">First include the required header files as illustrated:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;string&gt;</p></li>
				<li>Now, in the <strong class="inline">main</strong> function add a constant char variable named <strong class="inline">charString</strong> with capacity as <strong class="inline">8</strong> characters:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  // Construct a C-string being explicit about the null terminator</p><p class="snippet">  const char charString[8] = {'C', '+', '+', ' ', '1', '0', '1', '\0'};</p><p class="snippet">  // Construct a C-string from a literal string. The compiler automatically adds the \0 at the end</p><p class="snippet">  const char * literalString = "C++ Fundamentals";</p><p class="snippet">  // Strings can be constructed from literal strings.</p><p class="snippet">  std::string strString = literalString;</p></li>
				<li>Use the <strong class="inline">c_str()</strong> function and assign the value of <strong class="inline">strString</strong> to <strong class="inline">charString2</strong>:<p class="snippet">  const char *charString2 = strString.c_str();</p></li>
				<li>Print the <strong class="inline">charString</strong> and <strong class="inline">charString2</strong> using the print function:<p class="snippet">  std::cout &lt;&lt; charString &lt;&lt; std::endl;</p><p class="snippet">  std::cout &lt;&lt; charString2 &lt;&lt; std::endl;</p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">Output:</p><p class="snippet">C++ 101</p><p class="snippet">C++ Fundamentals</p></li>
			</ol>
			<p>As for vectors, strings have <strong class="inline">size()</strong>, <strong class="inline">empty()</strong>, and <strong class="inline">capacity()</strong> member functions, but there is an additional function called <strong class="inline">length()</strong>, which is just an alias for <strong class="inline">size()</strong>.</p>
			<p>Strings can be accessed in a character-by-character fashion using <strong class="inline">operator[]</strong> or the <strong class="inline">at()</strong>, <strong class="inline">front()</strong>, and <strong class="inline">back()</strong> member functions:</p>
			<p class="snippet">std::string chapter = "We are learning about strings";</p>
			<p class="snippet">std::cout &lt;&lt; "Length: " &lt;&lt; chapter.length() &lt;&lt; ", the second character is " &lt;&lt; chapter[1] &lt;&lt; std::endl;</p>
			<p>The usual comparison operators are provided for strings, thus simplifying the way two string objects can be compared.</p>
			<p>Since strings are like vectors, we can add and remove characters from them.</p>
			<p>Strings can be made empty by assigning an empty string, by calling the <strong class="inline">clear()</strong>, or <strong class="inline">erase()</strong> functions.</p>
			<p>Let's look at the following code to understand the usage of the <strong class="inline">clear()</strong> and <strong class="inline">erase()</strong> functions:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;string&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::string str = "C++ Fundamentals.";</p>
			<p class="snippet">  std::cout &lt;&lt; str &lt;&lt; std::endl;</p>
			<p class="snippet">  str.erase(5,10);</p>
			<p class="snippet">  std::cout &lt;&lt; "Erased: " &lt;&lt; str &lt;&lt; std::endl;</p>
			<p class="snippet">  str.clear();</p>
			<p class="snippet">  std::cout &lt;&lt; "Cleared: " &lt;&lt; str &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">C++ Fundamentals.</p>
			<p class="snippet">Erased: C++ Fs.</p>
			<p class="snippet">Cleared: </p>
			<p>C++ also provides many convenience functions to convert a string into numeric values or vice versa. For example, the <strong class="inline">stoi()</strong> and <strong class="inline">stod()</strong> functions (which stand for <em class="italics">string-to-int</em> and <em class="italics">string-to-double</em>) are used to convert <strong class="inline">string</strong> to <strong class="inline">int</strong> and <strong class="inline">double</strong>, respectively. Instead, to convert a value into a string, it is possible to use the overloaded function <strong class="inline">to_string()</strong>.</p>
			<p>Let's demystify these functions using the following code:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;string&gt;</p>
			<p class="snippet">using namespace std;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::string str = "55";</p>
			<p class="snippet">  std::int strInt = std::stoi(str);</p>
			<p class="snippet">  double strDou = std::stod(str);</p>
			<p class="snippet">  std::string valToString = std::to_string(strInt);</p>
			<p class="snippet">  </p>
			<p class="snippet">  std::cout &lt;&lt; str &lt;&lt; std::endl;</p>
			<p class="snippet">  std::cout &lt;&lt; strInt &lt;&lt; std::endl;</p>
			<p class="snippet">  std::cout &lt;&lt; strDou &lt;&lt; std::endl;</p>
			<p class="snippet">  std::cout &lt;&lt; valToString &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">55</p>
			<p class="snippet">55</p>
			<p class="snippet">55</p>
			<p class="snippet">55</p>
			<h3 id="_idParaDest-172"><a id="_idTextAnchor202"/>Pairs and Tuples</h3>
			<p>The <strong class="bold">pair</strong> and <strong class="bold">tuple</strong> classes are similar to some extent, in the way they can store a collection of heterogeneous elements.</p>
			<p>The <strong class="bold">pair</strong> class can store the values of two types, while the <strong class="bold">tuple</strong> class extended this concept to any length.</p>
			<p>Pair is defined in the <strong class="inline">&lt;utility&gt;</strong> header, while tuple is in the <strong class="inline">&lt;tuple&gt;</strong> header.</p>
			<p>The pair constructor takes two types as template parameters, used to specify the types for the first and second values. Those elements are accessed directly using the <strong class="inline">first</strong> and <strong class="inline">second</strong> data. Equivalently, these members can be accessed with the <strong class="inline">get&lt;0&gt;()</strong> and <strong class="inline">get&lt;1&gt;()</strong> functions.</p>
			<p>The <strong class="inline">make_pair()</strong> convenience function is used to create a value pair without explicitly specifying the types:</p>
			<p class="snippet">std::pair&lt;std::string, int&gt; nameAndAge = std::make_pair("John", 32);</p>
			<p class="snippet">std::cout &lt;&lt; "Name: " &lt;&lt; nameAndAge.first &lt;&lt; ", age: " &lt;&lt; nameAndAge.second &lt;&lt; std::endl;</p>
			<p>The second line is equivalent to the following one:</p>
			<p class="snippet">std::cout &lt;&lt; "Name: " &lt;&lt; std::get&lt;0&gt;(nameAndAge) &lt;&lt; ", age: " &lt;&lt; std::get&lt;1&gt;(nameAndAge) &lt;&lt; std::endl;</p>
			<p>Pairs are used by unordered map, unordered multimap, map, and multimap containers to manage their key/value elements.</p>
			<p>Tuples are similar to pairs. The constructor allows you to provide a variable number of template arguments. Elements are accessed with the <strong class="inline">get&lt;N&gt;()</strong> function only, which returns the nth element inside the tuple, and there is a convenience function to create them similar to that for pair, named <strong class="inline">make_tuple()</strong>. </p>
			<p>Additionally, tuples have another convenience function that's used to extract values from them. The <strong class="inline">tie()</strong> function allows for the creation of a tuple of references, which is useful in assigning selected elements from a tuple to specific variables.</p>
			<p>Let's understand how to use the <strong class="inline">make_tuple()</strong> and <strong class="inline">get()</strong> functions to retrieve data from a tuple:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;tuple&gt;</p>
			<p class="snippet">#include &lt;string&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::tuple&lt;std::string, int, float&gt; james = std::make_tuple("James", 7, 1.90f);</p>
			<p class="snippet">  std::cout &lt;&lt; "Name: " &lt;&lt; std::get&lt;0&gt;(james) &lt;&lt; ". Agent number: " &lt;&lt; std::get&lt;1&gt;(james) &lt;&lt; ". Height: " &lt;&lt; std::get&lt;2&gt;(james) &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Name: James. Agent number: 7. Height: 1.9</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor203"/>std::optional</h2>
			<p><strong class="inline">optional&lt;T&gt;</strong> is a that's used to contain a value that might be present or not.</p>
			<p>The class takes a template parameter, <strong class="inline">T</strong>, which represents the type that the <strong class="inline">std::optional</strong> template class might contain. Value type means that the instance of the class contains the value. Copying <strong class="inline">optional</strong> will create a new copy of the contained data.</p>
			<p>At any point in the execution of the program, <strong class="inline">optional&lt;T&gt;</strong> either contains nothing, when it's empty, or contains a value of type <strong class="inline">T</strong>.</p>
			<p>Optional is defined in the <strong class="inline">&lt;optional&gt;</strong> header.</p>
			<p>Let's imagine our application is using a class named <strong class="inline">User</strong> for managing registered users. We would like to have a function that gets us the information of a user from their email: <strong class="inline">User getUserByEmail(Email email);</strong>.</p>
			<p>But what happens when a user is not registered? That is, when we can determine that our system does not have the associated <strong class="inline">User</strong> instance?</p>
			<p>Some would suggest throwing an exception. In C++, exceptions are used for <em class="italics">exceptional</em> situations, ones that should almost never happen. A user not being registered on our website is a perfectly normal situation.</p>
			<p>In these situations, we can use the <strong class="inline">optional</strong> template class to represent the fact that we might not have the data:</p>
			<p class="snippet">std::optional&lt;User&gt; tryGetUserByEmail(Email email);</p>
			<p>The <strong class="inline">optional</strong> template provides two easy methods to work with:</p>
			<ul>
				<li><strong class="inline">has_value()</strong>: This returns <strong class="inline">true</strong> if <strong class="inline">optional</strong> is currently holding a value, and <strong class="inline">false</strong> if the variant is empty.</li>
				<li><strong class="inline">value()</strong>: This function returns the value currently held by <strong class="inline">optional</strong>, or throws an exception if it's not present.</li>
				<li>Additionally, <strong class="inline">optional</strong> can be used as a condition in an <strong class="inline">if</strong> statement: it will evaluate to <strong class="inline">true</strong> if it contains a value, or <strong class="inline">false</strong> otherwise.</li>
			</ul>
			<p>Let's look at the following example to understand how the <strong class="inline">has_value()</strong> and <strong class="inline">value()</strong> functions work:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;optional&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  // We might not know the hour. But if we know it, it's an integer</p>
			<p class="snippet">  std::optional&lt;int&gt; currentHour;</p>
			<p class="snippet">  if (not currentHour.has_value()) {</p>
			<p class="snippet">    std::cout &lt;&lt; "We don't know the time" &lt;&lt; std::endl;   </p>
			<p class="snippet">  }</p>
			<p class="snippet">  currentHour = 18;</p>
			<p class="snippet">  if (currentHour) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Current hour is: " &lt;&lt; currentHour.value() &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">We don't know the time</p>
			<p class="snippet">Current hour is: 18</p>
			<p>The <strong class="inline">optional</strong> template comes with additional convenience features. We can assign the <strong class="inline">std::nullopt</strong> value to <strong class="inline">optional</strong> to make it explicit when we want it empty, and we can use the <strong class="inline">make_optional</strong> value to create an optional from a value. Additionally, we can use the dereference operator, <strong class="inline">*</strong>, to access the value of <strong class="inline">optional</strong> without throwing an exception if the value is not present. In such cases, we will access invalid data, so we need to be sure that <strong class="inline">optional</strong> contains a value when we use <strong class="inline">*</strong>:</p>
			<p class="snippet">std::optional&lt;std::string&gt; maybeUser = std::nullopt;</p>
			<p class="snippet">if (not maybeUser) {</p>
			<p class="snippet">  std::cout &lt;&lt; "The user is not present" &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">maybeUser = std::make_optional&lt;std::string&gt;("email@example.com");</p>
			<p class="snippet">if (maybeUser) {</p>
			<p class="snippet">  std::cout &lt;&lt; "The user is: " &lt;&lt; *maybeUser  &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p>Another handy method is <strong class="inline">value_or(defaultValue)</strong>. This function takes a default value and returns the value contained by <strong class="inline">optional</strong> if it currently holds a value, otherwise it returns the default value. Let's explore the following example:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;optional&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::optional&lt;int&gt; x;</p>
			<p class="snippet">  std::cout &lt;&lt; x.value_or(10) &lt;&lt; std::endl;</p>
			<p class="snippet">  //Will return value of x as 10</p>
			<p class="snippet">  x = 15;</p>
			<p class="snippet">  std::cout &lt;&lt; x.value_or(10)&lt;&lt; std::endl;</p>
			<p class="snippet">  //Will return value of x as 15</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">10</p>
			<p class="snippet">15</p>
			<p>In addition to return values, <strong class="inline">optional</strong> is useful when accepting it as an argument to represent arguments that can be present or not.</p>
			<p>Let's recall our <strong class="inline">User</strong> class that's composed of an email address, a phone number, and a physical address. Sometimes, users don't have a phone number and don't want to provide a physical address, so the only required field we have in <strong class="inline">User</strong> is the email address:</p>
			<p class="snippet">User::User(Email email, std::optional&lt;PhoneNumber&gt; phoneNumber = std::nullopt, std::optional&lt;Address&gt; address = std::nullopt){</p>
			<p class="snippet">...</p>
			<p class="snippet">}</p>
			<p>This constructor allows us to pass in all the information we have on the user. If, instead of using <strong class="inline">optional</strong>, we used multiple overloads, we would have had four overloads: </p>
			<ol>
				<li value="1">Only email</li>
				<li>Email and phone number</li>
				<li>Email and address</li>
				<li>Email with phone number and address</li>
			</ol>
			<p>You can see that the number of overloads grows quickly when there are more arguments that we might not want to pass.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor204"/>std::variant</h2>
			<p><strong class="inline">variant</strong> is a value type that's used to represent a <em class="italics">choice of types</em>. The class takes a list of types, and the variant will be able to contain one value of any of those types.</p>
			<p>It is often referred to as <strong class="keyword">tagged union</strong>, because similar to a union, it can store multiple types, with only one present at a time. It also keeps track of which type is currently stored.</p>
			<p>During the execution of a program, <strong class="inline">variant</strong> will contain exactly one of the possible types at a time.</p>
			<p>Like <strong class="inline">optional</strong>, <strong class="inline">variant</strong> is a value type: when we create a copy of <strong class="inline">variant</strong>, the element that is currently stored is copied into the new <strong class="inline">variant</strong>.</p>
			<p>To interact with <strong class="inline">std::variant</strong>, the C++ standard library gives us two main functions:</p>
			<ul>
				<li><strong class="inline">holds_alternative&lt;Type&gt;(variant)</strong>: It returns <strong class="inline">true</strong> if the variant is currently holding the provided type, if not then <strong class="inline">false</strong>.</li>
				<li><strong class="inline">get(variant)</strong>: There are two versions: <strong class="inline">get&lt;Type&gt;(variant)</strong> and <strong class="inline">get&lt;Index&gt;(variant)</strong>.</li>
			</ul>
			<p><strong class="inline">get&lt;Type&gt;(variant)</strong> gets the value of the type that's currently stored inside the variant. Before calling this function, the caller needs to be sure that <strong class="inline">holds_alternative&lt;Type&gt;(variant)</strong> returns <strong class="inline">true</strong>.</p>
			<p><strong class="inline">get&lt;Index&gt;(variant)</strong> gets the value of the index type that's currently stored inside <strong class="inline">variant</strong>. Like before, the caller needs to be sure that <strong class="inline">variant</strong> is holding the correct type.</p>
			<p>For example, with <strong class="inline">std::variant&lt;string, float&gt; variant</strong>, calling <strong class="inline">get&lt;0&gt;(variant)</strong> will give us the <strong class="inline">string</strong> value, but we need to be sure that <strong class="inline">variant</strong> is currently storing a string at the moment. Usually, it is preferable to access the elements with <strong class="inline">get&lt;Type&gt;()</strong> so that we are explicit on the type that we expect and that if the order of the types in the variant changes, we will still get the same result:</p>
			<h3 id="_idParaDest-175"><a id="_idTextAnchor205"/>Exercise 13: Using Variant in the Program</h3>
			<p>Let's perform the following steps to understand how to use variant in the program:</p>
			<ol>
				<li value="1">Include the required header files:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;variant&gt;</p></li>
				<li>In the main function, add the variant with the value type as string and integer:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  std::variant&lt;std::string, int&gt; variant = 42;</p></li>
				<li>Now using the two print statements call the variant in different ways:<p class="snippet">  std::cout &lt;&lt; get&lt;1&gt;(variant) &lt;&lt; std::endl;</p><p class="snippet">  std::cout &lt;&lt; get&lt;int&gt;(variant) &lt;&lt; std::endl;</p></li>
			</ol>
			<p>The output is as follows:</p>
			<p class="snippet">Output:</p>
			<p class="snippet">42</p>
			<p class="snippet">42</p>
			<p>An alternative way to get the content of <strong class="inline">variant</strong> is to use <strong class="inline">std::visit(visitor, variant)</strong>, which takes <strong class="inline">variant</strong> and a callable object. The callable objects need to support an overload of <strong class="inline">operator()</strong>, taking a type for each of the possible types stored inside <strong class="inline">variant</strong>. Then, <strong class="inline">visit</strong> will make sure to call the function that accepts the current type that's stored inside <strong class="inline">variant</strong>:</p>
			<h3 id="_idParaDest-176"><a id="_idTextAnchor206"/>Exercise 14: Visitor Variant</h3>
			<p>Let's perform the following steps to understand how to use std::visit(visitor, variant) in the program:</p>
			<ol>
				<li value="1">Add the following header files at the start of the program:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;string&gt;</p><p class="snippet">#include &lt;variant&gt;</p></li>
				<li>Now, add the struct Visitor as illustrated:<p class="snippet">struct Visitor {</p><p class="snippet">    void operator()(const std::string&amp; value){</p><p class="snippet">        std::cout &lt;&lt; "a string: " &lt;&lt; value &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">    void operator()(const int&amp; value){</p><p class="snippet">        std::cout &lt;&lt; "an int: " &lt;&lt; value &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>Now, in the main function, call the struct Visitor and pass values as illustrated:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    std::variant&lt;std::string, int&gt; variant = 42;</p><p class="snippet">    Visitor visitor;</p><p class="snippet">    std::cout &lt;&lt; "The variant contains ";</p><p class="snippet">    std::visit(visitor, variant);</p><p class="snippet">    variant = std::string("Hello world");</p><p class="snippet">    std::cout &lt;&lt; "The variant contains ";</p><p class="snippet">    std::visit(visitor, variant);</p><p class="snippet">}</p></li>
			</ol>
			<p>The output is as follows:</p>
			<p class="snippet">The variant contains an int: 42</p>
			<p class="snippet">The variant contains a string: Hello world</p>
			<p><strong class="inline">variant</strong> is incredibly valuable when we want to represent a set of values of different types. Typical examples are as follows:</p>
			<ul>
				<li>A function returning different types depending on the current state of the program</li>
				<li>A class that represents several states</li>
			</ul>
			<p>Let's imagine our <strong class="inline">std::optional&lt;User&gt; tryGetUserByEmail()</strong> function, which we described earlier.</p>
			<p>Thanks to <strong class="inline">optional</strong>, we could now write the function in a clear way, showing that sometimes we would not retrieve the user. It is likely that if the user is not registered, we might ask them whether they want to register.</p>
			<p>Let's imagine we have <strong class="inline">struct UserRegistrationForm</strong>, which contains the information that's needed to let the user register.</p>
			<p>Our function can now return <strong class="inline">std::variant&lt;User, UserRegistrationForm&gt; tryGetUserByEmail()</strong>. When the user is registered, we return <strong class="inline">User</strong>, but if the user is not registered, we can return the registration form.</p>
			<p>Additionally, what should we do when there is an error? With <strong class="inline">variant</strong>, we could have <strong class="inline">struct GetUserError</strong> storing all the information we have so that our application will be able to recover from the error and add it to the return type: <strong class="inline">std::variant&lt;User</strong>, <strong class="inline">UserRegistrationForm</strong>, <strong class="inline">GetUserError&gt;</strong>, or <strong class="inline">tryGetUserByEmail()</strong>.</p>
			<p>Now we can have the complete picture of what is going to happen when we call <strong class="inline">getUserByEmail()</strong> by just looking at the function signature, and the compiler will help us make sure that we handle all the cases.</p>
			<p>Alternatively, <strong class="inline">variant</strong> can also be used to represent the various states in which a class can be. Each state contains the data that's required for that state, and the class only manages the transitions from one state to another.</p>
			<h3 id="_idParaDest-177"><a id="_idTextAnchor207"/>Activity 22: Airport System Management</h3>
			<p>Let's write a program to create airport system management:</p>
			<ol>
				<li value="1">We want to represent the state of an airplane in an airport system. The airplane can be in three states: <strong class="inline">at_gate</strong>, <strong class="inline">taxi</strong>, or <strong class="inline">flying</strong>. The three states store different information.</li>
				<li>With <strong class="inline">at_gate</strong>, the airplane stores the gate number at which it is. With <strong class="inline">taxi</strong>, we store which lane the airplane is assigned and how many passengers are on board. With <strong class="inline">flying</strong>, we store the speed:<p class="snippet">struct AtGate {</p><p class="snippet">    int gate;</p><p class="snippet">};</p><p class="snippet">struct Taxi {</p><p class="snippet">    int lane;</p><p class="snippet">    int numPassengers;</p><p class="snippet">};</p><p class="snippet">struct Flying {</p><p class="snippet">    float speed;</p><p class="snippet">};</p></li>
				<li>The airplane should have three methods:<ul><li><strong class="inline">startTaxi()</strong>: This method takes the lane the airplane should go on and the number of passengers on board. The airplane can start taxi only if it is at the gate.</li>
<li><strong class="inline">takeOff()</strong>: This method takes the speed at which the airplane should fly. The airplane can start flying only if it is in the taxi state.</li>
<li><strong class="inline">currentStatus()</strong>: This method prints the current status of the airplane.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 306.</p></li>
</ul></li>
			</ol>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor208"/>Iterators</h2>
			<p>In this chapter, we've mentioned multiple times that elements have a position in a container: for example, we said that we can insert an element in a specific position in a list.</p>
			<p>Iterators are the way in which the position of an element in a container is represented.</p>
			<p>They provide a consistent way to operate on elements of the container, abstracting the details of the container to which the elements belong.</p>
			<p>An iterator always belongs to a range. The iterator representing the start of the range, can be accessed by the <strong class="inline">begin()</strong> function, while the iterator representing the end of the range, non-inclusive, can be obtained with the <strong class="inline">end()</strong> function. The range where the first element is included, but where the last one is excluded, is referred to as half-open.</p>
			<p>The interface that the iterator must offer is composed of four functions:</p>
			<ol>
				<li value="1">The <strong class="inline">*</strong> operator provides access to the element at the position currently referenced by the iterator.</li>
				<li>The <strong class="inline">++</strong> operator is used to move forward to the next element. </li>
				<li>Then, the <strong class="inline">==</strong> operator is used to compare two iterators to check whether they are pointing to the same position.<p>Note that two iterators can only be compared if they are part of the same range: they must represent the position of elements of the same container.</p></li>
				<li>Finally, the <strong class="inline">=</strong> operator is used to assign an iterator.</li>
			</ol>
			<p>Every container class in C++ must specify the type of iterator that it provides to access its elements as a member type alias named <strong class="inline">iterator</strong>. For example, for a vector of integer, the type would be <strong class="inline">std::vector&lt;int&gt;::iterator</strong>.</p>
			<p>Let's see how we could use iterators to iterate over all the elements of a container (a vector, in this case):</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; numbers = {1, 2, 3};</p>
			<p class="snippet">    for(std::vector&lt;int&gt;::iterator it = numbers.begin(); it != numbers.end(); ++it) {</p>
			<p class="snippet">        std::cout &lt;&lt; "The number is: " &lt;&lt; *it &lt;&lt; std::endl;    </p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>This looks complex for such an operation, and we saw in <em class="italics">Chapter 1, Getting Started</em> how we can use <em class="italics">range-based for:</em></p>
			<p class="snippet">for(int number: numbers) {</p>
			<p class="snippet">    std::cout &lt;&lt; "The number is: " &lt;&lt; number &lt;&lt; std::endl;    </p>
			<p class="snippet">}</p>
			<p>R<em class="italics">ange-based for</em> works thanks to iterators: the compiler rewrites our <em class="italics">range-based for</em> to look like the one we wrote with iterators. This allows the <em class="italics">range-based for</em> to work with any type that provides <strong class="inline">begin()</strong> and <strong class="inline">end()</strong> functions and returns iterators.</p>
			<p>The way operators provided by the iterators are implemented depends on the container on which the iterator operates.</p>
			<p>Iterator can be grouped into four categories. Each category builds on the previous category, thus offering additional functionality:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="" src="image/C11557_05_17.jpg"/>
				</div>
			</div>
			<h6>Figure 5.17: Table presenting iterators and their descriptions</h6>
			<p>The following diagram gives more detail about C++ iterators:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 5.18: Representation of iterators in C++" src="image/C11557_05_18.jpg"/>
				</div>
			</div>
			<h6>Figure 5.18: Representation of iterators hierarchy in C++</h6>
			<p>Let's understand each of these iterators in more detail:</p>
			<ul>
				<li><strong class="keyword">Input iterator</strong> can step forward and allow you to read the element it is pointing to. The iterator can be copied, but when one copy is incremented or dereferenced to access the element, all the other copies are invalidated and cannot be incremented or dereferenced anymore. Conceptually, it means that elements in a sequence that are accessed through an input iterator can only be read once at most.<p>Input iterators are usually used in a pattern where access to elements is always followed by a position increment.</p><p>Additionally, input iterators provide the <strong class="inline">==</strong> and <strong class="inline">!=</strong> operators to check whether the iterator is equal to the <strong class="inline">end()</strong> value.</p><p>Typically, input iterators are used to access elements from a stream of elements, where the whole sequence is not stored in memory, but we are obtaining one element at a time.</p></li>
				<li><strong class="keyword">Forward iterators</strong> are very similar to input iterators but provide additional guarantees.<p>The same iterator can be dereferenced several times to access the element it points to.</p><p>Additionally, when we increment or dereference a forward iterator, the other copies are not invalidated: if we make a copy of a forward iterator, we can advance the first one, and the second can still be used to access the previous element.</p><p>Two iterators that refer to the same element are guaranteed to be equal.</p></li>
				<li><strong class="keyword">Bidirectional iterators</strong> are also forward iterators with the additional ability to iterate backward over the elements using the <strong class="inline">operator--</strong> (position decrement) member function. </li>
				<li><strong class="keyword">Random-access iterators</strong> are also bidirectional iterators with the additional ability to directly access any position without the need of a linear scan, in constant time. Random-access iterators are provided by the <strong class="inline">operator[]</strong> member function to access elements at generic indexes and the binary <strong class="inline">operator+</strong> and <strong class="inline">operator-</strong> to step forward and backward of any quantity.</li>
			</ul>
			<h3 id="_idParaDest-179"><a id="_idTextAnchor209"/>Exercise 15: Exploring Iterator</h3>
			<p>Perform the following steps to explore the four categories discussed in the previous section and writing to the element it points to, it is also an Output Iterator:</p>
			<ol>
				<li value="1">Add the following header files at the start of the program:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;vector&gt;</p></li>
				<li>In the main function declare the vector named number:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};</p><p class="snippet">    auto it = numbers.begin();</p></li>
				<li>Perform the various arithmetic operations as illustrated:<p class="snippet">    std::cout &lt;&lt; *it &lt;&lt; std::endl; // dereference: points to 1</p><p class="snippet">    it++; // increment: now it points to 2</p><p class="snippet">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</p><p class="snippet">    // random access: access the 2th element after the current one</p><p class="snippet">    std::cout &lt;&lt; it[2] &lt;&lt; std::endl;</p><p class="snippet">    --it; // decrement: now it points to 1 again</p><p class="snippet">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</p><p class="snippet">    it += 4; // advance the iterator by 4 positions: now it points to 5</p><p class="snippet">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</p><p class="snippet">    it++; // advance past the last element;</p><p class="snippet">    std::cout &lt;&lt; "'it' is after the past element: " &lt;&lt; (it == numbers.end()) &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
			</ol>
			<p>The output is as follows:</p>
			<p class="snippet">1</p>
			<p class="snippet">2</p>
			<p class="snippet">4</p>
			<p class="snippet">1</p>
			<p class="snippet">5</p>
			<p class="snippet">'it' is after the past element: 1</p>
			<p>Many of the iterators we will talk about are defined in the <strong class="inline">&lt;iterator&gt;</strong> header.</p>
			<h3 id="_idParaDest-180"><a id="_idTextAnchor210"/>Reverse Iterators</h3>
			<p>Sometimes, we need to iterate though a collection of elements in reverse order.</p>
			<p>C++ provides an iterator that allows us to do this: the <em class="italics">reverse iterator</em>.</p>
			<p>A <em class="italics">reverse iterator</em> wraps a <em class="italics">bidirectional iterator</em> and swaps the operation increment with the operation of decrement, and vice versa.</p>
			<p>Because of this, when we are iterating a reverse iterator in the forward direction, we are visiting the elements in a range in backward order.</p>
			<p>We can reverse the range of a container by calling the following methods on a container:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 5.19: Table representing iterator functions and its description" src="image/C11557_05_19.jpg"/>
				</div>
			</div>
			<h6>Figure 5.19: Table presenting iterator functions and their descriptions</h6>
			<p>Code that works on normal iterators, it will also work with reverse iterators.</p>
			<p>For example, we can see how similar the code is to iterate in reverse order.</p>
			<h3 id="_idParaDest-181"><a id="_idTextAnchor211"/>Exercise 16: Exploring Functions of Reverse Iterator</h3>
			<p>Let's perform the following steps to understand how functions in reverse iterator works:</p>
			<ol>
				<li value="1">Add the following header files at the start of the program:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;vector&gt;</p></li>
				<li>In the main function, add the vector named numbers as illustrated:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};</p></li>
				<li>Now iterate through the number vector as illustrated:<p class="snippet">    for(auto rit = numbers.rbegin(); rit != numbers.rend(); ++rit) {</p><p class="snippet">        std::cout &lt;&lt; "The number is: " &lt;&lt; *rit &lt;&lt; std::endl;    </p><p class="snippet">    }</p><p class="snippet">}</p></li>
			</ol>
			<p>The output is as follows:</p>
			<p class="snippet">The number is: 5</p>
			<p class="snippet">The number is: 4</p>
			<p class="snippet">The number is: 3</p>
			<p class="snippet">The number is: 2</p>
			<p class="snippet">The number is: 1</p>
			<h3 id="_idParaDest-182"><a id="_idTextAnchor212"/>Insert Iterators</h3>
			<p><strong class="bold">Insert iterators</strong>, also called <strong class="keyword">inserters</strong>, are used to insert new values into a container rather than overwrite them.</p>
			<p>There exist three types of inserters, which differ on the position in the container at which they insert the elements.</p>
			<p>The following table summarizes the different categories:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer065">
					<img alt="Figure 5.20: Table representing iterator functions and its description" src="image/C11557_05_20.jpg"/>
				</div>
			</div>
			<h6>Figure 5.20: Table presenting iterator functions and their descriptions</h6>
			<p>Some algorithms, which we are going to see later in this chapter, require an iterator for storing data. Insert iterators are usually used with such algorithms.</p>
			<h3 id="_idParaDest-183"><a id="_idTextAnchor213"/>Stream Iterators</h3>
			<p><strong class="inline">Stream iterators</strong> allow us to use streams as a source to read elements from or as a destination to write elements to:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 5.21: Table representing iterator functions and its description " src="image/C11557_05_21.jpg"/>
				</div>
			</div>
			<h6>Figure 5.21: Table presenting iterator functions and their descriptions</h6>
			<p>Because we don't have a container in this case, we cannot call the <strong class="inline">end()</strong> method to get the <strong class="inline">end</strong> iterator. A default constructed stream iterator counts as the end of any stream range.</p>
			<p>Let's look at a program that reads space-separated integers from the standard input.</p>
			<h3 id="_idParaDest-184"><a id="_idTextAnchor214"/>Exercise 17: Stream Iterator</h3>
			<p>Let's perform the following steps to understand how functions in reverse stream works:</p>
			<ol>
				<li value="1">Add the required header files as illustrated:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;iterator&gt;</p></li>
				<li>Now, in the main function, add the istream iterator as illustrated: <p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    std::istream_iterator&lt;int&gt; it = std::istream_iterator&lt;int&gt;(std::cin);</p><p class="snippet">    std::istream_iterator&lt;int&gt; end;</p><p class="snippet">    for(; it != end; ++it) {</p><p class="snippet">        std::cout &lt;&lt; "The number is: " &lt;&lt; *it &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">}</p></li>
			</ol>
			<p>The output is as follows (input: 10):</p>
			<p class="snippet">The number is: 10</p>
			<h3 id="_idParaDest-185"><a id="_idTextAnchor215"/>Iterator Invalidation</h3>
			<p>As we said, iterators represent the position of elements in a container.</p>
			<p>This means that they are tightly tied with the container, and changes to the container might move the elements: this means that iterators pointing to such an element can no longer be used – they are <strong class="keyword">invalidated</strong>.</p>
			<p>It is extremely important to always check the invalidation contract when using iterators with containers, as it is not specified what happens when using an invalidated iterator. More commonly, invalid data is accessed or the program crashes, leading to bugs that are hard to find.</p>
			<p>If we keep in mind how the containers are implemented, as we saw earlier in this chapter, we can more easily remember when an iterator is invalidated.</p>
			<p>For example, we said that when we insert an element in a vector, we might have to get more memory to store the element, in which case all the previous elements are moved to the newly obtained memory. This means that all the iterators pointing to the elements are now pointing to the old location of the elements: they are invalidated.</p>
			<p>On the other hand, we saw that when we insert an element into the list, we only have to update the predecessor and successor nodes, but the elements are not moved. This means that the iterators to the elements remain valid:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;list&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; vector = {1};</p>
			<p class="snippet">    auto first_in_vec = vector.begin();</p>
			<p class="snippet">    std::cout &lt;&lt; "Before vector insert: " &lt;&lt; *first_in_vec &lt;&lt; std::endl;</p>
			<p class="snippet">    vector.push_back(2);</p>
			<p class="snippet">    // first_number is invalidated! We can no longer use it!</p>
			<p class="snippet">    std::list&lt;int&gt; list = {1};</p>
			<p class="snippet">    auto first_in_list = list.begin();</p>
			<p class="snippet">    list.push_back(2);</p>
			<p class="snippet">    // first_in_list is not invalidated, we can use it.</p>
			<p class="snippet">    std::cout &lt;&lt; "After list insert: " &lt;&lt; *first_in_list &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Before vector insert: 1</p>
			<p class="snippet">After list insert: 1</p>
			<p>When there is a need to store iterators to elements, iterator invalidation is an important consideration to make when deciding which container to use.</p>
			<h3 id="_idParaDest-186"><a id="_idTextAnchor216"/>Exercise 18: Printing All of the Customers' Balances</h3>
			<p>We want to print the balances for all of the customers of our application. The balances are already stored inside a vector as integers.</p>
			<p>We want to use iterators to traverse the vector of balances. Follow these steps to do so:</p>
			<ol>
				<li value="1">Initially, we include the header file for the <strong class="inline">vector</strong> class, and we declare a vector of 10 elements of type <strong class="inline">int</strong>:<p class="snippet">#include &lt;vector&gt;</p><p class="snippet">std::vector&lt;int&gt; balances = {10, 34, 64, 97, 56, 43, 50, 89, 32, 5};</p></li>
				<li>The <strong class="inline">for</strong> loop has been modified to iterate using the vector's iterator, starting from the position returned by <strong class="inline">begin()</strong> until it reaches the one returned by <strong class="inline">end()</strong>:<p class="snippet">for (auto pos = numbers.begin(); pos != numbers.end(); ++pos)</p><p class="snippet">{</p><p class="snippet">    // to be filled</p><p class="snippet">}</p></li>
				<li>The element of the array is accessed using the dereference operator (<strong class="inline">*</strong>) on the iterator:<p class="snippet">for (auto pos = numbers.begin(); pos != numbers.end(); ++pos)</p><p class="snippet">{</p><p class="snippet">    std::cout &lt;&lt; "Balance: " &lt;&lt; *pos &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
			</ol>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor217"/>Algorithms Provided by the C++ Standard Template Library</h2>
			<p>Algorithms are a way to operate on containers in an abstract way.</p>
			<p>The C++ standard library provides a wide range of algorithms for all the common operations that can be performed on ranges of elements.</p>
			<p>Because algorithms accept iterators, they can operate on any container, even user-defined containers, as long as they provide iterators.</p>
			<p>This allows us to have a large number of algorithms that work with a large number of containers, without the need for the algorithm to know how the container is implemented.</p>
			<p>The following are some of the most important and common algorithms that are provided by the STL.</p>
			<h4>Note</h4>
			<p class="callout">Algorithms operate on ranges, so they normally take a pair of iterators: <em class="italics">first</em> and <em class="italics">last</em>.</p>
			<p class="callout">As we said earlier in this chapter, the <em class="italics">last</em> iterator denotes the element past the end of the range – it is not part of the range.</p>
			<p class="callout">This means that when we want to operate on a full container, we can pass <strong class="inline">begin()</strong> and <strong class="inline">end()</strong> as arguments to the algorithm, but if we want to operate on a shorter sequence, we must be sure that our <em class="italics">last</em> iterator is past the last item we want to include in the range.</p>
			<h3 id="_idParaDest-188"><a id="_idTextAnchor218"/>Lambda</h3>
			<p>Most of the algorithms accept a unary or binary predicate: a <strong class="inline">Functor</strong> (function object), which accepts either one or two parameters. These predicates allow the user to specify some of the actions that the algorithm requires. What the actions are vary from algorithm to algorithm.</p>
			<p>As we saw at the end of <em class="italics">Chapter 3, Classes</em>, to write a function object, we have to create a class and overload the <strong class="inline">operator()</strong>.</p>
			<p>This can be very verbose, especially when the functor should perform a simple operation.</p>
			<p>To overcome this with C++, the user has to write a <strong class="keyword">lambda expression</strong>, also called just a <em class="italics">lambda</em>.</p>
			<p>A <em class="italics">lambda expression</em> creates a special function object, with a type known only by the compiler, that behaves like a function but can access the variables in the scope in which it is created.</p>
			<p>It is defined with a syntax very similar to the one of functions:</p>
			<p class="snippet">[captured variables] (arguments) { body }</p>
			<p>This creates a new object that, when called with the arguments specified in the lambda expression, executes the body of the function.</p>
			<p><em class="italics">Arguments</em> is the list of arguments the function accepts, and <em class="italics">body</em> is the sequence of statements to execute when the function is invoked. They have the same meaning that they have for functions, and the same rules we saw in <em class="italics">Chapter 2, Functions,</em> apply.</p>
			<p>For example, let's create a lambda that takes two integers and returns their sum:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    auto sum_numbers = [] (int a, int b) { return a + b; };</p>
			<p class="snippet">    std::cout &lt;&lt; sum_numbers(10, 20) &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">30</p>
			<p>By default, the body of the lambda can only reference the variables that are defined in the argument list and inside the body, like for functions.</p>
			<p>Additionally, <em class="italics">lambdas</em> can <strong class="keyword">capture</strong> a variable in the local scope, and use it in their body.</p>
			<p><em class="italics">Captured variables</em> entail a list of variable names that can be referenced in the body of the lambda.</p>
			<p>When a variable is captured, it is stored inside the created function object, and it can be referenced in the body.</p>
			<p>By default, the variables are <em class="italics">captured by value</em>, so they are copied inside the function object:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    int addend = 1;</p>
			<p class="snippet">    auto sum_numbers = [addend](int b) { return addend + b; };</p>
			<p class="snippet">    addend = 2;</p>
			<p class="snippet">    std::cout &lt;&lt; sum_numbers(3) &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">4</p>
			<p>When we created the lambda, we captured <strong class="inline">addend</strong> by value: it was copied into the <strong class="inline">sum_numbers</strong> object. Even if we modified the value of <strong class="inline">addend</strong>, we did not change the copy stored inside <strong class="inline">sum_numbers</strong>, so when <strong class="inline">sum_numbers</strong> is executed, it sums 1 to <strong class="inline">b</strong>.</p>
			<p>In some situations, we want to be able to modify the value of a variable in the scope in which the <em class="italics">lambda</em> is created, or we want to access the actual value, not the value that the variable had when the lambda was created.</p>
			<p>In that case, we can capture by reference by prepending <strong class="inline">&amp;</strong> to the variable name.</p>
			<h4>Note</h4>
			<p class="callout">When we capture by reference, we need to make sure that the variable that's been captured by reference is still valid when the lambda is invoked, otherwise the body of the function accesses an invalid object, resulting in bugs.Prefer to capture by value when it is possible.</p>
			<p>Let's look at an example:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    int multiplier = 1;</p>
			<p class="snippet">    auto multiply_numbers = [&amp;multiplier](int b) { return multiplier * b; };</p>
			<p class="snippet">    multiplier = 2;</p>
			<p class="snippet">    std::cout &lt;&lt; multiply_numbers(3) &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">6</p>
			<p>Here, we capture the <strong class="inline">multiplier</strong> variable by reference: only a reference to it was stored into <strong class="inline">multiply_numbers</strong>. </p>
			<p>When we invoke <strong class="inline">multiply_numbers</strong>, the body accesses the current value of <strong class="inline">multiplier</strong>, and since <strong class="inline">multiplier</strong> was changed to 2, that is the value that's used by the <em class="italics">lambda</em>.</p>
			<p>A lambda can capture multiple variables, and each one can be either captured by value or by reference, independently one from the other.</p>
			<h3 id="_idParaDest-189"><a id="_idTextAnchor219"/>Read-Only Algorithms</h3>
			<p>Read-only algorithms are algorithms that inspect the elements stored inside a container but do not modify the order of the elements of the container.</p>
			<p>The following are the most common operations that inspect the elements of a range:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 5.22: Table representing the operations that inspect elements of a range" src="image/C11557_05_22.jpg"/>
				</div>
			</div>
			<h6>Figure 5.22: Table presenting the operations that inspect elements of a range</h6>
			<p>Let's see how we can use these functions:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;algorithm&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; vector = {1, 2, 3, 4};</p>
			<p class="snippet">    bool allLessThen10 = std::all_of(vector.begin(), vector.end(), [](int value) { return value &lt; 10; });</p>
			<p class="snippet">    std::cout &lt;&lt; "All are less than 10: " &lt;&lt; allLessThen10 &lt;&lt; std::endl;</p>
			<p class="snippet">    bool someAreEven = std::any_of(vector.begin(), vector.end(), [](int value) { return value % 2 == 0; });</p>
			<p class="snippet">    std::cout &lt;&lt; "Some are even: " &lt;&lt; someAreEven &lt;&lt; std::endl;</p>
			<p class="snippet">    bool noneIsNegative = std::none_of(vector.begin(), vector.end(), [](int value) { return value &lt; 0; });</p>
			<p class="snippet">    std::cout &lt;&lt; "None is negative: " &lt;&lt; noneIsNegative &lt;&lt; std::endl;</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::cout &lt;&lt; "Odd numbers: " &lt;&lt; std::count_if(vector.begin(), vector.end(), [](int value) { return value % 2 == 1; }) &lt;&lt; std::endl;</p>
			<p class="snippet">    </p>
			<p class="snippet">    auto position = std::find(vector.begin(), vector.end(), 6);</p>
			<p class="snippet">    std::cout &lt;&lt; "6 was found: " &lt;&lt; (position != vector.end()) &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">All are less than 10: 1</p>
			<p class="snippet">Some are even: 1</p>
			<p class="snippet">None is negative: 1</p>
			<p class="snippet">Odd numbers: 2</p>
			<p class="snippet">6 was found: 0</p>
			<h3 id="_idParaDest-190"><a id="_idTextAnchor220"/>Modifying Algorithms</h3>
			<p>Modifying algorithms are algorithms that modify the collections they iterate on:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 5.23: Table representing the modifying algorithms" src="image/C11557_05_23.jpg"/>
				</div>
			</div>
			<h6>Figure 5.23: Table presenting the modifying algorithms</h6>
			<p>Let's see these algorithms in action:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;algorithm&gt;</p>
			<p class="snippet">#include &lt;iterator&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;std::string&gt; vector = {"Hello", "C++", "Morning", "Learning"};</p>
			<p class="snippet">    std::vector&lt;std::string&gt; longWords;</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::copy_if(vector.begin(), vector.end(), std::back_inserter(longWords), [](const std::string&amp; s) { return s.length() &gt; 3; });</p>
			<p class="snippet">    std::cout &lt;&lt; "Number of longWords: " &lt;&lt; longWords.size() &lt;&lt; std::endl;</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::vector&lt;int&gt; lengths;</p>
			<p class="snippet">    std::transform(longWords.begin(), longWords.end(), std::back_inserter(lengths), [](const std::string&amp; s) { return s.length(); });</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::cout &lt;&lt; "Lengths: ";</p>
			<p class="snippet">    std::for_each(lengths.begin(), lengths.end(), [](int length) { std::cout &lt;&lt; length &lt;&lt; " "; });</p>
			<p class="snippet">    std::cout &lt;&lt; std::endl;</p>
			<p class="snippet">    </p>
			<p class="snippet">    auto newLast = std::remove_if(lengths.begin(), lengths.end(), [](int length) { return length &lt; 7; });</p>
			<p class="snippet">    std::cout &lt;&lt; "No element removed yet: " &lt;&lt; lengths.size() &lt;&lt; std::endl;</p>
			<p class="snippet">    </p>
			<p class="snippet">    // erase all the elements between the two iterators</p>
			<p class="snippet">    lengths.erase(newLast, lengths.end());</p>
			<p class="snippet">    std::cout &lt;&lt; "Elements are removed now. Content: ";</p>
			<p class="snippet">    std::for_each(lengths.begin(), lengths.end(), [](int length) { std::cout &lt;&lt; length &lt;&lt; " "; });</p>
			<p class="snippet">    std::cout &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Number of longWords: 3</p>
			<p class="snippet">Lengths: 5 7 8 </p>
			<p class="snippet">No element removed yet: 3</p>
			<p class="snippet">Elements are removed now. Content: 7 8</p>
			<h3 id="_idParaDest-191"><a id="_idTextAnchor221"/>Mutating Algorithms</h3>
			<p>Mutating algorithms are algorithms that change the order of elements:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 5.24: Table representing the mutating algorithms" src="image/C11557_05_24.jpg"/>
				</div>
			</div>
			<h6>Figure 5.24: Table presenting mutating algorithms</h6>
			<p>Let's see how we can use them:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;random&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;algorithm&gt;</p>
			<p class="snippet">#include &lt;iterator&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; vector = {1, 2, 3, 4, 5, 6};</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::random_device randomDevice;</p>
			<p class="snippet">    std::mt19937 randomNumberGenerator(randomDevice());</p>
			<p class="snippet">    std::shuffle(vector.begin(), vector.end(), randomNumberGenerator);</p>
			<p class="snippet">    std::cout &lt;&lt; "Values: ";</p>
			<p class="snippet">    std::for_each(vector.begin(), vector.end(), [](int value) { std::cout &lt;&lt; value &lt;&lt; " "; });</p>
			<p class="snippet">    std::cout &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Values: 5 2 6 4 3 1</p>
			<h3 id="_idParaDest-192"><a id="_idTextAnchor222"/>Sorting Algorithms</h3>
			<p>This class of algorithms rearranges the order of elements within a container in a specific order:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 5.25: Table representing the sorting algorithms" src="image/C11557_05_25.jpg"/>
				</div>
			</div>
			<h6>Figure 5.25: Table presenting sorting algorithms</h6>
			<p>Here is how to sort a vector:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;algorithm&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; vector = {5, 2, 6, 4, 3, 1};</p>
			<p class="snippet">    </p>
			<p class="snippet">    std::sort(vector.begin(), vector.end());</p>
			<p class="snippet">    std::cout &lt;&lt; "Values: ";</p>
			<p class="snippet">    std::for_each(vector.begin(), vector.end(), [](int value) { std::cout &lt;&lt; value &lt;&lt; " "; });</p>
			<p class="snippet">    std::cout &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Values: 1 2 3 4 5 6</p>
			<h3 id="_idParaDest-193"><a id="_idTextAnchor223"/>Binary Search Algorithms</h3>
			<p>The following table explains the use of <strong class="inline">binary_search</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="" src="image/C11557_05_26.jpg"/>
				</div>
			</div>
			<h6>Figure 5.26: Table presenting the use of binary_search</h6>
			<p>Here's how you can utilize the binary search algorithm:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;algorithm&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; vector = {1, 2, 3, 4, 5, 6};</p>
			<p class="snippet">    </p>
			<p class="snippet">    bool found = std::binary_search(vector.begin(), vector.end(), 2);</p>
			<p class="snippet">    std::cout &lt;&lt; "Found: " &lt;&lt; found &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Found: 1</p>
			<h3 id="_idParaDest-194"><a id="_idTextAnchor224"/>Numeric Algorithms</h3>
			<p>This class of algorithms combines numeric elements using a linear operation in different ways:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 5.27: Table representing the numeric algorithm" src="image/C11557_05_27.jpg"/>
				</div>
			</div>
			<h6>Figure 5.27: Table pres<a id="_idTextAnchor225"/>enting the numeric algorithm</h6>
			<p>Let's see how we can use <strong class="inline">accumulate</strong> in the following program:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">#include &lt;algorithm&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    std::vector&lt;int&gt; costs = {1, 2, 3};</p>
			<p class="snippet">    </p>
			<p class="snippet">    int budget = 10;</p>
			<p class="snippet">    int margin = std::accumulate(costs.begin(), costs.end(), budget, [](int a, int b) { return a - b; });</p>
			<p class="snippet">    std::cout &lt;&lt; "Margin: " &lt;&lt; margin &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Margin: 4</p>
			<h3 id="_idParaDest-195"><a id="_idTextAnchor226"/>Exercise 19: Customer Analytics</h3>
			<p>We have the information of many customers of our application and we want to compute analytics data on that.</p>
			<p>Given a map that has a username as a key and a user account as a value, we would like to print the balances of the new users in descending order.</p>
			<p>A user is considered new if they registered no more than 15 days ago. The struct representing the user's account is provided and is as follows:</p>
			<p class="snippet">struct UserAccount {</p>
			<p class="snippet">    int balance;</p>
			<p class="snippet">    int daysSinceRegistered;</p>
			<p class="snippet">};</p>
			<p>Write the <strong class="inline">void computeAnalytics(std::map&lt;std::string, UserAccount&gt;&amp; accounts)</strong> function, which prints the desired balances.</p>
			<ol>
				<li value="1">Make sure to include all the required headers for the solution:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;vector&gt;</p><p class="snippet">#include &lt;iterator&gt;</p><p class="snippet">#include &lt;map&gt;</p><p class="snippet">#include &lt;algorithm&gt;</p></li>
				<li>First, we need to extract <strong class="inline">UserAccount</strong> from the map. Remember that the element the map stores is <strong class="inline">pair</strong> containing a key and value. Since we need to transform the type into <strong class="inline">UserAccount</strong>, we can use <strong class="inline">std::transform</strong>, by passing a <strong class="inline">lambda</strong> that only returns the user account from the <strong class="inline">pair</strong>. To insert this into <strong class="inline">vector</strong>, we can use <strong class="inline">std::back_inserter</strong>. Make sure to use a <strong class="inline">const</strong> reference when accepting <strong class="inline">pair</strong> in the lambda that's passed to transform:<p class="snippet">void computeAnalytics(std::map&lt;std::string, UserAccount&gt;&amp; accounts) {</p><p class="snippet">    // Balance of accounts newer than 15 days, in descending order</p><p class="snippet">    std::vector&lt;UserAccount&gt; newAccounts;</p><p class="snippet">    std::transform(accounts.begin(), accounts.end(), std::back_inserter(newAccounts),</p><p class="snippet">                 [](const std::pair&lt;std::string, UserAccount&gt;&amp; user) { return user.second; });</p><p class="snippet">    }   </p></li>
				<li>After we have extracted the accounts in <strong class="inline">vector</strong>, we can use <strong class="inline">remove_if</strong> to remove all accounts that are older than 15 days:<p class="snippet">    auto newEnd = std::remove_if(newAccounts.begin(), newAccounts.end(), [](const UserAccount&amp; account) { return account.daysSinceRegistered &gt; 15; } );</p><p class="snippet">    newAccounts.erase(newEnd, newAccounts.end());</p></li>
				<li>After removing the old accounts, we need to sort the balances in descending order. By default, <strong class="inline">std::sort</strong>  uses an ascending order, so we need to provide a <strong class="inline">lambda</strong> to change the order:<p class="snippet">    std::sort(newAccounts.begin(), newAccounts.end(), [](const UserAccount&amp; lhs, const UserAccount&amp; rhs) { return lhs.balance &gt; rhs.balance; } );</p><p class="snippet">Now that the data is sorted, we can print it:</p><p class="snippet">    for(const UserAccount&amp; account : newAccounts) {</p><p class="snippet">        std::cout &lt;&lt; account.balance &lt;&lt; std::endl;</p><p class="snippet">    }   </p><p class="snippet">}</p></li>
				<li>We can now invoke our function with the following test data:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    std::map&lt;std::string, UserAccount&gt; users = {</p><p class="snippet">        {"Alice", UserAccount{500, 15}},</p><p class="snippet">        {"Bob", UserAccount{1000, 50}},</p><p class="snippet">        {"Charlie", UserAccount{600, 17}},</p><p class="snippet">        {"Donald", UserAccount{1500, 4}}</p><p class="snippet">    };</p><p class="snippet">    computeAnalytics(users);</p><p class="snippet">}</p></li>
			</ol>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor227"/>Summary</h2>
			<p>In this chapter, we introduced sequential containers – containers whose elements can be accessed in sequence. We looked at the <strong class="inline">array</strong>, <strong class="inline">vector</strong>, <strong class="inline">deque</strong>, <strong class="inline">list</strong>, and <strong class="inline">forward_list</strong> sequential containers.</p>
			<p>We saw what functionality they offer and how we can operate on them, and we saw how they are implemented and how storage works for vector and list.</p>
			<p>We followed this up with associative containers, containers that allow the fast lookup of their elements, always kept in order. <strong class="inline">Set</strong>, <strong class="inline">multiset</strong>, <strong class="inline">map</strong>, and <strong class="inline">multimap</strong> are part of this category. </p>
			<p>We looked at the operations they support and how map and multimap are used to associate a value to a key. We also saw their unordered version, which does not keep elements in order but provides higher performance. <strong class="inline">Unordered_set</strong> and <strong class="inline">unordered_map</strong> are in this category.</p>
			<p>Finally, we looked at unconventional containers. <strong class="inline">String</strong> is used to manipulate sequences of characters, <strong class="inline">pair</strong> and <strong class="inline">tuple</strong> are used to hold various elements of different types, <strong class="inline">optional</strong> is used to add optionality to a type, and <strong class="inline">variant</strong> is used to store a value that could be of several types.</p>
			<p>We then explored iterators and learned how they are used to abstract the concept of containers and provide a common set of functionalities.</p>
			<p>We looked at the various types of iterators, and we learned what iterator invalidation is and why it is important to be aware of it.</p>
			<p>We finally moved on to algorithms in the C++ standard, after explaining that <strong class="inline">lambda</strong> is a convenient way of defining a function that can also access variables in the scope in which it is created.</p>
			<p>We divided the most common algorithms into various categories, and we looked at the most important algorithms in those categories, including <strong class="inline">find</strong>, <strong class="inline">remove</strong>, and <strong class="inline">sort</strong>.</p>
			<p><span class="normaltextrun">In the next chapter, you will learn how to use the advanced features of C++ to create dynamic programs.</span><span class="eop"> </span></p>
		</div>
</body></html>