["```cpp\n#include <cstring>\n#include <boost/array.hpp>\n\ntemplate <class T, std::size_t BufSizeV>\nvoid serialize(const T& value, boost::array<unsigned char, BufSizeV>& buffer) {\n    // TODO: fixme\n    std::memcpy(&buffer[0], &value, sizeof(value));\n}\n```", "```cpp\ntemplate <class T, std::size_t BufSizeV>\nvoid serialize(const T& value, boost::array<unsigned char, BufSizeV>& buffer) {\n    assert(BufSizeV >= sizeof(value));\n    // TODO: fixme\n    std::memcpy(&buffer[0], &value, sizeof(value));\n}\n```", "```cpp\n#include <boost/static_assert.hpp>\n#include <boost/type_traits/is_pod.hpp>\n\ntemplate <class T, std::size_t BufSizeV>\nvoid serialize(const T& value, boost::array<unsigned char, BufSizeV>& buffer) {\n    BOOST_STATIC_ASSERT(BufSizeV >= sizeof(value));\n    BOOST_STATIC_ASSERT(boost::is_pod<T>::value);\n    std::memcpy(&buffer[0], &value, sizeof(value));\n}\n```", "```cpp\nBOOST_STATIC_ASSERT(3 >= 1);\n\nstruct some_struct { enum enum_t { value = 1}; };\nBOOST_STATIC_ASSERT(some_struct::value);\n\ntemplate <class T1, class T2>\nstruct some_templated_struct {\n    enum enum_t { value = (sizeof(T1) == sizeof(T2))};\n};\nBOOST_STATIC_ASSERT((some_templated_struct<int, unsigned int>::value));\n```", "```cpp\n#include <iostream>\n#include <boost/type_traits/is_unsigned.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/remove_const.hpp>\n\ntemplate <class T1, class T2>\nvoid type_traits_examples(T1& /*v1*/, T2& /*v2*/) {\n    // Returns true if T1 is an unsigned number\n    std::cout << boost::is_unsigned<T1>::value;\n\n    // Returns true if T1 has exactly the same type, as T2\n    std::cout << boost::is_same<T1, T2>::value;\n\n    // This line removes const modifier from type of T1.\n    // Here is what will happen with T1 type if T1 is:\n    // const int => int\n    // int => int\n    // int const volatile => int volatile\n    // const int& => const int&\n    typedef typename boost::remove_const<T1>::type t1_nonconst_t;\n}\n```", "```cpp\ntemplate <class T, std::size_t BufSizeV>\nvoid serialize2(const T& value, boost::array<unsigned char, BufSizeV>& buf) {\n    BOOST_STATIC_ASSERT_MSG(boost::is_pod<T>::value,\n        \"This serialize2 function may be used only \"\n        \"with POD types.\"\n    );\n\n    BOOST_STATIC_ASSERT_MSG(BufSizeV >= sizeof(value),\n        \"Can not fit value to buffer. \"\n        \"Make buffer bigger.\"\n    );\n\n    std::memcpy(&buf[0], &value, sizeof(value));\n}\n\n    // Somewhere in code:\n    boost::array<unsigned char, 1> buf;\n    serialize2(std::string(\"Hello word\"), buf);\n```", "```cpp\n../../../BoostBook/Chapter4/static_assert/main.cpp: In instantiation of 'void serialize2(const T&, boost::array<unsigned char, BufSizeV>&) [with T = std::basic_string<char>; long unsigned int BufSizeV = 1ul]':\n../../../BoostBook/Chapter4/static_assert/main.cpp:77:46: required from here\n../../../BoostBook/Chapter4/static_assert/main.cpp:58:5: error: static assertion failed: This serialize2 function may be used only with POD types.\n../../../BoostBook/Chapter4/static_assert/main.cpp:63:5: error: static assertion failed: Can not fit value to buffer. Make buffer bigger.\n```", "```cpp\n// Generic implementation\ntemplate <class T>\nclass data_processor {\n    double process(const T& v1, const T& v2, const T& v3);\n};\n```", "```cpp\n// Integral types optimized version\ntemplate <class T>\nclass data_processor {\n    typedef int fast_int_t;\n    double process(fast_int_t v1, fast_int_t v2, fast_int_t v3);\n};\n\n// SSE optimized version for float types\ntemplate <class T>\nclass data_processor {\n    double process(double v1, double v2, double v3);\n};\n```", "```cpp\n    #include <boost/utility/enable_if.hpp>\n    #include <boost/type_traits/is_integral.hpp>\n    #include <boost/type_traits/is_float.hpp>\n    ```", "```cpp\n    // Generic implementation\n    template <class T, class Enable = void>\n    class data_processor {\n        // ...\n    };\n    ```", "```cpp\n    // Integral types optimized version\n    template <class T>\n    class data_processor<T, typename boost::enable_if_c<\n        boost::is_integral<T>::value \n    >::type> { /* ... */ };\n\n    // SSE optimized version for float types\n    template <class T>\n    class data_processor<T, typename boost::enable_if_c<\n        boost::is_float<T>::value \n    >::type> { /* ... */ };\n    ```", "```cpp\n    template <class T>\n    double example_func(T v1, T v2, T v3) {\n        data_processor<T> proc;\n        return proc.process(v1, v2, v3);\n    }\n\n    int main () {\n        // Integral types optimized version\n        // will be called\n        example_func(1, 2, 3);\n        short s = 0;\n        example_func(s, s, s);\n\n        // Real types version will be called\n        example_func(1.0, 2.0, 3.0);\n        example_func(1.0f, 2.0f, 3.0f);\n\n        // Generic version will be called\n        example_func(\"Hello\", \"word\", \"processing\");\n    }\n    ```", "```cpp\ntemplate <class T>\nT process_data(const T& v1, const T& v2, const T& v3);\n```", "```cpp\ntemplate <class T>\nT process_data_plus_assign(const T& v1, const T& v2, const T& v3);\n```", "```cpp\n    #include <boost/utility/enable_if.hpp>\n    #include <boost/type_traits/has_plus_assign.hpp>\n    ```", "```cpp\n    // Modified generic version of process_data\n    template <class T>\n    typename boost::disable_if_c<boost::has_plus_assign<T>::value,T>::type\n        process_data(const T& v1, const T& v2, const T& v3);\n    ```", "```cpp\n    // This process_data will call a process_data_plus_assign\n    template <class T>\n    typename boost::enable_if_c<boost::has_plus_assign<T>::value, T>::type\n        process_data(const T& v1, const T& v2, const T& v3)\n    {\n        return process_data_plus_assign(v1, v2, v3);\n    }\n    ```", "```cpp\n    int main() {\n        int i = 1;\n        // Optimized version\n        process_data(i, i, i);\n\n        // Default version\n        // Explicitly specifing template parameter\n        process_data<const char*>(\"Testing\", \"example\", \"function\");\n    }\n    ```", "```cpp\n// First version\ntemplate <class T>\ntypename boost::disable_if<boost::has_plus_assign<T>, T>::type\nprocess_data2(const T& v1, const T& v2, const T& v3);\n\n// process_data_plus_assign\ntemplate <class T>\ntypename boost::enable_if<boost::has_plus_assign<T>, T>::type\nprocess_data2(const T& v1, const T& v2, const T& v3);\n```", "```cpp\n#include <boost/static_assert.hpp>\n#include <boost/type_traits/is_pod.hpp>\n\n// Generic implementation\ntemplate <class T>\nT process(const T& val) {\n    BOOST_STATIC_ASSERT((boost::is_pod<T>::value));\n    // ...\n}\n```", "```cpp\n    #include <boost/mpl/int.hpp>\n\n    namespace detail {\n        // Generic implementation\n        template <class T, class Tag>\n        T process_impl(const T& val, Tag /*ignore*/) {\n            // ...\n        }\n\n        // 1 byte optimized implementation\n        template <class T>\n        T process_impl(const T& val, boost::mpl::int_<1> /*ignore*/) {\n            // ...\n        }\n\n        // 4 bytes optimized implementation\n        template <class T>\n        T process_impl(const T& val, boost::mpl::int_<4> /*ignore*/) {\n            // ...\n        }\n\n        // 8 bytes optimized implementation\n        template <class T>\n        T process_impl(const T& val, boost::mpl::int_<8> /*ignore*/) {\n            // ...\n        }\n    } // namespace detail\n    ```", "```cpp\n    // will be only dispatching calls\n    template <class T>\n    T process(const T& val) {\n        BOOST_STATIC_ASSERT((boost::is_pod<T>::value));\n        return detail::process_impl(\n            val, boost::mpl::int_<sizeof(T)>());\n    }\n    ```", "```cpp\ntemplate <int Value>\nstruct int_ {\n    static const int value = Value;\n    typedef int_<Value> type;\n    typedef int value_type;\n};\n```", "```cpp\n#include <vector>\n#include <boost/type_traits/integral_constant.hpp>\n\ntemplate <class T>\nstruct is_stdvector: boost::false_type {};\n\ntemplate <class T, class Allocator>\nstruct is_stdvector<std::vector<T, Allocator> >: boost::true_type {};\n```", "```cpp\ntemplate <class T>\nvoid inc(T& value) {\n    // call ++value\n    // or call value ++\n    // or value += T(1);\n    // or value = value + T(1);\n}\n```", "```cpp\n    namespace detail {\n        struct pre_inc_functor {\n            template <class T>\n            void operator()(T& value) const {\n               ++ value;\n            }\n        };\n\n        struct post_inc_functor {\n            template <class T>\n            void operator()(T& value) const {\n                value++;\n            }\n        };\n\n        struct plus_assignable_functor {\n            template <class T>\n            void operator()(T& value) const {\n                value += T(1);\n            }\n        };\n\n        struct plus_functor {\n            template <class T>\n            void operator()(T& value) const {\n                value = value + T(1);\n            }\n        };\n    }\n    ```", "```cpp\n    #include <boost/type_traits/conditional.hpp>\n    #include <boost/type_traits/has_plus_assign.hpp>\n    #include <boost/type_traits/has_plus.hpp>\n    #include <boost/type_traits/has_post_increment.hpp>\n    #include <boost/type_traits/has_pre_increment.hpp>\n    ```", "```cpp\n    template <class T>\n    void inc(T& value) {\n        typedef detail::plus_functor step_0_t;\n\n        typedef typename boost::conditional<\n          boost::has_plus_assign<T>::value,\n          detail::plus_assignable_functor,\n          step_0_t\n        >::type step_1_t;\n\n        typedef typename boost::conditional<\n          boost::has_post_increment<T>::value,\n          detail::post_inc_functor,\n          step_1_t\n        >::type step_2_t;\n\n        typedef typename boost::conditional<\n          boost::has_pre_increment<T>::value,\n          detail::pre_inc_functor,\n          step_2_t\n        >::type step_3_t;\n\n        step_3_t() // default constructing functor\n            (value); // calling operator() of a functor\n    }\n    ```", "```cpp\n#include <boost/mpl/if.hpp>\n\ntemplate <class T>\nvoid inc_mpl(T& value) {\n    typedef detail::plus_functor step_0_t;\n\n    typedef typename boost::mpl::if_<\n      boost::has_plus_assign<T>,\n      detail::plus_assignable_functor,\n      step_0_t\n    >::type step_1_t;\n\n    typedef typename boost::mpl::if_<\n      boost::has_post_increment<T>,\n      detail::post_inc_functor,\n      step_1_t\n    >::type step_2_t;\n\n    typedef typename boost::mpl::if_<\n      boost::has_pre_increment<T>,\n      detail::pre_inc_functor,\n      step_2_t\n    >::type step_3_t;\n\n    step_3_t() // default constructing functor\n        (value); // calling operator() of a functor\n}\n```", "```cpp\n#include <functional>\n#include <boost/bind.hpp>\n\nconst ??? var = boost::bind(std::plus<int>(), _1, _1);\n```", "```cpp\n#include <boost/typeof/typeof.hpp>\nBOOST_AUTO(var, boost::bind(std::plus<int>(), _1, _1));\n```", "```cpp\ntypedef decltype(0.5 + 0.5f) type;\n```", "```cpp\ntypedef BOOST_TYPEOF(0.5 + 0.5f) type;\n```", "```cpp\ntemplate<class T1, class T2>\nauto add(const T1& t1, const T2& t2) ->decltype(t1 + t2) {\n    return t1 + t2;\n};\n```", "```cpp\ntemplate<class T1, class T2>\nBOOST_TYPEOF_TPL(T1() + T2()) add(const T1& t1, const T2& t2) {\n    return t1 + t2;\n};\n```", "```cpp\n#include <boost/static_assert.hpp>\n#include <boost/type_traits/is_same.hpp>\nBOOST_STATIC_ASSERT((boost::is_same<BOOST_TYPEOF(add(1, 1)), int>::value));\n```", "```cpp\nnamespace readers_project {\n    template <class T1, class T2, class T3>\n    struct readers_template_class{};\n}\n\n#include <boost/tuple/tuple.hpp>\n\ntypedef\n    readers_project::readers_template_class<int, int, float>\nreaders_template_class_1;\n\ntypedef BOOST_TYPEOF(boost::get<0>(\n    boost::make_tuple(readers_template_class_1(), 1)\n)) readers_template_class_deduced;\n\nBOOST_STATIC_ASSERT((\n    boost::is_same<\n        readers_template_class_1,\n        readers_template_class_deduced\n    >::value\n));\n```", "```cpp\nBOOST_TYPEOF_REGISTER_TEMPLATE(\n        readers_project::readers_template_class /*class name*/,\n        3 /*number of template classes*/\n)\n```"]