<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer060">
<h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor595"/>14</h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor596"/>Understanding STL Basics</h1>
<p>This chapter will continue our pursuit of increasing your C++ programming repertoire beyond OOP concepts by delving into a core C++ library that has become thoroughly integrated into the common usage of the language. We will explore the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) in C++ by examining a subset of this library, representing common utilities that can both simplify our programming and make our code more easily understood by others who are undoubtedly familiar with the STL. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Surveying the contents and purpose of the STL in C++ </li>
<li>Understanding how to use essential STL containers – <a id="_idTextAnchor597"/><strong class="source-inline">list</strong>, <strong class="source-inline">iterator</strong>, <strong class="source-inline">vector</strong>, <strong class="source-inline">deque</strong>, <strong class="source-inline">stack</strong>, <strong class="source-inline">queue</strong>, <strong class="source-inline">priority_queue</strong>, <strong class="source-inline">map</strong>, and <strong class="source-inline">map</strong> using a functor</li>
<li>Customizing STL containers</li>
</ul>
<p>By the end of this chapter, you will be able to utilize core STL classes to enhance your programming skills. Because you already understand the essential C++ language and OOP features in which libraries are built, you will see that you now have the ability to navigate and understand nearly any C++ class library, including the STL. By gaining familiarity with the STL, you will be able to enhance your programming repertoire significantly and become a more savvy and valuable programmer.</p>
<p>Let’s increase our C++ toolkit by examining a very heavily utilized class library, the STL.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor598"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter14</strong> in a file named <strong class="source-inline">Chp14-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3PCL5IJ">https://bit.ly/3PCL5IJ</a>.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor599"/><a id="_idTextAnchor600"/><a id="_idTextAnchor601"/>Surveying the contents and purpose of the STL</h1>
<p>The <strong class="bold">Standard Template Library</strong> in C++ is <a id="_idIndexMarker894"/>a library of standard classes and utilities that extend the C++ language. The use of the STL is so pervasive that it is as though the STL is a part of the language itself; it is an essential and integral part of C++. The STL in C++ has four<a id="_idIndexMarker895"/> key<a id="_idIndexMarker896"/> components <a id="_idIndexMarker897"/>comprising <a id="_idIndexMarker898"/>the library: <strong class="bold">containers</strong>, <strong class="bold">iterators</strong>, <strong class="bold">functions</strong>, and <strong class="bold">algorithms</strong>. </p>
<p>The STL has additionally influenced the C++ Standard Library in providing a set of programming standards; the two libraries actually share common features and components, most notably containers and iterators. We’ve already utilized components from the Standard Library, namely <strong class="source-inline">&lt;iostream&gt;</strong> for IOStreams, <strong class="source-inline">&lt;exception&gt;</strong> for exception handling, and <strong class="source-inline">&lt;new&gt;</strong> for operators <strong class="source-inline">new()</strong> and <strong class="source-inline">delete()</strong>. In this chapter, we will explore many overlapping components between the STL and the Standard Library in C++. </p>
<p>The STL has a full line<a id="_idIndexMarker899"/> of <strong class="bold">container</strong> classes. These classes encapsulate traditional data structures to allow similar items to be collected together and uniformly processed. There are several categories of container classes – sequential, associative, and unord<a id="_idTextAnchor602"/>ered. Let’s summarize <a id="_idTextAnchor603"/>these categories and provide a few examples of each:</p>
<ul>
<li><strong class="bold">Sequential containers</strong>: Implement<a id="_idIndexMarker900"/> encapsulated data structures that can be accessed in a sequential manner, such as <strong class="source-inline">list</strong>, <strong class="source-inline">queue</strong>, or <strong class="source-inline">stack</strong>. It is interesting to note that <strong class="source-inline">queue</strong> and <strong class="source-inline">stack</strong> can be thought of as a customized or adaptive interface for a more basic container, such as a <strong class="source-inline">list</strong>. Nonetheless, a <strong class="source-inline">queue</strong> and <strong class="source-inline">stack</strong> still provide sequential access to their elements.</li>
<li><strong class="bold">Associative containers</strong>: Implement <a id="_idIndexMarker901"/>sorted, encapsulated data structures that can be searched quickly to retrieve an element such as <strong class="source-inline">set</strong> or <strong class="source-inline">map</strong>.</li>
<li><strong class="bold">Unordered containers</strong>: Implement <a id="_idIndexMarker902"/>unordered, encapsulated data structures that can be searched reasonably quickly, such as <strong class="source-inline">unordered_set</strong> or <strong class="source-inline">unordered_map</strong>.</li>
</ul>
<p>In order for these container classes to be potentially used for any data type (and to preserve strong type checking), templates are utilized to abstract and genericize the data types of the collected items. In fact, we built our own container classes using templates in <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, including <strong class="source-inline">LinkList</strong> and <strong class="source-inline">Array</strong>, so we already have a basic understanding of templatized container classes!</p>
<p>Additionally, the STL provides a full <a id="_idIndexMarker903"/>complement of <strong class="bold">iterators</strong>, which allow us to <em class="italic">walk through</em> or traverse containers. Iterators keep track of our current place without corrupting the content or ordering of the respective collections of objects. We will see how iterators allow us to process container classes more safely within the STL.</p>
<p>The STL also contains a plentiful supply<a id="_idIndexMarker904"/> of useful <strong class="bold">algorithms</strong>. Examples include sorting, counting the number of elements in a collection that may satisfy a condition, searching for particular<a id="_idIndexMarker905"/> elements or subsequences within elements, or copying elements in a variety of manners. Additional examples of algorithms include modifying a sequence of objects (replacing, swapping, and removing values), partitioning sets into ranges, or merging sets back together. Moreover, the STL contains many other useful algorithms and utilities.</p>
<p>Lastly, the STL includes<a id="_idIndexMarker906"/> functions. Actually, it<a id="_idIndexMarker907"/> would be more correct to say that the STL includes <strong class="bold">functors</strong>, or <strong class="bold">function objects</strong>. Functors are built around the ability to overload <strong class="source-inline">operator()</strong> (the function call operator), and by doing so, allow us to achieve parameterized flexibility through a function pointer. Though this is not an elementary feature of the STL we will immediately (or often) use, we will see one small, simple example of a functor in this chapter coupled with an STL container class, in the upcoming section <em class="italic">Examining STL map using a functor</em>.</p>
<p>In this chapter, we will focus on the container class section of the STL. Though we won’t examine every STL container class in the STL, we will review a healthy assortment of these classes. We will notice that some of these container classes are similar to classes that we have built together in previous chapters of this book. Incidentally, during the incremental chapter progressions of this book, we have also built up our C++ language and OOP skills, which are necessary to decode a C++ class library such as STL. </p>
<p>Let’s move<a id="_idIndexMarker908"/> forward to take a look at selective STL classes and test our C++ knowledge as we interpret each class.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor604"/>Understanding how to use essential STL containers</h1>
<p>In this section, we <a id="_idIndexMarker909"/>will put our C++ skills to the test by decoding various STL container classes. We will see that language features we have mastered, from core C++ syntax to OOP skills, have put us in a position to easily interpret the various components of STL we will now examine. Most notably, we will put our knowledge of templates to use! Our knowledge of encapsulation and inheritance, for example, will guide us to understand how to use various methods in STL classes. However, we will notice that virtual functions and abstract classes are extremely rare in the STL. The best way to gain competence with a new class within the STL will be to embrace the documentation detailing each class. With knowledge of C++, we can easily navigate through a given class to decode how to use it successfully.</p>
<p>The container classes in the C++ STL implement<a id="_idIndexMarker910"/> various <strong class="bold">Abstract Data Types</strong> (<strong class="bold">ADTs</strong>) by encapsulating the data structures that implement these higher-level concepts. We will examine core STL containers: <strong class="source-inline">list</strong>, <strong class="source-inline">iterator</strong>, <strong class="source-inline">vector</strong>, <strong class="source-inline">deque</strong>, <strong class="source-inline">stack</strong>, <strong class="source-inline">queue</strong>, <strong class="source-inline">priority_queue</strong>, and <strong class="source-inline">map</strong>. </p>
<p>Let’s begin by examining how to utilize a very basic STL <a id="_idTextAnchor605"/><a id="_idTextAnchor606"/>container, <strong class="source-inline">list<a id="_idTextAnchor607"/></strong>.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor608"/>Using STL list</h2>
<p>The STL <strong class="source-inline">list</strong> class<a id="_idIndexMarker911"/> encapsulates <a id="_idIndexMarker912"/>the data structures necessary to implement a linked list. We can say that <strong class="source-inline">list</strong> implements the Abstract Data Type of a linked list. Recall that we have made our own linked list by creating <strong class="source-inline">LinkedListElement</strong> and <strong class="source-inline">LinkedList</strong> classes in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>. STL <strong class="source-inline">list</strong> allows for easy insertion, deletion, and sorting of elements. Direct access to individual elements (known as <em class="italic">random access</em>) is not supported. Rather, you must iteratively traverse past a prior item in the linked list until you reach the desired item. STL <strong class="source-inline">list</strong> is a good example of a sequential container.</p>
<p>STL <strong class="source-inline">list</strong> actually supports bidirectional sequential access to its elements (it is implemented using a doubly-linked list). The STL additionally offers <strong class="source-inline">forward_list</strong>, allowing unidirectional sequential access to its elements with a smaller footprint than <strong class="source-inline">list</strong>; <strong class="source-inline">forward_list</strong> is implemented using a singly-linked list (much like our <strong class="source-inline">LinkedList</strong> class). </p>
<p>The STL <strong class="source-inline">list</strong> class has an assortment of member functions; we’ll start by taking a look at a few popular methods in this example to get familiar with basic STL conta<a id="_idTextAnchor609"/>iner class usage. </p>
<p>Now, let’s take a look at how we can utilize t<a id="_idTextAnchor610"/>he STL <strong class="source-inline">list</strong> class. This example can be found, as a full <a id="_idIndexMarker913"/>working <a id="_idIndexMarker914"/>program with necessary class definitions, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;list&gt;</strong>
<strong class="bold">using std::list;</strong>
int main()
{   
    <strong class="bold">list&lt;Student&gt; studentBody;</strong>   // create a list
    Student s1("Jul", "Li", 'M', "Ms.", 3.8, "C++",
               "117PSU");
    // Note: simple heap instance below, later you can opt
    // for a smart pointer to ease allocation/deallocation
    Student *s2 = new Student("Deb", "King", 'H', "Dr.", 
                              3.8, "C++", "544UD");
    // Add Students to the studentBody list. 
    <strong class="bold">studentBody.push_back(s1);</strong>
    <strong class="bold">studentBody.push_back(*s2);</strong>
    // The next 3 instances are anonymous objects in main()
    <strong class="bold">studentBody.push_back(Student("Hana", "Sato", 'U', </strong>
<strong class="bold">                          "Dr.", 3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push_back(Student("Sara", "Kato", 'B',</strong>
<strong class="bold">                          "Dr.", 3.9, "C++", "272PSU"));</strong>
    <strong class="bold">studentBody.push_back(Student("Giselle", "LeBrun", 'R',</strong>
<strong class="bold">                          "Ms.", 3.4, "C++", "299TU"));</strong>
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
       <strong class="bold">studentBody.front()</strong>.Print();
       <strong class="bold">studentBody.pop_front();</strong>
    }
    delete s2;  // delete any heap instances
    return 0;
}</pre>
<p>Let’s examine the <a id="_idIndexMarker915"/>aforementioned <a id="_idIndexMarker916"/>program segment, where we create and utilize an STL <strong class="source-inline">list</strong>. First, we <strong class="source-inline">#include &lt;list&gt;</strong> to include the approp<a id="_idTextAnchor611"/>riate STL header file. We also add <strong class="source-inline">using std::list;</strong> to include <strong class="source-inline">list</strong> from the standard namespace. Now, in <strong class="source-inline">main()</strong>, we can instantiate a list using <strong class="source-inline">list&lt;Student&gt; studentBody;</strong>. Our list will contain <strong class="source-inline">Student</strong> instances. Then, we create <strong class="source-inline">Student s1</strong> on the stack and <strong class="source-inline">Student *s2</strong> on the heap using an allocation with <strong class="source-inline">new()</strong>. </p>
<p>Next, we use <strong class="source-inline">list::push_back()</strong> to add both <strong class="source-inline">s1</strong> and <strong class="source-inline">*s2</strong> to the list. Notice that we are passing objects to <strong class="source-inline">push_back()</strong>. As we add <strong class="source-inline">Student</strong> instances to the <strong class="source-inline">studentBody</strong> list, the list will make copies of the objects internally and will properly clean up these objects when they are no longer members of the list. We need to keep in mind that if any of our instances have been allocated on the heap, such as <strong class="source-inline">*s2</strong>, we must delete our copy of that instance when we are done with it at the end of <strong class="source-inline">main()</strong>. Looking ahead to the end of <strong class="source-inline">main()</strong>, we can see that we appropriately <strong class="source-inline">delete s2;</strong>.</p>
<p>Next, we add three more students to the list. These <strong class="source-inline">Student</strong> instances do not have local identifiers. These students are instantiated within the call to <strong class="source-inline">push_back()</strong>, for example, <strong class="source-inline">studentBody.push_back(Student("Hana", "Sato", 'U', "Dr.", 3.8, "C++", "178PSU"));</strong>. Here, we are instantiating an <em class="italic">anonymous (stack) object</em> that will be properly popped off the stack and destructed once the call to <strong class="source-inline">push_back()</strong> concludes. Keep in mind, <strong class="source-inline">push_back()</strong> will also create its own local copy for these instances for their life expectancy within the <strong class="source-inline">list</strong>.</p>
<p>Now, in a while loop, we repeatedly check whether the list is <strong class="source-inline">empty()</strong> and if not, we examine the <strong class="source-inline">front()</strong> item and call our <strong class="source-inline">Student::Print()</strong> method. We then use <strong class="source-inline">pop_front()</strong> to remove that item from the list.</p>
<p>Let’s take a look at <a id="_idIndexMarker917"/>the<a id="_idIndexMarker918"/> output for this program:</p>
<p class="source-code">Ms. Jul M. Li with id: 117PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Deb H. King with id: 544UD GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</p>
<p>Now that we have deciphered a simple STL <strong class="source-inline">list</strong> class, let us move forward to understand the idea of an <strong class="source-inline">iterator</strong> to complement a container such as <strong class="source-inline">list</strong>.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor612"/>Using STL iterator</h2>
<p>Quite often, we <a id="_idIndexMarker919"/>will <a id="_idIndexMarker920"/>need a non-destructive way to iterate through a collection of objects. For example, it is important to maintain the first, last, and current position in a given container, especially if the set may be accessed by more than one method, class, or thread. Using an <strong class="bold">iterator</strong>, the STL provides a common means to traverse any container class.</p>
<p>The use of iterators has definite benefits. A class can create an <strong class="source-inline">iterator</strong> that points to the first member in a collection. Iterators can then be moved to successive next members of the collection. Iterators can provide access to elements pointed to by the <strong class="source-inline">iterator</strong>. </p>
<p>Overall, the state information of a container can be maintained by an <strong class="source-inline">iterator</strong>. Iterators provide a safe means for interleaved access by abstracting the state information away from the container and instead into the iterator class. </p>
<p>We can think of an iterator as a bookmark within a book that two or more people are referencing. The first person reads the book sequentially, leaving the bookmark neatly where they expect to continue reading. While they step away, another person looks up an important item in the book and moves the bookmark to another location in the book to save their spot. When the first person returns, they find that they have lost their current location and are not where they expect to be. Each user should have had their own bookmark or iterator. The analogy is that an iterator (ideally) allows safe interleaved access to a resource that may be handled by multiple components within an application. Without an iterator, you may unintentionally modify a container without another user’s knowledge. STL iterators mostly, but not always, live up to this ideal goal.</p>
<p>Let’s take a look at how we can utilize an STL <strong class="source-inline">iterator</strong>. This example can be found as a complete <a id="_idIndexMarker921"/>program<a id="_idIndexMarker922"/> in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;list&gt;
<strong class="bold">#include &lt;iterator&gt;</strong>
<strong class="bold">using std::list;</strong>
<strong class="bold">using std::iterator;</strong>
<strong class="bold">bool operator&lt;(const Student &amp;s1, const Student &amp;s2)</strong>
{   // overloaded operator&lt; -- required to use list::sort()
    return s1.GetGpa() &lt; s2.GetGpa();
}
int main()
{
    list&lt;Student&gt; studentBody;  
    Student s1("Jul", "Li", 'M', "Ms.", 3.8, "C++",
               "117PSU");
    // Add Students to the studentBody list.
    studentBody.push_back(s1);
    // The next Student instances are anonymous objects
    studentBody.push_back(Student("Hana", "Sato", 'U',
                          "Dr.", 3.8, "C++", "178PSU"));
    studentBody.push_back(Student("Sara", "Kato", 'B',
                          "Dr.", 3.9, "C++", "272PSU"));
    studentBody.push_back(<a id="_idTextAnchor613"/>Student("Giselle", "LeBrun", 'R',
                          "Ms.", 3.4, "C++", "299TU"));
    <strong class="bold">studentBody.sort();</strong>  // sort() will rely on operator&lt; 
    // Though we'll generally prefer range-for loops, let's
    // understand and demo us<a id="_idTextAnchor614"/>ing an iterator for looping.
    // Create a list iterator; set to first item in list.
    // We'll next simplify it<a id="_idTextAnchor615"/>erator notation with 'auto'.
    <strong class="bold">list &lt;Student&gt;::iterator listIter =studentBody.begin();</strong>
    while (<strong class="bold">listIter != studentBody.end()</strong>)
    {
        <strong class="bold">Student &amp;temp = *listIter;</strong>
        temp.EarnPhD();
        <strong class="bold">++listIter;</strong>    // prefer pre-inc (less expensive)
    } 
    // Simplify iterator declaration using 'auto'
    <strong class="bold">auto autoIter = studentBody.begin();</strong>
    while (<strong class="bold">autoIter != studentBody.end()</strong>)
    {
        <strong class="bold">(*autoIter).Print();</strong>  
        <strong class="bold">++autoIter;</strong>
    }
    return 0;
}</pre>
<p>Let’s take a look at our previously defined code segment. Here, we include both the <strong class="source-inline">&lt;list&gt;</strong> and <strong class="source-inline">&lt;iterator&gt;</strong> headers from the STL. We also add <strong class="source-inline">using std::list;</strong> and <strong class="source-inline">using std::iterator;</strong> to include <strong class="source-inline">list</strong> and <strong class="source-inline">iterator</strong> from the standard namespace. As in our previous <strong class="source-inline">main()</strong> function, we instantiate a <strong class="source-inline">list</strong> that can contain <strong class="source-inline">Student</strong> instances using <strong class="source-inline">list&lt;Student&gt; studentbody;</strong>. We then instantiate<a id="_idIndexMarker923"/> several <strong class="source-inline">Student</strong> instances and add them to the list <a id="_idIndexMarker924"/>using <strong class="source-inline">push_back()</strong>. Again, notice that several <strong class="source-inline">Student</strong> instances are <em class="italic">anonymous objects</em>, having no local identifier in <strong class="source-inline">main()</strong>. These instances will be popped off the stack when <strong class="source-inline">push_back()</strong> completes. This is no problem, as <strong class="source-inline">push_back()</strong> will create local copies for the list.</p>
<p>Now, we can sort the list using <strong class="source-inline">studentBody.sort();</strong>. It is important to note that this <strong class="source-inline">list</strong> method required us to overload <strong class="source-inline">operator&lt;</strong> to provide a means of comparison between two <strong class="source-inline">Student</strong> instances. Luckily, we have! We have chosen to implement <strong class="source-inline">operator&lt;</strong> by comparing <strong class="source-inline">gpa</strong>, but it could also have used <strong class="source-inline">studentId</strong> for comparison.</p>
<p>Now that we have a <strong class="source-inline">list</strong>, we can create an <strong class="source-inline">iterator</strong> and establish it to refer to the first item of the <strong class="source-inline">list</strong>. We do so by declaring <strong class="source-inline">list &lt;Student&gt;::iterator listIter = studentBody.begin();</strong>. With the iterator established, we can use it to safely loop through the <strong class="source-inline">list</strong> from start (as it is initialized) to <strong class="source-inline">end()</strong>. We assign a local reference variable <strong class="source-inline">temp</strong> to the loop iteration’s current first element in the list with <strong class="source-inline">Student &amp;temp = *listIter;</strong>. We then call a method on this instance with <strong class="source-inline">temp.EarnPhD();</strong>, and then we increment our iterator b<a id="_idTextAnchor616"/>y one element using <strong class="source-inline">++listIter;</strong>.</p>
<p>In the subsequent loop, we simplify our declaration of the iterator using <strong class="source-inline">auto</strong>. The <strong class="source-inline">auto</strong> keyword allows the type of the iterator to be determined by its initial usage. Within this loop, we also eliminate the usage of <strong class="source-inline">temp</strong> – we simply deference the iterator first within parentheses and then invoke <strong class="source-inline">Print()</strong> by using <strong class="source-inline">(*autoIter).Print()</strong>. Using <strong class="source-inline">++autoIter</strong> simply advances to the next item in our list for processing.</p>
<p>Let’s take a look at the sorted output for this program (sorted by <strong class="source-inline">gpa</strong>):</p>
<p class="source-code">Dr. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</p>
<p class="source-code">Dr. Jul M. Li with id: 117PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p>Now that <a id="_idIndexMarker925"/>we<a id="_idIndexMarker926"/> have seen an <strong class="source-inline">iterator</strong> class in action, let’s investigate a variety of additional STL container classes, starting with <strong class="source-inline">vector</strong>. </p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor617"/>Using STL vector</h2>
<p>The STL <strong class="source-inline">vector</strong> class<a id="_idIndexMarker927"/> implements <a id="_idIndexMarker928"/>the Abstract Data Type of a dynamic array. Recall that we have made our own dynamic array by creating an <strong class="source-inline">Array</strong> class in <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>. The STL version, however, will be far more extensive. </p>
<p>The <strong class="source-inline">vector</strong> (dynamic or resizable array) will expand as necessary to accommodate additional elements beyond its initial size. The <strong class="source-inline">vector</strong> class allows direct (that is, <em class="italic">random access</em>) to elements by overloading <strong class="source-inline">operator[]</strong>. A <strong class="source-inline">vector</strong> allows elements to be accessed in constant time through direct access. It is not necessary to walk past all prior elements to access an element at a specific index.</p>
<p>However, adding elements in the middle of a <strong class="source-inline">vector</strong> is time-consuming. That is, adding to any location other than the end of the <strong class="source-inline">vector</strong> requires all elements past the insertion point to be internally shuffled; it may also require an internal resizing of the <strong class="source-inline">vector</strong>.</p>
<p>Clearly, <strong class="source-inline">list</strong> and <strong class="source-inline">vector</strong>, by comparison, have different strengths and weaknesses. Each is geared to different requirements of a collection of data. We can choose <a id="_idTextAnchor618"/><a id="_idTextAnchor619"/>the one that best fits our needs. </p>
<p>Let’s take a look at an assortment of common <strong class="source-inline">vector</strong> member functions. Th<a id="_idTextAnchor620"/>is is far from a complete list:</p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="" height="377" src="image/Figure_14.1_B19087.jpg" width="1649"/>
</div>
</div>
<p>The STL <strong class="source-inline">vector</strong> class additionally includes overloaded <strong class="source-inline">operator=</strong> (assignment replaces destination vector with source vector), <strong class="source-inline">operator==</strong> (comparison of vectors, element by element), and <strong class="source-inline">operator[]</strong> (returns a reference to the requested lo<a id="_idTextAnchor621"/>cation, that is, writable memory).</p>
<p>Let’s take <a id="_idIndexMarker929"/>a look <a id="_idIndexMarker930"/>at how we can utilize the STL <strong class="source-inline">vector</strong> class with some of its basic operations. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;vector&gt;</strong>
<strong class="bold">using std::vector;</strong>
int ma<a id="_idTextAnchor622"/>in()
{   // instantiate two vectors
    <strong class="bold">vector&lt;Student&gt; studentBody1, studentBody2;</strong> 
    // add 3 Students, which are anonymous objects 
    <strong class="bold">studentBody1.push_back(Student("Hana", "Sato", 'U',</strong>
<strong class="bold">                           </strong><strong class="bold">"Dr.", 3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody1.push_back(Student("Sara", "Kato", 'B',</strong>
<strong class="bold">                           "Dr.", 3.9, "C++", "272PSU"));</strong>
    <strong class="bold">studentBody1.push_back(Student("Giselle", "LeBrun",</strong>
<strong class="bold">                         'R', "Ms.", 3.4, "C++", "299TU"));</strong>
    // Compare this loop to next loop using an iterator and
    // also to the preferred range-for loop further beyond
    for (int i = 0; i &lt; studentBody1.size(); i++)   
        studentBody1[i].Print();   // print first vector
    <strong class="bold">studentBody2 = studentBody1;</strong>   // assign one to another
    if (<strong class="bold">studentBody1 == studentBody2</strong>)
        cout &lt;&lt; "Vectors are the same" &lt;&lt; endl;
    // Notice: auto keyword simplifies iterator declaration
    for (<strong class="bold">auto</strong> iter = studentBody2.begin();
              iter != studentBody2.end(); iter++)
        (*iter).EarnPhD();
   // Preferred range-for loop (and auto to simplify type)
    for (const auto &amp;student : studentBody2)
        student.Print();
    if (<strong class="bold">!studentBody1.empty()</strong>)   // clear first vector 
        <strong class="bold">studentBody1.clear();</strong>
    return 0;
}</pre>
<p>In the previously listed code segment, we <strong class="source-inline">#include &lt;vector&gt;</strong> to include the appropriate STL header file. We also add <strong class="source-inline">using std::vector;</strong> to include <strong class="source-inline">vector</strong> from the standard namespace. Now, in <strong class="source-inline">main()</strong>, we can instantiate two vectors using <strong class="source-inline">vector&lt;Student&gt; studentBody1, studentBody2;</strong>. We can then use the <strong class="source-inline">vector::push_back()</strong> method to add several <strong class="source-inline">Student</strong> instances in succession to our first <strong class="source-inline">vector</strong>. Again, notice that the <strong class="source-inline">Student</strong> instances are <em class="italic">anonymous objects</em> in <strong class="source-inline">main()</strong>. That is, there is no local identifier that references them – they are created only to be placed into our vector, which makes a local copy of each instance upon insertion. Once we have elements in our vector, we then loop through our first <strong class="source-inline">vector</strong>, printing each <strong class="source-inline">Student</strong> using <strong class="source-inline">studentBody1[i].Print();</strong>.</p>
<p>Next, we demonstrate the overloaded assignment operator for <strong class="source-inline">vector</strong> by assigning one vector to another using <strong class="source-inline">studentBody1 = studentBody2;</strong>. Here, we make a deep copy from right to left in the assignment. We can then test whether the two vectors are<a id="_idIndexMarker931"/> equal using the overloaded comparison operator within a conditional<a id="_idIndexMarker932"/> statement, that is, <strong class="source-inline">if (studentBody1 == studentBody2)</strong>. </p>
<p>We then apply <strong class="source-inline">EarnPhD()</strong> to the contents of the second vector in a <strong class="source-inline">for</strong> loop using an iterator specified with <strong class="source-inline">auto iter = studentBody2.begin();</strong>. The <strong class="source-inline">auto</strong> keyword allows the type of the iterator to be determined by its initial usage. We then print out the contents of our second vector using a preferred range-for loop (as well as using <strong class="source-inline">auto</strong> to simplify the variable type in the range-for loop). Finally, we look through our first <strong class="source-inline">vector</strong>, testing whether it is <strong class="source-inline">empty()</strong>, and then clear elements one by one using <strong class="source-inline">studentBody1.clear();</strong>. We have now seen a sampling of the <strong class="source-inline">vector</strong> methods and their capabilities. </p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</p>
<p class="source-code">Vectors are the same</p>
<p class="source-code">Everyone to earn a PhD</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">Dr. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</p>
<p>Next, let’s<a id="_idIndexMarker933"/> investigate<a id="_idIndexMarker934"/> the STL <strong class="source-inline">deque</strong> class to further our knowledge of STL containers. </p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor623"/>Using STL deque</h2>
<p>The STL <strong class="source-inline">deque</strong> class (pronounced <em class="italic">deck</em>) implements<a id="_idIndexMarker935"/> the Abstract Data Type <a id="_idIndexMarker936"/>of a double-ended queue. This ADT extends the notion that a queue is first in, first out. Instead, the <strong class="source-inline">deque</strong> class allows greater flexibility. Adding elements at either end of a <strong class="source-inline">deque</strong> is quick. Adding elements in the middle of a <strong class="source-inline">deque</strong> is time-consuming. A <strong class="source-inline">deque</strong> is a sequential container, though more flexible than a <strong class="source-inline">list</strong>.</p>
<p>You might imagine that a <strong class="source-inline">deque</strong> is a specialization of a <strong class="source-inline">queue</strong>; it is not. Instead, the flexible <strong class="source-inline">deque</strong> class will serve as a basis to implement other container classes, which we will see shortly. In these cases, private inheritance will allow us to conceal <strong class="source-inline">deque</strong> as an underlying implementation (with vast functionality) for more restrictive, specialized classes.</p>
<p>Let’s take a look at an assortment of common <strong class="source-inline">deque</strong> member functi<a id="_idTextAnchor624"/>ons. This is far from a complete list:</p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="" height="512" src="image/Figure_14.2_B19087.jpg" width="1650"/>
</div>
</div>
<p>The STL <strong class="source-inline">deque</strong> class additionally includes overloaded <strong class="source-inline">operator=</strong> (assignment of the source to destination deque) and <strong class="source-inline">operator[]</strong> (returns a reference to requested location – writable memory).</p>
<p>Let’s take a look at how we can utilize the STL <strong class="source-inline">deque</strong> class. This example can be found, as a full <a id="_idIndexMarker937"/>working <a id="_idIndexMarker938"/>program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;deque&gt;</strong> 
<strong class="bold">using std::deque;</strong>
int main()
{
    <strong class="bold">deque&lt;Student&gt; studentBody;</strong>   // create a deque
    Student s1("Tim", "Lim", 'O', "Mr.", 3.2, "C++",
               "111UD");
    // the remainder of the Students are anonymous objects
    <strong class="bold">studentBody.push_back(Student("Hana", "Sato", 'U',</strong>
<strong class="bold">                          "Dr.",3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push_back(Student("Sara", "Kato", 'B',</strong>
<strong class="bold">                          "Dr.", 3.9, "C++", "</strong><strong class="bold">272PSU"));</strong>
    <strong class="bold">studentBody.push_front(Student("Giselle", "LeBrun",</strong>
<strong class="bold">                          'R',"Ms.", 3.4, "C++"</strong><strong class="bold">, "299TU<a id="_idTextAnchor625"/>"));</strong>
    // insert one past the beginning 
    <strong class="bold">studentBody.insert(std::next(studentBody.begin()), </strong>
    <strong class="bold">Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++",</strong>
            <strong class="bold">"299CU"));</strong>
    <strong class="bold">studentBody[0] = s1;</strong>  // replace 0<span class="superscript">th</span> element; 
                          // no bounds checking!
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
        <strong class="bold">studentBody.front()</strong>.Print();
        <strong class="bold">studentBody.pop_front();</strong>
    }
    return 0;
}</pre>
<p>In the <a id="_idIndexMarker939"/>previously<a id="_idIndexMarker940"/> listed code segment, we <strong class="source-inline">#include &lt;deque&gt;</strong> to include the appropriate STL header file. We also add <strong class="source-inline">using std::deque;</strong> to include <strong class="source-inline">deque</strong> from the standard namespace. Now, in <strong class="source-inline">main()</strong>, we can instantiate a <strong class="source-inline">deque</strong> to contain <strong class="source-inline">Student</strong> instances using <strong class="source-inline">deque&lt;Student&gt; studentBody;</strong>. We then call either <strong class="source-inline">deque::push_back()</strong> or <strong class="source-inline">deque::push_front()</strong> to add several <strong class="source-inline">Student</strong> instances (some anonymous objects) to our <strong class="source-inline">deque</strong>. We are getting the hang of this! Now, we insert a <strong class="source-inline">Student</strong> one position past the front of our deque using <strong class="source-inline">studentBody.insert(std::next(studentBody.begin()), Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++", "299CU"));</strong>. </p>
<p>Next, we take advantage of overloaded <strong class="source-inline">operator[]</strong> to insert a <strong class="source-inline">Student</strong> into our deque using <strong class="source-inline">studentBody[0] = s1;</strong>. Please be warned that <strong class="source-inline">operator[]</strong> does not do any bounds checking on our deque! In this statement, we insert <strong class="source-inline">Student</strong> <strong class="source-inline">s1</strong> into the 0<span class="superscript">th</span><span class="superscript"> </span>position in the <strong class="source-inline">deque</strong>, instead of the <strong class="source-inline">Student</strong> that once occupied that position. A safer bet is to use the <strong class="source-inline">deque::at()</strong> method, which will incorporate bounds checking. Regarding the aforementioned assignment, we also want to ensure that <strong class="source-inline">operator=</strong> has been overloaded for both <strong class="source-inline">Person</strong> and <strong class="source-inline">Student</strong>, as each class has dynamically allocated data members.</p>
<p>Now, we loop through until our <strong class="source-inline">deque</strong> is <strong class="source-inline">empty()</strong>, extracting and printing the front element of the deque using <strong class="source-inline">studentBody.front().Print();</strong>. With each iteration, we also pop the front item from our <strong class="source-inline">deque</strong> using <strong class="source-inline">studentBody.pop_front();</strong>. </p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Mr. Tim O. Lim with id: 111UD GPA:  3.2 Course: C++</p>
<p class="source-code">Ms. Anne B. Brennan with id: 299CU GPA:  3.9 Course: C++</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p>Now that we<a id="_idIndexMarker941"/> have <a id="_idIndexMarker942"/>a feel for a <strong class="source-inline">deque</strong>, let’s next investigate the STL <strong class="source-inline">stack</strong> class.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor626"/>Using STL stack</h2>
<p>The STL <strong class="source-inline">stack</strong> class<a id="_idIndexMarker943"/> implements the Abstract Data Type of a stack. The <a id="_idIndexMarker944"/>stack ADT supports<a id="_idIndexMarker945"/> the <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) order for the insertion and removal of members. True to form for an ADT, the STL <strong class="source-inline">stack</strong> includes a public interface that does not advertise its underlying implementation. After all, a stack might change its implementation; the ADTs usage should not depend in any manner on its underlying implementation. The STL <strong class="source-inline">stack</strong> is considered an adaptive interface of a basic sequential container.</p>
<p>Recall that we have made our own <strong class="source-inline">Stack</strong> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>, using a private base class of <strong class="source-inline">LinkedList</strong>. The STL version will be more extensive; interestingly, it is implemented using <strong class="source-inline">deque</strong> as its underlying private base class. With <strong class="source-inline">deque</strong> as a private base class of the STL <strong class="source-inline">stack</strong>, the more versatile underlying capabilities of <strong class="source-inline">deque</strong> are hidden; only the applicable methods are used to implement the stack’s public interface. Also, because the means of implementation is hidden, a <strong class="source-inline">stack</strong> may be implemented using another container c<a id="_idTextAnchor627"/>lass at a later date without impacting its usage.</p>
<p>Let’s take a look at an assortment of common <strong class="source-inline">stack</strong> member functions. This is far from a complete list. It is important to note that the public interface for <strong class="source-inline">stack</strong> is far smaller than that of its private base class, <strong class="source-inline">deque</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="" height="358" src="image/Figure_14.3_B19087.jpg" width="1500"/>
</div>
</div>
<p>The STL <strong class="source-inline">stack</strong> class additionally includes overloaded <strong class="source-inline">operator=</strong> (assignment of source to destination stack), <strong class="source-inline">operator==</strong> and <strong class="source-inline">operator!=</strong> (equality/inequality of two stacks), and <strong class="source-inline">operator&lt;</strong> , <strong class="source-inline">operator&gt;</strong>, <strong class="source-inline">operator&lt;=</strong>, and <strong class="source-inline">operator&gt;=</strong> (comparison of stacks).</p>
<p>Let’s take a<a id="_idIndexMarker946"/> look <a id="_idIndexMarker947"/>at how we can utilize the STL <strong class="source-inline">stack</strong> class. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;stack&gt;</strong>   // template class preamble
<strong class="bold">using std::stack;</strong>
int main()
{
    <strong class="bold">stack&lt;Student&gt; studentBody;</strong>   // create a stack
    // add Students to the stack (anonymous objects)
    <strong class="bold">studentBody.push(Student("Hana", "Sato", 'U', "Dr.",</strong>
<strong class="bold">                             3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Sara", </strong><strong class="bold">"Kato", 'B', "Dr.",</strong>
<strong class="bold">                             3.9, "C++", "272PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Giselle</strong><strong class="bold">", "LeBrun", 'R',</strong>
<strong class="bold">                             "Ms.", 3.4, "C++", "299TU"));</strong>
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
        <strong class="bold">studentBody.top()</strong>.Print()<a id="_idTextAnchor628"/>;
        <strong class="bold">studentBody.pop();</strong>
    }
    return 0;
}</pre>
<p>In the aforementioned code segment, we <strong class="source-inline">#include &lt;<a id="_idTextAnchor629"/>stack&gt;</strong> to include the appropriate STL header file. We also add <strong class="source-inline">using std::stack;</strong> to include <strong class="source-inline">stack</strong> from the standard<a id="_idIndexMarker948"/> namespace. Now, in <strong class="source-inline">main()</strong>, we can instantiate a <strong class="source-inline">stack</strong> to contain <strong class="source-inline">Student</strong> instances <a id="_idIndexMarker949"/>using <strong class="source-inline">stack&lt;Student&gt; studentBody;</strong>. We then call <strong class="source-inline">stack::push()</strong> to add several <strong class="source-inline">Student</strong> instances to our <strong class="source-inline">stack</strong>. Notice that we are using the traditional <strong class="source-inline">push()</strong> method, which contributes to the ADT of a stack.</p>
<p>We then loop through our <strong class="source-inline">stack</strong> while it is not <strong class="source-inline">empty()</strong>. Our goal is to access and print the top element using <strong class="source-inline">studentBody.top().Print();</strong>. We then neatly pop our top element off the stack using <strong class="source-inline">studentBody.pop();</strong>.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p>Next, let’s <a id="_idIndexMarker950"/>investigate <a id="_idIndexMarker951"/>the STL <strong class="source-inline">queue</strong> class to further increase our STL container repertoire. </p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor630"/>Using STL queue</h2>
<p>The STL <strong class="source-inline">queue</strong> class<a id="_idIndexMarker952"/> implements the ADT of a queue. As the <a id="_idIndexMarker953"/>stereotypical queue class, STL’s <strong class="source-inline">queue</strong> class supports the <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) order<a id="_idIndexMarker954"/> of insertion and remova<a id="_idTextAnchor631"/>l of members. </p>
<p>Recall that we made our own <strong class="source-inline">Queue</strong> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>; we derived our <strong class="source-inline">Queue</strong> from our <strong class="source-inline">LinkedList</strong> class using private inheritance. The STL version will be more extensive; the STL <strong class="source-inline">queue</strong> class is implemented using <strong class="source-inline">deque</strong> as its underlying implementation (also using private inheritance). Remember, because the means of implementation are hidden with private inheritance, a <strong class="source-inline">queue</strong> may be implemented using another data type at a later date without impacting its public interface. The STL <strong class="source-inline">queue</strong> class is another example of an adaptive interface for a basic sequential container.</p>
<p>Let’s take a look at an assortment of common <strong class="source-inline">queue</strong> member functions. This is far from a complete list. It is important to note that the public interface of <strong class="source-inline">queue</strong> is far smaller than that of its private base class, <strong class="source-inline">deque</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="" height="411" src="image/Figure_14.4_B19087.jpg" width="1650"/>
</div>
</div>
<p>The STL <strong class="source-inline">queue</strong> class additionally includes overloaded <strong class="source-inline">operator=</strong> (assignment of source to destination queue), <strong class="source-inline">operator==</strong> and <strong class="source-inline">operator!=</strong> (equality/inequality of two queues), and <strong class="source-inline">operator&lt;</strong> , <strong class="source-inline">operator&gt;</strong>, <strong class="source-inline">operator&lt;=</strong>, and <strong class="source-inline">operator&gt;=</strong> (comparison of queues).</p>
<p>Let’s take a look at <a id="_idIndexMarker955"/>how we can utilize the STL <strong class="source-inline">queue</strong> class. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;queue&gt;</strong>  
<strong class="bold">using std::queue;</strong>
int main()
{
    <strong class="bold">queue&lt;Student&gt; studentBody;</strong>  // create a queue
    // add Students to the queue (anonymous objects)
    <strong class="bold">studentBody.push(Student("Hana", "Sato", 'U', "Dr.",</strong>
<strong class="bold">                             3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Sara", "Kato", 'B' "Dr.",</strong>
<strong class="bold">                             3.9, "C++", </strong><strong class="bold">"272PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Giselle", "LeBrun", 'R',</strong>
<strong class="bold">                             "Ms.", 3.4, "C++", "299TU"));</strong>
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
        <strong class="bold">studentBody.front()</strong>.Print();
        <strong class="bold">studentBody.pop();</strong>
    }
    return 0;
}</pre>
<p>In the previous <a id="_idIndexMarker956"/>code segment, we first <strong class="source-inline">#include &lt;queue&gt;</strong> to include <a id="_idIndexMarker957"/>the appropriate STL header file. We also add <strong class="source-inline">using std::queue;</strong> to include <strong class="source-inline">queue</strong> from the standard namespace. Now, in <strong class="source-inline">main()</strong>, we can instantiate a <strong class="source-inline">queue</strong> to contain <strong class="source-inline">Student</strong> instances using <strong class="source-inline">queue&lt;Student&gt; studentBody;</strong>. We then call <strong class="source-inline">queue::push()</strong> to add several <strong class="source-inline">Student</strong> instances to our <strong class="source-inline">queue</strong>. Recall that with the queue ADT, <strong class="source-inline">push()</strong> implies that we are adding an element at the end of the queue. Some programmers prefer the term <em class="italic">enqueue</em> to describe this operation; however, the STL has selected to name this operation <strong class="source-inline">push()</strong>. With the <strong class="source-inline">queue</strong> ADT, <strong class="source-inline">pop()</strong> will remove an item from the front of the queue; a better term is <em class="italic">dequeue</em>, however, that is not what the STL has chosen. We can adapt.</p>
<p>We then loop through our <strong class="source-inline">queue</strong> while it is not <strong class="source-inline">empty()</strong>. Our goal is to access and print the front element using <strong class="source-inline">studentBody.front().Print();</strong>. We then neatly pop our front element off the <strong class="source-inline">queue</strong> using <strong class="source-inline">studentBody.pop();</strong>. Our work is complete.</p>
<p>Let’s take a<a id="_idIndexMarker958"/> look <a id="_idIndexMarker959"/>at the output for this program:</p>
<p class="source-code">Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</p>
<p>Now that we have tried a <strong class="source-inline">queue</strong>, let’s invest<a id="_idTextAnchor632"/>igate the STL <strong class="source-inline">priority_queue</strong> class. </p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor633"/>Using STL priority queue</h2>
<p>The STL <strong class="source-inline">priority_queue</strong> class <a id="_idIndexMarker960"/>implements the <a id="_idIndexMarker961"/>Abstract Data Type of a priority queue. The priority queue ADT supports a modified FIFO order of insertion and removal of members; the elements are <em class="italic">weighted</em>. The front element is of the largest value (determined by overloaded <strong class="source-inline">operator&lt;</strong>) and the rest of the elements follow in sequence from the next greatest to the least. The STL <strong class="source-inline">priority_queue</strong> class is considered an adaptive interface for a sequential container.</p>
<p>Recall that we implemented our own <strong class="source-inline">PriorityQueue</strong> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>. We used public inheritance to allow our <strong class="source-inline">PriorityQueue</strong> to specialize our <strong class="source-inline">Queue</strong> class, adding additional methods to support the priority (weighted) enqueuing scheme. The underlying implementation of <strong class="source-inline">Queue</strong> (with private base class <strong class="source-inline">LinkedList</strong>) was hidden. By using public inheritance, we allowed our <strong class="source-inline">PriorityQueue</strong> to be able to be generalized as a <strong class="source-inline">Queue</strong> through upcasting (which we understood once we learned about polymorphism and virtual functions in <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em>). We made an acceptable design choice: <em class="italic">PriorityQueue Is-A</em> (specialization of) <em class="italic">Queue</em> and at times may be treated in its more general form. We also recall that neither a <strong class="source-inline">Queue</strong> nor a <strong class="source-inline">PriorityQueue</strong> could be upcast to their underlying implementation of a <strong class="source-inline">LinkedList</strong>, as <strong class="source-inline">Queue</strong> was derived privately from <strong class="source-inline">LinkedList</strong>; we cannot upcast past a non-public inheritance boundary.</p>
<p>Contrastingly, the STL version of <strong class="source-inline">priority_queue</strong> is implemented using the STL <strong class="source-inline">vector</strong> as its underlying implementation. Recall that because the means of implementation is hidden, a <strong class="source-inline">priority_queue</strong> may be implemented using another data type at a later date without impacting its public interface. </p>
<p>An STL <strong class="source-inline">priority_queue</strong> allows an inspection, but not a modification, of the top element. The STL <strong class="source-inline">priority_queue</strong> does not allow insertion through its elements. That is, elements may only be added resulting in an order from greatest to least. Accordingly, the top element may be inspected, and the top element may be removed.</p>
<p>Let’s take a look at an assortment of common <strong class="source-inline">priority_queue</strong> member functions. This is not a complete list. It is important to note that the public interface of <strong class="source-inline">priority_queue</strong> is far<a id="_idIndexMarker962"/> smaller than that of its private base class, <strong class="source-inline">vector</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="" height="326" src="image/Figure_14.5_B19087.jpg" width="1650"/>
</div>
</div>
<p>Unlike the previously examined container classes, the STL <strong class="source-inline">priority_queue</strong> does not overload operators, including <strong class="source-inline">operator=</strong>, <strong class="source-inline">operator==</strong>, and <strong class="source-inline">operator&lt;</strong>. </p>
<p>The most interesting method of <strong class="source-inline">priority_queue</strong> is that of <strong class="source-inline">void emplace(args);</strong>. This is the member function that allows the priority enqueuing mechanism to add items to this ADT. We also notice that <strong class="source-inline">top()</strong> must be used to return the top element (versus <strong class="source-inline">front()</strong>, which a <strong class="source-inline">queue</strong> utilizes). But then again, an STL <strong class="source-inline">priority_queue</strong> is not implemented using a <strong class="source-inline">queue</strong>). To utilize <strong class="source-inline">priority_queue</strong>, we <strong class="source-inline">#include &lt;queue&gt;</strong>, just as we would for a <strong class="source-inline">queue</strong>.</p>
<p>Because the usage of <strong class="source-inline">priority_queue</strong> is so similar to <strong class="source-inline">queue</strong>, we will instead explore it further, programming-wise, in our question set at the end of this chapter. </p>
<p>Now that we have seen many examples of sequential container types in STL (including adaptive<a id="_idIndexMarker963"/> interfaces), let<a id="_idTextAnchor634"/>’s next investigate the STL <strong class="source-inline">map</strong> class, an<a id="_idIndexMarker964"/> associative container.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor635"/>Examining STL map</h2>
<p>The STL <strong class="source-inline">map</strong> class<a id="_idIndexMarker965"/> implements the Abstract Data Type of a hash table. The class <strong class="source-inline">map</strong> allows for elements in the hash table or map to be stored and retrieved quickly using a <strong class="bold">key</strong> or index. The key can be numerical or any other data type. Only one key may be associated with a single element of value. However, the STL container <strong class="source-inline">multimap</strong> can be used instead should there be more than one piece of data that needs to be associated with a single key.</p>
<p>Hash tables (maps) are fast for storage and lookup of data. The performance is a guaranteed <em class="italic">O(log(n))</em>. The STL <strong class="source-inline">map</strong> is considered an associative container, as it associates a key to a value to quickly retrieve a value.</p>
<p>Let’s take a look at an assortment of common <strong class="source-inline">map</strong> member functions. This is not a complete list:</p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="" height="565" src="image/Figure_14.6_B19087.jpg" width="1650"/>
</div>
</div>
<p>The STL class map additionally includes overloaded operator <strong class="source-inline">operator==</strong> (comparison of maps, element by element) implemented as a global function. STL map also includes overloaded <strong class="source-inline">operator[]</strong> (returns a reference to the map element associated with a key that is used as an index; this is writable memory).</p>
<p>Let’s take a look at how we can utilize the STL <strong class="source-inline">map</strong> class. This example <a id="_idTextAnchor636"/>can be found, as a full <a id="_idIndexMarker966"/>working <a id="_idIndexMarker967"/>program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Obj<span id="_idTextAnchor637"/>ect-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;map&gt;</strong>
<strong class="bold">using std::map;</strong>
<strong class="bold">using std::pair;</strong>
bool operator&lt;(const Student &amp;s1, const Student &amp;s2)
{   // We need to overload operator&lt; to compare Students
    return s1.GetGpa() &lt; s2.GetGpa();
}
int main()
{
    Student s1("Hana", "Lo", 'U', "Dr.", 3.8, "C++",
               "178UD");
    Student s2("Ali", "Li", 'B', "Dr.", 3.9, "C++",
               "272UD");
    Student s3("Rui", "Qi", 'R', "Ms.", 3.4, "C++",
               "299TU");
    Student s4("Jiang", "Wu", 'C', "Ms.", 3.8, "C++",
      <a id="_idTextAnchor638"/>         "887TU");
    // create three pairings of ids to Students
    <strong class="bold">pair&lt;string, Student&gt; studentPair1</strong>
                                <strong class="bold">(s1.GetStudentId(), s1);</strong>
    <strong class="bold">pair&lt;string, Student&gt; studentPair2</strong>
                                <strong class="bold">(s2.GetStudentId(), s2);</strong>
    <strong class="bold">pair&lt;string, Student&gt; studentPair3</strong>
                                <strong class="bold">(s3.GetStudentId(), s3);</strong>
    // Create map of Students w string keys
    <strong class="bold">map&lt;string, Student&gt; studentBody;</strong>
    <strong class="bold">studentBody.insert(studentPair1);</strong>  // insert 3 pairs
    <strong class="bold">studentBody.insert(studentPair2);</strong>
    <strong class="bold">studentBody.insert(studentPair3);</strong>
    // insert using virtual indices per map
    <strong class="bold">studentBody[s4.GetStu<a id="_idTextAnchor639"/>dentId()] = s4;</strong> 
    // Iterate through set with map iterator – let's 
    // compare to range-for and auto usage just below
    <strong class="bold">map&lt;string, Student&gt;::iterator mapIter;</strong>
    <strong class="bold">mapIter = studentBody.begin();</strong>
    while (<strong class="bold">mapIter != studentBody.end()</strong>)
    {   
        // set temp to current item in map iterator
        <strong class="bold">pair&lt;string, Student&gt; temp = *mapIter;</strong>
        Student &amp;tempS = <strong class="bold">temp.second;</strong>  // get 2nd element
        // access using mapIter
        cout &lt;&lt; <strong class="bold">temp.first</strong> &lt;&lt; " ";
        cout &lt;&lt; <strong class="bold">temp.second</strong>.GetFirstName();  
        // or access using temporary Student, tempS  
        cout &lt;&lt; " " &lt;&lt; tempS.GetLastName() &lt;&lt; endl;
        <strong class="bold">++mapIter;</strong>
    }
    // Now, le<a id="_idTextAnchor640"/>t's iterate through our map using a range-for
    // loop and using 'auto' to simplify the declaration
    // (this decomposes the pair to 'id' and 'student')
    for (<strong class="bold">auto &amp;[id, student]</strong> : studentBody)
        cout &lt;&lt; <strong class="bold">id</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">student</strong>.GetFirstName() &lt;&lt; " " 
             &lt;&lt; <strong class="bold">student</strong>.GetLastName() &lt;&lt; endl;
    return 0;
}</pre>
<p>Let’s examine the<a id="_idIndexMarker968"/> preceding code segments. Again, we<a id="_idTextAnchor641"/> include<a id="_idIndexMarker969"/> the applicable header file with <strong class="source-inline">#include &lt;map&gt;</strong>. We also add <strong class="source-inline">using std::map;</strong> and <strong class="source-inline">using std::pair;</strong> to include <strong class="source-inline">map</strong> and <strong class="source-inline">pair</strong> from the standard namespace. Next, we instantiate four <strong class="source-inline">Student</strong> instances. Next, we create three <strong class="source-inline">pair</strong> instances to associate a grouping between each Student and its key (that is, with their respective <strong class="source-inline">studentId</strong>) using the declaration <strong class="source-inline">pair&lt;string, Student&gt; studentPair1 (s1.GetStudentId(), s1);</strong>. This may seem confusing to read, but let’s break this declaration down into its components. Here, the instance’s data type is <strong class="source-inline">pair&lt;string, Student&gt;</strong>, the variable name is <strong class="source-inline">studentPair1</strong>, and <strong class="source-inline">(s1.GetStudentId(), s1)</strong> are the arguments passed to the specific <strong class="source-inline">pair</strong> instance’s constructor.</p>
<p>We will be making a hash table (<strong class="source-inline">map</strong>) of <strong class="source-inline">Student</strong> instances to be indexed by a key (which is their <strong class="source-inline">studentId</strong>). Next, we declare a <strong class="source-inline">map</strong> to hold the collection of <strong class="source-inline">Student</strong> instances with <strong class="source-inline">map&lt;string, Student&gt; studentBody;</strong>. Here, we indicate that the association between the key and element will be between a <strong class="source-inline">string</strong> and a <strong class="source-inline">Student</strong>. We then declare a map iterator with <strong class="source-inline">map&lt;string, Student&gt;::iterator mapIter;</strong> using the same data types. </p>
<p>Now, we simply insert the three <strong class="source-inline">pair</strong> instances into the <strong class="source-inline">map</strong>. An example of this insertion is <strong class="source-inline">studentBody.insert(studentPair1);</strong>. We then insert a fourth <strong class="source-inline">Student</strong>, <strong class="source-inline">s4</strong>, into the <strong class="source-inline">map</strong> using the map’s overloaded <strong class="source-inline">operator[]</strong> with the following statement: <strong class="source-inline">studentBody[s4.GetStudentId()] = s4;</strong>. Notice that the <strong class="source-inline">studentId</strong> is used as the index value in <strong class="source-inline">operator[]</strong>; this value will become the key value for the <strong class="source-inline">Student</strong> in the hash table.</p>
<p>Next, we declare and establish the map iterator to the beginning of the <strong class="source-inline">map</strong> and then process the <strong class="source-inline">map</strong> while it is not at the <strong class="source-inline">end()</strong>. Within the loop, we set a variable, <strong class="source-inline">temp</strong>, to the <strong class="source-inline">pair</strong> at the front of the map, indicated by the map iterator. We also set <strong class="source-inline">tempS</strong> as a temporary reference to a <strong class="source-inline">Student</strong> in the <strong class="source-inline">map</strong>, which is indicated by <strong class="source-inline">temp.second</strong> (the second value in the current <strong class="source-inline">pair</strong> managed by the map iterator). We now can print out each <strong class="source-inline">Student</strong> instance’s <strong class="source-inline">studentId</strong> (the key, which is a <strong class="source-inline">string</strong>) using <strong class="source-inline">temp.first</strong> (the first item in the current <strong class="source-inline">pair</strong>). In the same statement, we can then print out each <strong class="source-inline">Student</strong> instance’s <strong class="source-inline">firstName</strong> using <strong class="source-inline">temp.second.GetFirstName()</strong> (since the <strong class="source-inline">Student</strong> corresponding to the key is the second item in the current <strong class="source-inline">pair</strong>). Similarly, we could also use <strong class="source-inline">tempS.GetLastName()</strong> to print a student’s <strong class="source-inline">lastName</strong>, as <strong class="source-inline">tempS</strong> was previously initialized to the <a id="_idIndexMarker970"/>second element in the current <strong class="source-inline">pair</strong> at the beginning<a id="_idIndexMarker971"/> of each loop iteration.</p>
<p>Finally, as an alternative to the more tedious approach demonstrated previously used to iterate through the <strong class="source-inline">map</strong> (taking apart the <strong class="source-inline">pair</strong> manually), let’s examine the final loop in our program. Here, we utilize a range-for loop to process the <strong class="source-inline">map</strong>. The use of <strong class="source-inline">auto</strong> with <strong class="source-inline">&amp;[id, student]</strong> will specify the type of data that we will iterate. The brackets (<strong class="source-inline">[]</strong>) will decompose the <strong class="source-inline">pair</strong>, binding the iterative elements to <strong class="source-inline">id</strong> and <strong class="source-inline">student</strong>, respectively, as identifiers<a id="_idTextAnchor642"/><a id="_idTextAnchor643"/>. Notice the ease at which we can now iterate over<a id="_idTextAnchor644"/> the <strong class="source-inline">studentBody</strong> map.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">178UD Hana Lo</p>
<p class="source-code">272UD Ali Li</p>
<p class="source-code">299TU Rui Qi</p>
<p class="source-code">887TU Jiang Wu</p>
<p class="source-code">178UD Hana Lo</p>
<p class="source-code">272UD Ali Li</p>
<p class="source-code">299TU Rui Qi</p>
<p class="source-code">887TU Jiang Wu</p>
<p>Next, let’s take a look at an alternative with an STL <strong class="source-inline">map</strong>, which will introduce us to the STL <strong class="source-inline">functor</strong> concept.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor645"/>Examining STL map using a functor</h2>
<p>The STL <strong class="source-inline">map</strong> class <a id="_idIndexMarker972"/>has great flexibility, like <a id="_idIndexMarker973"/>many<a id="_idIndexMarker974"/> STL classes. In our past <strong class="source-inline">map</strong> example, we assumed that a means for comparison was present in our <strong class="source-inline">Student</strong> class. We had, after all, overloaded <strong class="source-inline">operator&lt;</strong> for two <strong class="source-inline">Student</strong> instances. What happens, however, if we cannot revise a class that has not provided this overloaded operator and we also choose not to overload <strong class="source-inline">operator&lt;</strong> as an external function?</p>
<p>Fortunately, we may specify a third data type for the template type expansion when instantiating a <strong class="source-inline">map</strong> or map iterator. This additional data type will be a specific type of class, known as a functor. A <strong class="bold">functor</strong> is an <a id="_idIndexMarker975"/>object that can be treated as though it is a function or function pointer. We will create a class (or struct) to represent our functor type, and within that class (or struct), we must overload <strong class="source-inline">operator()</strong>. It is within overloaded <strong class="source-inline">operator()</strong> that we will provide a means of comparison for the objects in question. A functor essentially simulates encapsulating a function pointer by overloading <strong class="source-inline">operator()</strong>.</p>
<p>Let’s take a look at how we might revise our <strong class="source-inline">map</strong> example to utilize a simple functor. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;map&gt;</strong>
<strong class="bold">using std::map;</strong>
<strong class="bold">using std::pair;</strong>
<strong class="bold">struct comparison</strong>   // This struct represents a 'functor'
<strong class="bold">{</strong>                   // that is, a 'function object'
    <strong class="bold">bool operator() (const string &amp;key1, </strong>
<strong class="bold">                     const string &amp;key2) const</strong>
    <strong class="bold">{</strong>   
        int ans = key1.compare(key2);
        if (ans &gt;= 0) return true;  // return a boolean
        else return false;  
    <strong class="bold">}</strong>
    // default constructor and destructor are adequate
<strong class="bold">};</strong>
int main()
{
    Student s1("Hana", "Sato", 'U', "Dr.", 3.8, "C++", 
               "178PSU");
    Student s2("Sara", "Kato", 'B', "Dr.", 3.9, "C++",
               "272PSU");
    Student s3("Jill", "Long", 'R', "Dr.", 3.7, "C++",
               "234PSU");
    <strong class="bold">// Now, map is maintained in sorted (decreasing) order</strong>
    <strong class="bold">// per ‹comparison› functor using operator()</strong>
    map&lt;string, Student, <strong class="bold">comparison</strong>&gt; studentBody;
    map&lt;string, Student, <strong class="bold">comparison</strong>&gt;::iterator mapIter;
    // The remainder of the program is similar to prior
}   // map program. See online code for complete example.</pre>
<p>In the <a id="_idIndexMarker976"/>previously <a id="_idIndexMarker977"/>mentioned code fragment, we first introduce a user defined type of <strong class="source-inline">comparison</strong>. This can be a <strong class="source-inline">class</strong> or a <strong class="source-inline">struct</strong>. Within this structure definition, we have overloaded the function call operator (<strong class="source-inline">operator()</strong>) and provided a means of comparison between two <strong class="source-inline">string</strong> keys for <strong class="source-inline">Student</strong> instances. This comparison will allow <strong class="source-inline">Student</strong> instances to be inserted in an order determined by the comparison functor.</p>
<p>Now, when we instantiate our <strong class="source-inline">map</strong> and map iterators, we specify as the third parameter for the template type expansion our <strong class="source-inline">comparison</strong> type (the functor). And, neatly embedded within this type is the overloaded function call operator, <strong class="source-inline">operator()</strong>, which will provide our needed comparison. The remaining code will be similar to our original <strong class="source-inline">map</strong> program.</p>
<p>Certainly, functors may be used in additional, more advanced ways beyond what we have seen here with the container class <strong class="source-inline">map</strong>. Nonetheless, you now have a flavor for how a functor can apply to the STL.</p>
<p>Now that we <a id="_idIndexMarker978"/>have seen how to utilize a variety of<a id="_idIndexMarker979"/> STL <a id="_idIndexMarker980"/>container classes, let’s consider why we may want to customize an STL class, and how to do so.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor646"/>Customizing STL containers</h1>
<p>Most classes in C++ can<a id="_idIndexMarker981"/> be customized in some fashion, including classes in the STL. However, we must be aware of design decisions made within the STL that will limit how we may customize these components. Because the STL container classes purposely do not include virtual destructors or other virtual functions, we should not use specialization via public inheritance to extend these classes. Note that C++ will not stop us, but we know from <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Using Dynamic Binding through Polymorphism</em>, that we should never override non-virtual functions. STL’s choice to not include virtual destructors and other virtual functions to allow further specialization of these classes was a solid design choice made long ago when STL containers were crafted. </p>
<p>We could, however, use private or protected inheritance, or the concepts of containment or association to use an STL container class as a building block. That is, to hide the underlying implementation of a new class, where the STL provides a solid, yet hidden implementation for the new class. We would simply provide our own public interface for the new class and, under the hood, delegate the work to our underlying implementation (whether <a id="_idTextAnchor647"/>that be a private or protected base class, or a contained or associated object). </p>
<p>Extreme care and caution must be taken when extending any template class, including those in the STL using private or protected base classes. This caution will also apply to containing or associating to other template classes. Template classes are generally not compiled (or syntax checked) until an instance of the template class with a specific type is created. This means that any derived or wrapper classes that are created can only be fully tested when instances of specific types are created. </p>
<p>Appropriate overloaded operators will need to be put in place for new classes so that these operators will work automatically with customized types. Keep in mind that some operator functions, such as <strong class="source-inline">operator=</strong>, are not explicitly inherited from base to derived class and need to be written with each new class. This is appropriate since derived classes will likely have more work to accomplish than found in the generalized versions of <strong class="source-inline">operator=</strong>. Remember, if you cannot modify the class definition of a class requiring a selected overloaded operator, you must implement that operator function as an external function.</p>
<p>In addition to customizing containers, we may also choose to augment an algorithm based on an existing algorithm within the STL. In this case, we would use one o<a id="_idTextAnchor648"/><a id="_idTextAnchor649"/><a id="_idTextAnchor650"/>f the many STL functions as part of a new algorithm’s underlying implementation. </p>
<p>Customizing classes from existing libraries comes up routinely in programming. For example, consider how we extended the Standard Library <strong class="source-inline">exception</strong> class to create customized exceptions in <a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em> (though that scenario utilized public inheritance, which will not apply to customizing STL classes). Keep in mind that the STL offers a very full complement of container classes. Rarely will you find the need to augment STL classes – perhaps only with a very domain-specific class need. Nonetheless, you now know the caveats involved in customizing STL classes. Remember, care and caution must always be used when augmenting a class. We can now see the need to employ proper OO component testing for any classes we create.</p>
<p>We have now<a id="_idIndexMarker982"/> considered how to potentially customize STL container classes and algorithms within our programs. We have also seen quite a few STL container class examples in action. Let us now briefly recap these concepts before moving forward to our next chapter.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor651"/>Summary</h1>
<p>In this chapter, we have furthered our C++ knowledge beyond OOP language features to gain familiarity with the C++ Standard Template Library. As this library is used so commonly in C++, it is essential that we understand both the scope and breadth of the classes it contains. We are now prepared to utilize these useful, well-tested classes in our code. </p>
<p>We have looked at quite a few STL examples; by examining selective STL classes, we should feel empowered to understand the remainder of the STL (or any C++ library) on our own.</p>
<p>We have seen how to use common and essential STL classes such as <strong class="source-inline">list</strong>, <strong class="source-inline">iterator</strong>, <strong class="source-inline">vector</strong>,<strong class="source-inline"> deque</strong>, <strong class="source-inline">stack</strong>, <strong class="source-inline">queue</strong>, <strong class="source-inline">priority_queue</strong>, and <strong class="source-inline">map</strong>. We have also seen how to utilize a functor in conjunction with a container class. We have been reminded that we now have the tools to potentially customize any class, even those from class libraries such as STL through private or protected inheritance, or with containment or association.</p>
<p>We have additionally seen through examining selected STL classes that we have the skills to understand the remaining depth and breadth of the STL, as well as decode many additional class libraries that are available to us. As we navigate the prototypes of each member function, we notice key language concepts, such as the use of <strong class="source-inline">const</strong>, or that a method returns a reference to an object representing writable memory. Each prototype reveals the mechanics for the usage of the new class. It is very exciting to have come this far with our programming endeavors! </p>
<p>We have now adde<a id="_idTextAnchor652"/>d additional, useful features to our C++ repertoire through browsing the STL in C++. Usage of the STL (to encapsulate traditional data structures) will ensure that our code can easily be understood by other programmers who are also undoubtedly using the STL. Relying on the well-tested STL for these common containers and utilities ensures that our code remains more bug-free. </p>
<p>We are now ready to continue forward with <a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em>. We want to complement our C++ programming skills with useful OO component testing skills. Testing skills will help us understand whether we have created, extended, or augmented classes in a robust fash<a id="_idTextAnchor653"/>ion. These skills will make us better programmers. Let’s continue onward!</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor654"/>Questions</h1>
<ol>
<li>Replace your template <strong class="source-inline">Array</strong> class from your exercise from <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, with an STL <strong class="source-inline">vector</strong>. Create a <strong class="source-inline">vector</strong> of <strong class="source-inline">Student</strong> instances. Use <strong class="source-inline">vector</strong> operations to insert, retrieve, print, compare, and remove objects from the vector. Alternatively, utilize an STL <strong class="source-inline">list</strong>. Use this opportunity to utilize the STL documentation to navigate the full set of operations available for these classes.</li>
</ol>
<p>a. Consider what operators, if any, you will need to overload. Consider whether you will need an <strong class="source-inline">iterator</strong> to provide safe interleaved access to your collection.</p>
<p>b. Create a second <strong class="source-inline">vector</strong> of <strong class="source-inline">Student</strong> instances. Assign one to another. Print both vectors.</p>
<ol>
<li value="2">Modify the <strong class="source-inline">map</strong> from this chapter to index the hash table (map) of <strong class="source-inline">Student</strong> instances based on <strong class="source-inline">lastName</strong> rather than <strong class="source-inline">studentId</strong>. </li>
<li>Modify the <strong class="source-inline">queue</strong> example from this chapter to instead utilize <strong class="source-inline">priority_queue</strong>. Be sure to make use of the priority enqueueing mechanism <strong class="source-inline">priority_queue::emplace()</strong> to add elements into the <strong class="source-inline">priority_queue</strong>. You will also need to utilize <strong class="source-inline">top()</strong> instead of <strong class="source-inline">front()</strong>. Note that <strong class="source-inline">priority_queue</strong> can be found in the <strong class="source-inline">&lt;queue&gt;</strong> header file.</li>
<li>Try out an STL algorithm using <strong class="source-inline">sort()</strong>. Be sure to <strong class="source-inline">#include &lt;algorithm&gt;</strong>. Sort an array of integers. Keep in mind that many containers have sorting mechanisms built in, but native collection types, such as a language-supplied array, will not (which is why you should use a basic array of integers).</li>
</ol>
</div>
</div></body></html>