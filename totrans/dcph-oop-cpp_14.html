<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor595"/>14</h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor596"/>Understanding STL Basics</h1>
<p>This chapter will continue our pursuit of increasing your C++ programming repertoire beyond OOP concepts by delving into a core C++ library that has become thoroughly integrated into the common usage of the language. We will explore the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) in C++ by examining a subset of this library, representing common utilities that can both simplify our programming and make our code more easily understood by others who are undoubtedly familiar with the STL. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Surveying the contents and purpose of the STL in C++ </li>
<li>Understanding how to use essential STL containers – <a id="_idTextAnchor597"/><code>list</code>, <code>iterator</code>, <code>vector</code>, <code>deque</code>, <code>stack</code>, <code>queue</code>, <code>priority_queue</code>, <code>map</code>, and <code>map</code> using a functor</li>
<li>Customizing STL containers</li>
</ul>
<p>By the end of this chapter, you will be able to utilize core STL classes to enhance your programming skills. Because you already understand the essential C++ language and OOP features in which libraries are built, you will see that you now have the ability to navigate and understand nearly any C++ class library, including the STL. By gaining familiarity with the STL, you will be able to enhance your programming repertoire significantly and become a more savvy and valuable programmer.</p>
<p>Let’s increase our C++ toolkit by examining a very heavily utilized class library, the STL.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor598"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter14</code> in a file named <code>Chp14-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3PCL5IJ">https://bit.ly/3PCL5IJ</a>.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor599"/><a id="_idTextAnchor600"/><a id="_idTextAnchor601"/>Surveying the contents and purpose of the STL</h1>
<p>The <strong class="bold">Standard Template Library</strong> in C++ is <a id="_idIndexMarker894"/>a library of standard classes and utilities that extend the C++ language. The use of the STL is so pervasive that it is as though the STL is a part of the language itself; it is an essential and integral part of C++. The STL in C++ has four<a id="_idIndexMarker895"/> key<a id="_idIndexMarker896"/> components <a id="_idIndexMarker897"/>comprising <a id="_idIndexMarker898"/>the library: <strong class="bold">containers</strong>, <strong class="bold">iterators</strong>, <strong class="bold">functions</strong>, and <strong class="bold">algorithms</strong>. </p>
<p>The STL has additionally influenced the C++ Standard Library in providing a set of programming standards; the two libraries actually share common features and components, most notably containers and iterators. We’ve already utilized components from the Standard Library, namely <code>&lt;iostream&gt;</code> for IOStreams, <code>&lt;exception&gt;</code> for exception handling, and <code>&lt;new&gt;</code> for operators <code>new()</code> and <code>delete()</code>. In this chapter, we will explore many overlapping components between the STL and the Standard Library in C++. </p>
<p>The STL has a full line<a id="_idIndexMarker899"/> of <strong class="bold">container</strong> classes. These classes encapsulate traditional data structures to allow similar items to be collected together and uniformly processed. There are several categories of container classes – sequential, associative, and unord<a id="_idTextAnchor602"/>ered. Let’s summarize <a id="_idTextAnchor603"/>these categories and provide a few examples of each:</p>
<ul>
<li><code>list</code>, <code>queue</code>, or <code>stack</code>. It is interesting to note that <code>queue</code> and <code>stack</code> can be thought of as a customized or adaptive interface for a more basic container, such as a <code>list</code>. Nonetheless, a <code>queue</code> and <code>stack</code> still provide sequential access to their elements.</li>
<li><code>set</code> or <code>map</code>.</li>
<li><code>unordered_set</code> or <code>unordered_map</code>.</li>
</ul>
<p>In order for these container classes to be potentially used for any data type (and to preserve strong type checking), templates are utilized to abstract and genericize the data types of the collected items. In fact, we built our own container classes using templates in <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, including <code>LinkList</code> and <code>Array</code>, so we already have a basic understanding of templatized container classes!</p>
<p>Additionally, the STL provides a full <a id="_idIndexMarker903"/>complement of <strong class="bold">iterators</strong>, which allow us to <em class="italic">walk through</em> or traverse containers. Iterators keep track of our current place without corrupting the content or ordering of the respective collections of objects. We will see how iterators allow us to process container classes more safely within the STL.</p>
<p>The STL also contains a plentiful supply<a id="_idIndexMarker904"/> of useful <strong class="bold">algorithms</strong>. Examples include sorting, counting the number of elements in a collection that may satisfy a condition, searching for particular<a id="_idIndexMarker905"/> elements or subsequences within elements, or copying elements in a variety of manners. Additional examples of algorithms include modifying a sequence of objects (replacing, swapping, and removing values), partitioning sets into ranges, or merging sets back together. Moreover, the STL contains many other useful algorithms and utilities.</p>
<p>Lastly, the STL includes<a id="_idIndexMarker906"/> functions. Actually, it<a id="_idIndexMarker907"/> would be more correct to say that the STL includes <code>operator()</code> (the function call operator), and by doing so, allow us to achieve parameterized flexibility through a function pointer. Though this is not an elementary feature of the STL we will immediately (or often) use, we will see one small, simple example of a functor in this chapter coupled with an STL container class, in the upcoming section <em class="italic">Examining STL map using a functor</em>.</p>
<p>In this chapter, we will focus on the container class section of the STL. Though we won’t examine every STL container class in the STL, we will review a healthy assortment of these classes. We will notice that some of these container classes are similar to classes that we have built together in previous chapters of this book. Incidentally, during the incremental chapter progressions of this book, we have also built up our C++ language and OOP skills, which are necessary to decode a C++ class library such as STL. </p>
<p>Let’s move<a id="_idIndexMarker908"/> forward to take a look at selective STL classes and test our C++ knowledge as we interpret each class.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor604"/>Understanding how to use essential STL containers</h1>
<p>In this section, we <a id="_idIndexMarker909"/>will put our C++ skills to the test by decoding various STL container classes. We will see that language features we have mastered, from core C++ syntax to OOP skills, have put us in a position to easily interpret the various components of STL we will now examine. Most notably, we will put our knowledge of templates to use! Our knowledge of encapsulation and inheritance, for example, will guide us to understand how to use various methods in STL classes. However, we will notice that virtual functions and abstract classes are extremely rare in the STL. The best way to gain competence with a new class within the STL will be to embrace the documentation detailing each class. With knowledge of C++, we can easily navigate through a given class to decode how to use it successfully.</p>
<p>The container classes in the C++ STL implement<a id="_idIndexMarker910"/> various <code>list</code>, <code>iterator</code>, <code>vector</code>, <code>deque</code>, <code>stack</code>, <code>queue</code>, <code>priority_queue</code>, and <code>map</code>. </p>
<p>Let’s begin by examining how to utilize a very basic STL <a id="_idTextAnchor605"/><a id="_idTextAnchor606"/>container, <code>list<a id="_idTextAnchor607"/></code>.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor608"/>Using STL list</h2>
<p>The STL <code>list</code> class<a id="_idIndexMarker911"/> encapsulates <a id="_idIndexMarker912"/>the data structures necessary to implement a linked list. We can say that <code>list</code> implements the Abstract Data Type of a linked list. Recall that we have made our own linked list by creating <code>LinkedListElement</code> and <code>LinkedList</code> classes in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>. STL <code>list</code> allows for easy insertion, deletion, and sorting of elements. Direct access to individual elements (known as <em class="italic">random access</em>) is not supported. Rather, you must iteratively traverse past a prior item in the linked list until you reach the desired item. STL <code>list</code> is a good example of a sequential container.</p>
<p>STL <code>list</code> actually supports bidirectional sequential access to its elements (it is implemented using a doubly-linked list). The STL additionally offers <code>forward_list</code>, allowing unidirectional sequential access to its elements with a smaller footprint than <code>list</code>; <code>forward_list</code> is implemented using a singly-linked list (much like our <code>LinkedList</code> class). </p>
<p>The STL <code>list</code> class has an assortment of member functions; we’ll start by taking a look at a few popular methods in this example to get familiar with basic STL conta<a id="_idTextAnchor609"/>iner class usage. </p>
<p>Now, let’s take a look at how we can utilize t<a id="_idTextAnchor610"/>he STL <code>list</code> class. This example can be found, as a full <a id="_idIndexMarker913"/>working <a id="_idIndexMarker914"/>program with necessary class definitions, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;list&gt;</strong>
<strong class="bold">using std::list;</strong>
int main()
{   
    <strong class="bold">list&lt;Student&gt; studentBody;</strong>   // create a list
    Student s1("Jul", "Li", 'M', "Ms.", 3.8, "C++",
               "117PSU");
    // Note: simple heap instance below, later you can opt
    // for a smart pointer to ease allocation/deallocation
    Student *s2 = new Student("Deb", "King", 'H', "Dr.", 
                              3.8, "C++", "544UD");
    // Add Students to the studentBody list. 
    <strong class="bold">studentBody.push_back(s1);</strong>
    <strong class="bold">studentBody.push_back(*s2);</strong>
    // The next 3 instances are anonymous objects in main()
    <strong class="bold">studentBody.push_back(Student("Hana", "Sato", 'U', </strong>
<strong class="bold">                          "Dr.", 3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push_back(Student("Sara", "Kato", 'B',</strong>
<strong class="bold">                          "Dr.", 3.9, "C++", "272PSU"));</strong>
    <strong class="bold">studentBody.push_back(Student("Giselle", "LeBrun", 'R',</strong>
<strong class="bold">                          "Ms.", 3.4, "C++", "299TU"));</strong>
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
       <strong class="bold">studentBody.front()</strong>.Print();
       <strong class="bold">studentBody.pop_front();</strong>
    }
    delete s2;  // delete any heap instances
    return 0;
}</pre>
<p>Let’s examine the <a id="_idIndexMarker915"/>aforementioned <a id="_idIndexMarker916"/>program segment, where we create and utilize an STL <code>list</code>. First, we <code>#include &lt;list&gt;</code> to include the approp<a id="_idTextAnchor611"/>riate STL header file. We also add <code>using std::list;</code> to include <code>list</code> from the standard namespace. Now, in <code>main()</code>, we can instantiate a list using <code>list&lt;Student&gt; studentBody;</code>. Our list will contain <code>Student</code> instances. Then, we create <code>Student s1</code> on the stack and <code>Student *s2</code> on the heap using an allocation with <code>new()</code>. </p>
<p>Next, we use <code>list::push_back()</code> to add both <code>s1</code> and <code>*s2</code> to the list. Notice that we are passing objects to <code>push_back()</code>. As we add <code>Student</code> instances to the <code>studentBody</code> list, the list will make copies of the objects internally and will properly clean up these objects when they are no longer members of the list. We need to keep in mind that if any of our instances have been allocated on the heap, such as <code>*s2</code>, we must delete our copy of that instance when we are done with it at the end of <code>main()</code>. Looking ahead to the end of <code>main()</code>, we can see that we appropriately <code>delete s2;</code>.</p>
<p>Next, we add three more students to the list. These <code>Student</code> instances do not have local identifiers. These students are instantiated within the call to <code>push_back()</code>, for example, <code>studentBody.push_back(Student("Hana", "Sato", 'U', "Dr.", 3.8, "C++", "178PSU"));</code>. Here, we are instantiating an <em class="italic">anonymous (stack) object</em> that will be properly popped off the stack and destructed once the call to <code>push_back()</code> concludes. Keep in mind, <code>push_back()</code> will also create its own local copy for these instances for their life expectancy within the <code>list</code>.</p>
<p>Now, in a while loop, we repeatedly check whether the list is <code>empty()</code> and if not, we examine the <code>front()</code> item and call our <code>Student::Print()</code> method. We then use <code>pop_front()</code> to remove that item from the list.</p>
<p>Let’s take a look at <a id="_idIndexMarker917"/>the<a id="_idIndexMarker918"/> output for this program:</p>
<pre>Ms. Jul M. Li with id: 117PSU GPA:  3.8 Course: C++
Dr. Deb H. King with id: 544UD GPA:  3.8 Course: C++
Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++
Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</pre>
<p>Now that we have deciphered a simple STL <code>list</code> class, let us move forward to understand the idea of an <code>iterator</code> to complement a container such as <code>list</code>.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor612"/>Using STL iterator</h2>
<p>Quite often, we <a id="_idIndexMarker919"/>will <a id="_idIndexMarker920"/>need a non-destructive way to iterate through a collection of objects. For example, it is important to maintain the first, last, and current position in a given container, especially if the set may be accessed by more than one method, class, or thread. Using an <strong class="bold">iterator</strong>, the STL provides a common means to traverse any container class.</p>
<p>The use of iterators has definite benefits. A class can create an <code>iterator</code> that points to the first member in a collection. Iterators can then be moved to successive next members of the collection. Iterators can provide access to elements pointed to by the <code>iterator</code>. </p>
<p>Overall, the state information of a container can be maintained by an <code>iterator</code>. Iterators provide a safe means for interleaved access by abstracting the state information away from the container and instead into the iterator class. </p>
<p>We can think of an iterator as a bookmark within a book that two or more people are referencing. The first person reads the book sequentially, leaving the bookmark neatly where they expect to continue reading. While they step away, another person looks up an important item in the book and moves the bookmark to another location in the book to save their spot. When the first person returns, they find that they have lost their current location and are not where they expect to be. Each user should have had their own bookmark or iterator. The analogy is that an iterator (ideally) allows safe interleaved access to a resource that may be handled by multiple components within an application. Without an iterator, you may unintentionally modify a container without another user’s knowledge. STL iterators mostly, but not always, live up to this ideal goal.</p>
<p>Let’s take a look at how we can utilize an STL <code>iterator</code>. This example can be found as a complete <a id="_idIndexMarker921"/>program<a id="_idIndexMarker922"/> in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;list&gt;
<strong class="bold">#include &lt;iterator&gt;</strong>
<strong class="bold">using std::list;</strong>
<strong class="bold">using std::iterator;</strong>
<strong class="bold">bool operator&lt;(const Student &amp;s1, const Student &amp;s2)</strong>
{   // overloaded operator&lt; -- required to use list::sort()
    return s1.GetGpa() &lt; s2.GetGpa();
}
int main()
{
    list&lt;Student&gt; studentBody;  
    Student s1("Jul", "Li", 'M', "Ms.", 3.8, "C++",
               "117PSU");
    // Add Students to the studentBody list.
    studentBody.push_back(s1);
    // The next Student instances are anonymous objects
    studentBody.push_back(Student("Hana", "Sato", 'U',
                          "Dr.", 3.8, "C++", "178PSU"));
    studentBody.push_back(Student("Sara", "Kato", 'B',
                          "Dr.", 3.9, "C++", "272PSU"));
    studentBody.push_back(<a id="_idTextAnchor613"/>Student("Giselle", "LeBrun", 'R',
                          "Ms.", 3.4, "C++", "299TU"));
    <strong class="bold">studentBody.sort();</strong>  // sort() will rely on operator&lt; 
    // Though we'll generally prefer range-for loops, let's
    // understand and demo us<a id="_idTextAnchor614"/>ing an iterator for looping.
    // Create a list iterator; set to first item in list.
    // We'll next simplify it<a id="_idTextAnchor615"/>erator notation with 'auto'.
    <strong class="bold">list &lt;Student&gt;::iterator listIter =studentBody.begin();</strong>
    while (<strong class="bold">listIter != studentBody.end()</strong>)
    {
        <strong class="bold">Student &amp;temp = *listIter;</strong>
        temp.EarnPhD();
        <strong class="bold">++listIter;</strong>    // prefer pre-inc (less expensive)
    } 
    // Simplify iterator declaration using 'auto'
    <strong class="bold">auto autoIter = studentBody.begin();</strong>
    while (<strong class="bold">autoIter != studentBody.end()</strong>)
    {
        <strong class="bold">(*autoIter).Print();</strong>  
        <strong class="bold">++autoIter;</strong>
    }
    return 0;
}</pre>
<p>Let’s take a look at our previously defined code segment. Here, we include both the <code>&lt;list&gt;</code> and <code>&lt;iterator&gt;</code> headers from the STL. We also add <code>using std::list;</code> and <code>using std::iterator;</code> to include <code>list</code> and <code>iterator</code> from the standard namespace. As in our previous <code>main()</code> function, we instantiate a <code>list</code> that can contain <code>Student</code> instances using <code>list&lt;Student&gt; studentbody;</code>. We then instantiate<a id="_idIndexMarker923"/> several <code>Student</code> instances and add them to the list <a id="_idIndexMarker924"/>using <code>push_back()</code>. Again, notice that several <code>Student</code> instances are <em class="italic">anonymous objects</em>, having no local identifier in <code>main()</code>. These instances will be popped off the stack when <code>push_back()</code> completes. This is no problem, as <code>push_back()</code> will create local copies for the list.</p>
<p>Now, we can sort the list using <code>studentBody.sort();</code>. It is important to note that this <code>list</code> method required us to overload <code>operator&lt;</code> to provide a means of comparison between two <code>Student</code> instances. Luckily, we have! We have chosen to implement <code>operator&lt;</code> by comparing <code>gpa</code>, but it could also have used <code>studentId</code> for comparison.</p>
<p>Now that we have a <code>list</code>, we can create an <code>iterator</code> and establish it to refer to the first item of the <code>list</code>. We do so by declaring <code>list &lt;Student&gt;::iterator listIter = studentBody.begin();</code>. With the iterator established, we can use it to safely loop through the <code>list</code> from start (as it is initialized) to <code>end()</code>. We assign a local reference variable <code>temp</code> to the loop iteration’s current first element in the list with <code>Student &amp;temp = *listIter;</code>. We then call a method on this instance with <code>temp.EarnPhD();</code>, and then we increment our iterator b<a id="_idTextAnchor616"/>y one element using <code>++listIter;</code>.</p>
<p>In the subsequent loop, we simplify our declaration of the iterator using <code>auto</code>. The <code>auto</code> keyword allows the type of the iterator to be determined by its initial usage. Within this loop, we also eliminate the usage of <code>temp</code> – we simply deference the iterator first within parentheses and then invoke <code>Print()</code> by using <code>(*autoIter).Print()</code>. Using <code>++autoIter</code> simply advances to the next item in our list for processing.</p>
<p>Let’s take a look at the sorted output for this program (sorted by <code>gpa</code>):</p>
<pre>Dr. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++
Dr. Jul M. Li with id: 117PSU GPA:  3.8 Course: C++
Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</pre>
<p>Now that <a id="_idIndexMarker925"/>we<a id="_idIndexMarker926"/> have seen an <code>iterator</code> class in action, let’s investigate a variety of additional STL container classes, starting with <code>vector</code>. </p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor617"/>Using STL vector</h2>
<p>The STL <code>vector</code> class<a id="_idIndexMarker927"/> implements <a id="_idIndexMarker928"/>the Abstract Data Type of a dynamic array. Recall that we have made our own dynamic array by creating an <code>Array</code> class in <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>. The STL version, however, will be far more extensive. </p>
<p>The <code>vector</code> (dynamic or resizable array) will expand as necessary to accommodate additional elements beyond its initial size. The <code>vector</code> class allows direct (that is, <em class="italic">random access</em>) to elements by overloading <code>operator[]</code>. A <code>vector</code> allows elements to be accessed in constant time through direct access. It is not necessary to walk past all prior elements to access an element at a specific index.</p>
<p>However, adding elements in the middle of a <code>vector</code> is time-consuming. That is, adding to any location other than the end of the <code>vector</code> requires all elements past the insertion point to be internally shuffled; it may also require an internal resizing of the <code>vector</code>.</p>
<p>Clearly, <code>list</code> and <code>vector</code>, by comparison, have different strengths and weaknesses. Each is geared to different requirements of a collection of data. We can choose <a id="_idTextAnchor618"/><a id="_idTextAnchor619"/>the one that best fits our needs. </p>
<p>Let’s take a look at an assortment of common <code>vector</code> member functions. Th<a id="_idTextAnchor620"/>is is far from a complete list:</p>
<div><div><img alt="" height="377" src="img/Figure_14.1_B19087.jpg" width="1649"/>
</div>
</div>
<p>The STL <code>vector</code> class additionally includes overloaded <code>operator=</code> (assignment replaces destination vector with source vector), <code>operator==</code> (comparison of vectors, element by element), and <code>operator[]</code> (returns a reference to the requested lo<a id="_idTextAnchor621"/>cation, that is, writable memory).</p>
<p>Let’s take <a id="_idIndexMarker929"/>a look <a id="_idIndexMarker930"/>at how we can utilize the STL <code>vector</code> class with some of its basic operations. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;vector&gt;</strong>
<strong class="bold">using std::vector;</strong>
int ma<a id="_idTextAnchor622"/>in()
{   // instantiate two vectors
    <strong class="bold">vector&lt;Student&gt; studentBody1, studentBody2;</strong> 
    // add 3 Students, which are anonymous objects 
    <strong class="bold">studentBody1.push_back(Student("Hana", "Sato", 'U',</strong>
<strong class="bold">                           </strong><strong class="bold">"Dr.", 3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody1.push_back(Student("Sara", "Kato", 'B',</strong>
<strong class="bold">                           "Dr.", 3.9, "C++", "272PSU"));</strong>
    <strong class="bold">studentBody1.push_back(Student("Giselle", "LeBrun",</strong>
<strong class="bold">                         'R', "Ms.", 3.4, "C++", "299TU"));</strong>
    // Compare this loop to next loop using an iterator and
    // also to the preferred range-for loop further beyond
    for (int i = 0; i &lt; studentBody1.size(); i++)   
        studentBody1[i].Print();   // print first vector
    <strong class="bold">studentBody2 = studentBody1;</strong>   // assign one to another
    if (<strong class="bold">studentBody1 == studentBody2</strong>)
        cout &lt;&lt; "Vectors are the same" &lt;&lt; endl;
    // Notice: auto keyword simplifies iterator declaration
    for (<strong class="bold">auto</strong> iter = studentBody2.begin();
              iter != studentBody2.end(); iter++)
        (*iter).EarnPhD();
   // Preferred range-for loop (and auto to simplify type)
    for (const auto &amp;student : studentBody2)
        student.Print();
    if (<strong class="bold">!studentBody1.empty()</strong>)   // clear first vector 
        <strong class="bold">studentBody1.clear();</strong>
    return 0;
}</pre>
<p>In the previously listed code segment, we <code>#include &lt;vector&gt;</code> to include the appropriate STL header file. We also add <code>using std::vector;</code> to include <code>vector</code> from the standard namespace. Now, in <code>main()</code>, we can instantiate two vectors using <code>vector&lt;Student&gt; studentBody1, studentBody2;</code>. We can then use the <code>vector::push_back()</code> method to add several <code>Student</code> instances in succession to our first <code>vector</code>. Again, notice that the <code>Student</code> instances are <em class="italic">anonymous objects</em> in <code>main()</code>. That is, there is no local identifier that references them – they are created only to be placed into our vector, which makes a local copy of each instance upon insertion. Once we have elements in our vector, we then loop through our first <code>vector</code>, printing each <code>Student</code> using <code>studentBody1[i].Print();</code>.</p>
<p>Next, we demonstrate the overloaded assignment operator for <code>vector</code> by assigning one vector to another using <code>studentBody1 = studentBody2;</code>. Here, we make a deep copy from right to left in the assignment. We can then test whether the two vectors are<a id="_idIndexMarker931"/> equal using the overloaded comparison operator within a conditional<a id="_idIndexMarker932"/> statement, that is, <code>if (studentBody1 == studentBody2)</code>. </p>
<p>We then apply <code>EarnPhD()</code> to the contents of the second vector in a <code>for</code> loop using an iterator specified with <code>auto iter = studentBody2.begin();</code>. The <code>auto</code> keyword allows the type of the iterator to be determined by its initial usage. We then print out the contents of our second vector using a preferred range-for loop (as well as using <code>auto</code> to simplify the variable type in the range-for loop). Finally, we look through our first <code>vector</code>, testing whether it is <code>empty()</code>, and then clear elements one by one using <code>studentBody1.clear();</code>. We have now seen a sampling of the <code>vector</code> methods and their capabilities. </p>
<p>Let’s take a look at the output for this program:</p>
<pre>Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++
Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++
Vectors are the same
Everyone to earn a PhD
Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++
Dr. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</pre>
<p>Next, let’s<a id="_idIndexMarker933"/> investigate<a id="_idIndexMarker934"/> the STL <code>deque</code> class to further our knowledge of STL containers. </p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor623"/>Using STL deque</h2>
<p>The STL <code>deque</code> class (pronounced <em class="italic">deck</em>) implements<a id="_idIndexMarker935"/> the Abstract Data Type <a id="_idIndexMarker936"/>of a double-ended queue. This ADT extends the notion that a queue is first in, first out. Instead, the <code>deque</code> class allows greater flexibility. Adding elements at either end of a <code>deque</code> is quick. Adding elements in the middle of a <code>deque</code> is time-consuming. A <code>deque</code> is a sequential container, though more flexible than a <code>list</code>.</p>
<p>You might imagine that a <code>deque</code> is a specialization of a <code>queue</code>; it is not. Instead, the flexible <code>deque</code> class will serve as a basis to implement other container classes, which we will see shortly. In these cases, private inheritance will allow us to conceal <code>deque</code> as an underlying implementation (with vast functionality) for more restrictive, specialized classes.</p>
<p>Let’s take a look at an assortment of common <code>deque</code> member functi<a id="_idTextAnchor624"/>ons. This is far from a complete list:</p>
<div><div><img alt="" height="512" src="img/Figure_14.2_B19087.jpg" width="1650"/>
</div>
</div>
<p>The STL <code>deque</code> class additionally includes overloaded <code>operator=</code> (assignment of the source to destination deque) and <code>operator[]</code> (returns a reference to requested location – writable memory).</p>
<p>Let’s take a look at how we can utilize the STL <code>deque</code> class. This example can be found, as a full <a id="_idIndexMarker937"/>working <a id="_idIndexMarker938"/>program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;deque&gt;</strong> 
<strong class="bold">using std::deque;</strong>
int main()
{
    <strong class="bold">deque&lt;Student&gt; studentBody;</strong>   // create a deque
    Student s1("Tim", "Lim", 'O', "Mr.", 3.2, "C++",
               "111UD");
    // the remainder of the Students are anonymous objects
    <strong class="bold">studentBody.push_back(Student("Hana", "Sato", 'U',</strong>
<strong class="bold">                          "Dr.",3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push_back(Student("Sara", "Kato", 'B',</strong>
<strong class="bold">                          "Dr.", 3.9, "C++", "</strong><strong class="bold">272PSU"));</strong>
    <strong class="bold">studentBody.push_front(Student("Giselle", "LeBrun",</strong>
<strong class="bold">                          'R',"Ms.", 3.4, "C++"</strong><strong class="bold">, "299TU<a id="_idTextAnchor625"/>"));</strong>
    // insert one past the beginning 
    <strong class="bold">studentBody.insert(std::next(studentBody.begin()), </strong>
    <strong class="bold">Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++",</strong>
            <strong class="bold">"299CU"));</strong>
    <strong class="bold">studentBody[0] = s1;</strong>  // replace 0th element; 
                          // no bounds checking!
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
        <strong class="bold">studentBody.front()</strong>.Print();
        <strong class="bold">studentBody.pop_front();</strong>
    }
    return 0;
}</pre>
<p>In the <a id="_idIndexMarker939"/>previously<a id="_idIndexMarker940"/> listed code segment, we <code>#include &lt;deque&gt;</code> to include the appropriate STL header file. We also add <code>using std::deque;</code> to include <code>deque</code> from the standard namespace. Now, in <code>main()</code>, we can instantiate a <code>deque</code> to contain <code>Student</code> instances using <code>deque&lt;Student&gt; studentBody;</code>. We then call either <code>deque::push_back()</code> or <code>deque::push_front()</code> to add several <code>Student</code> instances (some anonymous objects) to our <code>deque</code>. We are getting the hang of this! Now, we insert a <code>Student</code> one position past the front of our deque using <code>studentBody.insert(std::next(studentBody.begin()), Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++", "299CU"));</code>. </p>
<p>Next, we take advantage of overloaded <code>operator[]</code> to insert a <code>Student</code> into our deque using <code>studentBody[0] = s1;</code>. Please be warned that <code>operator[]</code> does not do any bounds checking on our deque! In this statement, we insert <code>Student</code> <code>s1</code> into the 0th position in the <code>deque</code>, instead of the <code>Student</code> that once occupied that position. A safer bet is to use the <code>deque::at()</code> method, which will incorporate bounds checking. Regarding the aforementioned assignment, we also want to ensure that <code>operator=</code> has been overloaded for both <code>Person</code> and <code>Student</code>, as each class has dynamically allocated data members.</p>
<p>Now, we loop through until our <code>deque</code> is <code>empty()</code>, extracting and printing the front element of the deque using <code>studentBody.front().Print();</code>. With each iteration, we also pop the front item from our <code>deque</code> using <code>studentBody.pop_front();</code>. </p>
<p>Let’s take a look at the output for this program:</p>
<pre>Mr. Tim O. Lim with id: 111UD GPA:  3.2 Course: C++
Ms. Anne B. Brennan with id: 299CU GPA:  3.9 Course: C++
Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</pre>
<p>Now that we<a id="_idIndexMarker941"/> have <a id="_idIndexMarker942"/>a feel for a <code>deque</code>, let’s next investigate the STL <code>stack</code> class.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor626"/>Using STL stack</h2>
<p>The STL <code>stack</code> class<a id="_idIndexMarker943"/> implements the Abstract Data Type of a stack. The <a id="_idIndexMarker944"/>stack ADT supports<a id="_idIndexMarker945"/> the <code>stack</code> includes a public interface that does not advertise its underlying implementation. After all, a stack might change its implementation; the ADTs usage should not depend in any manner on its underlying implementation. The STL <code>stack</code> is considered an adaptive interface of a basic sequential container.</p>
<p>Recall that we have made our own <code>Stack</code> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>, using a private base class of <code>LinkedList</code>. The STL version will be more extensive; interestingly, it is implemented using <code>deque</code> as its underlying private base class. With <code>deque</code> as a private base class of the STL <code>stack</code>, the more versatile underlying capabilities of <code>deque</code> are hidden; only the applicable methods are used to implement the stack’s public interface. Also, because the means of implementation is hidden, a <code>stack</code> may be implemented using another container c<a id="_idTextAnchor627"/>lass at a later date without impacting its usage.</p>
<p>Let’s take a look at an assortment of common <code>stack</code> member functions. This is far from a complete list. It is important to note that the public interface for <code>stack</code> is far smaller than that of its private base class, <code>deque</code>:</p>
<div><div><img alt="" height="358" src="img/Figure_14.3_B19087.jpg" width="1500"/>
</div>
</div>
<p>The STL <code>stack</code> class additionally includes overloaded <code>operator=</code> (assignment of source to destination stack), <code>operator==</code> and <code>operator!=</code> (equality/inequality of two stacks), and <code>operator&lt;</code> , <code>operator&gt;</code>, <code>operator&lt;=</code>, and <code>operator&gt;=</code> (comparison of stacks).</p>
<p>Let’s take a<a id="_idIndexMarker946"/> look <a id="_idIndexMarker947"/>at how we can utilize the STL <code>stack</code> class. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;stack&gt;</strong>   // template class preamble
<strong class="bold">using std::stack;</strong>
int main()
{
    <strong class="bold">stack&lt;Student&gt; studentBody;</strong>   // create a stack
    // add Students to the stack (anonymous objects)
    <strong class="bold">studentBody.push(Student("Hana", "Sato", 'U', "Dr.",</strong>
<strong class="bold">                             3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Sara", </strong><strong class="bold">"Kato", 'B', "Dr.",</strong>
<strong class="bold">                             3.9, "C++", "272PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Giselle</strong><strong class="bold">", "LeBrun", 'R',</strong>
<strong class="bold">                             "Ms.", 3.4, "C++", "299TU"));</strong>
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
        <strong class="bold">studentBody.top()</strong>.Print()<a id="_idTextAnchor628"/>;
        <strong class="bold">studentBody.pop();</strong>
    }
    return 0;
}</pre>
<p>In the aforementioned code segment, we <code>#include &lt;<a id="_idTextAnchor629"/>stack&gt;</code> to include the appropriate STL header file. We also add <code>using std::stack;</code> to include <code>stack</code> from the standard<a id="_idIndexMarker948"/> namespace. Now, in <code>main()</code>, we can instantiate a <code>stack</code> to contain <code>Student</code> instances <a id="_idIndexMarker949"/>using <code>stack&lt;Student&gt; studentBody;</code>. We then call <code>stack::push()</code> to add several <code>Student</code> instances to our <code>stack</code>. Notice that we are using the traditional <code>push()</code> method, which contributes to the ADT of a stack.</p>
<p>We then loop through our <code>stack</code> while it is not <code>empty()</code>. Our goal is to access and print the top element using <code>studentBody.top().Print();</code>. We then neatly pop our top element off the stack using <code>studentBody.pop();</code>.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++
Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</pre>
<p>Next, let’s <a id="_idIndexMarker950"/>investigate <a id="_idIndexMarker951"/>the STL <code>queue</code> class to further increase our STL container repertoire. </p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor630"/>Using STL queue</h2>
<p>The STL <code>queue</code> class<a id="_idIndexMarker952"/> implements the ADT of a queue. As the <a id="_idIndexMarker953"/>stereotypical queue class, STL’s <code>queue</code> class supports the <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) order<a id="_idIndexMarker954"/> of insertion and remova<a id="_idTextAnchor631"/>l of members. </p>
<p>Recall that we made our own <code>Queue</code> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>; we derived our <code>Queue</code> from our <code>LinkedList</code> class using private inheritance. The STL version will be more extensive; the STL <code>queue</code> class is implemented using <code>deque</code> as its underlying implementation (also using private inheritance). Remember, because the means of implementation are hidden with private inheritance, a <code>queue</code> may be implemented using another data type at a later date without impacting its public interface. The STL <code>queue</code> class is another example of an adaptive interface for a basic sequential container.</p>
<p>Let’s take a look at an assortment of common <code>queue</code> member functions. This is far from a complete list. It is important to note that the public interface of <code>queue</code> is far smaller than that of its private base class, <code>deque</code>:</p>
<div><div><img alt="" height="411" src="img/Figure_14.4_B19087.jpg" width="1650"/>
</div>
</div>
<p>The STL <code>queue</code> class additionally includes overloaded <code>operator=</code> (assignment of source to destination queue), <code>operator==</code> and <code>operator!=</code> (equality/inequality of two queues), and <code>operator&lt;</code> , <code>operator&gt;</code>, <code>operator&lt;=</code>, and <code>operator&gt;=</code> (comparison of queues).</p>
<p>Let’s take a look at <a id="_idIndexMarker955"/>how we can utilize the STL <code>queue</code> class. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;queue&gt;</strong>  
<strong class="bold">using std::queue;</strong>
int main()
{
    <strong class="bold">queue&lt;Student&gt; studentBody;</strong>  // create a queue
    // add Students to the queue (anonymous objects)
    <strong class="bold">studentBody.push(Student("Hana", "Sato", 'U', "Dr.",</strong>
<strong class="bold">                             3.8, "C++", "178PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Sara", "Kato", 'B' "Dr.",</strong>
<strong class="bold">                             3.9, "C++", </strong><strong class="bold">"272PSU"));</strong>
    <strong class="bold">studentBody.push(Student("Giselle", "LeBrun", 'R',</strong>
<strong class="bold">                             "Ms.", 3.4, "C++", "299TU"));</strong>
    while (<strong class="bold">!studentBody.empty()</strong>)
    {
        <strong class="bold">studentBody.front()</strong>.Print();
        <strong class="bold">studentBody.pop();</strong>
    }
    return 0;
}</pre>
<p>In the previous <a id="_idIndexMarker956"/>code segment, we first <code>#include &lt;queue&gt;</code> to include <a id="_idIndexMarker957"/>the appropriate STL header file. We also add <code>using std::queue;</code> to include <code>queue</code> from the standard namespace. Now, in <code>main()</code>, we can instantiate a <code>queue</code> to contain <code>Student</code> instances using <code>queue&lt;Student&gt; studentBody;</code>. We then call <code>queue::push()</code> to add several <code>Student</code> instances to our <code>queue</code>. Recall that with the queue ADT, <code>push()</code> implies that we are adding an element at the end of the queue. Some programmers prefer the term <em class="italic">enqueue</em> to describe this operation; however, the STL has selected to name this operation <code>push()</code>. With the <code>queue</code> ADT, <code>pop()</code> will remove an item from the front of the queue; a better term is <em class="italic">dequeue</em>, however, that is not what the STL has chosen. We can adapt.</p>
<p>We then loop through our <code>queue</code> while it is not <code>empty()</code>. Our goal is to access and print the front element using <code>studentBody.front().Print();</code>. We then neatly pop our front element off the <code>queue</code> using <code>studentBody.pop();</code>. Our work is complete.</p>
<p>Let’s take a<a id="_idIndexMarker958"/> look <a id="_idIndexMarker959"/>at the output for this program:</p>
<pre>Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++
Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</pre>
<p>Now that we have tried a <code>queue</code>, let’s invest<a id="_idTextAnchor632"/>igate the STL <code>priority_queue</code> class. </p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor633"/>Using STL priority queue</h2>
<p>The STL <code>priority_queue</code> class <a id="_idIndexMarker960"/>implements the <a id="_idIndexMarker961"/>Abstract Data Type of a priority queue. The priority queue ADT supports a modified FIFO order of insertion and removal of members; the elements are <em class="italic">weighted</em>. The front element is of the largest value (determined by overloaded <code>operator&lt;</code>) and the rest of the elements follow in sequence from the next greatest to the least. The STL <code>priority_queue</code> class is considered an adaptive interface for a sequential container.</p>
<p>Recall that we implemented our own <code>PriorityQueue</code> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Inheritance</em>. We used public inheritance to allow our <code>PriorityQueue</code> to specialize our <code>Queue</code> class, adding additional methods to support the priority (weighted) enqueuing scheme. The underlying implementation of <code>Queue</code> (with private base class <code>LinkedList</code>) was hidden. By using public inheritance, we allowed our <code>PriorityQueue</code> to be able to be generalized as a <code>Queue</code> through upcasting (which we understood once we learned about polymorphism and virtual functions in <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em>). We made an acceptable design choice: <em class="italic">PriorityQueue Is-A</em> (specialization of) <em class="italic">Queue</em> and at times may be treated in its more general form. We also recall that neither a <code>Queue</code> nor a <code>PriorityQueue</code> could be upcast to their underlying implementation of a <code>LinkedList</code>, as <code>Queue</code> was derived privately from <code>LinkedList</code>; we cannot upcast past a non-public inheritance boundary.</p>
<p>Contrastingly, the STL version of <code>priority_queue</code> is implemented using the STL <code>vector</code> as its underlying implementation. Recall that because the means of implementation is hidden, a <code>priority_queue</code> may be implemented using another data type at a later date without impacting its public interface. </p>
<p>An STL <code>priority_queue</code> allows an inspection, but not a modification, of the top element. The STL <code>priority_queue</code> does not allow insertion through its elements. That is, elements may only be added resulting in an order from greatest to least. Accordingly, the top element may be inspected, and the top element may be removed.</p>
<p>Let’s take a look at an assortment of common <code>priority_queue</code> member functions. This is not a complete list. It is important to note that the public interface of <code>priority_queue</code> is far<a id="_idIndexMarker962"/> smaller than that of its private base class, <code>vector</code>:</p>
<div><div><img alt="" height="326" src="img/Figure_14.5_B19087.jpg" width="1650"/>
</div>
</div>
<p>Unlike the previously examined container classes, the STL <code>priority_queue</code> does not overload operators, including <code>operator=</code>, <code>operator==</code>, and <code>operator&lt;</code>. </p>
<p>The most interesting method of <code>priority_queue</code> is that of <code>void emplace(args);</code>. This is the member function that allows the priority enqueuing mechanism to add items to this ADT. We also notice that <code>top()</code> must be used to return the top element (versus <code>front()</code>, which a <code>queue</code> utilizes). But then again, an STL <code>priority_queue</code> is not implemented using a <code>queue</code>). To utilize <code>priority_queue</code>, we <code>#include &lt;queue&gt;</code>, just as we would for a <code>queue</code>.</p>
<p>Because the usage of <code>priority_queue</code> is so similar to <code>queue</code>, we will instead explore it further, programming-wise, in our question set at the end of this chapter. </p>
<p>Now that we have seen many examples of sequential container types in STL (including adaptive<a id="_idIndexMarker963"/> interfaces), let<a id="_idTextAnchor634"/>’s next investigate the STL <code>map</code> class, an<a id="_idIndexMarker964"/> associative container.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor635"/>Examining STL map</h2>
<p>The STL <code>map</code> class<a id="_idIndexMarker965"/> implements the Abstract Data Type of a hash table. The class <code>map</code> allows for elements in the hash table or map to be stored and retrieved quickly using a <code>multimap</code> can be used instead should there be more than one piece of data that needs to be associated with a single key.</p>
<p>Hash tables (maps) are fast for storage and lookup of data. The performance is a guaranteed <em class="italic">O(log(n))</em>. The STL <code>map</code> is considered an associative container, as it associates a key to a value to quickly retrieve a value.</p>
<p>Let’s take a look at an assortment of common <code>map</code> member functions. This is not a complete list:</p>
<div><div><img alt="" height="565" src="img/Figure_14.6_B19087.jpg" width="1650"/>
</div>
</div>
<p>The STL class map additionally includes overloaded operator <code>operator==</code> (comparison of maps, element by element) implemented as a global function. STL map also includes overloaded <code>operator[]</code> (returns a reference to the map element associated with a key that is used as an index; this is writable memory).</p>
<p>Let’s take a look at how we can utilize the STL <code>map</code> class. This example <a id="_idTextAnchor636"/>can be found, as a full <a id="_idIndexMarker966"/>working <a id="_idIndexMarker967"/>program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;map&gt;</strong>
<strong class="bold">using std::map;</strong>
<strong class="bold">using std::pair;</strong>
bool operator&lt;(const Student &amp;s1, const Student &amp;s2)
{   // We need to overload operator&lt; to compare Students
    return s1.GetGpa() &lt; s2.GetGpa();
}
int main()
{
    Student s1("Hana", "Lo", 'U', "Dr.", 3.8, "C++",
               "178UD");
    Student s2("Ali", "Li", 'B', "Dr.", 3.9, "C++",
               "272UD");
    Student s3("Rui", "Qi", 'R', "Ms.", 3.4, "C++",
               "299TU");
    Student s4("Jiang", "Wu", 'C', "Ms.", 3.8, "C++",
      <a id="_idTextAnchor638"/>         "887TU");
    // create three pairings of ids to Students
    <strong class="bold">pair&lt;string, Student&gt; studentPair1</strong>
                                <strong class="bold">(s1.GetStudentId(), s1);</strong>
    <strong class="bold">pair&lt;string, Student&gt; studentPair2</strong>
                                <strong class="bold">(s2.GetStudentId(), s2);</strong>
    <strong class="bold">pair&lt;string, Student&gt; studentPair3</strong>
                                <strong class="bold">(s3.GetStudentId(), s3);</strong>
    // Create map of Students w string keys
    <strong class="bold">map&lt;string, Student&gt; studentBody;</strong>
    <strong class="bold">studentBody.insert(studentPair1);</strong>  // insert 3 pairs
    <strong class="bold">studentBody.insert(studentPair2);</strong>
    <strong class="bold">studentBody.insert(studentPair3);</strong>
    // insert using virtual indices per map
    <strong class="bold">studentBody[s4.GetStu<a id="_idTextAnchor639"/>dentId()] = s4;</strong> 
    // Iterate through set with map iterator – let's 
    // compare to range-for and auto usage just below
    <strong class="bold">map&lt;string, Student&gt;::iterator mapIter;</strong>
    <strong class="bold">mapIter = studentBody.begin();</strong>
    while (<strong class="bold">mapIter != studentBody.end()</strong>)
    {   
        // set temp to current item in map iterator
        <strong class="bold">pair&lt;string, Student&gt; temp = *mapIter;</strong>
        Student &amp;tempS = <strong class="bold">temp.second;</strong>  // get 2nd element
        // access using mapIter
        cout &lt;&lt; <strong class="bold">temp.first</strong> &lt;&lt; " ";
        cout &lt;&lt; <strong class="bold">temp.second</strong>.GetFirstName();  
        // or access using temporary Student, tempS  
        cout &lt;&lt; " " &lt;&lt; tempS.GetLastName() &lt;&lt; endl;
        <strong class="bold">++mapIter;</strong>
    }
    // Now, le<a id="_idTextAnchor640"/>t's iterate through our map using a range-for
    // loop and using 'auto' to simplify the declaration
    // (this decomposes the pair to 'id' and 'student')
    for (<strong class="bold">auto &amp;[id, student]</strong> : studentBody)
        cout &lt;&lt; <strong class="bold">id</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">student</strong>.GetFirstName() &lt;&lt; " " 
             &lt;&lt; <strong class="bold">student</strong>.GetLastName() &lt;&lt; endl;
    return 0;
}</pre>
<p>Let’s examine the<a id="_idIndexMarker968"/> preceding code segments. Again, we<a id="_idTextAnchor641"/> include<a id="_idIndexMarker969"/> the applicable header file with <code>#include &lt;map&gt;</code>. We also add <code>using std::map;</code> and <code>using std::pair;</code> to include <code>map</code> and <code>pair</code> from the standard namespace. Next, we instantiate four <code>Student</code> instances. Next, we create three <code>pair</code> instances to associate a grouping between each Student and its key (that is, with their respective <code>studentId</code>) using the declaration <code>pair&lt;string, Student&gt; studentPair1 (s1.GetStudentId(), s1);</code>. This may seem confusing to read, but let’s break this declaration down into its components. Here, the instance’s data type is <code>pair&lt;string, Student&gt;</code>, the variable name is <code>studentPair1</code>, and <code>(s1.GetStudentId(), s1)</code> are the arguments passed to the specific <code>pair</code> instance’s constructor.</p>
<p>We will be making a hash table (<code>map</code>) of <code>Student</code> instances to be indexed by a key (which is their <code>studentId</code>). Next, we declare a <code>map</code> to hold the collection of <code>Student</code> instances with <code>map&lt;string, Student&gt; studentBody;</code>. Here, we indicate that the association between the key and element will be between a <code>string</code> and a <code>Student</code>. We then declare a map iterator with <code>map&lt;string, Student&gt;::iterator mapIter;</code> using the same data types. </p>
<p>Now, we simply insert the three <code>pair</code> instances into the <code>map</code>. An example of this insertion is <code>studentBody.insert(studentPair1);</code>. We then insert a fourth <code>Student</code>, <code>s4</code>, into the <code>map</code> using the map’s overloaded <code>operator[]</code> with the following statement: <code>studentBody[s4.GetStudentId()] = s4;</code>. Notice that the <code>studentId</code> is used as the index value in <code>operator[]</code>; this value will become the key value for the <code>Student</code> in the hash table.</p>
<p>Next, we declare and establish the map iterator to the beginning of the <code>map</code> and then process the <code>map</code> while it is not at the <code>end()</code>. Within the loop, we set a variable, <code>temp</code>, to the <code>pair</code> at the front of the map, indicated by the map iterator. We also set <code>tempS</code> as a temporary reference to a <code>Student</code> in the <code>map</code>, which is indicated by <code>temp.second</code> (the second value in the current <code>pair</code> managed by the map iterator). We now can print out each <code>Student</code> instance’s <code>studentId</code> (the key, which is a <code>string</code>) using <code>temp.first</code> (the first item in the current <code>pair</code>). In the same statement, we can then print out each <code>Student</code> instance’s <code>firstName</code> using <code>temp.second.GetFirstName()</code> (since the <code>Student</code> corresponding to the key is the second item in the current <code>pair</code>). Similarly, we could also use <code>tempS.GetLastName()</code> to print a student’s <code>lastName</code>, as <code>tempS</code> was previously initialized to the <a id="_idIndexMarker970"/>second element in the current <code>pair</code> at the beginning<a id="_idIndexMarker971"/> of each loop iteration.</p>
<p>Finally, as an alternative to the more tedious approach demonstrated previously used to iterate through the <code>map</code> (taking apart the <code>pair</code> manually), let’s examine the final loop in our program. Here, we utilize a range-for loop to process the <code>map</code>. The use of <code>auto</code> with <code>&amp;[id, student]</code> will specify the type of data that we will iterate. The brackets (<code>[]</code>) will decompose the <code>pair</code>, binding the iterative elements to <code>id</code> and <code>student</code>, respectively, as identifiers<a id="_idTextAnchor642"/><a id="_idTextAnchor643"/>. Notice the ease at which we can now iterate over<a id="_idTextAnchor644"/> the <code>studentBody</code> map.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>178UD Hana Lo
272UD Ali Li
299TU Rui Qi
887TU Jiang Wu
178UD Hana Lo
272UD Ali Li
299TU Rui Qi
887TU Jiang Wu</pre>
<p>Next, let’s take a look at an alternative with an STL <code>map</code>, which will introduce us to the STL <code>functor</code> concept.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor645"/>Examining STL map using a functor</h2>
<p>The STL <code>map</code> class <a id="_idIndexMarker972"/>has great flexibility, like <a id="_idIndexMarker973"/>many<a id="_idIndexMarker974"/> STL classes. In our past <code>map</code> example, we assumed that a means for comparison was present in our <code>Student</code> class. We had, after all, overloaded <code>operator&lt;</code> for two <code>Student</code> instances. What happens, however, if we cannot revise a class that has not provided this overloaded operator and we also choose not to overload <code>operator&lt;</code> as an external function?</p>
<p>Fortunately, we may specify a third data type for the template type expansion when instantiating a <code>map</code> or map iterator. This additional data type will be a specific type of class, known as a functor. A <code>operator()</code>. It is within overloaded <code>operator()</code> that we will provide a means of comparison for the objects in question. A functor essentially simulates encapsulating a function pointer by overloading <code>operator()</code>.</p>
<p>Let’s take a look at how we might revise our <code>map</code> example to utilize a simple functor. This example can be found, as a full working program, in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;map&gt;</strong>
<strong class="bold">using std::map;</strong>
<strong class="bold">using std::pair;</strong>
<strong class="bold">struct comparison</strong>   // This struct represents a 'functor'
<strong class="bold">{</strong>                   // that is, a 'function object'
    <strong class="bold">bool operator() (const string &amp;key1, </strong>
<strong class="bold">                     const string &amp;key2) const</strong>
    <strong class="bold">{</strong>   
        int ans = key1.compare(key2);
        if (ans &gt;= 0) return true;  // return a boolean
        else return false;  
    <strong class="bold">}</strong>
    // default constructor and destructor are adequate
<strong class="bold">};</strong>
int main()
{
    Student s1("Hana", "Sato", 'U', "Dr.", 3.8, "C++", 
               "178PSU");
    Student s2("Sara", "Kato", 'B', "Dr.", 3.9, "C++",
               "272PSU");
    Student s3("Jill", "Long", 'R', "Dr.", 3.7, "C++",
               "234PSU");
    <strong class="bold">// Now, map is maintained in sorted (decreasing) order</strong>
    <strong class="bold">// per ‹comparison› functor using operator()</strong>
    map&lt;string, Student, <strong class="bold">comparison</strong>&gt; studentBody;
    map&lt;string, Student, <strong class="bold">comparison</strong>&gt;::iterator mapIter;
    // The remainder of the program is similar to prior
}   // map program. See online code for complete example.</pre>
<p>In the <a id="_idIndexMarker976"/>previously <a id="_idIndexMarker977"/>mentioned code fragment, we first introduce a user defined type of <code>comparison</code>. This can be a <code>class</code> or a <code>struct</code>. Within this structure definition, we have overloaded the function call operator (<code>operator()</code>) and provided a means of comparison between two <code>string</code> keys for <code>Student</code> instances. This comparison will allow <code>Student</code> instances to be inserted in an order determined by the comparison functor.</p>
<p>Now, when we instantiate our <code>map</code> and map iterators, we specify as the third parameter for the template type expansion our <code>comparison</code> type (the functor). And, neatly embedded within this type is the overloaded function call operator, <code>operator()</code>, which will provide our needed comparison. The remaining code will be similar to our original <code>map</code> program.</p>
<p>Certainly, functors may be used in additional, more advanced ways beyond what we have seen here with the container class <code>map</code>. Nonetheless, you now have a flavor for how a functor can apply to the STL.</p>
<p>Now that we <a id="_idIndexMarker978"/>have seen how to utilize a variety of<a id="_idIndexMarker979"/> STL <a id="_idIndexMarker980"/>container classes, let’s consider why we may want to customize an STL class, and how to do so.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor646"/>Customizing STL containers</h1>
<p>Most classes in C++ can<a id="_idIndexMarker981"/> be customized in some fashion, including classes in the STL. However, we must be aware of design decisions made within the STL that will limit how we may customize these components. Because the STL container classes purposely do not include virtual destructors or other virtual functions, we should not use specialization via public inheritance to extend these classes. Note that C++ will not stop us, but we know from <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Using Dynamic Binding through Polymorphism</em>, that we should never override non-virtual functions. STL’s choice to not include virtual destructors and other virtual functions to allow further specialization of these classes was a solid design choice made long ago when STL containers were crafted. </p>
<p>We could, however, use private or protected inheritance, or the concepts of containment or association to use an STL container class as a building block. That is, to hide the underlying implementation of a new class, where the STL provides a solid, yet hidden implementation for the new class. We would simply provide our own public interface for the new class and, under the hood, delegate the work to our underlying implementation (whether <a id="_idTextAnchor647"/>that be a private or protected base class, or a contained or associated object). </p>
<p>Extreme care and caution must be taken when extending any template class, including those in the STL using private or protected base classes. This caution will also apply to containing or associating to other template classes. Template classes are generally not compiled (or syntax checked) until an instance of the template class with a specific type is created. This means that any derived or wrapper classes that are created can only be fully tested when instances of specific types are created. </p>
<p>Appropriate overloaded operators will need to be put in place for new classes so that these operators will work automatically with customized types. Keep in mind that some operator functions, such as <code>operator=</code>, are not explicitly inherited from base to derived class and need to be written with each new class. This is appropriate since derived classes will likely have more work to accomplish than found in the generalized versions of <code>operator=</code>. Remember, if you cannot modify the class definition of a class requiring a selected overloaded operator, you must implement that operator function as an external function.</p>
<p>In addition to customizing containers, we may also choose to augment an algorithm based on an existing algorithm within the STL. In this case, we would use one o<a id="_idTextAnchor648"/><a id="_idTextAnchor649"/><a id="_idTextAnchor650"/>f the many STL functions as part of a new algorithm’s underlying implementation. </p>
<p>Customizing classes from existing libraries comes up routinely in programming. For example, consider how we extended the Standard Library <code>exception</code> class to create customized exceptions in <a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em> (though that scenario utilized public inheritance, which will not apply to customizing STL classes). Keep in mind that the STL offers a very full complement of container classes. Rarely will you find the need to augment STL classes – perhaps only with a very domain-specific class need. Nonetheless, you now know the caveats involved in customizing STL classes. Remember, care and caution must always be used when augmenting a class. We can now see the need to employ proper OO component testing for any classes we create.</p>
<p>We have now<a id="_idIndexMarker982"/> considered how to potentially customize STL container classes and algorithms within our programs. We have also seen quite a few STL container class examples in action. Let us now briefly recap these concepts before moving forward to our next chapter.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor651"/>Summary</h1>
<p>In this chapter, we have furthered our C++ knowledge beyond OOP language features to gain familiarity with the C++ Standard Template Library. As this library is used so commonly in C++, it is essential that we understand both the scope and breadth of the classes it contains. We are now prepared to utilize these useful, well-tested classes in our code. </p>
<p>We have looked at quite a few STL examples; by examining selective STL classes, we should feel empowered to understand the remainder of the STL (or any C++ library) on our own.</p>
<p>We have seen how to use common and essential STL classes such as <code>list</code>, <code>iterator</code>, <code>vector</code>,<code> deque</code>, <code>stack</code>, <code>queue</code>, <code>priority_queue</code>, and <code>map</code>. We have also seen how to utilize a functor in conjunction with a container class. We have been reminded that we now have the tools to potentially customize any class, even those from class libraries such as STL through private or protected inheritance, or with containment or association.</p>
<p>We have additionally seen through examining selected STL classes that we have the skills to understand the remaining depth and breadth of the STL, as well as decode many additional class libraries that are available to us. As we navigate the prototypes of each member function, we notice key language concepts, such as the use of <code>const</code>, or that a method returns a reference to an object representing writable memory. Each prototype reveals the mechanics for the usage of the new class. It is very exciting to have come this far with our programming endeavors! </p>
<p>We have now adde<a id="_idTextAnchor652"/>d additional, useful features to our C++ repertoire through browsing the STL in C++. Usage of the STL (to encapsulate traditional data structures) will ensure that our code can easily be understood by other programmers who are also undoubtedly using the STL. Relying on the well-tested STL for these common containers and utilities ensures that our code remains more bug-free. </p>
<p>We are now ready to continue forward with <a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em>. We want to complement our C++ programming skills with useful OO component testing skills. Testing skills will help us understand whether we have created, extended, or augmented classes in a robust fash<a id="_idTextAnchor653"/>ion. These skills will make us better programmers. Let’s continue onward!</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor654"/>Questions</h1>
<ol>
<li>Replace your template <code>Array</code> class from your exercise from <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, with an STL <code>vector</code>. Create a <code>vector</code> of <code>Student</code> instances. Use <code>vector</code> operations to insert, retrieve, print, compare, and remove objects from the vector. Alternatively, utilize an STL <code>list</code>. Use this opportunity to utilize the STL documentation to navigate the full set of operations available for these classes.</li>
</ol>
<p>a. Consider what operators, if any, you will need to overload. Consider whether you will need an <code>iterator</code> to provide safe interleaved access to your collection.</p>
<p>b. Create a second <code>vector</code> of <code>Student</code> instances. Assign one to another. Print both vectors.</p>
<ol>
<li value="2">Modify the <code>map</code> from this chapter to index the hash table (map) of <code>Student</code> instances based on <code>lastName</code> rather than <code>studentId</code>. </li>
<li>Modify the <code>queue</code> example from this chapter to instead utilize <code>priority_queue</code>. Be sure to make use of the priority enqueueing mechanism <code>priority_queue::emplace()</code> to add elements into the <code>priority_queue</code>. You will also need to utilize <code>top()</code> instead of <code>front()</code>. Note that <code>priority_queue</code> can be found in the <code>&lt;queue&gt;</code> header file.</li>
<li>Try out an STL algorithm using <code>sort()</code>. Be sure to <code>#include &lt;algorithm&gt;</code>. Sort an array of integers. Keep in mind that many containers have sorting mechanisms built in, but native collection types, such as a language-supplied array, will not (which is why you should use a basic array of integers).</li>
</ol>
</div>
</div></body></html>