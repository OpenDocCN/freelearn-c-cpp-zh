<html><head></head><body>
<div id="_idContainer056">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 class="chapterTitle" id="_idParaDest-133"><span class="koboSpan" id="kobo.2.1">Improving Type-Safety with Strong Types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">C++ is a statically typed language, meaning that every expression is assigned a type at a compile time, either by a developer (in most cases), or deduced by a compiler when using the keyword auto. </span><span class="koboSpan" id="kobo.3.2">Still, this doesn’t make it a type-safe language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Both C++ and C allow functions with a variable number of arguments (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5.1">va_arg</span></code><span class="koboSpan" id="kobo.6.1">), or variadic functions and type casting, and support implicit type conversion. </span><span class="koboSpan" id="kobo.6.2">These low-level capabilities that are associated with the performance of C++ and C are often the source of bugs in programs. </span><span class="koboSpan" id="kobo.6.3">In this chapter, we will cover good practices used to increase type-safety in C++.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">Type-safety</span></strong><span class="koboSpan" id="kobo.8.1"> is an </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.9.1">important aspect of a program in safety-critical systems. </span><span class="koboSpan" id="kobo.9.2">That’s why safety coding standards provided by organizations such as MISRA and AUTOSAR restrain the usage of features that violate type-safety. </span><span class="koboSpan" id="kobo.9.3">In this chapter, we’re going to cover the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Implicit conversions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Explicit conversions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Strong types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-134"><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.14.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.15.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.16.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.16.2">Select GCC as your compiler for x86 architecture. </span><span class="koboSpan" id="kobo.16.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.16.4">As we are using a lot of modern C++ features, make sure to select the C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">-std=c++23</span></code><span class="koboSpan" id="kobo.18.1"> in the compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. </span><span class="koboSpan" id="kobo.19.2">Most of the examples can also be run in the Renode simulator on Arm Cortex-M0 target and are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09"><span class="url"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09</span></span></a><span class="koboSpan" id="kobo.21.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-135"><span class="koboSpan" id="kobo.22.1">Implicit conversion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.23.1">When you make a call to a function that expects an integer parameter, but you pass a float as an argument, the compiler will happily compile the program. </span><span class="koboSpan" id="kobo.23.2">Similarly, if you pass an array of integers </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.24.1">to a function that expects a pointer to an integer, the program will also compile. </span><span class="koboSpan" id="kobo.24.2">These scenarios have become so normalized in both C and C++ that they are often taken for granted </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.25.1">without considering what’s happening during the compilation process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">In both described scenarios, the compiler is performing implicit conversions. </span><span class="koboSpan" id="kobo.26.2">It converts the float to an integer in the first scenario and passes a pointer to the first element of the array in the second scenario, a process known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.27.1">array-to-pointer decay</span></strong><span class="koboSpan" id="kobo.28.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.29.1">While implicit conversions make the code less verbose and easier to write, they also open the door to a range of type-safety-related issues. </span><span class="koboSpan" id="kobo.29.2">Converting a float to an integer leads to precision loss, and assuming that an array always behaves like a pointer can lead to misinterpretations of the array’s bounds, potentially causing buffer overflows or other memory issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">Implicit conversion </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.31.1">is performed in the following cases:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">When a function is called with an argument of a type different than the parameter. </span><span class="koboSpan" id="kobo.32.2">For example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.33.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.34.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.35.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.36.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.37.1">print_int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.38.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.39.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.40.1"> value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.41.1">{
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.42.1">    printf</span></span><span class="koboSpan" id="kobo.43.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.44.1">"value = %d\n"</span></span><span class="koboSpan" id="kobo.45.1">, value);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.46.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.47.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.48.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.49.1">{
</span><span class="hljs-type"><span class="koboSpan" id="kobo.50.1">    float</span></span><span class="koboSpan" id="kobo.51.1"> pi = </span><span class="hljs-number"><span class="koboSpan" id="kobo.52.1">3.14f</span></span><span class="koboSpan" id="kobo.53.1">;
</span><span class="hljs-type"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.54.1">// int implicitly converts to float</span></span>
<span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.55.1">print_int</span></span><span class="koboSpan" id="kobo.56.1">(pi);
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.57.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.58.1">0</span></span><span class="koboSpan" id="kobo.59.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.60.1">When a value specified in a return statement is of a different type than specified by a function declaration. </span><span class="koboSpan" id="kobo.60.2">For example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.61.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.62.1">get_int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.63.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.64.1">{
</span><span class="hljs-type"><span class="koboSpan" id="kobo.65.1">    float</span></span><span class="koboSpan" id="kobo.66.1"> pi = </span><span class="hljs-number"><span class="koboSpan" id="kobo.67.1">3.14</span></span><span class="koboSpan" id="kobo.68.1">;
</span><span class="hljs-type"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.69.1">// float implicitly converts to int</span></span>
<span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.70.1">return</span></span><span class="koboSpan" id="kobo.71.1"> pi;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.72.1">In expressions </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.73.1">with binary operators provided with operands of different arithmetic types. </span><span class="koboSpan" id="kobo.73.2">For example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.74.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.75.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.76.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.77.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.78.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.79.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.80.1">{
</span><span class="hljs-type"><span class="koboSpan" id="kobo.81.1">    int</span></span><span class="koboSpan" id="kobo.82.1"> int_value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.83.1">5</span></span><span class="koboSpan" id="kobo.84.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.85.1">    float</span></span><span class="koboSpan" id="kobo.86.1"> float_value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.87.1">4.2</span></span><span class="koboSpan" id="kobo.88.1">;
</span><span class="hljs-type"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.89.1">// int converts to float</span></span>
<span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.90.1">auto</span></span><span class="koboSpan" id="kobo.91.1"> result = int_value + float_value;
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.92.1">printf</span></span><span class="koboSpan" id="kobo.93.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.94.1">"result = %f\n"</span></span><span class="koboSpan" id="kobo.95.1">, result);
</span><span class="hljs-type"> </span>
<span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.96.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.97.1">0</span></span><span class="koboSpan" id="kobo.98.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.99.1">In a </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">switch</span></code><span class="koboSpan" id="kobo.101.1"> statement to an integral type. </span><span class="koboSpan" id="kobo.101.2">For example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.102.1">char</span></span><span class="koboSpan" id="kobo.103.1"> input = </span><span class="hljs-string"><span class="koboSpan" id="kobo.104.1">'B'</span></span><span class="koboSpan" id="kobo.105.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.106.1">// implicit conversion from char to int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.107.1">switch</span></span><span class="koboSpan" id="kobo.108.1"> (input) {
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.109.1">case</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.110.1">65</span></span><span class="koboSpan" id="kobo.111.1">:
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.112.1">printf</span></span><span class="koboSpan" id="kobo.113.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.114.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.115.1">Input is 'A'\n"</span></span><span class="koboSpan" id="kobo.116.1">);
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.117.1">break</span></span><span class="koboSpan" id="kobo.118.1">;
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.119.1">case</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.120.1">66</span></span><span class="koboSpan" id="kobo.121.1">:
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.122.1">printf</span></span><span class="koboSpan" id="kobo.123.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.124.1">"Input is 'B'\n"</span></span><span class="koboSpan" id="kobo.125.1">);
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.126.1">break</span></span><span class="koboSpan" id="kobo.127.1">;
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.128.1">default</span></span><span class="koboSpan" id="kobo.129.1">:
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.130.1">printf</span></span><span class="koboSpan" id="kobo.131.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.132.1">"Unknown input"</span></span><span class="koboSpan" id="kobo.133.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.134.1">In an </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">if</span></code><span class="koboSpan" id="kobo.136.1"> statement, types can be converted to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">bool</span></code><span class="koboSpan" id="kobo.138.1"> type. </span><span class="koboSpan" id="kobo.138.2">For example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.139.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.140.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.141.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.142.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.143.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.144.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.145.1">{
</span><span class="hljs-type"><span class="koboSpan" id="kobo.146.1">    int</span></span><span class="koboSpan" id="kobo.147.1"> int_value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.148.1">10</span></span><span class="koboSpan" id="kobo.149.1">;
</span><span class="hljs-type"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.150.1">// int implicitly converts to bool</span></span>
<span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">if</span></span><span class="koboSpan" id="kobo.152.1"> (int_value) {
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.153.1">printf</span></span><span class="koboSpan" id="kobo.154.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.155.1">"true\n"</span></span><span class="koboSpan" id="kobo.156.1">);
</span><span class="hljs-type"> </span><span class="koboSpan" id="kobo.157.1">}
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.158.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.159.1">0</span></span><span class="koboSpan" id="kobo.160.1">;
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.161.1">There are different </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.162.1">types of implicit conversion that are handled by a compiler, and some of the most important are:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.163.1">Numeric promotions and conversions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.164.1">Array to pointer conversion</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.165.1">Function to pointer conversion</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.166.1">Next, we will discuss the above implicit conversions with examples.</span></p>
<h2 class="heading-2" id="_idParaDest-136"><span class="koboSpan" id="kobo.167.1">Numeric promotions and conversions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.168.1">Arithmetic types can be promoted or converted to other arithmetic types. </span><span class="koboSpan" id="kobo.168.2">Type promotion will not </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.169.1">change the value or lose precision. </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">std::uint8_t</span></code><span class="koboSpan" id="kobo.171.1"> can be promoted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">int</span></code><span class="koboSpan" id="kobo.173.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">float</span></code><span class="koboSpan" id="kobo.175.1"> can be promoted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">double</span></code><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">If a type that is being converted can fit entirely to the destination type, without loss of precision, it is being promoted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.178.1">Arithmetic operators do not accept types smaller than </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">int</span></code><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">Arithmetic types can be promoted when passed as operands to arithmetic operators. </span><span class="koboSpan" id="kobo.180.3">There are specific rules for promotions of integral and floating-point types based on their type:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.181.1">Boolean promotion: </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">bool</span></code><span class="koboSpan" id="kobo.183.1"> is promoted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">int</span></code><span class="koboSpan" id="kobo.185.1"> with value </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">0</span></code><span class="koboSpan" id="kobo.187.1"> if set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">false</span></code><span class="koboSpan" id="kobo.189.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">1</span></code><span class="koboSpan" id="kobo.191.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">true</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.193.1">Other integral types, including bitfields, are converted to the smallest type from the following list that can represent all the values of the converted type:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">int</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">unsigned int</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">long</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">unsigned long</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">long long</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">unsigned long long</span></code></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.200.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">float</span></code><span class="koboSpan" id="kobo.202.1"> can be promoted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">double</span></code><span class="koboSpan" id="kobo.204.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.205.1">To better understand integer promotion rules, we will go over the next example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.206.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.207.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.208.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.209.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.210.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.211.1">&lt;type_traits&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.212.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.213.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.214.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.215.1">{
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.216.1">uint8_t</span></span><span class="koboSpan" id="kobo.217.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.218.1">1</span></span><span class="koboSpan" id="kobo.219.1">;
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.220.1">uint16_t</span></span><span class="koboSpan" id="kobo.221.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.222.1">42</span></span><span class="koboSpan" id="kobo.223.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">auto</span></span><span class="koboSpan" id="kobo.225.1"> res1 = a + b;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.226.1">static_assert</span></span><span class="koboSpan" id="kobo.227.1">(std::is_same_v&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.228.1">int</span></span><span class="koboSpan" id="kobo.229.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.230.1">decltype</span></span><span class="koboSpan" id="kobo.231.1">(res1)&gt;);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.232.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.233.1">0</span></span><span class="koboSpan" id="kobo.234.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.235.1">In the above example, we added </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">uint8_t</span></code><span class="koboSpan" id="kobo.237.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">uint16_t</span></code><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">According to the promotion rules, both types </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.240.1">will be promoted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">int</span></code><span class="koboSpan" id="kobo.242.1">, as they can be fully represented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">int</span></code><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">The result of the adding is stored in the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">res1</span></code><span class="koboSpan" id="kobo.246.1">, which is declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">auto</span></code><span class="koboSpan" id="kobo.248.1">, meaning that the compiler will deduce its type. </span><span class="koboSpan" id="kobo.248.2">We expect it to be an </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">int</span></code><span class="koboSpan" id="kobo.250.1"> and we verify that using </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">static_assert</span></code><span class="koboSpan" id="kobo.252.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">std::is_same_v</span></code><span class="koboSpan" id="kobo.254.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.255.1">In this example, both types were promoted to the same type. </span><span class="koboSpan" id="kobo.255.2">If we had different types after promotion, then they would be converted to a common type under the rules of </span><strong class="keyWord"><span class="koboSpan" id="kobo.256.1">usual arithmetic conversion</span></strong><span class="koboSpan" id="kobo.257.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.258.1">The goal of </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.259.1">the usual arithmetic conversion is to yield types to a common type, which is also the type of the result. </span><span class="koboSpan" id="kobo.259.2">There are a couple of rules to usual arithmetic conversion:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.260.1">If both types are signed or unsigned integers, then the common type is the type of greater integer conversion rank. </span><span class="koboSpan" id="kobo.260.2">The ranks are listed below in decreasing order (the ranks of unsigned integers correspond to those of matching signed):</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">long long</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">long</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">int</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">short</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">signed char</span></code></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.266.1">If one of the types is a signed integer and the other one is unsigned then the following rules apply:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.267.1">If the integer conversion rank of the unsigned type is greater than or equal to the signed type, then the common type is that of the unsigned type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.268.1">Otherwise, if the signed type can represent all the values of the unsigned type, the common type is that of the signed type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.269.1">Otherwise, the common type is an unsigned integer of the type of the signed integer.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.270.1">If one of the types is a floating type and the other is an integer, the integer is converted to that floating type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.271.1">If both </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.272.1">types are the floating type but of different floating-point conversion ranks, the type with the lower conversion rank is converted to the other one. </span><span class="koboSpan" id="kobo.272.2">The floating-point conversion rank is listed below in decreasing order:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">long double</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">double</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">float</span></code></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.276.1">Let’s go through the following example to better understand the rules of usual arithmetic conversion:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.277.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.278.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.279.1">&lt;type_traits&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.280.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.281.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.282.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.283.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.284.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.285.1">bitfield</span></span><span class="koboSpan" id="kobo.286.1">{
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.287.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.288.1">long</span></span><span class="koboSpan" id="kobo.289.1"> a:</span><span class="hljs-number"><span class="koboSpan" id="kobo.290.1">31</span></span><span class="koboSpan" id="kobo.291.1">;
    };
    bitfield b {</span><span class="hljs-number"><span class="koboSpan" id="kobo.292.1">4</span></span><span class="koboSpan" id="kobo.293.1">};
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.294.1">int</span></span><span class="koboSpan" id="kobo.295.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.296.1">1</span></span><span class="koboSpan" id="kobo.297.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.298.1">auto</span></span><span class="koboSpan" id="kobo.299.1"> res1 = b.a + c;  
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.300.1">static_assert</span></span><span class="koboSpan" id="kobo.301.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.302.1">sizeof</span></span><span class="koboSpan" id="kobo.303.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.304.1">int</span></span><span class="koboSpan" id="kobo.305.1">) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.306.1">4</span></span><span class="koboSpan" id="kobo.307.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.308.1">static_assert</span></span><span class="koboSpan" id="kobo.309.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.310.1">sizeof</span></span><span class="koboSpan" id="kobo.311.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.312.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.313.1">long</span></span><span class="koboSpan" id="kobo.314.1">) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.315.1">8</span></span><span class="koboSpan" id="kobo.316.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.317.1">static_assert</span></span><span class="koboSpan" id="kobo.318.1">(std::is_same_v&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.319.1">int</span></span><span class="koboSpan" id="kobo.320.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.321.1">decltype</span></span><span class="koboSpan" id="kobo.322.1">(res1)&gt;);
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.323.1">long</span></span><span class="koboSpan" id="kobo.324.1"> e = </span><span class="hljs-number"><span class="koboSpan" id="kobo.325.1">5</span></span><span class="koboSpan" id="kobo.326.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.327.1">auto</span></span><span class="koboSpan" id="kobo.328.1"> res2 = e - b.a;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.329.1">static_assert</span></span><span class="koboSpan" id="kobo.330.1">(std::is_same_v&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.331.1">long</span></span><span class="koboSpan" id="kobo.332.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.333.1">decltype</span></span><span class="koboSpan" id="kobo.334.1">(res2)&gt;);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.335.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.336.1">0</span></span><span class="koboSpan" id="kobo.337.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.338.1">In the above example, we have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">bitfield</span></code><span class="koboSpan" id="kobo.340.1"> of 31 bits with an underlying type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">long long</span></code><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">We first add </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">b.a</span></code><span class="koboSpan" id="kobo.344.1"> and variable c of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">int</span></code><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">If we are on a platform where the size of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">int</span></code><span class="koboSpan" id="kobo.348.1"> is 4 bytes, the bitfield will be promoted to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">int</span></code><span class="koboSpan" id="kobo.350.1">, even though the underlying type </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">long long</span></code><span class="koboSpan" id="kobo.352.1"> has a size of 8 bytes. </span><span class="koboSpan" id="kobo.352.2">The promoted bitfield will be added to int </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">c</span></code><span class="koboSpan" id="kobo.354.1">, so the result of this operation will also be int, which we verify by checking the type of res1 using </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">std::is_same_v</span></code><span class="koboSpan" id="kobo.356.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.357.1">In the second part of the example, we subtract the bitfield from </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">long</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.359.1">e</span></code><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">In this case, the bitfield is </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.361.1">first promoted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">int</span></code><span class="koboSpan" id="kobo.363.1">; then, according to the rules of usual arithmetic conversion, it is converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">long</span></code><span class="koboSpan" id="kobo.365.1">, meaning that the resulting type will also be </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">long</span></code><span class="koboSpan" id="kobo.367.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.368.1">You can run the above example from the book’s GitHub repo. </span><span class="koboSpan" id="kobo.368.2">It is placed under </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">Chapter09/type_safety</span></code><span class="koboSpan" id="kobo.370.1"> and you can build and run it using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.371.1">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_usual_arithmetic_conversion.cpp"
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.372.1">The fact that the program builds successfully is enough to confirm the usual arithmetic conversion results, as we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">static_assert</span></code><span class="koboSpan" id="kobo.374.1"> to verify it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.375.1">Now, let us take a look at an example whose result may be surprising:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.376.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.377.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.378.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.379.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.380.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.381.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.382.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.383.1">int</span></span><span class="koboSpan" id="kobo.384.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.385.1">-4</span></span><span class="koboSpan" id="kobo.386.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.387.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.388.1">int</span></span><span class="koboSpan" id="kobo.389.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.390.1">3</span></span><span class="koboSpan" id="kobo.391.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.392.1">if</span></span><span class="koboSpan" id="kobo.393.1">(a + b &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.394.1">0</span></span><span class="koboSpan" id="kobo.395.1">) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.396.1">printf</span></span><span class="koboSpan" id="kobo.397.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.398.1">"%d + % u is greater than 0\r\n"</span></span><span class="koboSpan" id="kobo.399.1">, a, b);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.401.1">0</span></span><span class="koboSpan" id="kobo.402.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.403.1">If you run this example, the expression within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">if</span></code><span class="koboSpan" id="kobo.405.1"> clause will evaluate to true. </span><span class="koboSpan" id="kobo.405.2">As per the rules of usual arithmetic conversion, the signed </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">int</span></code><span class="koboSpan" id="kobo.407.1"> a will be converted to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">unsigned int</span></code><span class="koboSpan" id="kobo.409.1">, meaning that the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">a + b</span></code><span class="koboSpan" id="kobo.411.1"> will indeed be greater than </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">0</span></code><span class="koboSpan" id="kobo.413.1">. </span><span class="koboSpan" id="kobo.413.2">Mixing unsigned and signed types in arithmetic expressions can lead to undesired behavior and potential bugs due to implicit conversions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.414.1">We can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">–Wconversion</span></code><span class="koboSpan" id="kobo.416.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">-Wsign-conversion</span></code><span class="koboSpan" id="kobo.418.1"> compiler flags with GCC to make it raise a warning when implicit conversion may change a value and sign. </span><span class="koboSpan" id="kobo.418.2">Still, mixing signed and unsigned types in arithmetic expressions should be avoided as it can result in wrong results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.419.1">Next, we will discuss array-to-pointer conversion and its implications.</span></p>
<h2 class="heading-2" id="_idParaDest-137"><span class="koboSpan" id="kobo.420.1">Array-to-pointer conversion</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.421.1">An array can be implicitly converted to a pointer. </span><span class="koboSpan" id="kobo.421.2">The resulting pointer points to the first element </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.422.1">of the array. </span><span class="koboSpan" id="kobo.422.2">Many C and C++ functions that work on </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.423.1">arrays of data are designed with pointer and size parameters. </span><span class="koboSpan" id="kobo.423.2">These interfaces are based on contract design. </span><span class="koboSpan" id="kobo.423.3">The contract is the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.424.1">A caller will pass a pointer that points to the first element of the array</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.425.1">A caller will pass the size of the array</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.426.1">This is a simple contract, but there is no way to enforce it. </span><span class="koboSpan" id="kobo.426.2">Let’s take a look at the following simple example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.427.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.428.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.429.1">&lt;cstdio&gt;</span></span><span class="hljs-meta"> </span>
<span class="hljs-type"><span class="koboSpan" id="kobo.430.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.431.1">print_ints</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.432.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.433.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.434.1"> * arr, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.435.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.436.1"> len)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.437.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.438.1">for</span></span><span class="koboSpan" id="kobo.439.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.440.1">size_t</span></span><span class="koboSpan" id="kobo.441.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.442.1">0</span></span><span class="koboSpan" id="kobo.443.1">; i &lt; len; i++) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.444.1">printf</span></span><span class="koboSpan" id="kobo.445.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.446.1">"%d\r\n"</span></span><span class="koboSpan" id="kobo.447.1">, arr[i]);
    }
}
 </span><span class="hljs-type"><span class="koboSpan" id="kobo.448.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.449.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.450.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.451.1">{ 
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.452.1">int</span></span><span class="koboSpan" id="kobo.453.1"> array_ints[</span><span class="hljs-number"><span class="koboSpan" id="kobo.454.1">3</span></span><span class="koboSpan" id="kobo.455.1">] = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.456.1">1</span></span><span class="koboSpan" id="kobo.457.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.458.1">2</span></span><span class="koboSpan" id="kobo.459.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.460.1">3</span></span><span class="koboSpan" id="kobo.461.1">};
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.462.1">print_ints</span></span><span class="koboSpan" id="kobo.463.1">(array_ints, </span><span class="hljs-number"><span class="koboSpan" id="kobo.464.1">3</span></span><span class="koboSpan" id="kobo.465.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.466.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.467.1">0</span></span><span class="koboSpan" id="kobo.468.1">; 
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.469.1">In the above </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.470.1">example, we have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">print_ints</span></code><span class="koboSpan" id="kobo.472.1"> function with </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">arr</span></code><span class="koboSpan" id="kobo.474.1">, a pointer to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">int</span></code><span class="koboSpan" id="kobo.476.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">len</span></code><span class="koboSpan" id="kobo.478.1">, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">std::size_t</span></code><span class="koboSpan" id="kobo.480.1"> parameter. </span><span class="koboSpan" id="kobo.480.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">main</span></code><span class="koboSpan" id="kobo.482.1"> function, we call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">print_ints</span></code><span class="koboSpan" id="kobo.484.1"> function by passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">array_ints</span></code><span class="koboSpan" id="kobo.486.1">, an array of 3 integers, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">3</span></code><span class="koboSpan" id="kobo.488.1"> as arguments. </span><span class="koboSpan" id="kobo.488.2">The array </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">array_ints</span></code><span class="koboSpan" id="kobo.490.1"> will be implicitly converted to a pointer that points to its first element. </span><span class="koboSpan" id="kobo.490.2">There are a couple of potential issues with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">print_ints</span></code><span class="koboSpan" id="kobo.492.1"> function:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.493.1">It expects that the pointer we pass to it is valid. </span><span class="koboSpan" id="kobo.493.2">It doesn’t verify that.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.494.1">It expects that the argument it receives for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">len</span></code><span class="koboSpan" id="kobo.496.1"> parameter is the actual size of the array it operates on. </span><span class="koboSpan" id="kobo.496.2">A caller could pass a size that may cause out-of-bounds access.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.497.1">As it operates directly on a pointer, there is always a chance of out-of-bound access if pointer arithmetic is used in the function.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.498.1">To eliminate these potential issues, in C++, instead of using a pointer to work on an array of data, we can use the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">std::span</span></code><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">It is a wrapper for a contiguous sequence of objects, with the </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.501.1">first element of the sequence </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.502.1">at position zero. </span><span class="koboSpan" id="kobo.502.2">It can be constructed from a C-style array, it has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">size</span></code><span class="koboSpan" id="kobo.504.1"> method, and we can use range-based </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">for</span></code><span class="koboSpan" id="kobo.506.1"> loops on it. </span><span class="koboSpan" id="kobo.506.2">Let’s write the previous example using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">std::span</span></code><span class="koboSpan" id="kobo.508.1"> instead of the pointer:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.509.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.510.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.511.1">&lt;cstdio&gt;</span></span><span class="hljs-meta"> </span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.512.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.513.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.514.1">&lt;span&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.515.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.516.1">print_ints</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.517.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.518.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.519.1"> std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.520.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.521.1">&gt; arr)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.522.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.523.1">for</span></span><span class="koboSpan" id="kobo.524.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.525.1">int</span></span><span class="koboSpan" id="kobo.526.1"> elem: arr) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.527.1">printf</span></span><span class="koboSpan" id="kobo.528.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.529.1">"%d\r\n"</span></span><span class="koboSpan" id="kobo.530.1">, elem);
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.531.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.532.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.533.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.534.1">{ 
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.535.1">int</span></span><span class="koboSpan" id="kobo.536.1"> arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.537.1">3</span></span><span class="koboSpan" id="kobo.538.1">] = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.539.1">1</span></span><span class="koboSpan" id="kobo.540.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.541.1">2</span></span><span class="koboSpan" id="kobo.542.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.543.1">3</span></span><span class="koboSpan" id="kobo.544.1">};
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.545.1">print_ints</span></span><span class="koboSpan" id="kobo.546.1">(arr);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.547.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.548.1">0</span></span><span class="koboSpan" id="kobo.549.1">; 
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.550.1">In the above example, we can see that the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">print_ints</span></code><span class="koboSpan" id="kobo.552.1"> looks much simpler now. </span><span class="koboSpan" id="kobo.552.2">It accepts </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">std::span</span></code><span class="koboSpan" id="kobo.554.1"> of integers and it uses a range-based for loop to iterate over the elements. </span><span class="koboSpan" id="kobo.554.2">On the call site, we now just pass </span><code class="inlineCode"><span class="koboSpan" id="kobo.555.1">arr</span></code><span class="koboSpan" id="kobo.556.1">, an array of 3 integers. </span><span class="koboSpan" id="kobo.556.2">It is implicitly converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.557.1">std::span</span></code><span class="koboSpan" id="kobo.558.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.559.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">std::span</span></code><span class="koboSpan" id="kobo.561.1"> also has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">size</span></code><span class="koboSpan" id="kobo.563.1"> method, operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">[]</span></code><span class="koboSpan" id="kobo.565.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">begin</span></code><span class="koboSpan" id="kobo.567.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">end</span></code><span class="koboSpan" id="kobo.569.1"> iterators, meaning we can use it in standard library algorithms. </span><span class="koboSpan" id="kobo.569.2">We can also construct a subspan from </span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">span</span></code><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">It can be constructed from C-style arrays, but also from containers such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.572.1">std::array</span></code><span class="koboSpan" id="kobo.573.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">std::vector</span></code><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">It is a great solution to potential issues of interfaces that usually rely on pointer and size parameters.</span></p>
<h2 class="heading-2" id="_idParaDest-138"><span class="koboSpan" id="kobo.576.1">Function-to-pointer conversion</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.577.1">A function </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.578.1">can be implicitly converted to a pointer to that </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.579.1">function. </span><span class="koboSpan" id="kobo.579.2">The following example demonstrates this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.580.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.581.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.582.1">&lt;cstdio&gt;</span></span><span class="hljs-meta"> </span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.583.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.584.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.585.1">&lt;type_traits&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.586.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.587.1">print_hello</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.588.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.589.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.590.1">printf</span></span><span class="koboSpan" id="kobo.591.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.592.1">"Hello!\r\n"</span></span><span class="koboSpan" id="kobo.593.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.594.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.595.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.596.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.597.1">{ 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.598.1">void</span></span><span class="koboSpan" id="kobo.599.1">(*fptr)() = print_hello;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.600.1">fptr</span></span><span class="koboSpan" id="kobo.601.1">();
    fptr = &amp;print_hello;
    (*fptr)();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.602.1">static_assert</span></span><span class="koboSpan" id="kobo.603.1">(std::is_same_v&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.604.1">decltype</span></span><span class="koboSpan" id="kobo.605.1">(fptr), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.606.1">void</span></span><span class="koboSpan" id="kobo.607.1">(*)()&gt;);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.608.1">static_assert</span></span><span class="koboSpan" id="kobo.609.1">(std::is_same_v&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.610.1">decltype</span></span><span class="koboSpan" id="kobo.611.1">(print_hello), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.612.1">void</span></span><span class="koboSpan" id="kobo.613.1">()&gt;);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.614.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.615.1">0</span></span><span class="koboSpan" id="kobo.616.1">; 
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.617.1">In the example above, we assign the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.618.1">print_hello</span></code><span class="koboSpan" id="kobo.619.1"> to a function pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.620.1">fptr</span></code><span class="koboSpan" id="kobo.621.1">. </span><span class="koboSpan" id="kobo.621.2">In C++, we don’t </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.622.1">need to use the address-off </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.623.1">operator with a function name to assign it to a function pointer. </span><span class="koboSpan" id="kobo.623.2">Also, we don’t need to dereference a function pointer when making a call to a function through it. </span><span class="koboSpan" id="kobo.623.3">Still, </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">print_hello</span></code><span class="koboSpan" id="kobo.625.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">fptr</span></code><span class="koboSpan" id="kobo.627.1"> are two different types and we confirm this using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">static_assert</span></code><span class="koboSpan" id="kobo.629.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">is_same</span></code><span class="koboSpan" id="kobo.631.1"> type traits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.632.1">Implicit conversions in C++ make writing the code easier. </span><span class="koboSpan" id="kobo.632.2">They can sometimes lead to undesired behavior and potential issues with our program. </span><span class="koboSpan" id="kobo.632.3">To mitigate these concerns, we can explicitly convert types when needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.633.1">Next, we will cover explicit conversion.</span></p>
<h1 class="heading-1" id="_idParaDest-139"><span class="koboSpan" id="kobo.634.1">Explicit conversion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.635.1">C++ supports </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.636.1">C-style cast explicit conversion, but also functional-style cast and the following casting operators:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">const_cast</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">static_cast</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">dynamic_cast</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">reinterpret_cast</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.641.1">We will go through casting operators, starting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">const_cast</span></code><span class="koboSpan" id="kobo.643.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-140"><span class="koboSpan" id="kobo.644.1">const_cast</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">const_cast</span></code><span class="koboSpan" id="kobo.646.1"> is used </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.647.1">to cast away constness to work with non-const-correct </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.648.1">functions. </span><span class="koboSpan" id="kobo.648.2">We will go through the following example to better understand it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.649.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.650.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.651.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.652.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.653.1">print_num</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.654.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.655.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.656.1"> &amp; num)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.657.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.658.1">printf</span></span><span class="koboSpan" id="kobo.659.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.660.1">"num is %d\r\n"</span></span><span class="koboSpan" id="kobo.661.1">, num);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.662.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.663.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.664.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.665.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.666.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.667.1">int</span></span><span class="koboSpan" id="kobo.668.1"> num = </span><span class="hljs-number"><span class="koboSpan" id="kobo.669.1">42</span></span><span class="koboSpan" id="kobo.670.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.671.1">print_num</span></span><span class="koboSpan" id="kobo.672.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.673.1">const_cast</span></span><span class="koboSpan" id="kobo.674.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.675.1">int</span></span><span class="koboSpan" id="kobo.676.1">&amp;&gt;(num));
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.677.1">int</span></span><span class="koboSpan" id="kobo.678.1"> &amp; num_ref = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.679.1">const_cast</span></span><span class="koboSpan" id="kobo.680.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.681.1">int</span></span><span class="koboSpan" id="kobo.682.1">&amp;&gt;(num);
    num_ref = </span><span class="hljs-number"><span class="koboSpan" id="kobo.683.1">16</span></span><span class="koboSpan" id="kobo.684.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.685.1">return</span></span><span class="koboSpan" id="kobo.686.1"> num;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.687.1">In the above example, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.688.1">const_cast</span></code><span class="koboSpan" id="kobo.689.1"> in two different scenarios. </span><span class="koboSpan" id="kobo.689.2">We first used it to cast away constness from </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">const int num</span></code><span class="koboSpan" id="kobo.691.1"> to be able to pass it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">print_num</span></code><span class="koboSpan" id="kobo.693.1"> function. </span><span class="koboSpan" id="kobo.693.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">print_num</span></code><span class="koboSpan" id="kobo.695.1"> function has a single parameter – a non-const reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.696.1">int</span></code><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">As we know that this function is not trying to modify the object that the reference is bound to, we decided to cast away constness so we can pass a reference to a const int to it without the compiler generating an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.698.1">Then, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">const_cast</span></code><span class="koboSpan" id="kobo.700.1"> to cast away constness from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.701.1">num</span></code><span class="koboSpan" id="kobo.702.1"> to be able to assign it to non-const reference </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">num_ref</span></code><span class="koboSpan" id="kobo.704.1">. </span><span class="koboSpan" id="kobo.704.2">If you run this example in Compiler Explorer, you will see the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.705.1">Program returned: 42
num is 42
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.706.1">The program returned </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">42</span></code><span class="koboSpan" id="kobo.708.1">, that is, the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">num</span></code><span class="koboSpan" id="kobo.710.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">42</span></code><span class="koboSpan" id="kobo.712.1"> even though we tried to set it to </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">16</span></code><span class="koboSpan" id="kobo.714.1"> through </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">num_ref</span></code><span class="koboSpan" id="kobo.716.1">. </span><span class="koboSpan" id="kobo.716.2">This is due to the fact that modifying the const variable through a non-const reference or a pointer is undefined behavior.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">const_cast</span></code><span class="koboSpan" id="kobo.718.1"> is used mostly to interface with non-const correct functions. </span><span class="koboSpan" id="kobo.718.2">Still, this is dangerous and should be avoided as we can’t guarantee that the function we are passing a const-cast-away pointer or a reference will not try to modify the object that the pointer is pointing to or the reference it is bound to. </span><span class="koboSpan" id="kobo.718.3">Next, we will cover </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">static_cast</span></code><span class="koboSpan" id="kobo.720.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-141"><span class="koboSpan" id="kobo.721.1">static_cast</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.722.1">The most </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.723.1">used cast operator in C++ is </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">static_cast</span></code><span class="koboSpan" id="kobo.725.1">, and it is used in the following scenarios:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.726.1">To upcast </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.727.1">and downcast a pointer of base class to derived class and vice versa</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.728.1">To discard a value expression</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.729.1">To convert between types with well-known conversion paths such as int to float, </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">enum</span></code><span class="koboSpan" id="kobo.731.1"> to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">int</span></code><span class="koboSpan" id="kobo.733.1">, int to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">enum</span></code><span class="koboSpan" id="kobo.735.1">, and similar</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.736.1">We will go through several usages of </span><code class="inlineCode"><span class="koboSpan" id="kobo.737.1">static_cast</span></code><span class="koboSpan" id="kobo.738.1"> using the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.739.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.740.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.741.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.742.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.743.1">Base</span></span><span class="koboSpan" id="kobo.744.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.745.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.746.1">hi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.747.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.748.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.749.1">printf</span></span><span class="koboSpan" id="kobo.750.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.751.1">"Hi from Base\r\n"</span></span><span class="koboSpan" id="kobo.752.1">);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.753.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.754.1">Derived</span></span><span class="koboSpan" id="kobo.755.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.756.1">public</span></span><span class="koboSpan" id="kobo.757.1"> Base {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.758.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.759.1">hi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.760.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.761.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.762.1">printf</span></span><span class="koboSpan" id="kobo.763.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.764.1">"Hi from Derived\r\n"</span></span><span class="koboSpan" id="kobo.765.1">);
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.766.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.767.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.768.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.769.1">{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.770.1">// unsigned to signed int </span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.771.1">int</span></span><span class="koboSpan" id="kobo.772.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.773.1">-4</span></span><span class="koboSpan" id="kobo.774.1">; 
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.775.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.776.1">int</span></span><span class="koboSpan" id="kobo.777.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.778.1">3</span></span><span class="koboSpan" id="kobo.779.1">; 
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">if</span></span><span class="koboSpan" id="kobo.781.1">(a + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.782.1">static_cast</span></span><span class="koboSpan" id="kobo.783.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.784.1">int</span></span><span class="koboSpan" id="kobo.785.1">&gt;(b) &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.786.1">0</span></span><span class="koboSpan" id="kobo.787.1">) { 
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.788.1">printf</span></span><span class="koboSpan" id="kobo.789.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.790.1">"%d + %d is greater than 0\r\n"</span></span><span class="koboSpan" id="kobo.791.1">, a, b); 
    } 
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.792.1">else</span></span><span class="koboSpan" id="kobo.793.1"> {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.794.1">printf</span></span><span class="koboSpan" id="kobo.795.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.796.1">"%d + %d is not greater than 0\r\n"</span></span><span class="koboSpan" id="kobo.797.1">, a,b); 
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.798.1">// discard an expression</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.799.1">int</span></span><span class="koboSpan" id="kobo.800.1"> c;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.801.1">static_cast</span></span><span class="koboSpan" id="kobo.802.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.803.1">void</span></span><span class="koboSpan" id="kobo.804.1">&gt;(c);
    Derived derived;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.805.1">// implicit upcast</span></span><span class="koboSpan" id="kobo.806.1">
    Base * base_ptr = &amp;derived;
    base_ptr-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.807.1">hi</span></span><span class="koboSpan" id="kobo.808.1">();
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.809.1">// downcast</span></span><span class="koboSpan" id="kobo.810.1">
    Derived *derived_p = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.811.1">static_cast</span></span><span class="koboSpan" id="kobo.812.1">&lt;Derived*&gt;(base_ptr);
    derived_p-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.813.1">hi</span></span><span class="koboSpan" id="kobo.814.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.815.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.816.1">0</span></span><span class="koboSpan" id="kobo.817.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.818.1">If we run the above example, we will get the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.819.1">-4 + 3 is not greater than 0
Hi from Base
Hi from Derived
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.820.1">In the above example, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.821.1">static_cast</span></code><span class="koboSpan" id="kobo.822.1"> to convert an </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">unsigned int</span></code><span class="koboSpan" id="kobo.824.1"> to a signed </span><code class="inlineCode"><span class="koboSpan" id="kobo.825.1">int</span></code><span class="koboSpan" id="kobo.826.1">, which helps </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.827.1">mitigate the issue of comparing integers with mixed signs </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.828.1">introduced by implicit conversion. </span><span class="koboSpan" id="kobo.828.2">Still, we would need to make sure that the conversion is safe as </span><code class="inlineCode"><span class="koboSpan" id="kobo.829.1">static_cast</span></code><span class="koboSpan" id="kobo.830.1"> doesn’t do any runtime checks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.831.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.832.1">static_cast</span></code><span class="koboSpan" id="kobo.833.1"> to cast the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.834.1">c</span></code><span class="koboSpan" id="kobo.835.1"> to void is a technique used to suppress compiler warnings about unused variables. </span><span class="koboSpan" id="kobo.835.2">It indicates that we are aware of the variable, but we intentionally do not use it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.836.1">In the other part of the above example, we can see that an address to an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.837.1">Derived</span></code><span class="koboSpan" id="kobo.838.1"> class can be implicitly converted to a pointer of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.839.1">Base</span></code><span class="koboSpan" id="kobo.840.1"> class. </span><span class="koboSpan" id="kobo.840.2">If we call a function </span><code class="inlineCode"><span class="koboSpan" id="kobo.841.1">hi</span></code><span class="koboSpan" id="kobo.842.1"> on the pointer of the Base class which is pointing to an object of the Derived class, we will actually make a call to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">hi</span></code><span class="koboSpan" id="kobo.844.1"> function defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.845.1">Base</span></code><span class="koboSpan" id="kobo.846.1"> class. </span><span class="koboSpan" id="kobo.846.2">Then we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.847.1">static_cast</span></code><span class="koboSpan" id="kobo.848.1"> to downcast </span><code class="inlineCode"><span class="koboSpan" id="kobo.849.1">Base</span></code><span class="koboSpan" id="kobo.850.1"> pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.851.1">Derived</span></code><span class="koboSpan" id="kobo.852.1"> pointer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.853.1">Down-casting using </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">static_cast</span></code><span class="koboSpan" id="kobo.855.1"> can be dangerous as </span><code class="inlineCode"><span class="koboSpan" id="kobo.856.1">static_cast</span></code><span class="koboSpan" id="kobo.857.1"> doesn’t do any runtime checks to make sure that the pointer is actually pointing to the converting type. </span><span class="koboSpan" id="kobo.857.2">An object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.858.1">Derived</span></code><span class="koboSpan" id="kobo.859.1"> class is also an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.860.1">Base</span></code><span class="koboSpan" id="kobo.861.1"> class, but the reverse is not true – </span><code class="inlineCode"><span class="koboSpan" id="kobo.862.1">Base</span></code><span class="koboSpan" id="kobo.863.1"> is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">Derived</span></code><span class="koboSpan" id="kobo.865.1">. </span><span class="koboSpan" id="kobo.865.2">The following example demonstrates why this is dangerous:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.866.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.867.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.868.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.869.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.870.1">Base</span></span><span class="koboSpan" id="kobo.871.1"> {
</span><span class="hljs-type"><span class="koboSpan" id="kobo.872.1">    void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.873.1">hi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.874.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.875.1">{
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.876.1">printf</span></span><span class="koboSpan" id="kobo.877.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.878.1">"Hi from Base\r\n"</span></span><span class="koboSpan" id="kobo.879.1">);
</span><span class="hljs-type"> </span><span class="koboSpan" id="kobo.880.1">}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.881.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.882.1">Derived</span></span><span class="koboSpan" id="kobo.883.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.884.1">public</span></span><span class="koboSpan" id="kobo.885.1"> Base {
</span><span class="hljs-type"><span class="koboSpan" id="kobo.886.1">    void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.887.1">hi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.888.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.889.1">{
</span><span class="hljs-type"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.890.1">printf</span></span><span class="koboSpan" id="kobo.891.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.892.1">"Hi from Derived, x = %d\r\n"</span></span><span class="koboSpan" id="kobo.893.1">, x);
</span><span class="hljs-type"> </span><span class="koboSpan" id="kobo.894.1">}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.895.1">    int</span></span><span class="koboSpan" id="kobo.896.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.897.1">42</span></span><span class="koboSpan" id="kobo.898.1">;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.899.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.900.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.901.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.902.1">{
</span><span class="hljs-type"> </span><span class="koboSpan" id="kobo.903.1">Base base;
</span><span class="hljs-type"> </span><span class="koboSpan" id="kobo.904.1">Derived *derived_ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.905.1">static_cast</span></span><span class="koboSpan" id="kobo.906.1">&lt;Derived*&gt;(&amp;base);
</span><span class="hljs-type"> </span><span class="koboSpan" id="kobo.907.1">derived_ptr-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.908.1">hi</span></span><span class="koboSpan" id="kobo.909.1">();
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.910.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.911.1">0</span></span><span class="koboSpan" id="kobo.912.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.913.1">In this code, we are </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.914.1">trying to access member </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">x</span></code><span class="koboSpan" id="kobo.916.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">Derived</span></code><span class="koboSpan" id="kobo.918.1"> class on an object of the </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.919.1">base class. </span><span class="koboSpan" id="kobo.919.2">As we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">static_cast</span></code><span class="koboSpan" id="kobo.921.1">, the compiler will not complain and this will result in undefined behavior, as the base class doesn’t have member </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">x</span></code><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">One of the possible outputs of this program is shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.924.1">Hi from Derived, x = 1574921984
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.925.1">To avoid this problem, we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.927.1">, which we will cover next.</span></p>
<h2 class="heading-2" id="_idParaDest-142"><span class="koboSpan" id="kobo.928.1">dynamic_cast</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.929.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.930.1"> performs runtime </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.931.1">checks of types and sets </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.932.1">the result to </span><code class="inlineCode"><span class="koboSpan" id="kobo.933.1">nullptr</span></code><span class="koboSpan" id="kobo.934.1"> in case the </span><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">Base</span></code><span class="koboSpan" id="kobo.936.1"> pointer doesn’t actually point to an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">Derived</span></code><span class="koboSpan" id="kobo.938.1"> class. </span><span class="koboSpan" id="kobo.938.2">We will go through an example to better understand it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.939.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.941.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.942.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.943.1">Base</span></span><span class="koboSpan" id="kobo.944.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.946.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.947.1">hi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.948.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.949.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.950.1">printf</span></span><span class="koboSpan" id="kobo.951.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.952.1">"Hi from Base\r\n"</span></span><span class="koboSpan" id="kobo.953.1">);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.954.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.955.1">Derived</span></span><span class="koboSpan" id="kobo.956.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.957.1">public</span></span><span class="koboSpan" id="kobo.958.1"> Base {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.959.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.960.1">hi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.961.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.962.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.963.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.964.1">printf</span></span><span class="koboSpan" id="kobo.965.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.966.1">"Hi from Derived\r\n"</span></span><span class="koboSpan" id="kobo.967.1">);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.968.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.969.1">derived_only</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.970.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.971.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.972.1">printf</span></span><span class="koboSpan" id="kobo.973.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.974.1">"Derived only method\r\n"</span></span><span class="koboSpan" id="kobo.975.1">);
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.976.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.977.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.978.1">(Base *base)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.979.1">{
    base-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.980.1">hi</span></span><span class="koboSpan" id="kobo.981.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.982.1">if</span></span><span class="koboSpan" id="kobo.983.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.984.1">auto</span></span><span class="koboSpan" id="kobo.985.1"> ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.986.1">dynamic_cast</span></span><span class="koboSpan" id="kobo.987.1">&lt;Derived*&gt;(base); ptr ! </span><span class="koboSpan" id="kobo.987.2">= </span><span class="hljs-literal"><span class="koboSpan" id="kobo.988.1">nullptr</span></span><span class="koboSpan" id="kobo.989.1">) 
    {
        ptr-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.990.1">derived_only</span></span><span class="koboSpan" id="kobo.991.1">();
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.992.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.993.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.994.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.995.1">{
    Base base;
    Derived derived;
    Base * base_ptr = &amp;derived;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.996.1">process</span></span><span class="koboSpan" id="kobo.997.1">(&amp;base);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.998.1">process</span></span><span class="koboSpan" id="kobo.999.1">(base_ptr);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1000.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1001.1">0</span></span><span class="koboSpan" id="kobo.1002.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1003.1">In the </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.1004.1">above example, we have a function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1005.1">process</span></code><span class="koboSpan" id="kobo.1006.1"> with a pointer to Base as a </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.1007.1">parameter. </span><span class="koboSpan" id="kobo.1007.2">The function uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1008.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.1009.1"> to downcast the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1010.1">Base</span></code><span class="koboSpan" id="kobo.1011.1"> pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1012.1">Derived</span></code><span class="koboSpan" id="kobo.1013.1"> pointer. </span><span class="koboSpan" id="kobo.1013.2">In the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1014.1">if statement with initializer</span></strong><span class="koboSpan" id="kobo.1015.1">, we initialize </span><code class="inlineCode"><span class="koboSpan" id="kobo.1016.1">ptr</span></code><span class="koboSpan" id="kobo.1017.1"> with the result of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">dynamic_cast&lt;Derived*&gt;</span></code><span class="koboSpan" id="kobo.1019.1"> on a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">Base</span></code><span class="koboSpan" id="kobo.1021.1"> pointer. </span><span class="koboSpan" id="kobo.1021.2">In the condition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">if</span></code><span class="koboSpan" id="kobo.1023.1"> statement, we check if </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">ptr</span></code><span class="koboSpan" id="kobo.1025.1"> is different from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">nullptr</span></code><span class="koboSpan" id="kobo.1027.1">, and if it is we can safely use it as a pointer to an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1028.1">Derived</span></code><span class="koboSpan" id="kobo.1029.1"> class. </span><span class="koboSpan" id="kobo.1029.2">Next, we will cover </span><code class="inlineCode"><span class="koboSpan" id="kobo.1030.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1031.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-143"><span class="koboSpan" id="kobo.1032.1">reinterpret_cast</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1034.1"> is used </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.1035.1">to convert between types by </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.1036.1">reinterpreting the underlying bits. </span><span class="koboSpan" id="kobo.1036.2">It can be used in the following situations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1037.1">To convert a pointer to an integer large enough to hold all of its values.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1038.1">To convert a value of an integer to a pointer. </span><span class="koboSpan" id="kobo.1038.2">A pointer converted to an integer and back to its original type is guaranteed to have the original value and can be dereferenced safely.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1039.1">To convert pointers between different types, such as between </span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">T1</span></code><span class="koboSpan" id="kobo.1041.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1042.1">T2</span></code><span class="koboSpan" id="kobo.1043.1">. </span><span class="koboSpan" id="kobo.1043.2">The resulting pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">T2</span></code><span class="koboSpan" id="kobo.1045.1"> can be dereferenced safely only if the resulting pointer is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1046.1">char</span></code><span class="koboSpan" id="kobo.1047.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1048.1">unsigned char</span></code><span class="koboSpan" id="kobo.1049.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1050.1">std::byte</span></code><span class="koboSpan" id="kobo.1051.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">T1</span></code><span class="koboSpan" id="kobo.1053.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1054.1">To convert a function pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1055.1">F1</span></code><span class="koboSpan" id="kobo.1056.1"> to a pointer to a different function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">F2</span></code><span class="koboSpan" id="kobo.1058.1">. </span><span class="koboSpan" id="kobo.1058.2">Converting </span><code class="inlineCode"><span class="koboSpan" id="kobo.1059.1">F2</span></code><span class="koboSpan" id="kobo.1060.1"> back to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1061.1">F1</span></code><span class="koboSpan" id="kobo.1062.1"> will result in the pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1063.1">F1</span></code><span class="koboSpan" id="kobo.1064.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1065.1">To better understand </span><code class="inlineCode"><span class="koboSpan" id="kobo.1066.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1067.1">, we will go through the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1068.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1069.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1070.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1071.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1072.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1073.1">&lt;cstdint&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1074.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1075.1">fun</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1076.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1077.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1078.1">printf</span></span><span class="koboSpan" id="kobo.1079.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1080.1">"fun\r\n"</span></span><span class="koboSpan" id="kobo.1081.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1082.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1083.1">42</span></span><span class="koboSpan" id="kobo.1084.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1085.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1086.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1087.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1088.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1089.1">float</span></span><span class="koboSpan" id="kobo.1090.1"> f = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1091.1">3.14f</span></span><span class="koboSpan" id="kobo.1092.1">;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1093.1">// initialize pointer to an int with float address</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1094.1">auto</span></span><span class="koboSpan" id="kobo.1095.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1096.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1097.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1098.1">int</span></span><span class="koboSpan" id="kobo.1099.1">*&gt;(&amp;f);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1100.1">printf</span></span><span class="koboSpan" id="kobo.1101.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1102.1">"a = %d\r\n"</span></span><span class="koboSpan" id="kobo.1103.1">, *a);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1104.1">// the above is same as:</span></span><span class="koboSpan" id="kobo.1105.1">
    a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1106.1">static_cast</span></span><span class="koboSpan" id="kobo.1107.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1108.1">int</span></span><span class="koboSpan" id="kobo.1109.1">*&gt;(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1110.1">static_cast</span></span><span class="koboSpan" id="kobo.1111.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1112.1">void</span></span><span class="koboSpan" id="kobo.1113.1">*&gt;(&amp;f));
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1114.1">printf</span></span><span class="koboSpan" id="kobo.1115.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1116.1">"a = %d\r\n"</span></span><span class="koboSpan" id="kobo.1117.1">, *a);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1118.1">// casting back to float pointer</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1119.1">auto</span></span><span class="koboSpan" id="kobo.1120.1"> fptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1121.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1122.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1123.1">float</span></span><span class="koboSpan" id="kobo.1124.1">*&gt;(a);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1125.1">printf</span></span><span class="koboSpan" id="kobo.1126.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1127.1">"f = %.2f\r\n"</span></span><span class="koboSpan" id="kobo.1128.1">, *fptr);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1129.1">// converting a pointer to integer</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1130.1">auto</span></span><span class="koboSpan" id="kobo.1131.1"> int_val = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1132.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1133.1">&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1134.1">uintptr_t</span></span><span class="koboSpan" id="kobo.1135.1">&gt;(fptr);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1136.1">printf</span></span><span class="koboSpan" id="kobo.1137.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1138.1">"Address of float f is 0x%8X\r\n"</span></span><span class="koboSpan" id="kobo.1139.1">, int_val);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1140.1">auto</span></span><span class="koboSpan" id="kobo.1141.1"> fun_void_ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1142.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1143.1">&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1144.1">void</span></span><span class="koboSpan" id="kobo.1145.1">(*)()&gt;(fun);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1146.1">// undefined behavior</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1147.1">fun_void_ptr</span></span><span class="koboSpan" id="kobo.1148.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1149.1">auto</span></span><span class="koboSpan" id="kobo.1150.1"> fun_int_ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1151.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1152.1">&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1153.1">int</span></span><span class="koboSpan" id="kobo.1154.1">(*)()&gt;(fun);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1155.1">// safe call</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1156.1">printf</span></span><span class="koboSpan" id="kobo.1157.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1158.1">"fun_int_ptr returns %d\r\n"</span></span><span class="koboSpan" id="kobo.1159.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1160.1">fun_int_ptr</span></span><span class="koboSpan" id="kobo.1161.1">());
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1162.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1163.1">0</span></span><span class="koboSpan" id="kobo.1164.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1165.1">You can </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.1166.1">run the above example from the book’s GitHub repo. </span><span class="koboSpan" id="kobo.1166.2">It is placed </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.1167.1">under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1168.1">Chapter09/type_safety</span></code><span class="koboSpan" id="kobo.1169.1"> and you can build and run it using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1170.1">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_reinterpret_cast.cpp"
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1171.1">Running the example in Renode will provide the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1172.1">a = 1078523331
a = 1078523331
f = 3.14
Address of float f is 0x20003F18
fun
fun
fun_int_ptr returns 42
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1173.1">The above example demonstrates the usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1174.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1175.1">. </span><span class="koboSpan" id="kobo.1175.2">We first initialized a pointer to an int using the address of a float using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1176.1">reinterpret_cast&lt;int*&gt;(&amp;f)</span></code><span class="koboSpan" id="kobo.1177.1">. </span><span class="koboSpan" id="kobo.1177.2">This is equivalent to using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1178.1">static_cast</span></code><span class="koboSpan" id="kobo.1179.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1180.1">static_cast&lt;int*&gt;(static_cast&lt;void*&gt;(&amp;f))</span></code><span class="koboSpan" id="kobo.1181.1">. </span><span class="koboSpan" id="kobo.1181.2">We print the value of the dereference integer pointer, and it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1182.1">1078523331</span></code><span class="koboSpan" id="kobo.1183.1">. </span><span class="koboSpan" id="kobo.1183.2">This is an actual bit pattern contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1184.1">float</span></code><span class="koboSpan" id="kobo.1185.1"> variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1186.1">f</span></code><span class="koboSpan" id="kobo.1187.1">. </span><span class="koboSpan" id="kobo.1187.2">It is an IEEE-754 floating point representation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1188.1">3.14</span></code><span class="koboSpan" id="kobo.1189.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1190.1">However, dereferencing the integer pointer initialized by an address of a float is not a defined behavior according to </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.1191.1">the C++ standard. </span><span class="koboSpan" id="kobo.1191.2">This is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1192.1">type punning</span></strong><span class="koboSpan" id="kobo.1193.1"> – treating an object of one type as if it were another type. </span><span class="koboSpan" id="kobo.1193.2">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">reinterpet_cast</span></code><span class="koboSpan" id="kobo.1195.1"> for type punning is common, as it proved to yield expected results on most platforms despite the undefined behavior. </span><span class="koboSpan" id="kobo.1195.2">There are alternatives that we will discuss after going through this example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1196.1">If we cast the pointer to the integer back to a pointer to a float, it is safe to dereference the resulting pointer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1197.1">Next, we converted the pointer to float to an integer to print the address it contains. </span><span class="koboSpan" id="kobo.1197.2">We used </span><code class="inlineCode"><span class="koboSpan" id="kobo.1198.1">std::uintptr_t</span></code><span class="koboSpan" id="kobo.1199.1">, an integer type that is capable of holding a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1200.1">void</span></code><span class="koboSpan" id="kobo.1201.1">. </span><span class="koboSpan" id="kobo.1201.2">Following this, we initialized </span><code class="inlineCode"><span class="koboSpan" id="kobo.1202.1">fun_void_ptr</span></code><span class="koboSpan" id="kobo.1203.1"> – a pointer to a function that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1204.1">void</span></code><span class="koboSpan" id="kobo.1205.1"> with function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1206.1">fun</span></code><span class="koboSpan" id="kobo.1207.1">, which returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1208.1">int</span></code><span class="koboSpan" id="kobo.1209.1">. </span><span class="koboSpan" id="kobo.1209.2">We made a call on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1210.1">fun_void_ptr</span></code><span class="koboSpan" id="kobo.1211.1"> pointer, which printed the </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.1212.1">expected output, but it is still undefined. </span><span class="koboSpan" id="kobo.1212.2">Converting </span><code class="inlineCode"><span class="koboSpan" id="kobo.1213.1">fun_void_ptr</span></code><span class="koboSpan" id="kobo.1214.1"> to a pointer that matches the signature of function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1215.1">fun</span></code><span class="koboSpan" id="kobo.1216.1"> – </span><code class="inlineCode"><span class="koboSpan" id="kobo.1217.1">fun_int_ptr</span></code><span class="koboSpan" id="kobo.1218.1"> – will make </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.1219.1">calling fun through the resulting pointer safe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1220.1">Next, we will go through type punning in C++ and the alternatives to using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1221.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1222.1"> for this task.</span></p>
<h3 class="heading-3" id="_idParaDest-144"><span class="koboSpan" id="kobo.1223.1">Type punning</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1224.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1225.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1226.1"> for type punning is a common practice even though it introduces undefined </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.1227.1">behavior. </span><span class="koboSpan" id="kobo.1227.2">Aliasing rules determine how we can access an object in C++, and to put it simply, we can access an object through a pointer and const qualified version of that pointer, a struct or union that contains the object, and through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1228.1">char</span></code><span class="koboSpan" id="kobo.1229.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1230.1">unsigned char</span></code><span class="koboSpan" id="kobo.1231.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">std::byte</span></code><span class="koboSpan" id="kobo.1233.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1234.1">We will go through the following example to better understand type punning in C++:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1235.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1236.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1237.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1238.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1239.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1240.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1241.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1242.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1243.1">&lt;cstring&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1244.1">namespace</span></span><span class="koboSpan" id="kobo.1245.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1246.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1247.1">my_struct</span></span><span class="koboSpan" id="kobo.1248.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1249.1">int</span></span><span class="koboSpan" id="kobo.1250.1"> a;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1251.1">char</span></span><span class="koboSpan" id="kobo.1252.1"> c;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1253.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1254.1">print_my_struct</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1255.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1256.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1257.1"> my_struct &amp; str)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1258.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1259.1">printf</span></span><span class="koboSpan" id="kobo.1260.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1261.1">"a = %d, c = %c\r\n"</span></span><span class="koboSpan" id="kobo.1262.1">, str.a, str.c);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1263.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1264.1">process_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1265.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1266.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1267.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1268.1"> * data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1269.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1270.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1271.1">auto</span></span><span class="koboSpan" id="kobo.1272.1"> *pstr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1273.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1274.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1275.1">const</span></span><span class="koboSpan" id="kobo.1276.1"> my_struct *&gt;(data);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1277.1">printf</span></span><span class="koboSpan" id="kobo.1278.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1279.1">"%s\r\n"</span></span><span class="koboSpan" id="kobo.1280.1">, __func__);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1281.1">print_my_struct</span></span><span class="koboSpan" id="kobo.1282.1">(pstr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1283.1">0</span></span><span class="koboSpan" id="kobo.1284.1">]);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1285.1">print_my_struct</span></span><span class="koboSpan" id="kobo.1286.1">(pstr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1287.1">1</span></span><span class="koboSpan" id="kobo.1288.1">]);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1289.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1290.1">process_data_memcpy</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1291.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1292.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1293.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1294.1"> * data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1295.1">{
    my_struct my_structs[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1296.1">2</span></span><span class="koboSpan" id="kobo.1297.1">];
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1298.1">memcpy</span></span><span class="koboSpan" id="kobo.1299.1">(my_structs, data, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1300.1">sizeof</span></span><span class="koboSpan" id="kobo.1301.1">(my_structs));
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1302.1">printf</span></span><span class="koboSpan" id="kobo.1303.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1304.1">"%s\r\n"</span></span><span class="koboSpan" id="kobo.1305.1">, __func__);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1306.1">print_my_struct</span></span><span class="koboSpan" id="kobo.1307.1">(my_structs[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1308.1">0</span></span><span class="koboSpan" id="kobo.1309.1">]);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1310.1">print_my_struct</span></span><span class="koboSpan" id="kobo.1311.1">(my_structs[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1312.1">1</span></span><span class="koboSpan" id="kobo.1313.1">]);
}
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1314.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1315.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1316.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1317.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1318.1">int</span></span><span class="koboSpan" id="kobo.1319.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1320.1">42</span></span><span class="koboSpan" id="kobo.1321.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1322.1">auto</span></span><span class="koboSpan" id="kobo.1323.1"> * i_ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1324.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.1325.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1326.1">char</span></span><span class="koboSpan" id="kobo.1327.1">*&gt;(&amp;i);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1328.1">if</span></span><span class="koboSpan" id="kobo.1329.1">(i_ptr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1330.1">0</span></span><span class="koboSpan" id="kobo.1331.1">]==</span><span class="hljs-number"><span class="koboSpan" id="kobo.1332.1">42</span></span><span class="koboSpan" id="kobo.1333.1">) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1334.1">printf</span></span><span class="koboSpan" id="kobo.1335.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1336.1">"Little endian!\r\n"</span></span><span class="koboSpan" id="kobo.1337.1">);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1338.1">else</span></span><span class="koboSpan" id="kobo.1339.1"> {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1340.1">printf</span></span><span class="koboSpan" id="kobo.1341.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1342.1">"Big endian!\r\n"</span></span><span class="koboSpan" id="kobo.1343.1">);
    }
    my_struct my_structs_arr[] = {{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1344.1">4</span></span><span class="koboSpan" id="kobo.1345.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1346.1">'a'</span></span><span class="koboSpan" id="kobo.1347.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1348.1">5</span></span><span class="koboSpan" id="kobo.1349.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1350.1">'b'</span></span><span class="koboSpan" id="kobo.1351.1">}};
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1352.1">char</span></span><span class="koboSpan" id="kobo.1353.1"> arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1354.1">128</span></span><span class="koboSpan" id="kobo.1355.1">];
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1356.1">memcpy</span></span><span class="koboSpan" id="kobo.1357.1">(&amp;arr, my_structs_arr, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1358.1">sizeof</span></span><span class="koboSpan" id="kobo.1359.1">(my_structs_arr));
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1360.1">process_data</span></span><span class="koboSpan" id="kobo.1361.1">(arr);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1362.1">process_data_memcpy</span></span><span class="koboSpan" id="kobo.1363.1">(arr);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1364.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1365.1">0</span></span><span class="koboSpan" id="kobo.1366.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1367.1">You can run </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.1368.1">the above example from the book’s GitHub repo. </span><span class="koboSpan" id="kobo.1368.2">It is placed under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1369.1">Chapter09/type_safety</span></code><span class="koboSpan" id="kobo.1370.1"> and you can build and run it using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1371.1">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_type_punning.cpp"
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1372.1">Running the example in Renode will provide the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1373.1">Little endian!
</span><span class="koboSpan" id="kobo.1373.2">process_data
a = 4, c = a
a = 5, c = b
process_data_memcpy
a = 4, c = a
a = 5, c = b
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1374.1">In the example above, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.1375.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.1376.1"> to treat an integer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1377.1">i</span></code><span class="koboSpan" id="kobo.1378.1"> as an array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1379.1">chars</span></code><span class="koboSpan" id="kobo.1380.1">. </span><span class="koboSpan" id="kobo.1380.2">By checking the value pointed by the first element of the mentioned array, we can determine if </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.1381.1">we are on a big or little-endian system. </span><span class="koboSpan" id="kobo.1381.2">As per the aliasing rules, this is a valid approach, but treating an array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">chars</span></code><span class="koboSpan" id="kobo.1383.1"> as some other type would be undefined behavior. </span><span class="koboSpan" id="kobo.1383.2">We did that in the function void </span><code class="inlineCode"><span class="koboSpan" id="kobo.1384.1">process_data</span></code><span class="koboSpan" id="kobo.1385.1"> where we reinterpreted an array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1386.1">chars</span></code><span class="koboSpan" id="kobo.1387.1"> as an array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1388.1">my_struct</span></code><span class="koboSpan" id="kobo.1389.1"> objects. </span><span class="koboSpan" id="kobo.1389.2">The output of the program is as we would expect it, even though we introduced undefined behavior. </span><span class="koboSpan" id="kobo.1389.3">To mitigate this issue, we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1390.1">std::memcpy</span></code><span class="koboSpan" id="kobo.1391.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-145"><span class="koboSpan" id="kobo.1392.1">Type punning – the correct way</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1393.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1394.1">std::memcpy</span></code><span class="koboSpan" id="kobo.1395.1"> is the only (as of C++23) available option for type punning in C++. </span><span class="koboSpan" id="kobo.1395.2">In the above example, we demonstrate this in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1396.1">process_data_memcpy</span></code><span class="koboSpan" id="kobo.1397.1"> function. </span><span class="koboSpan" id="kobo.1397.2">There is usually a concern </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.1398.1">of bytes being copied, using additional memory and runtime overhead, but the fact is that the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">memcpy</span></code><span class="koboSpan" id="kobo.1400.1"> is usually optimized away by a compiler. </span><span class="koboSpan" id="kobo.1400.2">You can verify this by running the above example in Compiler Explorer and by experimenting with different optimization levels.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1401.1">C++20 introduces </span><code class="inlineCode"><span class="koboSpan" id="kobo.1402.1">std::bit_cast</span></code><span class="koboSpan" id="kobo.1403.1">, which can also be used for type punning, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1404.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1405.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1406.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1407.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1408.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1409.1">&lt;bit&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1410.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1411.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1412.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1413.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1414.1">float</span></span><span class="koboSpan" id="kobo.1415.1"> f = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1416.1">3.14f</span></span><span class="koboSpan" id="kobo.1417.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1418.1">auto</span></span><span class="koboSpan" id="kobo.1419.1"> a = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1420.1">bit_cast</span></span><span class="koboSpan" id="kobo.1421.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1422.1">int</span></span><span class="koboSpan" id="kobo.1423.1">&gt;(f);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1424.1">printf</span></span><span class="koboSpan" id="kobo.1425.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1426.1">"a = %d\r\n"</span></span><span class="koboSpan" id="kobo.1427.1">, a);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1428.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1429.1">0</span></span><span class="koboSpan" id="kobo.1430.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1431.1">The output of the above program is:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1432.1">a = 1078523331
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1433.1">The above example and the program output demonstrate the usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1434.1">std::bit_cast</span></code><span class="koboSpan" id="kobo.1435.1"> for type punning. </span><span class="koboSpan" id="kobo.1435.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1436.1">std::bit_cast</span></code><span class="koboSpan" id="kobo.1437.1"> will return an object. </span><span class="koboSpan" id="kobo.1437.2">We specify the type that we are converting to as the template argument. </span><span class="koboSpan" id="kobo.1437.3">This will also be the return type of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1438.1">std::bit_cast</span></code><span class="koboSpan" id="kobo.1439.1">. </span><span class="koboSpan" id="kobo.1439.2">The size of the converting type and the type we are converting to must be the same. </span><span class="koboSpan" id="kobo.1439.3">This </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.1440.1">means </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">std::bit_cast</span></code><span class="koboSpan" id="kobo.1442.1"> is not an option for interpreting arrays of one type as arrays of another type, and for that we still need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1443.1">std::memcpy</span></code><span class="koboSpan" id="kobo.1444.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1445.1">Next, we will see how we can use strong types in C++ to increase type safety.</span></p>
<h1 class="heading-1" id="_idParaDest-146"><span class="koboSpan" id="kobo.1446.1">Strong types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1447.1">When we talk about type-safety, we should also discuss the safety of interfaces that use commonly available </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.1448.1">types such as integers and floats to represent physical units such as time, length, and volume. </span><span class="koboSpan" id="kobo.1448.2">Let us take a look at the following function from a vendor’s SDK:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1449.1">/**</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1450.1">  * @brief Start the direct connection establishment procedure.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1451.1">A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1452.1">process connectable advertising packets only for the specified</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1453.1">device".</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1454.1">  * @param LE_Scan_Interval This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1455.1">Time = N * 0.625 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1456.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1457.1">  - 0x0004 (2.500 ms)  ... </span><span class="koboSpan" id="kobo.1457.2">0x4000 (10240.000 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1458.1">  * @param LE_Scan_Window Amount of time for the duration of the LE scan. </span><span class="koboSpan" id="kobo.1458.2">LE_Scan_Window</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1459.1">shall be less than or equal to LE_Scan_Interval.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1460.1">Time = N * 0.625 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1461.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1462.1">  - 0x0004 (2.500 ms)  ... </span><span class="koboSpan" id="kobo.1462.2">0x4000 (10240.000 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1463.1">  * @param Peer_Address_Type The address type of the peer device.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1464.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1465.1">  - 0x00: Public Device Address</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1466.1">  - 0x01: Random Device Address</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1467.1">  * @param Peer_Address Public Device Address or Random Device Address of the device</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1468.1">to be connected.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1469.1">    * @param Conn_Interval_Min Minimum value for the connection event interval. </span><span class="koboSpan" id="kobo.1469.2">This shall be less than or equal to Conn_Interval_Max.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1470.1">Time = N * 1.25 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1471.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1472.1">  - 0x0006 (7.50 ms)  ... </span><span class="koboSpan" id="kobo.1472.2">0x0C80 (4000.00 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1473.1">  * @param Conn_Interval_Max Maximum value for the connection event interval. </span><span class="koboSpan" id="kobo.1473.2">This shall be</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1474.1">greater than or equal to Conn_Interval_Min.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1475.1">Time = N * 1.25 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1476.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1477.1">  - 0x0006 (7.50 ms)  ... </span><span class="koboSpan" id="kobo.1477.2">0x0C80 (4000.00 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1478.1">  * @param Conn_Latency Slave latency for the connection in number of connection events.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1479.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1480.1">  - 0x0000 ... </span><span class="koboSpan" id="kobo.1480.2">0x01F3</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1481.1">  * @param Supervision_Timeout Supervision timeout for the LE Link.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1482.1">It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1483.1">Time = N * 10 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1484.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1485.1">  - 0x000A (100 ms)  ... </span><span class="koboSpan" id="kobo.1485.2">0x0C80 (32000 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1486.1">  * @param Minimum_CE_Length Information parameter about the minimum length of connection needed for this LE connection.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1487.1">Time = N * 0.625 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1488.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1489.1">  - 0x0000 (0.000 ms)  ... </span><span class="koboSpan" id="kobo.1489.2">0xFFFF (40959.375 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1490.1">  * @param Maximum_CE_Length Information parameter about the maximum length of connection needed</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1491.1">for this LE connection.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1492.1">Time = N * 0.625 msec.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1493.1">  * Values:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1494.1">  - 0x0000 (0.000 ms)  ... </span><span class="koboSpan" id="kobo.1494.2">0xFFFF (40959.375 ms)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1495.1">  * @retval Value indicating success or error code.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1496.1">*/</span></span><span class="koboSpan" id="kobo.1497.1">
tBleStatus </span><span class="hljs-title"><span class="koboSpan" id="kobo.1498.1">aci_gap_create_connection</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1499.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1500.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1501.1"> LE_Scan_Interval,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1502.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1503.1"> LE_Scan_Window,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1504.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1505.1"> Peer_Address_Type,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1506.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1507.1"> Peer_Address[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1508.1">6</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1509.1">],</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1510.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1511.1"> Conn_Interval_Min,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1512.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1513.1"> Conn_Interval_Max,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1514.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1515.1"> Conn_Latency,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1516.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1517.1"> Supervision_Timeout,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1518.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1519.1"> Minimum_CE_Length,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1520.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1521.1"> Maximum_CE_Length)</span></span><span class="koboSpan" id="kobo.1522.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1523.1">This is a well-documented function. </span><span class="koboSpan" id="kobo.1523.2">Still, it takes a lot of effort to understand all the parameters that it accepts and the exact units of each. </span><span class="koboSpan" id="kobo.1523.3">Most of the parameters represent time but in a different way.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1524.1">LE_Scan_Interval</span></code><span class="koboSpan" id="kobo.1525.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1526.1">LE_Scan_Window</span></code><span class="koboSpan" id="kobo.1527.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1528.1">Conn_Interval_Min</span></code><span class="koboSpan" id="kobo.1529.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">Conn_Interval_Max</span></code><span class="koboSpan" id="kobo.1531.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1532.1">Supervision_Timeout</span></code><span class="koboSpan" id="kobo.1533.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">Minimum_CE_Length</span></code><span class="koboSpan" id="kobo.1535.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1536.1">Maximum_CE_Length</span></code><span class="koboSpan" id="kobo.1537.1"> are all time-related parameters, but they represent different units. </span><span class="koboSpan" id="kobo.1537.2">They are either multiples of 0.625, 1.25, or 10 ms. </span><span class="koboSpan" id="kobo.1537.3">The vendor of the above function also provided the following macros:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1538.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1539.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1540.1"> CONN_L(x) ((int)((x) / 0.625f))</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1541.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1542.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1543.1"> CONN_P(x) ((int)((x) / 1.25f))</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1544.1">Here is an </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.1545.1">example of a call to the above function using the provided macros:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1546.1">tBleStatus status = aci_gap_create_connection(CONN_L(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1547.1">80</span></span><span class="koboSpan" id="kobo.1548.1">), CONN_L(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1549.1">120</span></span><span class="koboSpan" id="kobo.1550.1">), PUBLIC_ADDR, mac_addr, CONN_P(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1551.1">50</span></span><span class="koboSpan" id="kobo.1552.1">), CONN_P(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1553.1">60</span></span><span class="koboSpan" id="kobo.1554.1">), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1555.1">0</span></span><span class="koboSpan" id="kobo.1556.1">, SUPERV_TIMEOUT, CONN_L(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1557.1">10</span></span><span class="koboSpan" id="kobo.1558.1">), CONN_L(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1559.1">15</span></span><span class="koboSpan" id="kobo.1560.1">));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1561.1">The macros help a bit with readability, but the problem of passing bad values to this function still remains. </span><span class="koboSpan" id="kobo.1561.2">It is fairly easy to make a mistake, swap the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">CONN_L</span></code><span class="koboSpan" id="kobo.1563.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1564.1">CONN_P</span></code><span class="koboSpan" id="kobo.1565.1"> macros, and introduce a hard-to-find bug to the program. </span><span class="koboSpan" id="kobo.1565.2">Instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1566.1">uint16_t</span></code><span class="koboSpan" id="kobo.1567.1">, we could define and use types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1568.1">conn_l</span></code><span class="koboSpan" id="kobo.1569.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1570.1">conn_p</span></code><span class="koboSpan" id="kobo.1571.1">. </span><span class="koboSpan" id="kobo.1571.2">If we wrap the function with these amendments, we will have the following wrapper function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1572.1">tBleStatus </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1573.1">aci_gap_create_connection_wrapper</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1574.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1575.1">                            conn_l LE_Scan_Interval,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1576.1">                            conn_l LE_Scan_Window,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1577.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1578.1"> Peer_Address_Type,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1579.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1580.1"> Peer_Address[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1581.1">6</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1582.1">],</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1583.1">                            conn_p Conn_Interval_Min,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1584.1">                            conn_p Conn_Interval_Max,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1585.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1586.1"> Conn_Latency,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1587.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1588.1"> Supervision_Timeout,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1589.1">                            conn_l Minimum_CE_Length,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1590.1">                            conn_l Maximum_CE_Length)</span></span><span class="koboSpan" id="kobo.1591.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1592.1">In the above example, we are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1593.1">conn_l</span></code><span class="koboSpan" id="kobo.1594.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1595.1">conn_p</span></code><span class="koboSpan" id="kobo.1596.1"> types instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1597.1">uint16_t</span></code><span class="koboSpan" id="kobo.1598.1">, and we will define these types as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1599.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1600.1">conn_l</span></span><span class="koboSpan" id="kobo.1601.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1602.1">private</span></span><span class="koboSpan" id="kobo.1603.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1604.1">    uint16_t</span></span><span class="koboSpan" id="kobo.1605.1"> time_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1606.1">public</span></span><span class="koboSpan" id="kobo.1607.1">:
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1608.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1609.1">conn_l</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1610.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1611.1">float</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1612.1"> time_ms)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1613.1"> : time_(time_ms/</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1614.1">0.625f</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1615.1">){</span></span><span class="koboSpan" id="kobo.1616.1">}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1617.1">    uint16_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1618.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1619.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1620.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1621.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1622.1">return</span></span><span class="koboSpan" id="kobo.1623.1"> time_;}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1624.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1625.1">conn_p</span></span><span class="koboSpan" id="kobo.1626.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1627.1">private</span></span><span class="koboSpan" id="kobo.1628.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1629.1">    uint16_t</span></span><span class="koboSpan" id="kobo.1630.1"> time_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1631.1">public</span></span><span class="koboSpan" id="kobo.1632.1">:
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1633.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1634.1">conn_p</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1635.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1636.1">float</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1637.1"> time_ms)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1638.1"> : time_(time_ms/</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1639.1">1.25f</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1640.1">){</span></span><span class="koboSpan" id="kobo.1641.1">}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1642.1">    uint16_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1643.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1644.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1645.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1646.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1647.1">return</span></span><span class="koboSpan" id="kobo.1648.1"> time_;}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1649.1">Using the </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.1650.1">above strong types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1651.1">conn_l</span></code><span class="koboSpan" id="kobo.1652.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1653.1">conn_p</span></code><span class="koboSpan" id="kobo.1654.1">, we can call the wrapper function as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1655.1">    tBleStatus stat = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1656.1">aci_gap_create_connection_wrapper</span></span><span class="koboSpan" id="kobo.1657.1">(
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1658.1">conn_l</span></span><span class="koboSpan" id="kobo.1659.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1660.1">80</span></span><span class="koboSpan" id="kobo.1661.1">),
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1662.1">conn_l</span></span><span class="koboSpan" id="kobo.1663.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1664.1">120</span></span><span class="koboSpan" id="kobo.1665.1">),
            PUBLIC_ADDR,
            </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1666.1">nullptr</span></span><span class="koboSpan" id="kobo.1667.1">,
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1668.1">conn_p</span></span><span class="koboSpan" id="kobo.1669.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1670.1">50</span></span><span class="koboSpan" id="kobo.1671.1">),
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1672.1">conn_p</span></span><span class="koboSpan" id="kobo.1673.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1674.1">60</span></span><span class="koboSpan" id="kobo.1675.1">),
            </span><span class="hljs-number"><span class="koboSpan" id="kobo.1676.1">0</span></span><span class="koboSpan" id="kobo.1677.1">,
            SUPERV_TIMEOUT,
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1678.1">conn_l</span></span><span class="koboSpan" id="kobo.1679.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1680.1">10</span></span><span class="koboSpan" id="kobo.1681.1">),
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1682.1">conn_l</span></span><span class="koboSpan" id="kobo.1683.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1684.1">15</span></span><span class="koboSpan" id="kobo.1685.1">)
    );
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1686.1">By using the keyword explicit in front of constructors of types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1687.1">conn_l</span></code><span class="koboSpan" id="kobo.1688.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1689.1">conn_p</span></code><span class="koboSpan" id="kobo.1690.1">, we make sure that the compiler doesn’t perform implicit conversion from integer types. </span><span class="koboSpan" id="kobo.1690.2">This makes it impossible to pass an integer or a float that can be used to construct </span><code class="inlineCode"><span class="koboSpan" id="kobo.1691.1">conn_l</span></code><span class="koboSpan" id="kobo.1692.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1693.1">conn_p</span></code><span class="koboSpan" id="kobo.1694.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1695.1">aci_gap_create_connection_wrapper</span></code><span class="koboSpan" id="kobo.1696.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1697.1">You can run the entire example from the book’s GitHub repo. </span><span class="koboSpan" id="kobo.1697.2">It is placed under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">Chapter09/type_safety</span></code><span class="koboSpan" id="kobo.1699.1"> and you can build and run it using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1700.1">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_strong_types.cpp"
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1701.1">Compiling the example successfully means that we passed all the correct arguments to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">aci_gap_create_connection_wrapper</span></code><span class="koboSpan" id="kobo.1703.1">. </span><span class="koboSpan" id="kobo.1703.2">As an exercise, try passing integer values instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1704.1">conn_l</span></code><span class="koboSpan" id="kobo.1705.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">conn_p</span></code><span class="koboSpan" id="kobo.1707.1"> arguments to see how they prevent the compiler from doing implicit conversions. </span><span class="koboSpan" id="kobo.1707.2">After that, try removing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">explicit</span></code><span class="koboSpan" id="kobo.1709.1"> keyword from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">conn_l</span></code><span class="koboSpan" id="kobo.1711.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1712.1">conn_p</span></code><span class="koboSpan" id="kobo.1713.1"> constructors to see what will happen.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1714.1">We can further </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.1715.1">improve the example by introducing a strong-type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1716.1">time</span></code><span class="koboSpan" id="kobo.1717.1"> that will represent the time duration, and make it a private member of types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1718.1">conn_l</span></code><span class="koboSpan" id="kobo.1719.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1720.1">conn_p</span></code><span class="koboSpan" id="kobo.1721.1">. </span><span class="koboSpan" id="kobo.1721.2">The code would look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1722.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1723.1">time</span></span><span class="koboSpan" id="kobo.1724.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1725.1">private</span></span><span class="koboSpan" id="kobo.1726.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1727.1">    uint16_t</span></span><span class="koboSpan" id="kobo.1728.1"> time_in_ms_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1729.1">public</span></span><span class="koboSpan" id="kobo.1730.1">:
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1731.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1732.1">time</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1733.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1734.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1735.1"> time_in_ms)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1736.1"> : time_in_ms_(time_in_ms){</span></span><span class="koboSpan" id="kobo.1737.1">}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1738.1">    uint16_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1739.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1740.1">get_ms</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1741.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1742.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1743.1">return</span></span><span class="koboSpan" id="kobo.1744.1"> time_in_ms_;}
};
time </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1745.1">operator</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1746.1">""</span></span><span class="koboSpan" id="kobo.1747.1">_ms(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1748.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1749.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1750.1">long</span></span><span class="koboSpan" id="kobo.1751.1"> t) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1752.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1753.1">time</span></span><span class="koboSpan" id="kobo.1754.1">(t);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1755.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1756.1">conn_l</span></span><span class="koboSpan" id="kobo.1757.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1758.1">private</span></span><span class="koboSpan" id="kobo.1759.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1760.1">    uint16_t</span></span><span class="koboSpan" id="kobo.1761.1"> val_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1762.1">public</span></span><span class="koboSpan" id="kobo.1763.1">:
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1764.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1765.1">conn_l</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1766.1">(time t)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1767.1"> : val_(t.get_ms()/</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1768.1">0.625f</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1769.1">){</span></span><span class="koboSpan" id="kobo.1770.1">}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1771.1">    uint16_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1772.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1773.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1774.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1775.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1776.1">return</span></span><span class="koboSpan" id="kobo.1777.1"> val_;}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1778.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1779.1">conn_p</span></span><span class="koboSpan" id="kobo.1780.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1781.1">private</span></span><span class="koboSpan" id="kobo.1782.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1783.1">    uint16_t</span></span><span class="koboSpan" id="kobo.1784.1"> val_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1785.1">public</span></span><span class="koboSpan" id="kobo.1786.1">:
</span><span class="hljs-type"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1787.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1788.1">conn_p</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1789.1">(time t)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1790.1"> : val_(t.get_ms()/</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1791.1">1.25f</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1792.1">){</span></span><span class="koboSpan" id="kobo.1793.1">}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1794.1">    uint16_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1795.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1796.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1797.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1798.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1799.1">return</span></span><span class="koboSpan" id="kobo.1800.1"> val_;}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1801.1">In the above example, we created a strong-type time and used it as a private member in types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1802.1">conn_l</span></code><span class="koboSpan" id="kobo.1803.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1804.1">conn_p</span></code><span class="koboSpan" id="kobo.1805.1">. </span><span class="koboSpan" id="kobo.1805.2">We also created a user-defined literal with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1806.1">operator""_ms</span></code><span class="koboSpan" id="kobo.1807.1"> to make the following function call possible:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1808.1">    tBleStatus stat = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1809.1">aci_gap_create_connection_wrapper</span></span><span class="koboSpan" id="kobo.1810.1">(
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1811.1">conn_l</span></span><span class="koboSpan" id="kobo.1812.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1813.1">80</span></span><span class="koboSpan" id="kobo.1814.1">_ms),
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1815.1">conn_l</span></span><span class="koboSpan" id="kobo.1816.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1817.1">120</span></span><span class="koboSpan" id="kobo.1818.1">_ms),
            PUBLIC_ADDR,
            </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1819.1">nullptr</span></span><span class="koboSpan" id="kobo.1820.1">,
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1821.1">conn_p</span></span><span class="koboSpan" id="kobo.1822.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1823.1">50</span></span><span class="koboSpan" id="kobo.1824.1">_ms),
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1825.1">conn_p</span></span><span class="koboSpan" id="kobo.1826.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1827.1">60</span></span><span class="koboSpan" id="kobo.1828.1">_ms),
            </span><span class="hljs-number"><span class="koboSpan" id="kobo.1829.1">0</span></span><span class="koboSpan" id="kobo.1830.1">_ms,
            </span><span class="hljs-number"><span class="koboSpan" id="kobo.1831.1">4000</span></span><span class="koboSpan" id="kobo.1832.1">_ms,
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1833.1">conn_l</span></span><span class="koboSpan" id="kobo.1834.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1835.1">10</span></span><span class="koboSpan" id="kobo.1836.1">_ms),
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1837.1">conn_l</span></span><span class="koboSpan" id="kobo.1838.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1839.1">15</span></span><span class="koboSpan" id="kobo.1840.1">_ms)
    );
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1841.1">In the above example, we are using the user-defined literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.1842.1">operator""_ms</span></code><span class="koboSpan" id="kobo.1843.1"> to create objects of strong-type </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.1844.1">time that are used to instantiate conn_l and conn_p objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1845.1">The above changes to the original interface improve code readability and compile-time error detection. </span><span class="koboSpan" id="kobo.1845.2">Using strong types, we make it a lot harder to pass wrong values to the function, increasing the type-safety of our codebase.</span></p>
<h1 class="heading-1" id="_idParaDest-147"><span class="koboSpan" id="kobo.1846.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1847.1">Type safety is an important aspect of any programming language used in critical applications. </span><span class="koboSpan" id="kobo.1847.2">Understanding potential issues of implicit conversion is important to mitigate type-safety concerns. </span><span class="koboSpan" id="kobo.1847.3">Type punning is another area that deserves special attention in C++, and we learned how to address it properly. </span><span class="koboSpan" id="kobo.1847.4">We also learned how to use strong types to mitigate issues of passing wrong values to parameters with the same types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1848.1">Next, we will cover lambdas in C++.</span></p>
<h1 class="heading-1" id="_idParaDest-148"><span class="koboSpan" id="kobo.1849.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1850.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.1851.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1852.1"><img alt="" role="presentation" src="../Images/QR_code_Discord.png"/></span></p>
</div>
</body></html>