<html><head></head><body>
<div><h1 class="chapterNumber">9</h1>
<h1 class="chapterTitle" id="_idParaDest-133">Improving Type-Safety with Strong Types</h1>
<p class="normal">C++ is a statically typed language, meaning that every expression is assigned a type at a compile time, either by a developer (in most cases), or deduced by a compiler when using the keyword auto. Still, this doesn’t make it a type-safe language.</p>
<p class="normal">Both C++ and C allow functions with a variable number of arguments (<code class="inlineCode">va_arg</code>), or variadic functions and type casting, and support implicit type conversion. These low-level capabilities that are associated with the performance of C++ and C are often the source of bugs in programs. In this chapter, we will cover good practices used to increase type-safety in C++.</p>
<p class="normal"><strong class="keyWord">Type-safety</strong> is an <a id="_idIndexMarker432"/>important aspect of a program in safety-critical systems. That’s why safety coding standards provided by organizations such as MISRA and AUTOSAR restrain the usage of features that violate type-safety. In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList">Implicit conversions</li>
<li class="bulletList">Explicit conversions</li>
<li class="bulletList">Strong types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-134">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler for x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using a lot of modern C++ features, make sure to select the C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in the compiler options box.</p>
<p class="normal">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. Most of the examples can also be run in the Renode simulator on Arm Cortex-M0 target and are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter09</a>).</p>
<h1 class="heading-1" id="_idParaDest-135">Implicit conversion</h1>
<p class="normal">When you make a call to a function that expects an integer parameter, but you pass a float as an argument, the compiler will happily compile the program. Similarly, if you pass an array of integers <a id="_idIndexMarker433"/>to a function that expects a pointer to an integer, the program will also compile. These scenarios have become so normalized in both C and C++ that they are often taken for granted <a id="_idIndexMarker434"/>without considering what’s happening during the compilation process.</p>
<p class="normal">In both described scenarios, the compiler is performing implicit conversions. It converts the float to an integer in the first scenario and passes a pointer to the first element of the array in the second scenario, a process known as <strong class="keyWord">array-to-pointer decay</strong>.</p>
<p class="normal">While implicit conversions make the code less verbose and easier to write, they also open the door to a range of type-safety-related issues. Converting a float to an integer leads to precision loss, and assuming that an array always behaves like a pointer can lead to misinterpretations of the array’s bounds, potentially causing buffer overflows or other memory issues.</p>
<p class="normal">Implicit conversion <a id="_idIndexMarker435"/>is performed in the following cases:</p>
<ul>
<li class="bulletList">When a function is called with an argument of a type different than the parameter. For example:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
void print_int(int value) {
    printf("value = %d\n", value);
}
int main() {
    float pi = 3.14f;
 // int implicitly converts to float
 print_int(pi);
 return 0;
}
</code></pre>
</li>
<li class="bulletList">When a value specified in a return statement is of a different type than specified by a function declaration. For example:
        <pre class="programlisting code"><code class="hljs-code">int get_int() {
    float pi = 3.14;
 // float implicitly converts to int
 return pi;
}
</code></pre>
</li>
<li class="bulletList">In expressions <a id="_idIndexMarker436"/>with binary operators provided with operands of different arithmetic types. For example:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
int main() {
    int int_value = 5;
    float float_value = 4.2;
 // int converts to float
 auto result = int_value + float_value;
 printf("result = %f\n", result);
 
 return 0;
}
</code></pre>
</li>
<li class="bulletList">In a <code class="inlineCode">switch</code> statement to an integral type. For example:
        <pre class="programlisting code"><code class="hljs-code">char input = 'B';
// implicit conversion from char to int
switch (input) {
 case 65:
 printf("Input is 'A'\n");
 break;
 case 66:
 printf("Input is 'B'\n");
 break;
 default:
 printf("Unknown input");
}
</code></pre>
</li>
<li class="bulletList">In an <code class="inlineCode">if</code> statement, types can be converted to a <code class="inlineCode">bool</code> type. For example:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
int main() {
    int int_value = 10;
 // int implicitly converts to bool
 if (int_value) {
 printf("true\n");
 }
 return 0;
}
</code></pre>
</li>
</ul>
<p class="normal">There are different <a id="_idIndexMarker437"/>types of implicit conversion that are handled by a compiler, and some of the most important are:</p>
<ul>
<li class="bulletList">Numeric promotions and conversions</li>
<li class="bulletList">Array to pointer conversion</li>
<li class="bulletList">Function to pointer conversion</li>
</ul>
<p class="normal">Next, we will discuss the above implicit conversions with examples.</p>
<h2 class="heading-2" id="_idParaDest-136">Numeric promotions and conversions</h2>
<p class="normal">Arithmetic types can be promoted or converted to other arithmetic types. Type promotion will not <a id="_idIndexMarker438"/>change the value or lose precision. <code class="inlineCode">std::uint8_t</code> can be promoted to <code class="inlineCode">int</code>, or <code class="inlineCode">float</code> can be promoted to <code class="inlineCode">double</code>. If a type that is being converted can fit entirely to the destination type, without loss of precision, it is being promoted.</p>
<p class="normal">Arithmetic operators do not accept types smaller than <code class="inlineCode">int</code>. Arithmetic types can be promoted when passed as operands to arithmetic operators. There are specific rules for promotions of integral and floating-point types based on their type:</p>
<ul>
<li class="bulletList">Boolean promotion: <code class="inlineCode">bool</code> is promoted to <code class="inlineCode">int</code> with value <code class="inlineCode">0</code> if set to <code class="inlineCode">false</code>, and <code class="inlineCode">1</code> if <code class="inlineCode">true</code></li>
<li class="bulletList">Other integral types, including bitfields, are converted to the smallest type from the following list that can represent all the values of the converted type:<ul>
<li class="bulletList"><code class="inlineCode">int</code></li>
<li class="bulletList"><code class="inlineCode">unsigned int</code></li>
<li class="bulletList"><code class="inlineCode">long</code></li>
<li class="bulletList"><code class="inlineCode">unsigned long</code></li>
<li class="bulletList"><code class="inlineCode">long long</code></li>
<li class="bulletList"><code class="inlineCode">unsigned long long</code></li>
</ul>
</li>
<li class="bulletList">A <code class="inlineCode">float</code> can be promoted to <code class="inlineCode">double</code>.</li>
</ul>
<p class="normal">To better understand integer promotion rules, we will go over the next example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdint&gt;
#include &lt;type_traits&gt;
int main() {
    std::uint8_t a = 1;
    std::uint16_t b = 42;
    auto res1 = a + b;
    static_assert(std::is_same_v&lt;int, decltype(res1)&gt;);
    return 0;
}
</code></pre>
<p class="normal">In the above example, we added <code class="inlineCode">uint8_t</code> and <code class="inlineCode">uint16_t</code>. According to the promotion rules, both types <a id="_idIndexMarker439"/>will be promoted to <code class="inlineCode">int</code>, as they can be fully represented by <code class="inlineCode">int</code>. The result of the adding is stored in the variable <code class="inlineCode">res1</code>, which is declared as <code class="inlineCode">auto</code>, meaning that the compiler will deduce its type. We expect it to be an <code class="inlineCode">int</code> and we verify that using <code class="inlineCode">static_assert</code> and <code class="inlineCode">std::is_same_v</code>.</p>
<p class="normal">In this example, both types were promoted to the same type. If we had different types after promotion, then they would be converted to a common type under the rules of <strong class="keyWord">usual arithmetic conversion</strong>.</p>
<p class="normal">The goal of <a id="_idIndexMarker440"/>the usual arithmetic conversion is to yield types to a common type, which is also the type of the result. There are a couple of rules to usual arithmetic conversion:</p>
<ul>
<li class="bulletList">If both types are signed or unsigned integers, then the common type is the type of greater integer conversion rank. The ranks are listed below in decreasing order (the ranks of unsigned integers correspond to those of matching signed):<ul>
<li class="bulletList"><code class="inlineCode">long long</code></li>
<li class="bulletList"><code class="inlineCode">long</code></li>
<li class="bulletList"><code class="inlineCode">int</code></li>
<li class="bulletList"><code class="inlineCode">short</code></li>
<li class="bulletList"><code class="inlineCode">signed char</code></li>
</ul>
</li>
<li class="bulletList">If one of the types is a signed integer and the other one is unsigned then the following rules apply:<ul>
<li class="bulletList">If the integer conversion rank of the unsigned type is greater than or equal to the signed type, then the common type is that of the unsigned type.</li>
<li class="bulletList">Otherwise, if the signed type can represent all the values of the unsigned type, the common type is that of the signed type.</li>
<li class="bulletList">Otherwise, the common type is an unsigned integer of the type of the signed integer.</li>
</ul>
</li>
<li class="bulletList">If one of the types is a floating type and the other is an integer, the integer is converted to that floating type.</li>
<li class="bulletList">If both <a id="_idIndexMarker441"/>types are the floating type but of different floating-point conversion ranks, the type with the lower conversion rank is converted to the other one. The floating-point conversion rank is listed below in decreasing order:<ul>
<li class="bulletList"><code class="inlineCode">long double</code></li>
<li class="bulletList"><code class="inlineCode">double</code></li>
<li class="bulletList"><code class="inlineCode">float</code></li>
</ul>
</li>
</ul>
<p class="normal">Let’s go through the following example to better understand the rules of usual arithmetic conversion:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;type_traits&gt;
int main() {
    struct bitfield{
        long long a:31;
    };
    bitfield b {4};
    int c = 1;
    auto res1 = b.a + c;  
    static_assert(sizeof(int) == 4);
    static_assert(sizeof(long long) == 8);
    static_assert(std::is_same_v&lt;int, decltype(res1)&gt;);
    long e = 5;
    auto res2 = e - b.a;
    static_assert(std::is_same_v&lt;long, decltype(res2)&gt;);
    return 0;
}
</code></pre>
<p class="normal">In the above example, we have a <code class="inlineCode">bitfield</code> of 31 bits with an underlying type of <code class="inlineCode">long long</code>. We first add <code class="inlineCode">b.a</code> and variable c of type <code class="inlineCode">int</code>. If we are on a platform where the size of the <code class="inlineCode">int</code> is 4 bytes, the bitfield will be promoted to the <code class="inlineCode">int</code>, even though the underlying type <code class="inlineCode">long long</code> has a size of 8 bytes. The promoted bitfield will be added to int <code class="inlineCode">c</code>, so the result of this operation will also be int, which we verify by checking the type of res1 using <code class="inlineCode">std::is_same_v</code>.</p>
<p class="normal">In the second part of the example, we subtract the bitfield from <code class="inlineCode">long</code> <code class="inlineCode">e</code>. In this case, the bitfield is <a id="_idIndexMarker442"/>first promoted to <code class="inlineCode">int</code>; then, according to the rules of usual arithmetic conversion, it is converted to <code class="inlineCode">long</code>, meaning that the resulting type will also be <code class="inlineCode">long</code>.</p>
<p class="normal">You can run the above example from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter09/type_safety</code> and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_usual_arithmetic_conversion.cpp"
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">The fact that the program builds successfully is enough to confirm the usual arithmetic conversion results, as we used <code class="inlineCode">static_assert</code> to verify it.</p>
<p class="normal">Now, let us take a look at an example whose result may be surprising:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
int main() {
    int a = -4;
    unsigned int b = 3;
    if(a + b &gt; 0) {
        printf("%d + % u is greater than 0\r\n", a, b);
    }
    return 0;
}
</code></pre>
<p class="normal">If you run this example, the expression within the <code class="inlineCode">if</code> clause will evaluate to true. As per the rules of usual arithmetic conversion, the signed <code class="inlineCode">int</code> a will be converted to the <code class="inlineCode">unsigned int</code>, meaning that the expression <code class="inlineCode">a + b</code> will indeed be greater than <code class="inlineCode">0</code>. Mixing unsigned and signed types in arithmetic expressions can lead to undesired behavior and potential bugs due to implicit conversions.</p>
<p class="normal">We can use <code class="inlineCode">–Wconversion</code> and <code class="inlineCode">-Wsign-conversion</code> compiler flags with GCC to make it raise a warning when implicit conversion may change a value and sign. Still, mixing signed and unsigned types in arithmetic expressions should be avoided as it can result in wrong results.</p>
<p class="normal">Next, we will discuss array-to-pointer conversion and its implications.</p>
<h2 class="heading-2" id="_idParaDest-137">Array-to-pointer conversion</h2>
<p class="normal">An array can be implicitly converted to a pointer. The resulting pointer points to the first element <a id="_idIndexMarker443"/>of the array. Many C and C++ functions that work on <a id="_idIndexMarker444"/>arrays of data are designed with pointer and size parameters. These interfaces are based on contract design. The contract is the following:</p>
<ul>
<li class="bulletList">A caller will pass a pointer that points to the first element of the array</li>
<li class="bulletList">A caller will pass the size of the array</li>
</ul>
<p class="normal">This is a simple contract, but there is no way to enforce it. Let’s take a look at the following simple example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt; 
void print_ints(int * arr, std::size_t len) {
    for(std::size_t i = 0; i &lt; len; i++) {
        printf("%d\r\n", arr[i]);
    }
}
 int main() { 
    int array_ints[3] = {1, 2, 3};
    print_ints(array_ints, 3);
    return 0; 
}
</code></pre>
<p class="normal">In the above <a id="_idIndexMarker445"/>example, we have the <code class="inlineCode">print_ints</code> function with <code class="inlineCode">arr</code>, a pointer to an <code class="inlineCode">int</code>, and <code class="inlineCode">len</code>, a <code class="inlineCode">std::size_t</code> parameter. In the <code class="inlineCode">main</code> function, we call the <code class="inlineCode">print_ints</code> function by passing <code class="inlineCode">array_ints</code>, an array of 3 integers, and <code class="inlineCode">3</code> as arguments. The array <code class="inlineCode">array_ints</code> will be implicitly converted to a pointer that points to its first element. There are a couple of potential issues with the <code class="inlineCode">print_ints</code> function:</p>
<ul>
<li class="bulletList">It expects that the pointer we pass to it is valid. It doesn’t verify that.</li>
<li class="bulletList">It expects that the argument it receives for the <code class="inlineCode">len</code> parameter is the actual size of the array it operates on. A caller could pass a size that may cause out-of-bounds access.</li>
<li class="bulletList">As it operates directly on a pointer, there is always a chance of out-of-bound access if pointer arithmetic is used in the function.</li>
</ul>
<p class="normal">To eliminate these potential issues, in C++, instead of using a pointer to work on an array of data, we can use the class template <code class="inlineCode">std::span</code>. It is a wrapper for a contiguous sequence of objects, with the <a id="_idIndexMarker446"/>first element of the sequence <a id="_idIndexMarker447"/>at position zero. It can be constructed from a C-style array, it has the <code class="inlineCode">size</code> method, and we can use range-based <code class="inlineCode">for</code> loops on it. Let’s write the previous example using the <code class="inlineCode">std::span</code> instead of the pointer:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt; 
#include &lt;span&gt;
void print_ints(const std::span&lt;int&gt; arr) {
    for(int elem: arr) {
        printf("%d\r\n", elem);
    }
}
int main() { 
    int arr[3] = {1, 2, 3};
    print_ints(arr);
    return 0; 
}
</code></pre>
<p class="normal">In the above example, we can see that the function <code class="inlineCode">print_ints</code> looks much simpler now. It accepts <code class="inlineCode">std::span</code> of integers and it uses a range-based for loop to iterate over the elements. On the call site, we now just pass <code class="inlineCode">arr</code>, an array of 3 integers. It is implicitly converted to <code class="inlineCode">std::span</code>.</p>
<p class="normal">The class template <code class="inlineCode">std::span</code> also has the <code class="inlineCode">size</code> method, operator <code class="inlineCode">[]</code>, and <code class="inlineCode">begin</code> and <code class="inlineCode">end</code> iterators, meaning we can use it in standard library algorithms. We can also construct a subspan from <code class="inlineCode">span</code>. It can be constructed from C-style arrays, but also from containers such as <code class="inlineCode">std::array</code> and <code class="inlineCode">std::vector</code>. It is a great solution to potential issues of interfaces that usually rely on pointer and size parameters.</p>
<h2 class="heading-2" id="_idParaDest-138">Function-to-pointer conversion</h2>
<p class="normal">A function <a id="_idIndexMarker448"/>can be implicitly converted to a pointer to that <a id="_idIndexMarker449"/>function. The following example demonstrates this:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt; 
#include &lt;type_traits&gt;
void print_hello() {
    printf("Hello!\r\n");
}
int main() { 
    void(*fptr)() = print_hello;
    fptr();
    fptr = &amp;print_hello;
    (*fptr)();
    static_assert(std::is_same_v&lt;decltype(fptr), void(*)()&gt;);
    static_assert(std::is_same_v&lt;decltype(print_hello), void()&gt;);
    return 0; 
}
</code></pre>
<p class="normal">In the example above, we assign the function <code class="inlineCode">print_hello</code> to a function pointer <code class="inlineCode">fptr</code>. In C++, we don’t <a id="_idIndexMarker450"/>need to use the address-off <a id="_idIndexMarker451"/>operator with a function name to assign it to a function pointer. Also, we don’t need to dereference a function pointer when making a call to a function through it. Still, <code class="inlineCode">print_hello</code> and <code class="inlineCode">fptr</code> are two different types and we confirm this using the <code class="inlineCode">static_assert</code> and <code class="inlineCode">is_same</code> type traits.</p>
<p class="normal">Implicit conversions in C++ make writing the code easier. They can sometimes lead to undesired behavior and potential issues with our program. To mitigate these concerns, we can explicitly convert types when needed.</p>
<p class="normal">Next, we will cover explicit conversion.</p>
<h1 class="heading-1" id="_idParaDest-139">Explicit conversion</h1>
<p class="normal">C++ supports <a id="_idIndexMarker452"/>C-style cast explicit conversion, but also functional-style cast and the following casting operators:</p>
<ul>
<li class="bulletList"><code class="inlineCode">const_cast</code></li>
<li class="bulletList"><code class="inlineCode">static_cast</code></li>
<li class="bulletList"><code class="inlineCode">dynamic_cast</code></li>
<li class="bulletList"><code class="inlineCode">reinterpret_cast</code></li>
</ul>
<p class="normal">We will go through casting operators, starting with <code class="inlineCode">const_cast</code>.</p>
<h2 class="heading-2" id="_idParaDest-140">const_cast</h2>
<p class="normal"><code class="inlineCode">const_cast</code> is used <a id="_idIndexMarker453"/>to cast away constness to work with non-const-correct <a id="_idIndexMarker454"/>functions. We will go through the following example to better understand it:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
void print_num(int &amp; num) {
    printf("num is %d\r\n", num);
}
int main() {
    const int num = 42;
    print_num(const_cast&lt;int&amp;&gt;(num));
    int &amp; num_ref = const_cast&lt;int&amp;&gt;(num);
    num_ref = 16;
    return num;
}
</code></pre>
<p class="normal">In the above example, we used <code class="inlineCode">const_cast</code> in two different scenarios. We first used it to cast away constness from <code class="inlineCode">const int num</code> to be able to pass it to the <code class="inlineCode">print_num</code> function. The <code class="inlineCode">print_num</code> function has a single parameter – a non-const reference to an <code class="inlineCode">int</code>. As we know that this function is not trying to modify the object that the reference is bound to, we decided to cast away constness so we can pass a reference to a const int to it without the compiler generating an error.</p>
<p class="normal">Then, we used <code class="inlineCode">const_cast</code> to cast away constness from the <code class="inlineCode">num</code> to be able to assign it to non-const reference <code class="inlineCode">num_ref</code>. If you run this example in Compiler Explorer, you will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Program returned: 42
num is 42
</code></pre>
<p class="normal">The program returned <code class="inlineCode">42</code>, that is, the value of <code class="inlineCode">num</code> is <code class="inlineCode">42</code> even though we tried to set it to <code class="inlineCode">16</code> through <code class="inlineCode">num_ref</code>. This is due to the fact that modifying the const variable through a non-const reference or a pointer is undefined behavior.</p>
<p class="normal"><code class="inlineCode">const_cast</code> is used mostly to interface with non-const correct functions. Still, this is dangerous and should be avoided as we can’t guarantee that the function we are passing a const-cast-away pointer or a reference will not try to modify the object that the pointer is pointing to or the reference it is bound to. Next, we will cover <code class="inlineCode">static_cast</code>.</p>
<h2 class="heading-2" id="_idParaDest-141">static_cast</h2>
<p class="normal">The most <a id="_idIndexMarker455"/>used cast operator in C++ is <code class="inlineCode">static_cast</code>, and it is used in the following scenarios:</p>
<ul>
<li class="bulletList">To upcast <a id="_idIndexMarker456"/>and downcast a pointer of base class to derived class and vice versa</li>
<li class="bulletList">To discard a value expression</li>
<li class="bulletList">To convert between types with well-known conversion paths such as int to float, <code class="inlineCode">enum</code> to an <code class="inlineCode">int</code>, int to an <code class="inlineCode">enum</code>, and similar</li>
</ul>
<p class="normal">We will go through several usages of <code class="inlineCode">static_cast</code> using the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
struct Base {
    void hi() {
        printf("Hi from Base\r\n");
    }
};
struct Derived : public Base {
    void hi() {
        printf("Hi from Derived\r\n");
    }
};
int main() {
    // unsigned to signed int 
int a = -4; 
    unsigned int b = 3; 
    if(a + static_cast&lt;int&gt;(b) &gt; 0) { 
        printf("%d + %d is greater than 0\r\n", a, b); 
    } 
    else {
        printf("%d + %d is not greater than 0\r\n", a,b); 
    }
    // discard an expression
int c;
    static_cast&lt;void&gt;(c);
    Derived derived;
    // implicit upcast
    Base * base_ptr = &amp;derived;
    base_ptr-&gt;hi();
    // downcast
    Derived *derived_p = static_cast&lt;Derived*&gt;(base_ptr);
    derived_p-&gt;hi();
    return 0;
}
</code></pre>
<p class="normal">If we run the above example, we will get the following output:</p>
<pre class="programlisting con"><code class="hljs-con">-4 + 3 is not greater than 0
Hi from Base
Hi from Derived
</code></pre>
<p class="normal">In the above example, we used <code class="inlineCode">static_cast</code> to convert an <code class="inlineCode">unsigned int</code> to a signed <code class="inlineCode">int</code>, which helps <a id="_idIndexMarker457"/>mitigate the issue of comparing integers with mixed signs <a id="_idIndexMarker458"/>introduced by implicit conversion. Still, we would need to make sure that the conversion is safe as <code class="inlineCode">static_cast</code> doesn’t do any runtime checks.</p>
<p class="normal">Using <code class="inlineCode">static_cast</code> to cast the variable <code class="inlineCode">c</code> to void is a technique used to suppress compiler warnings about unused variables. It indicates that we are aware of the variable, but we intentionally do not use it.</p>
<p class="normal">In the other part of the above example, we can see that an address to an object of the <code class="inlineCode">Derived</code> class can be implicitly converted to a pointer of the <code class="inlineCode">Base</code> class. If we call a function <code class="inlineCode">hi</code> on the pointer of the Base class which is pointing to an object of the Derived class, we will actually make a call to a <code class="inlineCode">hi</code> function defined in the <code class="inlineCode">Base</code> class. Then we used <code class="inlineCode">static_cast</code> to downcast <code class="inlineCode">Base</code> pointer to a <code class="inlineCode">Derived</code> pointer.</p>
<p class="normal">Down-casting using <code class="inlineCode">static_cast</code> can be dangerous as <code class="inlineCode">static_cast</code> doesn’t do any runtime checks to make sure that the pointer is actually pointing to the converting type. An object of the <code class="inlineCode">Derived</code> class is also an object of the <code class="inlineCode">Base</code> class, but the reverse is not true – <code class="inlineCode">Base</code> is not <code class="inlineCode">Derived</code>. The following example demonstrates why this is dangerous:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
struct Base {
    void hi() {
 printf("Hi from Base\r\n");
 }
};
struct Derived : public Base {
    void hi() {
 printf("Hi from Derived, x = %d\r\n", x);
 }
    int x = 42;
};
int main() {
 Base base;
 Derived *derived_ptr = static_cast&lt;Derived*&gt;(&amp;base);
 derived_ptr-&gt;hi();
 return 0;
}
</code></pre>
<p class="normal">In this code, we are <a id="_idIndexMarker459"/>trying to access member <code class="inlineCode">x</code> of the <code class="inlineCode">Derived</code> class on an object of the <a id="_idIndexMarker460"/>base class. As we used <code class="inlineCode">static_cast</code>, the compiler will not complain and this will result in undefined behavior, as the base class doesn’t have member <code class="inlineCode">x</code>. One of the possible outputs of this program is shown here:</p>
<pre class="programlisting con"><code class="hljs-con">Hi from Derived, x = 1574921984
</code></pre>
<p class="normal">To avoid this problem, we can use <code class="inlineCode">dynamic_cast</code>, which we will cover next.</p>
<h2 class="heading-2" id="_idParaDest-142">dynamic_cast</h2>
<p class="normal"><code class="inlineCode">dynamic_cast</code> performs runtime <a id="_idIndexMarker461"/>checks of types and sets <a id="_idIndexMarker462"/>the result to <code class="inlineCode">nullptr</code> in case the <code class="inlineCode">Base</code> pointer doesn’t actually point to an object of the <code class="inlineCode">Derived</code> class. We will go through an example to better understand it:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
struct Base {
    virtual void hi() {
        printf("Hi from Base\r\n");
    }
};
struct Derived : public Base {
    void hi() override {
        printf("Hi from Derived\r\n");
    }
    void derived_only() {
        printf("Derived only method\r\n");
    }
};
void process(Base *base) {
    base-&gt;hi();
    if(auto ptr = dynamic_cast&lt;Derived*&gt;(base); ptr ! = nullptr) 
    {
        ptr-&gt;derived_only();
    }
}
int main() {
    Base base;
    Derived derived;
    Base * base_ptr = &amp;derived;
    process(&amp;base);
    process(base_ptr);
    return 0;
}
</code></pre>
<p class="normal">In the <a id="_idIndexMarker463"/>above example, we have a function <code class="inlineCode">process</code> with a pointer to Base as a <a id="_idIndexMarker464"/>parameter. The function uses <code class="inlineCode">dynamic_cast</code> to downcast the <code class="inlineCode">Base</code> pointer to a <code class="inlineCode">Derived</code> pointer. In the <strong class="keyWord">if statement with initializer</strong>, we initialize <code class="inlineCode">ptr</code> with the result of <code class="inlineCode">dynamic_cast&lt;Derived*&gt;</code> on a <code class="inlineCode">Base</code> pointer. In the condition of the <code class="inlineCode">if</code> statement, we check if <code class="inlineCode">ptr</code> is different from <code class="inlineCode">nullptr</code>, and if it is we can safely use it as a pointer to an object of the <code class="inlineCode">Derived</code> class. Next, we will cover <code class="inlineCode">reinterpret_cast</code>.</p>
<h2 class="heading-2" id="_idParaDest-143">reinterpret_cast</h2>
<p class="normal"><code class="inlineCode">reinterpret_cast</code> is used <a id="_idIndexMarker465"/>to convert between types by <a id="_idIndexMarker466"/>reinterpreting the underlying bits. It can be used in the following situations:</p>
<ul>
<li class="bulletList">To convert a pointer to an integer large enough to hold all of its values.</li>
<li class="bulletList">To convert a value of an integer to a pointer. A pointer converted to an integer and back to its original type is guaranteed to have the original value and can be dereferenced safely.</li>
<li class="bulletList">To convert pointers between different types, such as between <code class="inlineCode">T1</code> and <code class="inlineCode">T2</code>. The resulting pointer to <code class="inlineCode">T2</code> can be dereferenced safely only if the resulting pointer is <code class="inlineCode">char</code>, <code class="inlineCode">unsigned char</code>, <code class="inlineCode">std::byte</code>, or <code class="inlineCode">T1</code>.</li>
<li class="bulletList">To convert a function pointer <code class="inlineCode">F1</code> to a pointer to a different function <code class="inlineCode">F2</code>. Converting <code class="inlineCode">F2</code> back to <code class="inlineCode">F1</code> will result in the pointer to <code class="inlineCode">F1</code>.</li>
</ul>
<p class="normal">To better understand <code class="inlineCode">reinterpret_cast</code>, we will go through the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
int fun() {
    printf("fun\r\n");
    return 42;
}
int main() {
    float f = 3.14f;
    // initialize pointer to an int with float address
auto a = reinterpret_cast&lt;int*&gt;(&amp;f);
    printf("a = %d\r\n", *a);
    // the above is same as:
    a = static_cast&lt;int*&gt;(static_cast&lt;void*&gt;(&amp;f));
    printf("a = %d\r\n", *a);
    // casting back to float pointer
auto fptr = reinterpret_cast&lt;float*&gt;(a);
    printf("f = %.2f\r\n", *fptr);
    // converting a pointer to integer
auto int_val = reinterpret_cast&lt;std::uintptr_t&gt;(fptr);
    printf("Address of float f is 0x%8X\r\n", int_val);
    auto fun_void_ptr = reinterpret_cast&lt;void(*)()&gt;(fun);
    // undefined behavior
fun_void_ptr();
    auto fun_int_ptr = reinterpret_cast&lt;int(*)()&gt;(fun);
    // safe call
printf("fun_int_ptr returns %d\r\n", fun_int_ptr());
    return 0;
}
</code></pre>
<p class="normal">You can <a id="_idIndexMarker467"/>run the above example from the book’s GitHub repo. It is placed <a id="_idIndexMarker468"/>under <code class="inlineCode">Chapter09/type_safety</code> and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_reinterpret_cast.cpp"
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Running the example in Renode will provide the following output:</p>
<pre class="programlisting con"><code class="hljs-con">a = 1078523331
a = 1078523331
f = 3.14
Address of float f is 0x20003F18
fun
fun
fun_int_ptr returns 42
</code></pre>
<p class="normal">The above example demonstrates the usage of <code class="inlineCode">reinterpret_cast</code>. We first initialized a pointer to an int using the address of a float using <code class="inlineCode">reinterpret_cast&lt;int*&gt;(&amp;f)</code>. This is equivalent to using <code class="inlineCode">static_cast</code> as <code class="inlineCode">static_cast&lt;int*&gt;(static_cast&lt;void*&gt;(&amp;f))</code>. We print the value of the dereference integer pointer, and it is <code class="inlineCode">1078523331</code>. This is an actual bit pattern contained in the <code class="inlineCode">float</code> variable <code class="inlineCode">f</code>. It is an IEEE-754 floating point representation of <code class="inlineCode">3.14</code>.</p>
<p class="normal">However, dereferencing the integer pointer initialized by an address of a float is not a defined behavior according to <a id="_idIndexMarker469"/>the C++ standard. This is called <strong class="keyWord">type punning</strong> – treating an object of one type as if it were another type. Using <code class="inlineCode">reinterpet_cast</code> for type punning is common, as it proved to yield expected results on most platforms despite the undefined behavior. There are alternatives that we will discuss after going through this example.</p>
<p class="normal">If we cast the pointer to the integer back to a pointer to a float, it is safe to dereference the resulting pointer.</p>
<p class="normal">Next, we converted the pointer to float to an integer to print the address it contains. We used <code class="inlineCode">std::uintptr_t</code>, an integer type that is capable of holding a pointer to <code class="inlineCode">void</code>. Following this, we initialized <code class="inlineCode">fun_void_ptr</code> – a pointer to a function that returns <code class="inlineCode">void</code> with function <code class="inlineCode">fun</code>, which returns <code class="inlineCode">int</code>. We made a call on the <code class="inlineCode">fun_void_ptr</code> pointer, which printed the <a id="_idIndexMarker470"/>expected output, but it is still undefined. Converting <code class="inlineCode">fun_void_ptr</code> to a pointer that matches the signature of function <code class="inlineCode">fun</code> – <code class="inlineCode">fun_int_ptr</code> – will make <a id="_idIndexMarker471"/>calling fun through the resulting pointer safe.</p>
<p class="normal">Next, we will go through type punning in C++ and the alternatives to using <code class="inlineCode">reinterpret_cast</code> for this task.</p>
<h3 class="heading-3" id="_idParaDest-144">Type punning</h3>
<p class="normal">Using <code class="inlineCode">reinterpret_cast</code> for type punning is a common practice even though it introduces undefined <a id="_idIndexMarker472"/>behavior. Aliasing rules determine how we can access an object in C++, and to put it simply, we can access an object through a pointer and const qualified version of that pointer, a struct or union that contains the object, and through a <code class="inlineCode">char</code>, <code class="inlineCode">unsigned char</code>, and <code class="inlineCode">std::byte</code>.</p>
<p class="normal">We will go through the following example to better understand type punning in C++:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
#include &lt;cstring&gt;
namespace {
struct my_struct {
    int a;
    char c;
};
void print_my_struct (const my_struct &amp; str) {
    printf("a = %d, c = %c\r\n", str.a, str.c);
}
void process_data(const char * data) {
    const auto *pstr = reinterpret_cast&lt;const my_struct *&gt;(data);
    printf("%s\r\n", __func__);
    print_my_struct(pstr[0]);
    print_my_struct(pstr[1]);
}
void process_data_memcpy(const char * data) {
    my_struct my_structs[2];
    std::memcpy(my_structs, data, sizeof(my_structs));
    printf("%s\r\n", __func__);
    print_my_struct(my_structs[0]);
    print_my_struct(my_structs[1]);
}
};
int main() {
    int i = 42;
    auto * i_ptr = reinterpret_cast&lt;char*&gt;(&amp;i);
    if(i_ptr[0]==42) {
        printf("Little endian!\r\n");
    }
    else {
        printf("Big endian!\r\n");
    }
    my_struct my_structs_arr[] = {{4, 'a'}, {5, 'b'}};
    char arr[128];
    std::memcpy(&amp;arr, my_structs_arr, sizeof(my_structs_arr));
    process_data(arr);
    process_data_memcpy(arr);
    return 0;
}
</code></pre>
<p class="normal">You can run <a id="_idIndexMarker473"/>the above example from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter09/type_safety</code> and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_type_punning.cpp"
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Running the example in Renode will provide the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Little endian!
process_data
a = 4, c = a
a = 5, c = b
process_data_memcpy
a = 4, c = a
a = 5, c = b
</code></pre>
<p class="normal">In the example above, we used <code class="inlineCode">reinterpret_cast</code> to treat an integer <code class="inlineCode">i</code> as an array of <code class="inlineCode">chars</code>. By checking the value pointed by the first element of the mentioned array, we can determine if <a id="_idIndexMarker474"/>we are on a big or little-endian system. As per the aliasing rules, this is a valid approach, but treating an array of <code class="inlineCode">chars</code> as some other type would be undefined behavior. We did that in the function void <code class="inlineCode">process_data</code> where we reinterpreted an array of <code class="inlineCode">chars</code> as an array of <code class="inlineCode">my_struct</code> objects. The output of the program is as we would expect it, even though we introduced undefined behavior. To mitigate this issue, we can use <code class="inlineCode">std::memcpy</code>.</p>
<h3 class="heading-3" id="_idParaDest-145">Type punning – the correct way</h3>
<p class="normal">Using <code class="inlineCode">std::memcpy</code> is the only (as of C++23) available option for type punning in C++. In the above example, we demonstrate this in the <code class="inlineCode">process_data_memcpy</code> function. There is usually a concern <a id="_idIndexMarker475"/>of bytes being copied, using additional memory and runtime overhead, but the fact is that the call to <code class="inlineCode">memcpy</code> is usually optimized away by a compiler. You can verify this by running the above example in Compiler Explorer and by experimenting with different optimization levels.</p>
<p class="normal">C++20 introduces <code class="inlineCode">std::bit_cast</code>, which can also be used for type punning, as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;bit&gt;
int main() {
    float f = 3.14f;
    auto a = std::bit_cast&lt;int&gt;(f);
    printf("a = %d\r\n", a);
    return 0;
}
</code></pre>
<p class="normal">The output of the above program is:</p>
<pre class="programlisting con"><code class="hljs-con">a = 1078523331
</code></pre>
<p class="normal">The above example and the program output demonstrate the usage of <code class="inlineCode">std::bit_cast</code> for type punning. The <code class="inlineCode">std::bit_cast</code> will return an object. We specify the type that we are converting to as the template argument. This will also be the return type of the <code class="inlineCode">std::bit_cast</code>. The size of the converting type and the type we are converting to must be the same. This <a id="_idIndexMarker476"/>means <code class="inlineCode">std::bit_cast</code> is not an option for interpreting arrays of one type as arrays of another type, and for that we still need to use <code class="inlineCode">std::memcpy</code>.</p>
<p class="normal">Next, we will see how we can use strong types in C++ to increase type safety.</p>
<h1 class="heading-1" id="_idParaDest-146">Strong types</h1>
<p class="normal">When we talk about type-safety, we should also discuss the safety of interfaces that use commonly available <a id="_idIndexMarker477"/>types such as integers and floats to represent physical units such as time, length, and volume. Let us take a look at the following function from a vendor’s SDK:</p>
<pre class="programlisting code"><code class="hljs-code">/**
  * @brief Start the direct connection establishment procedure.
A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and
process connectable advertising packets only for the specified
device".
  * @param LE_Scan_Interval This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.
  * Values:
  - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param LE_Scan_Window Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.
  * Values:
  - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param Peer_Address_Type The address type of the peer device.
  * Values:
  - 0x00: Public Device Address
  - 0x01: Random Device Address
  * @param Peer_Address Public Device Address or Random Device Address of the device
to be connected.
    * @param Conn_Interval_Min Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.
  * Values:
  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param Conn_Interval_Max Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.
  * Values:
  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param Conn_Latency Slave latency for the connection in number of connection events.
  * Values:
  - 0x0000 ... 0x01F3
  * @param Supervision_Timeout Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.
  * Values:
  - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param Minimum_CE_Length Information parameter about the minimum length of connection needed for this LE connection.
Time = N * 0.625 msec.
  * Values:
  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms)
  * @param Maximum_CE_Length Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.
  * Values:
  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms)
  * @retval Value indicating success or error code.
*/
tBleStatus aci_gap_create_connection(
 uint16_t LE_Scan_Interval,
 uint16_t LE_Scan_Window,
 uint8_t Peer_Address_Type,
 uint8_t Peer_Address[6],
 uint16_t Conn_Interval_Min,
 uint16_t Conn_Interval_Max,
 uint16_t Conn_Latency,
 uint16_t Supervision_Timeout,
 uint16_t Minimum_CE_Length,
 uint16_t Maximum_CE_Length);
</code></pre>
<p class="normal">This is a well-documented function. Still, it takes a lot of effort to understand all the parameters that it accepts and the exact units of each. Most of the parameters represent time but in a different way.</p>
<p class="normal"><code class="inlineCode">LE_Scan_Interval</code>, <code class="inlineCode">LE_Scan_Window</code>, <code class="inlineCode">Conn_Interval_Min</code>, <code class="inlineCode">Conn_Interval_Max</code>, <code class="inlineCode">Supervision_Timeout</code>, <code class="inlineCode">Minimum_CE_Length</code>, and <code class="inlineCode">Maximum_CE_Length</code> are all time-related parameters, but they represent different units. They are either multiples of 0.625, 1.25, or 10 ms. The vendor of the above function also provided the following macros:</p>
<pre class="programlisting code"><code class="hljs-code">#define CONN_L(x) ((int)((x) / 0.625f))
#define CONN_P(x) ((int)((x) / 1.25f))
</code></pre>
<p class="normal">Here is an <a id="_idIndexMarker478"/>example of a call to the above function using the provided macros:</p>
<pre class="programlisting code"><code class="hljs-code">tBleStatus status = aci_gap_create_connection(CONN_L(80), CONN_L(120), PUBLIC_ADDR, mac_addr, CONN_P(50), CONN_P(60), 0, SUPERV_TIMEOUT, CONN_L(10), CONN_L(15));
</code></pre>
<p class="normal">The macros help a bit with readability, but the problem of passing bad values to this function still remains. It is fairly easy to make a mistake, swap the <code class="inlineCode">CONN_L</code> and <code class="inlineCode">CONN_P</code> macros, and introduce a hard-to-find bug to the program. Instead of <code class="inlineCode">uint16_t</code>, we could define and use types <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code>. If we wrap the function with these amendments, we will have the following wrapper function:</p>
<pre class="programlisting code"><code class="hljs-code">tBleStatus aci_gap_create_connection_wrapper(
                            conn_l LE_Scan_Interval,
                            conn_l LE_Scan_Window,
 uint8_t Peer_Address_Type,
 uint8_t Peer_Address[6],
                            conn_p Conn_Interval_Min,
                            conn_p Conn_Interval_Max,
 uint16_t Conn_Latency,
 uint16_t Supervision_Timeout,
                            conn_l Minimum_CE_Length,
                            conn_l Maximum_CE_Length);
</code></pre>
<p class="normal">In the above example, we are using <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code> types instead of <code class="inlineCode">uint16_t</code>, and we will define these types as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class conn_l {
private:
    uint16_t time_;
public:
 explicit conn_l(float time_ms) : time_(time_ms/0.625f){}
    uint16_t &amp; get() {return time_;}
};
class conn_p {
private:
    uint16_t time_;
public:
 explicit conn_p(float time_ms) : time_(time_ms/1.25f){}
    uint16_t &amp; get() {return time_;}
};
</code></pre>
<p class="normal">Using the <a id="_idIndexMarker479"/>above strong types <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code>, we can call the wrapper function as shown below:</p>
<pre class="programlisting code"><code class="hljs-code">    tBleStatus stat = aci_gap_create_connection_wrapper(
            conn_l(80),
            conn_l(120),
            PUBLIC_ADDR,
            nullptr,
            conn_p(50),
            conn_p(60),
            0,
            SUPERV_TIMEOUT,
            conn_l(10),
            conn_l(15)
    );
</code></pre>
<p class="normal">By using the keyword explicit in front of constructors of types <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code>, we make sure that the compiler doesn’t perform implicit conversion from integer types. This makes it impossible to pass an integer or a float that can be used to construct <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code> to the <code class="inlineCode">aci_gap_create_connection_wrapper</code>.</p>
<p class="normal">You can run the entire example from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter09/type_safety</code> and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DMAIN_CPP_FILE_NAME="main_strong_types.cpp"
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Compiling the example successfully means that we passed all the correct arguments to <code class="inlineCode">aci_gap_create_connection_wrapper</code>. As an exercise, try passing integer values instead of <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code> arguments to see how they prevent the compiler from doing implicit conversions. After that, try removing the <code class="inlineCode">explicit</code> keyword from the <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code> constructors to see what will happen.</p>
<p class="normal">We can further <a id="_idIndexMarker480"/>improve the example by introducing a strong-type <code class="inlineCode">time</code> that will represent the time duration, and make it a private member of types <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code>. The code would look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class time {
private:
    uint16_t time_in_ms_;
public:
 explicit time(uint16_t time_in_ms) : time_in_ms_(time_in_ms){}
    uint16_t &amp; get_ms() {return time_in_ms_;}
};
time operator""_ms(unsigned long long t) {
    return time(t);
}
class conn_l {
private:
    uint16_t val_;
public:
 explicit conn_l(time t) : val_(t.get_ms()/0.625f){}
    uint16_t &amp; get() {return val_;}
};
class conn_p {
private:
    uint16_t val_;
public:
 explicit conn_p(time t) : val_(t.get_ms()/1.25f){}
    uint16_t &amp; get() {return val_;}
};
</code></pre>
<p class="normal">In the above example, we created a strong-type time and used it as a private member in types <code class="inlineCode">conn_l</code> and <code class="inlineCode">conn_p</code>. We also created a user-defined literal with <code class="inlineCode">operator""_ms</code> to make the following function call possible:</p>
<pre class="programlisting code"><code class="hljs-code">    tBleStatus stat = aci_gap_create_connection_wrapper(
            conn_l(80_ms),
            conn_l(120_ms),
            PUBLIC_ADDR,
            nullptr,
            conn_p(50_ms),
            conn_p(60_ms),
            0_ms,
            4000_ms,
            conn_l(10_ms),
            conn_l(15_ms)
    );
</code></pre>
<p class="normal">In the above example, we are using the user-defined literal <code class="inlineCode">operator""_ms</code> to create objects of strong-type <a id="_idIndexMarker481"/>time that are used to instantiate conn_l and conn_p objects.</p>
<p class="normal">The above changes to the original interface improve code readability and compile-time error detection. Using strong types, we make it a lot harder to pass wrong values to the function, increasing the type-safety of our codebase.</p>
<h1 class="heading-1" id="_idParaDest-147">Summary</h1>
<p class="normal">Type safety is an important aspect of any programming language used in critical applications. Understanding potential issues of implicit conversion is important to mitigate type-safety concerns. Type punning is another area that deserves special attention in C++, and we learned how to address it properly. We also learned how to use strong types to mitigate issues of passing wrong values to parameters with the same types.</p>
<p class="normal">Next, we will cover lambdas in C++.</p>
<h1 class="heading-1" id="_idParaDest-148">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>
</body></html>