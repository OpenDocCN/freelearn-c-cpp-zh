["```cpp\nLogContentBrowser: Native class hierarchy updated for \n 'HierarchicalLODOutliner' in 0.0011 seconds. Added 1 classes and 2 \n folders. \nLogLoad: Full Startup: 8.88 seconds (BP compile: 0.07 seconds) \nLogStreaming:Warning: Failed to read file \n '../../../Engine/Content/Editor/Slate/Common/Selection_16x.png' \n error. \nLogExternalProfiler: Found external profiler: VSPerf \n```", "```cpp\nUE_LOG( LogTemp, Warning, TEXT( \"Message %d\" ), 1 ); \n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n\nDECLARE_LOG_CATEGORY_EXTERN(LogCh11, Log, All);\n```", "```cpp\n#include \"Chapter_11.h\"\n#include \"Modules/ModuleManager.h\"\n\nIMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, Chapter_11, \"Chapter_11\" );\n\nDEFINE_LOG_CATEGORY(LogCh11);\n```", "```cpp\nUCLASS()\nclass CHAPTER_11_API AChapter_11GameModeBase : public AGameModeBase\n{\n    GENERATED_BODY()\n\n    void BeginPlay();\n};\n```", "```cpp\n#include \"Chapter_11GameModeBase.h\"\n#include \"Chapter_11.h\"\n\nvoid AChapter_11GameModeBase::BeginPlay()\n{\n // Traditional Logging\n UE_LOG(LogTemp, Warning, TEXT(\"Message %d\"), 1);\n\n // Our custom log type\n UE_LOG(LogCh11, Display, TEXT(\"A display message, log is working\" ) ); // shows in gray \n UE_LOG(LogCh11, Warning, TEXT(\"A warning message\"));\n UE_LOG(LogCh11, Error, TEXT(\"An error message \"));\n}\n```", "```cpp\nLog LogName off // Stop LogName from displaying at the output \nLog LogName Log // Turn LogName's output on again \n```", "```cpp\n#define LOCTEXT_NAMESPACE \"Chapter11Namespace\"\n```", "```cpp\n#define LOCTEXT_NAMESPACE \"Chapter11Namespace\"\n#define FTEXT(x) LOCTEXT(x, x) \n\nextern FName LoggerName;\n\nvoid CreateLog(FName logName);\n```", "```cpp\n#include \"Chapter_11.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"MessageLog/Public/MessageLogModule.h\"\n#include \"MessageLog.h\"\n\n// ...\n\nFName LoggerName(\"MessageLogChapter11\");\n\nvoid CreateLog(FName logName)\n{\n    FMessageLogModule& MessageLogModule = FModuleManager::LoadModuleChecked<FMessageLogModule>(\"MessageLog\");\n    FMessageLogInitializationOptions InitOptions;\n    InitOptions.bShowPages = true;\n    InitOptions.bShowFilters = true;\n    FText LogListingName = FTEXT(\"Chapter 11's Log Listing\");\n    MessageLogModule.RegisterLogListing(logName, LogListingName, InitOptions);\n}\n```", "```cpp\nvoid AChapter_11GameModeBase::BeginPlay()\n{\n    // 11-01 - Core/Logging API - Defining a custom log\n    // category\n    // Traditional Logging\n    UE_LOG(LogTemp, Warning, TEXT(\"Message %d\"), 1);\n\n    // Our custom log type\n    UE_LOG(LogCh11, Display, TEXT(\"A display message, log is working\" ) ); // shows in gray \n    UE_LOG(LogCh11, Warning, TEXT(\"A warning message\"));\n    UE_LOG(LogCh11, Error, TEXT(\"An error message \"));\n\n // 11-02 - Core/Logging API - FMessageLog to write \n    // messages to the Message Log\n CreateLog(LoggerName);\n // Retrieve the Log by using the LoggerName. \n FMessageLog logger(LoggerName);\n logger.Warning(FTEXT(\"A warning message from gamemode\"));\n}\n```", "```cpp\nlogger.Info( FTEXT( \"Info to log\" ) ); \nlogger.Warning( FTEXT( \"Warning text to log\" ) ); \nlogger.Error( FTEXT( \"Error text to log\" ) ); \n```", "```cpp\nFRotator( float InPitch, float InYaw, float InRoll ); \n```", "```cpp\nFRotator rotator( 0, GetWorld()->TimeSeconds, 0 ); \n```", "```cpp\n// Called every frame\nvoid URotateActorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n FRotator rotator(0, GetWorld()->TimeSeconds, 0);\n GetOwner()->SetActorRotation(rotator);\n}\n```", "```cpp\nFQuat( FVector Axis, float AngleRad ); \n```", "```cpp\nvoid URotateActorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n    // 11-04 - Rotation using FQuat\n FQuat quat = FQuat(FVector(0, 1, 0), GetWorld()->TimeSeconds * PI / 4.f);\n GetOwner()->SetActorRotation(quat);\n\n}\n```", "```cpp\nFQuat( FVector( 1, 0, 0 ), PI/4.f ) * \nFQuat( FVector( 0, 1, 0 ), PI/4.f ); \n```", "```cpp\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass CHAPTER_11_API UFollowActorComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this component's properties\n    UFollowActorComponent();\n\nprotected:\n    // Called when the game starts\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n    UPROPERTY(EditAnywhere)\n AActor * target;\n};\n```", "```cpp\n// Called every frame\nvoid UFollowActorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n FVector toFollow = target->GetActorLocation() - GetOwner()->GetActorLocation();\n\n FMatrix rotationMatrix = FRotationMatrix::MakeFromXZ(toFollow, GetOwner()->GetActorUpVector());\n\n GetOwner()->SetActorRotation(rotationMatrix.Rotator());\n\n}\n```", "```cpp\nFRotationMatrix rotationMatrix = FRotationMatrix::MakeFromXY( \n lookAlong, right ); \nactor->SetActorRotation( rotationMatrix.Rotator() ); \n```", "```cpp\nusing UnrealBuildTool;\n\npublic class Chapter_11 : ModuleRules\n{\n    public Chapter_11(ReadOnlyTargetRules Target) : \n    base(Target)\n    {\n        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n\n        PublicDependencyModuleNames.AddRange(new string[] {\n        \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\" });\n        PublicDependencyModuleNames.AddRange(new string[] {  \n        \"GameplayAbilities\", \"GameplayTags\", \"GameplayTasks\" });\n\n        PrivateDependencyModuleNames.AddRange(new string[] { });\n    }\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Abilities/GameplayAbility.h\"\n#include \"GameplayAbility_Attack.generated.h\"\n\nUCLASS()\nclass CHAPTER_11_API UGameplayAbility_Attack : public UGameplayAbility\n{\n  GENERATED_BODY()\n\n /** Returns true if this ability can be activated\n        right now. Has no side effects */\n virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const {\n UE_LOG(LogTemp, Warning, TEXT(\"ability_attack \n        CanActivateAbility!\"));\n return true;\n }\n\n /** Checks cost. returns true if we can pay for the\n    ability. False if not */\n virtual bool CheckCost(const FGameplayAbilitySpecHandle Handle, \n    const FGameplayAbilityActorInfo* ActorInfo, OUT \n    FGameplayTagContainer* OptionalRelevantTags = nullptr) const {\n UE_LOG(LogTemp, Warning, TEXT(\"ability_attack CheckCost!\"));\n return true;\n //return Super::CheckCost( Handle, ActorInfo, \n        //OptionalRelevantTags );\n }\n\n virtual void ActivateAbility(const FGameplayAbilitySpecHandle \n    Handle,\n const FGameplayAbilityActorInfo* ActorInfo, const \n        FGameplayAbilityActivationInfo ActivationInfo,\n const FGameplayEventData* TriggerEventData)\n {\n UE_LOG(LogTemp, Warning, TEXT(\"Activating \n        ugameplayability_attack().. swings weapon!\"));\n Super::ActivateAbility(Handle, ActorInfo, ActivationInfo,  \n        TriggerEventData);\n }\n\n /** Input binding stub. */\n virtual void InputPressed(const FGameplayAbilitySpecHandle \n    Handle, const FGameplayAbilityActorInfo* ActorInfo, const \n    FGameplayAbilityActivationInfo ActivationInfo) {\n UE_LOG(LogTemp, Warning, TEXT(\"ability_attack \n        inputpressed!\"));\n Super::InputPressed(Handle, ActorInfo, ActivationInfo);\n }\n\n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameplayAbilitySet.h\"\n#include \"AbilitySystemInterface.h\"\n#include \"Warrior.generated.h\"\n\n#define FS(x,...) FString::Printf( TEXT( x ), __VA_ARGS__ )\n\nUCLASS()\nclass CHAPTER_11_API AWarrior : public ACharacter, public IAbilitySystemInterface\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AWarrior();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n // Lists key triggers for various abilities for the \n    // player.\n // Selects an instance of UGameplayAbilitySet (which is a      //    \\\n    UDataAsset derivative\n // that you construct in the Content Browser).\n UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n    Stats)\n UGameplayAbilitySet* gameplayAbilitySet;\n\n // The AbilitySystemComponent itself\n UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n    Stats)\n UAbilitySystemComponent* AbilitySystemComponent;\n\n // IAbilitySystemInterface implementation:\n virtual UAbilitySystemComponent* GetAbilitySystemComponent() const { return AbilitySystemComponent; }\n\n};\n\n```", "```cpp\n#include \"AbilitySystemComponent.h\"\n\n// ...\n\n// Called to bind functionality to input\nvoid AWarrior::SetupPlayerInputComponent(UInputComponent* Input)\n{\n    Super::SetupPlayerInputComponent(Input);\n\n    // Connect the class's AbilitySystemComponent \n    // to the actor's input component \n    AbilitySystemComponent->BindToInputComponent(Input);\n\n    // Go thru each BindInfo in the gameplayAbilitySet. \n    // Give & try and activate each on the \n    // AbilitySystemComponent. \n    for (const FGameplayAbilityBindInfo& BindInfo :\n        gameplayAbilitySet->Abilities)\n    {\n\n        FGameplayAbilitySpec spec(\n            // Gets you an instance of the UClass \n            BindInfo.GameplayAbilityClass->\n            GetDefaultObject<UGameplayAbility>(),\n            1, (int32)BindInfo.Command);\n\n        // STORE THE ABILITY HANDLE FOR LATER INVOKATION \n        // OF THE ABILITY \n        FGameplayAbilitySpecHandle abilityHandle =\n            AbilitySystemComponent->GiveAbility(spec);\n\n        // The integer id that invokes the ability \n        // (ith value in enum listing) \n        int32 AbilityID = (int32)BindInfo.Command;\n\n        // CONSTRUCT the inputBinds object, which will \n        // allow us to wire-up an input event to the \n        // InputPressed() / InputReleased() events of \n        // the GameplayAbility. \n        FGameplayAbilityInputBinds inputBinds(\n            // These are supposed to be unique strings that \n            // define what kicks off the ability for the actor        \n            // instance. \n            // Using strings of the format \n            // \"ConfirmTargetting_Player0_AbilityClass\" \n            FS(\"ConfirmTargetting_%s_%s\", *GetName(),\n                *BindInfo.GameplayAbilityClass->GetName()),\n            FS(\"CancelTargetting_%s_%s\", *GetName(),\n                *BindInfo.GameplayAbilityClass->GetName()),\n            \"EGameplayAbilityInputBinds\", // The name of the\n            // ENUM that has the abilities listing\n            // (GameplayAbilitySet.h). \n            AbilityID, AbilityID\n        );\n        // MUST BIND EACH ABILITY TO THE INPUTCOMPONENT,\n        // OTHERWISE THE ABILITY CANNOT \"HEAR\" INPUT EVENTS. \n        // Enables triggering of InputPressed() / \n        // InputReleased() events, which you can in-turn use \n        // to call \n        // TryActivateAbility() if you so choose. \n        AbilitySystemComponent->BindAbilityActivationToInputComponent(\n            Input, inputBinds\n        );\n\n        // Test-kicks the ability to active state. \n        // You can try invoking this manually via your \n        // own hookups to keypresses in this Warrior class \n        // TryActivateAbility() calls ActivateAbility() if \n        // the ability is indeed invokable at this time \n        // according to rules internal to the Ability's class \n        // (such as cooldown is ready and cost is met) \n        AbilitySystemComponent->TryActivateAbility(\n            abilityHandle, 1);\n    }\n}\n\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AttributeSet.h\"\n#include \"GameUnitAttributeSet.generated.h\"\n\n/**\n * \n */\nUCLASS(Blueprintable, BlueprintType)\nclass CHAPTER_11_API UGameUnitAttributeSet : public UAttributeSet\n{\n    GENERATED_BODY()\n\npublic:\n UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes)\n float Hp;\n\n UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes)\n float Mana;\n\n UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes)\n float Speed;\n};\n\n```", "```cpp\nvirtual void PostInitializeComponents() override;\n```", "```cpp\n#include \"GameUnitAttributeSet.h\"\n```", "```cpp\nvoid AWarrior::PostInitializeComponents()\n{\n    Super::PostInitializeComponents();\n\n    if(AbilitySystemComponent)\n    {\n        AbilitySystemComponent->InitStats(UGameUnitAttributeSet::StaticClass(), NULL);\n    }\n}\n```", "```cpp\nvoid TestGameplayEffect();\n```", "```cpp\ninline UGameplayEffect* ConstructGameplayEffect(FString name)\n{\n    return NewObject<UGameplayEffect>(GetTransientPackage(), FName(*name));\n}\n\ninline FGameplayModifierInfo& AddModifier(\n    UGameplayEffect* Effect, UProperty* Property,\n    EGameplayModOp::Type Op,\n    const FGameplayEffectModifierMagnitude& Magnitude)\n{\n    int32 index = Effect->Modifiers.Num();\n    Effect->Modifiers.SetNum(index + 1);\n    FGameplayModifierInfo& Info = Effect->Modifiers[index];\n    Info.ModifierMagnitude = Magnitude;\n    Info.ModifierOp = Op;\n    Info.Attribute.SetUProperty(Property);\n    return Info;\n}\n```", "```cpp\nvoid AWarrior::TestGameplayEffect()\n{\n    // Construct & retrieve UProperty to affect\n    UGameplayEffect* RecoverHP = ConstructGameplayEffect(\"RecoverHP\");\n\n    // Compile-time checked retrieval of Hp UPROPERTY()\n    // from our UGameUnitAttributeSet class (listed in\n    // UGameUnitAttributeSet.h)\n    UProperty* hpProperty = FindFieldChecked<UProperty>(\n        UGameUnitAttributeSet::StaticClass(),\n        GET_MEMBER_NAME_CHECKED(UGameUnitAttributeSet, Hp));\n\n}\n```", "```cpp\n  // Command the addition of +5 HP to the hpProperty\n  AddModifier(RecoverHP, hpProperty, EGameplayModOp::Additive, FScalableFloat(50.f));\n```", "```cpp\n// .. for a fixed-duration of 10 seconds ..\nRecoverHP->DurationPolicy = EGameplayEffectDurationType::HasDuration;\nRecoverHP->DurationMagnitude = FScalableFloat(10.f);\n\n// .. with 100% chance of success ..\nRecoverHP->ChanceToApplyToTarget = 1.f;\n\n// .. with recurrency (Period) of 0.5 seconds\nRecoverHP->Period = 0.5f;\n```", "```cpp\nFActiveGameplayEffectHandle recoverHpEffectHandle =\n    AbilitySystemComponent->ApplyGameplayEffectToTarget(\n        RecoverHP, AbilitySystemComponent, 1.f);\n```", "```cpp\nFOnActiveGameplayEffectRemoved* ep = AbilitySystemComponent->\n    OnGameplayEffectRemovedDelegate(recoverHpEffectHandle);\n\nif (ep) \n{\n    ep->AddLambda([]() \n    {\n        UE_LOG(LogTemp, Warning, TEXT(\"Recover effect has been removed.\"), 1);\n    });\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTask.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"GameplayTask_CreateParticles.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass CHAPTER_11_API UGameplayTask_CreateParticles : public UGameplayTask\n{\n    GENERATED_BODY()\n\npublic:\n virtual void Activate();\n\n // A static constructor for an instance of a \n    // UGameplayTask_CreateEmitter instance,\n // including args of (what class of emitter, where to \n    // create it).\n UFUNCTION(BlueprintCallable, Category = \"GameplayTasks\", meta = (AdvancedDisplay = \"TaskOwner\", DefaultToSelf = \"TaskOwner\", BlueprintInternalUseOnly = \"TRUE\"))\n static UGameplayTask_CreateParticles* ConstructTask(\n TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner,\n UParticleSystem* particleSystem,\n FVector location);\n\n UParticleSystem* ParticleSystem;\n FVector Location;\n\n};\n```", "```cpp\n#include \"GameplayTask_CreateParticles.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Like a constructor.\nUGameplayTask_CreateParticles* UGameplayTask_CreateParticles::ConstructTask(\n TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner,\n UParticleSystem* particleSystem,\n FVector location)\n{\n UGameplayTask_CreateParticles* task = \n    NewTask<UGameplayTask_CreateParticles>(TaskOwner);\n // Fill fields\n if (task)\n {\n task->ParticleSystem = particleSystem;\n task->Location = location;\n }\n return task;\n}\n\nvoid UGameplayTask_CreateParticles::Activate()\n{\n Super::Activate();\n\n UGameplayStatics::SpawnEmitterAtLocation(GetWorld(),\n    ParticleSystem, Location);\n}\n```", "```cpp\nUCLASS()\nclass CHAPTER_11_API AWarrior : public ACharacter, public IAbilitySystemInterface, public IGameplayTaskOwnerInterface\n{\n    GENERATED_BODY()\n```", "```cpp\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)\n    UGameplayTasksComponent* GameplayTasksComponent;\n\n    // This is the particleSystem that we create with the\n    // GameplayTask_CreateParticles object.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)\n    UParticleSystem* particleSystem;\n```", "```cpp\n    // <GameplayTaskOwnerInterface>\n\n    virtual UGameplayTasksComponent* GetGameplayTasksComponent(const \n    UGameplayTask& Task) const { return GameplayTasksComponent; }\n\n    // This gets called both when task starts and when task gets \n    // resumed.\n    // Check Task.GetStatus() if you want to differentiate.\n    virtual void OnTaskActivated(UGameplayTask& Task) { }\n    virtual void OnTaskDeactivated(UGameplayTask& Task) { }\n\n    virtual AActor* GetOwnerActor(const UGameplayTask* Task) const {\n        return Task->GetOwnerActor(); // This will give us the \n    // accurate answer for the Task..\n    }\n    // </End GameplayTaskOwnerInterface>\n```", "```cpp\nAWarrior::AWarrior()\n{\n    // Set this character to call Tick() every frame. You can \n    // turn this off to improve performance if you don't need \n    // it.\n    PrimaryActorTick.bCanEverTick = true;\n    AbilitySystemComponent = CreateDefaultSubobject<UAbilitySystemComponent>\n    (\"UAbilitySystemComponent\");\n    GameplayTasksComponent = CreateDefaultSubobject<UGameplayTasksComponent>\n    (\"UGameplayTasksComponent\");\n}\n```", "```cpp\n    UGameplayTask_CreateParticles* task =\n        UGameplayTask_CreateParticles::ConstructTask(this,\n        particleSystem, FVector(200.f, 0.f, 200.f));\n\n    if (GameplayTasksComponent && task)\n    {\n        GameplayTasksComponent->AddTaskReadyForActivation(*task);\n    }\n```", "```cpp\nusing UnrealBuildTool;\n\npublic class Chapter_11 : ModuleRules\n{\n    public Chapter_11(ReadOnlyTargetRules Target) : base(Target)\n    {\n        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n\n        PublicDependencyModuleNames.AddRange(new string[] {\n        \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\" });\n        PublicDependencyModuleNames.AddRange(new string[] { \n        \"GameplayAbilities\", \"GameplayTags\", \"GameplayTasks\" });\n PublicDependencyModuleNames.AddRange(new string[] {\n        \"HTTP\" });\n\n        PrivateDependencyModuleNames.AddRange(new string[] { });\n\n        // Uncomment if you are using Slate UI\n        // PrivateDependencyModuleNames.AddRange(new string[]\n        // { \"Slate\", \"SlateCore\" });\n\n        // Uncomment if you are using online features\n        // PrivateDependencyModuleNames.Add(\"OnlineSubsystem\");\n\n        // To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true\n    }\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"Runtime/Online/HTTP/Public/HttpManager.h\" \n#include \"Runtime/Online/HTTP/Public/HttpModule.h\" \n#include \"Runtime/Online/HTTP/Public/HttpRetrySystem.h\" \n#include \"Runtime/Online/HTTP/Public/Interfaces/IHttpResponse.h\"\nusing namespace FHttpRetrySystem;\n#include \"Chapter_11GameModeBase.generated.h\"\n```", "```cpp\nTSharedRef<IHttpRequest> \n http=FHttpModule::Get().CreateRequest();\n```", "```cpp\nvoid HttpRequestComplete( FHttpRequestPtr request,\n FHttpResponsePtr response, bool success );\n```", "```cpp\nFHttpRequestCompleteDelegate& delegate = http-\n >OnProcessRequestComplete();\n```", "```cpp\ndelegate.BindLambda( \n  // Anonymous, inlined code function (aka lambda) \n  []( FHttpRequestPtr request, FHttpResponsePtr response, bool \n   success ) -> void \n{ \n  UE_LOG( LogTemp, Warning, TEXT( \"Http Response: %d, %s\" ), \n  request->GetResponse()->GetResponseCode(), \n  *request->GetResponse()->GetContentAsString() ); \n}); \n```", "```cpp\nhttp->SetURL( TEXT( \"http://unrealengine.com\" ) ); \n```", "```cpp\nhttp->ProcessRequest();\n```", "```cpp\ndelegate.BindUObject(this, &AChapter_11GameModeBase::HttpRequestComplete);\n```", "```cpp\nPlainObject* plainObject = new PlainObject();\ndelegate.BindRaw( plainObject, &PlainObject::httpHandler );\n // plainObject cannot be DELETED Until httpHandler gets\n // called..\n```", "```cpp\n// C-style function for handling the HTTP response: \nvoid httpHandler( FHttpRequestPtr request,  \nFHttpResponsePtr response, bool success ) \n{ \n  Info( \"static: Http req handled\" ); \n} \ndelegate.BindStatic( &httpHandler ); \n```", "```cpp\nHandleRequestProgress( FHttpRequestPtr request, int32 \n sentBytes, int32 receivedBytes )\n```", "```cpp\nTSharedRef<IHttpRequest> http = \n HttpModule::Get().CreateRequest();\n```", "```cpp\nhttp->OnRequestProgress().BindLambda(\n    [this](FHttpRequestPtr request, int32 sentBytes, int32\n    receivedBytes)\n    -> void\n    {\n        int32 contentLen =\n        request->GetResponse()->GetContentLength();\n        float percentComplete = 100.f * receivedBytes /\n        contentLen;\n\n        UE_LOG(LogTemp, Warning, TEXT(\"Progress sent=%d bytes /\n        received=%d/%d bytes [%.0f%%]\"), sentBytes, receivedBytes,\n        contentLen, percentComplete);\n\n    });\n```"]