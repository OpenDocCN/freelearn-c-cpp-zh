["```cpp\nclass X {\npublic:\n    // #0 delegates to #1 which delegates to #0 which...\n    X(float x) : X{ static_cast<int>(x) } { // #0\n    }\n    X(int n) : X{ n + 0.5f } { // #1\n    }\n};\nint main() {}\n```", "```cpp\nint g(int);\nint f(int *p) {\n    if(p != nullptr)\n        return g(*p); // Ok, we know p is not null\n    return *p; // oops, if p == nullptr this is UB\n}\n```", "```cpp\nint main() {\n    // our code supposes int is four bytes wide, a non-\n    // portable assumption\n    static_assert(sizeof(int)==4);\n    // only compiles if condition is true...\n}\n```", "```cpp\nint f(int); // declaration\nint f(int n); // Ok, declaration again\nint f(int m) { return m; } // Ok, definition\n// int f(int) { return 3; } // not Ok (ODR violation)\n```", "```cpp\nvoid f(int);\nint main() {\n    int vals[]{ 2,3,5,7,11 };\n    enum { N = sizeof vals / sizeof vals[0] };\n    for(int i = 0; i != N; ++i) // A\n      f(vals[i]);\n    for(int *p = vals; p != vals + N; ++p) // B\n      f(*p);\n}\n```", "```cpp\nint arr[10]{ }; // all elements initialized to zero\nint *p = &arr[3];\np += 4; assert(p == &arr[7]);\n--p;    assert(p == &arr[6]);\np += 4; // still Ok as long as you don't try to access *p\n++p; // UB, not guaranteed to be valid\n```", "```cpp\nstruct X { int n; };\nstruct Y : X {};\nunion U { X x; short s; };\nint main() {\n    X x;\n    Y y;\n    U u;\n    // x is pointer-interconvertible with x\n    // u is pointer-interconvertible with u.x\n    // u is pointer-interconvertible with u.s\n    // y is pointer-interconvertible with y.x\n}\n```", "```cpp\nstruct A {\n    int a;\n    short s;\n};\nshort * f(A &a) {\n    // pointer interconvertibility in action!\n    int *p = reinterpret_cast<int*>(&a);\n    p++;\n    return reinterpret_cast<short*>(p); // Ok, within the\n                                       // same object\n}\nint main() {\n    A a;\n    short *p = f(a);\n    *p = 3; // fine, technically\n}\n```", "```cpp\nint f(int); //#0\nint f(char*); // #1\nint main() {\n    int n = 3;\n    char c;\n    f(n); // calls #0\n    f(&c); // calls #1\n    f(0); // ambiguous before C++11, calls #0 since\n    f(nullptr); // only since C++11; unambiguously calls #1\n}\n```", "```cpp\ntemplate <class T> class Array {\n    T *elems = nullptr; // pointer to the beginning\n    std::size_t nelems = 0; // number of elements\npublic:\n    Array() = default; // =empty array\n    // ...\n    auto size() const noexcept { return nelems; }\n    // note: could return nullptr\n    auto begin() noexcept { return elems; }\n    auto end() noexcept { return begin() + size(); }\n};\n```", "```cpp\nstruct X {\n    char c[5]; short s;\n} x;\n// one byte of padding between x.c and x.s\nstatic_assert(sizeof x.s == 2 && sizeof x == 8);\nstatic_assert(alignof(x) == alignof(short));\nunion U {\n    int n; X x;\n} u;\nstatic_assert(sizeof u == sizeof u.x);\nstatic_assert(alignof(u) == alignof(u.n));\nint main() {}\n```", "```cpp\nunion U {\n    float f;\n    int n;\n};\nconstexpr int f() {\n    U u{ 1.5f };\n    return u.n; // UB (u.f is the active member)\n}\nint main() {\n    // constexpr auto r0 = f(); // would not compile\n    auto r1 = f(); // compiles, as not a constexpr\n                  // context, but still UB\n}\n```", "```cpp\nstruct A { int n; float f; char c; };\nstruct B{ const int b0; volatile float x; };\n```", "```cpp\nstruct A { int n0; char c0; };\nstruct B { int n1; char c1; float x; };\nunion U {\n    A a;\n    B b;\n};\nint f() {\n    U u{ { 1, '2' } }; // initializes u.a\n    return u.b.n1; // not UB\n}\nint main() {\n    return f(); // Ok\n}\n```", "```cpp\n#include <iostream>\n#include <cstdint>\nint main() {\n    using namespace std;\n    int m,\n       n;\n    // simply comparing &m with &n is not allowed\n    if(reinterpret_cast<intptr_t>(&m) <\n      reinterpret_cast<intptr_t>(&n))\n      cout << \"m precedes n in address order\\n\";\n    else\n      cout << \"n precedes m in address order\\n\";\n}\n```", "```cpp\n// suppose this holds for this example\nstatic_assert(sizeof(int) == sizeof(float));\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\nint main() {\n    float f = 1.5f;\n    void *p = malloc(sizeof f);\n    assert(p);\n    int *q = std::memcpy(p, &f, sizeof f);\n    int value = *q; // UB\n    //\n}\n```", "```cpp\n// suppose this holds for this example\nstatic_assert(sizeof(int) == sizeof(float));\n#include <cassert>\n#include <cstring>\nint main() {\n    float f = 1.5f;\n    int value;\n    std::memcpy(&value, &f, sizeof f); // Ok\n    // ...\n}\n```", "```cpp\nstatic_assert(sizeof(short) == 2);\n#include <memory>\nint main() {\n    char buf[]{ 0x00, 0x01, 0x02, 0x03 };\n    short* p = std::start_lifetime_as<short>(buf);\n    // use *p as a short\n}\n```"]