["```cpp\n#include <cstdint>\nclass super_video_card {\n  // ...\npublic:\n  // super duper registers\n  volatile std::uint32_t r0{}, r1{}, r2{}, r3{};\n  static_assert(sizeof(float) == 4); // sanity check\n  volatile float f0{}, f1{}, f2{}, f3{};\n  // etc.\n  // initialize the video card's state\n  super_video_card() = default;\n  super_video_card(const super_video_card&) = delete;\n  super_video_card&\n    operator=(const super_video_card&) = delete;\n  // could be used to reset the video card's state\n  ~super_video_card() = default;\n  // various services (omitted for brevity)\n};\n// ...\n```", "```cpp\n// somewhere in memory where we have read / write\n// access privileges is a memory-mapped hardware\n// that corresponds to the actual device\nalignas(super_video_card) char\n  mem_mapped_device[sizeof(super_video_card)];\nvoid* get_super_card_address() {\n  return mem_mapped_device;\n}\n// ...\n```", "```cpp\n// ...\n#include <new>\nint main() {\n  // map our object to the hardware\n  void* p = get_super_card_address();\n  auto the_card =\n      new(p) super_video_card{ /* args */ };\n  // through pointer the_card, use the actual memory-\n  // mapped hardware\n  // ...\n  the_card->~super_video_card();\n}\n```", "```cpp\n// ...\n#include <new>\n#include <memory>\nint main() {\n  // map our object to the hardware\n  void* p = get_super_card_address();\n  std::unique_ptr<\n      super_video_card,\n      decltype([](super_video_card *p) {\n        p->~super_video_card(); // do not call delete p!\n      })\n  > the_card {\n      new(p) super_video_card{ /* args */ }\n};\n  // through pointer the_card, use the actual memory-\n  // mapped hardware\n   // ...\n   // implicit call to the_card->~super_video_card()\n}\n```", "```cpp\n#include <new>\n#include <iostream>\nstruct X {\n  int n;\n  X(int n) : n { n } { }\n};\nint main() {\n  auto p = new (std::nothrow) X{ 3 };\n  std::cout << p->n; // <-- HERE\n  delete p;\n}\n```", "```cpp\n#include <new>\n#include <iostream>\nstruct X {\n  int n;\n  X(int n) : n { n } { }\n};\nint main() {\n  auto p = new (std::nothrow) X{ 3 };\n  if(p) {\n      std::cout << p->n; // ...use *p as needed...\n  }\n  delete p; // fine even in p is null\n}\n```", "```cpp\n#include <new>\n#include <iostream>\nstruct X {\n  int n;\n  X(int n) : n { n } { }\n};\nint main() {\n  auto p = new X{ 3 }; // throws if operator new() or\n                        // X::X(int) fails\n  std::cout << p->n; // ...use *p as needed...\n  delete p;\n}\n```", "```cpp\n// ...\nint *p = new int{ 3 };\nif(!p) std::abort(); // for example\nreturn p;\n// ...\n```", "```cpp\n#include <new>\n#include <cstdlib>\n#define TRY_NEW(T,...) [&] { \\\n  auto p = new (std::nothrow) T(__VA_ARGS__); \\\n  if(!p) std::abort(); \\\n  return p; \\\n}()\nstruct dies_when_newed {\n  void* operator new(std::size_t, std::nothrow_t) {\n      return {};\n  }\n};\nint main() {\n  // p0 is int*, points to an int{ 0 }\n  auto p0 = TRY_NEW(int);\n  // p1 is int*, points to an int{ 3 }\n  auto p1 = TRY_NEW(int, 3);\n  auto q = TRY_NEW(dies_when_newed); // calls abort()\n}\n```", "```cpp\n#include <new>\n#include <cstdlib>\n#include <utility>\ntemplate <class T, class ... Args>\n  auto try_new(Args &&... args) {\n      auto p =\n        new (std::nothrow) T(std::forward<Args>(args)...);\n      if(!p) std::abort();\n      return p;\n  }\nstruct dies_when_newed {\n  void* operator new(std::size_t, std::nothrow_t) {\n      return {};\n  }\n};\nint main() {\n  // p0 is int*, points to an int{ 0 }\n  auto p0 = try_new<int>();\n  // p1 is int*, points to an int{ 3 }\n  auto p1 = try_new<int>(3);\n  auto q = try_new<dies_when_newed>(); // calls abort()\n}\n```", "```cpp\n#include <new>\n#include <vector>\n#include <iostream>\nstruct X {\n  // toy example, not thread-safe\n  static inline int limit = 5;\n  void* operator new(std::size_t n) {\n      std::cout << \"X::operator new() called with \"\n                << limit << \" blocks left\\n\";\n      while (limit <= 0) {\n        if (auto hdl = std::get_new_handler(); hdl)\n            hdl();\n        else\n            throw std::bad_alloc{};\n      }\n      --limit;\n      return ::operator new(n);\n  }\n  void operator delete(void* p) {\n      std::cout << \"X::operator delete()\\n\";\n      ::operator delete(p);\n  }\n  // same for the array versions\n};\nint main() {\n  std::set_new_handler([]() noexcept {\n      std::cout << \"allocation failure, \"\n                   \"fetching more memory\\n\";\n      X::limit = 10;\n      std::set_new_handler(nullptr); // as per default\n  });\n  std::vector<X*> v;\n  v.reserve(100);\n  try {\n      for (int i = 0; i != 10; ++i)\n         v.emplace_back(new X);\n  } catch(...) {\n      // this will never be reached with this program\n      std::cerr << \"out of memory\\n\";\n  }\n  for (auto p : v) delete p;\n}\n```", "```cpp\n// ...\n#include <cstddef> // std::size_t\n#include <new> // std::bad_alloc\n#include <utility> // std::pair\nclass invalid_shared_mem_key {};\nenum shared_mem_id : std::size_t;\nshared_mem_id create_shared_mem(std::size_t size);\nstd::pair<void*, std::size_t>\n  get_shared_mem(shared_mem_id);\nvoid destroy_shared_mem(shared_mem_id);\n// ...\n```", "```cpp\n// ...\n#include <vector>\n#include <memory>\n#include <utility>\nstruct shared_mem_block {\n  std::unique_ptr<char[]> mem;\n  std::size_t size;\n};\nstd::vector<shared_mem_block> shared_mems;\nstd::pair<void*, std::size_t>\n  get_shared_mem(shared_mem_id id) {\n  if (id < std::size(shared_mems))\n      return { shared_mems[id].mem.get(),\n               shared_mems[id].size };\n  return { nullptr, 0 };\n}\nshared_mem_id create_shared_mem(std::size_t size) {\n  auto p = std::make_unique<char[]>(size);\n  shared_mems.emplace_back(std::move(p), size);\n  // note the parentheses\n  return shared_mem_id(std::size(shared_mems) - 1);\n}\n// function for internal purposes only\nbool is_valid_shared_mem_key(shared_mem_id id) {\n  return id < std::size(shared_mems) &&\n         shared_mems[id].mem;\n}\nvoid destroy_shared_mem(shared_mem_id id) {\n  if (!is_valid_shared_mem_key(id))\n      throw invalid_shared_mem_key{};\n  shared_mems[id].mem.reset();\n}\n```", "```cpp\nstruct data {\n  bool ready;\n  int value;\n};\n```", "```cpp\n// ...\n#include <thread>\n#include <atomic>\n#include <iostream>\nint main() {\n  // we need a N-bytes shared memory block\n  constexpr std::size_t N = 1'000'000;\n  auto key = create_shared_mem(N);\n  // map a data object in the shared memory block\n  auto [p, sz] = get_shared_mem(key);\n  if (!p) return -1;\n  // start the lifetime of a non-ready data object\n  auto p_data = new (p) data{ false };\n  std::atomic<bool> go{ false };\n  std::atomic<bool> done{ false };\n  std::jthread writer{ [key, &go] {\n      go.wait(false);\n      auto [p, sz] = get_shared_mem(key);\n      if (p) {\n        auto p_data = static_cast<data*>(p);\n        p_data->value = 3;\n        std::atomic_thread_fence(\n            std::memory_order_release\n        );\n        p_data->ready = true;\n      }\n  } };\n  std::jthread reader{ [key, &done] {\nauto [p, sz] = get_shared_mem(key);\n      if (p) {\n        auto p_data = static_cast<data*>(p);\n        while (!p_data->ready)\n            ; // busy waiting, not cool\n        std::cout << \"read value \"\n                  << p_data->value << '\\n';\n      }\n      done = true;\n      done.notify_all();\n  } };\n  if (char c; !std::cin.get(c)) exit(-1);\n  go = true;\n  go.notify_all();\n  // writer and reader run to completion, then complete\n  done.wait(false);\n  p_data->~data();\n  destroy_shared_mem(key);\n}\n```", "```cpp\n#include <algorithm>\n#include <iterator>\n#include <new>\nclass shared_mem_mgr {\n  shared_mem_id key;\n  std::vector<bool> taken;\n  void *mem;\n  auto find_first_free(std::size_t from = 0) {\n      using namespace std;\n      auto p = find(begin(taken) + from, end(taken),\n                    false);\n      return distance(begin(taken), p);\n  }\n  bool at_least_free_from(std::size_t from, int n) {\n      using namespace std;\n      return from + n < size(taken) &&\n             count(begin(taken) + from,\n                   begin(taken) + from + n,\n                   false) == n;\n  }\n  void take(std::size_t from, std::size_t to) {\n      using namespace std;\n      fill(begin(taken) + from, begin(taken) + to,\n          begin(taken) + from, true);\n  }\n  void free(std::size_t from, std::size_t to) {\n      using namespace std;\n      fill(begin(taken) + from, begin(taken) + to,\n          begin(taken) + from, false);\n  }\npublic:\n  // create shared memory block\n  shared_mem_mgr(std::size_t size)\n      : key{ create_shared_mem(size) }, taken(size) {\n      auto [p, sz] = get_shared_mem(key);\n      if (!p) throw invalid_shared_mem_key{};\nmem = p;\n  }\n  shared_mem_mgr(const shared_mem_mgr&) = delete;\n  shared_mem_mgr&\n      operator=(const shared_mem_mgr&) = delete;\n  void* allocate(std::size_t n) {\n      using namespace std;\n      std::size_t i = find_first_free();\n      // insanely inefficient\n      while (!at_least_free_from(i, n) && i != size(taken))\n        i = find_first_free(i + 1);\n      if (i == size(taken)) throw bad_alloc{};\n      take(i, i + n);\n      return static_cast<char*>(mem) + i;\n  }\n  void deallocate(void *p, std::size_t n) {\n      using namespace std;\n      auto i = distance(\n         static_cast<char*>(mem), static_cast<char*>(p)\n      );\n      take(i, i + n);\n  }\n  ~shared_mem_mgr() {\n      destroy_shared_mem(key);\n  }\n};\n```", "```cpp\nvoid* operator new(std::size_t n, shared_mem_mgr& mgr) {\n  return mgr.allocate(n);\n}\nvoid* operator new[](std::size_t n, shared_mem_mgr& mgr) {\n  return mgr.allocate(n);\n}\nvoid operator delete(void *p, std::size_t n,\n                    shared_mem_mgr& mgr) {\n  mgr.deallocate(p, n);\n}\nvoid operator delete[](void *p, std::size_t n,\n                      shared_mem_mgr& mgr) {\n  mgr.deallocate(p, n);\n}\n```", "```cpp\nint main() {\n  // we need a N-bytes shared memory block\n  constexpr std::size_t N = 1'000'000;\n  // HERE\n  shared_mem_mgr mgr{ N };\n  // start the lifetime of a non-ready data object\nauto p_data = new (mgr) data{ false };\n  std::atomic<bool> go{ false };\n  std::atomic<bool> done{ false };\n  std::jthread writer{ [p_data, &go] {\n      go.wait(false);\n      p_data->value = 3;\n      std::atomic_thread_fence(std::memory_order_release);\n      p_data->ready = true;\n  } };\n  std::jthread reader{ [p_data, &done] {\n      while (!p_data->ready)\n        ; // busy waiting, not cool\n      std::cout << \"read value \" << p_data->value << '\\n';\n      done = true;\n      done.notify_all();\n  } };\n  if (char c; !std::cin.get(c)) exit(-1);\n  go = true;\n  go.notify_all();\n  // writer and reader run to completion, then complete\n  done.wait(false);\n  p_data->~data();\n  operator delete(p_data, sizeof(data), mgr);\n}\n```"]