["```cpp\ntypedef int (*lua_CFunction) (lua_State *L);\n```", "```cpp\nnamespace\n{\n    int luaGetExecutorVersionCode(lua_State *L)\n    {\n        lua_pushinteger(L, LuaExecutor::versionCode);\n        return 1;\n    }\n}\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    static const int versionCode = 6;\n};\n```", "```cpp\nnamespace\n{\n    void registerHostFunctions(lua_State *L)\n    {\n        lua_pushcfunction(L, luaGetExecutorVersionCode);\n        lua_setglobal(L, \"host_version\");\n    }\n}\n```", "```cpp\nLuaExecutor::LuaExecutor(...)\n{\n    ...\n    registerHostFunctions(L);\n}\n```", "```cpp\nprint(\"Host version is \" .. host_version())\n```", "```cpp\n#include \"LuaExecutor.h\"\n#include \"LoggingLuaExecutorListener.h\"\nint main()\n{\n    auto listener = std::make_unique<\n        LoggingLuaExecutorListener>();\n    auto lua = std::make_unique<LuaExecutor>(*listener);\n    lua->executeFile(\"script.lua\");\n    return 0;\n}\n```", "```cpp\nHost version is 6\n```", "```cpp\nnamespace\n{\n    int luaPrintOverride(lua_State *L)\n    {\n        int nArgs = lua_gettop(L);\n        std::cout << \"[Lua]\";\n        for (int i = 1; i <= nArgs; i++)\n        {\n            std::cout << \" \"\n                      << luaL_tolstring(L, i, NULL);\n        }\n        std::cout << std::endl;\n        return 0;\n    }\n}\n```", "```cpp\nnamespace\n{\n    void overrideLuaFunctions(lua_State *L)\n    {\n        const struct luaL_Reg overrides[] = {\n            {\"print\", luaPrintOverride},\n            {NULL, NULL}};\n        lua_getglobal(L, \"_G\");\n        luaL_setfuncs(L, overrides, 0);\n        lua_pop(L, 1);\n    }\n}\n```", "```cpp\ntypedef struct luaL_Reg {\n    const char *name;\n    lua_CFunction func;\n} luaL_Reg;\n```", "```cpp\nLuaExecutor::LuaExecutor(...)\n{\n    ...\n    overrideLuaFunctions(L);\n}\n```", "```cpp\n[Lua] Host version is 6\n```", "```cpp\n#ifndef _DESTINATIONS_H\n#define _DESTINATIONS_H\n#include <map>\n#include <vector>\n#include <string>\nclass Destinations\n{\npublic:\n    Destinations(const std::string &name);\n    void wish(const std::vector<std::string> &places);\n    void went(const std::vector<std::string> &places);\n    std::vector<std::string> listVisited() const;\n    std::vector<std::string> listUnvisited() const;\nprivate:\n    std::string name;\n    std::map<std::string, bool> wishlist;\n};\n#endif // _DESTINATIONS_H\n```", "```cpp\n#include \"Destinations.h\"\nDestinations::Destinations(const std::string &name)\n    : name(name), wishlist({}) {}\n```", "```cpp\nvoid Destinations::wish(\n    const std::vector<std::string> &places)\n{\n    for (const auto &place : places)\n    {\n        wishlist[place] = false;\n    }\n}\n```", "```cpp\nvoid Destinations::went(\n    const std::vector<std::string> &places)\n{\n    for (const auto &place : places)\n    {\n        wishlist[place] = true;\n    }\n}\n```", "```cpp\nstd::vector<std::string>\nDestinations::listVisited() const\n{\n    std::vector<std::string> results;\n    for (const auto &[place, visited] : wishlist)\n    {\n        if (visited)\n        {\n            results.push_back(place);\n        }\n    }\n    return results;\n}\n```", "```cpp\nstd::vector<std::string>\nDestinations::listUnvisited() const\n{\n    std::vector<std::string> results;\n    for (const auto &[place, visited] : wishlist)\n    {\n        if (not visited)\n        {\n            results.push_back(place);\n        }\n    }\n    return results;\n}\n```", "```cpp\nnamespace\n{\nint luaWish(lua_State *L) { return 0; }\nint luaWent(lua_State *L) { return 0; }\nint luaListVisited(lua_State *L) { return 0; }\nint luaListUnvisited(lua_State *L) { return 0; }\nconst std::vector<luaL_Reg> REGS = {\n    {\"wish\", luaWish},\n    {\"went\", luaWent},\n    {\"list_visited\", luaListVisited},\n    {\"list_unvisited\", luaListUnvisited},\n    {NULL, NULL}};\n}\n```", "```cpp\n#ifndef _LUA_MODULE_H\n#define _LUA_MODULE_H\n#include <lua.hpp>\n#include <string>\n#include <vector>\nclass LuaModule\n{\npublic:\n    virtual const std::string &luaName()\n        const override = 0;\n    virtual const std::vector<luaL_Reg> &luaRegs()\n        const overrode = 0;\n    virtual ~LuaModule() = default;\n};\n#endif // _LUA_MODULE_H\n```", "```cpp\nclass Destinations : public LuaModule\n{\npublic:\n    ...\n    const std::string &luaName() const;\n    const std::vector<luaL_Reg> &luaRegs() const;\n    ...\n};\n```", "```cpp\nconst std::string &\nDestinations::luaName() const\n{\n    return name;\n}\nconst std::vector<luaL_Reg> &\nDestinations::luaRegs() const\n{\n    return REGS;\n}\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    void registerModule(LuaModule &module);\n};\n```", "```cpp\nvoid LuaExecutor::registerModule(LuaModule &module)\n{\n    lua_createtable(L, 0, module.luaRegs().size() - 1);\n    luaL_setfuncs(L, module.luaRegs().data(), 0);\n    lua_setglobal(L, module.luaName().c_str());\n}\n```", "```cpp\n#include \"LuaExecutor.h\"\n#include \"LoggingLuaExecutorListener.h\"\n#include \"Destinations.h\"\nint main()\n{\n    auto listener = std::make_unique<\n       LoggingLuaExecutorListener>();\n    auto lua = std::make_unique<LuaExecutor>(*listener);\n    auto wishlist = std::make_unique<Destinations>(\n        \"destinations\");\n    lua->registerModule(*wishlist.get());\n    lua->executeFile(\"script.lua\");\n    return 0;\n}\n```", "```cpp\ndestinations.wish(\"London\", \"Paris\", \"Amsterdam\")\ndestinations.went(\"Paris\")\nprint(\"Visited:\", destinations.list_visited())\nprint(\"Unvisited:\", destinations.list_unvisited())\n```", "```cpp\n[Lua] Visited:\n[Lua] Unvisited:\n```", "```cpp\nvoid LuaExecutor::registerModule(LuaModule &module)\n{\n    lua_createtable(L, 0, module.luaRegs().size() - 1);\n    int nUpvalues = module.pushLuaUpvalues(L);\n    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);\n    lua_setglobal(L, module.luaName().c_str());\n}\n```", "```cpp\nclass LuaModule\n{\npublic:\n    virtual int pushLuaUpvalues(lua_State *L)\n    {\n        lua_pushlightuserdata(L, this);\n        return 1;\n    }\n};\n```", "```cpp\nnamespace\n{\n    inline Destinations *getObj(lua_State *L)\n    {\n        return reinterpret_cast<Destinations *>(\n            lua_touserdata(L, lua_upvalueindex(1)));\n    }\n}\n```", "```cpp\nint luaWish(lua_State *L)\n{\n    Destinations *obj = getObj(L);\n    std::vector<std::string> places;\n    int nArgs = lua_gettop(L);\n    for (int i = 1; i <= nArgs; i++)\n    {\n        places.push_back(lua_tostring(L, i));\n    }\n    obj->wish(places);\n    return 0;\n}\n```", "```cpp\nint luaWent(lua_State *L)\n{\n    Destinations *obj = getObj(L);\n    std::vector<std::string> places;\n    int nArgs = lua_gettop(L);\n    for (int i = 1; i <= nArgs; i++)\n    {\n        places.push_back(lua_tostring(L, i));\n    }\n    obj->went(places);\n    return 0;\n}\n```", "```cpp\nint luaListVisited(lua_State *L)\n{\n    Destinations *obj = getObj(L);\n    auto places = obj->listVisited();\n    for (const auto &place : places)\n    {\n        lua_pushstring(L, place.c_str());\n    }\n    return places.size();\n}\nint luaListUnvisited(lua_State *L)\n{\n    Destinations *obj = getObj(L);\n    auto places = obj->listUnvisited();\n    for (const auto &place : places)\n    {\n        lua_pushstring(L, place.c_str());\n    }\n    return places.size();\n}\n```", "```cpp\ndestinations.wish(\"London\", \"Paris\", \"Amsterdam\")\ndestinations.went(\"Paris\")\nprint(\"Visited:\", destinations.list_visited())\nprint(\"Unvisited:\", destinations.list_unvisited())\n```", "```cpp\n[Lua] Visited: Paris\n[Lua] Unvisited: Amsterdam London\n```"]