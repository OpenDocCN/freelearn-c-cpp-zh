["```cpp\n#if condition1\n  text1\n#elif condition2\n  text2\n#elif condition3\n  text3\n#else\n  text4\n#endif \n```", "```cpp\n#ifdef identifier1\n  text1\n#elifdef identifier2\n  text2\n#endif\n#ifndef identifier1\n  text1\n#elifndef identifier2\n  text2\n#endif \n```", "```cpp\n    #define VERBOSE_PRINTS\n    #define VERBOSITY_LEVEL 5 \n    ```", "```cpp\n    #ifndef UNIQUE_NAME\n    #define UNIQUE_NAME\n    class widget { };\n    #endif \n    ```", "```cpp\n    void show_compiler()\n    {\n      #if defined _MSC_VER\n        std::cout << \"Visual C++\\n\";\n      #elif defined __clang__\n        std::cout << \"Clang\\n\";\n      #elif defined __GNUG__\n        std::cout << \"GCC\\n\";\n      #else\n        std::cout << \"Unknown compiler\\n\";\n      #endif\n    } \n    ```", "```cpp\n    void show_architecture()\n    {\n    #if defined _MSC_VER\n    #if defined _M_X64\n      std::cout << \"AMD64\\n\";\n    #elif defined _M_IX86\n      std::cout << \"INTEL x86\\n\";\n    #elif defined _M_ARM\n      std::cout << \"ARM\\n\";\n    #else\n      std::cout << \"unknown\\n\";\n    #endif\n    #elif defined __clang__ || __GNUG__\n    #if defined __amd64__\n      std::cout << \"AMD64\\n\";\n    #elif defined __i386__\n      std::cout << \"INTEL x86\\n\";\n    #elif defined __arm__\n      std::cout << \"ARM\\n\";\n    #else\n      std::cout << \"unknown\\n\";\n    #endif\n    #else\n    #error Unknown compiler\n    #endif\n    } \n    ```", "```cpp\n    void show_configuration()\n    {\n    #ifdef _DEBUG\n      std::cout << \"debug\\n\";\n    #else\n      std::cout << \"release\\n\";\n    #endif\n    } \n    ```", "```cpp\n    #ifdef __cpp_consteval\n    #define CONSTEVAL consteval\n    #else\n    #define CONSTEVAL constexpr\n    #endif\n    CONSTEVAL int twice(int const n)\n    {\n        return n + n;\n    }\n    int main()\n    {\n      twice(42);\n    } \n    ```", "```cpp\n    #if __has_include(<optional>)\n    #include <optional>\n    template<class T> using optional_t = std::optional<T>;\n    #elif\n    #include \"myoptional.h\"\n    template<class T> using optional_t = my::optional<T>;\n    #endif \n    ```", "```cpp\n    #if defined(__has_cpp_attribute) \n    #if __has_cpp_attribute(deprecated)\n    #define DEPRECATED(msg) [[deprecated(msg)]]\n    #endif\n    #endif\n    DEPRECATED(\"This function is deprecated.\")\n    void func() {} \n    ```", "```cpp\n#ifdef _WIN64\n#error \"64-bit not supported\"\n#endif\n#if __cplusplus < 201703L\n#warning \"Consider upgrading to a C++17 compiler\"\n#endif \n```", "```cpp\n    #define MAKE_STR2(x) #x \n    ```", "```cpp\n    #define MAKE_STR(x) MAKE_STR2(x) \n    ```", "```cpp\n    #define MERGE2(x, y)    x##y \n    ```", "```cpp\n    #define MERGE(x, y)     MERGE2(x, y) \n    ```", "```cpp\nstd::string s1 { MAKE_STR(sample) };  // s1 = \"sample\"\nstd::string s2 { MAKE_STR2(sample) }; // s2 = \"sample\" \n```", "```cpp\n#define NUMBER 42\nstd::string s3 { MAKE_STR(NUMBER) };    // s3 = \"42\"\nstd::string s4 { MAKE_STR2(NUMBER) };   // s4 = \"NUMBER\" \n```", "```cpp\n#define DECL_MAKE(x)    DECL_MAKE2(x)\n#define DECL_MAKE2(x)   x* make##_##x() { return new x(); }\nstruct bar {};\nstruct foo {};\nDECL_MAKE(foo)\nDECL_MAKE(bar)\nauto f = make_foo(); // f is a foo*\nauto b = make_bar(); // b is a bar* \n```", "```cpp\nauto text{ _T(\"sample\") }; // text is either \"sample\" or L\"sample\" \n```", "```cpp\n#ifdef _UNICODE\n#define __T(x)   L ## x\n#else\n#define __T(x)   x\n#endif\n#define _T(x)    __T(x)\n#define _TEXT(x) __T(x) \n```", "```cpp\n    struct alignas(8) item\n    {\n      int      id;\n      bool     active;\n      double   value;\n    };\n    static_assert(sizeof(item) == 16, \"size of item must be 16 bytes\"); \n    ```", "```cpp\n    template <typename T>\n    class pod_wrapper\n    {\n      static_assert(std::is_standard_layout_v<T>, \"POD type expected!\");\n      T value;\n    };\n    struct point\n    {\n      int x;\n      int y;\n    };\n    pod_wrapper<int>         w1; // OK\n    pod_wrapper<point>       w2; // OK\n    pod_wrapper<std::string> w3; // error: POD type expected \n    ```", "```cpp\n    template<typename T>\n    auto mul(T const a, T const b)\n    {\n      static_assert(std::is_integral_v<T>, \"Integral type expected\");\n      return a * b;\n    }\n    auto v1 = mul(1, 2);       // OK\n    auto v2 = mul(12.0, 42.5); // error: Integral type expected \n    ```", "```cpp\nstatic_assert(condition, message); \n```", "```cpp\nstatic_assert(\n   sizeof(item) == 16,\n   std::format(\"size of item must be 16 bytes but got {}\", sizeof(item))); \n```", "```cpp\ntemplate<bool Test, class T = void>\nstruct enable_if\n{};\ntemplate<class T>\nstruct enable_if<true, T>\n{\n  typedef T type;\n}; \n```", "```cpp\n    template <typename T,\n              typename = typename\n              std::enable_if_t<std::is_standard_layout_v<T>, T>>\n    class pod_wrapper\n    {\n      T value;\n    };\n    struct point\n    {\n      int x;\n      int y;\n    };\n    struct foo\n    {\n       virtual int f() const\n       {\n          return 42;\n       }\n    };\n    pod_wrapper<int>         w1; // OK\n    pod_wrapper<point>       w2; // OK\n    pod_wrapper<std::string> w3; // OK with Clang and GCC\n                                 // error with MSVC\n                                 // too few template arguments\n    pod_wrapper<foo>         w4; // error \n    ```", "```cpp\n    template<typename T,\n             typename = typename std::enable_if_t<std::is_integral_v<T>, T>>\n    auto mul(T const a, T const b)\n    {\n      return a * b;\n    }\n    auto v1 = mul(1, 2);     // OK\n    auto v2 = mul(1.0, 2.0); // error: no matching overloaded function found \n    ```", "```cpp\ntemplate <typename Test, typename T = void>\nusing EnableIf = typename std::enable_if_t<Test::value, T>;\ntemplate <typename Test, typename T = void>\nusing DisableIf = typename std::enable_if_t<!Test::value, T>; \n```", "```cpp\ntemplate <typename T, typename = EnableIf<std::is_standard_layout<T>>>\nclass pod_wrapper\n{\n  T value;\n};\ntemplate<typename T, typename = EnableIf<std::is_integral<T>>>\nauto mul(T const a, T const b)\n{\n  return a * b;\n} \n```", "```cpp\ntemplate <typename T>\nvoid func(typename T::value_type const a)\n{ std::cout << \"func<>\" << '\\n'; }\nvoid func(int const a)\n{ std::cout << \"func\" << '\\n'; }\ntemplate <typename T>\nstruct some_type\n{\n  using value_type = T;\n}; \n```", "```cpp\ntemplate <typename T>\nauto compute(T const a, T const b)\n{\n  static_assert(std::is_integral_v<T>, \"An integral type expected\");\n  return a + b;\n}\ntemplate <typename T, typename = void>\nauto compute(T const a, T const b)\n{\n  static_assert(!std::is_integral_v<T>, \"A non-integral type expected\");\n  return a * b;\n}\nauto v1 = compute(1, 2);\n// error: ambiguous call to overloaded function\nauto v2 = compute(1.0, 2.0);\n// error: ambiguous call to overloaded function \n```", "```cpp\ntemplate <typename T, typename = EnableIf<std::is_integral<T>>>\nauto compute(T const a, T const b)\n{\n  return a * b;\n}\ntemplate <typename T, typename = DisableIf<std::is_integral<T>>,\n          typename = void>\nauto compute(T const a, T const b)\n{\n  return a + b;\n}\nauto v1 = compute(1, 2);     // OK; v1 = 2\nauto v2 = compute(1.0, 2.0); // OK; v2 = 3.0 \n```", "```cpp\nif constexpr (init-statement condition) statement-true\nelse statement-false \n```", "```cpp\n    template <typename T>\n    auto value_of(T value)\n    {\n      if constexpr (std::is_pointer_v<T>)\n     return *value;\n      else\n    return value;\n    } \n    ```", "```cpp\n    namespace binary\n    {\n      using byte8 = unsigned char;\n      namespace binary_literals\n      {\n        namespace binary_literals_internals\n        {\n          template <typename CharT, char d, char... bits>\n          constexpr CharT binary_eval()\n     {\n            if constexpr(sizeof...(bits) == 0)\n     return static_cast<CharT>(d-'0');\n            else if constexpr(d == '0')\n              return binary_eval<CharT, bits...>();\n            else if constexpr(d == '1')\n              return static_cast<CharT>(\n                (1 << sizeof...(bits)) |\n                binary_eval<CharT, bits...>());\n          }\n        }\n        template<char... bits>\n        constexpr byte8 operator\"\"_b8()\n        {\n          static_assert(\n            sizeof...(bits) <= 8,\n            \"binary literal b8 must be up to 8 digits long\");\n          return binary_literals_internals::\n                     binary_eval<byte8, bits...>();\n        }\n      }\n    } \n    ```", "```cpp\nauto v1 = value_of(42);\nauto p = std::make_unique<int>(42);\nauto v2 = value_of(p.get()); \n```", "```cpp\ntemplate <typename T,\n          typename = typename std::enable_if_t<std::is_pointer_v<T>, T>>\nauto value_of(T value)\n{\n  return *value;\n}\ntemplate <typename T,\n          typename = typename std::enable_if_t<!std::is_pointer_v<T>, T>>\nT value_of(T value)\n{\n  return value;\n} \n```", "```cpp\n    [[nodiscard]] int get_value1()\n    {\n      return 42;\n    }\n    get_value1();\n    // warning: ignoring return value of function\n    //          declared with 'nodiscard' attribute get_value1(); \n    ```", "```cpp\n    enum class[[nodiscard]] ReturnCodes{ OK, NoData, Error };\n    ReturnCodes get_value2()\n    {\n      return ReturnCodes::OK;\n    }\n    struct[[nodiscard]] Item{};\n    Item get_value3()\n    {\n      return Item{};\n    }\n    // warning: ignoring return value of function\n    //          declared with 'nodiscard' attribute\n    get_value2();\n    get_value3(); \n    ```", "```cpp\n    [[deprecated(\"Use func2()\")]] void func()\n    {\n    }\n    // warning: 'func' is deprecated : Use func2()\n    func();\n    class [[deprecated]] foo\n    {\n    };\n    // warning: 'foo' is deprecated\n    foo f; \n    ```", "```cpp\n    double run([[maybe_unused]] int a, double b)\n    {\n      return 2 * b;\n    }\n    [[maybe_unused]] auto i = get_value1(); \n    ```", "```cpp\n    void option1() {}\n    void option2() {}\n    int alternative = get_value1();\n    switch (alternative)\n    {\n      case 1:\n        option1();\n        [[fallthrough]]; // this is intentional\n    case 2:\n        option2();\n    } \n    ```", "```cpp\n    void execute_command(char cmd)\n    {\n      switch(cmd)\n      {\n        [[likely]]\n        case 'a': /* add */ break;\n        [[unlikely]]\n        case 'd': /* delete */ break;\n        case 'p': /* print */ break;\n        default:  /* do something else */ break;\n      }\n    } \n    ```", "```cpp\n    void process(int* data, size_t len)\n    {\n       [[assume(len > 0)]];\n       for(size_t i = 0; i < len; ++i)\n       {\n         // do something with data[i]\n       }\n    } \n    ```", "```cpp\n// attr1 applies to a, attr2 applies to b\nint a [[attr1]], b [[attr2]];\n// attr1 applies to a and b\nint [[attr1]] a, b;\n// attr1 applies to a and b, attr2 applies to a\nint [[attr1]] a [[attr2]], b; \n```", "```cpp\nnamespace test\n{\n  [[debug]];\n} \n```"]