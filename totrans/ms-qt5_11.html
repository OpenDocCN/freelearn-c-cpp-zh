<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11.     Having Fun with Serialization    </h1></div></div></div><p>The previous chapter was a firework of threads, sockets, and workers. We hope that your minions have been working hard. In this chapter, we will turn our attention to the serialization with Qt. You will learn how to serialize data in multiple formats with a flexible system. The example project will be a virtual drum machine, in which you can compose you own drum beat, record it, play it, save it, and load it back. Your drum beat will be probably so awesome that you will want to share it: you will now be able to do it in various formats.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">How to architecture an application that plays and records sounds</li><li class="listitem">The <code class="literal">QVariant</code> class and its inner mechanics</li><li class="listitem">A flexible serialization system</li><li class="listitem">JSON serialization</li><li class="listitem">XML serialization</li><li class="listitem">Binary serialization</li><li class="listitem">The Qt Multimedia framework</li><li class="listitem">Drag and drop handling with Qt</li><li class="listitem">Triggering a button from your keyboard</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec97"/>Architecting the drum machine project</h1></div></div></div><p>As usual, before diving into the code, let's study the structure of the project. The aim of the project is to be able to:</p><div><ul class="itemizedlist"><li class="listitem">Play and record a sound track from a drum machine</li><li class="listitem">Save this track to a file and load it to play it back</li></ul></div><p>To play a sound, we will lay out four big buttons that will play a specific drum sound upon click (or a keyboard event): a kick, a snare, a hi-hat, and a cymbal crash. These sounds will be <code class="literal">.wav</code> files loaded by the application. The user will be able to record his sequence of sounds and replay it.</p><p>For the serialization part, we do not only want to save the track to a single file format, we would rather do three:</p><div><ul class="itemizedlist"><li class="listitem"><strong>JSON</strong> (<strong>JavaScript Object Notation</strong>)</li><li class="listitem"><strong>XML</strong> (<strong>eXtensible Markup Language</strong>)</li><li class="listitem"><strong>Binary</strong></li></ul></div><p>Not only is it more fun to cover three formats, but it also gives us the opportunity to understand the advantages and limitations of each one, and how it fits within the Qt framework. The architecture we are going to implement will try to be flexible to handle future evolutions. You never know how a project can evolve!</p><p>The classes' organization looks like this:</p><div><img src="img/image00441.jpeg" alt="Architecting the drum machine project"/></div><p style="clear:both; height: 1em;"> </p><p>Let's review the role of these classes:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">SoundEvent</code> class is the basic building block of a track. It is a simple class containing <code class="literal">timestamp</code> (when the sound has been played) and <code class="literal">soundId</code> variables (what sound has been played).</li><li class="listitem">The <code class="literal">Track</code> class contains a list of <code class="literal">SoundEvents</code>, a duration and a state (playing, recording, stopped). Each time the user plays a sound, a <code class="literal">SoundEvent</code> class is created and added to the <code class="literal">Track</code> class.</li><li class="listitem">The <code class="literal">PlaybackWorker</code> class is a worker class that runs in a different thread. It is responsible of looping through the <code class="literal">Track</code> class's <code class="literal">soundEvents</code> and triggering the proper sound when its <code class="literal">timestamp</code> has been reached.</li><li class="listitem">The <code class="literal">Serializable</code> class is an interface that must be implemented by each class that wants to be serialized (in our case: <code class="literal">SoundEvent</code> and <code class="literal">Track</code>).</li><li class="listitem">The <code class="literal">Serializer</code> class is an interface that must be implemented by each format-specific implementation class.</li><li class="listitem">The <code class="literal">JsonSerializer</code>, <code class="literal">XmlSerializer</code>, and <code class="literal">BinarySerializer</code> are the sub-classes of <code class="literal">Serializer</code> class that do the format-specific job to serialize/deserialize a <code class="literal">Serializable</code> instance.</li><li class="listitem">The <code class="literal">SoundEffectWidget</code> class is the widget that holds the information to play a single sound. It displays the button for one of our four sounds. It also owns a <code class="literal">QSoundEffect</code> class that sends the sound to the audio card.</li><li class="listitem">The <code class="literal">MainWindow</code> class holds everything together. It owns the <code class="literal">Track</code> class, spawns the <code class="literal">PlaybackWorker</code> thread, and triggers the serialization/deserialization.</li></ul></div><p>The output format should be easily swapped. To achieve this, we will rely on a modified version of the bridge design pattern that will allow <code class="literal">Serializable</code> and <code class="literal">Serializer</code> classes to evolve independently.</p><p>The whole project revolves around this notion of independence between modules. It goes to the extent that a sound can be replaced on the spot during a playback. Let's say that you listen to your incredible beat, and you want to try another snare sound. You will be able to replace it with a simple drag and drop of a <code class="literal">.wav</code> file on the <code class="literal">SoundEffectWidget</code> class holding the snare sound.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec98"/>Creating a drum track</h1></div></div></div><p>Let's buckle up and do this project! Create a new <strong>Qt Widgets Application</strong> project named <code class="literal">ch11-drum-machine</code>. As usual, add the <code class="literal">CONFIG += c++14</code> in <code class="literal">ch11-drum-machine.pro</code>.</p><p>Now create a new C++ class named <code class="literal">SoundEvent</code>. Here is <code class="literal">SoundEvent.h</code> stripped from its functions:</p><pre class="programlisting">#include &lt;QtGlobal&gt; 
 
class SoundEvent 
{ 
 
public: 
    SoundEvent(qint64 timestamp = 0, int soundId = 0); 
    ~SoundEvent(); 
 
    qint64 timestamp; 
    int soundId; 
}; 
</pre><p>This class contains only two public members:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">timestamp</code>: A <code class="literal">qint64</code> (<code class="literal">long long</code> type) that contains the current time of the <code class="literal">SoundEvent</code> in milliseconds since the beginning of the track</li><li class="listitem"><code class="literal">soundId</code>: The ID of the sound that has been played</li></ul></div><p>In recording mode, each time the user plays a sound, a <code class="literal">SoundEvent</code> is created with the appropriate data. The <code class="literal">SoundEvent.cpp</code> file is so boring that we will not inflict it on you.</p><p>The next class to build is <code class="literal">Track</code>. Again, create the new C++ class. Let's review <code class="literal">Track.h</code> with its members only:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QVector&gt; 
#include &lt;QElapsedTimer&gt; 
 
#include "SoundEvent.h" 
 
class Track : public QObject 
{ 
    Q_OBJECT 
public: 
    enum class State { 
        STOPPED, 
        PLAYING, 
        RECORDING, 
    }; 
 
    explicit Track(QObject *parent = 0); 
    ~Track(); 
 
private: 
    qint64 mDuration; 
       std::vector&lt;std::unique_ptr&lt;SoundEvent&gt;&gt; mSoundEvents; 
    QElapsedTimer mTimer; 
    State mState; 
    State mPreviousState; 
}; 
</pre><p>We can now go into detail about them:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mDuration</code>: This variable holds the duration of the <code class="literal">Track</code> class. This member is reset to 0 when a recording is started and updated when the recording is stopped.</li><li class="listitem"><code class="literal">mSoundEvents</code>: This variable is the list of <code class="literal">SoundEvents</code> for the given <code class="literal">Track</code>. As the <code class="literal">unique_ptr</code> semantic states it, <code class="literal">Track</code> is the owner of the sound events.</li><li class="listitem"><code class="literal">mTimer</code>: This variable is started each time <code class="literal">Track</code> is played or recorded.</li><li class="listitem"><code class="literal">mState</code>: This variable is the current <code class="literal">State</code> of <code class="literal">Track</code> class, which can have three possible values: <code class="literal">STOPPED</code>, <code class="literal">PLAYING</code>, <code class="literal">RECORDING</code>.</li><li class="listitem"><code class="literal">mPreviousState</code>: This variable is the previous <code class="literal">State</code> of <code class="literal">Track</code>. This is useful when you want to know which action to do on a new <code class="literal">STOPPED</code><code class="literal">State</code>. We will have to stop the playback if <code class="literal">mPreviousState</code> is in the <code class="literal">PLAYING</code> state.</li></ul></div><p>The <code class="literal">Track</code> class is the pivot of the business logic of the project. It holds <code class="literal">mState</code>, which is the state of the whole application. Its content will be read during a playback of your awesome musical performance and also be serialized to a file.</p><p>Let's enrich <code class="literal">Track.h</code> with functions:</p><pre class="programlisting">class Track : public QObject 
{ 
    Q_OBJECT 
public: 
    ... 
    qint64 duration() const; 
    State state() const; 
    State previousState() const; 
    quint64 elapsedTime() const; 
    const std::vector&lt;std::unique_ptr&lt;SoundEvent&gt;&gt;&amp; soundEvents() const; 
 
signals: 
    void stateChanged(State state); 
 
public slots: 
    void play(); 
    void record(); 
    void stop(); 
    void addSoundEvent(int soundEventId); 
 
private: 
    void clear(); 
    void setState(State state); 
 
private: 
    ... 
}; 
</pre><p>We will skip the simple getters and concentrate on the important functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">elapsedTime()</code>: This function returns the value of the <code class="literal">mTimer.elapsed()</code>.</li><li class="listitem"><code class="literal">soundEvents()</code>: This function is a little more complicated getter. The <code class="literal">Track</code> class is the owner of <code class="literal">mSoundEvents</code> content and we really want to enforce it. For this, the getter returns a <code class="literal">const &amp;</code> to <code class="literal">mSoundEvents</code>.</li><li class="listitem"><code class="literal">stateChanged()</code>: This function is emitted when the <code class="literal">mState</code> value is updated. The new <code class="literal">State</code> is passed as a parameter.</li><li class="listitem"><code class="literal">play()</code>: This function is a slot that starts to play the <code class="literal">Track</code>. This play is purely logical, the real playback will be triggered by <code class="literal">PlaybackWorker</code>.</li><li class="listitem"><code class="literal">record()</code>: This function is a slot that starts the recording state of <code class="literal">Track</code>.</li><li class="listitem"><code class="literal">stop()</code>: This function is a slot that stops the current start or record state.</li><li class="listitem"><code class="literal">addSoundEvent()</code>: This function creates a new <code class="literal">SoundEvent</code> with the given <code class="literal">soundId</code> and adds it to <code class="literal">mSoundEvents</code>.</li><li class="listitem"><code class="literal">clear()</code>: This function resets the content of <code class="literal">Track</code>: it clears <code class="literal">mSoundEvents</code> and sets <code class="literal">mDuration</code> to <code class="literal">0</code>.</li><li class="listitem"><code class="literal">setState()</code>: This function is a private helper function that updates <code class="literal">mState</code>, <code class="literal">mPreviousState</code> and emits the <code class="literal">stateChanged()</code> signal.</li></ul></div><p>Now that the header has been covered, we can study the interesting parts of <code class="literal">Track.cpp</code>:</p><pre class="programlisting">void Track::play() 
{ 
    setState(State::PLAYING); 
    mTimer.start(); 
} 
</pre><p>Calling <code class="literal">Track.play()</code> simply updates the state to <code class="literal">PLAYING</code> and starts <code class="literal">mTimer</code>. The <code class="literal">Track</code> class does not hold anything related to the Qt Multimedia API; it is limited to an evolved data holder (as it also manages a state).</p><p>Now for <code class="literal">record()</code>, which brings a lot of surprises:</p><pre class="programlisting">void Track::record() 
{ 
    clearSoundEvents(); 
    setState(State::RECORDING); 
    mTimer.start(); 
} 
</pre><p>It starts by clearing the data, sets the state to <code class="literal">RECORDING</code>, and also starts <code class="literal">mTimer</code>. Now consider <code class="literal">stop()</code>, which is a slight variation:</p><pre class="programlisting">void Track::stop() 
{ 
    if (mState == State::RECORDING) { 
        mDuration = mTimer.elapsed(); 
    } 
    setState(State::STOPPED); 
} 
</pre><p>If we are stopping in the <code class="literal">RECORDING</code> state, <code class="literal">mDuration</code> is updated. Nothing very fancy here. We saw three times the <code class="literal">setState()</code> call without seeing its body:</p><pre class="programlisting">void Track::setState(Track::State state) 
{ 
    mPreviousState = mState; 
    mState = state; 
    emit stateChanged(mState); 
} 
</pre><p>The current value of <code class="literal">mState</code> is stored in <code class="literal">mPreviousState</code> before being updated. Finally, <code class="literal">stateChanged()</code> is emitted with the new value.</p><p>The state system of <code class="literal">Track</code> is completely covered. The last missing part is the <code class="literal">SoundEvents</code> interactions. We can start with the <code class="literal">addSoundEvent()</code> snippet:</p><pre class="programlisting">void Track::addSoundEvent(int soundEventId) 
{ 
    if (mState != State::RECORDING) { 
        return; 
    } 
    mSoundEvents.push_back(make_unique&lt;SoundEvent&gt;( 
                               mTimer.elapsed(), 
                               soundEventId)); 
} 
</pre><p>A <code class="literal">soundEvent</code> is created only if we are in the <code class="literal">RECORDING</code> state. After that, a <code class="literal">SoundEvent</code> is added to <code class="literal">mSoundEvents</code> with the current elapsed time of <code class="literal">mTimer</code> and the passed <code class="literal">soundEventId</code>.</p><p>Now for the <code class="literal">clear()</code> function:</p><pre class="programlisting">void Track::clear() 
{ 
    mSoundEvents.clear(); 
    mDuration = 0; 
} 
</pre><p>Because we use <code class="literal">unique_ptr&lt;SoundEvent&gt;</code> in <code class="literal">mSoundEvents</code>, the <code class="literal">mSoundEvents.clear()</code> function is enough to empty the vector and also delete each <code class="literal">SoundEvent</code>. This is one less thing you have to worry with smart pointers.</p><p>The <code class="literal">SoundEvent</code> and <code class="literal">Track</code> are the base classes that hold the information about your future beat. We are going to see the class responsible for reading this data to play it: <code class="literal">PlaybackWorker</code>.</p><p>Create a new C++ class and update <code class="literal">PlaybackWorker.h</code> like so:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QAtomicInteger&gt; 
 
class Track; 
 
class PlaybackWorker : public QObject 
{ 
    Q_OBJECT 
public: 
    explicit PlaybackWorker(const Track&amp; track, QObject *parent = 0); 
 
signals: 
    void playSound(int soundId); 
    void trackFinished(); 
 
public slots: 
    void play(); 
    void stop(); 
 
private: 
    const Track&amp; mTrack; 
    QAtomicInteger&lt;bool&gt; mIsPlaying; 
}; 
</pre><p>The <code class="literal">PlaybackWorker</code> class will be running in a different thread. If your memory needs to be refreshed, go back to <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>. Its role is to iterate through the <code class="literal">Track</code> class's content to trigger the sounds. Let's break down this header:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mTrack</code>: This function is the reference to the <code class="literal">Track</code> class on which <code class="literal">PlaybackWorker</code> is working. It is passed in the constructor as a <code class="literal">const</code> reference. With this information, you already know that <code class="literal">PlaybackWorker</code> cannot modify <code class="literal">mTrack</code> in any way.</li><li class="listitem"><code class="literal">mIsPlaying</code>: This function is a flag used to be able to stop the worker from another thread. It is a <code class="literal">QAtomicInteger</code> to guarantee an atomic access to the variable.</li><li class="listitem"><code class="literal">playSound()</code>: This function is emitted by <code class="literal">PlaybackWorker</code> each time a sound needs to be played.</li><li class="listitem"><code class="literal">trackFinished()</code>: This function is emitted when the playback has been played until the end. If it has been stopped along the way, this signal will not be emitted.</li><li class="listitem"><code class="literal">play()</code>: This function is the main function of <code class="literal">PlaybackWorker</code>. In it, <code class="literal">mTrack</code> content will be queried to trigger sounds.</li><li class="listitem"><code class="literal">stop()</code>: This function is the function that updates the <code class="literal">mIsPlaying</code> flag and causes <code class="literal">play()</code> to exit its loop.</li></ul></div><p>The meat of the class lies in the <code class="literal">play()</code> function:</p><pre class="programlisting">void PlaybackWorker::play() 
{ 
    mIsPlaying.store(true); 
    QElapsedTimer timer; 
    size_t soundEventIndex = 0; 
    const auto&amp; soundEvents = mTrack.soundEvents(); 
 
    timer.start(); 
    while(timer.elapsed() &lt;= mTrack.duration() 
          &amp;&amp; mIsPlaying.load()) { 
        if (soundEventIndex &lt; soundEvents.size()) { 
            const auto&amp; soundEvent =   
                                  soundEvents.at(soundEventIndex); 
 
            if (timer.elapsed() &gt;= soundEvent-&gt;timestamp) { 
                emit playSound(soundEvent-&gt;soundId); 
                soundEventIndex++; 
            } 
        } 
        QThread::msleep(1); 
    } 
 
    if (soundEventIndex &gt;= soundEvents.size()) { 
        emit trackFinished(); 
    } 
} 
</pre><p>The first thing that <code class="literal">play()</code> function does is to prepare its reading: <code class="literal">mIsPlaying</code> is set to <code class="literal">true</code>, a <code class="literal">QElapsedTimer</code> class is declared, and a <code class="literal">soundEventIndex</code> is initialized. Each time <code class="literal">timer.elapsed()</code> is called, we will know if a sound should be played.</p><p>To know which sound should be played, <code class="literal">soundEventIndex</code> will be used to know where we are in the <code class="literal">soundEvents</code> vector.</p><p>Right after that, the <code class="literal">timer</code> object is started and we enter in the <code class="literal">while</code> loop. This <code class="literal">while</code> loop has two conditions to continue:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">timer.elapsed() &lt;= mTrack.duration()</code>: This condition states that we did not finish playing the track</li><li class="listitem"><code class="literal">mIsPlaying.load()</code>: This condition returns <strong>true</strong>: nobody asked <code class="literal">PlaybackWorker</code> to stop</li></ul></div><p>Intuitively, you might have added the <code class="literal">soundEventIndex &lt; soundEvents.size()</code> condition in the <code class="literal">while</code> condition. By doing so, you would have exited <code class="literal">PlaybackWorker</code> as soon as the last sound has been played. Technically, it works, but that would not have respected what the user recorded.</p><p>Consider a user that created a complex beat (do not underestimate what you can do with four sounds!) and decided on a long pause of 5 seconds at the end of the song. When he clicks on the stop button, the time display indicates 00:55 (for 55 seconds). However, when he plays back his performance, the last sound finishes at 00:50. The playback stops at 00:50 and the program does not respect what he recorded.</p><p>For this reason, the <code class="literal">soundEventIndex &lt; size()</code> test is moved inside the <code class="literal">while</code> loop and is used only as a fuse for the <code class="literal">soundEvents</code> read through.</p><p>Inside this condition, we retrieve the reference to the current <code class="literal">soundEvent</code>. We then compare the elapsed time against the <code class="literal">timestamp</code> of the <code class="literal">soundEvent</code>. If <code class="literal">timer.elapsed()</code> is greater or equal to <code class="literal">soundEvent-&gt;timestamp</code>, the signal <code class="literal">playSound()</code> is emitted with the <code class="literal">soundId</code>.</p><p>This is only a request to play a sound. The <code class="literal">PlaybackWorker</code> class limits itself to read through <code class="literal">soundEvents</code> and trigger a <code class="literal">playSound()</code> at the proper moment. The real sound will be handled later on, with the <code class="literal">SoundEffectWidget</code> class.</p><p>At each iteration in the <code class="literal">while</code> loop, a <code class="literal">QThread::msleep(1)</code> is done to avoid a busy loop. We minimize the sleep because we want the playback to be as faithful as possible to the original score. The longer the sleep, the more discrepancy we may encounter in the playback timing.</p><p>Finally, if the whole <code class="literal">soundEvents</code> has been processed, the <code class="literal">trackFinished</code> signal is emitted.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec99"/>Making your objects serializable with QVariant</h1></div></div></div><p>Now that we implemented the logic in our business classes, we have to think about what we are going to serialize and how we are going to do it. The user interacts with a <code class="literal">Track</code> class that contains all the data to be recorded and played back.</p><p>Starting from here, we can assume that the object to be serialized is <code class="literal">Track</code>, which in turn should somehow bring along its <code class="literal">mSoundEvents</code> containing a list of <code class="literal">SoundEvent</code> instances. To achieve this, we will rely heavily on the <code class="literal">QVariant</code> class.</p><p>You might have worked with <code class="literal">QVariant</code> before. It is a generic placeholder for any primitive type (<code class="literal">char</code>, <code class="literal">int</code>, <code class="literal">double</code>, and so on) but also complex types (<code class="literal">QString</code>, <code class="literal">QDate</code>, <code class="literal">QPoint</code>, and many more).</p><div><h3 class="title"><a id="note50"/>Note</h3><p>The complete list of QVariant supported types is available at <a class="ulink" href="http://doc.qt.io/qt-5/qmetatype.html#Type-enum">http://doc.qt.io/qt-5/qmetatype.html#Type-enum</a>.</p></div><p>A simple example of <code class="literal">QVariant</code> is:</p><pre class="programlisting">QVariant variant(21); 
 
int answer = variant.toInt() * 2; 
 
qDebug() &lt;&lt; "what is the meaning of the universe,  
             life and everything?" 
         &lt;&lt; answer; 
</pre><p>We store <code class="literal">21</code> in <code class="literal">variant</code>. From here, we can ask for <code class="literal">variant</code> to have a copy of the value casted to our desired type. Here we want an <code class="literal">int</code> value, so we call <code class="literal">variant.toInt()</code>. There are a lot of conversions already available with the <code class="literal">variant.toX()</code> syntax.</p><p>We can take a very quick peek at what happens behind the curtain in <code class="literal">QVariant</code>. How does it store all we feed it? The answer lies in the C++ type <code class="literal">union</code>. The <code class="literal">QVariant</code> class is a kind of super <code class="literal">union</code>.</p><p>A <code class="literal">union</code> is a special class type that can hold only one of its non-static data members at a time. A short snippet should illustrate this:</p><pre class="programlisting">union Sound 
{ 
    int duration; 
    char code; 
}; 
 
Sound s = 10; 
qDebug() &lt;&lt; "Sound duration:" &lt;&lt; s.duration; 
// output= Sound duration: 10 
 
s.code = 'K'; 
qDebug() &lt;&lt; "Sound code:" &lt;&lt; s.code; 
// output= Sound code: K 
</pre><p>First, a <code class="literal">union</code> class is declared like a <code class="literal">struct</code>. By default, all the members are <code class="literal">public</code>. The specificity of the <code class="literal">union</code> is that it takes only the largest member size in memory. Here, <code class="literal">Sound</code> will take only as much as the <code class="literal">int duration</code> space in memory.</p><p>Because <code class="literal">union</code> takes only this specific space, every member variable shares the same memory space. Therefore, only one member is available at a time, unless you want to have undefined behaviors.</p><p>When using the <code class="literal">Sound</code> snippet, we start by initializing with the value <code class="literal">10</code> (by default the first member is initialized). From here, <code class="literal">s.duration</code> is accessible but <code class="literal">s.code</code> is considered undefined.</p><p>Once we assign a value to <code class="literal">s.code</code>, <code class="literal">s.duration</code> becomes undefined and <code class="literal">s.code</code> is now accessible.</p><p>The <code class="literal">union</code> class makes the memory usage very efficient. In <code class="literal">QVariant</code>, when you store a value, it is stored in a private <code class="literal">union</code>:</p><pre class="programlisting">union Data 
{ 
    char c; 
    uchar uc; 
    short s; 
    signed char sc; 
    ushort us; 
    ... 
    qulonglong ull; 
    QObject *o; 
    void *ptr; 
    PrivateShared *shared; 
} data; 
</pre><p>Note the list of primitive types and at the end the complex types, <code class="literal">QObject*</code> and <code class="literal">void*</code>.</p><p>Besides <code class="literal">Data</code>, a <code class="literal">QMetaType</code> object is initialized to know the type of the stored object. The combination of <code class="literal">union</code> and <code class="literal">QMetaType</code> lets <code class="literal">QVariant</code> know which <code class="literal">Data</code> member it should use to cast the value and give it back to the caller.</p><p>Now that you know what a <code class="literal">union</code> is and how <code class="literal">QVariant</code> uses it, you might ask: why make a <code class="literal">QVariant</code> class at all? A simple <code class="literal">union</code> would not have been enough?</p><p>The answer is no. It is not enough because a <code class="literal">union</code> class cannot have members that do not have a default constructor. It drastically reduces the number of classes you can put in a <code class="literal">union</code>. Qt folks wanted to include many classes that did not have a default constructor in <code class="literal">union</code>. To mitigate this, <code class="literal">QVariant</code> was born.</p><p>What makes <code class="literal">QVariant</code> very interesting is that it is possible to store custom types. If we wanted to convert <code class="literal">SoundEvent</code> class to a <code class="literal">QVariant</code> class, we would have added the following in <code class="literal">SoundEvent.h</code>:</p><pre class="programlisting">class SoundEvent 
{ 
    ... 
}; 
Q_DECLARE_METATYPE(SoundEvent); 
</pre><p>We already used <code class="literal">Q_DECLARE_METATYPE</code> macro in <a class="link" title="Chapter 10.  Need IPC? Get Your Minions to Work" href="part0097.xhtml#aid-2SG6I2">Chapter 10</a>, <em>Need IPC? Get Your Minions to Work</em>. This macro effectively registers <code class="literal">SoundEvent</code> to the <code class="literal">QMetaType</code> register, making it available for <code class="literal">QVariant</code>. Because <code class="literal">QDataStream</code> relies on <code class="literal">QVariant</code>, we had to use this macro in the last chapter.</p><p>Now to convert back and forth with a <code class="literal">QVariant</code>:</p><pre class="programlisting">SoundEvent soundEvent(4365, 0); 
QVariant stored; 
stored.setValue(soundEvent); 
 
SoundEvent newEvent = stored.value&lt;SoundEvent&gt;(); 
qDebug() &lt;&lt; newEvent.timestamp; 
</pre><p>As you can guess, the output of this snippet is <code class="literal">4365</code>, the original <code class="literal">timestamp</code> stored in <code class="literal">soundEvent</code>.</p><p>This approach would have been perfect if we wanted to do only binary serialization. Data can be easily written and read from. However, we want to output our <code class="literal">Track</code> and <code class="literal">SoundEvents</code> to standard formats: JSON and XML.</p><p>There is a major issue with the <code class="literal">Q_DECLARE_METATYPE</code>/<code class="literal">QVariant</code> combo: it does not store any key for the fields of the serialized class. We can already foresee that the JSON object of a <code class="literal">SoundEvent</code> class will look like this:</p><pre class="programlisting">{ 
    "timestamp": 4365, 
    "soundId": 0 
} 
</pre><p>There is no way the <code class="literal">QVariant</code> class could know that we want a <code class="literal">timestamp</code> key. It will only store the raw binary data. The same principle applies for the XML counterpart.</p><p>For this reason, we are going to use a variation of a <code class="literal">QVariant</code> with a <code class="literal">QVariantMap</code>. The <code class="literal">QVariantMap</code> class is only a <code class="literal">typedef</code> on <code class="literal">QMap&lt;QString, QVariant&gt;</code>. This map will be used to store the key names of the fields and the value in the <code class="literal">QVariant</code> class. In turn, these keys will be used by the JSON and XML serialization system to output a pretty file.</p><p>Because we aim to have a flexible serialization system, we have to be able to serialize and deserialize this <code class="literal">QVariantMap</code> in multiple formats. To achieve this, we will define an interface that gives the ability for a class to serialize/deserialize its content in a <code class="literal">QVariantMap</code>.</p><p>This <code class="literal">QVariantMap</code> will be used as an intermediate format, agnostic of the final JSON, XML, or binary.</p><p>Create a C++ header named <code class="literal">Serializer.h</code>. Here is the content:</p><pre class="programlisting">#include &lt;QVariant&gt; 
 
class Serializable { 
public: 
    virtual ~Serializable() {} 
    virtual QVariant toVariant() const = 0; 
    virtual void fromVariant(const QVariant&amp; variant) = 0; 
}; 
</pre><p>By implementing this abstract base class, a class will be <code class="literal">Serializable</code>. There are only two virtual pure functions:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">toVariant()</code> function, in which the class must return a <code class="literal">QVariant</code> (or, more precisely a <code class="literal">QVariantMap</code>, which can be casted to a <code class="literal">QVariant</code> thanks to the <code class="literal">QMetaType</code> system)</li><li class="listitem">The <code class="literal">fromVariant()</code> function, in which the class must initialize its members from the variant passed as a parameter</li></ul></div><p>By doing so, we give the responsibility to the final class to load and save its content. After all, who knows better <code class="literal">SoundEvent</code> than <code class="literal">SoundEvent</code> itself?</p><p>Let's see <code class="literal">Serializable</code> in action with <code class="literal">SoundEvent</code>. Update <code class="literal">SoundEvent.h</code> like this:</p><pre class="programlisting">#include "Serializable.h" 
 
class SoundEvent : public Serializable 
{ 
    SoundEvent(qint64 timestamp = 0, int soundId = 0); 
    ~SoundEvent(); 
 
    QVariant toVariant() const override; 
    void fromVariant(const QVariant&amp; variant) override; 
 
    ... 
}; 
</pre><p>The <code class="literal">SoundEvent</code> class is now <code class="literal">Serializable</code>. Let's do the real work in <code class="literal">SoundEvent.cpp</code>:</p><pre class="programlisting">QVariant SoundEvent::toVariant() const 
{ 
    QVariantMap map; 
    map.insert("timestamp", timestamp); 
    map.insert("soundId", soundId); 
    return map; 
} 
 
void SoundEvent::fromVariant(const QVariant&amp; variant) 
{ 
    QVariantMap map = variant.toMap(); 
    timestamp = map.value("timestamp").toLongLong(); 
    soundId = map.value("soundId").toInt(); 
} 
</pre><p>In <code class="literal">toVariant()</code>, we simply declare a <code class="literal">QVariantMap</code> that gets filled with <code class="literal">timestamp</code> and <code class="literal">soundId</code>.</p><p>On the other side, in <code class="literal">fromVariant()</code>, we convert <code class="literal">variant</code> to a <code class="literal">QVariantMap</code> and retrieve its content with the same keys we used in <code class="literal">toVariant()</code>. It is as simple as that!</p><p>The next class that have to be <code class="literal">Serializable</code> is <code class="literal">Track</code>. After making <code class="literal">Track</code> inherit from <code class="literal">Serializable</code>, update <code class="literal">Track.cpp</code>:</p><pre class="programlisting">QVariant Track::toVariant() const 
{ 
    QVariantMap map; 
    map.insert("duration", mDuration); 
 
    QVariantList list; 
    for (const auto&amp; soundEvent : mSoundEvents) { 
        list.append(soundEvent-&gt;toVariant()); 
    } 
    map.insert("soundEvents", list); 
 
    return map; 
} 
</pre><p>The principle is the same, although a bit more complex. The <code class="literal">mDuration</code> variable is stored in <code class="literal">map</code> object as we have seen for <code class="literal">SoundEvent</code>. For <code class="literal">mSoundEvents</code>, we have to generate a list of <code class="literal">QVariant</code> (a <code class="literal">QVariantList</code>) where each item is the converted <code class="literal">QVariant</code> version of a <code class="literal">soundEvent</code> key.</p><p>To do so, we simply loop over <code class="literal">mSoundEvents</code> and fill <code class="literal">list</code> with the <code class="literal">soundEvent-&gt;toVariant()</code> result we covered a few paragraphs before.</p><p>Now for <code class="literal">fromVariant()</code>:</p><pre class="programlisting">void Track::fromVariant(const QVariant&amp; variant) 
{ 
    QVariantMap map = variant.toMap(); 
    mDuration = map.value("duration").toLongLong(); 
 
    QVariantList list = map.value("soundEvents").toList(); 
    for(const QVariant&amp; data : list) { 
        auto soundEvent = make_unique&lt;SoundEvent&gt;(); 
        soundEvent-&gt;fromVariant(data); 
        mSoundEvents.push_back(move(soundEvent)); 
    } 
} 
</pre><p>Here, for each element of the key <code class="literal">soundEvents</code>, we create a new <code class="literal">SoundEvent</code>, load it with the content of <code class="literal">data</code>, and finally add it to the vector <code class="literal">mSoundEvents</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec100"/>Serializing objects in JSON format</h1></div></div></div><p>The <code class="literal">Track</code> and <code class="literal">SoundEvent</code> classes can now be converted to a common Qt format <code class="literal">QVariant</code>. We now need to write a <code class="literal">Track</code> (and its <code class="literal">SoundEvent</code> objects) class in a file with a text or a binary format. This example project allows you to handle all the formats. It will allow you to switch the saved file format in one line. So where to put the specific format code? That is the million dollar question! Here is a primary approach:</p><div><img src="img/image00442.jpeg" alt="Serializing objects in JSON format"/></div><p style="clear:both; height: 1em;"> </p><p>In this proposition, the specific file format serialization code is inside a dedicated child class. Well, it works but what would the hierarchy look like if we add two new file formats? Moreover, each time we add a new object to serialize, we have to create all these children classes to handle the different serialization file formats. This massive inheritance tree can quickly become a sticky mess. The code will be unmaintainable. You do not want to do that. So, here is where the bridge pattern can be a good solution:</p><div><img src="img/image00443.jpeg" alt="Serializing objects in JSON format"/></div><p style="clear:both; height: 1em;"> </p><p>In a bridge pattern, we decouple the classes in two inheritance hierarchies:</p><div><ul class="itemizedlist"><li class="listitem">The components independent from the file format. The <code class="literal">SoundEvent</code> and <code class="literal">Track</code> objects do not care about JSON, XML, or a binary format.</li><li class="listitem">The file format implementations. The <code class="literal">JsonSerializer</code>, <code class="literal">XmlSerializer</code> and <code class="literal">BinarySerializer</code> handle a generic format, <code class="literal">Serializable</code>, not a specific component such as <code class="literal">SoundEvent</code> or <code class="literal">Track</code>.</li></ul></div><p>Notice that in a classic bridge pattern, an abstraction (<code class="literal">Serializable</code>) should contains an implementor (<code class="literal">Serializer</code>) variable. The caller only deals with the abstraction. However in this project example, <code class="literal">MainWindow</code> has the ownership of <code class="literal">Serializable</code> and also of <code class="literal">Serializer</code>. This is a personal choice to use the power of design pattern while keeping uncoupled functional classes.</p><p>The architecture of <code class="literal">Serializable</code> and <code class="literal">Serializer</code> is clear. The <code class="literal">Serializable</code> class is already implemented so you can now create a new C++ header file called <code class="literal">Serializer.h</code>:</p><pre class="programlisting">#include &lt;QString&gt; 
 
#include "Serializable.h" 
 
class Serializer 
{ 
public: 
    virtual ~Serializer() {} 
 
    virtual void save(const Serializable&amp; serializable, 
        const QString&amp; filepath,  
        const QString&amp; rootName = "") = 0; 
    virtual void load(Serializable&amp; serializable,  
        const QString&amp; filepath) = 0; 
}; 
</pre><p>The <code class="literal">Serializer</code> class is an interface, an abstract class with only pure virtual functions and no data. Let's talk about the <code class="literal">save()</code> function:</p><div><ul class="itemizedlist"><li class="listitem">This function saves <code class="literal">Serializable</code> to a file on the hard disk drive.</li><li class="listitem">The <code class="literal">Serializable</code> class is <code class="literal">const</code> and cannot be modified by this function.</li><li class="listitem">The <code class="literal">filepath</code> function indicates the destination file to create.</li><li class="listitem">Some <code class="literal">Serializer</code> implementations can use the <code class="literal">rootName</code> variable. For example, if we request to save a <code class="literal">Track</code> object, the <code class="literal">rootName</code> variable could be the string <code class="literal">track</code>. This is the label used to write the root element. The XML implementation requires this information.</li></ul></div><p>The <code class="literal">load()</code> function is also easy to understand:</p><div><ul class="itemizedlist"><li class="listitem">This function loads data from a file to fill a <code class="literal">Serializable</code> class</li><li class="listitem">The <code class="literal">Serializable</code> class will be updated by this function</li><li class="listitem">The <code class="literal">filepath</code> function indicates which file to read</li></ul></div><p>The interface <code class="literal">Serializer</code> is ready and waits for some implementations! Let's start with JSON. Create a C++ class, <code class="literal">JsonSerializer</code>. Here is the header for <code class="literal">JsonSerializer.h</code>:</p><pre class="programlisting">#include "Serializer.h" 
 
class JsonSerializer : public Serializer 
{ 
public: 
    JsonSerializer(); 
 
    void save(const Serializable&amp; serializable,  
        const QString&amp; filepath, 
        const QString&amp; rootName) override; 
    void load(Serializable&amp; serializable, 
        const QString&amp; filepath) override; 
}; 
</pre><p>No difficulties here; we have to provide an implementation of <code class="literal">save()</code> and <code class="literal">load()</code>. Here is the <code class="literal">save()</code> implementation:</p><pre class="programlisting">void JsonSerializer::save(const Serializable&amp; serializable, 
    const QString&amp; filepath, const QString&amp; /*rootName*/) 
{ 
    QJsonDocument doc =     
        QJsonDocument::fromVariant(serializable.toVariant()); 
    QFile file(filepath); 
    file.open(QFile::WriteOnly); 
    file.write(doc.toJson()); 
    file.close(); 
} 
</pre><p>The Qt framework provides a nice way to read and write a JSON file with the <code class="literal">QJsonDocument</code> class. We can create a <code class="literal">QJsonDocument</code> class from a <code class="literal">QVariant</code> class. Notice that the <code class="literal">QVariant</code> accepted by <code class="literal">QJsonDocument</code> must be a <code class="literal">QVariantMap</code>, <code class="literal">QVariantList</code>, or <code class="literal">QStringList</code>. No worries, the <code class="literal">toVariant()</code> function of <code class="literal">Track</code> class and <code class="literal">SoundEvent</code> generates a <code class="literal">QVariantMap</code>. Then, we can create a <code class="literal">QFile</code> file with the destination <code class="literal">filepath</code>. The <code class="literal">QJsonDocument::toJson()</code> function converts it to a UTF-8 encoded text representation. We write this result to the <code class="literal">QFile</code> file and close the file.</p><div><h3 class="title"><a id="tip51"/>Tip</h3><p>The <code class="literal">QJsonDocument::toJson()</code> function can produce an <code class="literal">Indented</code> or a <code class="literal">Compact</code> JSON format. By default, the format is <code class="literal">QJsonDocument::Indented</code>.</p></div><p>The <code class="literal">load()</code> implementation is also short:</p><pre class="programlisting">void JsonSerializer::load(Serializable&amp; serializable, 
    const QString&amp; filepath) 
{ 
    QFile file(filepath); 
    file.open(QFile::ReadOnly); 
    QJsonDocument doc = QJsonDocument::fromJson(file.readAll()); 
    file.close(); 
    serializable.fromVariant(doc.toVariant()); 
} 
</pre><p>We open a <code class="literal">QFile</code> with the source <code class="literal">filepath</code>. We read all the data with <code class="literal">QFile::readAll()</code>. Then we can create a <code class="literal">QJsonDocument</code> class with the <code class="literal">QJsonDocument::fromJson()</code> function. Finally, we can fill our destination <code class="literal">Serializable</code> with the <code class="literal">QJsonDocument</code> converted to a <code class="literal">QVariant</code> class. Notice that the <code class="literal">QJsonDocument::toVariant()</code> function can return <code class="literal">QVariantList</code> or a <code class="literal">QVariantMap</code> depending the nature of the JSON document.</p><p>Here is an example of a <code class="literal">Track</code> class saved with this <code class="literal">JsonSerializer</code>:</p><pre class="programlisting">{ 
    "duration": 6205, 
    "soundEvents": [ 
        { 
            "soundId": 0, 
            "timestamp": 2689 
        }, 
        { 
            "soundId": 2, 
            "timestamp": 2690 
        }, 
        { 
            "soundId": 2, 
            "timestamp": 3067 
        } 
    ] 
} 
</pre><p>The root element is a JSON object, represented by a map with two keys:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Duration</code>: This is a simple integer value</li><li class="listitem"><code class="literal">soundEvents</code>: This is an array of objects. Each object is a map with the following keys:</li><li class="listitem"><code class="literal">soundId</code>: This is an integer</li><li class="listitem"><code class="literal">timestamp</code>: This is also an integer</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec101"/>Serializing objects in XML format</h1></div></div></div><p>The JSON serialization was a direct representation of the C++ objects and Qt already provides all we need. However, the serialization of a C++ object can be done with various representations in an XML format. So we have to write the XML â” <code class="literal">QVariant</code> conversion ourselves. We have decided to use the following XML representation:</p><pre class="programlisting">&lt;[name]&gt; type="[type]"&gt;[data]&lt;/[name]&gt; 
</pre><p>For example, the <code class="literal">soundId</code> type gives this XML representation:</p><pre class="programlisting">&lt;soundId type="int"&gt;2&lt;/soundId&gt; 
</pre><p>Create a C++ class <code class="literal">XmlSerializer</code> that also inherits from <code class="literal">Serializer</code>. Let's begin with the <code class="literal">save()</code> function, here is <code class="literal">XmlSerializer.h</code>:</p><pre class="programlisting">#include &lt;QXmlStreamWriter&gt; 
#include &lt;QXmlStreamReader&gt; 
 
#include "Serializer.h" 
 
class XmlSerializer : public Serializer 
{ 
public: 
    XmlSerializer(); 
 
    void save(const Serializable&amp; serializable,  
        const QString&amp; filepath,  
        const QString&amp; rootName) override; 
}; 
</pre><p>Now we can see the <code class="literal">save()</code> implementation in <code class="literal">XmlSerializer.cpp</code>:</p><pre class="programlisting">void XmlSerializer::save(const Serializable&amp; serializable, const QString&amp; filepath, const QString&amp; rootName) 
{ 
    QFile file(filepath); 
    file.open(QFile::WriteOnly); 
    QXmlStreamWriter stream(&amp;file); 
    stream.setAutoFormatting(true); 
    stream.writeStartDocument(); 
    writeVariantToStream(rootName, serializable.toVariant(), 
        stream); 
    stream.writeEndDocument(); 
    file.close(); 
} 
</pre><p>We create a <code class="literal">QFile</code> file with the <code class="literal">filepath</code> destination. We construct a <code class="literal">QXmlStreamWriter</code> object that writes in the <code class="literal">QFile</code>. By default, the writer will produce a compact XML; you can generate a pretty XML with the <code class="literal">QXmlStreamWriter::setAutoFormatting()</code> function. The <code class="literal">QXmlStreamWriter::writeStartDocument()</code> function writes the XML version and the encoding. We write our <code class="literal">QVariant</code> in the XML stream with our <code class="literal">writeVariantToStream()</code> function. Finally, we end the document and close the <code class="literal">QFile</code>. As already explained, writing a <code class="literal">QVariant</code> to an XML stream depends on how you want to represent the data. So we have to write the conversion function. Please update your class with <code class="literal">writeVariantToStream()</code> like this:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    void writeVariantToStream(const QString&amp; nodeName, 
        const QVariant&amp; variant, QXmlStreamWriter&amp; stream); 
 
//XmlSerializer.cpp 
void XmlSerializer::writeVariantToStream(const QString&amp; nodeName, 
    const QVariant&amp; variant, QXmlStreamWriter&amp; stream) 
{ 
    stream.writeStartElement(nodeName); 
    stream.writeAttribute("type", variant.typeName()); 
 
    switch (variant.type()) { 
        case QMetaType::QVariantList: 
            writeVariantListToStream(variant, stream); 
            break; 
        case QMetaType::QVariantMap: 
            writeVariantMapToStream(variant, stream); 
            break; 
        default: 
            writeVariantValueToStream(variant, stream); 
            break; 
    } 
 
    stream.writeEndElement(); 
} 
</pre><p>This <code class="literal">writeVariantToStream()</code> function is a generic entry point. It will be called each time we want to put a <code class="literal">QVariant</code> in the XML stream. The <code class="literal">QVariant</code> class could be a list, a map, or data. So we apply a specific treatment if the <code class="literal">QVariant</code> is a container (<code class="literal">QVariantList</code> or <code class="literal">QVariantMap</code>). All the other cases are considered to be a data value. Here are the steps of this function:</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new XML element with the <code class="literal">writeStartElement()</code> function. The <code class="literal">nodeName</code> will be used to create the XML tag. For example, <code class="literal">&lt;soundId</code>.</li><li class="listitem">Write an XML attribute called <code class="literal">type</code> in the current element. We use the name of the type stored in the <code class="literal">QVariant</code>. For example, <code class="literal">&lt;soundId type="int"</code>.</li><li class="listitem">Depending on the <code class="literal">QVariant</code> data type, we call one of our XML serialization functions. For example, <code class="literal">&lt;soundId type="int"&gt;2</code>.</li><li class="listitem">Finally, we end the current XML element with <code class="literal">writeEndElement()</code>:<div><ul class="itemizedlist"><li class="listitem">The final result is: <code class="literal">&lt;soundId type="int"&gt;2&lt;/soundId&gt;</code></li><li class="listitem">In this function, we call three helper functions that we will create now. The easiest one is <code class="literal">writeVariantValueToStream()</code>. Please update your <code class="literal">XmlSerializer</code> class with:<pre class="programlisting">//XmlSerializer.h 
void writeVariantValueToStream(const QVariant&amp; variant, 
    QXmlStreamWriter&amp; stream); 
 
//XmlSerializer.cpp 
void XmlSerializer::writeVariantValueToStream( 
    const QVariant&amp; variant, QXmlStreamWriter&amp; stream) 
{ 
    stream.writeCharacters(variant.toString()); 
} 
</pre></li></ul></div></li></ol><div></div><p>If the <code class="literal">QVariant</code> is a simple type, we retrieve its <code class="literal">QString</code> representation. Then we use <code class="literal">QXmlStreamWriter::writeCharacters()</code> to write this <code class="literal">QString</code> in the XML stream.</p><p>The second helper function is <code class="literal">writeVariantListToStream()</code>. Here is its implementation:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    void writeVariantListToStream(const QVariant&amp; variant, 
        QXmlStreamWriter&amp; stream); 
 
//XmlSerializer.cpp 
void XmlSerializer::writeVariantListToStream( 
    const QVariant&amp; variant, QXmlStreamWriter&amp; stream) 
{ 
    QVariantList list = variant.toList(); 
 
    for(const QVariant&amp; element : list) { 
        writeVariantToStream("item", element, stream); 
    } 
} 
</pre><p>At this step, we already know that the <code class="literal">QVariant</code> is a <code class="literal">QVariantList</code>. We call <code class="literal">QVariant::toList()</code> to retrieve the list. Then we iterate over all elements of the list and call our generic entry point, <code class="literal">writeVariantToStream()</code>. Notice that we retrieve the elements from a list so we do not have an element name. But the tag name does not matter for a list item serialization, so insert the arbitrary label <code class="literal">item</code>.</p><p>The last write helper function is <code class="literal">writeVariantMapToStream()</code>:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    void writeVariantMapToStream(const QVariant&amp; variant, 
        QXmlStreamWriter&amp; stream); 
 
//XmlSerializer.cpp 
void XmlSerializer::writeVariantMapToStream( 
    const QVariant&amp; variant, QXmlStreamWriter&amp; stream) 
{ 
    QVariantMap map = variant.toMap(); 
    QMapIterator&lt;QString, QVariant&gt; i(map); 
 
    while (i.hasNext()) { 
        i.next(); 
        writeVariantToStream(i.key(), i.value(), stream); 
    } 
} 
</pre><p>The <code class="literal">QVariant</code> is a container but a <code class="literal">QVariantMap</code> this time. We call <code class="literal">writeVariantToStream()</code> for each element found. The tag name is important because this is a map. We use the map key from <code class="literal">QMapIterator::key()</code> as the node name.</p><p>The saving part is over. We can now implement the loading part. Its architecture follows the same spirit as the saving functions. Let's begin with the <code class="literal">load()</code> function:</p><pre class="programlisting">//XmlSerializer.h 
public: 
    void load(Serializable&amp; serializable,  
        const QString&amp; filepath) override; 
 
//XmlSerializer.cpp 
void XmlSerializer::load(Serializable&amp; serializable, 
    const QString&amp; filepath) 
{ 
    QFile file(filepath); 
    file.open(QFile::ReadOnly); 
    QXmlStreamReader stream(&amp;file); 
    stream.readNextStartElement(); 
    serializable.fromVariant(readVariantFromStream(stream)); 
} 
</pre><p>The first thing to do is to create a <code class="literal">QFile</code> with the source <code class="literal">filepath</code>. We construct a <code class="literal">QXmlStreamReader</code> with the <code class="literal">QFile</code>. The <code class="literal">QXmlStreamReader ::readNextStartElement()</code> function reads until the next start element in the XML stream. Then we can use our read helper function, <code class="literal">readVariantFromStream()</code>, to create a <code class="literal">QVariant</code> class from an XML stream. Finally, we can use our <code class="literal">Serializable::fromVariant()</code> to fill the destination <code class="literal">serializable</code>. Let's implement the helper function, <code class="literal">readVariantFromStream()</code>:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    QVariant readVariantFromStream(QXmlStreamReader&amp; stream); 
 
//XmlSerializer.cpp 
QVariant XmlSerializer::readVariantFromStream(QXmlStreamReader&amp; stream) 
{ 
    QXmlStreamAttributes attributes = stream.attributes(); 
    QString typeString = attributes.value("type").toString(); 
 
    QVariant variant; 
    switch (QVariant::nameToType( 
            typeString.toStdString().c_str())) { 
        case QMetaType::QVariantList: 
            variant = readVariantListFromStream(stream); 
            break; 
        case QMetaType::QVariantMap: 
            variant = readVariantMapFromStream(stream); 
            break; 
        default: 
            variant = readVariantValueFromStream(stream); 
            break; 
    } 
 
    return variant; 
} 
</pre><p>The role of this function is to create a <code class="literal">QVariant</code>. Firstly, we retrieve the <code class="literal">"type"</code> from the XML attributes. In our case, we have only one attribute to handle. Then, depending on the type, we will call one of our three read helper functions. Let's implement the <code class="literal">readVariantValueFromStream()</code> function:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    QVariant readVariantValueFromStream(QXmlStreamReader&amp; stream); 
 
//XmlSerializer.cpp 
QVariant XmlSerializer::readVariantValueFromStream( 
    QXmlStreamReader&amp; stream) 
{ 
    QXmlStreamAttributes attributes = stream.attributes(); 
    QString typeString = attributes.value("type").toString(); 
    QString dataString = stream.readElementText(); 
 
    QVariant variant(dataString); 
    variant.convert(QVariant::nameToType( 
        typeString.toStdString().c_str())); 
    return variant; 
} 
</pre><p>This function create a <code class="literal">QVariant</code> with its data depending on the type. Like the previous function, we retrieve the type from the XML attribute. We also read the data as a text with the <code class="literal">QXmlStreamReader::readElementText()</code> function. A <code class="literal">QVariant</code> class is created with this <code class="literal">QString</code> data. At this step, the <code class="literal">QVariant</code> type is a <code class="literal">QString</code>. So we use the <code class="literal">QVariant::convert()</code> function to convert the <code class="literal">QVariant</code> to the real type (<code class="literal">int</code> , <code class="literal">qlonglong</code>, and so on).</p><p>The second read helper function is <code class="literal">readVariantListFromStream()</code>:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    QVariant readVariantListFromStream(QXmlStreamReader&amp; stream); 
 
//XmlSerializer.cpp 
QVariant XmlSerializer::readVariantListFromStream(QXmlStreamReader&amp; stream) 
{ 
    QVariantList list; 
    while(stream.readNextStartElement()) { 
        list.append(readVariantFromStream(stream)); 
    } 
    return list; 
} 
</pre><p>We know that the stream element contains an array. So, this function creates and returns a <code class="literal">QVariantList</code>. The <code class="literal">QXmlStreamReader::readNextStartElement()</code> function reads until the next start element and returns <code class="literal">true</code> if a start element is found within the current element. We call the entry-point function, <code class="literal">readVariantFromStream()</code>, for each element. Finally, we return the <code class="literal">QVariantList</code>.</p><p>The last helper function to cover is <code class="literal">readVariantMapFromStream()</code>. Update your file with the following snippet:</p><pre class="programlisting">//XmlSerializer.h 
private: 
    QVariant readVariantMapFromStream(QXmlStreamReader&amp; stream); 
 
//XmlSerializer.cpp 
QVariant XmlSerializer::readVariantMapFromStream( 
    QXmlStreamReader&amp; stream) 
{ 
    QVariantMap map; 
    while(stream.readNextStartElement()) { 
        map.insert(stream.name().toString(), 
                   readVariantFromStream(stream)); 
    } 
    return map; 
} 
</pre><p>This function sounds like the <code class="literal">readVariantListFromStream()</code>. This time we have to create a <code class="literal">QVariantMap</code>. The key used for inserting a new item is the element name. We retrieve the name with the <code class="literal">QXmlStreamReader::name()</code> function.</p><p>A <code class="literal">Track</code> class serialized with the <code class="literal">XmlSerializer</code> looks like this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;track type="QVariantMap"&gt; 
    &lt;duration type="qlonglong"&gt;6205&lt;/duration&gt; 
    &lt;soundEvents type="QVariantList"&gt; 
        &lt;item type="QVariantMap"&gt; 
            &lt;soundId type="int"&gt;0&lt;/soundId&gt; 
            &lt;timestamp type="qlonglong"&gt;2689&lt;/timestamp&gt; 
        &lt;/item&gt; 
        &lt;item type="QVariantMap"&gt; 
            &lt;soundId type="int"&gt;2&lt;/soundId&gt; 
            &lt;timestamp type="qlonglong"&gt;2690&lt;/timestamp&gt; 
        &lt;/item&gt; 
        &lt;item type="QVariantMap"&gt; 
            &lt;soundId type="int"&gt;2&lt;/soundId&gt; 
            &lt;timestamp type="qlonglong"&gt;3067&lt;/timestamp&gt; 
        &lt;/item&gt; 
    &lt;/soundEvents&gt; 
&lt;/track&gt; 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec102"/>Serializing objects in binary format</h1></div></div></div><p>The XML serialization is fully functional! We can now switch to the last type of serialization covered in this chapter.</p><p>The binary serialization is easier because Qt provides a direct way to do it. Please create a <code class="literal">BinarySerializer</code> class that inherits from <code class="literal">Serializer</code>. The header is common, we have only the override functions, <code class="literal">save()</code> and <code class="literal">load()</code>. Here is the implementation of the <code class="literal">save()</code> function:</p><pre class="programlisting">void BinarySerializer::save(const Serializable&amp; serializable, 
    const QString&amp; filepath, const QString&amp; /*rootName*/) 
{ 
    QFile file(filepath); 
    file.open(QFile::WriteOnly); 
    QDataStream dataStream(&amp;file); 
    dataStream &lt;&lt; serializable.toVariant(); 
    file.close(); 
} 
</pre><p>We hope you recognized the <code class="literal">QDataStream</code> class used in <a class="link" title="Chapter 10.  Need IPC? Get Your Minions to Work" href="part0097.xhtml#aid-2SG6I2">Chapter 10</a>, <em>Need IPC? Get Your Minions to Work</em>. This time we use this class to serialize binary data in a destination <code class="literal">QFile</code>. A <code class="literal">QDataStream</code> class accepts a <code class="literal">QVariant</code> class with the <code class="literal">&lt;&lt;</code> operator. Notice that the <code class="literal">rootName</code> variable is not used in the binary serializer.</p><p>Here is the <code class="literal">load()</code> function:</p><pre class="programlisting">void BinarySerializer::load(Serializable&amp; serializable, const QString&amp; filepath) 
{ 
    QFile file(filepath); 
    file.open(QFile::ReadOnly); 
    QDataStream dataStream(&amp;file); 
    QVariant variant; 
    dataStream &gt;&gt; variant; 
    serializable.fromVariant(variant); 
    file.close(); 
} 
</pre><p>Thanks to the <code class="literal">QVariant</code> and the <code class="literal">QDataStream</code> mechanism, the task is easy. We open the <code class="literal">QFile</code> with the source <code class="literal">filepath</code>. We construct a <code class="literal">QDatastream</code> class with this <code class="literal">QFile</code>. Then, we use the <code class="literal">&gt;&gt;</code> operator to read the root <code class="literal">QVariant</code>. Finally, we fill the source <code class="literal">Serializable</code> with our <code class="literal">Serializable::fromVariant()</code> function.</p><p>Do not worry, we will not include an example of a <code class="literal">Track</code> class serialized with the <code class="literal">BinarySerializer</code> class.</p><p>The serialization part is completed. The GUI part of this example project has been covered many times during the previous chapters of this book. The following sections will only cover specific features used in our <code class="literal">MainWindow</code> and <code class="literal">SoundEffectWidget </code>classes. Check the source code if you need the complete C++ classes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec103"/>Playing low latency sounds with QSoundEffect</h1></div></div></div><p>The project application <code class="literal">ch11-drum-machine</code> displays four <code class="literal">SoundEffectWidget</code> widgets: <code class="literal">kickWidget</code>, <code class="literal">snareWidget</code>, <code class="literal">hihatWidget</code>, and <code class="literal">crashWidget</code>.</p><p>Each <code class="literal">SoundEffectWidget</code> widget displays a <code class="literal">QLabel</code> and a <code class="literal">QPushButton</code>. The label displays the sound name. If the button is clicked, a sound is played.</p><p>The Qt Multimedia module provides two main ways to play an audio file:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">QMediaPlayer</code>: This file can play songs, movies, and Internet radio with various input formats</li><li class="listitem"><code class="literal">QSoundEffect</code>: This file can play low-latency <code class="literal">.wav</code> files</li></ul></div><p>This project example is a virtual drum machine, so we are using a <code class="literal">QSoundEffect</code> object. The first step to use a <code class="literal">QSoundEffect</code> is to update your <code class="literal">.pro</code> file like this:</p><pre class="programlisting">QT       += core gui multimedia 
</pre><p>Then you can initialize the sound. Here is an example:</p><pre class="programlisting">QUrl urlKick("qrc:/sounds/kick.wav"); 
QUrl urlBetterKick = QUrl::fromLocalFile("/home/better-kick.wav"); 
 
QSoundEffect soundEffect; 
QSoundEffect.setSource(urlBetterKick); 
</pre><p>The first step is to create a valid <code class="literal">QUrl</code> for your sound file. The <code class="literal">urlKick</code> is initialized from a <code class="literal">.qrc</code> resources file path, while <code class="literal">urlBetterKick</code> is created from a local file path. Then we can create <code class="literal">QSoundEffect</code> and set the URL sound to play with the <code class="literal">QSoundEffect::setSource()</code> function.</p><p>Now that we have a <code class="literal">QSoundEffect</code> object initialized, we can play the sound with the following code snippet:</p><pre class="programlisting">soundEffect.setVolume(1.0f); 
soundEffect.play(); 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec104"/>Triggering a QButton with your keyboard</h1></div></div></div><p>Let's explore the public slot, <code class="literal">triggerPlayButton()</code>, in the <code class="literal">SoundEffectWidget</code> class:</p><pre class="programlisting">//SoundEffectWidget.h 
class SoundEffectWidget : public QWidget 
{ 
... 
public slots: 
    void triggerPlayButton(); 
    ... 
 
private: 
    QPushButton* mPlayButton; 
    ... 
}; 
 
//SoundEffectWidget.cpp 
void SoundEffectWidget::triggerPlayButton() 
{ 
   mPlayButton-&gt;animateClick(); 
} 
</pre><p>This widget has a <code class="literal">QPushButton</code> called <code class="literal">mPlayButton</code>. The <code class="literal">triggerPlayButton()</code> slot calls the <code class="literal">QPushButton::animateClick()</code> function, which simulates a click on the button over 100 ms by default. All signals will be sent as a real click does. The button really appears to be down. If you do not want the animation you can call <code class="literal">QPushButton::click()</code>.</p><p>Let's see now how to trigger this slot with a key. Each <code class="literal">SoundEffectWidget</code> has a <code class="literal">Qt:Key</code>:</p><pre class="programlisting">//SoundEffectWidget.h 
class SoundEffectWidget : public QWidget 
{ 
... 
public: 
    Qt::Key triggerKey() const; 
    void setTriggerKey(const Qt::Key&amp; triggerKey); 
}; 
 
//SoundEffectWidget.cpp 
Qt::Key SoundEffectWidget::triggerKey() const 
{ 
    return mTriggerKey; 
} 
 
void SoundEffectWidget::setTriggerKey(const Qt::Key&amp; triggerKey) 
{ 
    mTriggerKey = triggerKey; 
} 
</pre><p>The <code class="literal">SoundEffectWidget</code> class provides a getter and a setter to get and set the member variable, <code class="literal">mTriggerKey</code>.</p><p>The <code class="literal">MainWindow</code> class initializes the keys of its four <code class="literal">SoundEffectWidget</code> like this:</p><pre class="programlisting">ui-&gt;kickWidget-&gt;setTriggerKey(Qt::Key_H); 
ui-&gt;snareWidget-&gt;setTriggerKey(Qt::Key_J); 
ui-&gt;hihatWidget-&gt;setTriggerKey(Qt::Key_K); 
ui-&gt;crashWidget-&gt;setTriggerKey(Qt::Key_L); 
</pre><p>By default, the <code class="literal">QObject::eventFilter()</code> function is not called. To enable it and intercept these events, we need to install an event filter on the <code class="literal">MainWindow</code>:</p><pre class="programlisting">installEventFilter(this); 
</pre><p>So each time the <code class="literal">MainWindow</code> receives an event, the <code class="literal">MainWindow::eventFilter()</code> function is called.</p><p>Here is the <code class="literal">MainWindow.h</code> header:</p><pre class="programlisting">class MainWindow : public QMainWindow 
{ 
    Q_OBJECT 
public: 
    ... 
    bool eventFilter(QObject* watched, QEvent* event) override; 
 
private: 
    QVector&lt;SoundEffectWidget*&gt; mSoundEffectWidgets; 
    ... 
}; 
</pre><p>The <code class="literal">MainWindow</code> class has a <code class="literal">QVector</code> with the four <code class="literal">SoundEffectWidgets</code> (<code class="literal">kickWidget</code>, <code class="literal">snareWidget</code>, <code class="literal">hihatWidget</code>, and <code class="literal">crashWidget</code>). Let's see the implementation in <code class="literal">MainWindow.cpp</code>:</p><pre class="programlisting">bool MainWindow::eventFilter(QObject* watched, QEvent* event) 
{ 
    if (event-&gt;type() == QEvent::KeyPress) { 
        QKeyEvent* keyEvent = static_cast&lt;QKeyEvent*&gt;(event); 
        for(SoundEffectWidget* widget : mSoundEffectWidgets) { 
            if (keyEvent-&gt;key() == widget-&gt;triggerKey()) { 
                widget-&gt;triggerPlayButton(); 
                return true; 
            } 
        } 
    } 
    return QObject::eventFilter(watched, event); 
} 
</pre><p>The first thing to do is to check that the <code class="literal">QEvent</code> class is a <code class="literal">KeyPress</code> type. We do not care about other event types. If the event type is correct, we proceed to the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Cast the <code class="literal">QEvent</code> class to <code class="literal">QKeyEvent</code>.</li><li class="listitem">Then we search if the pressed key belongs to the <code class="literal">SoundEffectWidget</code> class.</li><li class="listitem">If a <code class="literal">SoundEffectWidget</code> class corresponds to the key, we call our <code class="literal">SoundEffectWidget::triggerPlayButton()</code> function and we return <code class="literal">true</code> to indicate that we consumed the event and it must not be propagated to others classes.</li><li class="listitem">Otherwise, we call the <code class="literal">QObject</code> class implementation of <code class="literal">eventFilter()</code>.</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec105"/>Bringing PlaybackWorker to life</h1></div></div></div><p>The user can play a sound live with a mouse click or a keyboard key. But when he records an awesome beat, the application must be able to play it again with the <code class="literal">PlaybackWorker</code> class. Let's see how <code class="literal">MainWindow</code> uses this worker. Here is the <code class="literal">MainWindow.h</code> related to the <code class="literal">PlaybackWorker</code> class:</p><pre class="programlisting">class MainWindow : public QMainWindow 
{ 
... 
private slots: 
    void playSoundEffect(int soundId); 
    void clearPlayback(); 
    void stopPlayback(); 
    ... 
 
private: 
    void startPlayback(); 
    ... 
 
private: 
    PlaybackWorker* mPlaybackWorker; 
    QThread* mPlaybackThread; 
    ... 
}; 
</pre><p>As you can see, <code class="literal">MainWindow</code> has <code class="literal">PlaybackWorker</code> and a <code class="literal">QThread</code> member variables. Let's see the implementation of <code class="literal">startPlayback()</code>:</p><pre class="programlisting">void MainWindow::startPlayback() 
{ 
    clearPlayback(); 
 
    mPlaybackThread = new QThread(); 
 
    mPlaybackWorker = new PlaybackWorker(mTrack); 
    mPlaybackWorker-&gt;moveToThread(mPlaybackThread); 
 
    connect(mPlaybackThread, &amp;QThread::started, 
            mPlaybackWorker, &amp;PlaybackWorker::play); 
    connect(mPlaybackThread, &amp;QThread::finished, 
            mPlaybackWorker, &amp;QObject::deleteLater); 
 
    connect(mPlaybackWorker, &amp;PlaybackWorker::playSound, 
            this, &amp;MainWindow::playSoundEffect); 
 
    connect(mPlaybackWorker, &amp;PlaybackWorker::trackFinished, 
            &amp;mTrack, &amp;Track::stop); 
 
    mPlaybackThread-&gt;start(QThread::HighPriority); 
} 
</pre><p>Let's analyze all the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">We clear the current playback with the <code class="literal">clearPlayback()</code> function, which will be covered soon.</li><li class="listitem">The new <code class="literal">QThread</code> and <code class="literal">PlaybackWorker</code> are constructed. The current track is given to the worker at this moment. As usual, the worker is then moved to its dedicated thread.</li><li class="listitem">We want to play the track as soon as possible. So, when the <code class="literal">QThread</code> emits the <code class="literal">started()</code> signal, the <code class="literal">PlaybackWorker::play()</code> slot is called.</li><li class="listitem">We do not want to worry about the <code class="literal">PlaybackWorker</code> memory. So when the <code class="literal">QThread</code> is over and it has sent the <code class="literal">finished()</code> signal, we call the <code class="literal">QObject::deleteLater()</code> slot, which schedules the worker for deletion.</li><li class="listitem">When the <code class="literal">PlaybackWorker</code> class needs to play a sound, the <code class="literal">playSound()</code> signal is emitted and our <code class="literal">MainWindow:playSoundEffect()</code> slot is called.</li><li class="listitem">The last connect covers when the <code class="literal">PlaybackWorker</code> class finishes playing the whole track. A <code class="literal">trackFinished()</code> signal is emitted and we call the <code class="literal">Track::Stop()</code> slot.</li><li class="listitem">Finally, the thread is started with a high priority. Notice that some operating systems (for example, Linux) do not support thread priorities.</li></ol><div></div><p>We can now see the <code class="literal">stopPlayback()</code> body:</p><pre class="programlisting">void MainWindow::stopPlayback() 
{ 
    mPlaybackWorker-&gt;stop(); 
    clearPlayback(); 
} 
</pre><p>We call the <code class="literal">stop()</code> function of the <code class="literal">PlaybackWorker</code> from our thread. Because we use a <code class="literal">QAtomicInteger</code> in <code class="literal">stop()</code>, the function is thread-safe and can be directly called. Finally, we call our helper function, <code class="literal">clearPlayback()</code>. This is the second time that we use <code class="literal">clearPlayback()</code>, so let's implement it:</p><pre class="programlisting">void MainWindow::clearPlayback() 
{ 
    if (mPlaybackThread) { 
        mPlaybackThread-&gt;quit(); 
        mPlaybackThread-&gt;wait(1000); 
        mPlaybackThread = nullptr; 
        mPlaybackWorker = nullptr; 
    } 
} 
</pre><p>No surprises here. If the thread is valid, we ask the thread to exit and wait 1 second. Then, we set the thread and the worker to <code class="literal">nullptr</code>.</p><p>The <code class="literal">PlaybackWorker::PlaySound</code> signal is connected to <code class="literal">MainWindow::playSoundEffect()</code>. Here is the implementation:</p><pre class="programlisting">void MainWindow::playSoundEffect(int soundId) 
{ 
   mSoundEffectWidgets[soundId]-&gt;triggerPlayButton(); 
} 
</pre><p>This slot retrieves the <code class="literal">SoundEffectWidget</code> class corresponding to the <code class="literal">soundId</code>. Then, we call the <code class="literal">triggerPlayButton()</code>, the same method that is called when you press the trigger key on your keyboard.</p><p>So, when you click on the button, press a key, or when the <code class="literal">PlaybackWorker</code> class requests to play a sound, the <code class="literal">QPushButton</code> of <code class="literal">SoundEffectWidget</code> emits the signal, <code class="literal">clicked()</code>. This signal is connected to our <code class="literal">SoundEffectWidget::play()</code> slot. The next snippet describes this slot:</p><pre class="programlisting">void SoundEffectWidget::play() 
{ 
    mSoundEffect.play(); 
    emit soundPlayed(mId); 
} 
</pre><p>Nothing fancy here. We call the <code class="literal">play()</code> function on the <code class="literal">QSoundEffect</code> already covered. Finally, we emit the <code class="literal">soundPlayed()</code> signal that is used by <code class="literal">Track</code> to add a new <code class="literal">SoundEvent</code> if we are in the <code class="literal">RECORDING</code> state.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec106"/>Accepting mouse drag and drop events</h1></div></div></div><p>In this project example, if you drag and drop a <code class="literal">.wav</code> file on a <code class="literal">SoundEffectWidget</code>, you can change the sound played. The constructor of <code class="literal">SoundEffectWidget</code> performs a specific task to allow drag and drop:</p><pre class="programlisting">setAcceptDrops(true); 
</pre><p>We can now override the drag and drop callbacks. Let's start with the <code class="literal">dragEnterEvent()</code> function:</p><pre class="programlisting">//SoundEffectWidget.h 
class SoundEffectWidget : public QWidget 
{ 
... 
protected: 
    void dragEnterEvent(QDragEnterEvent* event) override; 
... 
}; 
 
//SoundEffectWidget.cpp 
void SoundEffectWidget::dragEnterEvent(QDragEnterEvent* event) 
{ 
    if (event-&gt;mimeData()-&gt;hasFormat("text/uri-list")) { 
        event-&gt;acceptProposedAction(); 
    } 
} 
</pre><p>The <code class="literal">dragEnterEvent()</code> function is called each time the user drags an object on the widget. In our case, we only want to allow drag and drop on files that are of the MIME type: <code class="literal">"text/uri-list"</code> (a list of URIs, which can be <code class="literal">file://</code>, <code class="literal">http://</code>, and so on). In this case, though we can call the <code class="literal">QDragEnterEvent::acceptProposedAction()</code> function to notify that we accept this object for a drag and drop.</p><p>We can now add a second function, <code class="literal">dropEvent()</code>:</p><pre class="programlisting">//SoundEffectWidget.h 
class SoundEffectWidget : public QWidget 
{ 
... 
protected: 
    void dropEvent(QDropEvent* event) override; 
... 
}; 
 
//SoundEffectWidget.cpp 
void SoundEffectWidget::dropEvent(QDropEvent* event) 
{ 
    const QMimeData* mimeData = event-&gt;mimeData(); 
    if (!mimeData-&gt;hasUrls()) { 
        return; 
    } 
    const QUrl url = mimeData-&gt;urls().first(); 
    QMimeType mime = QMimeDatabase().mimeTypeForUrl(url); 
    if (mime.inherits("audio/wav")) { 
        loadSound(url); 
    } 
} 
</pre><p>The first step is a sanity check. If the event does not have a URL, we do nothing. The <code class="literal">QMimeData::hasUrls()</code> function returns <code class="literal">true</code> only with the MIME type: <code class="literal">"text/uri-text"</code>. Notice that a user can drag and drop multiple files at once. In our case, we only handle the first URL. You can check that the file is a <code class="literal">.wav</code> file with its MIME type. If the MIME type is <code class="literal">"audio/wav"</code>, we call the <code class="literal">loadSound()</code> function, which updates the sound assigned to this <code class="literal">SoundEffectWidget</code>.</p><p>The following screenshot show the complete application for <code class="literal">ch11-drum-machine</code>:</p><div><img src="img/image00444.jpeg" alt="Accepting mouse drag and drop events"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec107"/>Summary</h1></div></div></div><p>Serialization is a good way to make your data persistent when you close your application. In this chapter, you learned to make your C++ objects serializable with <code class="literal">QVariant</code>. You created a flexible serialization structure with the Bridge pattern. You saved an object in a different text format such as JSON or XML and also in a binary format.</p><p>You also learned to use the Qt Multimedia module to play some sound effects. These sounds can be triggered by a mouse click or by a keyboard key. You implemented a friendly user interaction, allowing you to load a new sound with a file drag and drop.</p><p>In the next chapter, we will discover the <code class="literal">QTest</code> framework and how you can organize your project so it has a clean application/test separation.</p></div></body></html>