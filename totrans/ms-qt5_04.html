<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0; Conquering the Desktop UI"><div class="titlepage" id="aid-164MG2"><div><div><h1 class="title"><a id="ch04"/>Chapter 4.      Conquering the Desktop UI     </h1></div></div></div><p>In the previous chapter, we built the brain of our gallery using Qt models. It is now time to build a desktop application using this engine. This software will use all the features offered by the <code class="literal">gallery-core</code> library, leading to a completely usable gallery on your computer.</p><p>The first task will be to link your project-shared library to this new application. Then you will learn how to create custom widgets, when to use Qt views, and how to synchronize them with the model.</p><p>The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Linking the application to a project library</li><li class="listitem">Qt model/view</li><li class="listitem">Qt resource file</li><li class="listitem">Promoting custom widgets</li></ul></div><div class="section" title="Creating a GUI linked to a core shared library"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Creating a GUI linked to a core shared library</h1></div></div></div><p>The <code class="literal">gallery-core</code> shared library is now ready. Let's see how to create the desktop GUI project. We will create a Qt Widgets application sub-project called <code class="literal">gallery-desktop</code>. Only the first steps differ from a classic Qt Widgets application. Right-click on the main project, and select <span class="strong"><strong>ch04-gallery-desktop</strong></span> | <span class="strong"><strong>New subproject</strong></span> | <span class="strong"><strong>Application</strong></span> | <span class="strong"><strong>Qt Widgets Application</strong></span> | <span class="strong"><strong>Choose</strong></span>.</p><p>You will get a nice multi-projects hierarchy like this:</p><div class="mediaobject"><img src="../Images/image00369.jpeg" alt="Creating a GUI linked to a core shared library"/></div><p style="clear:both; height: 1em;"> </p><p>It is now time to link this <code class="literal">gallery-desktop</code> application to the <code class="literal">gallery-core</code>. You can edit the file <code class="literal">gallery-desktop.pro</code> yourself or use the Qt Creator wizard like this: right-click on the project and select <span class="strong"><strong>gallery-desktop</strong></span> | <span class="strong"><strong>Add library</strong></span> | <span class="strong"><strong>Internal library</strong></span> | <span class="strong"><strong>gallery-core</strong></span> | <span class="strong"><strong>Next</strong></span> | <span class="strong"><strong>Finish</strong></span>. Here is the updated <code class="literal">gallery-desktop.pro</code>:</p><pre class="programlisting">QT       += core gui 
 
TARGET = desktop-gallery 
TEMPLATE = app 
 
SOURCES += main.cpp\ 
        MainWindow.cpp 
 
HEADERS  += MainWindow.h 
 
FORMS    += MainWindow.ui 
 
win32:CONFIG(release, debug|release): LIBS += -L$$OUT_PWD/../gallery-core/release/ -lgallery-core 
else:win32:CONFIG(debug, debug|release): LIBS += -L$$OUT_PWD/../gallery-core/debug/ -lgallery-core 
else:unix: LIBS += -L$$OUT_PWD/../gallery-core/ -lgallery-core 
 
INCLUDEPATH += $$PWD/../gallery-core 
DEPENDPATH += $$PWD/../gallery-core 
</pre><p>The <code class="literal">LIBS</code> variable specifies the libraries to link in this project. The syntax is very simple: you can provide library paths with the <code class="literal">-L</code> prefix and library names with the <code class="literal">-l</code> prefix.</p><pre class="programlisting">LIBS += -L&lt;pathToLibrary&gt; -l&lt;libraryName&gt; 
</pre><p>By default, compiling a Qt project on Windows will create a <code class="literal">debug</code> and <code class="literal">release</code> sub-directory. That is why a different <code class="literal">LIBS</code> edition is created depending on the platform.</p><p>Now that the application is linked to the library <code class="literal">gallery-core</code> and knows where to find it, we must indicate where the library header files are located. That is why we must add the <code class="literal">gallery-core</code> source path to <code class="literal">INCLUDEPATH</code> and <code class="literal">DEPENDPATH</code>.</p><p>To complete all those tasks successfully, qmake offers some useful variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">$$OUT_PWD</code>: The absolute path to the output directory</li><li class="listitem"><code class="literal">$$PWD</code>: The absolute path of the current <code class="literal">.pro</code> file</li></ul></div><p>To ensure that <code class="literal">qmake</code> will compile the shared library before the desktop application, we must update the <code class="literal">ch04-gallery-desktop.pro</code> file according the following snippet:</p><pre class="programlisting">TEMPLATE = subdirs 
 
SUBDIRS += \ 
    gallery-core \ 
    gallery-desktop 
 
gallery-desktop.depends = gallery-core 
</pre><p>The <code class="literal">depends</code> attribute explicitly indicates that <code class="literal">gallery-core</code> must be built before <code class="literal">gallery-desktop</code>.</p><div class="note" title="Note"><h3 class="title"><a id="tip23"/>Tip</h3><p>Try to always use the <code class="literal">depends</code> attribute instead of relying on <code class="literal">CONFIG += ordered,</code> which only specifies a simple list order. The <code class="literal">depends</code> attribute helps qmake process your projects in parallel, if it can be done.</p></div><p>Instead of rushing into coding blindly, we will take some time to think about the UI architecture. We have a lot of features to implement from the <code class="literal">gallery-core</code> library. We should split these features into independent QWidgets. The final application will look like this:</p><div class="mediaobject"><img src="../Images/image00370.jpeg" alt="Creating a GUI linked to a core shared library"/><div class="caption"><p>Our future gallery desktop is here!</p></div></div><p style="clear:both; height: 1em;"> </p><p>The exapanded view of a photo will look like this:</p><div class="mediaobject"><img src="../Images/image00371.jpeg" alt="Creating a GUI linked to a core shared library"/><div class="caption"><p>Double-click on a thumbnail to display it in full size.</p></div></div><p style="clear:both; height: 1em;"> </p><p>To sum up the main UI components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">AlbumListWidget</code>: This component lists all existing albums</li><li class="listitem"><code class="literal">AlbumWidget</code>: This component shows the selected album and its thumbnails</li><li class="listitem"><code class="literal">PictureWidget</code>: This component displays the picture in full size</li></ul></div><p>This is how we will organize it:</p><div class="mediaobject"><img src="../Images/image00372.jpeg" alt="Creating a GUI linked to a core shared library"/></div><p style="clear:both; height: 1em;"> </p><p>Each widget has a defined role and will handle specific features:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Class name</strong></span></p>
</td><td>
<p><span class="strong"><strong>Features</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">MainWindow</code></p>
</td><td>
<p>Handles the switch between the gallery and the current picture</p>
</td></tr><tr><td>
<p><code class="literal">GalleryWidget</code></p>
</td><td>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Displays existing albums</li><li class="listitem">Album selection</li><li class="listitem">Album creation</li></ul></div>
</td></tr><tr><td>
<p><code class="literal">AlbumListWidget</code></p>
</td><td>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Displays existing albums</li><li class="listitem">Album selection</li><li class="listitem">Album creation</li></ul></div>
</td></tr><tr><td>
<p><code class="literal">AlbumWidget</code></p>
</td><td>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Displays existing pictures as thumbnails</li><li class="listitem">Adds pictures in the album</li><li class="listitem">Album rename</li><li class="listitem">Album deletion</li><li class="listitem">Picture selection</li></ul></div>
</td></tr><tr><td>
<p><code class="literal">PictureWidget</code></p>
</td><td>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Displays the selected picture</li><li class="listitem">Picture selection</li><li class="listitem">Picture deletion</li></ul></div>
</td></tr></tbody></table></div><p>In the core shared library, we used smart pointers with standard containers (<code class="literal">vector</code>). Generally, in GUI projects, we tend to only use Qt containers and their powerful parent-child ownership system. This approach seems more appropriate to us. That is why we will rely on Qt containers for the GUI (and won't use smart pointers) in this chapter.</p><p>We can now safely begin to create our widgets; all of them are created from <span class="strong"><strong>Qt Designer Form Class</strong></span>. If you have a memory lapse, you can check the <span class="emphasis"><em>Custom QWidget</em></span> section in <span><a class="link" title="Chapter 1.  Get Your Qt Feet Wet" href="part0014.xhtml#aid-DB7S1">Chapter 1</a></span>, <span class="emphasis"><em>Get Your Qt Feet Wet</em></span>.</p></div></div>
<div class="section" title="Listing your albums with AlbumListWidget"><div class="titlepage" id="aid-173722"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Listing your albums with AlbumListWidget</h1></div></div></div><p>This widget must offer a way to create a new album and display existing ones. Selecting an album must also trigger an event that will be used by other widgets to display the proper data. The <code class="literal">AlbumListWidget</code> component is the simplest widget in this project using the Qt View mechanism. Take the time to fully understand <code class="literal">AlbumListWidget</code> before jumping to the next widget.</p><p>The following screenshot shows the <span class="strong"><strong>Form Editor</strong></span> view of the file, <code class="literal">AlbumListWidget.ui</code>:</p><div class="mediaobject"><img src="../Images/image00373.jpeg" alt="Listing your albums with AlbumListWidget"/></div><p style="clear:both; height: 1em;"> </p><p>The layout is very simple. The components are described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">AlbumListWidget</code> component uses a vertical layout to display the <span class="strong"><strong>Create</strong></span> button above the list</li><li class="listitem">The <code class="literal">frame</code> component contains an attractive button</li><li class="listitem">The <code class="literal">createAlbumButton</code> component handles album creation</li><li class="listitem">The <code class="literal">albumList</code> component displays the album list</li></ul></div><p>You should have recognized most of the types used here. Let us take the time to talk about the really new one: <code class="literal">QListView</code>. As we already saw in the previous chapter, Qt provides a Model/View architecture. This system relies on specific interfaces that you must implement to provide generic data access via your model classes. That is what we did in the project <code class="literal">gallery-core</code> with the <code class="literal">AlbumModel</code> and <code class="literal">PictureModel</code> classes.</p><p>It is now time to deal with the view part. The view is in charge of the presentation of the data. It will also handle user interactions like selection, drag and drop, or item editing. Fortunately, to achieve these tasks, the view is helped by other Qt classes such as <code class="literal">QItemSelectionModel</code>, <code class="literal">QModelIndex,</code> or <code class="literal">QStyledItemDelegate</code>, which we will soon use in this chapter.</p><p>We can now enjoy one of the ready-to-use views offered by Qt:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">QListView</code>: This view displays items from a model as a simple list</li><li class="listitem"><code class="literal">QTableView</code>: This view displays items from a model as a two-dimensional table</li><li class="listitem"><code class="literal">QTreeView</code>: This view displays items from a hierarchy of lists</li></ul></div><p>Here, the choice is rather obvious because we want to display a list of album names. But in a more complex situation, a rule of thumb for choosing the proper view is to look for the model type; here we want to add a view for <code class="literal">AlbumModel</code> of type <code class="literal">QAbstractListModel</code> so the <code class="literal">QListView</code> class seems correct.</p><p>As you can see in the preceding screenshot, the  <code class="literal">createAlbumButton</code> object has an icon. You can add one to a <code class="literal">QPushButton</code> class by selecting the widget <span class="strong"><strong>property: icon</strong></span> | <span class="strong"><strong>Choose resource</strong></span>. You can now choose a picture from the <code class="literal">resource.qrc</code> file.</p><p>A <span class="strong"><strong>Qt resource</strong></span> file is a collection of files for embedding binary files in your application. You can store any types of file but we commonly use it to store pictures, sounds, or translation files. To create a resource file, right-click on the project name and then follow <span class="strong"><strong>Add New</strong></span> | <span class="strong"><strong>Qt</strong></span> | <span class="strong"><strong>Qt Resource File</strong></span>. Qt Creator will create a default file, <code class="literal">resource.qrc</code>, and add this line in your file <code class="literal">gallery-desktop.pro</code>:</p><pre class="programlisting">RESOURCES += resource.qrc 
</pre><p>The resource file can be mainly displayed in two ways: <span class="strong"><strong>Resource Editor</strong></span> and <span class="strong"><strong>Plain Text Editor</strong></span>. You can choose an editor with by right-clicking on the resource file and selecting <span class="strong"><strong>Open With</strong></span>.</p><p>The <span class="strong"><strong>Resource Editor</strong></span> is a visual editor that helps you to easily add and remove files in your resource file, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00374.jpeg" alt="Listing your albums with AlbumListWidget"/></div><p style="clear:both; height: 1em;"> </p><p>The <span class="strong"><strong>Plain Text Editor</strong></span> will display this XML-based file <code class="literal">resource.qrc</code> like this:</p><pre class="programlisting">&lt;RCC&gt; 
    &lt;qresource prefix="/"&gt; 
        &lt;file&gt;icons/album-add.png&lt;/file&gt; 
        &lt;file&gt;icons/album-delete.png&lt;/file&gt; 
        &lt;file&gt;icons/album-edit.png&lt;/file&gt; 
        &lt;file&gt;icons/back-to-gallery.png&lt;/file&gt; 
        &lt;file&gt;icons/photo-add.png&lt;/file&gt; 
        &lt;file&gt;icons/photo-delete.png&lt;/file&gt; 
        &lt;file&gt;icons/photo-next.png&lt;/file&gt; 
        &lt;file&gt;icons/photo-previous.png&lt;/file&gt; 
    &lt;/qresource&gt; 
&lt;/RCC&gt; 
</pre><p>At the build time, <code class="literal">qmake</code> and <code class="literal">rcc</code> (Qt Resource Compiler) embed your resources into the application binary.</p><p>Now that the form part is clear, we can analyze the <code class="literal">AlbumListWidget.h </code>file:</p><pre class="programlisting">#include &lt;QWidget&gt; 
#include &lt;QItemSelectionModel&gt; 
 
namespace Ui { 
class AlbumListWidget; 
} 
 
class AlbumModel; 
 
class AlbumListWidget : public QWidget 
{ 
    Q_OBJECT 
 
public: 
    explicit AlbumListWidget(QWidget *parent = 0); 
    ~AlbumListWidget(); 
 
    void setModel(AlbumModel* model); 
    void setSelectionModel(QItemSelectionModel* selectionModel); 
 
private slots: 
    void createAlbum(); 
 
private: 
    Ui::AlbumListWidget* ui; 
    AlbumModel* mAlbumModel; 
}; 
</pre><p>The <code class="literal">setModel()</code> and <code class="literal">setSelectionModel()</code>functions are the most important lines in this snippet. This widget require two things to work correctly:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">AlbumModel</code>: This is the model class that provides access to data. We already created this class in the <code class="literal">gallery-core </code>project.</li><li class="listitem"><code class="literal">QItemSelectionModel</code>: This is a Qt class that handles the selection in a view. By default, views use their own selection model. Sharing the same selection model with different views or widgets will help us to synchronize album selection easily.</li></ul></div><p>This is the main part of <code class="literal">AlbumListWidget.cpp</code>:</p><pre class="programlisting">#include "AlbumListWidget.h" 
#include "ui_AlbumListWidget.h" 
 
#include &lt;QInputDialog&gt; 
 
#include "AlbumModel.h" 
 
AlbumListWidget::AlbumListWidget(QWidget *parent) : 
    QWidget(parent), 
    ui(new Ui::AlbumListWidget), 
    mAlbumModel(nullptr) 
{ 
    ui-&gt;setupUi(this); 
 
    connect(ui-&gt;createAlbumButton, &amp;QPushButton::clicked, 
            this, &amp;AlbumListWidget::createAlbum); 
} 
 
AlbumListWidget::~AlbumListWidget() 
{ 
    delete ui; 
} 
 
void AlbumListWidget::setModel(AlbumModel* model) 
{ 
    mAlbumModel = model; 
    ui-&gt;albumList-&gt;setModel(mAlbumModel); 
} 
 
void AlbumListWidget::setSelectionModel(QItemSelectionModel* selectionModel) 
{ 
    ui-&gt;albumList-&gt;setSelectionModel(selectionModel); 
} 
</pre><p>The two setters will mainly be used to set the model and the selection model of the <code class="literal">albumList</code>. Our <code class="literal">QListView</code> class will then automatically request the model (<code class="literal">AlbumModel</code>) to get the row count and the <code class="literal">Qt::DisplayRole</code> (the album's name) for each one of them.</p><p>Let's now see the last part of the <code class="literal">AlbumListWidget.cpp</code> file that handles the album creation:</p><pre class="programlisting">void AlbumListWidget::createAlbum() 
{ 
    if(!mAlbumModel) { 
        return; 
    } 
 
    bool ok; 
    QString albumName = QInputDialog::getText(this, 
                            "Create a new Album", 
                            "Choose an name", 
                            QLineEdit::Normal, 
                            "New album", 
                            &amp;ok); 
 
    if (ok &amp;&amp; !albumName.isEmpty()) { 
        Album album(albumName); 
        QModelIndex createdIndex = mAlbumModel-&gt;addAlbum(album); 
        ui-&gt;albumList-&gt;setCurrentIndex(createdIndex); 
    } 
} 
</pre><p>We already worked with the <code class="literal">QInputDialog</code> class in <span><a class="link" title="Chapter 1.  Get Your Qt Feet Wet" href="part0014.xhtml#aid-DB7S1">Chapter 1</a></span>, <span class="emphasis"><em>Get Your Qt Feet Wet</em></span>. This time we are using it to ask the user to enter an album's name. Then we create an <code class="literal">Album</code> class with the requested name. This object is just a "data holder;" <code class="literal">addAlbum()</code> will use it to create and store the real object with a unique ID.</p><p>The function <code class="literal">addAlbum()</code> returns us the <code class="literal">QModelIndex</code> value corresponding to the created album. From here, we can request the list view to select this new album.</p></div>
<div class="section" title="Creating a ThumbnailProxyModel"><div class="titlepage" id="aid-181NK2"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Creating a ThumbnailProxyModel</h1></div></div></div><p>The future <code class="literal">AlbumWidget</code> view will display a grid of thumbnails with the pictures attached to the selected <code class="literal">Album</code>. In <a class="link" title="Chapter 3.  Dividing Your Project and Ruling Your Code" href="part0034.xhtml#aid-10DJ42"><span>Chapter 3</span></a>, <span class="emphasis"><em>Dividing Your Project and Ruling Your Code</em></span>, we designed the <code class="literal">gallery-core</code> library to be agnostic of how a picture should be displayed: a <code class="literal">Picture</code> class contains only a <code class="literal">mUrl</code> field.</p><p>In other words, the generation of the thumbnails has to be done in <code class="literal">gallery-desktop</code> rather than <code class="literal">gallery-core</code>. We already have the <code class="literal">PictureModel</code> class that is responsible for retrieving the <code class="literal">Picture</code> information, so it would be great to be able to extend its behavior with the thumbnail data.</p><p>This is possible in Qt with the use of the <code class="literal">QAbstractProxyModel</code> class and its subclasses. The goal of this class is to process data from a base <code class="literal">QAbstractItemModel</code> (sorting, filtering, adding data, and so on) and present it to the view by proxying the original model. To take a database analogy, you can view it as a projection over a table.</p><p>The <code class="literal">QAbstractProxyModel</code> class has two subclasses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">QIdentityProxyModel</code> subclass proxies its source model without any modification (all the indexes match). This class is suitable if you want to transform the <code class="literal">data()</code> function.</li><li class="listitem">The <code class="literal">QSortFilterProxyModel</code> subclass proxies its source model with the ability to sort and filter the passing data.</li></ul></div><p>The former, <code class="literal">QIdentityProxyModel,</code> fits our requirements. The only thing we need to do is to extend the <code class="literal">data()</code> function with the thumbnail generation content. Create a new class named <code class="literal">ThumbnailProxyModel</code>. Here is the <code class="literal">ThumbnailProxyModel.h</code> file:</p><pre class="programlisting">#include &lt;QIdentityProxyModel&gt; 
#include &lt;QHash&gt; 
#include &lt;QPixmap&gt; 
 
class PictureModel; 
 
class ThumbnailProxyModel : public QIdentityProxyModel 
{ 
public: 
    ThumbnailProxyModel(QObject* parent = 0); 
 
    QVariant data(const QModelIndex&amp; index, int role) const override; 
    void setSourceModel(QAbstractItemModel* sourceModel) override; 
    PictureModel* pictureModel() const; 
 
private: 
    void generateThumbnails(const QModelIndex&amp; startIndex, int count); 
    void reloadThumbnails(); 
 
private: 
   QHash&lt;QString, QPixmap*&gt; mThumbnails; 
 
}; 
</pre><p>This class extends <code class="literal">QIdentityProxyModel</code> and overrides a couple of functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">data()</code> function to provide the thumbnail data to the client of <code class="literal">ThumbnailProxyModel</code></li><li class="listitem">The <code class="literal">setSourceModel()</code> function to register to signals emitted by <code class="literal">sourceModel</code></li></ul></div><p>The remaining custom functions have the following goals:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">pictureModel()</code> is a helper function that casts the <code class="literal">sourceModel</code> to a <code class="literal">PictureModel*</code></li><li class="listitem">The <code class="literal">generateThumbnails()</code> function takes care of generating the <code class="literal">QPixmap</code> thumbnails for a given set of pictures</li><li class="listitem">The <code class="literal">reloadThumbnails()</code> is a helper function that clears the stored thumbnails before calling <code class="literal">generateThumbnails()</code></li></ul></div><p>As you might have guessed, the <code class="literal">mThumbnails</code> class stores the <code class="literal">QPixmap*</code> thumbnails using the <code class="literal">filepath</code> for the key.</p><p>We now switch to the <code class="literal">ThumbnailProxyModel.cpp</code> file and build it from the ground up. Let's focus on <code class="literal">generateThumbnails()</code>:</p><pre class="programlisting">const unsigned int THUMBNAIL_SIZE = 350; 
... 
void ThumbnailProxyModel::generateThumbnails( 
                                            const QModelIndex&amp; startIndex, int count) 
{ 
    if (!startIndex.isValid()) { 
        return; 
    } 
 
    const QAbstractItemModel* model = startIndex.model(); 
    int lastIndex = startIndex.row() + count; 
    for(int row = startIndex.row(); row &lt; lastIndex; row++) { 
        QString filepath = model-&gt;data(model-&gt;index(row, 0),  
                                                   PictureModel::Roles::FilePathRole).toString(); 
        QPixmap pixmap(filepath); 
        auto thumbnail = new QPixmap(pixmap 
                                     .scaled(THUMBNAIL_SIZE, THUMBNAIL_SIZE, 
                                             Qt::KeepAspectRatio, 
                                             Qt::SmoothTransformation)); 
        mThumbnails.insert(filepath, thumbnail); 
    } 
} 
</pre><p>This function generates the thumbnails for a given range indicated by the parameters (<code class="literal">startIndex</code> and <code class="literal">count</code>). For each picture, we retrieve the <code class="literal">filepath</code> from the original model, using <code class="literal">model-&gt;data()</code>, and we generate a downsized <code class="literal">QPixmap</code> that is inserted in the <code class="literal">mThumbnails</code> QHash. Note that we arbitrarily set the thumbnail size using <code class="literal">const THUMBNAIL_SIZE</code>. The picture is scaled down to this size and respects the aspect ratio of the original picture.</p><p>Each time that an album is loaded, we should clear the content of the <code class="literal">mThumbnails</code> class and load the new pictures. This work is done by the <code class="literal">reloadThumbnails()</code> function:</p><pre class="programlisting">void ThumbnailProxyModel::reloadThumbnails() 
{ 
    qDeleteAll(mThumbnails); 
    mThumbnails.clear(); 
    generateThumbnails(index(0, 0), rowCount()); 
} 
</pre><p>In this function, we simply clear the content of <code class="literal">mThumbnails</code> and call the <code class="literal">generateThumbnails()</code> function with parameters indicating that all the thumbnails should be generated. Let's see when these two functions will be used, in <code class="literal">setSourceModel()</code>:</p><pre class="programlisting">void ThumbnailProxyModel::setSourceModel(QAbstractItemModel* sourceModel) 
{ 
    QIdentityProxyModel::setSourceModel(sourceModel); 
    if (!sourceModel) { 
        return; 
    } 
 
    connect(sourceModel, &amp;QAbstractItemModel::modelReset,  
                  [this] { 
        reloadThumbnails(); 
    }); 
 
    connect(sourceModel, &amp;QAbstractItemModel::rowsInserted,  
                 [this] (const QModelIndex&amp; parent, int first, int last) { 
        generateThumbnails(index(first, 0), last - first + 1); 
    }); 
} 
</pre><p>When the <code class="literal">setSourceModel()</code> function is called, the <code class="literal">ThumbnailProxyModel</code> class is configured to know which base model should be proxied. In this function, we register lambdas to two signals emitted by the original model:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">modelReset</code> signal is triggered when pictures should be loaded for a given album. In this case, we have to completely reload the thumbnails.</li><li class="listitem">The <code class="literal">rowsInserted</code> signal is triggered each time new pictures are added. At this point, <code class="literal">generateThumbnails</code> should be called to update <code class="literal">mThumbnails</code> with these newcomers.</li></ul></div><p>Finally, we have to cover the <code class="literal">data()</code> function:</p><pre class="programlisting">QVariant ThumbnailProxyModel::data(const QModelIndex&amp; index, int role) const 
{ 
    if (role != Qt::DecorationRole) { 
        return QIdentityProxyModel::data(index, role); 
    } 
 
    QString filepath = sourceModel()-&gt;data(index,  
                                 PictureModel::Roles::FilePathRole).toString(); 
    return *mThumbnails[filepath]; 
} 
</pre><p>For any role that is not <code class="literal">Qt::DecorationRole</code>, the parent class <code class="literal">data()</code> is called. In our case, this triggers the <code class="literal">data()</code> function from the original model, <code class="literal">PictureModel</code>. After that, when <code class="literal">data()</code> must return a thumbnail, the <code class="literal">filepath</code> of the picture referenced by the <code class="literal">index</code> is retrieved and used to return the <code class="literal">QPixmap</code> object of <code class="literal">mThumbnails</code>. Luckily for us, <code class="literal">QPixmap</code> can be implicitly cast to <code class="literal">QVariant</code>, so we do not have anything special to do here.</p><p>The last function to cover in the <code class="literal">ThumbnailProxyModel</code> class is the <code class="literal">pictureModel()</code> function:</p><pre class="programlisting">PictureModel* ThumbnailProxyModel::pictureModel() const 
{ 
    return static_cast&lt;PictureModel*&gt;(sourceModel()); 
} 
</pre><p>Classes that will interact with <code class="literal">ThumbnailProxyModel</code> will need to call some functions that are specific to <code class="literal">PictureModel</code> to create or delete pictures. This function is a helper to centralize the cast of the <code class="literal">sourceModel</code> to <code class="literal">PictureModel*</code>.</p><p>As a side note, we could have tried to generate thumbnails on-the-fly to avoid a possible initial bottleneck during the album loading (and the call to <code class="literal">generateThumbnails()</code>). However, <code class="literal">data()</code> is a <code class="literal">const</code> function, meaning that it cannot modify the <code class="literal">ThumbnailProxyModel</code> instance. This rules out any way of generating a thumbnail in the <code class="literal">data()</code> function and storing it in <code class="literal">mThumbnails</code>.</p><p>As you can see, <code class="literal">QIdentityProxyModel</code>, and more generally <code class="literal">QAbstractProxyModel</code>, are valuable tools to add behavior to an existing model without breaking it. In our case, this is enforced by design in so far as the <code class="literal">PictureModel</code> class is defined in <code class="literal">gallery-core</code> rather than <code class="literal">gallery-desktop</code>. Modifying <code class="literal">PictureModel</code> implies modifying <code class="literal">gallery-core</code> and potentially breaking its behavior for other users of the library. This approach lets us keep things cleanly separated.</p></div>
<div class="section" title="Displaying the selected album with AlbumWidget"><div class="titlepage" id="aid-190862"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Displaying the selected album with AlbumWidget</h1></div></div></div><p>This widget will display the data of the selected album from <code class="literal">AlbumListWidget</code>. Some buttons will allow us to interact with this album.</p><p>Here is the layout of the <code class="literal">AlbumWidget.ui</code> file:</p><div class="mediaobject"><img src="../Images/image00375.jpeg" alt="Displaying the selected album with AlbumWidget"/></div><p style="clear:both; height: 1em;"> </p><p>The top frame, <code class="literal">albumInfoFrame</code>, with a horizontal layout, contains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">albumName</code>: This object displays the album's name (<span class="strong"><strong>Lorem ipsum</strong></span> in the designer)</li><li class="listitem"><code class="literal">addPicturesButton</code>: This object allows the user to add pictures selecting files</li><li class="listitem"><code class="literal">editButton</code>: This object is used to rename the album</li><li class="listitem"><code class="literal">deleteButton</code>: This object is used to delete the album</li></ul></div><p>The bottom element, <code class="literal">thumbnailListView,</code> is a <code class="literal">QListView</code>. This list view represents items from <code class="literal">PictureModel</code>. By default, <code class="literal">QListView</code> is able to display a picture next to text requesting <code class="literal">Qt::DisplayRole</code> and <code class="literal">Qt::DecorationRole</code> from the model.</p><p>Take a look at the header <code class="literal">AlbumWidget.h</code> file:</p><pre class="programlisting">#include &lt;QWidget&gt; 
#include &lt;QModelIndex&gt; 
 
namespace Ui { 
class AlbumWidget; 
} 
 
class AlbumModel; 
class PictureModel; 
class QItemSelectionModel; 
class ThumbnailProxyModel; 
 
class AlbumWidget : public QWidget 
{ 
    Q_OBJECT 
 
public: 
    explicit AlbumWidget(QWidget *parent = 0); 
    ~AlbumWidget(); 
 
    void setAlbumModel(AlbumModel* albumModel); 
    void setAlbumSelectionModel(QItemSelectionModel* albumSelectionModel); 
    void setPictureModel(ThumbnailProxyModel* pictureModel); 
    void setPictureSelectionModel(QItemSelectionModel* selectionModel); 
 
signals: 
    void pictureActivated(const QModelIndex&amp; index); 
 
private slots: 
    void deleteAlbum(); 
    void editAlbum(); 
    void addPictures(); 
 
private: 
    void clearUi(); 
    void loadAlbum(const QModelIndex&amp; albumIndex); 
 
private: 
    Ui::AlbumWidget* ui; 
    AlbumModel* mAlbumModel; 
    QItemSelectionModel* mAlbumSelectionModel; 
 
    ThumbnailProxyModel* mPictureModel; 
    QItemSelectionModel* mPictureSelectionModel; 
}; 
</pre><p>As this widget needs to deal with <code class="literal">Album</code> and <code class="literal">Picture</code> data, this class has <code class="literal">AlbumModel</code> and <code class="literal">ThumbnailProxyModel</code> setters. We also want to know and share the model selection with other widgets and views (that is, <code class="literal">AlbumListWidget</code>). That is why we also have <code class="literal">Album</code> and <code class="literal">Picture</code> model selection setters.</p><p>The signal <code class="literal">pictureActivated()</code> will be triggered when the user double-clicks on a thumbnail. We will see later how <code class="literal">MainWindow</code> will connect to this signal to display the picture at full size.</p><p>The private slots, <code class="literal">deleteAlbum()</code>, <code class="literal">editAlbum()</code>, and <code class="literal">addPictures()</code>, will be called when the user clicks on one of these buttons.</p><p>Finally, the <code class="literal">loadAlbum()</code> function will be called to update the UI for a specific album. The <code class="literal">clearUi()</code>function will be useful to clear all information displayed by this widget UI.</p><p>Take a look at the beginning of the implementation in the <code class="literal">AlbumWidget.cpp</code> file:</p><pre class="programlisting">#include "AlbumWidget.h" 
#include "ui_AlbumWidget.h" 
 
#include &lt;QInputDialog&gt; 
#include &lt;QFileDialog&gt; 
 
#include "AlbumModel.h" 
#include "PictureModel.h" 
 
AlbumWidget::AlbumWidget(QWidget *parent) : 
    QWidget(parent), 
    ui(new Ui::AlbumWidget), 
    mAlbumModel(nullptr), 
    mAlbumSelectionModel(nullptr), 
    mPictureModel(nullptr), 
    mPictureSelectionModel(nullptr) 
{ 
    ui-&gt;setupUi(this); 
    clearUi(); 
 
    ui-&gt;thumbnailListView-&gt;setSpacing(5); 
    ui-&gt;thumbnailListView-&gt;setResizeMode(QListView::Adjust); 
    ui-&gt;thumbnailListView-&gt;setFlow(QListView::LeftToRight); 
    ui-&gt;thumbnailListView-&gt;setWrapping(true); 
 
    connect(ui-&gt;thumbnailListView, &amp;QListView::doubleClicked, 
            this, &amp;AlbumWidget::pictureActivated); 
 
    connect(ui-&gt;deleteButton, &amp;QPushButton::clicked, 
            this, &amp;AlbumWidget::deleteAlbum); 
 
    connect(ui-&gt;editButton, &amp;QPushButton::clicked, 
            this, &amp;AlbumWidget::editAlbum); 
 
    connect(ui-&gt;addPicturesButton, &amp;QPushButton::clicked, 
            this, &amp;AlbumWidget::addPictures); 
} 
 
AlbumWidget::~AlbumWidget() 
{ 
    delete ui; 
} 
</pre><p>The constructor configures <code class="literal">thumbnailListView</code>, our <code class="literal">QListView</code> that will display thumbnails of the current selected album. We set here various parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">setSpacing()</code>: In this parameter, by default items are glued to each other. You can add spacing between them.</li><li class="listitem"><code class="literal">setResizeMode()</code>: This parameter dynamically lays out items when the view is resized. By default, items keep their original placement even if the view is resized.</li><li class="listitem"><code class="literal">setFlow()</code>: This parameter specifies the list direction. Here we want to display items from left to right. By default, the direction is <code class="literal">TopToBottom</code>.</li><li class="listitem"><code class="literal">setWrapping()</code>: This parameter allows an item to wrap when there is not enough space to display it in the visible area. By default, wrapping is not allowed and scrollbars will be displayed.</li></ul></div><p>The end of the constructor performs all the signal connections related to the UI. The first one is a good example of signal relaying, explained in <span><a class="link" title="Chapter 1.  Get Your Qt Feet Wet" href="part0014.xhtml#aid-DB7S1">Chapter 1</a></span>, <span class="emphasis"><em>Get Your Qt Feet Wet</em></span>. We connect the <code class="literal">QListView::doubleClicked</code> signal to our class signal, <code class="literal">AlbumWidget::pictureActivated</code>. Other connections are common; we want to call a specific slot when the user clicks on a button. As always in the <span class="strong"><strong>Qt Designer Form Class</strong></span>, the destructor will delete the member variable <code class="literal">ui</code>.</p><p>Let's see the <code class="literal">AlbumModel</code> setter implementation:</p><pre class="programlisting">void AlbumWidget::setAlbumModel(AlbumModel* albumModel) 
{ 
    mAlbumModel = albumModel; 
 
    connect(mAlbumModel, &amp;QAbstractItemModel::dataChanged, 
        [this] (const QModelIndex &amp;topLeft) { 
            if (topLeft == mAlbumSelectionModel-&gt;currentIndex()) { 
                loadAlbum(topLeft); 
            } 
    }); 
} 
 
void AlbumWidget::setAlbumSelectionModel(QItemSelectionModel* albumSelectionModel) 
{ 
    mAlbumSelectionModel = albumSelectionModel; 
 
    connect(mAlbumSelectionModel, 
            &amp;QItemSelectionModel::selectionChanged, 
            [this] (const QItemSelection &amp;selected) { 
                if (selected.isEmpty()) { 
                    clearUi(); 
                    return; 
                } 
                loadAlbum(selected.indexes().first()); 
    }); 
} 
</pre><p>If the selected album's data changed, we need to update the UI with the <code class="literal">loadAlbum()</code> function. A test is performed to ensure that the updated album is the currently selected one. Notice that the <code class="literal">QAbstractItemModel::dataChanged()</code> function has three parameters but the lambda slot syntax allows us to omit unused parameters.</p><p>Our <code class="literal">AlbumWidget</code> component must update its UI according to the currently selected album. As we share the same selection model, each time the user selects an album from <code class="literal">AlbumListWidget</code>, the signal <code class="literal">QItemSelectionModel::selectionChanged</code> is triggered. In this case, we update the UI by calling the <code class="literal">loadAlbum()</code> function. As we do not support album multi-selection, we can restrict the process to the first selected element. If the selection is empty, we simply clear the UI.</p><p>It is now the turn of the <code class="literal">PictureModel</code> setter implementation:</p><pre class="programlisting">void AlbumWidget::setPictureModel(PictureModel* pictureModel) 
{ 
    mPictureModel = pictureModel; 
    ui-&gt;thumbnailListView-&gt;setModel(mPictureModel); 
} 
 
void AlbumWidget::setPictureSelectionModel(QItemSelectionModel* selectionModel) 
{ 
    ui-&gt;thumbnailListView-&gt;setSelectionModel(selectionModel); 
} 
</pre><p>It is very simple here. We set the model and the selection model of <code class="literal">thumbnailListView</code>, our <code class="literal">QListView</code> that will display the selected album's thumbnails. We also keep the picture model to manipulate the data later on.</p><p>We can now cover the features one by one. Let's start with album deletion:</p><pre class="programlisting">void AlbumWidget::deleteAlbum() 
{ 
    if (mAlbumSelectionModel-&gt;selectedIndexes().isEmpty()) { 
        return; 
    } 
    int row = mAlbumSelectionModel-&gt;currentIndex().row(); 
    mAlbumModel-&gt;removeRow(row); 
 
    // Try to select the previous album 
    QModelIndex previousModelIndex = mAlbumModel-&gt;index(row - 1, 
        0); 
    if(previousModelIndex.isValid()) { 
        mAlbumSelectionModel-&gt;setCurrentIndex(previousModelIndex, 
             QItemSelectionModel::SelectCurrent); 
        return; 
    } 
 
    // Try to select the next album 
    QModelIndex nextModelIndex = mAlbumModel-&gt;index(row, 0); 
    if(nextModelIndex.isValid()) { 
        mAlbumSelectionModel-&gt;setCurrentIndex(nextModelIndex, 
            QItemSelectionModel::SelectCurrent); 
        return; 
    } 
} 
</pre><p>The most important task in the <code class="literal">deleteAlbum()</code> function is to retrieve the current row index from <code class="literal">mAlbumSelectionModel</code>. Then, we can request <code class="literal">mAlbumModel</code> to delete this row. The rest of the function will only try to automatically select the previous or the next album. Once again, as we shared the same selection model, <code class="literal">AlbumListWidget</code> will automatically update its album selection.</p><p>The following snippet shows the album rename feature:</p><pre class="programlisting">void AlbumWidget::editAlbum() 
{ 
    if (mAlbumSelectionModel-&gt;selectedIndexes().isEmpty()) { 
        return; 
    } 
 
    QModelIndex currentAlbumIndex =  
        mAlbumSelectionModel-&gt;selectedIndexes().first(); 
 
    QString oldAlbumName = mAlbumModel-&gt;data(currentAlbumIndex, 
        AlbumModel::Roles::NameRole).toString(); 
 
    bool ok; 
    QString newName = QInputDialog::getText(this, 
                                            "Album's name", 
                                            "Change Album name", 
                                            QLineEdit::Normal, 
                                            oldAlbumName, 
                                            &amp;ok); 
 
    if (ok &amp;&amp; !newName.isEmpty()) { 
        mAlbumModel-&gt;setData(currentAlbumIndex, 
                             newName, 
                             AlbumModel::Roles::NameRole); 
    } 
} 
</pre><p>Here, again the <code class="literal">QInputDialog</code> class will help us to implement a feature. You should be confident with its behavior now. This function performs three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Retrieve the current name from album model.</li><li class="listitem">Generate a great input dialog.</li><li class="listitem">Request the album model to update the name</li></ol><div style="height:10px; width: 1px"/></div><p>As you can see, the generic functions <code class="literal">data()</code> and <code class="literal">setData()</code> from the models are very powerful when combined with <code class="literal">ItemDataRole</code>. As already explained, we do not directly update our UI; this will be automatically performed because <code class="literal">setData()</code> emits a signal, <code class="literal">dataChanged()</code>, which <code class="literal">AlbumWidget</code> handles.</p><p>The last feature allows us to add some new picture files in the current album:</p><pre class="programlisting">void AlbumWidget::addPictures() 
{ 
    QStringList filenames = 
        QFileDialog::getOpenFileNames(this, 
            "Add pictures", 
             QDir::homePath(), 
            "Picture files (*.jpg *.png)"); 
 
    if (!filenames.isEmpty()) { 
        QModelIndex lastModelIndex; 
        for (auto filename : filenames) { 
            Picture picture(filename); 
            lastModelIndex = mPictureModelâpictureModel()-&gt;addPicture(picture); 
        } 
        ui-&gt;thumbnailListView-&gt;setCurrentIndex(lastModelIndex); 
    } 
} 
</pre><p>The <code class="literal">QFileDialog</code> class is used here to help the user select several picture files. For each filename, we create a <code class="literal">Picture</code> data holder, like we have already seen in this chapter for album creation. Then we can request <code class="literal">mPictureModel</code> to add this picture in the current album. Note that, because <code class="literal">mPictureModel</code> is a <code class="literal">ThumbnailProxyModel</code> class, we have to retrieve the real <code class="literal">PictureModel</code> using the helper function, <code class="literal">pictureModel()</code>. As the function <code class="literal">addPicture()</code> returns us the corresponding <code class="literal">QModelIndex</code>, we finally select the most recently added picture in <code class="literal">thumbnailListView</code>.</p><p>Let's complete <code class="literal">AlbumWidget.cpp</code>:</p><pre class="programlisting">void AlbumWidget::clearUi() 
{ 
    ui-&gt;albumName-&gt;setText(""); 
    ui-&gt;deleteButton-&gt;setVisible(false); 
    ui-&gt;editButton-&gt;setVisible(false); 
    ui-&gt;addPicturesButton-&gt;setVisible(false); 
} 
 
void AlbumWidget::loadAlbum(const QModelIndex&amp; albumIndex) 
{ 
    mPictureModel-&gt;pictureModel()-&gt;setAlbumId(mAlbumModel-&gt;data(albumIndex, 
        AlbumModel::Roles::IdRole).toInt()); 
 
    ui-&gt;albumName-&gt;setText(mAlbumModel-&gt;data(albumIndex, 
        Qt::DisplayRole).toString()); 
 
    ui-&gt;deleteButton-&gt;setVisible(true); 
    ui-&gt;editButton-&gt;setVisible(true); 
    ui-&gt;addPicturesButton-&gt;setVisible(true); 
} 
</pre><p>The <code class="literal">clearUi()</code>function clears the album's name and hides the buttons, while the <code class="literal">loadAlbum()</code> function retrieves the <code class="literal">Qt::DisplayRole</code> (the album's name) and displays the buttons.</p></div>
<div class="section" title="Enhancing thumbnails with PictureDelegate"><div class="titlepage" id="aid-19UOO2"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Enhancing thumbnails with PictureDelegate</h1></div></div></div><p>By default, a <code class="literal">QListView</code> class will request <code class="literal">Qt::DisplayRole</code> and <code class="literal">Qt::DecorationRole</code> to display text and a picture for each item. Thus, we already have a visual result, for free, that looks like this:</p><div class="mediaobject"><img src="../Images/image00376.jpeg" alt="Enhancing thumbnails with PictureDelegate"/></div><p style="clear:both; height: 1em;"> </p><p>However, our <span class="strong"><strong>Gallery</strong></span> application deserves better thumbnail rendering. Hopefully, we can easily customize it using the view's delegate concept. A <code class="literal">QListView</code> class provides a default item rendering. We can do our own item rendering by creating a class that inherits <code class="literal">QStyledItemDelegate</code>. The aim is to paint your dream thumbnails with a name banner like the following screenshot:</p><div class="mediaobject"><img src="../Images/image00377.jpeg" alt="Enhancing thumbnails with PictureDelegate"/></div><p style="clear:both; height: 1em;"> </p><p>Let's take a look at <code class="literal">PictureDelegate.h</code>:</p><pre class="programlisting">#include &lt;QStyledItemDelegate&gt; 
 
class PictureDelegate : public QStyledItemDelegate 
{ 
    Q_OBJECT 
public: 
    PictureDelegate(QObject* parent = 0); 
 
    void paint(QPainter* painter, const QStyleOptionViewItem&amp; 
        option, const QModelIndex&amp; index) const override; 
 
    QSize sizeHint(const QStyleOptionViewItem&amp; option, 
        const QModelIndex&amp; index) const override; 
}; 
</pre><p>That is right, we only have to override two functions. The most important function, <code class="literal">paint()</code>, will allow us to paint the item like we want. The <code class="literal">sizeHint()</code> function will be used to specify the item size.</p><p>We can now see the painter work in <code class="literal">PictureDelegate.cpp</code>:</p><pre class="programlisting">#include "PictureDelegate.h" 
 
#include &lt;QPainter&gt; 
 
const unsigned int BANNER_HEIGHT = 20; 
const unsigned int BANNER_COLOR = 0x303030; 
const unsigned int BANNER_ALPHA = 200; 
const unsigned int BANNER_TEXT_COLOR = 0xffffff; 
const unsigned int HIGHLIGHT_ALPHA = 100; 
 
PictureDelegate::PictureDelegate(QObject* parent) : 
    QStyledItemDelegate(parent) 
{ 
} 
 
void PictureDelegate::paint(QPainter* painter, const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const 
{ 
    painter-&gt;save(); 
 
    QPixmap pixmap = index.model()-&gt;data(index, 
        Qt::DecorationRole).value&lt;QPixmap&gt;(); 
    painter-&gt;drawPixmap(option.rect.x(), option.rect.y(), pixmap); 
 
    QRect bannerRect = QRect(option.rect.x(), option.rect.y(), 
        pixmap.width(), BANNER_HEIGHT); 
    QColor bannerColor = QColor(BANNER_COLOR); 
    bannerColor.setAlpha(BANNER_ALPHA); 
    painter-&gt;fillRect(bannerRect, bannerColor); 
 
    QString filename = index.model()-&gt;data(index, 
        Qt::DisplayRole).toString(); 
    painter-&gt;setPen(BANNER_TEXT_COLOR); 
    painter-&gt;drawText(bannerRect, Qt::AlignCenter, filename); 
 
    if (option.state.testFlag(QStyle::State_Selected)) { 
        QColor selectedColor = option.palette.highlight().color(); 
        selectedColor.setAlpha(HIGHLIGHT_ALPHA); 
        painter-&gt;fillRect(option.rect, selectedColor); 
    } 
 
    painter-&gt;restore(); 
} 
</pre><p>Each time <code class="literal">QListView</code> needs to display an item, this delegate's <code class="literal">paint()</code> function will be called. The paint system can be seen as layers that you paint one on top of each other. The <code class="literal">QPainter</code> class allows us to paint anything we want: circles, pies, rectangles, text, and so on. The item area can be retrieved with <code class="literal">option.rect()</code>. Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It is easy to break the <code class="literal">painter</code> state passed in the parameter list, thus we must save the painter state with <code class="literal">painter-&gt;save()</code> before doing anything, to be able to restore it when we have finished our drawing.</li><li class="listitem">Retrieve the item thumbnail and draw it with the <code class="literal">QPainter::drawPixmap()</code> function.</li><li class="listitem">Paint a translucent gray banner on top of the thumbnail with the <code class="literal">QPainter::fillRect()</code> function.</li><li class="listitem">Retrieve the item display name and draw it on the banner using the <code class="literal">QPainter::drawText()</code> function.</li><li class="listitem">If the item is selected, we paint a translucent rectangle on the top using the highlight color from the item.</li><li class="listitem">We restore the painter state to its original state.</li></ol><div style="height:10px; width: 1px"/></div><div class="note" title="Note"><h3 class="title"><a id="tip24"/>Tip</h3><p>If you want to draw a more complex item, check the <code class="literal">QPainter</code> official documentation at <span><a class="ulink" href="http://doc.qt.io/qt-5/qpainter.html">doc.qt.io/qt-5/qpainter.html</a></span>.</p></div><p>This is the <code class="literal">sizeHint()</code> function's implementation:</p><pre class="programlisting">QSize PictureDelegate::sizeHint(const QStyleOptionViewItem&amp; /*option*/, const QModelIndex&amp; index) const 
{ 
    const QPixmap&amp; pixmap = index.model()-&gt;data(index, 
        Qt::DecorationRole).value&lt;QPixmap&gt;(); 
    return pixmap.size(); 
} 
</pre><p>This one is easier. We want the item's size to be equal to the thumbnail size. As we kept the aspect ratio of the thumbnail during its creation in <code class="literal">Picture::setFilePath()</code>, thumbnails can have a different width and height. Hence, we basically retrieve the thumbnail and return its size.</p><div class="note" title="Note"><h3 class="title"><a id="tip25"/>Tip</h3><p>When you create an item delegate, avoid directly inheriting the <code class="literal">QItemDelegate</code> class and instead inherit <code class="literal">QStyledItemDelegate</code>. This last one supports Qt style sheets, allowing you to easily customize the rendering.</p></div><p>Now that <code class="literal">PictureDelegate</code> is ready, we can configure our <code class="literal">thumbnailListView</code> to use it, updating the <code class="literal">AlbumWidget.cpp</code> file like this:</p><pre class="programlisting">AlbumWidget::AlbumWidget(QWidget *parent) : 
    QWidget(parent), 
    ui(new Ui::AlbumWidget), 
    mAlbumModel(nullptr), 
    mAlbumSelectionModel(nullptr), 
    mPictureModel(nullptr), 
    mPictureSelectionModel(nullptr) 
{ 
    ui-&gt;setupUi(this); 
    clearUi(); 
 
    ui-&gt;thumbnailListView-&gt;setSpacing(5); 
    ui-&gt;thumbnailListView-&gt;setResizeMode(QListView::Adjust); 
    ui-&gt;thumbnailListView-&gt;setFlow(QListView::LeftToRight); 
    ui-&gt;thumbnailListView-&gt;setWrapping(true); 
    ui-&gt;thumbnailListView-&gt;setItemDelegate( 
        new PictureDelegate(this)); 
    ... 
} 
</pre><div class="note" title="Note"><h3 class="title"><a id="tip26"/>Tip</h3><p><span class="strong"><strong>Qt tip</strong></span></p><p>An item delegate can also manage the editing process with the <code class="literal">QStyledItemDelegate::createEditor()</code> function.</p></div></div>
<div class="section" title="Displaying a picture with PictureWidget" id="aid-1AT9A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Displaying a picture with PictureWidget</h1></div></div></div><p>This widget will be called to display a picture at its full size. We also add some buttons to go to the previous/next picture or delete the current one.</p><p>Let's start to analyze the <code class="literal">PictureWidget.ui</code> form, here is the design view:</p><div class="mediaobject"><img src="../Images/image00378.jpeg" alt="Displaying a picture with PictureWidget"/></div><p style="clear:both; height: 1em;"> </p><p>Here are the details:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">backButton</code>: This object requests to display the gallery</li><li class="listitem"><code class="literal">deleteButton</code>: This object removes the picture from the album</li><li class="listitem"><code class="literal">nameLabel</code>: This object displays the picture name</li><li class="listitem"><code class="literal">nextButton</code>: This object selects the next picture in the album</li><li class="listitem"><code class="literal">previousButton</code>: This object selects the previous picture in the album</li><li class="listitem"><code class="literal">pictureLabel</code>: This object displays the picture</li></ul></div><p>We can now take a look at the header <code class="literal">PictureWidget.h</code>:</p><pre class="programlisting">#include &lt;QWidget&gt; 
#include &lt;QItemSelection&gt; 
 
namespace Ui { 
class PictureWidget; 
} 
 
class PictureModel; 
class QItemSelectionModel; 
class ThumbnailProxyModel; 
 
class PictureWidget : public QWidget 
{ 
    Q_OBJECT 
 
public: 
    explicit PictureWidget(QWidget *parent = 0); 
    ~PictureWidget(); 
    void setModel(ThumbnailProxyModel* model); 
    void setSelectionModel(QItemSelectionModel* selectionModel); 
 
signals: 
    void backToGallery(); 
 
protected: 
    void resizeEvent(QResizeEvent* event) override; 
 
private slots: 
    void deletePicture(); 
    void loadPicture(const QItemSelection&amp; selected); 
 
private: 
    void updatePicturePixmap(); 
 
private: 
    Ui::PictureWidget* ui; 
    ThumbnailProxyModel* mModel; 
    QItemSelectionModel* mSelectionModel; 
    QPixmap mPixmap; 
}; 
</pre><p>No surprises here, we have the <code class="literal">ThumbnailProxyModel*</code> and <code class="literal">QItemSelectionModel*</code> setters in the <code class="literal">PictureWidget</code> class. The signal <code class="literal">backToGallery()</code> is triggered when the user clicks on the <code class="literal">backButton</code> object. It will be handled by <code class="literal">MainWindow</code> to display again the gallery. We override <code class="literal">resizeEvent()</code> to ensure that we always use all the visible area to display the picture. The <code class="literal">deletePicture()</code>slot will process the deletion when the user clicks on the corresponding button. The <code class="literal">loadPicture()</code>function will be called to update the UI with the specified picture. Finally, <code class="literal">updatePicturePixmap()</code> is a helper function to display the picture according to the current widget size.</p><p>This widget is really similar to the others. As a result, we will not put the full implementation code of <code class="literal">PictureWidget.cpp</code> here. You can check the full source code example if needed.</p><p>Let's see how this widget is able to always display the picture at its full size in <code class="literal">PictureWidget.cpp</code>:</p><pre class="programlisting">void PictureWidget::resizeEvent(QResizeEvent* event) 
{ 
    QWidget::resizeEvent(event); 
    updatePicturePixmap(); 
} 
 
void PictureWidget::updatePicturePixmap() 
{ 
    if (mPixmap.isNull()) { 
        return; 
    } 
    ui-&gt;pictureLabel-&gt;setPixmap(mPixmap.scaled(ui-&gt;pictureLabel-&gt;size(), Qt::KeepAspectRatio)); 
} 
</pre><p>So, every time the widget is resized, we call <code class="literal">updatePicturePixmap()</code>. The <code class="literal">mPixmap</code> variable is the full-size picture from <code class="literal">PictureModel</code>. This function will scale the picture to the <code class="literal">pictureLabel</code> size, keeping the aspect ratio. You can freely resize the window and enjoy your picture with the biggest possible size.</p></div>
<div class="section" title="Composing your Gallery app"><div class="titlepage" id="aid-1BRPS2"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Composing your Gallery app</h1></div></div></div><p>Alright, we completed <code class="literal">AlbumListWidget</code>, <code class="literal">AlbumWidget,</code> and <code class="literal">PictureWidget</code>. If you remember correctly, <code class="literal">AlbumListWidget</code> and <code class="literal">AlbumWidget</code> are contained in a widget called <code class="literal">GalleryWidget</code>.</p><p>Let's take a look at the <code class="literal">GalleryWidget.ui</code> file:</p><div class="mediaobject"><img src="../Images/image00379.jpeg" alt="Composing your Gallery app"/></div><p style="clear:both; height: 1em;"> </p><p>This widget does not contain any standard Qt widgets but only our created widgets. Qt provides two ways to use your own widgets in the Qt designer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Promoting widgets</strong></span>: This is the fastest and easiest way</li><li class="listitem"><span class="strong"><strong>Creating widget plugin for Qt designer</strong></span>: This is more powerful but more complex</li></ul></div><p>In this chapter, we will use the first way, which consists of placing a generic <code class="literal">QWidget</code> as a placeholder and then promoting it to our custom widget class. You can follow these steps to add the <code class="literal">albumListWidget</code> and the <code class="literal">albumWidget</code> objects to the <code class="literal">GalleryWidget.ui</code> file from the Qt designer:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Drag and drop a <span class="strong"><strong>Widget</strong></span> from <span class="strong"><strong>Containers</strong></span> to your form.</li><li class="listitem">Set the <span class="strong"><strong>objectName</strong></span> (for example, <code class="literal">albumListWidget</code>) from the <span class="strong"><strong>Property Editor</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>Promote to...</strong></span> from the widget contextual menu.</li><li class="listitem">Set the promoted class name (for example, <code class="literal">AlbumWidget</code>).</li><li class="listitem">Check that header file is correct (for example, <code class="literal">AlbumWidget.h</code>).</li><li class="listitem">Click on the <span class="strong"><strong>Add</strong></span> button and then click on <span class="strong"><strong>Promote</strong></span>.</li></ol><div style="height:10px; width: 1px"/></div><p>If you fail your widget promotion, you can always reverse it with <span class="strong"><strong>Demote to QWidget</strong></span> from the contextual menu.</p><p>There is nothing really exciting in the header and implementation of <code class="literal">GalleryWidget</code>. We only provide setters for the model and model selection of <code class="literal">Album</code> and <code class="literal">Picture</code> to forward them to <code class="literal">albumListWidget</code> and <code class="literal">albumWidget</code>. This class also relays the signal <code class="literal">pictureActivated</code> from <code class="literal">albumWidget</code>. Please check the full source code if needed.</p><p>This is the final part of this chapter. We will now analyze <code class="literal">MainWindow</code>. Nothing is done in <code class="literal">MainWindow.ui</code> because everything is handled in the code. This is <code class="literal">MainWindow.h</code>:</p><pre class="programlisting">#include &lt;QMainWindow&gt; 
#include &lt;QStackedWidget&gt; 
 
namespace Ui { 
class MainWindow; 
} 
 
class GalleryWidget; 
class PictureWidget; 
 
class MainWindow : public QMainWindow 
{ 
    Q_OBJECT 
 
public: 
    explicit MainWindow(QWidget *parent = 0); 
    ~MainWindow(); 
 
public slots: 
    void displayGallery(); 
    void displayPicture(const QModelIndex&amp; index); 
 
private: 
    Ui::MainWindow *ui; 
    GalleryWidget* mGalleryWidget; 
    PictureWidget* mPictureWidget; 
    QStackedWidget* mStackedWidget; 
}; 
</pre><p>The two slots, <code class="literal">displayGallery()</code> and <code class="literal">displayPicture(),</code> will be used to switch the display between the gallery (album list with the album and thumbnail) and the picture ( full-size). The <code class="literal">QStackedWidget</code> class can contain various widgets but display only one at a time.</p><p>Let's take a look to the beginning of the constructor in the <code class="literal">MainWindow.cpp </code>file:</p><pre class="programlisting">ui-&gt;setupUi(this); 
 
AlbumModel* albumModel = new AlbumModel(this); 
QItemSelectionModel* albumSelectionModel = 
    new QItemSelectionModel(albumModel, this); 
mGalleryWidget-&gt;setAlbumModel(albumModel); 
mGalleryWidget-&gt;setAlbumSelectionModel(albumSelectionModel); 
</pre><p>First, we initialize the UI by calling <code class="literal">ui-&gt;setupUi()</code>. Then we create <code class="literal">AlbumModel</code> and its <code class="literal">QItemSelectionModel</code>. Finally, we call the setters of <code class="literal">GalleryWidget</code> that will dispatch them to the <code class="literal">AlbumListWidget</code> and <code class="literal">AlbumWidget</code> objects.</p><p>Continuing our analysis of this constructor:</p><pre class="programlisting">PictureModel* pictureModel = new PictureModel(*albumModel, this); 
ThumbnailProxyModel* thumbnailModel = new ThumbnailProxyModel(this); thumbnailModel-&gt;setSourceModel(pictureModel); 
 
QItemSelectionModel* pictureSelectionModel = 
    new QItemSelectionModel(pictureModel, this); 
 
mGalleryWidget-&gt;setPictureModel(thumbnailModel); 
mGalleryWidget-&gt;setPictureSelectionModel(pictureSelectionModel); 
mPictureWidget-&gt;setModel(thumbnailModel); 
mPictureWidget-&gt;setSelectionModel(pictureSelectionModel); 
</pre><p>The behavior with <code class="literal">Picture</code> is close to the previous one with <code class="literal">Album</code>. But we also share <code class="literal">ThumbnailProxyModel</code>, which is initialized from <code class="literal">PictureModel</code>, and its <code class="literal">QItemSelectionModel</code> with <code class="literal">PictureWidget</code>.</p><p>The constructor now performs the signal/slot connections:</p><pre class="programlisting">connect(mGalleryWidget, &amp;GalleryWidget::pictureActivated, 
        this, &amp;MainWindow::displayPicture); 
 
connect(mPictureWidget, &amp;PictureWidget::backToGallery, 
        this, &amp;MainWindow::displayGallery); 
</pre><p>Do you remember the <code class="literal">pictureActivated()</code> function? This signal is emitted when you double-click on a thumbnail in <code class="literal">albumWidget</code>. We can now connect it to our <code class="literal">displayPicture</code> slot, which will switch the display with the picture at its full size. Do not forget to also connect the <code class="literal">backToGallery</code> signal emitted when the user clicks on the <code class="literal">backButton</code> from <code class="literal">PictureWidget</code>. It will switch again to display the gallery.</p><p>The last part of the constructor is easy:</p><pre class="programlisting">mStackedWidget-&gt;addWidget(mGalleryWidget); 
mStackedWidget-&gt;addWidget(mPictureWidget); 
displayGallery(); 
 
setCentralWidget(mStackedWidget); 
</pre><p>We add our two widgets, <code class="literal">mGalleryWidget</code> and <code class="literal">mPictureWidget,</code> to the <code class="literal">mStackedWidget</code> class. When the application starts, we want to display the gallery, so we call our own slot <code class="literal">displayGallery()</code>. Finally, we define <code class="literal">mStackedWidget</code> as the main window's central widget.</p><p>To finish this chapter, let's see what happens in these two magic slots that allows to switch the display when the user requests it:</p><pre class="programlisting">void MainWindow::displayGallery() 
{ 
    mStackedWidget-&gt;setCurrentWidget(mGalleryWidget); 
} 
 
void MainWindow::displayPicture(const QModelIndex&amp; /*index*/) 
{ 
    mStackedWidget-&gt;setCurrentWidget(mPictureWidget); 
} 
</pre><p>That seems ridiculously easy. We just request <code class="literal">mStackedWidget</code> to select the corresponding widget. As <code class="literal">PictureWidget</code> shares the same selection model with other views, we can even ignore the <code class="literal">index</code> variable.</p></div>
<div class="section" title="Summary" id="aid-1CQAE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>The real separation between data and representation is not always an easy task. Dividing the core and the GUI in two different projects is a good practice. It will force you to design separated layers in your application. At first sight, the Qt model/view system can appear complex. But this chapter taught you how powerful it can be and how easy it is to use. Thanks to the Qt framework, the persistence of data in a database can be done without headaches.</p><p>This chapter built on top of the foundations laid with the <code class="literal">gallery-core</code> library. In the next chapter, we will reuse the same core library and create a mobile UI with Qt Quick in QML.</p></div></body></html>