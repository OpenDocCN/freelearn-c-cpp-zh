<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.2.1">Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Software testing stands as a cornerstone in the edifice of software development, holding paramount importance in the assurance of software quality, reliability, and maintainability. </span><span class="koboSpan" id="kobo.3.2">It is through the meticulous process of testing that developers can ensure their creations meet the highest standards of functionality and user satisfaction. </span><span class="koboSpan" id="kobo.3.3">The inception of any software project is invariably intertwined with the potential for bugs and unforeseen issues; it is testing that illuminates these hidden pitfalls, allowing developers to address them proactively, thereby enhancing the overall integrity and performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">At the heart of software testing lies a diverse array of methodologies, each tailored to examine distinct facets of the software. </span><span class="koboSpan" id="kobo.5.2">Among these, unit testing serves as the foundational layer, focusing on the smallest testable parts of the software to ensure their correct behavior. </span><span class="koboSpan" id="kobo.5.3">This granular approach facilitates the early detection of errors, streamlining the development process by enabling immediate corrections. </span><span class="koboSpan" id="kobo.5.4">Ascending from the micro to the macro perspective, integration testing takes precedence, wherein the interaction between integrated units is scrutinized. </span><span class="koboSpan" id="kobo.5.5">This method is pivotal in identifying issues in the interfacing of components, ensuring seamless communication and functionality within </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Progressing further, system testing emerges as a comprehensive examination of the complete and integrated software system. </span><span class="koboSpan" id="kobo.7.2">This methodology delves into the software’s adherence to specified requirements, offering an overarching assessment of its behavior and performance. </span><span class="koboSpan" id="kobo.7.3">It is a crucial phase that validates the software’s readiness for deployment, ensuring that it functions correctly in its intended environment. </span><span class="koboSpan" id="kobo.7.4">Lastly, acceptance testing marks the culmination of the testing process, where the software is evaluated to determine whether it fulfills the criteria for delivery to end users. </span><span class="koboSpan" id="kobo.7.5">This final stage is instrumental in affirming the software’s alignment with user needs and expectations, serving as the ultimate testament to its quality </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and effectiveness.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Embarking on this chapter, you will be guided through the intricate landscape of software testing, gaining insights into the pivotal role it plays in the development life cycle. </span><span class="koboSpan" id="kobo.9.2">The exploration will encompass the nuanced distinctions between testing methodologies, shedding light on their unique objectives and the scope of their application. </span><span class="koboSpan" id="kobo.9.3">Through this journey, you will acquire a comprehensive understanding of how testing underpins the creation of robust, reliable, and user-centric software, setting the stage for the subsequent chapters that delve deeper into the specifics of unit testing and beyond in the realm </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of C++.</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.11.1">Test-driven development</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.12.1">Test-driven development</span></strong><span class="koboSpan" id="kobo.13.1">, commonly abbreviated as </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">TDD</span></strong><span class="koboSpan" id="kobo.15.1">, is a modern software development approach that </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.16.1">has revolutionized the way code is written and tested. </span><span class="koboSpan" id="kobo.16.2">At its core, TDD inverts traditional development methodologies by advocating for the creation of tests before the development of the actual functional code. </span><span class="koboSpan" id="kobo.16.3">This paradigm shift is encapsulated in a cyclic process known as “Red-Green-Refactor.” </span><span class="koboSpan" id="kobo.16.4">Initially, a developer writes a test that defines a desired improvement or a new function, which inevitably fails on the first run – this is the “Red” phase, indicating the absence of the corresponding functionality. </span><span class="koboSpan" id="kobo.16.5">Subsequently, in the “Green” phase, the developer crafts the minimum amount of code necessary to pass the test, thereby ensuring that the functionality meets the specified requirements. </span><span class="koboSpan" id="kobo.16.6">The cycle culminates in the “Refactor” phase, where the new code is refined and optimized without altering its behavior, thus maintaining the test’s </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">successful outcome.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">The adoption of TDD brings with it a plethora of advantages that contribute to a more robust and reliable code base. </span><span class="koboSpan" id="kobo.18.2">One of the most significant benefits is the marked improvement in code quality. </span><span class="koboSpan" id="kobo.18.3">Since TDD necessitates the definition of tests upfront, it inherently encourages a more thoughtful and deliberate design process, reducing the likelihood of bugs and errors. </span><span class="koboSpan" id="kobo.18.4">Moreover, tests crafted in the TDD process serve a dual purpose as detailed documentation of the code base. </span><span class="koboSpan" id="kobo.18.5">These tests provide clear insights into the code’s intended functionality and usage, offering valuable guidance for current and future developers. </span><span class="koboSpan" id="kobo.18.6">Additionally, TDD facilitates the design and refactoring of code by ensuring that changes do not inadvertently break existing functionalities, thereby fostering a code base that is both flexible </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">and maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Despite its numerous benefits, TDD is not without its challenges and potential drawbacks. </span><span class="koboSpan" id="kobo.20.2">One of the initial hurdles encountered when adopting TDD is the perceived slowdown in the development process. </span><span class="koboSpan" id="kobo.20.3">Writing tests before functionality can feel counterintuitive and may extend the time to deliver features, particularly in the early stages of adoption. </span><span class="koboSpan" id="kobo.20.4">Furthermore, TDD demands a steep learning curve, requiring developers to acquire new skills and adapt to a different mindset, which can be a significant investment in time and resources. </span><span class="koboSpan" id="kobo.20.5">It’s also worth noting that TDD may not be universally applicable or ideal for all scenarios. </span><span class="koboSpan" id="kobo.20.6">Certain types of projects, such as those involving complex user interfaces or requiring extensive interaction with external systems, may pose challenges to the TDD methodology, necessitating a more nuanced or hybrid approach </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">to testing.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In conclusion, while TDD presents a transformative approach to software development with its emphasis on test-first methodology, it is essential to weigh its benefits against the potential challenges. </span><span class="koboSpan" id="kobo.22.2">The effectiveness of TDD is contingent upon the context of its application, the proficiency of the development team, and the nature of the project at hand. </span><span class="koboSpan" id="kobo.22.3">As we delve deeper into the subsequent sections, the nuances of unit testing, integration with testing frameworks, and practical considerations will further illuminate the role of TDD in shaping high-quality, maintainable C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">code bases.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.24.1">Unit testing in C++</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Unit tests are </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.26.1">a foundational aspect of TDD in software engineering, playing a pivotal role in the C++ development process. </span><span class="koboSpan" id="kobo.26.2">They focus on validating the smallest sections of code, known as units, which are typically individual functions, methods, or classes. </span><span class="koboSpan" id="kobo.26.3">By testing these components in isolation, unit tests ensure that each part of the software behaves as intended, which is crucial for the system’s </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">overall functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">In the TDD framework, unit tests take on an even more significant role. </span><span class="koboSpan" id="kobo.28.2">They are often written before the actual code, guiding the development process and ensuring that the software is designed with testability and correctness in mind from the outset. </span><span class="koboSpan" id="kobo.28.3">This approach to writing unit tests before the implementation helps in identifying bugs early in the development cycle, allowing for timely corrections that prevent the bugs from becoming more complex or affecting other parts of the system. </span><span class="koboSpan" id="kobo.28.4">This proactive bug detection not only saves time and resources but also contributes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">software’s stability.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Moreover, unit tests act as a safety net for developers, enabling them to refactor code confidently without fear of breaking existing functionality. </span><span class="koboSpan" id="kobo.30.2">This is particularly valuable in TDD, where refactoring is a key step in the cycle of writing a test, making it pass, and then improving the code. </span><span class="koboSpan" id="kobo.30.3">Beyond their role in bug detection and facilitating refactoring, unit tests also serve as effective documentation, providing clear insights into the expected behavior of the system. </span><span class="koboSpan" id="kobo.30.4">This makes them an invaluable resource for developers, especially those new to the code base. </span><span class="koboSpan" id="kobo.30.5">Additionally, the process of writing unit tests in the TDD approach often highlights design improvements, leading to more robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">maintainable code.</span></span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.32.1">C++ unit testing frameworks</span></h1>
<p><span class="koboSpan" id="kobo.33.1">The C++ ecosystem is rich with unit testing frameworks designed to facilitate the creation, execution, and maintenance of tests. </span><span class="koboSpan" id="kobo.33.2">Among these, Google Test and Google Mock stand out for their comprehensive feature set, ease of use, and integration capabilities with C++ projects. </span><span class="koboSpan" id="kobo.33.3">In this section, we’ll delve into Google Test and Google Mock, highlighting their key features and syntax, and demonstrate how they can be integrated into a </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">CMake project.</span></span></p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.35.1">Google Test and Google Mock</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.36.1">Google Test</span></strong><span class="koboSpan" id="kobo.37.1">, also </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.38.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">GTest</span></strong><span class="koboSpan" id="kobo.40.1">, is Google’s framework for </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.41.1">writing unit tests in C++. </span><span class="koboSpan" id="kobo.41.2">It is widely recognized for its extensive testing capabilities and offers several notable features that facilitate comprehensive and efficient unit testing in C++. </span><span class="koboSpan" id="kobo.41.3">Among its key offerings are rich assertions, which enable developers to use a variety of assertions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">EXPECT_EQ</span></strong><span class="koboSpan" id="kobo.43.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">ASSERT_NE</span></strong><span class="koboSpan" id="kobo.45.1"> to compare expected outcomes with actual results, ensuring precise validation of test conditions. </span><span class="koboSpan" id="kobo.45.2">Furthermore, Google Test simplifies </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.46.1">the management of common test configurations through test fixtures, which define setup and teardown operations, providing a consistent environment for </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">each test.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Another significant feature is the support for parameterized tests, allowing developers to write a single test and run it with multiple inputs. </span><span class="koboSpan" id="kobo.48.2">This approach greatly enhances test coverage without the need for duplicative code. </span><span class="koboSpan" id="kobo.48.3">Complementing this, Google Test also supports type-parameterized tests, which permit the execution of the same test logic across different data types, broadening the scope of test coverage </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">even further.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">One of the most user-friendly features of Google Test is its automatic test discovery mechanism. </span><span class="koboSpan" id="kobo.50.2">This feature eliminates the need for manual test registration, as Google Test automatically identifies and executes tests within the project, streamlining the testing process and saving valuable </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">development time.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.52.1">Google Mock</span></strong><span class="koboSpan" id="kobo.53.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">gMock</span></strong><span class="koboSpan" id="kobo.55.1">, complements Google Test by providing a robust mocking framework, which</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.56.1"> integrates seamlessly to simulate complex object </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.57.1">behaviors. </span><span class="koboSpan" id="kobo.57.2">This capability is invaluable in creating conditions that mimic real-world scenarios, allowing for more thorough testing of code interactions. </span><span class="koboSpan" id="kobo.57.3">With Google Mock, developers gain the flexibility to set expectations on mocked objects, tailoring them to specific needs such as the number of times a function is called, the arguments it receives, and the sequence of calls. </span><span class="koboSpan" id="kobo.57.4">This level of control ensures that tests can verify not just the outcomes but also the interactions between different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Furthermore, Google Mock is specifically designed to work in harmony with Google Test, facilitating the creation of comprehensive tests that can leverage both actual objects and their mocked counterparts. </span><span class="koboSpan" id="kobo.59.2">This integration simplifies the process of writing tests that are both extensive and reflective of real application behavior, thereby enhancing the reliability and maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">the codebase.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.61.1">Integrating Google Test into a C++ project</span></h1>
<p><span class="koboSpan" id="kobo.62.1">We’re going</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.63.1"> to demonstrate how to incorporate Google Test into a CMake project, providing a step-by-step guide to configuring CMake to work with Google Test for unit testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">C++ projects.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">To start, ensure that Google Test is included in your project. </span><span class="koboSpan" id="kobo.65.2">This can be done by adding Google Test as a submodule in your project’s repository or downloading it via CMake. </span><span class="koboSpan" id="kobo.65.3">Once Google Test is part of your project, the next step is to configure your </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">CMakeLists.txt</span></strong><span class="koboSpan" id="kobo.67.1"> file to include Google Test in the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">build process.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Here’s an example of how you might configure your </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">CMakeLists.txt</span></strong><span class="koboSpan" id="kobo.71.1"> file to integrate Google Test via </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">a submodule:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
git submodule add https://github.com/google/googletest.git external/googletest</span></pre>
<p><span class="koboSpan" id="kobo.74.1">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">CMakeLists.txt</span></strong><span class="koboSpan" id="kobo.76.1"> to include</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.77.1"> Google Test and Google Mock in </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">the build:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
# Minimum version of CMake
cmake_minimum_required(VERSION 3.14)
project(MyProject)
# GoogleTest requires at least C++14
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
# Enable testing capabilities
enable_testing()
# Add GoogleTest to the project
add_subdirectory(external/googletest)
# Include GoogleTest and GoogleMock headers
include_directories(${gtest_SOURCE_DIR}/include ${gmock_SOURCE_DIR}/include)
# Define your test executable
add_executable(my_tests test1.cpp test2.cpp)
# Link GoogleTest and GoogleMock to your test executable
target_link_libraries(my_tests gtest gtest_main gmock gmock_main)</span></pre>
<p><span class="koboSpan" id="kobo.80.1">In this</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.81.1"> configuration, </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">add_subdirectory(external/googletest)</span></strong><span class="koboSpan" id="kobo.83.1"> tells CMake to include Google Test in the build. </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">include_directories</span></strong><span class="koboSpan" id="kobo.85.1"> ensures that the Google Test headers are accessible to your test files. </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">add_executable</span></strong><span class="koboSpan" id="kobo.87.1"> defines a new executable for your tests, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">target_link_libraries</span></strong><span class="koboSpan" id="kobo.89.1"> links the Google Test libraries to your </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">test executable.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">After configuring </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">CMakeLists.txt</span></strong><span class="koboSpan" id="kobo.93.1">, you can build and run your tests using CMake and make commands. </span><span class="koboSpan" id="kobo.93.2">This setup not only integrates Google Test into your project but also leverages CMake’s testing capabilities to automate running </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">The following code snippet demonstrates another way to configure CMake to use Google Test, which is by downloading Google Test via CMake’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">FetchContent</span></strong><span class="koboSpan" id="kobo.97.1"> module. </span><span class="koboSpan" id="kobo.97.2">This approach allows CMake to download Google Test during the build process, ensuring that the project’s dependencies are </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">automatically managed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
cmake_minimum_required(VERSION 3.14)
project(MyProject)
# GoogleTest requires at least C++14
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip
)
# For Windows: Prevent overriding the parent project’s compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL “” FORCE)
FetchContent_MakeAvailable(googletest)</span></pre>
<p><span class="koboSpan" id="kobo.100.1">While this example focuses</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.101.1"> on integrating Google Test with CMake, it’s worth noting that Google Test is versatile and can be integrated into other build systems as well, such as Google’s own Bazel. </span><span class="koboSpan" id="kobo.101.2">For projects using different build systems or for more complex configurations, refer to the official Google Test documentation for comprehensive guidance and best practices. </span><span class="koboSpan" id="kobo.101.3">This documentation provides valuable insights into leveraging Google Test across various environments and build systems, ensuring that you can effectively implement unit testing in your C++ projects regardless of the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">development setup.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.103.1">Usage of Google Test in C++ projects</span></h1>
<p><span class="koboSpan" id="kobo.104.1">Google Test</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.105.1"> provides a comprehensive suite of functionalities to support various testing needs in C++ development. </span><span class="koboSpan" id="kobo.105.2">Understanding how to effectively leverage these features can significantly enhance your testing practices. </span><span class="koboSpan" id="kobo.105.3">Let’s explore the usage of Google Test through simple examples </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">and explanations.</span></span></p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.107.1">Writing a simple test</span></h1>
<p><span class="koboSpan" id="kobo.108.1">A </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.109.1">simple test in Google Test can be written using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">TEST</span></strong><span class="koboSpan" id="kobo.111.1"> macro, which defines a test function. </span><span class="koboSpan" id="kobo.111.2">Within this function, you can use various assertions to verify the behavior of your code. </span><span class="koboSpan" id="kobo.111.3">Here’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">basic example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
#include &lt;gtest/gtest.h&gt;
int add(int a, int b) {
    return a + b;
}
TEST(AdditionTest, HandlesPositiveNumbers) {
    EXPECT_EQ(5, add(2, 3));
}</span></pre>
<p><span class="koboSpan" id="kobo.114.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">EXPECT_EQ</span></strong><span class="koboSpan" id="kobo.116.1"> is used to assert that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">add</span></strong><span class="koboSpan" id="kobo.118.1"> function returns the expected sum of two positive numbers. </span><span class="koboSpan" id="kobo.118.2">Google Test provides a variety of assertions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">EXPECT_GT</span></strong><span class="koboSpan" id="kobo.120.1"> (greater than), </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">EXPECT_TRUE</span></strong><span class="koboSpan" id="kobo.122.1"> (Boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">true</span></strong><span class="koboSpan" id="kobo.124.1">), and many others for different </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">testing scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">The key</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.127.1"> difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">EXPECT_*</span></strong><span class="koboSpan" id="kobo.129.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">ASSERT_*</span></strong><span class="koboSpan" id="kobo.131.1"> assertions lies in their behavior upon failure. </span><span class="koboSpan" id="kobo.131.2">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">EXPECT_*</span></strong><span class="koboSpan" id="kobo.133.1"> assertions allow the test to continue running after a failure, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">ASSERT_*</span></strong><span class="koboSpan" id="kobo.135.1"> assertions will halt the current test function immediately upon failure. </span><span class="koboSpan" id="kobo.135.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">EXPECT_*</span></strong><span class="koboSpan" id="kobo.137.1"> when subsequent lines of the test do not depend on the success of the current assertion, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">ASSERT_*</span></strong><span class="koboSpan" id="kobo.139.1"> when the failure of an assertion would make the continuation of the test meaningless or potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">cause errors.</span></span></p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.141.1">Using a test fixture</span></h1>
<p><span class="koboSpan" id="kobo.142.1">For tests </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.143.1">that require a common setup and teardown for multiple test cases, Google Test offers the concept of a test fixture. </span><span class="koboSpan" id="kobo.143.2">This is achieved by defining a class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">::testing::Test</span></strong><span class="koboSpan" id="kobo.145.1"> and then using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">TEST_F</span></strong><span class="koboSpan" id="kobo.147.1"> macro to write tests that use </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">this fixture:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
class CalculatorTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Code here will be called immediately before each test
        calculator.reset(new Calculator());
    }
    void TearDown() override {
        // Code here will be called immediately after each test
        calculator.reset();
    }
    std::unique_ptr&lt;Calculator&gt; calculator;
};
TEST_F(CalculatorTest, CanAddPositiveNumbers) {
    EXPECT_EQ(5, calculator-&gt;add(2, 3));
}
TEST_F(CalculatorTest, CanAddNegativeNumbers) {
    EXPECT_EQ(-5, calculator-&gt;add(-2, -3));
}</span></pre>
<p><span class="koboSpan" id="kobo.150.1">In this </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.151.1">example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">SetUp</span></strong><span class="koboSpan" id="kobo.153.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">TearDown</span></strong><span class="koboSpan" id="kobo.155.1"> are overridden to provide a common setup (initializing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Calculator</span></strong><span class="koboSpan" id="kobo.157.1"> object) and teardown (cleaning up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Calculator</span></strong><span class="koboSpan" id="kobo.159.1"> object) for each test case. </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">TEST_F</span></strong><span class="koboSpan" id="kobo.161.1"> is used to define test functions that automatically use this setup and teardown, ensuring that each test starts with a fresh </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Calculator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> instance.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.164.1">The main function</span></h1>
<p><span class="koboSpan" id="kobo.165.1">To run the </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.166.1">tests, Google Test requires a main function that initializes the Google Test framework and runs all the tests. </span><span class="koboSpan" id="kobo.166.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
#include &lt;gtest/gtest.h&gt;
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
<p><span class="koboSpan" id="kobo.169.1">This main function initializes Google Test, passing the command-line arguments to it, which allows for controlling test execution from the command line. </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">RUN_ALL_TESTS()</span></strong><span class="koboSpan" id="kobo.171.1"> runs all the tests that have been defined and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">0</span></strong><span class="koboSpan" id="kobo.173.1"> if all tests pass or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1"> otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">By following these examples and explanations, you can start using Google Test to write comprehensive tests for your C++ projects, ensuring that your code behaves as expected across a wide range </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">of scenarios.</span></span></p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.178.1">Running Google Test tests</span></h1>
<p><span class="koboSpan" id="kobo.179.1">After setting up </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.180.1">Google Test with your CMake project and compiling your tests, running them is straightforward. </span><span class="koboSpan" id="kobo.180.2">You execute the tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">ctest</span></strong><span class="koboSpan" id="kobo.182.1"> command in your build directory, which CMake uses to run tests defined in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">CMakeLists.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">When you run the tests for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Calculator</span></strong><span class="koboSpan" id="kobo.187.1"> class, the standard output to your terminal might look like this if you execute the test </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">binary directly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
$ cd path/to/build
[==========] Running 4 tests from 2 test suites.
</span><span class="koboSpan" id="kobo.189.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.189.3">[----------] 2 tests from AdditionTests
[ RUN      ] AdditionTests.HandlesZeroInput
[       OK ] AdditionTests.HandlesZeroInput (0 ms)
[ RUN      ] AdditionTests.HandlesPositiveInput
[       OK ] AdditionTests.HandlesPositiveInput (0 ms)
[----------] 2 tests from AdditionTests (0 ms total)
[----------] 2 tests from SubtractionTests
[ RUN      ] SubtractionTests.HandlesZeroInput
[       OK ] SubtractionTests.HandlesZeroInput (0 ms)
[ RUN      ] SubtractionTests.HandlesPositiveInput
[       OK ] SubtractionTests.HandlesPositiveInput (0 ms)
[----------] 2 tests from SubtractionTests (0 ms total)
[----------] Global test environment tear-down
[==========] 4 tests from 2 test suites ran. </span><span class="koboSpan" id="kobo.189.4">(1 ms total)
[  PASSED  ] 4 tests.</span></pre>
<p><span class="koboSpan" id="kobo.190.1">This output </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.191.1">details each test suite and test case, showing which tests were run (</span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">[ RUN      ]</span></strong><span class="koboSpan" id="kobo.193.1">) and their results (</span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">[       OK ]</span></strong><span class="koboSpan" id="kobo.195.1"> for passed tests). </span><span class="koboSpan" id="kobo.195.2">It provides a clear breakdown of the testing process, including setup and teardown phases, and aggregates the results at </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the end.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">If you run the tests using </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">ctest</span></strong><span class="koboSpan" id="kobo.199.1">, the output is more concise </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">by default:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.201.1">
$ ctest
Test project /path/to/build
    Start 1: AdditionTests.HandlesZeroInput
1/4 Test #1: AdditionTests.HandlesZeroInput ......   Passed    0.01 sec
    Start 2: AdditionTests.HandlesPositiveInput
2/4 Test #2: AdditionTests.HandlesPositiveInput ...   Passed    0.01 sec
    Start 3: SubtractionTests.HandlesZeroInput
3/4 Test #3: SubtractionTests.HandlesZeroInput .....   Passed    0.01 sec
    Start 4: SubtractionTests.HandlesPositiveInput
4/4 Test #4: SubtractionTests.HandlesPositiveInput ..   Passed    0.01 sec
100% tests passed, 0 tests failed out of 4</span></pre>
<p><span class="koboSpan" id="kobo.202.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">ctest</span></strong><span class="koboSpan" id="kobo.204.1"> output, each line corresponds to a test case, showing its start order, name, and result. </span><span class="koboSpan" id="kobo.204.2">The summary at the end gives a quick overview of the total number of tests, how many passed, and how many failed. </span><span class="koboSpan" id="kobo.204.3">This format is useful for getting a quick assessment of your test suite’s health without the detailed breakdown provided by the Google </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">Test output.</span></span></p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.206.1">Advanced features of Google Test</span></h1>
<p><span class="koboSpan" id="kobo.207.1">Google Test </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.208.1">offers a range of advanced features designed to handle complex testing scenarios, providing developers with powerful tools to ensure their code’s robustness. </span><span class="koboSpan" id="kobo.208.2">Among these features, one notable capability is the support for </span><em class="italic"><span class="koboSpan" id="kobo.209.1">death tests</span></em><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">Death tests are particularly useful for verifying that your code exhibits the expected behavior when it encounters fatal conditions, such as failed assertions or explicit calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">abort()</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">This is crucial in scenarios where you want to ensure that your application responds appropriately to unrecoverable errors, enhancing its reliability </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">and safety.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Here’s a brief example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">death test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
void risky_function(bool trigger) {
    if (trigger) {
        assert(false &amp;&amp; “Triggered a fatal error”);
    }
}
TEST(RiskyFunctionTest, TriggersAssertOnCondition) {
    EXPECT_DEATH_IF_SUPPORTED(risky_function(true), “Triggered a fatal error”);
}</span></pre>
<p><span class="koboSpan" id="kobo.217.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">EXPECT_DEATH_IF_SUPPORTED</span></strong><span class="koboSpan" id="kobo.219.1"> checks that </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">risky_function(true)</span></strong><span class="koboSpan" id="kobo.221.1"> indeed causes the program to exit (due to the failed assertion), and it matches the specified error message. </span><span class="koboSpan" id="kobo.221.2">This ensures that the function behaves as expected under </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">fatal conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Other advanced features of Google Test include </span><em class="italic"><span class="koboSpan" id="kobo.224.1">mocking</span></em><span class="koboSpan" id="kobo.225.1"> for simulating complex object interactions, </span><em class="italic"><span class="koboSpan" id="kobo.226.1">parameterized tests</span></em><span class="koboSpan" id="kobo.227.1"> for running the same test logic with various inputs, and </span><em class="italic"><span class="koboSpan" id="kobo.228.1">type-parameterized tests</span></em><span class="koboSpan" id="kobo.229.1"> for applying the same test logic across different data types. </span><span class="koboSpan" id="kobo.229.2">These features enable comprehensive testing strategies that can cover a wide range of scenarios and inputs, ensuring thorough validation of </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">For developers seeking to leverage the full potential of Google Test, including its advanced features such as death tests and more, the official Google Test documentation serves as an invaluable resource. </span><span class="koboSpan" id="kobo.231.2">It offers detailed explanations, examples, and best practices, guiding you through the nuances of effective test writing and execution in C++ projects. </span><span class="koboSpan" id="kobo.231.3">By referring to this documentation, you can </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.232.1">deepen your understanding of Google Test’s capabilities and integrate them effectively into your </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">testing workflow.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.234.1">Using gMock in C++ projects</span></h1>
<p><span class="koboSpan" id="kobo.235.1">In the</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.236.1"> world of software testing, particularly within the methodology of TDD, a mock object plays a crucial role. </span><span class="koboSpan" id="kobo.236.2">It’s designed to mimic the behavior of real objects by implementing the same interface, allowing it to stand in for the actual object in tests. </span><span class="koboSpan" id="kobo.236.3">However, the power of a mock object lies in its flexibility; developers can specify its behavior at runtime, including which methods are called, their call order, frequency, argument specifications, and the return values. </span><span class="koboSpan" id="kobo.236.4">This level of control turns mock objects into powerful tools for testing interactions and integrations within </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Mocks address several challenges in testing complex or interconnected systems. </span><span class="koboSpan" id="kobo.238.2">When developing prototypes or tests, relying solely on real objects might not be feasible or practical due to constraints such as external dependencies, execution time, or costs associated with real operations. </span><span class="koboSpan" id="kobo.238.3">In such cases, mocks provide a lightweight, controllable substitute that replicates the necessary interactions without the overhead or side effects of the real implementations. </span><span class="koboSpan" id="kobo.238.4">They enable developers to focus on the behavior and integration of components rather than their underlying implementations, facilitating more focused and </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">efficient testing.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">The distinction between fake objects and mock objects is crucial to understanding their appropriate use cases. </span><span class="koboSpan" id="kobo.240.2">While both serve as substitutes for real objects in testing, they have different characteristics </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">and purposes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.242.1">Fake objects</span></strong><span class="koboSpan" id="kobo.243.1">: These </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.244.1">are simplified implementations that mimic real objects but typically take shortcuts for the sake of testing efficiency. </span><span class="koboSpan" id="kobo.244.2">An example would be an in-memory database that replicates the functionality of a real database system without persistent storage. </span><span class="koboSpan" id="kobo.244.3">Fakes are practical for tests where the exact workings of the real object are not </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">under scrutiny.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.246.1">Mock objects</span></strong><span class="koboSpan" id="kobo.247.1">: Unlike </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.248.1">fakes, mocks are pre-programmed with specific expectations that form a contract of how they should be used. </span><span class="koboSpan" id="kobo.248.2">They are ideal for testing the interactions between the system under test and its dependencies. </span><span class="koboSpan" id="kobo.248.3">For instance, when testing a class that relies on a service, a mock of the service can be used to ensure that the class interacts with the service as expected without actually invoking the service’s </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">real implementation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.250.1">gMock, Google’s framework for creating mock classes in C++, provides a comprehensive solution akin to what jMock and EasyMock offer for Java. </span><span class="koboSpan" id="kobo.250.2">With gMock, developers first describe the interface of the object to be mocked using macros, which then generate the mock class implementation. </span><span class="koboSpan" id="kobo.250.3">Developers </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.251.1">can then instantiate mock objects, setting up their expected behaviors and interactions using gMock’s intuitive syntax. </span><span class="koboSpan" id="kobo.251.2">During test execution, gMock monitors these mock objects, ensuring that all specified interactions adhere to the defined expectations, and flagging any deviations as errors. </span><span class="koboSpan" id="kobo.251.3">This immediate feedback is invaluable for identifying issues in how components interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">their dependencies.</span></span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.253.1">Example of using gMock</span></h1>
<p><span class="koboSpan" id="kobo.254.1">In</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.255.1"> unit testing, particularly when interfacing with network operations, mocking is an invaluable technique. </span><span class="koboSpan" id="kobo.255.2">This is exemplified in the case of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Socket</span></strong><span class="koboSpan" id="kobo.257.1"> class, which serves as a foundational element for network communication. </span><span class="koboSpan" id="kobo.257.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Socket</span></strong><span class="koboSpan" id="kobo.259.1"> class abstracts the functionality of sending and receiving raw byte arrays over a network, providing methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">send</span></strong><span class="koboSpan" id="kobo.261.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">recv</span></strong><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">Concrete classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">TcpSocket</span></strong><span class="koboSpan" id="kobo.265.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">UdpSocket</span></strong><span class="koboSpan" id="kobo.267.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">WebSocket</span></strong><span class="koboSpan" id="kobo.269.1"> extend this base class to implement specific network protocols. </span><span class="koboSpan" id="kobo.269.2">The following code shows the definition of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Socket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
class Socket {
public:
    // sends raw byte array of given size, returns number of bytes sent
    // or -1 in case of error
    virtual ssize_t send(void* data, size_t size) = 0;
    // receives raw byte array of given size, returns number of bytes received
    // or -1 in case of error
    virtual ssize_t recv(void* data, size_t size) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.273.1">For instance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">DataSender</span></strong><span class="koboSpan" id="kobo.275.1"> class relies on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Socket</span></strong><span class="koboSpan" id="kobo.277.1"> instance to send data. </span><span class="koboSpan" id="kobo.277.2">This class is meticulously designed to manage data transmission, attempting retries as necessary and handling various scenarios such as partial data sends, peer-initiated connection closures, and connection errors. </span><span class="koboSpan" id="kobo.277.3">The objective in unit testing </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">DataSender</span></strong><span class="koboSpan" id="kobo.279.1"> is to validate its behavior across these different scenarios without engaging in actual network communication. </span><span class="koboSpan" id="kobo.279.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">DataSender</span></strong><span class="koboSpan" id="kobo.281.1"> class</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.282.1"> is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
struct DataSentParitally {};
struct ConnectionClosedByPeer {};
struct ConnectionError {};
// Class under test
class DataSender {
    static constexpr size_t RETRY_NUM = 2;
public:
    DataSender(Socket* socket) : _socket{socket} {}
    void send() {
        auto data = std::array&lt;int, 32&gt;{};
        auto bytesSent = 0;
        for (size_t i = 0; i &lt; RETRY_NUM &amp;&amp; bytesSent != sizeof(data); ++i) {
            bytesSent = _socket-&gt;send(&amp;data, sizeof(data));
            if (bytesSent &lt; 0) {
                throw ConnectionError{};
            }
            if (bytesSent == 0) {
                throw ConnectionClosedByPeer{};
            }
        }
        if (bytesSent != sizeof(data)) {
            throw DataSentParitally{};
        }
    }
private:
    Socket* _socket;
};</span></pre>
<p><span class="koboSpan" id="kobo.285.1">This </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.286.1">requirement leads us to the use of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">MockSocket</span></strong><span class="koboSpan" id="kobo.288.1"> class, derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Socket</span></strong><span class="koboSpan" id="kobo.290.1">, to simulate network interactions. </span><span class="koboSpan" id="kobo.290.2">Here’s how </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">MockSocket</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.292.1">is defined:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
class MockSocket : public Socket {
public:
    MOCK_METHOD(ssize_t, send, (void* data, size_t size), (override));
    MOCK_METHOD(ssize_t, recv, (void* data, size_t size), (override));
};</span></pre>
<p><span class="koboSpan" id="kobo.294.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">MockSocket</span></strong><span class="koboSpan" id="kobo.296.1"> class utilizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">MOCK_METHOD</span></strong><span class="koboSpan" id="kobo.298.1"> macro from gMock to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">send</span></strong><span class="koboSpan" id="kobo.300.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">recv</span></strong><span class="koboSpan" id="kobo.302.1"> methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Socket</span></strong><span class="koboSpan" id="kobo.304.1"> class, allowing for the specification of expected behavior during tests. </span><span class="koboSpan" id="kobo.304.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">override</span></strong><span class="koboSpan" id="kobo.306.1"> keyword ensures that these mock methods correctly override their counterparts in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Socket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">Setting expectations in gMock is done using constructs such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">WillOnce</span></strong><span class="koboSpan" id="kobo.311.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">WillRepeatedly</span></strong><span class="koboSpan" id="kobo.313.1">, which define how mock methods behave </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">when invoked:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.315.1">
TEST(DataSender, HappyPath) {
    auto socket = MockSocket{};
    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));
    auto sender = DataSender(&amp;socket);
    sender.send();
}</span></pre>
<p><span class="koboSpan" id="kobo.316.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">HappyPath</span></strong><span class="koboSpan" id="kobo.318.1"> test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">EXPECT_CALL</span></strong><span class="koboSpan" id="kobo.320.1"> sets an expectation that </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">send</span></strong><span class="koboSpan" id="kobo.322.1"> will be called exactly </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.323.1">once, successfully transmitting all the data in a </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">single attempt.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
TEST(DataSender, SendSuccessfullyOnSecondAttempt) {
    auto socket = MockSocket{};
    EXPECT_CALL(socket, send(_, _)).Times(2)
                                   .WillOnce(Return(2 * sizeof(int)))
                                   .WillOnce(Return(32 * sizeof(int)));
    auto sender = DataSender(&amp;socket);
    sender.send();
}</span></pre>
<p><span class="koboSpan" id="kobo.326.1">This test expects two calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">send</span></strong><span class="koboSpan" id="kobo.328.1">: the first transmits only a portion of the data, while the second completes the transmission, simulating a successful </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">send</span></strong><span class="koboSpan" id="kobo.330.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">second attempt.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">The rest of the tests check various error scenarios, such as partial data transmission, connection closure by the peer, and connection errors. </span><span class="koboSpan" id="kobo.332.2">Here’s an example of a test for the scenario where data is </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">sent partially:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
 TEST(DataSender, DataSentParitally) {
     auto socket = MockSocket{};
     EXPECT_CALL(socket, send(_, _)).Times(2)
                                    .WillRepeatedly(Return(2 * sizeof(int)));
     auto sender = DataSender(&amp;socket);
     EXPECT_THROW(sender.send(), DataSentParitally);
 }
 TEST(DataSender, ConnectionClosedByPeer) {
     auto socket = MockSocket{};
     EXPECT_CALL(socket, send(_, _)).Times(1)
                                    .WillRepeatedly(Return(0 * sizeof(int)));
     auto sender = DataSender(&amp;socket);
     EXPECT_THROW(sender.send(), ConnectionClosedByPeer);
 }
 TEST(DataSender, ConnectionError) {
     auto socket = MockSocket{};
     EXPECT_CALL(socket, send(_, _)).Times(1)
                                    .WillRepeatedly(Return(-1 * sizeof(int)));
     auto sender = DataSender(&amp;socket);
     EXPECT_THROW(sender.send(), ConnectionError);
 }</span></pre>
<p><span class="koboSpan" id="kobo.335.1">Running these</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.336.1"> tests with gMock and observing the output allows us to confirm the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">DataSender</span></strong><span class="koboSpan" id="kobo.338.1"> class’s behavior under </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">various conditions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
[==========] Running 5 tests from 1 test suite.
</span><span class="koboSpan" id="kobo.340.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.340.3">[----------] 5 tests from DataSender
[ RUN      ] DataSender.HappyPath
[       OK ] DataSender.HappyPath (0 ms)
[ RUN      ] DataSender.SendSuccessfullyOnSecondAttempt
[       OK ] DataSender.SendSuccessfullyOnSecondAttempt (0 ms)
[ RUN      ] DataSender.DataSentPartially
[       OK ] DataSender.DataSentPartially (1 ms)
[ RUN      ] DataSender.ConnectionClosedByPeer
[       OK ] DataSender.ConnectionClosedByPeer (0 ms)
[ RUN      ] DataSender.ConnectionError
[       OK ] DataSender.ConnectionError (0 ms)
[----------] 5 tests from DataSender (1 ms total)
[----------] Global test environment tear-down
[==========] 5 tests from 1 test suite ran. </span><span class="koboSpan" id="kobo.340.4">(1 ms total)
[  PASSED  ] 5 tests.</span></pre>
<p><span class="koboSpan" id="kobo.341.1">The </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.342.1">output succinctly reports the execution and outcomes of each test, indicating the successful validation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">DataSender</span></strong><span class="koboSpan" id="kobo.344.1"> class’s handling of different network communication scenarios. </span><span class="koboSpan" id="kobo.344.2">For more comprehensive details on utilizing gMock, including its full suite of features, the official gMock documentation serves as an essential resource, guiding developers through effective mocking strategies in C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">unit testing.</span></span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.346.1">Mocking non-virtual methods via dependency injection</span></h2>
<p><span class="koboSpan" id="kobo.347.1">In </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.348.1">certain scenarios, you might encounter the need to mock non-virtual methods for unit testing. </span><span class="koboSpan" id="kobo.348.2">This can be challenging, as traditional mocking frameworks such as gMock primarily target virtual methods due to C++’s polymorphism requirements. </span><span class="koboSpan" id="kobo.348.3">However, one effective strategy to overcome this limitation is through dependency injection, coupled with the use of templates. </span><span class="koboSpan" id="kobo.348.4">This approach enhances testability and flexibility by decoupling the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">class dependencies.</span></span></p>
<h3><span class="koboSpan" id="kobo.350.1">Refactoring for testability</span></h3>
<p><span class="koboSpan" id="kobo.351.1">To </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.352.1">illustrate this, let’s refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Socket</span></strong><span class="koboSpan" id="kobo.354.1"> class interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">DataSender</span></strong><span class="koboSpan" id="kobo.356.1"> class to accommodate the mocking of non-virtual methods. </span><span class="koboSpan" id="kobo.356.2">We’ll introduce templates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">DataSender</span></strong><span class="koboSpan" id="kobo.358.1"> to allow injecting either the real </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Socket</span></strong><span class="koboSpan" id="kobo.360.1"> class or its </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">mock version.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">First, consider a simplified version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Socket</span></strong><span class="koboSpan" id="kobo.364.1"> class without </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">virtual methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
class Socket {
public:
    // sends raw byte array of given size, returns number of bytes sent
    // or -1 in case of error
    ssize_t send(void* data, size_t size);
    // receives raw byte array of given size, returns number of bytes received
    // or -1 in case of error
    ssize_t recv(void* data, size_t size);
};</span></pre>
<p><span class="koboSpan" id="kobo.367.1">Next, we modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">DataSender</span></strong><span class="koboSpan" id="kobo.369.1"> class to accept a </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">template</span></strong><span class="koboSpan" id="kobo.371.1"> parameter for the socket type, enabling the injection of either a real socket or a mock socket </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">at compile-time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
template&lt;typename SocketType&gt;
class DataSender {
    static constexpr size_t RETRY_NUM = 2;
public:
    DataSender(SocketType* socket) : _socket{socket} {}
    void send() {
        auto data = std::array&lt;int, 32&gt;{};
        auto bytesSent = 0;
        for (size_t i = 0; i &lt; RETRY_NUM &amp;&amp; bytesSent != sizeof(data); ++i) {
            bytesSent = _socket-&gt;send(&amp;data, sizeof(data));
            if (bytesSent &lt; 0) {
                throw ConnectionError{};
            }
            if (bytesSent == 0) {
                throw ConnectionClosedByPeer{};
            }
        }
        if (bytesSent != sizeof(data)) {
            throw DataSentPartially{};
        }
    }
private:
    SocketType* _socket;
};</span></pre>
<p><span class="koboSpan" id="kobo.374.1">With</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.375.1"> this template-based design, </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">DataSender</span></strong><span class="koboSpan" id="kobo.377.1"> can now be instantiated with any type that conforms to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Socket</span></strong><span class="koboSpan" id="kobo.379.1"> interface, including </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">mock types.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.381.1">Mocking with templates</span></h2>
<p><span class="koboSpan" id="kobo.382.1">For the</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.383.1"> mock version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Socket</span></strong><span class="koboSpan" id="kobo.385.1">, we can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">MockSocket</span></strong><span class="koboSpan" id="kobo.387.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
class MockSocket {
public:
    MOCK_METHOD(ssize_t, send, (void* data, size_t size), ());
    MOCK_METHOD(ssize_t, recv, (void* data, size_t size), ());
};</span></pre>
<p><span class="koboSpan" id="kobo.390.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">MockSocket</span></strong><span class="koboSpan" id="kobo.392.1"> class mimics the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Socket</span></strong><span class="koboSpan" id="kobo.394.1"> interface but uses gMock’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">MOCK_METHOD</span></strong><span class="koboSpan" id="kobo.396.1"> to define </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">mock methods.</span></span></p>
<h3><span class="koboSpan" id="kobo.398.1">Unit testing with dependency injection</span></h3>
<p><span class="koboSpan" id="kobo.399.1">When</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.400.1"> writing tests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">DataSender</span></strong><span class="koboSpan" id="kobo.402.1">, we can now inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">MockSocket</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.404.1">using templates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
TEST(DataSender, HappyPath) {
    MockSocket socket;
    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));
    DataSender&lt;MockSocket&gt; sender(&amp;socket);
    sender.send();
}</span></pre>
<p><span class="koboSpan" id="kobo.406.1">In this test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">DataSender</span></strong><span class="koboSpan" id="kobo.408.1"> is instantiated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">MockSocket</span></strong><span class="koboSpan" id="kobo.410.1">, allowing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">send</span></strong><span class="koboSpan" id="kobo.412.1"> method to be mocked as desired. </span><span class="koboSpan" id="kobo.412.2">This demonstrates how templates and dependency injection enable the mocking of non-virtual methods, providing a flexible and powerful approach to unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">in C++.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">This technique, while powerful, requires careful design consideration to ensure that the code remains clean </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.415.1">and maintainable. </span><span class="koboSpan" id="kobo.415.2">For complex scenarios or further exploration of mocking strategies, the official gMock documentation remains an invaluable resource, offering a wealth of information on advanced mocking techniques and </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">best practices.</span></span></p>
<h4><span class="koboSpan" id="kobo.417.1">Mocking singletons</span></h4>
<p><span class="koboSpan" id="kobo.418.1">Despite being </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.419.1">considered an anti-pattern due to its potential to introduce a global state and tight coupling in software designs, the Singleton pattern is nevertheless prevalent in many code bases. </span><span class="koboSpan" id="kobo.419.2">Its convenience for ensuring a single instance of a class often leads to its use in scenarios such as database connections, where a single, shared resource is </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">logically appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">The Singleton pattern’s characteristic of restricting class instantiation and providing a global access point presents a challenge for unit testing, particularly when the need arises to mock the </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">singleton’s behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">Consider the example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">Database</span></strong><span class="koboSpan" id="kobo.425.1"> class implemented as </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">a singleton:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
class Database {
public:
    std::vector&lt;std::string&gt; query(uint32_t id) const {
        return {};
    }
    static Database&amp; getInstance() {
        static Database db;
        return db;
    }
private:
    Database() = default;
};</span></pre>
<p><span class="koboSpan" id="kobo.428.1">In this scenario, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">DataHandler</span></strong><span class="koboSpan" id="kobo.430.1"> class interacts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Database</span></strong><span class="koboSpan" id="kobo.432.1"> singleton to perform operations, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">querying data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
class DataHandler {
public:
    DataHandler() {}
    void doSomething() {
        auto&amp; db = Database::getInstance();
        auto result = db.query(42);
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.435.1">To</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.436.1"> facilitate testing of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">DataHandler</span></strong><span class="koboSpan" id="kobo.438.1"> class without relying on the real </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Database</span></strong><span class="koboSpan" id="kobo.440.1"> instance, we can introduce a templated variation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">DataHandler1</span></strong><span class="koboSpan" id="kobo.442.1">, that allows injecting a mock </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">database instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
template&lt;typename Db&gt;
class DataHandler1 {
public:
    DataHandler1() {}
    std::vector&lt;std::string&gt; doSomething() {
        auto&amp; db = Db::getInstance();
        auto result = db.query(42);
        return result;
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.445.1">This approach leverages templates to decouple </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">DataHandler1</span></strong><span class="koboSpan" id="kobo.447.1"> from the concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Database</span></strong><span class="koboSpan" id="kobo.449.1"> singleton, enabling the substitution of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">MockDatabase</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.451.1">during tests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
class MockDatabase {
public:
    std::vector&lt;std::string&gt; query(uint32_t id) const {
        return {“AAA”};
    }
    static MockDatabase&amp; getInstance() {
        static MockDatabase db;
        return db;
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.453.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">MockDatabase</span></strong><span class="koboSpan" id="kobo.455.1"> in</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.456.1"> place, unit tests can now simulate database interactions without hitting the actual database, as demonstrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">test case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
TEST(DataHandler, check) {
    auto dh = DataHandler1&lt;MockDatabase&gt;{};
    EXPECT_EQ(dh.doSomething(), std::vector&lt;std::string&gt;{“AAA”});
}</span></pre>
<p><span class="koboSpan" id="kobo.459.1">This test instantiates </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">DataHandler1</span></strong><span class="koboSpan" id="kobo.461.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">MockDatabase</span></strong><span class="koboSpan" id="kobo.463.1">, ensuring that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">doSomething</span></strong><span class="koboSpan" id="kobo.465.1"> method interacts with the mock rather than the real database. </span><span class="koboSpan" id="kobo.465.2">The expected result is a predefined mock response, making the test predictable and isolated from </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">external dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">This templated solution, a variation of the dependency injection technique discussed earlier, showcases the flexibility and power of templates in C++. </span><span class="koboSpan" id="kobo.467.2">It elegantly addresses the challenge of mocking singletons, thereby enhancing the testability of components that depend on singleton instances. </span><span class="koboSpan" id="kobo.467.3">For more complex scenarios or further exploration of mocking strategies, referring to the official gMock documentation is advisable, as it offers comprehensive insights into advanced mocking techniques and </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">best practices.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.469.1">The Nice, the Strict, and the Naggy</span></h2>
<p><span class="koboSpan" id="kobo.470.1">In the world of unit testing with gMock, managing the behavior of mock objects and their interactions with the system under test is crucial. </span><span class="koboSpan" id="kobo.470.2">gMock introduces three modes to control this behavior: Naggy, Nice, and Strict. </span><span class="koboSpan" id="kobo.470.3">These modes determine how gMock handles uninteresting calls – those not matched by </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">any </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">EXPECT_CALL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.474.1">Naggy mocks</span></h3>
<p><span class="koboSpan" id="kobo.475.1">By default, mock</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.476.1"> objects in gMock are “naggy.” </span><span class="koboSpan" id="kobo.476.2">This means that while they warn about uninteresting calls, these calls do not cause the test to fail. </span><span class="koboSpan" id="kobo.476.3">The warning serves as a</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.477.1"> reminder that there might be unexpected interactions with the mock, but it’s not critical enough to warrant a test failure. </span><span class="koboSpan" id="kobo.477.2">This behavior ensures that tests focus on the intended expectations without being too lenient or too strict about </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">incidental interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">test scenario:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
TEST(DataSender, Naggy) {
    auto socket = MockSocket{};
    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));
    auto sender = DataSender(&amp;socket);
    sender.send();
}</span></pre>
<p><span class="koboSpan" id="kobo.482.1">In this case, if there’s an uninteresting call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">recv</span></strong><span class="koboSpan" id="kobo.484.1">, gMock issues a warning but the test will pass, marking unanticipated interactions without failing </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the test.</span></span></p>
<h3><span class="koboSpan" id="kobo.486.1">Nice mocks</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">NiceMock</span></strong><span class="koboSpan" id="kobo.488.1"> objects</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.489.1"> go a step further by suppressing warnings for </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.490.1">uninteresting calls. </span><span class="koboSpan" id="kobo.490.2">This mode is useful when the test’s focus is strictly on specific interactions, and other incidental calls to the mock should be ignored without cluttering the test output </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">with warnings.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">NiceMock</span></strong><span class="koboSpan" id="kobo.494.1"> in a test looks </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
TEST(DataSender, Nice) {
    auto socket = NiceMock&lt;MockSocket&gt;{};
    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));
    auto sender = DataSender(&amp;socket);
    sender.send();
}</span></pre>
<p><span class="koboSpan" id="kobo.497.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Nice</span></strong><span class="koboSpan" id="kobo.499.1"> mode, even </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.500.1">if there are uninteresting calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">recv</span></strong><span class="koboSpan" id="kobo.502.1">, gMock</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.503.1"> quietly ignores them, keeping the test output clean and focused on the </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">defined expectations.</span></span></p>
<h3><span class="koboSpan" id="kobo.505.1">Strict mocks</span></h3>
<p><span class="koboSpan" id="kobo.506.1">On</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.507.1"> the other</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.508.1"> end of the spectrum, </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">StrictMock</span></strong><span class="koboSpan" id="kobo.510.1"> objects treat uninteresting calls as errors. </span><span class="koboSpan" id="kobo.510.2">This strictness ensures that every interaction with the mock is accounted for by an </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">EXPECT_CALL</span></strong><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">This mode is particularly useful in tests where precise control over mock interactions is necessary, and any deviation from the expected calls should lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">test failure.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">A test using </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">StrictMock</span></strong><span class="koboSpan" id="kobo.516.1"> might look </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">
TEST(DataSender, Strict) {
    auto socket = StrictMock&lt;MockSocket&gt;{};
    EXPECT_CALL(socket, send(_, _)).Times(1).WillOnce(Return(32 * sizeof(int)));
    auto sender = DataSender(&amp;socket);
    sender.send();
}</span></pre>
<p><span class="koboSpan" id="kobo.519.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Strict</span></strong><span class="koboSpan" id="kobo.521.1"> mode, any uninteresting call, such as to </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">recv</span></strong><span class="koboSpan" id="kobo.523.1">, results in a test failure, enforcing strict adherence to the </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">defined expectations.</span></span></p>
<h3><span class="koboSpan" id="kobo.525.1">Test output and recommended settings</span></h3>
<p><span class="koboSpan" id="kobo.526.1">The</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.527.1"> behavior of these mocking modes is reflected in the </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">test output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
Program returned: 1
Program stdout
[==========] Running 3 tests from 1 test suite.
</span><span class="koboSpan" id="kobo.529.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.529.3">[----------] 3 tests from DataSender
[ RUN      ] DataSender.Naggy
GMOCK WARNING:
Uninteresting mock function call - returning default value.
</span><span class="koboSpan" id="kobo.529.4">    Function call: recv(0x7ffd4aae23f0, 128)
          Returns: 0
NOTE: You can safely ignore the above warning unless this call should not happen.  Do not suppress it by blindly adding an EXPECT_CALL() if you don’t mean to enforce the call.  See https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md#knowing-when-to-expect for details.
</span><span class="koboSpan" id="kobo.529.5">[       OK ] DataSender.Naggy (0 ms)
[ RUN      ] DataSender.Nice
[       OK ] DataSender.Nice (0 ms)
[ RUN      ] DataSender.Strict
unknown file: Failure
Uninteresting mock function call - returning default value.
</span><span class="koboSpan" id="kobo.529.6">    Function call: recv(0x7ffd4aae23f0, 128)
          Returns: 0
[  FAILED  ] DataSender.Strict (0 ms)
[----------] 3 tests from DataSender (0 ms total)
[----------] Global test environment tear-down
[==========] 3 tests from 1 test suite ran. </span><span class="koboSpan" id="kobo.529.7">(0 ms total)
[  PASSED  ] 2 tests.
</span><span class="koboSpan" id="kobo.529.8">[  FAILED  ] 1 test, listed below:
[  FAILED  ] DataSender.Strict
 1 FAILED TEST</span></pre>
<p><span class="koboSpan" id="kobo.530.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">Naggy</span></strong><span class="koboSpan" id="kobo.532.1"> mode, the </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.533.1">test passes with a warning for uninteresting calls. </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Nice</span></strong><span class="koboSpan" id="kobo.535.1"> mode also passes but without any warnings. </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">Strict</span></strong><span class="koboSpan" id="kobo.537.1"> mode, however, fails the test if there are </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">uninteresting calls.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">It is recommended to start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">StrickMock</span></strong><span class="koboSpan" id="kobo.541.1"> and then relax the mode as needed. </span><span class="koboSpan" id="kobo.541.2">This approach ensures that tests are initially strict about interactions with mock objects, providing a safety net for unexpected calls. </span><span class="koboSpan" id="kobo.541.3">As the test suite matures and the expected interactions become clearer, the mode can be relaxed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">Naggy</span></strong><span class="koboSpan" id="kobo.543.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">Nice</span></strong><span class="koboSpan" id="kobo.545.1"> to reduce noise in the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">test output.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">For further exploration of these modes and advanced mocking techniques, the official gMock documentation provides comprehensive insights and examples, guiding developers through effective mock object management in </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Throughout this section, we delved into the functionalities and practical applications of Google Test (GTest) and Google Mock (GMock), essential tools for enhancing the testing framework and development workflow of C++ projects. </span><span class="koboSpan" id="kobo.549.2">GTest offers a robust environment for creating, managing, and executing unit tests, featuring test fixtures for shared setup and teardown routines, parameterized tests for varied input testing, and type-parameterized tests for applying the same tests across different data types. </span><span class="koboSpan" id="kobo.549.3">Its comprehensive assertion library ensures thorough validation of code behavior, contributing to the stability and durability of </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Complementing GTest, GMock allows for the seamless creation and utilization of mock objects, enabling isolated component testing by mimicking the behavior of dependencies. </span><span class="koboSpan" id="kobo.551.2">This is invaluable in complex systems where direct testing with real dependencies is either impractical or counterproductive. </span><span class="koboSpan" id="kobo.551.3">With GMock, developers gain access to a suite of features including automatic mock generation, versatile expectation settings, and detailed behavior verification, enabling in-depth testing of </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">component interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">By integrating GTest and GMock into the C++ development life cycle, developers can adopt a robust test-driven approach, ensuring code quality and facilitating continuous testing and integration practices, ultimately leading to more reliable and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">software projects.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.555.1">Other notable C++ unit testing frameworks</span></h1>
<p><span class="koboSpan" id="kobo.556.1">Beyond Google Test and Google Mock, the C++ ecosystem is rich with unit testing frameworks, each offering unique features and philosophies. </span><span class="koboSpan" id="kobo.556.2">These frameworks cater to various testing needs and preferences, providing developers with multiple options for integrating unit testing into </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">their projects.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.558.1">Catch2</span></h2>
<p><span class="koboSpan" id="kobo.559.1">Catch2 </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.560.1">stands out for its simplicity and ease of use, requiring</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.561.1"> minimal boilerplate code to get started. </span><span class="koboSpan" id="kobo.561.2">It adopts a header-only distribution, making it straightforward to integrate into projects. </span><span class="koboSpan" id="kobo.561.3">Catch2 supports a variety of testing paradigms, including BDD-style test cases, and offers expressive assertion macros that enhance test readability and intent. </span><span class="koboSpan" id="kobo.561.4">Its standout feature is the “Sections” mechanism, which provides a natural way to share setup and teardown code among tests in a flexible and </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">hierarchical manner.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.563.1">Boost.Test</span></h2>
<p><span class="koboSpan" id="kobo.564.1">Part of the </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.565.1">extensive Boost libraries, Boost.Test offers robust support </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.566.1">for unit testing in C++. </span><span class="koboSpan" id="kobo.566.2">It provides a comprehensive assertion framework, test organization facilities, and integration with the Boost build system. </span><span class="koboSpan" id="kobo.566.3">Boost.Test can be used in a header-only mode or compiled mode, offering flexibility in its deployment. </span><span class="koboSpan" id="kobo.566.4">It’s known for its detailed test result reports and wide range of built-in tools for test case management, making it suitable for both small and </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">large-scale projects.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.568.1">Doctest</span></h2>
<p><span class="koboSpan" id="kobo.569.1">Doctest is </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.570.1">designed with a focus on simplicity and speed, positioning </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.571.1">itself as the lightest feature-rich C++ testing framework. </span><span class="koboSpan" id="kobo.571.2">It’s particularly appealing for TDD due to its fast compile times. </span><span class="koboSpan" id="kobo.571.3">Inspired by Catch2, Doctest offers a similar syntax but aims to be more lightweight and faster to compile, making it ideal for including tests in everyday development without impacting build </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">times significantly.</span></span></p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.573.1">Google Test versus Catch2 versus Boost.Test versus Doctest</span></h2>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.574.1">Simplicity</span></strong><span class="koboSpan" id="kobo.575.1">: Catch2 </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.576.1">and Doctest excel in simplicity and ease of use, with Catch2 offering BDD-style syntax and Doctest being </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">extremely lightweight</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.578.1">Integration</span></strong><span class="koboSpan" id="kobo.579.1">: Google Test and Boost.Test will provide more extensive integration capabilities, particularly suited for larger projects with complex </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">testing needs</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.581.1">Performance</span></strong><span class="koboSpan" id="kobo.582.1">: Doctest stands out for its compile-time and runtime performance, making it ideal for rapid </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">development cycles</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.584.1">Features</span></strong><span class="koboSpan" id="kobo.585.1">: Boost.Test and Google Test come with a more comprehensive set of features out of the box, including</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.586.1"> advanced test case management and </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">detailed reporting</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.588.1">Choosing the right framework often comes down to project-specific requirements, developer preferences, and the desired balance between simplicity, performance, and feature richness. </span><span class="koboSpan" id="kobo.588.2">Developers are encouraged to explore these frameworks further to determine which best fits their unit testing needs, contributing to more reliable, maintainable, and high-quality </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">C++ software.</span></span></p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.590.1">Good candidates for unit tests</span></h1>
<p><span class="koboSpan" id="kobo.591.1">Identifying the</span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.592.1"> optimal candidates for unit testing is pivotal in establishing a robust testing strategy. </span><span class="koboSpan" id="kobo.592.2">Unit tests excel when applied to parts of the code base that are well-suited to isolation and fine-grained verification. </span><span class="koboSpan" id="kobo.592.3">Here are some key examples </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">and recommendations:</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">Classes and functions with clear boundaries and well-defined responsibilities are prime candidates for unit testing. </span><span class="koboSpan" id="kobo.594.2">These components should ideally embody the Single Responsibility Principle, handling a specific aspect of the application’s functionality. </span><span class="koboSpan" id="kobo.594.3">Testing these isolated units allows for precise verification of their behavior, ensuring that they perform their intended tasks correctly under </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">various conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Pure functions, which depend solely on their input parameters and produce no side effects, are excellent targets for unit tests. </span><span class="koboSpan" id="kobo.596.2">Their deterministic nature – where a given input always results in the same output – makes them straightforward to test and verify. </span><span class="koboSpan" id="kobo.596.3">Pure functions are often found in utility libraries, mathematical computations, and data </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">transformation operations.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">Components that interact with dependencies through well-defined interfaces are easier to test, especially when those dependencies can be easily mocked or stubbed. </span><span class="koboSpan" id="kobo.598.2">This facilitates testing the component in isolation, focusing on its logic rather than the implementation details of </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">The business logic layer, which encapsulates the core functionality and rules of the application, is typically well-suited for unit testing. </span><span class="koboSpan" id="kobo.600.2">This layer often involves calculations, data processing, and decision-making that can be tested in isolation from the user interface and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">external systems.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">While many aspects of an application are suitable for unit testing, it’s prudent to recognize scenarios that pose challenges. </span><span class="koboSpan" id="kobo.602.2">Components that require complex interactions with external resources, such as databases, filesystems, and network services, might be difficult to effectively mock or might</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.603.1"> lead to flaky tests due to their reliance on external state or behavior. </span><span class="koboSpan" id="kobo.603.2">While mocking can simulate some of these interactions, the complexity and overhead might not always justify the effort in the context of </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">Although unit tests are invaluable for verifying individual components, they have their limitations, especially concerning integrations and end-to-end interactions. </span><span class="koboSpan" id="kobo.605.2">For code that is inherently difficult to isolate or requires complex external interactions, </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">end-to-end</span></strong><span class="koboSpan" id="kobo.607.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.608.1">E2E</span></strong><span class="koboSpan" id="kobo.609.1">) tests become crucial. </span><span class="koboSpan" id="kobo.609.2">E2E tests simulate real-world usage scenarios, covering the flow from the user interface through to the backend systems and external integrations. </span><span class="koboSpan" id="kobo.609.3">In the next section, we will delve into E2E testing, exploring its role in complementing unit tests and providing comprehensive coverage of the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">application’s functionality.</span></span></p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.611.1">E2E testing in software development</span></h1>
<p><span class="koboSpan" id="kobo.612.1">E2E testing is a</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.613.1"> comprehensive testing approach that evaluates the application’s functionality and performance from start to finish. </span><span class="koboSpan" id="kobo.613.2">Unlike unit testing, which isolates and tests individual components or units of code, E2E testing examines the application as an integrated whole, simulating real-world user scenarios. </span><span class="koboSpan" id="kobo.613.3">This method ensures that all the various components of the application, including its interfaces, databases, networks, and other services, work harmoniously to deliver the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">user experience.</span></span></p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.615.1">E2E testing frameworks</span></h2>
<p><span class="koboSpan" id="kobo.616.1">Given that </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.617.1">E2E testing often involves interacting with the application from the outside, it’s not confined to the language in which the application is written. </span><span class="koboSpan" id="kobo.617.2">For C++ applications, which might be part of a larger ecosystem or serve as backend systems, E2E testing can be conducted using a variety of frameworks across different languages. </span><span class="koboSpan" id="kobo.617.3">Some popular E2E testing frameworks include </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.619.1">Selenium</span></strong><span class="koboSpan" id="kobo.620.1">: Predominantly </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.621.1">used for web applications, Selenium</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.622.1"> can automate browsers to simulate user interactions with web interfaces, making it a versatile tool for </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">E2E testing</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.624.1">Cypress</span></strong><span class="koboSpan" id="kobo.625.1">: Another </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.626.1">powerful tool for web applications, Cypress</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.627.1"> offers a more modern and developer-friendly approach to E2E testing with rich debugging capabilities and a </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">robust API</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.629.1">Postman</span></strong><span class="koboSpan" id="kobo.630.1">: For </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.631.1">applications exposing RESTful APIs, Postman </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.632.1">allows comprehensive API testing, ensuring that the application’s endpoints perform as expected under </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">various conditions</span></span></li>
</ul>
<h2 id="_idParaDest-252"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.634.1">When to use E2E testing</span></h2>
<p><span class="koboSpan" id="kobo.635.1">E2E testing is</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.636.1"> particularly valuable in scenarios where the application’s components must interact in complex workflows, often involving multiple systems and external dependencies. </span><span class="koboSpan" id="kobo.636.2">It’s crucial for </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.638.1">Testing complex user workflows</span></strong><span class="koboSpan" id="kobo.639.1">: E2E testing shines in validating user journeys that span multiple application components, ensuring a seamless experience from the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">user’s perspective</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.641.1">Integration scenarios</span></strong><span class="koboSpan" id="kobo.642.1">: When the application interacts with external systems or services, E2E testing verifies that these integrations work as intended, catching issues that might not be evident </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">in isolation</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.644.1">Critical path testing</span></strong><span class="koboSpan" id="kobo.645.1">: For features and pathways that are critical to the application’s core functionality, E2E testing ensures reliability and performance under realistic </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">usage conditions</span></span></li>
</ul>
<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.647.1">Situations favoring E2E testing</span></h1>
<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.648.1">Complex interactions</span></h2>
<p><span class="koboSpan" id="kobo.649.1">In</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.650.1"> situations where the application’s components engage in intricate interactions, possibly spanning different technologies and platforms, unit tests might fall short. </span><span class="koboSpan" id="kobo.650.2">E2E testing is indispensable for ensuring that the collective behavior of these components aligns with the expected outcomes, </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">especially in:</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">The architecture outlined in the diagram represents a typical web application with several interconnected services, each serving a distinct role in </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">the system.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.654.1"><img alt="Figure 12.1 – E2E testing" src="image/B19606_12_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.655.1">Figure 12.1 – E2E testing</span></p>
<p><span class="koboSpan" id="kobo.656.1">At the frontend, there’s a </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">user UI</span></strong><span class="koboSpan" id="kobo.658.1">, which</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.659.1"> is the graphical interface where users interact with the application. </span><span class="koboSpan" id="kobo.659.2">It’s designed to send and receive data to and from the backend services through </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.660.1">an </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">API gateway</span></strong><span class="koboSpan" id="kobo.662.1">. </span><span class="koboSpan" id="kobo.662.2">The API gateway acts as an intermediary that routes requests from the user UI to the appropriate backend services and aggregates responses to send back to </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">the UI.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">Several backend services </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">are illustrated:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.666.1">Account management</span></strong><span class="koboSpan" id="kobo.667.1">: This service handles user accounts, including authentication, profile management, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">user-related data</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.669.1">Billing</span></strong><span class="koboSpan" id="kobo.670.1">: Responsible for managing billing information, subscriptions, </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">and invoicing</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.672.1">Payments</span></strong><span class="koboSpan" id="kobo.673.1">: Processes financial transactions, such as credit card processing or interfacing with </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">payment gateways</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.675.1">Notifications</span></strong><span class="koboSpan" id="kobo.676.1">: Sends out alerts or messages to users, likely triggered by certain events in the account management or </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">billing services</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.678.1">External services, possibly third-party applications or data providers, can also interact with the API gateway, providing additional functionality or data that supports the </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">main application.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">For E2E testing of this system, tests would simulate user actions on the user UI, such as signing up for an account or making a payment. </span><span class="koboSpan" id="kobo.680.2">The tests would then verify that the UI correctly sends the appropriate requests through the API gateway to the backend services. </span><span class="koboSpan" id="kobo.680.3">Subsequently, the tests would confirm that the user UI responds correctly to the data received from the backend, ensuring that the entire workflow, from the user UI down to notifications, operates as expected. </span><span class="koboSpan" id="kobo.680.4">This comprehensive testing approach ensures that each component functions individually and in concert with the rest of the system, delivering a seamless experience for </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">To summarize, it is </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.683.1">essential to consider E2E testing in scenarios where the application’s components engage in complex interactions, especially when these interactions span different technologies and platforms. </span><span class="koboSpan" id="kobo.683.2">E2E testing ensures that the collective behavior of these components aligns with the expected outcomes, providing a comprehensive assessment of the application’s functionality and performance. </span><span class="koboSpan" id="kobo.683.3">Here are some of the most common cases when E2E </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">is beneficial:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.685.1">Multi-layered applications</span></strong><span class="koboSpan" id="kobo.686.1">: Applications with multiple layers or tiers, such as client-server architectures, benefit from E2E testing to ensure the layers </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">communicate effectively</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.688.1">Distributed systems</span></strong><span class="koboSpan" id="kobo.689.1">: For applications spread across different environments or services, E2E testing can validate the data flow and functionality across these </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">distributed components</span></span></li>
</ul>
<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.691.1">Real-world environment testing</span></h2>
<p><span class="koboSpan" id="kobo.692.1">One of </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.693.1">the primary advantages of E2E testing is its ability to replicate the conditions close to the production environment. </span><span class="koboSpan" id="kobo.693.2">This includes testing the application on actual hardware, interacting with real databases, and navigating through the genuine network infrastructure. </span><span class="koboSpan" id="kobo.693.3">This level of testing is crucial for </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.695.1">Performance validation</span></strong><span class="koboSpan" id="kobo.696.1">: Ensuring that the application performs optimally under expected load conditions and </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">user traffic</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.698.1">Security assurance</span></strong><span class="koboSpan" id="kobo.699.1">: Verifying that the application’s security measures are effective in a realistic environment, protecting against </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">potential vulnerabilities</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.701.1">E2E testing serves as the final checkpoint before software release, offering a comprehensive assessment of the application’s readiness for deployment. </span><span class="koboSpan" id="kobo.701.2">By simulating real-world scenarios, E2E testing ensures that the application not only meets its technical specifications but also delivers a reliable and user-friendly experience, making it an essential component of the software development </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">life cycle.</span></span></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.703.1">Automatic test coverage tracking tools</span></h1>
<p><span class="koboSpan" id="kobo.704.1">In the </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.705.1">quest to ensure comprehensive testing of software projects, automatic test coverage tracking tools play a pivotal role. </span><span class="koboSpan" id="kobo.705.2">These tools provide invaluable insights into the extent to which the source code of an application is executed during testing, highlighting areas that are well-tested and those that may need </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">additional attention.</span></span></p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.707.1">Automatic test coverage tracking tools with examples</span></h2>
<p><span class="koboSpan" id="kobo.708.1">Ensuring</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.709.1"> comprehensive test coverage is a cornerstone of reliable</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.710.1"> software development. </span><span class="koboSpan" id="kobo.710.2">Tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">gcov</span></strong><span class="koboSpan" id="kobo.712.1"> for the </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">GNU Compiler Collection</span></strong><span class="koboSpan" id="kobo.714.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.715.1">GCC</span></strong><span class="koboSpan" id="kobo.716.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.718.1"> for LLVM projects automate the tracking of test coverage, providing crucial insights into how thoroughly the tests exercise </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">the code.</span></span></p>
<h3><span class="koboSpan" id="kobo.720.1">Tool overview with examples</span></h3>
<p><span class="koboSpan" id="kobo.721.1">There are two major tools used for automatic test coverage tracking in </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">C++ projects:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.723.1">gcov</span></strong><span class="koboSpan" id="kobo.724.1">: As</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.725.1"> an integral part of GCC, </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">gcov</span></strong><span class="koboSpan" id="kobo.727.1"> analyzes </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.728.1">the execution paths taken in your code during test runs. </span><span class="koboSpan" id="kobo.728.2">For instance, after compiling a C++ </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">example.cpp</span></strong><span class="koboSpan" id="kobo.730.1"> file with </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">g++ -fprofile-arcs -ftest-coverage example.cpp</span></strong><span class="koboSpan" id="kobo.732.1">, running the corresponding test suite generates coverage data. </span><span class="koboSpan" id="kobo.732.2">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">gcov example.cpp</span></strong><span class="koboSpan" id="kobo.734.1"> afterward produces a report detailing the number of times each line of code </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">was executed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.736.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.737.1">: Serving</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.738.1"> a similar purpose within</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.739.1"> LLVM projects, </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.741.1"> works with Clang to offer detailed coverage reports. </span><span class="koboSpan" id="kobo.741.2">Compiling with </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">clang++ -fprofile-instr-generate -fcoverage-mapping example.cpp</span></strong><span class="koboSpan" id="kobo.743.1"> and then executing the test binary with </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">LLVM_PROFILE_FILE=”example.profraw” ./example</span></strong><span class="koboSpan" id="kobo.745.1"> prepares the coverage data. </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">llvm-profdata merge -sparse example.profraw -o example.profdata</span></strong><span class="koboSpan" id="kobo.747.1"> followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">llvm-cov show ./example -instr-profile=example.profdata</span></strong><span class="koboSpan" id="kobo.749.1"> generates a coverage report </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">example.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.753.1">Integration with C++ projects</span></h3>
<p><span class="koboSpan" id="kobo.754.1">Integrating these </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.755.1">tools into C++ projects involves compiling the source with coverage flags, executing the tests to generate coverage data, and then analyzing this data to </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">produce reports.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">For a project with multiple files, you might compile with </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
g++ -fprofile-arcs -ftest-coverage file1.cpp file2.cpp -o testExecutable</span></pre>
<p><span class="koboSpan" id="kobo.760.1">After running </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">./testExecutable</span></strong><span class="koboSpan" id="kobo.762.1"> to execute your tests, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">gcov file1.cpp file2.cpp</span></strong><span class="koboSpan" id="kobo.764.1"> to generate coverage reports for each </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.766.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.768.1">, the</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.769.1"> process is similar but tailored for Clang. </span><span class="koboSpan" id="kobo.769.2">After compilation and test execution, merging profile data with </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">llvm-profdata</span></strong><span class="koboSpan" id="kobo.771.1"> and generating the report with </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.773.1"> provides a comprehensive view of </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">test coverage.</span></span></p>
<h3><span class="koboSpan" id="kobo.775.1">Interpreting coverage reports</span></h3>
<p><span class="koboSpan" id="kobo.776.1">The</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.777.1"> coverage reports generated by these tools offer </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">several metrics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.779.1">Line coverage</span></strong><span class="koboSpan" id="kobo.780.1">: This</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.781.1"> indicates the percentage of code lines executed. </span><span class="koboSpan" id="kobo.781.2">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">gcov</span></strong><span class="koboSpan" id="kobo.783.1"> report might state </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">Lines executed:90.00% of 100</span></strong><span class="koboSpan" id="kobo.785.1">, meaning 90 out of 100 lines were run </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">during tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.787.1">Branch coverage</span></strong><span class="koboSpan" id="kobo.788.1">: This provides insight into conditional statement testing. </span><span class="koboSpan" id="kobo.788.2">A line in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">gcov</span></strong><span class="koboSpan" id="kobo.790.1"> report</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.791.1"> such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">Branches executed:85.00% of 40</span></strong><span class="koboSpan" id="kobo.793.1"> shows that 85% of all branches </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">were tested.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.795.1">Function coverage</span></strong><span class="koboSpan" id="kobo.796.1">: This</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.797.1"> shows the percentage of functions that were called. </span><span class="koboSpan" id="kobo.797.2">An entry such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">Functions executed:95.00% of 20</span></strong><span class="koboSpan" id="kobo.799.1"> in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">gcov</span></strong><span class="koboSpan" id="kobo.801.1"> report indicates that 95% of functions were invoked </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">during testing.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.803.1">For example, a simplified </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">gcov</span></strong><span class="koboSpan" id="kobo.805.1"> report might look </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.807.1">
File ‘example.cpp’
Lines executed:90.00% of 100
Branches executed:85.00% of 40
Functions executed:95.00% of 20</span></pre>
<p><span class="koboSpan" id="kobo.808.1">Similarly, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.810.1"> report provides detailed coverage metrics, along with the specific lines and branches covered, enhancing the ability to pinpoint areas needing </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">additional tests.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">These reports guide developers in improving test coverage by highlighting untested code paths and functions, but they should not be the sole metric for test quality. </span><span class="koboSpan" id="kobo.812.2">High coverage with poorly designed tests can give a false sense of security. </span><span class="koboSpan" id="kobo.812.3">Effective use of these tools involves not just aiming for high coverage percentages but also ensuring that tests are meaningful and reflective of real-world </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">usage scenarios.</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.814.1">Utilizing hit maps for enhanced test coverage analysis</span></h2>
<p><span class="koboSpan" id="kobo.815.1">Hit maps, produced </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.816.1">by test coverage tracking tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">gcov</span></strong><span class="koboSpan" id="kobo.818.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.820.1">, offer a granular view of how tests exercise the code, serving as a detailed guide for developers aiming to improve test coverage. </span><span class="koboSpan" id="kobo.820.2">These hit maps go beyond simple percentage metrics, showing precisely which lines of code were executed during tests and how many times, thus enabling a more informed approach to enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">test suites.</span></span></p>
<h3><span class="koboSpan" id="kobo.822.1">Understanding hit maps</span></h3>
<p><span class="koboSpan" id="kobo.823.1">A hit map is</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.824.1"> essentially a detailed annotation of the source code, with each line accompanied by execution counts indicating how many times tests have run that particular line. </span><span class="koboSpan" id="kobo.824.2">This level of detail helps identify not only untested parts of the code but also areas that might be over-tested or need more varied </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">testing scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">.gcov</span></strong><span class="koboSpan" id="kobo.828.1"> files generated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">gcov</span></strong><span class="koboSpan" id="kobo.830.1"> and the annotated source code produced by </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.832.1"> provide these hit maps, offering a clear picture of test coverage at the </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">line level.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.834.1">
-:    0:Source:example.cpp
-:    0:Graph:example.gcno
-:    0:Data:example.gcda
-:    0:Runs:3
-:    0:Programs:1
3:    1:int main() {
-:    2:  // Some comment
2:    3:  bool condition = checkCondition();
1:    4:  if (condition) {
1:    5:    performAction();
    ...</span></pre>
<p><span class="koboSpan" id="kobo.835.1">In this example, line 3 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">bool condition = checkCondition();</span></strong><span class="koboSpan" id="kobo.837.1">) was executed twice, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">performAction();</span></strong><span class="koboSpan" id="kobo.839.1"> line within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">if</span></strong><span class="koboSpan" id="kobo.841.1"> statement was executed once, indicating that the condition was </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">true</span></strong><span class="koboSpan" id="kobo.843.1"> in one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">test runs.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">gcov</span></strong><span class="koboSpan" id="kobo.847.1">, after compiling with </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">clang++</span></strong><span class="koboSpan" id="kobo.849.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">-fprofile-instr-generate -fcoverage-mapping</span></strong><span class="koboSpan" id="kobo.851.1"> flags and executing the tests, </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.853.1"> can produce a hit map using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">llvm-cov show</span></strong><span class="koboSpan" id="kobo.855.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">-instr-profile</span></strong><span class="koboSpan" id="kobo.857.1"> flag pointing to the generated profile data. </span><span class="koboSpan" id="kobo.857.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">llvm-cov show ./example -instr-profile=example.profdata example.cpp</span></strong><span class="koboSpan" id="kobo.859.1"> outputs the annotated source code with </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">execution counts.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">The output </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.862.1">would resemble </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
example.cpp:
int main() {
    |  3|  // Some comment
    |  2|  bool condition = checkCondition();
    |  1|  if (condition) {
    |  1|    performAction();
    ...</span></pre>
<p><span class="koboSpan" id="kobo.865.1">Here, the execution count is prefixed to each line, providing a clear picture of test coverage at </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">a glance.</span></span></p>
<h3><span class="koboSpan" id="kobo.867.1">Leveraging hit maps for test improvement</span></h3>
<p><span class="koboSpan" id="kobo.868.1">By </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.869.1">examining hit maps, developers can identify code sections that are not covered by any test case, indicated by execution counts of zero. </span><span class="koboSpan" id="kobo.869.2">These areas represent potential risks for undetected bugs and should be prioritized for additional testing. </span><span class="koboSpan" id="kobo.869.3">Conversely, lines with exceptionally high execution counts might indicate areas where tests are redundant or overly focused, suggesting an opportunity to diversify test scenarios or refocus testing efforts on less-covered parts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.871.1">Incorporating hit map analysis into regular development workflows encourages a proactive approach to maintaining and enhancing test coverage, ensuring that tests remain effective and aligned with the evolving code base. </span><span class="koboSpan" id="kobo.871.2">As with all testing strategies, the goal is not merely to achieve high coverage numbers but to ensure that the test suite comprehensively validates the software’s functionality and reliability in a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">of scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">Incorporating hit maps into the development workflow has been made even more accessible with the advent</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.874.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.875.1">integrated development environment</span></strong><span class="koboSpan" id="kobo.876.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.877.1">IDE</span></strong><span class="koboSpan" id="kobo.878.1">) plugins that integrate coverage visualization directly into the coding environment. </span><span class="koboSpan" id="kobo.878.2">A notable example is the “Code Coverage” plugin by Markis Taylor for </span><strong class="bold"><span class="koboSpan" id="kobo.879.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.880.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.881.1">VSCode</span></strong><span class="koboSpan" id="kobo.882.1">). </span><span class="koboSpan" id="kobo.882.2">This </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.883.1">plugin overlays hit maps onto the source code within the VSCode editor, providing immediate, visual feedback on </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">test coverage.</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">The “Code Coverage” plugin </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.886.1">processes coverage reports generated by tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">gcov</span></strong><span class="koboSpan" id="kobo.888.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.890.1"> and visually annotates the source code in VSCode. </span><span class="koboSpan" id="kobo.890.2">Lines of code covered by tests are highlighted, typically in green, while uncovered lines are marked in red. </span><span class="koboSpan" id="kobo.890.3">This immediate visual representation allows developers to quickly identify untested code regions without leaving the editor or navigating through external </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">coverage reports.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.892.1">Recommendations for code coverage</span></h2>
<p><span class="koboSpan" id="kobo.893.1">Code coverage</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.894.1"> is a vital metric in</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.895.1"> the realm of software testing, providing insights into the extent to which the code base is exercised by the test suite. </span><span class="koboSpan" id="kobo.895.2">For C++ projects, leveraging tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">gcov</span></strong><span class="koboSpan" id="kobo.897.1"> for GCC and </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.899.1"> for LLVM projects can offer detailed coverage analysis. </span><span class="koboSpan" id="kobo.899.2">These tools are adept at not only tracking coverage from unit tests but also from E2E tests, allowing for a comprehensive assessment of test coverage across different </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">testing levels.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">A robust</span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.902.1"> testing strategy involves a combination of focused unit tests, which validate individual components in isolation, and broader E2E tests, which assess the system’s functionality as a whole. </span><span class="koboSpan" id="kobo.902.2">By employing </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">gcov</span></strong><span class="koboSpan" id="kobo.904.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.906.1">, teams can aggregate coverage data from both testing types, providing a holistic view of the project’s test coverage. </span><span class="koboSpan" id="kobo.906.2">This combined approach helps identify areas of the code that are either under-tested or not tested at all, guiding efforts to enhance the test </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">suite’s effectiveness.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">It is recommended to keep a vigilant eye on code coverage metrics and strive to prevent any decrease in coverage percentages. </span><span class="koboSpan" id="kobo.908.2">A decline in coverage might indicate new code being added without adequate testing, potentially introducing undetected bugs into the system. </span><span class="koboSpan" id="kobo.908.3">To mitigate this risk, teams should integrate coverage checks into their </span><strong class="bold"><span class="koboSpan" id="kobo.909.1">continuous integration</span></strong><span class="koboSpan" id="kobo.910.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.911.1">CI</span></strong><span class="koboSpan" id="kobo.912.1">) pipelines, ensuring that any changes that reduce coverage are promptly identified </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">and addressed.</span></span></p>
<p><span class="koboSpan" id="kobo.914.1">Periodically, it’s beneficial to allocate time specifically for increasing test coverage, especially in areas identified as critical or risky. </span><span class="koboSpan" id="kobo.914.2">This might involve writing additional tests for complex logic, edge cases, or error-handling paths that were previously overlooked. </span><span class="koboSpan" id="kobo.914.3">Investing in coverage improvement initiatives not only enhances the software’s reliability but also contributes to a more maintainable and robust code base in the </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">long term.</span></span></p>
<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.916.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.917.1">This chapter provided a thorough overview of testing in C++, covering essential topics from unit testing basics to advanced E2E testing. </span><span class="koboSpan" id="kobo.917.2">You learned about unit testing’s role in ensuring individual components work correctly and how tools such as Google Test and Google Mock help write and manage these tests effectively. </span><span class="koboSpan" id="kobo.917.3">The chapter also touched on mocking techniques for simulating complex behaviors </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">in tests.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">Additionally, the importance of tracking test coverage using tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">gcov</span></strong><span class="koboSpan" id="kobo.921.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">llvm-cov</span></strong><span class="koboSpan" id="kobo.923.1"> was discussed, emphasizing the need to maintain and improve coverage over time. </span><span class="koboSpan" id="kobo.923.2">E2E testing was highlighted as crucial for checking the entire application’s functionality, complementing the more focused </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">By exploring different C++ testing frameworks, the chapter offered insights into the various tools available for developers, helping them choose the right ones for their projects. </span><span class="koboSpan" id="kobo.925.2">In essence, this chapter equipped you with the knowledge to implement comprehensive and effective testing strategies in your C++ development endeavors, contributing to the creation of reliable and </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">robust software.</span></span></p>
<p><span class="koboSpan" id="kobo.927.1">In the next chapter, we will explore modern approaches to third-party management in C++, including Docker-based solutions and available </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">package managers.</span></span></p>
</div>
</body></html>