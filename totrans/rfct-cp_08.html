<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-147"><a id="_idTextAnchor146"/>8</h1>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Designing and Developing APIs in C++</h1>
<p>In the world of software development, the design of <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) is<a id="_idIndexMarker367"/> of paramount importance. Good APIs serve as the backbone of software libraries, facilitating interaction between different software components and enabling developers to leverage functionality efficiently and effectively. Well-designed APIs are intuitive, easy to use, and maintainable, playing a crucial role in the success and longevity of software projects. In this chapter, we will delve into principles and practices for designing maintainable APIs for libraries developed in C++. We will explore key aspects of API design, including clarity, consistency, and extensibility, and provide concrete examples to illustrate best practices. By understanding and applying these principles, you will be able to create APIs that not only meet the immediate needs of users but also remain robust and adaptable over time, ensuring that your libraries are both powerful and user-friendly.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Principles of minimalistic API design</h1>
<p>Minimalistic APIs are <a id="_idIndexMarker368"/>designed to provide only the essential functionalities required to perform specific tasks, avoiding unnecessary features and complexity. The primary goal is to offer a clean, efficient, and user-friendly interface that facilitates easy integration and usage. Key benefits <a id="_idIndexMarker369"/>of minimalistic APIs include the following:</p>
<ul>
<li><strong class="bold">Ease of use</strong>: Users can quickly understand and utilize the API without extensive learning or documentation, promoting faster development cycles</li>
<li><strong class="bold">Maintainability</strong>: Simplified APIs are easier to maintain, allowing for straightforward updates and bug fixes without introducing new complexities</li>
<li><strong class="bold">Performance</strong>: Leaner APIs tend to have better performance due to reduced overhead and more efficient execution paths</li>
<li><strong class="bold">Reliability</strong>: With fewer components and interactions, the likelihood of bugs and unexpected<a id="_idIndexMarker370"/> issues is minimized, leading to more reliable and stable software</li>
</ul>
<p>Simplicity and<a id="_idIndexMarker371"/> clarity are fundamental principles in the design of minimalistic APIs. These principles ensure that the API remains accessible and user-friendly, enhancing the overall developer experience. Key aspects of simplicity and clarity include the following:</p>
<ul>
<li><strong class="bold">Straightforward interfaces</strong>: Designing simple and clear interfaces helps developers quickly grasp the available functionalities, making it easier to integrate and use the API effectively</li>
<li><strong class="bold">Reduced cognitive load</strong>: By minimizing the mental effort required to understand and use the API, developers are less likely to make mistakes, leading to more efficient development processes</li>
<li><strong class="bold">Intuitive design</strong>: An API that adheres to simplicity and clarity aligns closely with common usage patterns and developer expectations, making it more intuitive and easier to adopt</li>
</ul>
<p>Overengineering and unnecessary complexity can severely undermine the effectiveness of an API. To avoid these pitfalls, consider the following strategies:</p>
<ul>
<li><strong class="bold">Focus on core functionality</strong>: Concentrate on delivering essential features that address the primary use cases. Avoid adding extraneous features that are not directly aligned with the core purpose of the API.</li>
<li><strong class="bold">Iterative design</strong>: Begin with<a id="_idIndexMarker372"/> a <strong class="bold">minimum viable product</strong> (<strong class="bold">MVP</strong>) and incrementally add features based on user feedback and actual needs rather than speculative requirements.</li>
<li><strong class="bold">Clear documentation</strong>: Provide comprehensive yet concise documentation that focuses on core functionality and common use cases. This helps prevent confusion and misuse.</li>
<li><strong class="bold">Consistent naming conventions</strong>: Use consistent and descriptive names for functions, classes, and parameters to enhance clarity and predictability.</li>
<li><strong class="bold">Minimal dependencies</strong>: Reduce the number of external dependencies to simplify the integration process and minimize potential compatibility issues.</li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Techniques for achieving minimalism</h1>
<p>Functional <a id="_idIndexMarker373"/>decomposition is the process of breaking down complex functionalities into smaller, more manageable units. This technique is crucial for creating minimalistic APIs as it promotes simplicity and modularity. By decomposing functions, you ensure that each part of the API has a clear, well-defined purpose, which enhances maintainability and usability.</p>
<p>Key aspects of functional decomposition include the following:</p>
<ul>
<li><strong class="bold">Modular design</strong>: Design the API such that each module or function handles a specific aspect of the overall functionality. This <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>) ensures that each <a id="_idIndexMarker374"/>part of the API has a clear, well-defined purpose.</li>
<li><strong class="bold">Single Responsibility Principle (SRP)</strong>: Each function or class should have one, and only one, reason to change. This principle helps in keeping the API simple and focused.</li>
<li><strong class="bold">Reusable components</strong>: By decomposing functions into smaller units, you can create reusable components that can be combined in different ways to achieve various tasks, enhancing the flexibility and reusability of the API.</li>
</ul>
<p>Interface segregation aims to keep interfaces lean and focused on specific tasks, avoiding the design of monolithic interfaces that try to cover too many use cases. This principle ensures that clients only need to know about the methods that are relevant to them, making the API easier to use and understand.</p>
<p>Key aspects of interface segregation include the following:</p>
<ul>
<li><strong class="bold">Specific interfaces</strong>: Instead of one large, general-purpose interface, design multiple smaller, specific interfaces. Each interface should cater to a specific aspect of the functionality.</li>
<li><strong class="bold">User-centric design</strong>: Consider the needs of the end users of your API. Design interfaces that are intuitive and provide only methods they need for their tasks, avoiding unnecessary complexity.</li>
<li><strong class="bold">Reduced client impact</strong>: Smaller, focused interfaces minimize the impact on clients when changes are necessary. Clients using a specific interface are less likely to be affected by changes in unrelated functionality.</li>
</ul>
<p>Let us <a id="_idIndexMarker375"/>consider an example where a complex API class is responsible for various features, such as loading, processing, and saving data:</p>
<pre class="source-code">
class ComplexAPI {
public:
    void initialize();
    void load_data_from_file(const std::string&amp; filePath);
    void load_data_from_database(const std::string&amp; connection_string);
    void process_data(int mode);
    void save_data_to_file(const std::string&amp; filePath);
    void save_data_to_database(const std::string&amp; connection_string);
    void cleanup();
};</pre>
<p>The major issue is that the class has too many responsibilities, mixing different data sources and sinks, leading to complexity and lack of focus. Let us start with extracting the loading and processing functionalities into separate classes:</p>
<pre class="source-code">
class FileDataLoader {
public:
    explicit FileDataLoader(const std::string&amp; filePath) : filePath(filePath) {}
    void load() {
        // Code to load data from a file
    }
private:
    std::string filePath;
};
class DatabaseDataLoader {
public:
    explicit DatabaseDataLoader(const std::string&amp; connection_string) : _connection_string(connection_string) {}
    void load() {
        // Code to load data from a database
    }
private:
    std::string _connection_string;
};
class DataProcessor {
public:
    void process(int mode) {
        // Code to process data based on the mode
    }
};</pre>
<p>The next step is <a id="_idIndexMarker376"/>to extract the saving functionalities into separate classes:</p>
<pre class="source-code">
class DataSaver {
public:
    virtual void save() = 0;
    virtual ~DataSaver() = default;
};
class FileDataSaver : public DataSaver {
public:
    explicit FileDataSaver(const std::string&amp; filePath) : filePath(filePath) {}
    void save() override {
        // Code to save data to a file
    }
private:
    std::string filePath;
};
class DatabaseDataSaver : public DataSaver {
public:
    explicit DatabaseDataSaver(const std::string&amp; connection_string) : _connection_string(connection_string) {}
    void save() override {
        // Code to save data to a database
    }
private:
    std::string _connection_string;
};</pre>
<p>Minimizing the <a id="_idIndexMarker377"/>number of dependencies required by the API is crucial for achieving minimalism. Fewer dependencies lead to a more stable, reliable, and maintainable API. Dependencies can complicate integration, increase the risk of compatibility issues, and make the API harder to understand.</p>
<p>Key strategies for reducing dependencies include the following:</p>
<ul>
<li><strong class="bold">Core functionality focus</strong>: Concentrate on implementing core functionalities within the API itself, avoiding reliance on external libraries or components unless absolutely necessary.</li>
<li><strong class="bold">Selective use of libraries</strong>: When external libraries are required, choose those that are stable, well maintained, and widely used. Ensure that they align closely with the needs of your API.</li>
<li><strong class="bold">Decoupled design</strong>: Design the API in a way that it can function independently of external <a id="_idIndexMarker378"/>components as much as possible. Use <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) or other design patterns to decouple the implementation from specific dependencies.</li>
<li><strong class="bold">Version management</strong>: Carefully manage and specify versions of any dependencies to avoid compatibility issues. Ensure that updates to dependencies do not break the API or introduce instability.</li>
</ul>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Real-world examples of minimalistic API design</h1>
<p>To solidify <a id="_idIndexMarker379"/>our understanding of these concepts, we will examine a few real-world examples of API design in C++. These examples will highlight common challenges and effective solutions, demonstrating how to apply the principles of good API design in practical scenarios. Through these examples, we aim to provide clear, actionable insights that you can apply to your own projects, ensuring that your APIs are not only functional but also elegant and maintainable. Let’s dive into the intricacies of real-world API design and see how these principles come to life in practice:</p>
<ul>
<li><strong class="bold">JSON for Modern C++ (nlohmann/json)</strong>: This<a id="_idIndexMarker380"/> library is an excellent example of minimalistic API design. It provides intuitive and straightforward methods for <a id="_idIndexMarker381"/>parsing, serializing, and manipulating JSON data in C++ and has the following benefits:<ul><li><strong class="bold">Simplicity</strong>: Clear and concise interface that is easy to use.</li><li><strong class="bold">Functional decomposition</strong>: Each function handles a specific task related to JSON processing.</li><li><strong class="bold">Minimal dependencies</strong>: Designed to work with the C++ Standard Library, avoiding unnecessary external dependencies:<pre class="source-code">
#include &lt;nlohmann/json.hpp&gt;</pre><pre class="source-code">
nlohmann::json j = {</pre><pre class="source-code">
    {"pi", 3.141},</pre><pre class="source-code">
    {"happy", true},</pre><pre class="source-code">
    {"name", "Niels"},</pre><pre class="source-code">
    {"nothing", nullptr},</pre><pre class="source-code">
    {"answer", {</pre><pre class="source-code">
        {"everything", 42}</pre><pre class="source-code">
    }},</pre><pre class="source-code">
    {"list", {1, 0, 2}},</pre><pre class="source-code">
    {"object", {</pre><pre class="source-code">
        {"currency", "USD"},</pre><pre class="source-code">
        {"value", 42.99}</pre><pre class="source-code">
    }}</pre><pre class="source-code">
};</pre></li></ul></li>
<li><strong class="bold">SQLite C++ Interface (SQLiteCpp)</strong>: This library offers a minimalistic interface<a id="_idIndexMarker382"/> for<a id="_idIndexMarker383"/> interacting with SQLite databases in C++. It has the following benefits:<ul><li><strong class="bold">Simplicity</strong>: Provides a straightforward and clear API for database operations.</li><li><strong class="bold">Interface segregation</strong>: Separate classes for different database operations such as queries and transactions.</li><li><strong class="bold">Minimal dependencies</strong>: Built to use SQLite and the C++ Standard Library:<pre class="source-code">
#include &lt;SQLiteCpp/SQLiteCpp.h&gt;</pre><pre class="source-code">
SQLite::Database db("test.db", SQLite::OPEN_READWRITE|SQLite::OPEN_CREATE);</pre><pre class="source-code">
db.exec("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)");</pre><pre class="source-code">
SQLite::Statement query(db, "INSERT INTO test (value) VALUES (?)");</pre><pre class="source-code">
query.bind(1, "Sample value");</pre><pre class="source-code">
query.exec();</pre></li></ul></li>
</ul>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Common pitfalls and how to avoid them</h1>
<p>Overcomplication<a id="_idIndexMarker384"/> occurs when the API design includes unnecessary features or complexity, making it difficult to use and maintain. Here’s how to mitigate this:</p>
<ul>
<li><strong class="bold">Avoidance strategy</strong>: Focus on core functionalities required by the end users. Regularly review the API design to eliminate any unnecessary features.</li>
</ul>
<p>Feature creep <a id="_idIndexMarker385"/>happens when additional features are continually added to the API, leading to increased complexity and reduced usability. Here’s how you can avoid this:</p>
<ul>
<li><strong class="bold">Avoidance strategy</strong>: Implement a strict feature prioritization process. Ensure that new features are aligned with the core purpose of the API and are necessary for the target users.</li>
</ul>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Important caveats of developing shared libraries in C++</h1>
<p>Developing <a id="_idIndexMarker386"/>shared libraries in C++ requires careful consideration to ensure compatibility, stability, and usability. Originally, shared libraries were intended to promote code reuse, modularity, and efficient memory usage, allowing multiple programs to use the same library code simultaneously. This approach was expected to reduce redundancy, save system resources, and provide the ability to replace only parts of applications. While this approach worked well for widely used libraries, such as <code>libc</code>, <code>libstdc++</code>, OpenSSL, and others, it proved to be less efficient for applications. Shared libraries provided with an application can rarely be spotlessly replaced with a newer version. Usually, it is required to replace the whole installation kit, which includes the application and all its dependencies.</p>
<p>Nowadays, shared libraries are often used to enable interoperability between different programming languages. For instance, a C++ library might be used in applications written in Java or Python. This cross-language functionality extends the usability and reach of the library but introduces certain complexities and caveats that developers must consider.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Shared libraries within a single project</h2>
<p>If the<a id="_idIndexMarker387"/> shared library is designed to be used within a single project and loaded by an executable compiled with the same compiler, then shared objects (or DLLs) with C++ interfaces are generally acceptable. However, this approach comes with caveats, such as the use of singletons, which can lead to issues with multithreading and unexpected initialization order. When singletons are used, managing<a id="_idIndexMarker388"/> their initialization and destruction in a multithreaded environment can be challenging, leading to potential race conditions and unpredictable behavior. Additionally, ensuring the correct order of initialization and destruction of global state is complex, which can result in subtle and hard-to-diagnose bugs.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Shared libraries for wider distribution</h2>
<p>If the<a id="_idIndexMarker389"/> shared library is expected to be distributed more widely, where the developers cannot predict the compiler used by the end users or if the library might be used from other programming languages, then C++ shared libraries are not an ideal choice. This is primarily because the C++ <code>libc</code> or operating system syscalls, which are also in C. A common solution to this problem is to develop a C wrapper around the C++ code and ship the C interface.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Example – MessageSender class</h2>
<p>Next is an<a id="_idIndexMarker391"/> example demonstrating<a id="_idIndexMarker392"/> this approach, where we create a C++ <code>MessageSender</code> class and provide a C wrapper for it. The class has a constructor that initializes a <code>MessageSender</code> instance with a specified receiver and two overloaded <code>send</code> methods that allow sending messages either as a <code>std::vector&lt;uint8_t&gt;</code> instance or as a raw pointer with a specified length. The implementation prints messages to the console to demonstrate functionality.</p>
<p>Here’s the C++ library implementation:</p>
<pre class="source-code">
// MessageSender.hpp
#pragma once
#include &lt;string&gt;
#include &lt;vector&gt;
class MessageSender {
public:
    MessageSender(const std::string&amp; receiver);
    void send(const std::vector&lt;uint8_t&gt;&amp; message) const;
    void send(const uint8_t* message, size_t length) const;
};
// MessageSender.cpp
#include "MessageSender.h"
#include &lt;iostream&gt;
MessageSender::MessageSender(const std::string&amp; receiver) {
    std::cout &lt;&lt; "MessageSender created for receiver: " &lt;&lt; receiver &lt;&lt; std::endl;
}
void MessageSender::send(const std::vector&lt;uint8_t&gt;&amp; message) const {
    std::cout &lt;&lt; "Sending message of size: " &lt;&lt; message.size() &lt;&lt; std::endl;
}
void MessageSender::send(const uint8_t* message, size_t length) const {
    std::cout &lt;&lt; "Sending message of length: " &lt;&lt; length &lt;&lt; std::endl;
}</pre>
<p>Here’s<a id="_idIndexMarker393"/> the <a id="_idIndexMarker394"/>C wrapper implementation:</p>
<pre class="source-code">
// MessageSender.h (C Wrapper Header)
#ifdef __cplusplus
extern "C" {
#endif
typedef void* MessageSenderHandle;
MessageSenderHandle create_message_sender(const char* receiver);
void destroy_message_sender(MessageSenderHandle handle);
void send_message(MessageSenderHandle handle, const uint8_t* message, size_t length);
#ifdef __cplusplus
}
#endif
// MessageSenderC.cpp (C Wrapper Implementation)
#include "MessageSenderC.h"
#include "MessageSender.hpp"
MessageSenderHandle create_message_sender(const char* receiver) {
    return new(std::nothrow) MessageSender(receiver);
}
void destroy_message_sender(MessageSenderHandle handle) {
    MessageSender* instance = reinterpret_cast&lt;MessageSender*&gt;(handle);
    assert(instance);
    delete instance;
}
void send_message(MessageSenderHandle handle, const uint8_t* message, size_t length) {
    MessageSender* instance = reinterpret_cast&lt;MessageSender*&gt;(handle);
    assert(instance);
    instance-&gt;send(message, length);
}</pre>
<p>In this example, the C++ <code>MessageSender</code> class is defined in the <code>MessageSender.hpp</code> and <code>MessageSender.cpp</code> files. The class has a constructor that initializes a <code>MessageSender</code> instance with a specified receiver and two overloaded <code>send</code> methods that allow sending messages either as a <code>std::vector&lt;uint8_t&gt;</code> instance or as a raw pointer with a specified length. The implementation prints messages to the console to demonstrate functionality.</p>
<p>To make<a id="_idIndexMarker395"/> this C++ class usable from <a id="_idIndexMarker396"/>other programming languages or with different compilers, we create a C wrapper. The C wrapper is defined in the <code>MessageSender.h</code> and <code>MessageSenderC.cpp</code> files. The header file uses an <code>extern "C"</code> block to ensure that the C++ functions are callable from C, preventing name mangling. The C wrapper uses an opaque handle, <code>void*</code> (typedef as <code>MessageSenderHandle</code>), to represent the <code>MessageSender</code> instance in C, abstracting the actual C++ class.</p>
<p>The <code>create_message_sender</code> function allocates and initializes a <code>MessageSender</code> instance and returns a handle to it. Note that it uses <code>new(std::nothrow)</code> to avoid throwing exceptions in case of memory allocation failure. C or any other programming language that does not support exceptions can still use this function without issues.</p>
<p>The <code>destroy_message_sender</code> function deallocates the <code>MessageSender</code> instance to ensure proper cleanup. The <code>send_message</code> function calls the corresponding <code>send</code> method on the <code>MessageSender</code> instance using the handle, facilitating message sending.</p>
<p>By handling memory allocation and deallocation within the same binary, this approach avoids issues related to different memory allocators being used by the end user, which can lead to memory corruption or leaks. The C wrapper provides a stable and consistent interface that can be used across different compilers and languages, ensuring greater compatibility and stability. This method addresses the complexities of developing shared libraries and ensures their broad usability and reliability.</p>
<p>If the C++ library is expected to throw exceptions, it is important to handle them properly in C wrapper functions to prevent exceptions from propagating to the caller. For example, we can have the following exception types:</p>
<pre class="source-code">
class ConnectionError : public std::runtime_error {
public:
    ConnectionError(const std::string&amp; message) : std::runtime_error(message) {}
};
class SendError : public std::runtime_error {
public:
    SendError(const std::string&amp; message) : std::runtime_error(message) {}
};</pre>
<p>Then, the <a id="_idIndexMarker397"/>C wrapper functions can catch <a id="_idIndexMarker398"/>these exceptions and return appropriate error codes or messages to the caller:</p>
<pre class="source-code">
// MessageSender.h (C Wrapper Header)
typedef enum {
    OK,
    CONNECTION_ERROR,
    SEND_ERROR,
} MessageSenderStatus;
// MessageSenderC.cpp (C Wrapper Implementation)
MessageSenderStatus send_message(MessageSenderHandle handle, const uint8_t* message, size_t length) {
    try {
        MessageSender* instance = reinterpret_cast&lt;MessageSender*&gt;(handle);
        instance-&gt;send(message, length);
        return OK;
    } catch (const ConnectionError&amp;) {
        return CONNECTION_ERROR;
    } catch (const SendError&amp;) {
        return SEND_ERROR;
    } catch (...) {
       std::abort();
    }
}</pre>
<p>Note that<a id="_idIndexMarker399"/> we use <code>std::abort</code> in case of an unknown exception, as it is not safe to propagate unknown exceptions across language boundaries.</p>
<p>This <a id="_idIndexMarker400"/>example illustrates how to create a C wrapper around a C++ library to ensure compatibility and stability when developing shared libraries. By following these guidelines, developers can create robust, maintainable, and widely compatible shared libraries, ensuring their usability across various platforms and programming environments.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Summary</h1>
<p>In this chapter, we explored critical aspects of designing and developing shared libraries in C++. Shared libraries were initially conceived to promote code reuse, modularity, and efficient memory usage by allowing multiple programs to utilize the same library code simultaneously. This approach reduces redundancy and conserves system resources.</p>
<p>We delved into the nuances of developing shared libraries for different contexts. When the shared library is intended for use within a single project and compiled with the same compiler, shared objects (or DLLs) with C++ interfaces can be suitable, albeit with caution around singletons and global state to avoid multithreading issues and unpredictable initialization order.</p>
<p>However, for wider distribution where the end user’s compiler or programming language might differ, using C++ shared libraries directly is less advisable due to the instability of the C++ ABI across different compilers and versions. To overcome this, we discussed creating a C wrapper around the C++ code, leveraging the stable C ABI for broader compatibility and cross-language functionality.</p>
<p>We provided a comprehensive example using a <code>MessageSender</code> class, illustrating how to create a C++ library and its corresponding C wrapper. The example emphasized safe memory management by ensuring allocation and deallocation within the same binary and handling exceptions gracefully by representing them with an enumerated status in the C interface.</p>
<p>By following these guidelines, developers can create robust, maintainable, and widely compatible shared libraries, ensuring their usability across various platforms and programming environments. This chapter equips developers with the necessary knowledge to address common caveats and implement best practices in shared library development, fostering effective and reliable software solutions.</p>
<p>In the next chapter, we will shift our focus to code formatting, exploring best practices for creating clear, consistent, and readable code, which is essential for collaboration and long-term maintenance.</p>
</div>
</body></html>