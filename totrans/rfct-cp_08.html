<html><head></head><body>
<div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.2.1">Designing and Developing APIs in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the world of software development, the design of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">application programming interfaces</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">APIs</span></strong><span class="koboSpan" id="kobo.7.1">) is</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.8.1"> of paramount importance. </span><span class="koboSpan" id="kobo.8.2">Good APIs serve as the backbone of software libraries, facilitating interaction between different software components and enabling developers to leverage functionality efficiently and effectively. </span><span class="koboSpan" id="kobo.8.3">Well-designed APIs are intuitive, easy to use, and maintainable, playing a crucial role in the success and longevity of software projects. </span><span class="koboSpan" id="kobo.8.4">In this chapter, we will delve into principles and practices for designing maintainable APIs for libraries developed in C++. </span><span class="koboSpan" id="kobo.8.5">We will explore key aspects of API design, including clarity, consistency, and extensibility, and provide concrete examples to illustrate best practices. </span><span class="koboSpan" id="kobo.8.6">By understanding and applying these principles, you will be able to create APIs that not only meet the immediate needs of users but also remain robust and adaptable over time, ensuring that your libraries are both powerful </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">and user-friendly.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.10.1">Principles of minimalistic API design</span></h1>
<p><span class="koboSpan" id="kobo.11.1">Minimalistic APIs are </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.12.1">designed to provide only the essential functionalities required to perform specific tasks, avoiding unnecessary features and complexity. </span><span class="koboSpan" id="kobo.12.2">The primary goal is to offer a clean, efficient, and user-friendly interface that facilitates easy integration and usage. </span><span class="koboSpan" id="kobo.12.3">Key benefits </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.13.1">of minimalistic APIs include </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.15.1">Ease of use</span></strong><span class="koboSpan" id="kobo.16.1">: Users can quickly understand and utilize the API without extensive learning or documentation, promoting faster </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">development cycles</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.18.1">Maintainability</span></strong><span class="koboSpan" id="kobo.19.1">: Simplified APIs are easier to maintain, allowing for straightforward updates and bug fixes without introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">new complexities</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.21.1">Performance</span></strong><span class="koboSpan" id="kobo.22.1">: Leaner APIs tend to have better performance due to reduced overhead and more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">execution paths</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Reliability</span></strong><span class="koboSpan" id="kobo.25.1">: With fewer components and interactions, the likelihood of bugs and unexpected</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.26.1"> issues is minimized, leading to more reliable and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">stable software</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">Simplicity and</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.29.1"> clarity are fundamental principles in the design of minimalistic APIs. </span><span class="koboSpan" id="kobo.29.2">These principles ensure that the API remains accessible and user-friendly, enhancing the overall developer experience. </span><span class="koboSpan" id="kobo.29.3">Key aspects of simplicity and clarity include </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Straightforward interfaces</span></strong><span class="koboSpan" id="kobo.32.1">: Designing simple and clear interfaces helps developers quickly grasp the available functionalities, making it easier to integrate and use the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">API effectively</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Reduced cognitive load</span></strong><span class="koboSpan" id="kobo.35.1">: By minimizing the mental effort required to understand and use the API, developers are less likely to make mistakes, leading to more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">development processes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Intuitive design</span></strong><span class="koboSpan" id="kobo.38.1">: An API that adheres to simplicity and clarity aligns closely with common usage patterns and developer expectations, making it more intuitive and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">to adopt</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">Overengineering and unnecessary complexity can severely undermine the effectiveness of an API. </span><span class="koboSpan" id="kobo.40.2">To avoid these pitfalls, consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">following strategies:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Focus on core functionality</span></strong><span class="koboSpan" id="kobo.43.1">: Concentrate on delivering essential features that address the primary use cases. </span><span class="koboSpan" id="kobo.43.2">Avoid adding extraneous features that are not directly aligned with the core purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the API.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Iterative design</span></strong><span class="koboSpan" id="kobo.46.1">: Begin with</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.47.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">minimum viable product</span></strong><span class="koboSpan" id="kobo.49.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.50.1">MVP</span></strong><span class="koboSpan" id="kobo.51.1">) and incrementally add features based on user feedback and actual needs rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">speculative requirements.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Clear documentation</span></strong><span class="koboSpan" id="kobo.54.1">: Provide comprehensive yet concise documentation that focuses on core functionality and common use cases. </span><span class="koboSpan" id="kobo.54.2">This helps prevent confusion </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">and misuse.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Consistent naming conventions</span></strong><span class="koboSpan" id="kobo.57.1">: Use consistent and descriptive names for functions, classes, and parameters to enhance clarity </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">and predictability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Minimal dependencies</span></strong><span class="koboSpan" id="kobo.60.1">: Reduce the number of external dependencies to simplify the integration process and minimize potential </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">compatibility issues.</span></span></li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.62.1">Techniques for achieving minimalism</span></h1>
<p><span class="koboSpan" id="kobo.63.1">Functional </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.64.1">decomposition is the process of breaking down complex functionalities into smaller, more manageable units. </span><span class="koboSpan" id="kobo.64.2">This technique is crucial for creating minimalistic APIs as it promotes simplicity and modularity. </span><span class="koboSpan" id="kobo.64.3">By decomposing functions, you ensure that each part of the API has a clear, well-defined purpose, which enhances maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">and usability.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Key aspects of functional decomposition include </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Modular design</span></strong><span class="koboSpan" id="kobo.69.1">: Design the API such that each module or function handles a specific aspect of the overall functionality. </span><span class="koboSpan" id="kobo.69.2">This </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">separation of concerns</span></strong><span class="koboSpan" id="kobo.71.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.72.1">SoC</span></strong><span class="koboSpan" id="kobo.73.1">) ensures that each </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.74.1">part of the API has a clear, </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">well-defined purpose.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Single Responsibility Principle (SRP)</span></strong><span class="koboSpan" id="kobo.77.1">: Each function or class should have one, and only one, reason to change. </span><span class="koboSpan" id="kobo.77.2">This principle helps in keeping the API simple </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">and focused.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Reusable components</span></strong><span class="koboSpan" id="kobo.80.1">: By decomposing functions into smaller units, you can create reusable components that can be combined in different ways to achieve various tasks, enhancing the flexibility and reusability of </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the API.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.82.1">Interface segregation aims to keep interfaces lean and focused on specific tasks, avoiding the design of monolithic interfaces that try to cover too many use cases. </span><span class="koboSpan" id="kobo.82.2">This principle ensures that clients only need to know about the methods that are relevant to them, making the API easier to use </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">and understand.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Key aspects of interface segregation include </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.86.1">Specific interfaces</span></strong><span class="koboSpan" id="kobo.87.1">: Instead of one large, general-purpose interface, design multiple smaller, specific interfaces. </span><span class="koboSpan" id="kobo.87.2">Each interface should cater to a specific aspect of </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">the functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">User-centric design</span></strong><span class="koboSpan" id="kobo.90.1">: Consider the needs of the end users of your API. </span><span class="koboSpan" id="kobo.90.2">Design interfaces that are intuitive and provide only methods they need for their tasks, avoiding </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">unnecessary complexity.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.92.1">Reduced client impact</span></strong><span class="koboSpan" id="kobo.93.1">: Smaller, focused interfaces minimize the impact on clients when changes are necessary. </span><span class="koboSpan" id="kobo.93.2">Clients using a specific interface are less likely to be affected by changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">unrelated functionality.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.95.1">Let us </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.96.1">consider an example where a complex API class is responsible for various features, such as loading, processing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">saving data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
class ComplexAPI {
public:
    void initialize();
    void load_data_from_file(const std::string&amp; filePath);
    void load_data_from_database(const std::string&amp; connection_string);
    void process_data(int mode);
    void save_data_to_file(const std::string&amp; filePath);
    void save_data_to_database(const std::string&amp; connection_string);
    void cleanup();
};</span></pre>
<p><span class="koboSpan" id="kobo.99.1">The major issue is that the class has too many responsibilities, mixing different data sources and sinks, leading to complexity and lack of focus. </span><span class="koboSpan" id="kobo.99.2">Let us start with extracting the loading and processing functionalities into </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">separate classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
class FileDataLoader {
public:
    explicit FileDataLoader(const std::string&amp; filePath) : filePath(filePath) {}
    void load() {
        // Code to load data from a file
    }
private:
    std::string filePath;
};
class DatabaseDataLoader {
public:
    explicit DatabaseDataLoader(const std::string&amp; connection_string) : _connection_string(connection_string) {}
    void load() {
        // Code to load data from a database
    }
private:
    std::string _connection_string;
};
class DataProcessor {
public:
    void process(int mode) {
        // Code to process data based on the mode
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.102.1">The next step is </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.103.1">to extract the saving functionalities into </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">separate classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
class DataSaver {
public:
    virtual void save() = 0;
    virtual ~DataSaver() = default;
};
class FileDataSaver : public DataSaver {
public:
    explicit FileDataSaver(const std::string&amp; filePath) : filePath(filePath) {}
    void save() override {
        // Code to save data to a file
    }
private:
    std::string filePath;
};
class DatabaseDataSaver : public DataSaver {
public:
    explicit DatabaseDataSaver(const std::string&amp; connection_string) : _connection_string(connection_string) {}
    void save() override {
        // Code to save data to a database
    }
private:
    std::string _connection_string;
};</span></pre>
<p><span class="koboSpan" id="kobo.106.1">Minimizing the </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.107.1">number of dependencies required by the API is crucial for achieving minimalism. </span><span class="koboSpan" id="kobo.107.2">Fewer dependencies lead to a more stable, reliable, and maintainable API. </span><span class="koboSpan" id="kobo.107.3">Dependencies can complicate integration, increase the risk of compatibility issues, and make the API harder </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Key strategies for reducing dependencies include </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">Core functionality focus</span></strong><span class="koboSpan" id="kobo.112.1">: Concentrate on implementing core functionalities within the API itself, avoiding reliance on external libraries or components unless </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">absolutely necessary.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">Selective use of libraries</span></strong><span class="koboSpan" id="kobo.115.1">: When external libraries are required, choose those that are stable, well maintained, and widely used. </span><span class="koboSpan" id="kobo.115.2">Ensure that they align closely with the needs of </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">your API.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Decoupled design</span></strong><span class="koboSpan" id="kobo.118.1">: Design the API in a way that it can function independently of external </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.119.1">components as much as possible. </span><span class="koboSpan" id="kobo.119.2">Use </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">dependency injection</span></strong><span class="koboSpan" id="kobo.121.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.122.1">DI</span></strong><span class="koboSpan" id="kobo.123.1">) or other design patterns to decouple the implementation from </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">specific dependencies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.125.1">Version management</span></strong><span class="koboSpan" id="kobo.126.1">: Carefully manage and specify versions of any dependencies to avoid compatibility issues. </span><span class="koboSpan" id="kobo.126.2">Ensure that updates to dependencies do not break the API or </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">introduce instability.</span></span></li>
</ul>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.128.1">Real-world examples of minimalistic API design</span></h1>
<p><span class="koboSpan" id="kobo.129.1">To solidify </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.130.1">our understanding of these concepts, we will examine a few real-world examples of API design in C++. </span><span class="koboSpan" id="kobo.130.2">These examples will highlight common challenges and effective solutions, demonstrating how to apply the principles of good API design in practical scenarios. </span><span class="koboSpan" id="kobo.130.3">Through these examples, we aim to provide clear, actionable insights that you can apply to your own projects, ensuring that your APIs are not only functional but also elegant and maintainable. </span><span class="koboSpan" id="kobo.130.4">Let’s dive into the intricacies of real-world API design and see how these principles come to life </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">in practice:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">JSON for Modern C++ (nlohmann/json)</span></strong><span class="koboSpan" id="kobo.133.1">: This</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.134.1"> library is an excellent example of minimalistic API design. </span><span class="koboSpan" id="kobo.134.2">It provides intuitive and straightforward methods for </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.135.1">parsing, serializing, and manipulating JSON data in C++ and has the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">following benefits:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Simplicity</span></strong><span class="koboSpan" id="kobo.138.1">: Clear and concise interface that is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">to use.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.140.1">Functional decomposition</span></strong><span class="koboSpan" id="kobo.141.1">: Each function handles a specific task related to </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">JSON processing.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.143.1">Minimal dependencies</span></strong><span class="koboSpan" id="kobo.144.1">: Designed to work with the C++ Standard Library, avoiding unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">external dependencies:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.146.1">
#include &lt;nlohmann/json.hpp&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.147.1">
nlohmann::json j = {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.148.1">
    {"pi", 3.141},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.149.1">
    {"happy", true},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.150.1">
    {"name", "Niels"},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.151.1">
    {"nothing", nullptr},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.152.1">
    {"answer", {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.153.1">
        {"everything", 42}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
    }},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
    {"list", {1, 0, 2}},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
    {"object", {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
        {"currency", "USD"},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.158.1">
        {"value", 42.99}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.159.1">
    }}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
};</span></pre></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">SQLite C++ Interface (SQLiteCpp)</span></strong><span class="koboSpan" id="kobo.162.1">: This library offers a minimalistic interface</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.163.1"> for</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.164.1"> interacting with SQLite databases in C++. </span><span class="koboSpan" id="kobo.164.2">It has the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">following benefits:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.166.1">Simplicity</span></strong><span class="koboSpan" id="kobo.167.1">: Provides a straightforward and clear API for </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">database operations.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.169.1">Interface segregation</span></strong><span class="koboSpan" id="kobo.170.1">: Separate classes for different database operations such as queries </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">and transactions.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Minimal dependencies</span></strong><span class="koboSpan" id="kobo.173.1">: Built to use SQLite and the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">Standard Library:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.175.1">
#include &lt;SQLiteCpp/SQLiteCpp.h&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.176.1">
SQLite::Database db("test.db", SQLite::OPEN_READWRITE|SQLite::OPEN_CREATE);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.177.1">
db.exec("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.178.1">
SQLite::Statement query(db, "INSERT INTO test (value) VALUES (?)");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.179.1">
query.bind(1, "Sample value");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.180.1">
query.exec();</span></pre></li></ul></li>
</ul>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.181.1">Common pitfalls and how to avoid them</span></h1>
<p><span class="koboSpan" id="kobo.182.1">Overcomplication</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.183.1"> occurs when the API design includes unnecessary features or complexity, making it difficult to use and maintain. </span><span class="koboSpan" id="kobo.183.2">Here’s how to </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">mitigate this:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.185.1">Avoidance strategy</span></strong><span class="koboSpan" id="kobo.186.1">: Focus on core functionalities required by the end users. </span><span class="koboSpan" id="kobo.186.2">Regularly review the API design to eliminate any </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">unnecessary features.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.188.1">Feature creep </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.189.1">happens when additional features are continually added to the API, leading to increased complexity and reduced usability. </span><span class="koboSpan" id="kobo.189.2">Here’s how you can </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">avoid this:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Avoidance strategy</span></strong><span class="koboSpan" id="kobo.192.1">: Implement a strict feature prioritization process. </span><span class="koboSpan" id="kobo.192.2">Ensure that new features are aligned with the core purpose of the API and are necessary for the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">target users.</span></span></li>
</ul>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.194.1">Important caveats of developing shared libraries in C++</span></h1>
<p><span class="koboSpan" id="kobo.195.1">Developing </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.196.1">shared libraries in C++ requires careful consideration to ensure compatibility, stability, and usability. </span><span class="koboSpan" id="kobo.196.2">Originally, shared libraries were intended to promote code reuse, modularity, and efficient memory usage, allowing multiple programs to use the same library code simultaneously. </span><span class="koboSpan" id="kobo.196.3">This approach was expected to reduce redundancy, save system resources, and provide the ability to replace only parts of applications. </span><span class="koboSpan" id="kobo.196.4">While this approach worked well for widely used libraries, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">libc</span></strong><span class="koboSpan" id="kobo.198.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">libstdc++</span></strong><span class="koboSpan" id="kobo.200.1">, OpenSSL, and others, it proved to be less efficient for applications. </span><span class="koboSpan" id="kobo.200.2">Shared libraries provided with an application can rarely be spotlessly replaced with a newer version. </span><span class="koboSpan" id="kobo.200.3">Usually, it is required to replace the whole installation kit, which includes the application and all </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">Nowadays, shared libraries are often used to enable interoperability between different programming languages. </span><span class="koboSpan" id="kobo.202.2">For instance, a C++ library might be used in applications written in Java or Python. </span><span class="koboSpan" id="kobo.202.3">This cross-language functionality extends the usability and reach of the library but introduces certain complexities and caveats that developers </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">must consider.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.204.1">Shared libraries within a single project</span></h2>
<p><span class="koboSpan" id="kobo.205.1">If the</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.206.1"> shared library is designed to be used within a single project and loaded by an executable compiled with the same compiler, then shared objects (or DLLs) with C++ interfaces are generally acceptable. </span><span class="koboSpan" id="kobo.206.2">However, this approach comes with caveats, such as the use of singletons, which can lead to issues with multithreading and unexpected initialization order. </span><span class="koboSpan" id="kobo.206.3">When singletons are used, managing</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.207.1"> their initialization and destruction in a multithreaded environment can be challenging, leading to potential race conditions and unpredictable behavior. </span><span class="koboSpan" id="kobo.207.2">Additionally, ensuring the correct order of initialization and destruction of global state is complex, which can result in subtle and </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">hard-to-diagnose bugs.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.209.1">Shared libraries for wider distribution</span></h2>
<p><span class="koboSpan" id="kobo.210.1">If the</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.211.1"> shared library is expected to be distributed more widely, where the developers cannot predict the compiler used by the end users or if the library might be used from other programming languages, then C++ shared libraries are not an ideal choice. </span><span class="koboSpan" id="kobo.211.2">This is primarily because the C++ </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">Application Binary Interface</span></strong><span class="koboSpan" id="kobo.213.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.214.1">ABI</span></strong><span class="koboSpan" id="kobo.215.1">) is </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.216.1">not stable across different compilers or even different versions of the same compiler. </span><span class="koboSpan" id="kobo.216.2">C++ ABI instability arises from the complexity of the language, evolving standards, platform-specific variations, compiler optimizations, and differences in runtime and standard library implementations. </span><span class="koboSpan" id="kobo.216.3">This instability can lead to binary compatibility issues, making it challenging to distribute shared libraries and increasing maintenance overhead. </span><span class="koboSpan" id="kobo.216.4">For instance, C++ templates and inline functions are instantiated in every translation unit where they are used, leading to potential differences across compilers or compiler versions. </span><span class="koboSpan" id="kobo.216.5">Changes in C++ standards and compiler updates can also alter the ABI. </span><span class="koboSpan" id="kobo.216.6">Different operating systems and hardware platforms may have their own calling conventions and binary formats, adding to the complexity. </span><span class="koboSpan" id="kobo.216.7">Compiler optimizations can vary, and the implementation of the C++ Standard Library differs across compilers and platforms, further contributing to ABI incompatibilities. </span><span class="koboSpan" id="kobo.216.8">These issues can cause crashes or undefined behavior when modules compiled with different compilers or versions interact, necessitating careful versioning and management of libraries. </span><span class="koboSpan" id="kobo.216.9">One effective way to mitigate ABI instability is to use C interfaces, as the C ABI is much more stable. </span><span class="koboSpan" id="kobo.216.10">Despite not being formally standardized, the C ABI serves as a de facto standard glue between programming languages since all languages essentially need to support C interfaces to communicate with </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">libc</span></strong><span class="koboSpan" id="kobo.218.1"> or operating system syscalls, which are also in C. </span><span class="koboSpan" id="kobo.218.2">A common solution to this problem is to develop a C wrapper around the C++ code and ship the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">C interface.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.220.1">Example – MessageSender class</span></h2>
<p><span class="koboSpan" id="kobo.221.1">Next is an</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.222.1"> example demonstrating</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.223.1"> this approach, where we create a C++ </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">MessageSender</span></strong><span class="koboSpan" id="kobo.225.1"> class and provide a C wrapper for it. </span><span class="koboSpan" id="kobo.225.2">The class has a constructor that initializes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">MessageSender</span></strong><span class="koboSpan" id="kobo.227.1"> instance with a specified receiver and two overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">send</span></strong><span class="koboSpan" id="kobo.229.1"> methods that allow sending messages either as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">std::vector&lt;uint8_t&gt;</span></strong><span class="koboSpan" id="kobo.231.1"> instance or as a raw pointer with a specified length. </span><span class="koboSpan" id="kobo.231.2">The implementation prints messages to the console to </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">demonstrate functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Here’s the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">library implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
// MessageSender.hpp
#pragma once
#include &lt;string&gt;
#include &lt;vector&gt;
class MessageSender {
public:
    MessageSender(const std::string&amp; receiver);
    void send(const std::vector&lt;uint8_t&gt;&amp; message) const;
    void send(const uint8_t* message, size_t length) const;
};
// MessageSender.cpp
#include "MessageSender.h"
#include &lt;iostream&gt;
MessageSender::MessageSender(const std::string&amp; receiver) {
    std::cout &lt;&lt; "MessageSender created for receiver: " &lt;&lt; receiver &lt;&lt; std::endl;
}
void MessageSender::send(const std::vector&lt;uint8_t&gt;&amp; message) const {
    std::cout &lt;&lt; "Sending message of size: " &lt;&lt; message.size() &lt;&lt; std::endl;
}
void MessageSender::send(const uint8_t* message, size_t length) const {
    std::cout &lt;&lt; "Sending message of length: " &lt;&lt; length &lt;&lt; std::endl;
}</span></pre>
<p><span class="koboSpan" id="kobo.236.1">Here’s</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.237.1"> the </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.238.1">C </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">wrapper implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
// MessageSender.h (C Wrapper Header)
#ifdef __cplusplus
extern "C" {
#endif
typedef void* MessageSenderHandle;
MessageSenderHandle create_message_sender(const char* receiver);
void destroy_message_sender(MessageSenderHandle handle);
void send_message(MessageSenderHandle handle, const uint8_t* message, size_t length);
#ifdef __cplusplus
}
#endif
// MessageSenderC.cpp (C Wrapper Implementation)
#include "MessageSenderC.h"
#include "MessageSender.hpp"
MessageSenderHandle create_message_sender(const char* receiver) {
    return new(std::nothrow) MessageSender(receiver);
}
void destroy_message_sender(MessageSenderHandle handle) {
    MessageSender* instance = reinterpret_cast&lt;MessageSender*&gt;(handle);
    assert(instance);
    delete instance;
}
void send_message(MessageSenderHandle handle, const uint8_t* message, size_t length) {
    MessageSender* instance = reinterpret_cast&lt;MessageSender*&gt;(handle);
    assert(instance);
    instance-&gt;send(message, length);
}</span></pre>
<p><span class="koboSpan" id="kobo.241.1">In this example, the C++ </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">MessageSender</span></strong><span class="koboSpan" id="kobo.243.1"> class is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">MessageSender.hpp</span></strong><span class="koboSpan" id="kobo.245.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">MessageSender.cpp</span></strong><span class="koboSpan" id="kobo.247.1"> files. </span><span class="koboSpan" id="kobo.247.2">The class has a constructor that initializes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">MessageSender</span></strong><span class="koboSpan" id="kobo.249.1"> instance with a specified receiver and two overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">send</span></strong><span class="koboSpan" id="kobo.251.1"> methods that allow sending messages either as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">std::vector&lt;uint8_t&gt;</span></strong><span class="koboSpan" id="kobo.253.1"> instance or as a raw pointer with a specified length. </span><span class="koboSpan" id="kobo.253.2">The implementation prints messages to the console to </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">demonstrate functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">To make</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.256.1"> this C++ class usable from </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.257.1">other programming languages or with different compilers, we create a C wrapper. </span><span class="koboSpan" id="kobo.257.2">The C wrapper is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">MessageSender.h</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">MessageSenderC.cpp</span></strong><span class="koboSpan" id="kobo.261.1"> files. </span><span class="koboSpan" id="kobo.261.2">The header file uses an </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">extern "C"</span></strong><span class="koboSpan" id="kobo.263.1"> block to ensure that the C++ functions are callable from C, preventing name mangling. </span><span class="koboSpan" id="kobo.263.2">The C wrapper uses an opaque handle, </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">void*</span></strong><span class="koboSpan" id="kobo.265.1"> (typedef as </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">MessageSenderHandle</span></strong><span class="koboSpan" id="kobo.267.1">), to represent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">MessageSender</span></strong><span class="koboSpan" id="kobo.269.1"> instance in C, abstracting the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">C++ class.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">create_message_sender</span></strong><span class="koboSpan" id="kobo.273.1"> function allocates and initializes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">MessageSender</span></strong><span class="koboSpan" id="kobo.275.1"> instance and returns a handle to it. </span><span class="koboSpan" id="kobo.275.2">Note that it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">new(std::nothrow)</span></strong><span class="koboSpan" id="kobo.277.1"> to avoid throwing exceptions in case of memory allocation failure. </span><span class="koboSpan" id="kobo.277.2">C or any other programming language that does not support exceptions can still use this function </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">without issues.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">destroy_message_sender</span></strong><span class="koboSpan" id="kobo.281.1"> function deallocates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">MessageSender</span></strong><span class="koboSpan" id="kobo.283.1"> instance to ensure proper cleanup. </span><span class="koboSpan" id="kobo.283.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">send_message</span></strong><span class="koboSpan" id="kobo.285.1"> function calls the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">send</span></strong><span class="koboSpan" id="kobo.287.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">MessageSender</span></strong><span class="koboSpan" id="kobo.289.1"> instance using the handle, facilitating </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">message sending.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">By handling memory allocation and deallocation within the same binary, this approach avoids issues related to different memory allocators being used by the end user, which can lead to memory corruption or leaks. </span><span class="koboSpan" id="kobo.291.2">The C wrapper provides a stable and consistent interface that can be used across different compilers and languages, ensuring greater compatibility and stability. </span><span class="koboSpan" id="kobo.291.3">This method addresses the complexities of developing shared libraries and ensures their broad usability </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">and reliability.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">If the C++ library is expected to throw exceptions, it is important to handle them properly in C wrapper functions to prevent exceptions from propagating to the caller. </span><span class="koboSpan" id="kobo.293.2">For example, we can have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">exception types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
class ConnectionError : public std::runtime_error {
public:
    ConnectionError(const std::string&amp; message) : std::runtime_error(message) {}
};
class SendError : public std::runtime_error {
public:
    SendError(const std::string&amp; message) : std::runtime_error(message) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.296.1">Then, the </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.297.1">C wrapper functions can catch </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.298.1">these exceptions and return appropriate error codes or messages to </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the caller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
// MessageSender.h (C Wrapper Header)
typedef enum {
    OK,
    CONNECTION_ERROR,
    SEND_ERROR,
} MessageSenderStatus;
// MessageSenderC.cpp (C Wrapper Implementation)
MessageSenderStatus send_message(MessageSenderHandle handle, const uint8_t* message, size_t length) {
    try {
        MessageSender* instance = reinterpret_cast&lt;MessageSender*&gt;(handle);
        instance-&gt;send(message, length);
        return OK;
    } catch (const ConnectionError&amp;) {
        return CONNECTION_ERROR;
    } catch (const SendError&amp;) {
        return SEND_ERROR;
    } catch (...) {
       std::abort();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.301.1">Note that</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.302.1"> we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">std::abort</span></strong><span class="koboSpan" id="kobo.304.1"> in case of an unknown exception, as it is not safe to propagate unknown exceptions across </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">language boundaries.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">This </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.307.1">example illustrates how to create a C wrapper around a C++ library to ensure compatibility and stability when developing shared libraries. </span><span class="koboSpan" id="kobo.307.2">By following these guidelines, developers can create robust, maintainable, and widely compatible shared libraries, ensuring their usability across various platforms and </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">programming environments.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.309.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.310.1">In this chapter, we explored critical aspects of designing and developing shared libraries in C++. </span><span class="koboSpan" id="kobo.310.2">Shared libraries were initially conceived to promote code reuse, modularity, and efficient memory usage by allowing multiple programs to utilize the same library code simultaneously. </span><span class="koboSpan" id="kobo.310.3">This approach reduces redundancy and conserves </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">system resources.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">We delved into the nuances of developing shared libraries for different contexts. </span><span class="koboSpan" id="kobo.312.2">When the shared library is intended for use within a single project and compiled with the same compiler, shared objects (or DLLs) with C++ interfaces can be suitable, albeit with caution around singletons and global state to avoid multithreading issues and unpredictable </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">initialization order.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">However, for wider distribution where the end user’s compiler or programming language might differ, using C++ shared libraries directly is less advisable due to the instability of the C++ ABI across different compilers and versions. </span><span class="koboSpan" id="kobo.314.2">To overcome this, we discussed creating a C wrapper around the C++ code, leveraging the stable C ABI for broader compatibility and </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">cross-language functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">We provided a comprehensive example using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">MessageSender</span></strong><span class="koboSpan" id="kobo.318.1"> class, illustrating how to create a C++ library and its corresponding C wrapper. </span><span class="koboSpan" id="kobo.318.2">The example emphasized safe memory management by ensuring allocation and deallocation within the same binary and handling exceptions gracefully by representing them with an enumerated status in the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">C interface.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">By following these guidelines, developers can create robust, maintainable, and widely compatible shared libraries, ensuring their usability across various platforms and programming environments. </span><span class="koboSpan" id="kobo.320.2">This chapter equips developers with the necessary knowledge to address common caveats and implement best practices in shared library development, fostering effective and reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">software solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">In the next chapter, we will shift our focus to code formatting, exploring best practices for creating clear, consistent, and readable code, which is essential for collaboration and </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">long-term maintenance.</span></span></p>
</div>
</body></html>