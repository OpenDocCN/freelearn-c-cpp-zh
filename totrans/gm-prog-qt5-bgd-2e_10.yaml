- en: Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: In this chapter, you will learn how to bring scripting facilities to your programs.
    You will gain knowledge of how to use JavaScript to implement the logic and details
    of your game, without having to rebuild the main game engine. These skills will
    also be useful in the last part of the book when we work with Qt Quick. Although
    the environment we will focus on blends best with Qt applications, there are other
    options if you don't like JavaScript. We will also show how you can use Python
    to make your games scriptable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将脚本功能引入你的程序。你将了解如何使用JavaScript来实现游戏逻辑和细节，而无需重新构建主游戏引擎。这些技能在本书的最后一部分也将非常有用，当我们与Qt
    Quick一起工作时。尽管我们将关注的最佳环境与Qt应用程序相融合，但如果你不喜欢JavaScript，还有其他选择。我们还将展示如何使用Python使你的游戏可脚本化。
- en: 'The main topics covered in this chapter are as listed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Executing JavaScript code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行JavaScript代码
- en: Interaction between C++ and JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++与JavaScript之间的交互
- en: Implementing a scripting game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现脚本游戏
- en: Integrating the Python interpreter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Python解释器
- en: Why script?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用脚本？
- en: You might ask yourself, "why should I use any scripting language if I can implement
    everything I need in C++"? There are a number of benefits to providing a scripting
    environment to your games. Most modern games really consist of two parts. One
    is the main game engine that implements the core of the game (data structures,
    processing algorithms, and the rendering layer) and exposes an API to the other
    component, which provides details, behavior patterns, and action flows for the
    game. This other component is sometimes written in a scripting language. The main
    benefit of this is that story designers can work independently from the engine
    developers, and they don't have to rebuild the whole game just to modify some
    of its parameters or check whether the new quest fits well into the existing story.
    This makes the development much quicker compared to the monolithic approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“如果我可以使用C++实现所有需要的功能，为什么还要使用任何脚本语言”？为你的游戏提供脚本环境有许多好处。大多数现代游戏实际上由两部分组成。一部分是主游戏引擎，它实现了游戏的核心（数据结构、处理算法和渲染层），并向其他组件提供了一个API，该组件提供游戏的具体细节、行为模式和动作流程。这个其他组件有时是用脚本语言编写的。这种做法的主要好处是，故事设计师可以独立于引擎开发者工作，他们不需要重建整个游戏，只需修改一些参数或检查新的任务是否与现有故事很好地融合。这使得开发速度比单一方法快得多。
- en: Another benefit is that this development opens the game to modding—skilled end
    users can extend or modify the game to provide some added value to the game. It's
    also a way to implement extensions of the game on top of the existing scripting
    API without having to redeploy the complete game binary to every player. Finally,
    you can reuse the same game driver for other games and just replace the scripts
    to obtain a totally different product.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，这为游戏开启了模组化——熟练的最终用户可以扩展或修改游戏，为游戏提供一些附加价值。这也是在不重新部署整个游戏二进制文件到每个玩家的情况下，在现有的脚本API之上实现游戏扩展的一种方式。最后，你可以重用相同的游戏驱动程序为其他游戏服务，只需替换脚本即可获得一个完全不同的产品。
- en: In this chapter, we will use the Qt QML module to implement scripting. This
    module implements QML language used in Qt Quick. Since QML is JavaScript-based,
    Qt QML includes a JavaScript engine and provides API for running JavaScript code.
    It also allows you to expose C++ objects to JavaScript and vice versa.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Qt QML模块来实现脚本。此模块实现了Qt Quick中使用的QML语言。由于QML是基于JavaScript的，Qt QML包含一个JavaScript引擎，并提供运行JavaScript代码的API。它还允许你将C++对象暴露给JavaScript，反之亦然。
- en: We will not discuss the details of the JavaScript language itself, as there
    are many good books and websites available where you can learn JavaScript. Besides,
    the JavaScript syntax is very similar to that of C, and you shouldn't have any
    problems understanding the scripts that we use in this chapter even if you haven't
    seen any JavaScript code before.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会讨论JavaScript语言本身的细节，因为有许多优秀的书籍和网站可供学习JavaScript。此外，JavaScript的语法与C语言非常相似，即使你之前没有见过任何JavaScript代码，也应该没有问题理解我们在这章中使用的脚本。
- en: Evaluating JavaScript expressions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估JavaScript表达式
- en: To use Qt QML in your programs, you have to enable the script module for your
    projects by adding the `QT += qml` line to the project file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序中使用Qt QML，你必须通过在项目文件中添加`QT += qml`行来为你的项目启用脚本模块。
- en: 'C++ compilers do not understand JavaScript. Therefore, to execute any script,
    you need to have a running interpreter that will parse the script and evaluate
    it. In Qt, this is done with the `QJSEngine` class. This is a JavaScript runtime
    that handles the execution of script code and manages all the resources related
    to scripts. It provides the `evaluate()` method, which can be used to execute
    JavaScript expressions. Let''s look at a "Hello World" program using `QJSEngine`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器不理解JavaScript。因此，要执行任何脚本，你需要有一个正在运行的解释器，该解释器将解析脚本并评估它。在Qt中，这是通过`QJSEngine`类完成的。这是一个JavaScript运行时，负责执行脚本代码并管理所有与脚本相关的资源。它提供了`evaluate()`方法，可以用来执行JavaScript表达式。让我们看看使用`QJSEngine`的“Hello
    World”程序：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program is very simple. First, it creates an application object that is
    required for the script environment to function properly and instantiates a `QJSEngine`
    object. Next, we ask `QJSEngine` to install the console extension—the global `console`
    object that can be used to print messages to the console. It's not part of the
    ECMAScript standard, so it's not available by default, but we can easily enable
    it using the `installExtensions()` function. Finally, we call the `evaluate()`
    function to execute the script source given to it as a parameter. After building
    and running the program, you will see a well-known `Hello World!` printed to the
    console with the `js:` prefix.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序非常简单。首先，它创建一个应用程序对象，这对于脚本环境正常工作来说是必需的，并实例化一个`QJSEngine`对象。接下来，我们要求`QJSEngine`安装控制台扩展——一个全局的`console`对象，可以用来向控制台打印消息。它不是ECMAScript标准的一部分，因此默认情况下不可用，但我们可以通过使用`installExtensions()`函数轻松启用它。最后，我们调用`evaluate()`函数来执行作为参数传递给它的脚本源代码。构建并运行程序后，你将在控制台看到带有`js:`前缀的熟悉的`Hello
    World!`。
- en: By default, `QJSEngine` provides built-in objects defined by ECMA-262 standard,
    including `Math`, `Date`, and `String`. For example, a script can use `Math.abs(x)`
    to get the absolute value of a number.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`QJSEngine`提供了由ECMA-262标准定义的内置对象，包括`Math`、`Date`和`String`。例如，一个脚本可以使用`Math.abs(x)`来获取一个数字的绝对值。
- en: 'If you don''t get any output, it probably means that the script didn''t get
    executed properly, possibly because of an error in the script''s source code.
    To verify that, we can check the value returned from `evaluate()`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有获得任何输出，这可能意味着脚本没有正确执行，可能是由于脚本源代码中的错误。为了验证这一点，我们可以检查`evaluate()`函数返回的值：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code checks whether there is an exception or a syntax error and if yes,
    it displays the corresponding error message. For example, if you omit the closing
    single quote in the script source text and run the program, the following message
    will be displayed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查是否存在异常或语法错误，如果有，则显示相应的错误消息。例如，如果你在脚本源文本中省略了关闭的单引号并运行程序，将显示以下消息：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that `evaluate()` returns a `QJSValue`. This is a special type that
    is used to exchange data between the JavaScript engine and the C++ world. Like
    `QVariant`, it can hold a number of primitive types (`boolean`, `integer`, `string`,
    and so on). However, it is in fact much more powerful, because it can hold a reference
    to a JavaScript object or function that lives in the JavaScript engine. Copying
    a `QJSValue` will produce another object that references the same JavaScript object.
    You can use the member functions of `QJSValue` to interact with the objects from
    C++. For example, you can use `property()` and `setProperty()` to manipulate the
    object's properties and `call()` to call the function and get the returned value
    as another `QJSValue`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`evaluate()`返回一个`QJSValue`。这是一种特殊类型，用于在JavaScript引擎和C++世界之间交换数据。像`QVariant`一样，它可以持有多种原始类型（`boolean`、`integer`、`string`等）。然而，实际上它更强大，因为它可以持有指向JavaScript引擎中存在的JavaScript对象或函数的引用。复制一个`QJSValue`将产生另一个引用相同JavaScript对象的另一个对象。你可以使用`QJSValue`的成员函数与C++中的对象交互。例如，你可以使用`property()`和`setProperty()`来操作对象的属性，使用`call()`来调用函数并获取作为另一个`QJSValue`返回的值。
- en: 'In the previous example, `QJSEngine::evaluate()` returned an `Error` object.
    When the JavaScript code runs successfully, you can use the returned value later
    in your C++ code. For example, the script can calculate the amount of damage done
    to a creature when it is hit with a particular weapon. Modifying our code to use
    the result of the script is very simple. All that is required is to store the
    value returned by `evaluate()` and then it can be used elsewhere in the code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`QJSEngine::evaluate()` 返回了一个 `Error` 对象。当 JavaScript 代码成功运行时，您可以在 C++
    代码中稍后使用返回的值。例如，脚本可以计算当生物被特定武器击中时造成的伤害量。修改我们的代码以使用脚本的输出非常简单。所需的所有操作只是存储 `evaluate()`
    返回的值，然后它可以在代码的其他部分使用：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Time for action – Creating a JavaScript editor
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建 JavaScript 编辑器
- en: Let's do a simple exercise and create a graphical editor to write and execute
    scripts. Start by creating a new Qt Widgets project and implement a main window
    composed of two plain text edit widgets (`ui->codeEditor` and `ui->logWindow`)
    that are separated using a vertical splitter. One of the edit boxes will be used
    as an editor to input code and the other will be used as a console to display
    script results. Then, add a menu and toolbar to the window and create actions
    to open (`ui->actionOpenDocument`) and save (`ui->actionSaveDocument` and `ui->actionSaveDocumentAs`)
    the document, create a new document (`ui->actionNewDocument`), execute the script
    (`ui->actionExecuteScript`), and to quit the application (`ui->actionQuit`). Remember
    to add them to the menu and toolbar.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的练习，创建一个图形编辑器来编写和执行脚本。首先创建一个新的 Qt Widgets 项目，并实现一个由两个纯文本编辑小部件（`ui->codeEditor`
    和 `ui->logWindow`）组成的窗口，这两个小部件通过垂直分隔符分开。其中一个编辑框将用作输入代码的编辑器，另一个将用作显示脚本结果的控制台。然后，向窗口添加菜单和工具栏，并创建打开（`ui->actionOpenDocument`）、保存（`ui->actionSaveDocument`
    和 `ui->actionSaveDocumentAs`）、创建新文档（`ui->actionNewDocument`）、执行脚本（`ui->actionExecuteScript`）和退出应用程序（`ui->actionQuit`）的操作。请记住将它们添加到菜单和工具栏中。
- en: 'As a result, you should receive a window similar to the one shown in the following
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该会收到一个类似于以下截图的窗口：
- en: '![](img/bbc56b53-86e7-40f9-b8f1-19528ce6d0a9.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbc56b53-86e7-40f9-b8f1-19528ce6d0a9.png)'
- en: 'Connect the quit action to the `QApplication::quit()` slot. Then, create an
    `openDocument()` slot and connect it to the `triggered` signal of the appropriate
    action. In the slot, use `QFileDialog::getOpenFileName()` to ask the user for
    a document path, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将退出操作连接到 `QApplication::quit()` 插槽。然后，创建一个 `openDocument()` 插槽并将其连接到适当操作的 `triggered`
    信号。在插槽中，使用 `QFileDialog::getOpenFileName()` 询问用户文档路径，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a similar fashion, implement the New, Save, and Save As action handlers.
    Lastly, create the `open(const QString &filePath)` slot that should read the document
    and put its contents into the code editor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式实现新建、保存和另存为操作处理程序。最后，创建一个 `open(const QString &filePath)` 插槽，该插槽应读取文档并将其内容放入代码编辑器：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `windowFilePath` property of `QWidget` can be used to associate a file with
    a window. When this property is set, Qt will automatically adjust the window title
    and even add a proxy icon on macOS, allowing convenient access to the file. You
    can then use this property in actions related to using the file—when saving a
    document, you can check whether this property is empty and ask the user to provide
    a filename. Then, you can reset this property when creating a new document or
    when the user provides a new path for the document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget` 的 `windowFilePath` 属性可以用来将文件与窗口关联。当此属性被设置时，Qt 会自动调整窗口标题，甚至在 macOS
    上添加代理图标，以便方便地访问文件。然后，您可以在与文件使用相关的操作中使用此属性——在保存文档时，您可以检查此属性是否为空，并要求用户提供文件名。然后，在创建新文档或用户为文档提供新路径时，您可以重置此属性。'
- en: At this point, you should be able to run the program and use it to create scripts
    and save and reload them in the editor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该能够运行程序，并使用它来创建脚本，在编辑器中保存和重新加载它们。
- en: 'Now, to execute the scripts, add a `QJSEngine m_engine` member variable to
    the window class. Create a new slot, call it `run`, and connect it to the execute
    action. Put the following code in the body of the slot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了执行脚本，向窗口类中添加一个 `QJSEngine m_engine` 成员变量。创建一个新的插槽，命名为 `run`，并将其连接到执行操作。在插槽的主体中放入以下代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build and run the program. To do so, enter the following script in the editor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行程序。为此，在编辑器中输入以下脚本：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the script in a file called `factorial.js` and then run it. You should
    get an output as shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本保存到名为 `factorial.js` 的文件中，然后运行它。你应该得到如下输出：
- en: '![](img/fa9c7836-4685-414d-94e9-9cfadb238755.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa9c7836-4685-414d-94e9-9cfadb238755.png)'
- en: 'Next, replace the script with the following one:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将脚本替换为以下内容：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the script should yield the following result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本应产生以下结果：
- en: '![](img/6785935d-8c68-4c9c-8aaa-77fa656db629.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6785935d-8c68-4c9c-8aaa-77fa656db629.png)'
- en: What just happened?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `run()` method clears the log window and evaluates the script using the
    method that we learned earlier in this chapter. If the evaluation is successful,
    it prints the result in the log window, which is what we see in the first screenshot
    shown in the previous section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法清除日志窗口并使用我们在本章前面学到的方法评估脚本。如果评估成功，它将在日志窗口中打印结果，这就是我们在上一节中看到的第一个截图所示的内容。'
- en: In the second attempt, we made an error in the script using a nonexistent variable.
    Evaluating such code results in an exception. In addition to reporting the actual
    error, we also use the `lineNumber` property of the returned `Error` object to
    report the line that caused the problem. Next, we display the `stack` property
    of the error object, which returns the backtrace (a stack of function calls) of
    the problem, which we also print on the log.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次尝试中，我们在脚本中使用了一个不存在的变量，导致错误。评估此类代码会导致异常。除了报告实际错误外，我们还使用返回的`Error`对象的`lineNumber`属性来报告导致问题的行。接下来，我们显示错误对象的`stack`属性，它返回问题的回溯（函数调用堆栈），我们也在日志中打印出来。
- en: Global object state
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局对象状态
- en: 'Let''s try another script. The following code defines the `fun` local variable, which
    is assigned an anonymous function that returns a number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个脚本。以下代码定义了`fun`局部变量，它被分配了一个返回数字的匿名函数：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then call `fun()` like a regular function, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像调用常规函数一样调用`fun()`，如下所示：
- en: '![](img/c4ec89e0-cd77-4c85-8a77-49db05956220.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4ec89e0-cd77-4c85-8a77-49db05956220.png)'
- en: 'Now, let''s look at what happens if we delete the definition of `fun` from
    the script, but still keep the invocation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们从脚本中删除`fun`的定义，但仍然保留调用会发生什么：
- en: '![](img/7d8c75cc-760c-4cfd-a217-006cdb4f3e46.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d8c75cc-760c-4cfd-a217-006cdb4f3e46.png)'
- en: We still get the same result even though we didn't define what `fun` means!
    This is because any variables at the top scope become properties of the global
    object. The state of the global object is preserved during the existence of `QJSEngine`,
    so the `fun` variable will remain available until it's overwritten or the engine
    is destroyed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有定义`fun`的含义，我们仍然得到相同的结果！这是因为任何在顶层作用域中的变量都成为全局对象的属性。全局对象的状态在`QJSEngine`存在期间被保留，所以`fun`变量将保持可用，直到它被覆盖或引擎被销毁。
- en: 'To prevent users from accidentally changing the global object with local variables,
    we can wrap the provided code in an anonymous function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户意外地使用局部变量更改全局对象，我们可以将提供的代码包裹在一个匿名函数中：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, the JavaScript code must use the `return` statement to actually
    return a value to the editor:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript代码必须使用`return`语句实际上将值返回到编辑器：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Removing the `fun` variable initialization will now result in an error:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`fun`变量初始化现在将导致错误：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, removing the `var` keyword will make the variable global and preserved.
    A malicious user can also break the existing global object's properties. For example,
    evaluating `Math.floor = null;` will make the built-in `Math.floor` function unavailable
    in all subsequent calls.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，移除`var`关键字将使变量成为全局并保留。恶意用户还可以破坏现有全局对象的属性。例如，评估`Math.floor = null;`将使内置的`Math.floor`函数在所有后续调用中不可用。
- en: There isn't really a good way to guard or reset the global object. If you are
    concerned about malicious scripts, destroying and creating a new `QJSEngine` object
    is the best option. If you need to run multiple scripts that are not allowed to
    interfere with each other, you have to create a separate `QJSEngine` for each
    of them. However, in most applications, such sandboxing seems to be an overkill.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有很好的方法来保护或重置全局对象。如果您担心恶意脚本，销毁并创建一个新的`QJSEngine`对象是最佳选择。如果您需要运行多个不允许相互干扰的脚本，您必须为每个脚本创建一个单独的`QJSEngine`。然而，在大多数应用程序中，这种沙箱化似乎是一种过度行为。
- en: Exposing C++ objects and functions to JavaScript code
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将C++对象和函数暴露给JavaScript代码
- en: So far, we were only evaluating some standalone scripts that can make use of
    built-in JavaScript features. Now, it is time to learn to use data from your programs
    in the scripts. This is done by exposing different kinds of entities to and from
    scripts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只评估了一些可以充分利用内置 JavaScript 功能的独立脚本。现在，是时候学习如何在脚本中使用程序中的数据了。这是通过将不同类型的实体暴露给脚本和从脚本中实现的。
- en: Accessing C++ object's properties and methods
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 C++ 对象的属性和方法
- en: 'The simplest way to expose a C++ object to JavaScript code is to take advantage
    of Qt''s meta-object system. `QJSEngine` is able to inspect `QObject` instances
    and detect their properties and methods. To use them in scripts, the object has
    to be visible to the script. The easiest way to make this happen is to add it
    to the engine''s global object. As you remember, all data between the script engine
    and C++ is exchanged using the `QJSValue` class, so first we have to obtain a
    JS value handle for the C++ object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将 C++ 对象暴露给 JavaScript 代码的最简单方法就是利用 Qt 的元对象系统。`QJSEngine` 能够检查 `QObject` 实例并检测它们的属性和方法。要在脚本中使用它们，对象必须对脚本可见。使这一行为发生的最简单方法是将它添加到引擎的全局对象中。正如你所记得的，脚本引擎和
    C++ 之间的所有数据交换都使用 `QJSValue` 类进行，因此我们首先需要为 C++ 对象获取一个 JS 值句柄：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`QJSEngine::newQObject()` creates a JavaScript object wrapping an existing
    `QObject` instance. We then set the wrapper as a property of the global object
    called `pushButton`. This makes the button available in the global context of
    the engine as a JavaScript object. All the properties defined with `Q_PROPERTY`
    are available as properties of the object, and every slot is accessible as a method
    of that object. In JavaScript, you will be able to use the `pushButton` object
    like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJSEngine::newQObject()` 创建一个 JavaScript 对象，它封装了一个现有的 `QObject` 实例。然后我们将包装器设置为全局对象的属性，称为
    `pushButton`。这使得按钮作为 JavaScript 对象在引擎的全局上下文中可用。所有使用 `Q_PROPERTY` 定义的属性都作为对象的属性可用，每个槽都可以作为该对象的方法访问。在
    JavaScript 中，你将能够像这样使用 `pushButton` 对象：'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Qt slots conventionally return `void`. They technically can have any return
    type, but Qt won''t use the return value, so in most cases, there is no sense
    in returning any value. On the contrary, when you expose a C++ method to the JavaScript
    engine, you often want to return a value and receive it in JavaScript. In these
    cases, you should not create slots, as that will break the convention. You should
    make the method invokable instead. To do this, place the method declaration in
    a regular `public` scope and add `Q_INVOKABLE` before it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 槽传统上返回 `void`。技术上它们可以有任何返回类型，但 Qt 不会使用返回值，所以在大多数情况下，返回任何值都没有意义。相反，当你将 C++
    方法暴露给 JavaScript 引擎时，你通常希望返回一个值并在 JavaScript 中接收它。在这些情况下，你不应该创建槽，因为这会破坏约定。你应该使方法可调用。为此，将方法声明放在常规
    `public` 范围内，并在其前面添加 `Q_INVOKABLE`：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This macro instructs **moc** to make this method invokable in the meta-object
    system so that Qt will be able to call it at runtime. All invokable methods are
    automatically exposed to scripts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏指示 **moc** 使此方法在元对象系统中可调用，以便 Qt 能够在运行时调用它。所有可调用的方法都会自动暴露给脚本。
- en: Data type conversions between C++ and JavaScript
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 和 JavaScript 之间的数据类型转换
- en: 'Qt will automatically convert arguments and return types of methods to its
    JavaScript counterparts. The supported conversions include the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 会自动将方法的参数和返回类型转换为它的 JavaScript 对应类型。支持的转换包括以下内容：
- en: Basic types (`bool`, `int`, `double`, and such) are exposed without changes
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型（`bool`、`int`、`double` 等）未经更改地暴露
- en: Qt data types (`QString`, `QUrl`, `QColor`, `QFont`, `QDate`, `QPoint`, `QSize`,
    `QRect`, `QMatrix4x4`, `QQuaternion`, `QVector2D`, and such) are converted to
    objects with the available properties
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 数据类型（`QString`、`QUrl`、`QColor`、`QFont`、`QDate`、`QPoint`、`QSize`、`QRect`、`QMatrix4x4`、`QQuaternion`、`QVector2D`
    等）转换为具有可用属性的对象
- en: '`QDateTime` and `QTime` values are automatically converted to JavaScript `Date`
    objects'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QDateTime` 和 `QTime` 值自动转换为 JavaScript `Date` 对象'
- en: Enums declared with `Q_ENUM` macro can be used in JavaScript
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Q_ENUM` 宏声明的枚举可以在 JavaScript 中使用
- en: Flags declared with `Q_FLAG` macro can be used as flags in JavaScript
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Q_FLAG` 宏声明的标志可以用作 JavaScript 中的标志
- en: '`QObject*` pointers will be automatically converted to JavaScript wrapper objects'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QObject*` 指针将自动转换为 JavaScript 包装对象'
- en: '`QVariant` objects containing any supported types are recognized'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含任何支持类型的 `QVariant` 对象被识别
- en: '`QVariantList` is an equivalent of a JavaScript array with arbitrary items'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVariantList` 是一个具有任意项的 JavaScript 数组的等价物'
- en: '`QVariantMap` is an equivalent of a JavaScript object with arbitrary properties'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVariantMap` 是具有任意属性的 JavaScript 对象的等效物'
- en: Some C++ list types (`QList<int>`, `QList<qreal>`, `QList<bool>`, `QList<QString>`,
    `QStringList`, `QList<QUrl>`, `QVector<int>`, `QVector<qreal>`, and `QVector<bool>`)
    are exposed to JavaScript without performing additional data conversions
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 C++ 列表类型（`QList<int>`, `QList<qreal>`, `QList<bool>`, `QList<QString>`, `QStringList`,
    `QList<QUrl>`, `QVector<int>`, `QVector<qreal>`, 和 `QVector<bool>`）在 JavaScript
    中暴露，无需执行额外的数据转换
- en: If you want more fine-grained control over data type conversions, you can simply
    use `QJSValue` as an argument type or a return type. For example, this will allow
    you to return a reference to an existing JavaScript object instead of creating
    a new one each time. This approach is also useful for creating or accessing multidimensional
    arrays or other objects with complex structure. While you can use nested `QVariantList`
    or `QVariantMap` objects, creating `QJSValue` objects directly may be more efficient.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更精细地控制数据类型转换，你可以简单地使用 `QJSValue` 作为参数类型或返回类型。例如，这将允许你返回现有 JavaScript 对象的引用，而不是每次都创建一个新的对象。这种方法对于创建或访问具有复杂结构的二维数组或其他对象也非常有用。虽然你可以使用嵌套的
    `QVariantList` 或 `QVariantMap` 对象，但直接创建 `QJSValue` 对象可能更有效。
- en: Qt will not be able to recognize and automatically convert a custom type. Attempting
    to access such method or property from JavaScript will result in an error. You
    can use the `Q_GADGET` macro to make a C++ data type available to JavaScript and
    use `Q_PROPERTY` to declare properties that should be exposed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 无法识别并自动转换自定义类型。尝试从 JavaScript 访问此类方法或属性将导致错误。你可以使用 `Q_GADGET` 宏使 C++ 数据类型对
    JavaScript 可用，并使用 `Q_PROPERTY` 声明应公开的属性。
- en: For more information on this topic, refer to the Data Type Conversion Between
    QML and C++ documentation page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅 QML 和 C++ 之间数据类型转换文档页面。
- en: Accessing signals and slots in scripts
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在脚本中访问信号和槽
- en: '`QJSEngine` also offers the capability to use signals and slots. The slot can
    be either a C++ method or a JavaScript function. The connection can be made either
    in C++ or in the script.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJSEngine` 还提供了使用信号和槽的能力。槽可以是 C++ 方法或 JavaScript 函数。连接可以在 C++ 或脚本中创建。'
- en: 'First, let''s see how to establish a connection within a script. When a `QObject`
    instance is exposed to a script, the object''s signals become the properties of
    the wrapping object. These properties have a `connect` method that accepts a function
    object that is to be called when the signal is emitted. The receiver can be a
    regular slot or a JavaScript function. The most common case is when you connect
    the signal to an anonymous function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在脚本内部建立连接。当一个 `QObject` 实例暴露给脚本时，对象信号成为包装对象的属性。这些属性有一个 `connect` 方法，它接受一个函数对象，当信号被发射时将调用该对象。接收者可以是常规槽或
    JavaScript 函数。最常见的情况是将信号连接到一个匿名函数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you need to undo the connection, you will need to store the function in
    a variable:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要撤销连接，你需要将函数存储在一个变量中：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can define the `this` object for the function by providing an extra argument
    to `connect()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 `connect()` 提供一个额外的参数来为函数定义 `this` 对象：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also connect the signal to a signal or slot of another exposed object.
    To connect the `clicked()` signal of an object called `pushButton` to a `clear()`
    slot of another object called `lineEdit`, you can use the following statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将信号连接到另一个暴露对象的信号或槽。要将名为 `pushButton` 的对象的 `clicked()` 信号连接到名为 `lineEdit`
    的另一个对象的 `clear()` 槽，可以使用以下语句：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Emitting signals from within the script is also easy—just call the signal as
    a function and pass to it any necessary parameters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本内部发射信号也很简单——只需将信号作为函数调用，并传递任何必要的参数：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To create a signal-slot connection on the C++ side where the receiver is a
    JavaScript function, you can utilize C++ lambda functions and the `QJSValue::call()`
    function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C++ 端创建接收器为 JavaScript 函数的信号-槽连接，你可以利用 C++ lambda 函数和 `QJSValue::call()`
    函数：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Time for action – Using a button from JavaScript
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用 JavaScript 中的按钮
- en: 'Let''s put all this together and build a complete example of a scriptable button:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些放在一起，构建一个可脚本化的按钮的完整示例：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we expose the function to JavaScript and execute code that sets
    some properties of the button and accesses its `toggled` signal. Next, we create
    a JavaScript function, store a reference to it in the `func` variable, and connect
    the `toggled` signal of the button to this function from C++ side.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将函数暴露给JavaScript并执行设置按钮某些属性和访问其`toggled`信号的代码。接下来，我们创建一个JavaScript函数，将其引用存储在`func`变量中，并从C++侧将按钮的`toggled`信号连接到这个函数。
- en: Restricting access to C++ classes from JavaScript
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制从JavaScript访问C++类
- en: There are cases when you want to provide a rich interface for a class to manipulate
    it from within C++ easily, but to have strict control over what can be done using
    scripting, you want to prevent scripters from using some of the properties or
    methods of the class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想为类提供一个丰富的接口，以便从C++内部轻松地操作它，但同时又想严格控制使用脚本可以执行的操作，因此你想阻止脚本编写者使用类的一些属性或方法。
- en: The safest approach is to create a wrapper class that only exposes the allowed
    methods and signals. This will allow you to design your original classes freely.
    For example, if you want to hide some methods, it's quite easy—just don't make
    them slots and don't declare them with `Q_INVOKABLE`. However, you may want them
    to be slots in the internal implementation. By creating a wrapper class, you can
    easily hide slots of the internal class from the JavaScript code. We'll show how
    to apply this approach later in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的做法是创建一个只暴露允许的方法和信号的包装器类。这将允许你自由地设计你的原始类。例如，如果你想隐藏某些方法，这相当简单——只需不要将它们作为槽函数，也不要用`Q_INVOKABLE`声明它们。然而，你可能希望在内部实现中将它们作为槽函数。通过创建包装器类，你可以轻松地将内部类的槽函数隐藏起来，使其无法被JavaScript代码访问。我们将在本章后面展示如何应用这种方法。
- en: Another issue may arise if the data types used by your internal object cannot
    be directly exposed to JavaScript. For example, if one of your methods returns
    a `QVector<QVector<int>>`, you will not be able to call such a method directly
    from JavaScript. The wrapper class is a good place to put the required data conversion
    operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的内部对象使用的数据类型不能直接暴露给JavaScript，可能会出现另一个问题。例如，如果你的某个方法返回一个`QVector<QVector<int>>`，你将无法直接从JavaScript调用此方法。包装器类是放置所需数据转换操作的好地方。
- en: You should also be aware that JavaScript code can emit any signals of exposed
    C++ objects. In some cases, this can break the logic of your application. If you're
    using a wrapper, you can just connect the signal of the internal class to the
    signal of the exposed wrapper. The script will be able to connect to the wrapper's
    signal, but it won't be able to emit the original signal. However, the script
    will be able to emit the wrapper's signal, and this can affect all the other JavaScript
    code in the engine.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该意识到，JavaScript代码可以发出暴露的C++对象的任何信号。在某些情况下，这可能会破坏你应用程序的逻辑。如果你使用包装器，你只需将内部类的信号连接到暴露的包装器的信号。脚本将能够连接到包装器的信号，但无法发出原始信号。然而，脚本将能够发出包装器的信号，这可能会影响引擎中所有其他JavaScript代码。
- en: If all or almost all APIs of the class are safe to expose to JavaScript, it's
    much easier to make the objects themselves available, instead of creating wrappers.
    If you want to restrict access to certain methods, keep in mind that JavaScript
    code can only access public and protected methods declared with `Q_INVOKABLE`
    and slots. Remember that you can still connect signals to non-slot methods if
    you use the `connect()` variant that takes a function pointer as an argument.
    JavaScript code also cannot access any private methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类的所有或几乎所有API都安全地暴露给JavaScript，那么直接使对象本身可用，而不是创建包装器，会更容易。如果你想限制对某些方法的访问，请记住，JavaScript代码只能访问用`Q_INVOKABLE`声明的公共和受保护方法以及槽函数。记住，如果你使用接受函数指针作为参数的`connect()`变体，你仍然可以将信号连接到非槽方法。JavaScript代码也无法访问任何私有方法。
- en: 'For properties, you can mark them inaccessible from scripts using the `SCRIPTABLE`
    keyword in the `Q_PROPERTY` declaration. By default, all properties are scriptable,
    but you can forbid their exposure to scripts by setting `SCRIPTABLE` to `false`,
    as shown in the following example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性，你可以在`Q_PROPERTY`声明中使用`SCRIPTABLE`关键字来标记它们不被脚本访问。默认情况下，所有属性都是可脚本化的，但你可以通过将`SCRIPTABLE`设置为`false`来禁止它们被脚本暴露，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating C++ objects from JavaScript
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JavaScript创建C++对象
- en: 'We''ve only exposed the existing C++ objects to JavaScript so far, but what
    if you want to create a new C++ object from JavaScript? You can do this using
    what you already know. A C++ method of an already exposed object can create a
    new object for you:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止只暴露了现有的C++对象给JavaScript，但如果你想在JavaScript中创建一个新的C++对象怎么办？你可以使用你已知的知识来做这件事。一个已暴露对象的C++方法可以为你创建一个新的对象：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use `QObject*` instead of `MyObject*` in the function signature. This allows
    us to import the object into the JS engine automatically. The engine will take
    ownership of the object and delete it when there are no more references to it
    in JavaScript.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中，我们使用`QObject*`而不是`MyObject*`。这允许我们自动将对象导入JS引擎。当JavaScript中没有更多引用时，引擎将接管对象并删除它。
- en: 'Using this method from JavaScript is also pretty straightforward:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法从JavaScript中调用也是相当直接的：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This approach is fine if you have a good place for the `createMyObject` function.
    However, sometimes you want to create new objects independently of the existing
    ones, or you don''t have any objects created yet. For these situations, there
    is a neat way to expose the constructor of the class to the JavaScript engine.
    First, you need to make your constructor invokable in the class declaration:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有合适的`createMyObject`函数位置，这种方法是可行的。然而，有时你想要独立于现有对象创建新对象，或者你还没有创建任何对象。对于这些情况，有一种巧妙的方法可以将类的构造函数暴露给JavaScript引擎。首先，你需要使类声明中的构造函数可调用：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, you should use the `newQMetaObject()` function to import the *meta-object*
    of the class to the engine. You can immediately assign the imported meta-object
    to a property of the global object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该使用`newQMetaObject()`函数将类的*元对象*导入到引擎中。你可以立即将导入的元对象分配给全局对象的属性：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can now invoke the constructor by calling the exposed object with the `new`
    keyword:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过使用`new`关键字调用暴露的对象来调用构造函数：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Exposing C++ functions to JavaScript
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将C++函数暴露给JavaScript
- en: 'Sometimes you just want to provide a single function instead of an object.
    Unfortunately, `QJSEngine` only supports functions that belong to `QObject`-derived
    classes. However, we can hide this implementation detail from the JavaScript side.
    First, create a subclass of `QObject` and add an invokable member function that
    proxies the original standalone function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你只想提供一个函数而不是一个对象。不幸的是，`QJSEngine`只支持属于`QObject`派生类的函数。然而，我们可以从JavaScript方面隐藏这个实现细节。首先，创建`QObject`的一个子类并添加一个可调用的成员函数，该函数代理原始独立函数：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, expose the wrapper object using the `newQObject()` function, as usual.
    However, instead of assigning this object to a property of the global object,
    extract the `factorial` property from the object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`newQObject()`函数像往常一样暴露包装对象。然而，不要将此对象分配给全局对象的属性，而是从对象中提取`factorial`属性：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, the JavaScript code can access the method as if it were a global function,
    like `factorial(4)`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript代码可以像访问全局函数一样访问方法，例如`factorial(4)`。
- en: Creating a JavaScript scripting game
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个JavaScript脚本游戏
- en: Let's perfect our skills by implementing a game that allows players to use JavaScript.
    The rules are simple. Each player has a number of entities that move on the board.
    All entities move in turns; during each turn, the entity can stand still or move
    to an adjacent tile (cardinally or diagonally). If an entity moves to the tile
    occupied by another entity, that entity is killed and removed from the board.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个允许玩家使用JavaScript的游戏来完善我们的技能。规则很简单。每个玩家在棋盘上都有一些实体移动。所有实体轮流移动；在每一轮中，实体可以静止不动或移动到相邻的方格（直线或对角线）。如果一个实体移动到另一个实体占据的方格，那个实体就会被杀死并从棋盘上移除。
- en: 'At the beginning of the game, all entities are placed randomly on the board.
    An example of a starting position is displayed on the following image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，所有实体都随机放置在棋盘上。以下图像显示了起始位置的示例：
- en: '![](img/561a69d4-121f-4b71-ba94-27e22c8dcfee.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/561a69d4-121f-4b71-ba94-27e22c8dcfee.png)'
- en: Each player must provide a JavaScript function that receives an entity object
    and returns its new position. This function will be called when one of the player's
    entities should move. Additionally, the player may provide an initialization function
    that will be called at the beginning of the game. The state of the board and entities
    on it will be exposed through a property of the global JavaScript object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个玩家必须提供一个JavaScript函数，该函数接收一个实体对象并返回其新位置。当玩家的某个实体应该移动时，将调用此函数。此外，玩家还可以提供一个初始化函数，该函数将在游戏开始时被调用。棋盘的状态和其上的实体将通过全局JavaScript对象的一个属性公开。
- en: In our game, the players will compete to create the best survival strategy.
    Once the game is started, the players have no control over the entities, and the
    provided JavaScript functions must account for any possible game situation. When
    only entities of one player remain on the board, that player wins. The rules allow
    any number of players to participate, although we will only have two players in
    our example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，玩家将竞争创建最佳的生存策略。一旦游戏开始，玩家就无法控制实体，提供的JavaScript函数必须考虑到任何可能的游戏情况。当棋盘上只剩下一个玩家的实体时，该玩家获胜。规则允许任何数量的玩家参与，尽管在我们的示例中我们只有两个玩家。
- en: Time for action – Implementing the game engine
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 实现游戏引擎
- en: We will use the Graphics View framework to implement the board visualization.
    We will not provide too many details about the implementation, since we focus
    on scripting in this chapter. The basic skills you learned in [Chapter 4](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml),
    *Custom 2D Graphics with Graphics View*, should be enough for you to implement
    this game. The full code of this example is provided with the book. However, we
    will highlight the architecture of the project and briefly describe how it works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用图形视图框架来实现棋盘可视化。由于本章重点在于脚本编写，我们将不对实现细节进行过多介绍。你在[第4章](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml)，*使用图形视图的定制2D图形*中学到的基本技能应该足够你实现这个游戏。本书提供了这个示例的完整代码。然而，我们将突出展示项目的架构，并简要描述其工作原理。
- en: 'The game engine implementation consists of two classes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎的实现包括两个类：
- en: The `Scene` class (derived from `QGraphicsScene`) manages the graphics scene,
    creates items, and implements the general game logic
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scene`类（由`QGraphicsScene`派生）管理图形场景，创建项目，并实现通用游戏逻辑'
- en: The `Entity` class (derived from `QGraphicsEllipseItem`) represents a single
    game entity on the board
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entity`类（由`QGraphicsEllipseItem`派生）代表棋盘上的单个游戏实体'
- en: 'Each `Entity` object is a circle with 0.4 radius and (0, 0) center. It is initialized
    in the constructor, using the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Entity`对象是一个半径为0.4且中心为(0, 0)的圆。它是在构造函数中初始化的，使用以下代码：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will use the `pos` property (inherited from `QGraphicsItem`) to move the
    circle on the board. The tiles of the board will have a unit size, so we can just
    treat `pos` as integer `QPoint` instead of `QPointF` with `double` coordinates.
    We will zoom in to the graphics view to achieve the desired visible size of the
    entities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pos`属性（从`QGraphicsItem`继承）来移动棋盘上的圆。棋盘的瓦片将具有单位大小，因此我们可以将`pos`视为整数`QPoint`，而不是具有`double`坐标的`QPointF`。我们将放大图形视图以实现实体所需的可见大小。
- en: 'The `Entity` class has two special properties with getters and setters. The
    `team` property is the number of the player this entity belongs to. This property
    also defines the color of the circle:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity`类有两个具有获取器和设置器的特殊属性。`team`属性是该实体所属玩家的编号。此属性还定义了圆的颜色：'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `alive` flag indicates whether the entity is still in play. For simplicity,
    we will not immediately delete the killed entity objects. We will just hide them
    instead:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`alive`标志指示实体是否仍在游戏中。为了简单起见，我们不会立即删除被杀死的实体对象，而是将其隐藏：'
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s turn our attention to the `Scene` class. First, it defines some game
    configuration options:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向`Scene`类。首先，它定义了一些游戏配置选项：
- en: The `fieldSize` property determines the two-dimensional size of the board
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldSize`属性确定棋盘的二维大小'
- en: The `teamSize` property determines how many entities each player has at the
    beginning of the game
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teamSize`属性确定每个玩家在游戏开始时拥有的实体数量'
- en: The `stepDuration` property determines the number of milliseconds passed between
    executing the next round of turns
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stepDuration`属性确定执行下一轮回合之间经过的毫秒数'
- en: 'The setter of the `fieldSize` property adjusts the scene rect so that the graphics
    view is correctly resized at the beginning of the game:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`fieldSize` 属性的设置器调整场景矩形，以便在游戏开始时正确调整图形视图的大小：'
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The execution of each round of the game will be done in the `step()` function.
    In the constructor, we initialize a `QTimer` object responsible for calling this
    function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮游戏的执行将在 `step()` 函数中完成。在构造函数中，我们初始化一个负责调用此函数的 `QTimer` 对象：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `setStepDuration()` function, we simply change the interval of this timer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setStepDuration()` 函数中，我们简单地改变这个计时器的间隔。
- en: 'The `QVector<Entity*> m_entities` private field of the `Scene` class will contain
    all the entities in play. The game is started by calling the `start()` function.
    Let''s take a look at it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene` 类的 `QVector<Entity*> m_entities` 私有字段将包含所有在游戏中运行的实体。游戏通过调用 `start()`
    函数开始。让我们看看它：'
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We create the requested number of entities for each team and place them at random
    locations on the board. If we happen to choose an already occupied place, we go
    on the next iteration of the `do`-`while` loop and choose another location. Next,
    we add the new item to the scene and to the `m_entities` vector. Finally, we start
    our timer so that the `step()` function will be called periodically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个团队创建所需数量的实体，并将它们随机放置在棋盘上的位置。如果我们恰好选择了一个已被占用的位置，我们将进入 `do`-`while` 循环的下一个迭代并选择另一个位置。接下来，我们将新项目添加到场景和
    `m_entities` 向量中。最后，我们开始计时器，以便 `step()` 函数能定期被调用。
- en: 'In the `main()` function, we initialize the random number generator because
    we want to get new random numbers each time:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们初始化随机数生成器，因为我们希望每次都能得到新的随机数：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, we create and initialize the `Scene` object, and we create a `QGraphicsView`
    to display our scene.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建并初始化 `Scene` 对象，并创建一个 `QGraphicsView` 来显示我们的场景。
- en: The game engine is almost ready. We only need to implement the scripting.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎几乎准备好了。我们只需要实现脚本。
- en: Time for action – Exposing the game state to the JS engine
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将游戏状态暴露给 JS 引擎
- en: Before we move on to executing the players' scripts, we need to create a `QJSEngine`
    and insert some information into its global object. The scripts will use this
    information to decide the optimal move.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行玩家的脚本之前，我们需要创建一个 `QJSEngine` 并向其全局对象中插入一些信息。脚本将使用这些信息来决定最佳移动。
- en: 'First, we add the `QJSEngine m_jsEngine` private field to the `Scene` class.
    Next, we create a new `SceneProxy` class and derive it from `QObject`. This class
    will expose the permitted API of `Scene` to the scripts. We pass a pointer to
    the `Scene` object to the constructor of the `SceneProxy` object and store it
    in a private variable:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `QJSEngine m_jsEngine` 私有字段添加到 `Scene` 类中。接下来，我们创建一个新的 `SceneProxy` 类，并从
    `QObject` 派生它。这个类将向脚本暴露 `Scene` 的允许 API。我们将 `Scene` 对象的指针传递给 `SceneProxy` 对象的构造函数，并将其存储在一个私有变量中：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add two invokable methods to the class declaration:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 向类声明中添加两个可调用方法：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The implementation of the `size()` function is pretty straightforward:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()` 函数的实现相当简单：'
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, the `entities()` function is a bit trickier. We cannot add `Entity`
    objects to the JS engine because they are not based on `QObject`. Even if we could,
    we prefer to create a proxy class for entities as well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`entities()` 函数有点复杂。我们不能将 `Entity` 对象添加到 JS 引擎中，因为它们不是基于 `QObject` 的。即使我们可以，我们也更喜欢为实体创建一个代理类。
- en: 'Let''s do this right now. Create the `EntityProxy` class, derive it from `QObject`,
    and pass a pointer to the underlying `Entity` object to the constructor, like
    we did in `SceneProxy`. Declare two invokable functions and a signal in the new
    class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即这样做。创建 `EntityProxy` 类，从 `QObject` 派生它，并将底层 `Entity` 对象的指针传递给构造函数，就像我们在
    `SceneProxy` 中做的那样。在新的类中声明两个可调用函数和一个信号：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implementation of the methods just forward the calls to the underlying `Entity`
    object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实现只是将调用转发到底层的 `Entity` 对象：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Entity` class will be responsible for creating its own proxy object. Add
    the following private fields to the `Entity` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity` 类将负责创建自己的代理对象。向 `Entity` 类添加以下私有字段：'
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `m_proxy` field will hold the proxy object. The `m_proxyValue` field will
    contain the reference to the same object added to the JS engine. Initialize these
    fields in the constructor:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_proxy` 字段将保存代理对象。`m_proxyValue` 字段将包含添加到 JS 引擎的同一对象的引用。在构造函数中初始化这些字段：'
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We modify the `Entity::setAlive()` function to emit the `killed()` signal when
    the entity is killed:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改 `Entity::setAlive()` 函数，当实体被杀死时发出 `killed()` 信号：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's generally considered bad practice to emit signals from outside the class
    that owns the signal. If the source of the signal is another `QObject`-based class,
    you should create a separate signal in that class and connect it to the destination
    signal. In our case, we cannot do that, since `Entity` is not a `QObject`, so
    we choose to emit the signal directly to avoid further complication.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为，从拥有该信号类的外部发出信号是不良实践。如果信号的来源是另一个基于 `QObject` 的类，你应该在那个类中创建一个单独的信号并将其连接到目标信号。在我们的情况下，我们无法这样做，因为
    `Entity` 不是一个 `QObject`，所以我们选择直接发出信号以避免进一步的复杂化。
- en: 'Create the `proxy()` and `proxyValue()` getters for these fields. We can now
    return to the `SceneProxy` implementation and use the entity proxy:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些字段创建 `proxy()` 和 `proxyValue()` 获取器。我们现在可以回到 `SceneProxy` 的实现并使用实体代理：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What just happened?
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we ask the JS engine to create a new JavaScript array object. Then, we
    iterate over all entities and skip entities that were already killed. We use `QJSValue::setProperty`
    to add the proxy object of each entity to the array. We need to specify the index
    of the new array item, so we create the `arrayIndex` counter and increment it
    after each insertion. Finally, we return the array.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求 JS 引擎创建一个新的 JavaScript 数组对象。然后，我们遍历所有实体并跳过已死亡的实体。我们使用 `QJSValue::setProperty`
    将每个实体的代理对象添加到数组中。我们需要指定新数组项的索引，因此我们创建 `arrayIndex` 计数器并在每次插入后递增。最后，我们返回数组。
- en: 'This function completes the `SceneProxy` class implementation. We just need
    to create a proxy object and add it to the JS engine in the constructor of the
    `Scene` class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数完成了 `SceneProxy` 类的实现。我们只需要在 `Scene` 类的构造函数中创建一个代理对象并将其添加到 JS 引擎中：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Time for action – Loading scripts provided by users
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 加载用户提供的脚本
- en: 'Each player will provide their own strategy script, so the `Scene` class should
    have a field for storing all provided scripts:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个玩家将提供他们自己的策略脚本，因此 `Scene` 类应该有一个字段来存储所有提供的脚本：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s provide the `setScript()` function that accepts the player''s script
    and loads it into the JS engine:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供 `setScript()` 函数，该函数接受玩家的脚本并将其加载到 JS 引擎中：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this function, we try to evaluate the provided code. If the code returned
    a JavaScript object, we put it in the `m_teamScripts` hash table. We expect that
    the provided object has the `step` property containing the function that decides
    the entity's move. The object may also contain the `init` property that will be
    executed at the beginning of the game.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们尝试评估提供的代码。如果代码返回了一个 JavaScript 对象，我们将它放入 `m_teamScripts` 哈希表中。我们期望提供的对象包含一个
    `step` 属性，该属性包含决定实体移动的函数。该对象可能还包含一个 `init` 属性，该属性将在游戏开始时执行。
- en: 'In the `main()` function, we load the scripts from the project''s resources:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们从项目的资源中加载脚本：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `loadFile()` helper function simply loads the content of the file to a
    `QString`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadFile()` 辅助函数简单地加载文件内容到 `QString`：'
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you want to allow users to provide their scripts without needing to recompile
    the project, you can accept the script files from the command-line arguments instead:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想允许用户提供他们的脚本而无需重新编译项目，你可以从命令行参数接受脚本文件：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To set the command-line arguments for your project, switch to the Projects pane,
    select Run in the left column and locate the Command line arguments input box.
    The provided project contains two sample scripts in the `scripts` subdirectory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置项目的命令行参数，切换到项目面板，在左侧列中选择运行，并定位命令行参数输入框。提供的项目在 `scripts` 子目录中包含两个示例脚本。
- en: Time for action – Executing the strategy scripts
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 执行策略脚本
- en: 'First, we need to check whether the player provided an `init` function and
    execute it. We''ll do it in the `Scene::start()` function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查玩家是否提供了一个 `init` 函数并执行它。我们将在 `Scene::start()` 函数中这样做：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this code, we use `isUndefined()` to check whether the code was provided
    and parsed successfully. Next, we use `hasProperty()` to check whether the returned
    object contains the optional `init` function. If we found it, we execute it using
    `QJSValue::call()`. We provide some information about the board by assigning our
    `SceneProxy` instance to the `field` property of the global object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用 `isUndefined()` 来检查代码是否已提供并成功解析。接下来，我们使用 `hasProperty()` 来检查返回的对象是否包含可选的
    `init` 函数。如果我们找到了它，我们将使用 `QJSValue::call()` 来执行它。我们通过将我们的 `SceneProxy` 实例分配给全局对象的
    `field` 属性来提供有关板的信息。
- en: 'The most exciting part is the `step()` function that implements the actual
    game execution. Let''s take a look at it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最激动人心的部分是`step()`函数，它实现了实际的游戏执行。让我们看看它：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'First, we iterate over all entities and skip the killed ones. Next, we use
    `Entity::team()` to determine which player this entity belongs to. We extract
    the corresponding strategy script from the `m_teamScripts` field and extract the
    `step` property from it. Then, we try to call it as a function and pass the current
    entity''s proxy object as an argument. Let''s see what we do with the script output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们遍历所有实体并跳过已死亡的实体。接下来，我们使用`Entity::team()`来确定这个实体属于哪个玩家。我们从`m_teamScripts`字段中提取相应的策略脚本，并从中提取`step`属性。然后，我们尝试将其作为函数调用，并将当前实体的代理对象作为参数传递。让我们看看我们对脚本输出的处理：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We try to interpret the function's return value as an object with `x` and `y`
    properties. If both properties contain numbers, we construct a `QPoint` from them
    and call our `moveEntity()` function that tries to execute the move chosen by
    the strategy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试将函数的返回值解释为一个具有`x`和`y`属性的对象。如果这两个属性都包含数字，我们就从它们中构建一个`QPoint`，并调用我们的`moveEntity()`函数，该函数尝试执行策略选择的移动。
- en: 'We will not blindly trust the value returned by the user''s script. Instead,
    we carefully check whether the move is valid:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会盲目地相信用户脚本返回的值。相反，我们仔细检查移动是否有效：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We check that the new position is in bounds and is not too far from the entity's
    current position. If everything is correct, we execute the move. If another entity
    was on the destination tile, we mark it as killed. The function returns `true`
    if the move was successful.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查新位置是否在范围内，并且是否离实体的当前位置不远。如果一切正常，我们执行移动。如果目的地格子上已经有另一个实体，我们将其标记为已死亡。如果移动成功，函数返回`true`。
- en: That's it! Our game is ready to run. Let's create some strategy scripts to play
    with.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！我们的游戏已经准备好运行。让我们创建一些策略脚本来进行游戏。
- en: Time for action – Writing a strategy script
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 编写策略脚本
- en: 'Our first script will simply select a random move:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一脚本将简单地选择一个随机移动：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Of course, a more intelligent strategy can beat this script. You can find a
    more advanced script in the code bundle. First, when it sees an enemy entity nearby,
    it always goes for the kill. If there is no such enemy, it tries to move away
    from the closest ally, attempting to fill the whole board. This script will easily
    wipe out the randomly moving enemy:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个更智能的策略可以击败这个脚本。你可以在代码包中找到一个更高级的脚本。首先，当它看到附近的敌人实体时，它总是试图杀死它。如果没有这样的敌人，它试图远离最近的盟友，试图填满整个棋盘。这个脚本将轻易地消灭随机移动的敌人：
- en: '![](img/26146c49-3498-414e-b68c-7060c4d5d998.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26146c49-3498-414e-b68c-7060c4d5d998.png)'
- en: Of course, there is always room for improvement. Try to think of a better strategy
    and write a script that can win the game.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，总有改进的空间。试着想出一个更好的策略，并编写一个可以赢得游戏的脚本。
- en: Have a go hero – Extending the game
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 扩展游戏
- en: There are a couple of ways for you to improve the game implementation. For example,
    you can detect when a player has won and display a pop-up message. You can also
    allow an arbitrary number of players. You just need to replace the `TEAM_COUNT`
    constant with a new property in the `Scene` class and define more team colors.
    You can even create a GUI for users to provide their scripts instead of passing
    them as command-line arguments.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以改进游戏实现。例如，你可以检测玩家何时获胜并显示一个弹出消息。你也可以允许任意数量的玩家。你只需要将`TEAM_COUNT`常量替换为`Scene`类中的一个新属性，并定义更多的团队颜色。你甚至可以为用户提供一个GUI，让他们提供脚本而不是作为命令行参数传递。
- en: The scripting environment can also be improved. You can provide more helper
    functions (for example, a function to calculate the distance between two tiles)
    to make creating scripts easier. On the other hand, you can modify the rules and
    reduce the amount of available information so that, for example, each entity can
    only see other entities at a certain distance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本环境也可以得到改进。你可以提供更多的辅助函数（例如，计算两个格子之间距离的函数）来使创建脚本更容易。另一方面，你可以修改规则并减少可用的信息量，例如，每个实体只能看到一定距离内的其他实体。
- en: As discussed earlier, each script has ways to break the global object or emit
    the signals of the exposed C++ objects, affecting the other players. To prevent
    that, you can create a separate `QJSEngine` and a separate set of proxy objects
    for each player, effectively sandboxing them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个脚本都有方法来破坏全局对象或发出暴露的C++对象信号，从而影响其他玩家。为了防止这种情况，你可以为每个玩家创建一个单独的`QJSEngine`和一组单独的代理对象，从而有效地隔离它们。
- en: Python scripting
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 脚本
- en: Qt QML is an environment that is designed to be part of the Qt world. Since
    not everyone knows or likes JavaScript, we will present another language that
    can easily be used to provide scripting environments for games that are created
    with Qt. Just be aware that this will not be an in-depth description of the environment—we
    will just show you the basics that can provide foundations for your own research.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Qt QML 是一个设计为 Qt 世界一部分的环境。由于并非每个人都了解或喜欢 JavaScript，我们将介绍另一种可以轻松用于为使用 Qt 创建的游戏提供脚本环境的语言。只需注意，这不会是环境的深入描述——我们只会展示可以为您自己的研究提供基础的基本知识。
- en: 'A popular language used for scripting is Python. There are two variants of
    Qt bindings that are available for Python: PySide2 and PyQt. PySide2 is the official
    binding that is available under LGPL. PyQt is a third-party library that is available
    under GPL v3 and a commercial license.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 用于脚本的一种流行语言是 Python。Python 有两种针对 Python 的 Qt 绑定可用：PySide2 和 PyQt。PySide2 是在
    LGPL 下可用的官方绑定。PyQt 是一个在 GPL v3 和商业许可证下可用的第三方库。
- en: PyQt is not available under LGPL, so for commercial closed-source products,
    you need to obtain a commercial license from Riverbank computing!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt 不在 LGPL 许可下可用，因此对于商业闭源产品，您需要从 Riverbank computing 获得商业许可证！
- en: These bindings allow you to use the Qt API from within Python—you can write
    a complete Qt application using just Python. However, to call Python code from
    within C++, you will need a regular Python interpreter. Luckily, it is very easy
    to embed such an interpreter in a C++ application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定允许您在 Python 中使用 Qt API——您可以使用 Python 编写完整的 Qt 应用程序。然而，要从 C++ 中调用 Python
    代码，您将需要一个常规的 Python 解释器。幸运的是，在 C++ 应用程序中嵌入这样的解释器非常简单。
- en: 'First, you will need Python installed, along with its development package.
    For example, for Debian-based systems, it is easiest to simply install the `libpythonX.Y-dev`
    package, where `X.Y` stands for the version of Python available in the repository:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装 Python，以及其开发包。例如，对于基于 Debian 的系统，最简单的方法是简单地安装 `libpythonX.Y-dev` 包，其中
    `X.Y` 代表存储库中可用的 Python 版本：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We will use Python 3.5 in our example, but later minor versions should also
    be compatible with our code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 Python 3.5，但稍后的较小版本也应与我们的代码兼容。
- en: 'Then, you need to tell qmake to link your program against the library. For
    Linux, you can use `pkgconfig` to do this automatically:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要告诉 qmake 将您的程序链接到库。对于 Linux，您可以使用 `pkgconfig` 自动完成此操作：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `no_keywords` configuration option tells the build system to disable Qt-specific
    keywords (`signals`, `slots`, and `emit`). We have to do this because Python headers
    use the `slots` identifier that would conflict with the same Qt keyword. You can
    still access the Qt keywords if you write them as `Q_SIGNALS`, `Q_SLOTS`, and
    `Q_EMIT`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`no_keywords` 配置选项告诉构建系统禁用 Qt 特定的关键字（`signals`、`slots` 和 `emit`）。我们必须这样做，因为
    Python 头文件使用 `slots` 标识符，这会与相同的 Qt 关键字冲突。如果您将它们写成 `Q_SIGNALS`、`Q_SLOTS` 和 `Q_EMIT`，您仍然可以访问
    Qt 关键字。'
- en: 'For Windows, you need to manually pass information to the compiler:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，您需要手动将信息传递给编译器：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To call Python code from within a Qt app, the simplest way is to use the following
    code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Qt 应用程序中调用 Python 代码，最简单的方法是使用以下代码：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This code initializes a Python interpreter, then invokes a script by passing
    it directly as a string, and finally, it shuts down the interpreter before invoking
    Qt's event loop. Such code makes sense only for simple scripting. In real life,
    you'd want to pass some data to the script or fetch the result. For that, we have
    to write some more code. As the library exposes the C API only, let's write a
    nice Qt wrapper for it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码初始化一个 Python 解释器，然后通过直接传递字符串来调用脚本，最后在调用 Qt 的事件循环之前关闭解释器。这样的代码只适用于简单的脚本。在现实生活中，您可能希望将一些数据传递给脚本或获取结果。为此，我们需要编写更多的代码。由于库仅公开
    C API，让我们为它编写一个漂亮的 Qt 包装器。
- en: Time for action – Writing a Qt wrapper for embedding Python
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 为嵌入 Python 编写 Qt 包装器
- en: 'As the first task, we will implement the last program using an object-oriented
    API. Create a new console project and add the following class to it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个任务，我们将使用面向对象的 API 实现最后一个程序。创建一个新的控制台项目，并向其中添加以下类：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The implementation file should look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件应如下所示：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, add a `main()` function, as shown in the following snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一个 `main()` 函数，如下面的代码片段所示：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Finally, open the `.pro` file and tell Qt to link with the Python library, as
    was shown earlier.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `.pro` 文件，并告诉 Qt 将其链接到 Python 库，如之前所示。
- en: What just happened?
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We created a class called `QtPython` that wraps the Python C API for us.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `QtPython` 的类，它为我们封装了 Python C API。
- en: Never use a `Q` prefix to call your custom classes, as this prefix is reserved
    for official Qt classes. This is to ensure that your code will never have a name
    clash with future code added to Qt. The Qt prefix, on the other hand, is meant
    to be used with classes that are extensions to Qt. You probably still shouldn't
    use it, but the probability of a name clash is much smaller and yields a lesser
    impact than clashes with an official class. It is best to come up with an application-specific
    prefix or use a namespace.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用 `Q` 前缀来调用你的自定义类，因为这个前缀是为官方 Qt 类保留的。这是为了确保你的代码永远不会与 Qt 中添加的未来代码发生名称冲突。另一方面，Qt
    前缀是用来与 Qt 的扩展类一起使用的。你可能仍然不应该使用它，但名称冲突的概率要小得多，并且影响也小于与官方类的冲突。最好想出一个特定于应用程序的前缀或使用命名空间。
- en: The class constructor creates a Python interpreter, and the class destructor
    destroys it. We use `Py_InitializeEx(0)`, which has the same functionality as
    `Py_Initialize()`, but it does not apply C signal handlers, as this is not something
    we would want when embedding Python. Prior to this, we use `Py_SetProgramName()`
    to inform the interpreter of our context. We also defined a `run()` method, taking
    `QString` and returning `void`. It uses `qPrintable()`, which is a convenience
    function that extracts a C string pointer from a `QString` object, which is then
    fed into `PyRun_SimpleString()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数创建了一个 Python 解释器，而类析构函数则销毁它。我们使用 `Py_InitializeEx(0)`，它具有与 `Py_Initialize()`
    相同的功能，但它不会应用 C 信号处理器，因为在嵌入 Python 时我们并不希望这样做。在此之前，我们使用 `Py_SetProgramName()` 通知解释器我们的上下文。我们还定义了一个
    `run()` 方法，它接受 `QString` 并返回 `void`。它使用 `qPrintable()`，这是一个便利函数，可以从 `QString`
    对象中提取一个 C 字符串指针，然后将其输入到 `PyRun_SimpleString()`。
- en: Never store the output of `qPrintable()`, as it returns an internal pointer
    to a temporary byte array (this is equivalent to calling `toLocal8Bit().constData()`
    on a string). It is safe to use directly, but the byte array is destroyed immediately
    afterward; thus, if you store the pointer in a variable, the data may not be valid
    later when you try using that pointer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要存储 `qPrintable()` 的输出，因为它返回一个指向临时字节数组的内部指针（这相当于在字符串上调用 `toLocal8Bit().constData()`）。它可以安全地直接使用，但字节数组随后立即被销毁；因此，如果你将指针存储在变量中，当你在稍后尝试使用该指针时，数据可能不再有效。
- en: The most difficult work when using embedded interpreters is to convert values
    between C++ and the types that the interpreter expects. With Qt Script, the `QScriptValue`
    type was used for this. We can implement something similar for our Python scripting
    environment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌入式解释器时最困难的工作是将值在 C++ 和解释器期望的类型之间进行转换。在 Qt Script 中，使用了 `QScriptValue` 类型来完成这项工作。我们可以为我们自己的
    Python 脚本环境实现类似的功能。
- en: Time for action – Converting data between C++ and Python
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行数据在 C++ 和 Python 之间的转换操作了
- en: 'Create a new class and call it `QtPythonValue`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类并命名为 `QtPythonValue`：
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, implement the constructors, the assignment operator, and the destructor,
    as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现构造函数、赋值运算符和析构函数，如下所示：
- en: '[PRE66]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, implement the `incRef()` and `decRef()` functions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现 `incRef()` 和 `decRef()` 函数：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, implement conversions from `QtPythonValue` to C++ types:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现从 `QtPythonValue` 到 C++ 类型的转换：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, let''s modify the `main()` function to test our new code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修改 `main()` 函数以测试我们的新代码：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When you run the program, you will see that the conversion between C++ and Python
    works correctly in both directions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到 C++ 和 Python 之间的转换在两个方向上都是正确的。
- en: What just happened?
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The `QtPythonValue` class wraps a `PyObject` pointer (through the `m_value`
    member), providing a nice interface to convert between what the interpreter expects
    and our Qt types. Let''s see how this is done. First, take a look at the three
    private methods: two versions of `incRef()` and one `decRef()`. `PyObject` contains
    an internal reference counter that counts the number of handles on the contained
    value. When that counter drops to 0, the object can be destroyed. Our three methods
    use adequate Python C API calls to increase or decrease the counter in order to
    prevent memory leaks and keep Python''s garbage collector happy.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtPythonValue` 类封装了一个 `PyObject` 指针（通过 `m_value` 成员），提供了一个很好的接口，用于在解释器期望的类型和我们的
    Qt 类型之间进行转换。让我们看看这是如何实现的。首先，看一下三个私有方法：两个版本的 `incRef()` 和一个 `decRef()`。`PyObject`
    包含一个内部引用计数器，它计算包含值的句柄数量。当计数器降到 0 时，对象可以被销毁。我们的三个方法使用适当的 Python C API 调用来增加或减少计数器，以防止内存泄漏并使
    Python 的垃圾回收器保持满意。'
- en: The second important aspect is that the class defines a private constructor
    that takes a `PyObject` pointer, effectively creating a wrapper over the given
    value. The constructor is private; however, the `QtPython` class is declared as
    a friend of `QtPythonValue`, which means that only `QtPython` and `QtPythonValue`
    can instantiate values by passing `PyObject` pointers to it. Now, let's take a
    look at public constructors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要方面是，该类定义了一个私有构造函数，它接受一个 `PyObject` 指针，实际上是在给定的值上创建了一个包装器。构造函数是私有的；然而，`QtPython`
    类被声明为 `QtPythonValue` 的友元，这意味着只有 `QtPython` 和 `QtPythonValue` 可以通过传递 `PyObject`
    指针来实例化值。现在，让我们看看公共构造函数。
- en: The default constructor creates an object pointing to a `None` value, which
    represents the absence of a value. The copy constructor and assignment operator
    are pretty standard, taking care of bookkeeping of the reference counter. Then,
    we have two constructors—one taking `int` and the other taking a `QString` value.
    They use appropriate Python C API calls to obtain a `PyObject` representation
    of the value. Note that these calls already increase the reference count for us,
    so we don't have to do it ourselves.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数创建了一个指向 `None` 值的对象，它表示值的缺失。复制构造函数和赋值运算符相当标准，负责管理引用计数。然后，我们有两个构造函数——一个接受
    `int` 值，另一个接受 `QString` 值。它们使用适当的 Python C API 调用来获取值的 `PyObject` 表示形式。请注意，这些调用已经为我们增加了引用计数，所以我们不需要自己操作。
- en: The code ends with a destructor that decreases the reference counter and three
    methods that provide safe conversions from `QtPythonValue` to appropriate Qt/C++
    types.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以一个析构函数结束，该函数减少引用计数，并提供了三个将 `QtPythonValue` 安全转换为适当的 Qt/C++ 类型的方法。
- en: Have a go hero – Implementing the remaining conversions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英雄尝试 - 实现剩余的转换
- en: Now, you should be able to implement other constructors and conversions for
    `QtPythonValue` that operates on the `float`, `bool`, or even on `QDate` and `QTime`
    types. Try implementing them yourself. If needed, take a look at the Python documentation to
    find appropriate calls that you should use.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够实现其他构造函数和 `QtPythonValue` 的转换，这些转换操作 `float`、`bool`，甚至是 `QDate` 和 `QTime`
    类型。尝试自己实现它们。如果需要，查看 Python 文档以找到您应该使用的适当调用。
- en: The documentation for Python 3.5 is available online at [https://docs.python.org/3.5/](https://docs.python.org/3.5/).
    If you've installed a different Python version, you can find the documentation
    for your version on the same website.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5 的文档可在网上找到，链接为 [https://docs.python.org/3.5/](https://docs.python.org/3.5/)。如果您安装了不同的
    Python 版本，您可以在同一网站上找到您版本的相关文档。
- en: 'We''ll give you a head start by providing a skeleton implementation of how
    to convert `QVariant` to `QtPythonValue`. This is especially important, because
    Python makes use of two types whose equivalents are not available in C++, namely,
    tuples and dictionaries. We will need them later, so having a proper implementation
    is crucial. Here''s the code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个如何将 `QVariant` 转换为 `QtPythonValue` 的框架实现，这尤为重要，因为 Python 使用了两种在 C++ 中没有等效类型的数据类型，即元组和字典。我们稍后会需要它们，因此拥有一个合适的实现至关重要。以下是代码：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The highlighted code shows how to create a tuple (which is a list of arbitrary
    elements) from `QVariantList` and how to create a dictionary (which is an associative
    array) from `QVariantMap`. You should also add a `QtPythonValue` constructor that
    takes `QStringList` and produces a tuple.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码展示了如何从 `QVariantList` 创建一个元组（它是一个任意元素的列表），以及如何从 `QVariantMap` 创建一个字典（它是一个关联数组）。您还应该添加一个接受
    `QStringList` 并生成元组的 `QtPythonValue` 构造函数。
- en: We have written quite a lot of code now, but there is no way of binding any
    data from our programs with Python scripting so far. Let's change that.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了相当多的代码，但到目前为止，我们还没有办法将程序中的任何数据绑定到 Python 脚本。让我们改变这一点。
- en: Time for action – Calling functions and returning values
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 调用函数和返回值
- en: 'The next task is to provide ways to invoke Python functions and return values
    from scripts. Let''s start by providing a richer `run()` API. Implement the following
    method in the `QtPython` class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是提供从脚本中调用 Python 函数和返回值的方法。让我们首先提供一个更丰富的 `run()` API。在 `QtPython` 类中实现以下方法：
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''ll also need a functionality to import Python modules. Add the following
    methods to the class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个导入 Python 模块的功能。向该类添加以下方法：
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The last piece of the code is to extend `QtPythonValue` with this code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分是扩展 `QtPythonValue` 的代码：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, you can modify `main()` to test the new functionality:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以修改 `main()` 函数来测试新的功能：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can replace `/home` with a directory of your choice. Then, you can run the
    program.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `/home` 替换为您选择的目录。然后，您可以运行程序。
- en: What just happened?
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We did two tests in the last program. First, we used the new `run()` method,
    passing to it the code that is to be executed and two dictionaries that define
    the current execution context—the first dictionary contains global symbols and
    the second contains local symbols. The dictionaries come from Python's `__main__`
    module (which, among other things, defines the `print` function). The `run()`
    method may modify the contents of the two dictionaries—the first call defines
    the tuple called `foo`, and the second call prints it to the standard output.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序中，我们进行了两次测试。首先，我们使用了新的 `run()` 方法，将其传递要执行的代码和两个定义当前执行上下文的字典——第一个字典包含全局符号，第二个包含局部符号。这些字典来自
    Python 的 `__main__` 模块（它定义了 `print` 函数等）。`run()` 方法可能会修改这两个字典的内容——第一次调用定义了一个名为
    `foo` 的元组，第二次调用将其打印到标准输出。
- en: The second test calls a function from an imported module; in this case, we call
    two functions from the `os` module—the first function, `chdir`, changes the current
    working directory, and the other, called `getcwd`, returns the current working
    directory. The convention is that we should pass a tuple to `call()`, where we
    pass the needed parameters. The first function takes a string as a parameter;
    therefore, we pass a `QStringList` object, assuming that there is a `QtPythonValue`
    constructor that converts `QStringList` to a tuple (you need to implement it if
    you haven't done it already). Since the second function does not take any parameters,
    we pass an empty tuple to the call. In the same way, you can provide your own
    modules and call functions from them, query the results, inspect dictionaries,
    and so on. This is a pretty good start for an embedded Python interpreter. Remember
    that a proper component should have some error checking code to avoid crashing
    the whole application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试调用了一个导入模块中的函数；在这种情况下，我们调用 `os` 模块中的两个函数——第一个函数 `chdir` 改变当前工作目录，另一个函数 `getcwd`
    返回当前工作目录。惯例是我们应该将一个元组传递给 `call()`，其中我们传递所需的参数。第一个函数接受一个字符串作为参数；因此，我们传递一个 `QStringList`
    对象，假设存在一个 `QtPythonValue` 构造函数，它将 `QStringList` 转换为元组（如果您还没有实现它，则需要实现它）。由于第二个函数不接受任何参数，我们传递一个空元组到调用中。以同样的方式，您可以提供自己的模块并从中调用函数，查询结果，检查字典等。这对于嵌入式
    Python 解释器来说是一个很好的开始。请记住，一个合适的组件应该有一些错误检查代码来避免整个应用程序崩溃。
- en: You can extend the functionality of the interpreter in many ways. You can even
    use PyQt5 to use Qt bindings in scripts, combining Qt/C++ code with Qt/Python
    code.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式扩展解释器的功能。您甚至可以使用 PyQt5 在脚本中使用 Qt 绑定，将 Qt/C++ 代码与 Qt/Python 代码结合。
- en: Have a go hero – Wrapping Qt objects into Python objects
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 勇敢尝试者——将 Qt 对象包装成 Python 对象
- en: At this point, you should be experienced enough to try and implement a wrapper
    for the `QObject` instances to expose signals and slots to Python scripting. If
    you decide to pursue the goal, [https://docs.python.org/3/](https://docs.python.org/3/)
    will be your best friend, especially the section about extending Python with C++.
    Remember that `QMetaObject` provides information about the properties and methods
    of Qt objects and `QMetaObject::invokeMethod()` allows you to execute a method
    by its name. This is not an easy task, so don't be hard on yourself if you are
    not able to complete it. You can always return to it once you gain more experience
    in using Qt and Python.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，您应该已经足够熟练，可以尝试实现一个包装器来暴露 `QObject` 实例的信号和槽到 Python 脚本。如果您决定追求这个目标，[https://docs.python.org/3/](https://docs.python.org/3/)
    将是您的最佳朋友，特别是关于使用 C++ 扩展 Python 的部分。请记住，`QMetaObject` 提供了 Qt 对象的属性和方法信息，`QMetaObject::invokeMethod()`
    允许您通过名称执行方法。这不是一项容易的任务，所以如果您无法完成它，请不要对自己太苛刻。您可以在使用 Qt 和 Python 获得更多经验后随时返回。 '
- en: Before you head on to the next chapter, try testing your knowledge about scripting
    in Qt.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在您进入下一章之前，尝试测试您关于 Qt 脚本的知识。
- en: Pop quiz
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. Which is the method that you can use to execute JavaScript code?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 您可以使用哪个方法来执行 JavaScript 代码？
- en: '`QJSValue::call()`'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJSValue::call()`'
- en: '`QJSEngine::evaluate()`'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJSEngine::evaluate()`'
- en: '`QJSEngine::fromScriptValue()`'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJSEngine::fromScriptValue()`'
- en: Q2\. What is the name of the class that serves as a bridge to exchange data
    between JS engine and C++?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 什么类作为 JS 引擎和 C++ 之间交换数据的桥梁？
- en: '`QObject`'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QObject`'
- en: '`QJSValue`'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJSValue`'
- en: '`QVariant`'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QVariant`'
- en: Q3\. If you want to expose a C++ object to the script, which class must this
    object be derived from?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 如果你想将一个 C++ 对象暴露给脚本，这个对象必须从哪个类派生？
- en: '`QObject`'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QObject`'
- en: '`QJSValue`'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJSValue`'
- en: '`QGraphicsItem`'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`'
- en: Q4\. Which of the following kinds of functions is not available to JavaScript
    code?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 以下哪种类型的函数对 JavaScript 代码不可用？
- en: Signals
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号
- en: '`Q_INVOKABLE` methods'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Q_INVOKABLE` 方法'
- en: Slots
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 槽
- en: Global functions
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局函数
- en: Q5\. When is a `PyObject` instance destroyed?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Q5. `PyObject` 实例何时被销毁？
- en: When its value is set to `Py_None`
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当其值设置为 `Py_None` 时
- en: When its internal reference counter drops to 0
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当其内部引用计数器降至 0 时
- en: When the corresponding `QtPythonValue` is destroyed
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当相应的 `QtPythonValue` 被销毁时
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that providing a scripting environment to your
    games opens up new possibilities. Implementing a functionality using scripting
    languages is usually faster than doing the full write-compile-test cycle with
    C++, and you can even use the skills and creativity of your users who have no
    understanding of the internals of your game engine to make your games better and
    more feature-rich. You were shown how to use `QJSEngine`, which blends the C++
    and JavaScript worlds together by exposing Qt objects to JavaScript and making
    cross-language signal-slot connections. You also learned the basics of scripting
    with Python. There are other scripting languages available (for example, Lua),
    and many of them can be used along with Qt. Using the experience gained in this
    chapter, you should even be able to bring other scripting environments to your
    programs, as most embeddable interpreters offer similar approaches to that of
    Python.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到为你的游戏提供脚本环境可以开启新的可能性。使用脚本语言实现功能通常比使用 C++ 的完整编写-编译-测试周期要快，你甚至可以利用那些不了解你游戏引擎内部结构的用户的技能和创造力，使你的游戏变得更好、功能更丰富。你学习了如何使用
    `QJSEngine`，它通过将 Qt 对象暴露给 JavaScript 并实现跨语言信号-槽连接，将 C++ 和 JavaScript 世界融合在一起。你还学习了使用
    Python 的脚本基础。还有其他脚本语言可用（例如 Lua），并且许多脚本语言都可以与 Qt 一起使用。利用本章获得的经验，你应该甚至能够将其他脚本环境带到你的程序中，因为大多数可嵌入的解释器都提供了类似于
    Python 的方法。
- en: In the next chapter, you will be introduced to Qt Quick—a library for creating
    fluid and dynamic user interfaces. It may not sound like it's related to this
    chapter, but Qt Quick is based on Qt QML. In fact, any Qt Quick application contains
    a `QJSEngine` object that executes JavaScript code of the application. Being familiar
    with this system will help you understand how such applications work. You will
    also be able to apply the skills you've learned here when you need to access C++
    objects from Qt Quick and vice versa. Welcome to the world of Qt Quick.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将介绍 Qt Quick——一个用于创建流畅和动态用户界面的库。它可能听起来与本章无关，但 Qt Quick 基于 Qt QML。实际上，任何
    Qt Quick 应用都包含一个 `QJSEngine` 对象，该对象执行应用程序的 JavaScript 代码。熟悉这个系统将帮助你理解这类应用程序是如何工作的。你还将能够在需要从
    Qt Quick 访问 C++ 对象以及反之亦然时应用你在这里学到的技能。欢迎来到 Qt Quick 的世界。
