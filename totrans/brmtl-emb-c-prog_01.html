<html><head></head><body>
<div><div><div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Setting Up the Tools of the Trade</h1>
			<p>In the world of embedded systems, crafting efficient firmware begins with a clear comprehension of the tools available. This chapter will guide you in establishing a robust development environment, ensuring that you are equipped with all the necessary tools for a comprehensive firmware development experience.</p>
			<p>Central to our discussion is the concept of datasheets. Consider these as the detailed blueprints for any microcontroller, encompassing its capabilities, specifications, and intricate details. However, the challenge often isn’t merely understanding a datasheet but also sourcing the correct datasheets tailored to your specific microcontroller. To address this, I will assist you in pinpointing and understanding both datasheets and user manuals important to our chosen microcontroller.</p>
			<p>As we progress, we’ll delve into the intricacies of setting up our <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) and acknowledging its critical function within the development life cycle. Furthermore, you’ll gain insights into configuring the GNU Arm Embedded Toolchain and OpenOCD. These tools will later empower us to craft our firmware, bypassing the need for an IDE altogether.</p>
			<p>In this chapter, we will explore the following main topics:</p>
			<ul>
				<li>Essential development tools for microcontrollers</li>
				<li>The development board</li>
				<li>Datasheets and manuals – unraveling the details</li>
				<li>Navigating the STM32CubeIDE</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>The following are the prerequisites for the chapter:</p>
			<ul>
				<li>STM32CubeIDE: <a href="https://www.st.com/en/development-tools/stm32cubeide.html">https://www.st.com/en/development-tools/stm32cubeide.html</a></li>
				<li><a id="_idTextAnchor018"/>GNU Arm Embedded Toolchain (<code>gcc-arm-none-eabi-10.3-2021.10-win32.exe</code>): <a href="https://developer.arm.com/downloads/-/gnu-rm">https://developer.arm.com/downloads/-/gnu-rm</a></li>
				<li>OpenOCD: <a href="https://github.com/xpack-dev-tools/openocd-xpack/releases">https://github.com/xpack-dev-tools/openocd-xpack/releases</a></li>
				<li>Notepad++: <a href="https://notepad-plus-plus.org/downloads/v8.5.8/">https://notepad-plus-plus.org/downloads/v8.5.8/</a></li>
				<li>STM32F11 reference manual: <a href="https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf</a></li>
				<li>STM32F411 datasheet: <a href="https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf</a></li>
				<li>NUCLEO-F411 user manual: <a href="https://www.st.com/resource/en/user_manual/um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf">https://www.st.com/resource/en/user_manual/um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf</a></li>
				<li>Cortex-M4 generic user guide: <a href="https://developer.arm.com/documentation/dui0553/latest/">https://developer.arm.com/documentation/dui0553/latest/</a></li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Essential development tools for microcontrollers</h1>
			<p>In this section, we will explore the essential tools that form the backbone of our development process. Understanding these tools is important, as they will be our companions in transforming ideas<a id="_idIndexMarker000"/> into functioning firmware.</p>
			<p>When selecting tools for firmware development, we have two primary options.</p>
			<ul>
				<li>IDEs: An IDE is a unified software<a id="_idIndexMarker001"/> application offering a <strong class="bold">Graphical User Interface</strong> (<strong class="bold">GUI</strong>) tailored to crafting software – in our <a id="_idIndexMarker002"/>context, firmware. Popular IDEs for microcontroller firmware development include the following:</li>
				<li><strong class="bold">Keil uVision (also known as Keil MDK)</strong>: Developed <a id="_idIndexMarker003"/>by ARM Holdings</li>
				<li><strong class="bold">STM32CubeIDE</strong>: Developed by <a id="_idIndexMarker004"/>STMicroelectronics</li>
				<li><strong class="bold">IAR Embedded Workbench</strong>: Developed<a id="_idIndexMarker005"/> by IAR Systems<p class="list-inset">These IDEs boast a GUI-centric design, enabling users to conveniently create new files, build, compile, and step through code lines interactively. For the demonstrations and exercises in this book, we’ll use the STM32CubeIDE. It has all the requisite features and is<a id="_idIndexMarker006"/> generously available for free, without any code size constraints.</p></li>
				<li><code>assemble</code>, <code>compile</code>, and <code>link</code> are often used. In this book, we’ll use the open source GNU Arm Embedded Toolchain. Based on the renowned open source <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>), this integrates a GCC compiler <a id="_idIndexMarker008"/>tailored for ARM, the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) debugger, and several other invaluable ut<a id="_idTextAnchor020"/>ilities.</li>
			</ul>
			<p>In the following section, we will carefully go through the process of setting up our preferred IDE, the STM32CubeIDE.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor021"/>Setting up the STM32CubeIDE</h2>
			<p>Throughout this book, we’ll use<a id="_idIndexMarker009"/> both the STM32CubeIDE <a id="_idIndexMarker010"/>and the GNU Arm Embedded Toolchain to develop our firmware. Leveraging an IDE such as STM32CubeIDE enables us to easily analyze and compare the linker script and startup files, autogenerated by the IDE, against those we’ll construct from the ground up.</p>
			<p>Let’s start by downloading<a id="_idIndexMarker011"/> and installing STM32CubeIDE:</p>
			<ol>
				<li>Launch your web browser and navigate to <a href="http://st.com">st.com</a>.</li>
				<li>Click on <strong class="bold">STM32 Developer Zone</strong>, and then select <strong class="bold">STM32CubeIDE</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_1.jpg" alt="Figure 1.1: The home page of st.com" width="1006" height="694"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: The home page of st.com</p>
			<ol>
				<li value="3">Scroll down to the <strong class="bold">All software versions</strong> section of<a id="_idIndexMarker012"/> the page and click on <strong class="bold">Download Software</strong>. You’ll need to log into your ST account before proceeding with the download.</li>
			</ol>
			<div><div><img src="img/B21914_01_2.jpg" alt="Figure 1.2: The All software versions section of the stm32cubeide page" width="1171" height="268"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: The All software versions section of the stm32cubeide page</p>
			<ol>
				<li value="4">If you don’t have an account, click on <strong class="bold">Login/Register</strong> to sign up. If you already have one, simply log in.</li>
				<li>Complete the registration form with your first name, last name, and email address.</li>
				<li>Click on <code>.zip</code> file will be downloaded into your <code>Downloads</code> folder.</li>
			</ol>
			<p>Let’s install the STM32CubeIDE:</p>
			<ol>
				<li>Unzip the <a id="_idIndexMarker014"/>downloaded package.</li>
				<li>Double-click the <code>st-stm32cubeide</code> file to initiate the installer.</li>
				<li>Retain default settings by clicking <strong class="bold">Next</strong> throughout the setup process.</li>
				<li>On the <strong class="bold">Choose Components</strong> page, ensure that both <strong class="bold">SEGGER J-Link drivers</strong> and <strong class="bold">ST-LINK drivers</strong> are selected. Then, click <strong class="bold">Install</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_3.jpg" alt="Figure 1.3: The installer showing the Choose Components page" width="698" height="547"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: The installer showing the Choose Components page</p>
			<p>Having successfully installed STM32CubeIDE on our computer, we will now proceed to configure our alternate <a id="_idIndexMarker015"/>development tool, the GNU Arm Embedde<a id="_idTextAnchor022"/>d Toolchain.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor023"/>Setting up the GNU Arm Embedded Toolchain</h2>
			<p>In this section, we will go through<a id="_idIndexMarker016"/> the process of setting up the GNU Arm Embedded Toolchain – an important tool for <a id="_idIndexMarker017"/>developing firmware for ARM-based microcontrollers:</p>
			<ol>
				<li>Launch your web browser and navigate to <a href="https://developer.arm.com/downloads/-/gnu-rm">https://developer.arm.com/downloads/-/gnu-rm</a>.</li>
				<li>Scroll down the page to find the download link appropriate for your operating system. For those of you using Windows, like myself, opt for the <code>.exe</code> version. For Linux or macOS users, choose the corresponding <code>.tar</code> file for your operating system.</li>
				<li>After the download completes, double-click the installer to begin the installation process.</li>
				<li>Read through the license agreement. Then, choose to install in the default folder location by clicking <strong class="bold">Install</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_4.jpg" alt="Figure 1.4: The GNU Arm Embedded Toolchain installer" width="715" height="558"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: The GNU Arm Embedded Toolch<a id="_idTextAnchor024"/>ain installer</p>
			<ol>
				<li value="5">When the installation is complete, ensure<a id="_idIndexMarker018"/> that you check the <strong class="bold">Add path to environment </strong><strong class="bold">variable</strong> option.</li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21914_01_5.jpg" alt="Figure 1.5: The installer showing the Add path to environment variable option" width="770" height="597"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: The installer showing the Add path to environment variable option</p>
			<ol>
				<li value="6">Click <strong class="bold">Finish</strong> to <a id="_idIndexMarker019"/>finalize <a id="_idIndexMarker020"/>the setup.</li>
			</ol>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor025"/>Setting up OpenOCD</h2>
			<p>For firmware development<a id="_idIndexMarker021"/> with the GNU Arm Toolchain, OpenOCD plays an integral role, facilitating both the downloading of firmware into our<a id="_idIndexMarker022"/> microcontroller and the debugging of code in real time.</p>
			<p>Let’s set up OpenOCD:</p>
			<ol>
				<li>Launch your web browser and navigate to <a href="https://openocd.org/pages/getting-openocd.html">https://openocd.org/pages/getting-openocd.html</a>.</li>
				<li>Scroll to the section titled <strong class="bold">Unofficial </strong><strong class="bold">binary packages</strong>.</li>
				<li>Click on the link for multiplatform binaries.</li>
			</ol>
			<div><div><img src="img/B21914_01_6.jpg" alt="Figure 1.6: The Unofficial binary packages section" width="963" height="190"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6: The Unofficial binary packages section</p>
			<ol>
				<li value="4">Identify the latest <a id="_idIndexMarker023"/>version compatible with your <a id="_idIndexMarker024"/>operating system. For an exhaustive list, click on <strong class="bold">Show all </strong><strong class="bold">14 assets</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_7.jpg" alt="Figure 1.7: The OpenOCD packages" width="1005" height="565"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7: The OpenOCD packages</p>
			<ol>
				<li value="5">For Windows users, download the <code>win32-x64.zip</code> version. For Linux or macOS users, download the corresponding <code>.tar</code> file for your operating system.</li>
				<li>Once <a id="_idIndexMarker025"/>downloaded, unzip the package.</li>
				<li>Navigate to the extracted folder, and then the <code>bin</code> subfolder. Here, you’ll find the <code>openocd.exe</code> application. This is the application we shall call in the command prompt together <a id="_idIndexMarker026"/>with the specific script of our chosen microcontroller, in order to debug or download code onto the microcontroller.</li>
			</ol>
			<p>Within the <code>xpack-openocd-0.12.0-2</code> | <code>openocd</code> | <code>scripts</code> directory structure, you’ll find scripts tailored for various microcontrollers and development boards.</p>
			<p>Next, we need to add OpenOCD to our environment variables:</p>
			<ol>
				<li>Begin by relocating the entire <code>openocd</code> folder to your <code>Program </code><code>Files</code> directory.</li>
			</ol>
			<div><div><img src="img/B21914_01_8.jpg" alt="Figure 1.8: OpenOCD moved to Program Files, showing the path to the bin folder" width="1140" height="733"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8: OpenOCD moved to Program Files, showing the path to the bin folder</p>
			<ol>
				<li value="2">Copy the path to the <code>openocd </code><code>bin</code> folder.</li>
				<li>Right-click on <strong class="bold">This PC</strong>, and <a id="_idIndexMarker027"/>then choose <strong class="bold">Properties</strong>.</li>
				<li>Search for<a id="_idIndexMarker028"/> and select <strong class="bold">Edit the system </strong><strong class="bold">environment variables</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_9.jpg" alt="Figure 1.9: The This PC properties page" width="1100" height="633"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9: The This PC properties page</p>
			<ol>
				<li value="5">Click the <strong class="bold">Environment Variables</strong> button in the <strong class="bold">System Properties</strong> pop-up window.</li>
			</ol>
			<div><div><img src="img/B21914_01_10.jpg" alt="Figure 1.10: The System Properties pop-up window" width="712" height="779"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10: The System Properties pop-up window</p>
			<ol>
				<li value="6">Under <a id="_idIndexMarker029"/>the <strong class="bold">User variables</strong> section<a id="_idIndexMarker030"/> of the <strong class="bold">Environment Variables</strong> popup, double-click the <strong class="bold">Path</strong> entry.</li>
			</ol>
			<div><div><img src="img/B21914_01_11.jpg" alt="Figure 1.11: The Environment Variables popup" width="800" height="761"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11: The Environment Variables popup</p>
			<ol>
				<li value="7">In the <strong class="bold">Edit environment variable</strong> popup, click on <strong class="bold">New</strong> to create a row for a new path entry.</li>
				<li>Paste the previously<a id="_idIndexMarker031"/> copied OpenOCD<a id="_idIndexMarker032"/> path into this new row.</li>
				<li>Confirm your changes by clicking <strong class="bold">OK</strong> on the various pop-up windows.</li>
			</ol>
			<div><div><img src="img/B21914_01_12.jpg" alt="Figure 1.12: The Edit environment variable popup" width="700" height="665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12: The Edit environment variable popup</p>
			<p>Finally, we have successfully completed the setup process. We have configured two essential, standalone <a id="_idIndexMarker033"/>tools to develop firmware for STM32 microcontrollers – the STM32CubeIDE for an IDE, and the GNU Arm Embedded Toolchain, complemented by OpenOCD, to develop and debug our firmware without an<a id="_idIndexMarker034"/> IDE.</p>
			<p>Next, we will turn our attention to our development board.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor026"/>The development board</h1>
			<p>In this segment of the <a id="_idIndexMarker035"/>chapter, we will delve into the specifications and features of the development board selected for this book.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor027"/>Understanding the role of a development board</h2>
			<p>Firstly, let’s clarify the concept of a <a id="_idIndexMarker036"/>development board. It’s essential to note that a development board is not synonymous with a microcontroller. While a development board might derive part of its name from the microcontroller mounted on it, it would be a misnomer to refer to the board itself as the microcontroller. A development board allows us to validate our firmware on the exact microcontroller variant we aim to deploy in our final product. Consequently, the firmware tested on our development board is assured to operate identically on the microcontroller in the end product. This is why companies such as STMicroelectronics offer a diverse range of development boards, tailored to each microcontroller in their portfolio.</p>
			<p>It’s also essential to contrast the role of a development board with prototyping boards, such as Arduino. While prototyping boards (which might not house the microcontrollers intended for the final product) serve as preliminary testing platforms, development boards elevate this process. They enable us to rigorously test concepts and the performance evaluation of our firmware on the designated microcontroller meant for bulk product manufacturing. For the purposes of this book, our focus will be on the NUCLEO-F411 development board.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor028"/>An overview of the NUCLEO-F411 Development Board</h2>
			<p>The NUCLEO-F411 development<a id="_idIndexMarker037"/> board is equipped with an STM32F411RE microcontroller, capable of a peak operating frequency of 100MHz. It comes with a generous 512 Kbytes of flash memory and 128 Kbytes of SRAM. Furthermore, the board is <a id="_idIndexMarker038"/>equipped with several columns of berg pins, allowing us to effortlessly make connections using jumper wires to interface with a variety of modules and components – from sensors and motors to LEDs. For quick and straightforward input/output firmware tests, the board also features a built-in user button and LED, eliminating the immediate need for external components.</p>
			<div><div><img src="img/B21914_01_13.jpg" alt="Figure 1.13: The NUCLEO-F411 development board" width="755" height="660"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13: The NUCLEO-F411 development board</p>
			<p>Now that we’re familiar with the <a id="_idIndexMarker039"/>development board, let’s delve into the various types of documentation that are essential for a comprehensive understanding and programming<a id="_idTextAnchor029"/> of the<a id="_idIndexMarker040"/> development board.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor030"/>Datasheets and manuals – unraveling the details</h1>
			<p>Our main objective in this book is to write firmware code that interacts directly with the registers of our microcontroller. This means there’s no abstraction or intermediary library between our code and the target microcontroller. To achieve this, it’s important to grasp the internal architecture of the microcontroller, understand the addresses of each register we interact with, and know the functions of relevant bits within those registers. This is where datasheets and manuals come in. Manufacturers provide these documents for users to understand their products, which in our case refers to the microcontroller core architecture, the microcontroller, and the development board.</p>
			<p>Two distinct companies play roles in the making of our development board. The first is ARM Holdings, which licenses processor and microcontroller core architecture designs to semiconductor manufacturing firms such as STMicroelectronics, Texas Instruments, and Renesas. These <a id="_idIndexMarker041"/>manufacturers then produce the physical microcontroller or processor based on the licensed designs from ARM, often with their custom additions. This explains why two different microcontrollers from separate manufacturers might share the same microcontroller core. For instance, both the TM4C123 from Texas Instruments and STM32F4 from STMicroelectronics are based on the ARM Cortex-M4 core.</p>
			<p>Since our chosen development board, the NUCLEO-F411 from STMicroelectronics, is based on the ARM Cortex-M4 microcontroller core, in the following sections, we’ll delve into the documentation for the board, its integrated microcontroller, and the underlying core.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor031"/>Understanding STMicroelectronics’ documentation</h2>
			<p>A significant reason for the<a id="_idIndexMarker042"/> popularity of STM32 microcontrollers is STMicroelectronics’ continued commitment to providing comprehensive support. This includes well-organized documentation and various firmware development resources.</p>
			<p>STMicroelectronics has a range of documents, each following a specific naming convention. Let’s discuss those relevant to our work:</p>
			<ul>
				<li><code>RM</code>, followed by a number. For instance, the RM for our <a id="_idIndexMarker043"/>microcontroller is <code>RM0383</code>. This document details every register in our microcontroller, clarifying each bit’s role and providing insights on register configurations.</li>
				<li><code>STM32F411</code>. This document provides a functional overview of the microcontroller, a complete memory map, a block diagram showcasing the microcontroller’s peripherals and connecting buses, as well as the pinout and electrical characteristics of the microcontroller.</li>
				<li><code>UM</code> and followed by a number, such as <code>UM1724</code> for our NUCLEO-F411, this document focuses on the development board. It describes how components on our board, such as LEDs and buttons, are connected <a id="_idIndexMarker045"/>to specific ports <a id="_idTextAnchor032"/>and pins<a id="_idIndexMarker046"/> of the microcontroller.</li>
			</ul>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor033"/>The generic user guide by ARM</h2>
			<p>ARM provides documents for every microcontroller and processor core they design. Important to our discussion is the <a id="_idIndexMarker047"/>generic user guide for our microcontroller core. As we’re using the STM32F411, which is based on the ARM Cortex-M4 core, we’ll refer to the Cortex-M4 generic user guide.</p>
			<p>This means that if we were using an STM32F7 microcontroller, which is based on the ARM Cortex-M7 core, then we would need to get the Cortex-M7 generic user guide. The naming convention of this document is simply the name of the microcontroller core + the phrase <code>generic </code><code>user guide</code>.</p>
			<p>As the name implies, this document provides information generic to the specific microcontroller core. This means that the information provided in the Cortex-M4 generic user guide applies to all microcontrollers based on the Cortex-M4 core, irrespective of the manufacturers of those microcontrollers. In contrast, the information provided in the STMicroelectronics documentation applies to only STMicroelectronics’ microcontrollers.</p>
			<div><div><img src="img/B21914_01_14.jpg" alt="Figure 1.14: The relationship between the development board, microcontroller, and microcontroller core" width="1583" height="919"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14: The relationship between the development board, microcontroller, and microcontroller core</p>
			<p><em class="italic">Why do we need the generic </em><em class="italic">user guide?</em></p>
			<p>The generic user guide provides information on the core peripherals of the processor core. As the term suggests, these core peripherals are consistent across all microcontrollers, based on a <a id="_idIndexMarker048"/>specific core. The Cortex-M4 core has five core peripherals – the System Timer, Floating-Point Unit, System Control Block, Memory Protection Unit, and the Nested Vectored Interrupt Controller. When developing bare-metal drivers for these peripherals, the generic user guide is the definitive source for the essential details.</p>
			<p>Additionally, the guide provides information on the microcontroller core’s Instruction Set, as well as the Programmer’s Model, Exception Model, fault handling, and power management.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor034"/>Getting the documents</h2>
			<p>To obtain the aforementioned <a id="_idIndexMarker049"/>documents, you can use the following search phrases on Google:</p>
			<ul>
				<li><code>STM32F11 Reference Manual</code> or <code>RM0383</code>.</li>
				<li><code>STM32F411 Datasheet</code>.</li>
				<li><code>Nucleo-F11 User Manual</code> or <code>UM1724</code>.</li>
				<li><code>Cortex-M4 Generic </code><code>User Guide</code></li>
			</ul>
			<p>Direct links to these documents are also available, in the <em class="italic">Technical requirements</em> section of this chapter.</p>
			<p>Before analyzing the key <a id="_idIndexMarker050"/>areas of the various documents to program our development board, let’s first take a closer look at the STM32CubeIDE we installed earlier. We will familiarize ourselves with its features and functionalities in the next section.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor035"/>Navigating the STM32CubeIDE</h1>
			<p>When you launch STM32CubeIDE for the<a id="_idIndexMarker051"/> first time, you’ll see the <strong class="bold">Information Center</strong>. This center offers <a id="_idIndexMarker052"/>quick access to a number of valuable resources for STM32 firmware development.</p>
			<p>To exit the Information Center, simply click the <strong class="bold">X</strong> on its tab. If you wish to revisit it later, simply navigate to <strong class="bold">Help</strong> | <strong class="bold">Information Center</strong>.</p>
			<div><div><img src="img/B21914_01_15.jpg" alt="Figure 1.15: Information Center" width="1120" height="800"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15: Information Center</p>
			<p>The STM32CubeIDE is based on the Eclipse framework, and therefore, the layout and elements are similar to those of other Eclipse-based IDEs.</p>
			<p>Let’s go through <a id="_idIndexMarker053"/>the process of creating a new project:</p>
			<ol>
				<li>Either click <strong class="bold">Create a New STM32 project</strong> in the empty <strong class="bold">Project Explorer</strong> pane or select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">STM32 Project</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_16.jpg" alt="Figure 1.16: A workspace showing an empty Project Explorer pane" width="800" height="684"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16: A workspace showing an empty Project Explorer pane</p>
			<ol>
				<li value="2">You will be presented with the <strong class="bold">Target Selection</strong> window to select the microcontroller <a id="_idIndexMarker054"/>or development board for your project.</li>
				<li>Click the <strong class="bold">Board </strong><strong class="bold">Selector</strong> tab.</li>
				<li>Enter <code>NUCLEO-F411</code> into the <strong class="bold">Commercial Part </strong><strong class="bold">Number</strong> field.</li>
			</ol>
			<div><div><img src="img/B21914_01_17.jpg" alt="Figure 1.17: The Target Selection window" width="1102" height="773"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17: The Target Selection window</p>
			<ol>
				<li value="5">From the displayed board list, select <strong class="bold">NUCLEO-F11RE</strong>, and then click <strong class="bold">Next</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_18.jpg" alt="Figure 1.18: The board list with NUCLEO-F411 selected" width="1500" height="450"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18: The board list with NUCLEO-F411 selected</p>
			<ol>
				<li value="6">Give the<a id="_idIndexMarker055"/> project a name.</li>
				<li>For <strong class="bold">Targeted Project Type</strong>, select <strong class="bold">Empty</strong>.</li>
			</ol>
			<div><div><img src="img/B21914_01_19.jpg" alt="Figure 1.19: The Setup STM32 project window" width="841" height="932"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19: The Setup STM32 project window</p>
			<ol>
				<li value="8">Click <strong class="bold">Finish</strong> to create the project.</li>
			</ol>
			<p>You will see the new project, containing<a id="_idIndexMarker056"/> all the necessary startup files and linker scripts, in the <strong class="bold">Project </strong><strong class="bold">Explorer</strong> pane.</p>
			<div><div><img src="img/B21914_01_20.jpg" alt="Figure 1.20: The Project Explorer pane showing a new project" width="1099" height="507"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20: The Project Explorer pane showing a new project</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor036"/>Understanding the control icons</h1>
			<p>The most frequently used<a id="_idIndexMarker057"/> control icons are the <strong class="bold">New</strong>, <strong class="bold">Build</strong>, and <strong class="bold">Debug</strong> icons.</p>
			<div><div><img src="img/B21914_01_21.jpg" alt="Figure 1.21: The control icons" width="1065" height="190"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21: The control icons</p>
			<p>Let’s look closely at the functions of these icons:</p>
			<ul>
				<li><strong class="bold">The New icon</strong>: This icon allows <a id="_idIndexMarker058"/>us to create various files, including source code, header files, projects, libraries, and <a id="_idIndexMarker059"/>more. This funct<a id="_idTextAnchor037"/>ion is also accessible via <strong class="bold">File</strong> | <strong class="bold">New</strong>.</li>
				<li><strong class="bold">The Build icon</strong>: Used for building<a id="_idIndexMarker060"/> projects. This functionality can also be <a id="_idIndexMarker061"/>accessed by right-clicking on a project and selecting <strong class="bold">Build Project</strong>.</li>
				<li><strong class="bold">The Debug icon</strong>: This<a id="_idIndexMarker062"/> launches a debug configuration to facilitate project debugging. This functionality is<a id="_idIndexMarker063"/> also available by right-clicking a project and selecting <strong class="bold">Debug Project</strong>.</li>
			</ul>
			<p>These control icons provide quick access to essential functions, significantly enhancing productivity and streamlining the development process.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor038"/>Summary</h1>
			<p>In this chapter, we set out to create a robust environment for embedded firmware development, focusing on the careful selection and setup of essential tools. Each tool we selected plays a crucial role in the efficient development of firmware for microcontrollers. We explored the installation processes of STM32CubeIDE, the GNU Arm Embedded Toolchain, and OpenOCD, laying a solid groundwork for our development activities.</p>
			<p>We then introduced the NUCLEO-F411 development board, equipped with an STM32F411RE microcontroller, as our experimental platform, and we spent time identifying some of the components on the board.</p>
			<p>We also emphasized the importance of knowing the different types of datasheets and reference manuals, equipping us with the ability to quickly access detailed information about a microcontroller’s architecture and functionalities.</p>
			<p>Moving on to the next chapter, we will leap into developing our first bare-metal firmware, using only the documentation we have compiled as our guide.</p>
		</div>
	</div>
</div>
</body></html>