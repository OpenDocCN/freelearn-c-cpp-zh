- en: '*Chapter 3*: STL Containers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：STL 容器'
- en: In this chapter, we will focus on the container classes in the STL. In short,
    a *container* is an object that contains a collection of other objects, or *elements*.
    The STL provides a complete suite of container types that form the foundation
    of the STL itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注 STL 中的容器类。简而言之，*容器* 是一个包含其他对象集合或 *元素* 的对象。STL 提供了一套完整的容器类型，这些类型构成了
    STL 本身的基础。
- en: A quick overview of the STL container types
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL 容器类型的快速概述
- en: 'The STL provides a comprehensive set of container types, including *sequential
    containers*, *associative containers*, and *container adapters*. Here''s a brief
    overview:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了一套全面的容器类型，包括 *顺序容器*、*关联容器* 和 *容器适配器*。以下是简要概述：
- en: Sequential containers
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序容器
- en: 'The sequential containers provide an interface where the elements are arranged
    in sequence. While you may use the elements sequentially, some of these containers
    use contiguous storage, and others do not. The STL includes these sequential containers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序容器提供了一个接口，其中元素按顺序排列。虽然您可能按顺序使用元素，但其中一些容器使用连续存储，而另一些则不使用。STL 包括以下顺序容器：
- en: The `array` is a fixed-size sequence that holds a specific number of elements
    in contiguous storage. Once allocated, it cannot change size. This is the simplest
    and fastest contiguous storage container.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array` 是一个固定大小的序列，在连续存储中持有特定数量的元素。一旦分配，它就不能改变大小。这是最简单且最快的连续存储容器。'
- en: The `vector` is like an array that can shrink and grow. Its elements are stored
    contiguously, so changing size may involve the expense of allocating memory and
    moving data. A `vector` may keep extra space in reserve to mitigate that cost.
    Inserting and deleting elements from anywhere other than the *back* of a `vector`
    will trigger realignment of the elements to maintain contiguous storage.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector` 类似于可以收缩和扩展的数组。其元素连续存储，因此改变大小可能涉及分配内存和移动数据的开销。`vector` 可以保留额外的空间以减轻这种成本。从
    `vector` 的 *末尾* 之外的位置插入或删除元素将触发元素的重新排列，以保持连续存储。'
- en: The `list` is a doubly-linked list structure that allows elements to be inserted
    and deleted in constant (*O(1)*) time. Traversing the list happens in linear *O(n)*
    time. A single-linked variant is available as `forward_list`, which only iterates
    forward. A `forward_list` uses less space and is somewhat more efficient than
    a doubly-linked `list`, but lacks some capability.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list` 是一种双向链表结构，允许在常数 (*O(1)*) 时间内插入和删除元素。遍历列表发生在线性 *O(n)* 时间。有一个单链表变体，称为
    `forward_list`，它只能向前迭代。`forward_list` 使用更少的空间，并且比双向链表 `list` 更有效率，但缺乏一些功能。'
- en: The `deque` (commonly pronounced, *deck*) is a `deque` allows random access
    to its elements, much like a `vector`, but does not guarantee contiguous storage.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`（通常发音为 *deck*）允许随机访问其元素，类似于 `vector`，但不保证连续存储。'
- en: Associative containers
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联容器
- en: 'An associative container associates a key with each element. Elements are referenced
    by their key, rather than their position in the container. STL associative containers
    include these containers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器将键与每个元素关联。元素通过其键而不是在容器中的位置进行引用。STL 关联容器包括以下容器：
- en: The `set` is an associative container where each element is also its own key.
    Elements are ordered, usually by some sort of binary tree. Elements in a `set`
    are immutable and cannot be modified, but they can be inserted and removed. Elements
    in a `set` are *unique*, duplicates are not allowed. A `set` iterates in order
    according to its sorting operators.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 是一个关联容器，其中每个元素也是它自己的键。元素按某种二叉树排序。`set` 中的元素是不可变的，不能修改，但可以插入和删除。`set`
    中的元素是 *唯一的*，不允许重复。`set` 按照其排序运算符的顺序迭代。'
- en: The `multiset` is like a `set` with non-unique keys, where duplicates are allowed.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiset` 与 `set` 类似，具有非唯一的键，允许重复。'
- en: The `unordered_set` is like a `set` that does not iterate in order. Elements
    are not sorted in any specific order, but are organized according to their hash
    values for fast access.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_set` 类似于不按顺序迭代的 `set`，元素不按任何特定顺序排序，而是根据它们的哈希值组织以实现快速访问。'
- en: The `unordered_multiset` is like an `unordered_set` with non-unique keys, where
    duplicates are allowed.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_multiset` 类似于具有非唯一键的 `unordered_set`，允许重复。'
- en: The `map` is an associative container for key-value pairs, where each *key*
    is mapped to a specific *value* (or *payload*). The types of the key and value
    may be different. Keys are unique but values are not. A map iterates in order
    of its keys, according to its sorting operators.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 是一个关联容器，用于键值对，其中每个 *键* 都映射到一个特定的 *值*（或 *有效负载*）。键和值的类型可能不同。键是唯一的，但值不是。映射根据其排序运算符按键的顺序迭代。'
- en: The `multimap` is like a `map` with non-unique keys, where duplicate keys are
    allowed.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multimap` 类似于 `map`，但键不是唯一的，允许重复键。'
- en: The `unordered_map` is like a map that does not iterate in order.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_map` 类似于不按顺序迭代的映射。'
- en: The `unordered_multimap` is like an `unordered_map` with non-unique keys, where
    duplicates are allowed.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_multimap` 类似于 `unordered_map`，但键不是唯一的，允许重复。'
- en: Container adapters
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器适配器
- en: 'A container adapter is a class which encapsulates an underlying container.
    The container class provides a specific set of member functions to access the
    underlying container elements. The STL provides these container adapters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适配器是一个封装底层容器的类。容器类提供一组特定的成员函数来访问底层容器元素。STL 提供以下容器适配器：
- en: The `stack` provides a `vector`, `deque`, or `list`. If no underlying container
    is specified, the default is `deque`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stack` 提供了 `vector`、`deque` 或 `list`。如果没有指定底层容器，默认是 `deque`。'
- en: The `queue` provides a `deque` or `list`. If no underlying container is specified,
    the default is `deque`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue` 提供了 `deque` 或 `list`。如果没有指定底层容器，默认是 `deque`。'
- en: The `priority_queue` keeps the greatest value element at the top, according
    to a *strict weak ordering*. It provides a constant time lookup of the greatest
    value element, at the expense of logarithmic time insertion and extraction. The
    underlying container may be one of `vector` or `deque`. If no underlying container
    is specified, the default is `vector`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority_queue` 根据严格的弱排序将最大值元素放在顶部。它以对数时间插入和提取为代价，提供对最大值元素的常数时间查找。底层容器可能是
    `vector` 或 `deque`。如果没有指定底层容器，默认是 `vector`。'
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Use uniform erasure functions to delete items from a container
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统一的删除函数从容器中删除项目
- en: Delete items from an unsorted vector in constant time
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常数时间内从无序向量中删除项目
- en: Access vector elements directly and safely
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接且安全地访问向量元素
- en: Keep vector elements sorted
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持向量元素排序
- en: Efficiently insert elements into a map
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地将元素插入到映射中
- en: Efficiently modify the keys of map items
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效修改映射项的键
- en: Use `unordered_map` with custom keys
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义键的 `unordered_map`
- en: Use set to sort and filter user input
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合对用户输入进行排序和过滤
- en: A simple RPN calculator with deque
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 deque 实现一个简单的 RPN 计算器
- en: A word frequency counter with map
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射实现单词频率计数器
- en: Find long sentences with a vector of vectors
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用向量数组查找长句子
- en: A ToDo list using multimap
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多映射的待办事项列表
- en: Technical requirements
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03)。
- en: Use uniform erasure functions to delete items from a container
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统一的删除函数从容器中删除项目
- en: 'Before C++20, the *erase-remove idiom* was commonly used to efficiently delete
    elements from an STL container. This was a little cumbersome, but not a great
    burden. It was common to use a function like this for the task:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，*erase-remove 习语* 通常用于高效地从 STL 容器中删除元素。这有点繁琐，但并不算太大的负担。通常使用如下这样的函数来完成这项任务：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `std::remove()` function is from the `<algorithms>` header. `std::remove()`
    searches for the specified value and removes it by shifting elements forward from
    the end of the container. It does not change the size of the container. It returns
    an iterator past the end of the shifted range. We then call the container's `erase()`
    function to delete the remaining elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::remove()` 函数来自 `<algorithms>` 头文件。`std::remove()` 搜索指定的值，并通过从容器末尾向前移动元素来删除它。它不会改变容器的大小。它返回一个指向移动范围末尾之后的迭代器。然后我们调用容器的
    `erase()` 函数来删除剩余的元素。'
- en: 'This two-step process is now reduced to one step with the new uniform erasure
    function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个两步过程现在通过新的统一删除函数简化为一步：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This one function call does the same thing as the `remove_value()` function
    we wrote above.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用与上面我们编写的 `remove_value()` 函数做的是同样的事情。
- en: 'There''s also a version that uses a predicate function. For example, to remove
    all even numbered values from a numeric container:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个使用谓词函数的版本。例如，从数值容器中移除所有偶数编号的值：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's look at the uniform erasure functions in a bit more detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看统一擦除函数。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are two forms of the uniform erasure functions. The first form, called
    `erase()`, takes two parameters, a container and a value:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 统一擦除函数有两种形式。第一种形式，称为 `erase()`，接受两个参数，一个容器和一个值：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The container may be any of the sequential containers (`vector`, `list`, `forward_list`,
    `deque`), except `array`, which cannot change size.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以是任何顺序容器（`vector`、`list`、`forward_list`、`deque`），但不能是 `array`，因为 `array`
    不能改变大小。
- en: 'The second form, called `erase_if()`, takes a container and a predicate function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式，称为 `erase_if()`，接受一个容器和一个谓词函数：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This form works with any of the containers that work with `erase()`, plus the
    associative containers, `set`, `map`, and their multi-key and unordered variants.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式与任何可以与 `erase()` 一起工作的容器以及关联容器 `set`、`map` 及其多键和无序变体一起工作。
- en: The functions `erase()` and `erase_if()` are defined, as non-member functions,
    in the header for the corresponding container. There is no need to include another
    header.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `erase()` 和 `erase_if()` 作为非成员函数定义在相应容器的头文件中。不需要包含另一个头文件。
- en: 'Let''s look at some examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: 'First, let''s define a simple function to print the size and elements of a
    sequential container:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个简单的函数来打印顺序容器的尺寸和元素：
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `printc()` function uses the C++20 `format()` function to format a string
    for `cout`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`printc()` 函数使用 C++20 的 `format()` 函数来格式化字符串以供 `cout` 使用。'
- en: 'Here''s a `vector` with 10 integer elements, printed with our `printc()` function:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个包含 10 个整数元素的 `vector`，使用我们的 `printc()` 函数打印：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We see that the vector has 10 elements. Now we can use `erase()` to remove
    all elements with the value `5`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到向量有 10 个元素。现在我们可以使用 `erase()` 来移除所有具有值 `5` 的元素：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `vector` version of the `std::erase()` function is defined in the `<vector>`
    header. After the `erase()` call, the element with the value 5 has been removed
    and the vector has 9 elements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::erase()` 函数的 `vector` 版本定义在 `<vector>` 头文件中。在 `erase()` 调用之后，值为 5 的元素已被移除，并且向量中有
    9 个元素。'
- en: 'This works just as well with a `list` container:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与 `list` 容器一样有效：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `list` version of the `std::erase()` function is defined in the `<list>`
    header. After the `erase()` call, the element with the value `5` has been removed
    and the `list` has 9 elements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::erase()` 函数的 `list` 版本定义在 `<list>` 头文件中。在 `erase()` 调用之后，具有值 `5` 的元素已被移除，并且列表中有
    9 个元素。'
- en: 'We can use `erase_if()` to remove all the even numbered elements with a simple
    predicate function:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `erase_if()` 通过简单的谓词函数来移除所有偶数编号的元素：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `erase_if()` function also works with associative containers, like `map`:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`erase_if()` 函数也可以与关联容器（如 `map`）一起使用：'
- en: '[PRE14]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because each element of a `map` is returned as a `pair`, we need a different
    function to print them. The `print_assoc()` function unpacks the `pair` elements
    with a *structured binding* in the `for` loop. We also use a structured binding
    in the predicate function of `erase_if()` to isolate the key for filtering the
    even numbered elements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `map` 的每个元素都作为 `pair` 返回，所以我们需要一个不同的函数来打印它们。`print_assoc()` 函数在 `for` 循环中使用
    *结构化绑定* 来解包 `pair` 元素。我们还在 `erase_if()` 的谓词函数中使用结构化绑定来隔离键以过滤偶数编号的元素。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `erase()` and `erase_if()` functions are simply wrappers that perform the
    *erase-remove idiom* in one step. They perform the same operations as a function,
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`erase()` 和 `erase_if()` 函数只是执行 *erase-remove 习语* 的包装器，一步完成。它们执行与函数相同的操作，如下所示：'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we consider a simple `vector` of `int`, called `vec`, with the following
    values:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑一个简单的 `int` 类型的 `vector`，称为 `vec`，具有以下值：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can visualize `vec` as a one-row table of `int` values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `vec` 可视化为一个包含 `int` 值的单行表：
- en: '![Figure 3.1 – begin() and end() iterators'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – begin() 和 end() 迭代器'
- en: '](img/B18267_03_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_03_01.jpg)'
- en: Figure 3.1 – begin() and end() iterators
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – begin() 和 end() 迭代器
- en: The `begin()` iterator points at the first element, and the `end()` iterator
    points *past* the last element. This configuration is standard for all STL sequential
    containers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()` 迭代器指向第一个元素，而 `end()` 迭代器指向最后一个元素之后。这种配置是所有 STL 顺序容器的标准配置。'
- en: 'When we call `remove(c.begin(), c.end(), 5)`, the algorithm searches for matching
    elements, starting at the `begin()` iterator. For each matching element that it
    finds, it shifts the next element into its place. It continues searching and shifting
    until it reaches the `end()` iterator. The result is a container where all the
    remaining elements are at the beginning, without the deleted elements, and in
    their original order. The `end()` iterator is unchanged and the remaining elements
    are *undefined*. We can visualize the operation like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `remove(c.begin(), c.end(), 5)` 时，算法从 `begin()` 迭代器开始搜索匹配的元素。对于它找到的每个匹配元素，它将下一个元素移入其位置。它继续搜索和移动，直到达到
    `end()` 迭代器。结果是容器，其中所有剩余的元素都在开头，没有删除的元素，并且保持原始顺序。`end()` 迭代器保持不变，剩余的元素是 *未定义*
    的。我们可以这样可视化操作：
- en: '![Figure 3.2 – Removing an element'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 移除一个元素'
- en: '](img/B18267_03_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 移除一个元素](img/B18267_03_02.jpg)'
- en: Figure 3.2 – Removing an element
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 移除一个元素
- en: 'The `remove()` function returns an iterator (`remove_it`) that points to the
    first element *past* the elements that were shifted. The `end()` iterator remains
    as it was before the `remove()` operation. To further illustrate, if we were to
    remove all even-numbered elements using `remove_if()`, our result would look like
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()` 函数返回一个迭代器 (`remove_it`)，它指向移除元素后第一个元素。`end()` 迭代器保持 `remove()` 操作前的状态。为了进一步说明，如果我们使用
    `remove_if()` 移除所有偶数元素，我们的结果将如下所示：'
- en: '![Figure 3.3 – After removing even-numbered elements'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 移除偶数元素后的结果'
- en: '](img/B18267_03_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 移除偶数元素后的结果'
- en: Figure 3.3 – After removing even-numbered elements
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 移除偶数元素后的结果
- en: In this case, all that remains is the five odd-numbered elements followed by
    five elements of *undefined* value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，剩下的只有五个奇数元素，然后是五个 *未定义* 值的元素。
- en: 'The container''s `erase()` function is then called to erase the remaining elements:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用容器的 `erase()` 函数来擦除剩余的元素：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The container's `erase()` function is called with the `remove_it` and `end()`
    iterators to delete all the undefined elements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的 `erase()` 函数使用 `remove_it` 和 `end()` 迭代器调用，以删除所有未定义的元素。
- en: The `erase()` and `erase_if()` functions call both the `remove()` function and
    the container's `erase()` function, in order to perform the *erase-remove idiom*
    in one step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`erase()` 和 `erase_if()` 函数调用 `remove()` 函数和容器的 `erase()` 函数，以便在一步中执行 *erase-remove
    习语*。'
- en: Delete items from an unsorted vector in constant time
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在常数时间内从无序向量中删除项目
- en: Using the uniform erasure functions (or the *erase-remove idiom*) to delete
    items from the middle of a vector takes *O(n)* (*linear*) time. This is because
    elements must be shifted from the end of the vector to close the gap of the deleted
    items. If the order of items in the vector is not important, we can optimize this
    process to take *O(1)* (*constant*) time. Here's how.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用统一的擦除函数（或 *erase-remove 习语*）从向量中间删除项目需要 *O(n)*（线性）时间。这是因为必须将向量末尾的元素移动以关闭被删除项目留下的空隙。如果向量中项目的顺序不重要，我们可以优化此过程以在
    *O(1)*（常数）时间内完成。下面是如何做到这一点。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: This recipe takes advantage of the fact that removing an element from the end
    of a vector is quick and easy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法利用了从向量末尾移除元素既快又简单的事实。
- en: 'Let''s start by defining a function to print out a vector:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们首先定义一个函数来打印向量：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our `main()` function we define a vector of `int` and print it using `printc()`:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们定义一个 `int` 类型的向量并使用 `printc()` 打印它：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we''ll write the function that will delete an element from the vector:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们将编写一个函数来从向量中删除一个元素：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `quick_delete()` function takes two arguments, a vector `v` and an index
    `idx`. We first check to make sure our index is within boundaries. Then we call
    the `move()` function from the `<algorithms>` header to move the last element
    of the vector to the position of our index. Finally, the `v.pop_back()` function
    is called to shorten the vector from the back.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_delete()` 函数接受两个参数，一个向量 `v` 和一个索引 `idx`。我们首先检查确保我们的索引在边界内。然后我们调用 `<algorithms>`
    头文件中的 `move()` 函数，将向量的最后一个元素移动到我们的索引位置。最后，调用 `v.pop_back()` 函数从后面缩短向量。'
- en: Let's also include a version of `quick_delete()` for use with an iterator instead
    of an index.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们还包括一个 `quick_delete()` 的版本，用于使用迭代器而不是索引。
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This version of `quick_delete()` operates from an iterator instead of an index.
    Otherwise, it works the same as the indexed version.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `quick_delete()` 从迭代器而不是索引开始操作。否则，它的工作方式与索引版本相同。
- en: 'Now we can call it from our `main()` function:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以从我们的`main()`函数中调用它：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And the output will look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first call to `quick_delete()` uses an iterator from the `std::ranges::find()`algorithm.
    This deletes the value `47` from the vector. Notice the value from the back of
    the vector (`19`) takes its place. The second call to `quick_delete()` uses an
    index (`1`) to delete the second element from the vector (`196`). Again, the value
    from the back of the vector takes its place.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_delete()`的第一个调用使用`std::ranges::find()`算法的迭代器。这将从向量中删除值`47`。注意向量末尾的值(`19`)取而代之。`quick_delete()`的第二次调用使用索引(`1`)从向量中删除第二个元素(`196`)。同样，向量末尾的值取而代之。'
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `quick_delete()` function uses a simple trick to delete elements from a
    vector quickly and efficiently. The element at the back of the vector is moved
    (*not copied*) into the position of the element to be deleted. The deleted element
    is discarded in the process. Then, the `pop_back()` function shortens the vector
    by one element from the end.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_delete()`函数使用一个简单的技巧来快速有效地从向量中删除元素。向量末尾的元素被移动(*不是复制*)到要删除的元素的位置。在这个过程中，被删除的元素被丢弃。然后，`pop_back()`函数从末尾缩短向量一个元素。'
- en: This takes advantage of the fact that deleting the element at the back of the
    vector is especially cheap. The `pop_back()` function operates at constant complexity,
    as it only needs to change the `end()` iterator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了删除向量末尾元素特别便宜的事实。`pop_back()`函数以常数复杂度运行，因为它只需要更改`end()`迭代器。
- en: 'This diagram shows the state of the vector before and after the `quick_delete()`
    operation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了`quick_delete()`操作前后向量的状态：
- en: '![Figure 3.4 – Before and after quick_delete()'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – quick_delete()前后]'
- en: '](img/B18267_03_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18267_03_04.jpg]'
- en: Figure 3.4 – Before and after quick_delete()
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – quick_delete()前后
- en: The `quick_remove()` operation simply *moves* the element from the back of the
    vector into the position of the iterator (`it`), then shortens the vector by one
    element. It's important to use `std::move()` instead of an assignment to move
    the element. The move operation is much faster than a copy-assignment, especially
    for large objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_remove()`操作简单地将向量末尾的元素移动到迭代器(`it`)的位置，然后通过缩短向量来减少一个元素。使用`std::move()`而不是赋值来移动元素是很重要的。移动操作比复制赋值快得多，尤其是对于大对象。'
- en: If you don't require ordered elements, this is an extremely efficient technique.
    It happens in constant (*O(1)*) time and without touching any other elements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要有序元素，这是一个非常高效的技巧。它发生在常数时间(*O(1)*)，并且不触及任何其他元素。
- en: Access vector elements directly and safely
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接且安全地访问向量元素
- en: 'The `vector` is one of the most widely used containers in the STL, and for
    good reason. It''s just as convenient as an `array` but far more powerful and
    flexible. It''s common practice to use the `[]` operator to access elements in
    a vector like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`是STL中最广泛使用的容器之一，原因很好。它使用起来与`array`一样方便，但功能更强大，更灵活。通常的做法是使用`[]`运算符以这种方式访问向量中的元素：'
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `vector` class also provides a member function for the same purpose:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类还提供了一个用于相同目的的成员函数：'
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is the same but there is an important difference. The `at()` function
    does bounds checking and the `[]` operator does not. This is intentional, as it
    allows the `[]` operator to maintain compatibility with the original C-array.
    Let's examine this in a bit more detail.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相同，但有一个重要的区别。`at()`函数会进行边界检查，而`[]`运算符则不会。这是故意的，因为它允许`[]`运算符与原始C数组保持兼容。让我们更详细地考察一下这一点。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: There are two ways to access an element with an index in a vector. The `at()`
    member function does bounds checking, and the `[]` operator does not.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 访问向量中具有索引的元素有两种方式。`at()`成员函数会进行边界检查，而`[]`运算符则不会。
- en: 'Here''s a simple `main()` function that initializes a vector and accesses an
    element:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个简单的`main()`函数，它初始化一个向量并访问一个元素：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, I used the `[]` operator to directly access the third element in the vector.
    As with most sequential objects in C++, the index starts at `0` so the third element
    is number `2`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了`[]`运算符直接访问向量的第三个元素。与C++中大多数顺序对象一样，索引从`0`开始，所以第三个元素是数字`2`。
- en: 'The vector has five elements, numbered `0` through `4`. If I were to try to
    access element number `5` that would be beyond the boundary of the vector:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量有五个元素，编号从`0`到`4`。如果尝试访问编号为`5`的元素，这将超出向量的边界：
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This result is extremely deceiving. It's a common error, since humans tend to
    count from 1, not 0\. But there is no guarantee that an element past the end of
    the vector has any particular value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果极具误导性。这是一个常见的错误，因为人类倾向于从 1 开始计数，而不是从 0 开始。但是，无法保证向量的末尾之后的元素有任何特定的值。
- en: 'Even worse, the `[]` operator will silently allow you to *write* to a position
    beyond the end of the vector:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更糟糕的是，`[]` 操作符会静默地允许你向向量的末尾之后的位置 *写入*：
- en: '[PRE31]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I have now written to memory that is not under my control and the compiler has
    *silently* allowed it, with no error messages or crashes. But do not be fooled—this
    is extremely dangerous code, and it *will* cause problems at some point in the
    future. Out of bounds memory access is one of the primary causes of security breaches.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经写入了我无法控制的内存，编译器 *静默地* 允许了它，没有任何错误信息或崩溃。但不要被骗——这是一段极其危险的代码，*将会* 在未来的某个时刻引起问题。越界内存访问是安全漏洞的主要原因之一。
- en: 'The solution is to use the `at()` member function wherever possible, instead
    of the `[]` operator:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案是在可能的情况下使用 `at()` 成员函数，而不是使用 `[]` 操作符：
- en: '[PRE32]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we get a run-time exception:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一个运行时异常：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code compiles without error, but the `at()` function checks the boundaries
    of the container and throws a *run-time exception* when you try to access memory
    outside of those boundaries. This is the exception message from code compiled
    with the GCC compiler. The message will be different in different environments.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译没有错误，但 `at()` 函数会检查容器的边界，并在你尝试访问这些边界之外的内存时抛出一个 *运行时异常*。这是使用 GCC 编译器编译的代码的异常信息。在不同的环境中，信息可能会有所不同。
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `[]` operator and the `at()` member function do the same job; they provide
    direct access to container elements based on their indexed position. The `[]`
    operator does it without any bounds checking, so it may be a tiny bit faster in
    some intensely iterative applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]` 操作符和 `at()` 成员函数执行相同的工作；它们根据索引位置提供对容器元素的直接访问。`[]` 操作符不进行边界检查，因此在某些密集迭代的程序中可能会稍微快一点。'
- en: That said, the `at()` function *should be your default choice*. While the bounds
    checking may take a few CPU cycles, it's cheap insurance. For most applications
    the benefit is well worth the cost.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`at()` 函数 *应该是你的默认选择*。虽然边界检查可能会占用几个 CPU 周期，但这是一种低成本的保险。对于大多数应用程序来说，这种好处远远值得这种成本。
- en: While the `vector` class is commonly used as a direct-access container, the
    `array` and `deque` containers also support both the `[]` operator and the `at()`
    member function. These caveats apply there as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `vector` 类通常用作直接访问容器，但 `array` 和 `deque` 容器也支持 `[]` 操作符和 `at()` 成员函数。这些注意事项同样适用。
- en: There's more…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In some applications you may not want your application to just *crash* when
    an out-of-bounds condition is encountered. In this case, you can *catch* the exception,
    like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，你可能不希望当遇到越界条件时，你的应用程序只是 *崩溃*。在这种情况下，你可以 *捕获* 这个异常，如下所示：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `try` block catches the exception specified in the `catch` clause, in this
    case the exception is `std::out_of_range`. The `e.what()` function returns a C-string
    with the error message from the STL library. Each library will have different
    messages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 块捕获了 `catch` 子句中指定的异常，在这种情况下，异常是 `std::out_of_range`。`e.what()` 函数返回一个包含
    STL 库错误信息的 C 字符串。每个库都会有不同的信息。'
- en: Keep in mind that this also applies to `array` and `deque` containers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这也适用于 `array` 和 `deque` 容器。
- en: Keep vector elements sorted
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持向量元素排序
- en: The `vector` is a sequential container that keeps elements in the order in which
    they were inserted. It does not sort elements, nor change their order in any way.
    Other containers, such as `set` and `map`, keep elements sorted, but those containers
    are not random-access and may not have the features you need. You can, however,
    keep your vector sorted. It just requires a little bit of management.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 是一个顺序容器，它按照元素插入的顺序保持元素。它不会对元素进行排序，也不会以任何方式改变它们的顺序。其他容器，如 `set` 和 `map`，会保持元素排序，但这些容器不是随机访问的，可能没有你需要的功能。然而，你可以保持你的向量排序。这只需要一点管理。'
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: The idea with this recipe is to create a simple function, `insert_sorted()`,
    that inserts an element into the correct position in a vector to keep the vector
    sorted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的想法是创建一个简单的函数，`insert_sorted()`，将元素插入到向量中的正确位置以保持向量排序。
- en: 'For convenience, we''ll start with a *type alias* for a vector of strings:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便，我们将从一个字符串向量的 `type alias` 开始：
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I like a type alias here because the exact details of the vector are not so
    important as its application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在这里使用类型别名，因为向量的具体细节并不那么重要，重要的是它的应用。
- en: 'Then we can define a couple of support functions:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们可以定义几个辅助函数：
- en: '[PRE37]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `printv()` function is simple enough; it prints the elements of the vector
    on one line.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`printv()` 函数很简单；它在一行上打印向量的元素。'
- en: The `psorted()` function uses the *ranges* version of the `is_sorted()` algorithm
    to tell us if the vector is sorted. Then it calls `printv()` to print the vector.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`psorted()` 函数使用 `is_sorted()` 算法的 *ranges* 版本来告诉我们向量是否已排序。然后它调用 `printv()`
    来打印向量。'
- en: 'Now we can initialize a `Vstr` vector in our `main()` function:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `main()` 函数中初始化一个 `Vstr` 向量：
- en: '[PRE38]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At this point we have a `Vstr` vector with the names of some interesting musicians,
    in no particular order.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个包含一些有趣音乐家名字的 `Vstr` 向量，没有任何特定的顺序。
- en: Let's sort our vector using the `ranges` version of the `sort()` algorithm.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们使用 `sort()` 算法的 ranges 版本来排序我们的向量。
- en: '[PRE40]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this point, we want to be able to insert items into the vector so that they''re
    already in sorted order. The `insert_sorted()` function does this for us:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，我们希望能够在向量中插入项目，使它们已经按顺序排列。`insert_sorted()` 函数为我们做到了这一点：
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `insert_sorted()` function uses the *ranges* version of the `lower_bound()`
    algorithm to get an iterator for the `insert()` function that keeps the vector
    sorted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_sorted()` 函数使用 `lower_bound()` 算法的 *ranges* 版本来获取 `insert()` 函数的迭代器，以保持向量排序。'
- en: 'Now we can use the `insert_sorted()` function to insert more musicians into
    the vector:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `insert_sorted()` 函数将更多音乐家插入到向量中：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `insert_sorted()` function is used to insert elements into a sorted vector
    while maintaining its order:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_sorted()` 函数用于在保持其顺序的同时将元素插入到有序向量中：'
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `lower_bound()` algorithm finds the first element *not less than* the argument.
    We then use the iterator returned by `lower_bound()` to insert an element at the
    correct position.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower_bound()` 算法找到第一个不小于参数的元素。然后我们使用 `lower_bound()` 返回的迭代器在正确的位置插入一个元素。'
- en: In this case we're using the ranges version of `lower_bound()`, but either version
    will work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `lower_bound()` 的 ranges 版本，但两种版本都可以工作。
- en: There's more…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The `insert_sorted()` function can be made more generic by using a template.
    This version will work with other container types, such as `set`, `deque`, and
    `list`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板可以使 `insert_sorted()` 函数更加通用。这个版本将支持其他容器类型，例如 `set`、`deque` 和 `list`。
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Keep in mind that the `std::sort()` algorithm (and its derivatives) requires
    a container that supports random access. Not all STL containers fulfill this requirement.
    Notably, `std::list` does not.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`std::sort()` 算法（及其衍生算法）需要一个支持随机访问的容器。并非所有 STL 容器都满足此要求。值得注意的是，`std::list`
    不满足。
- en: Efficiently insert elements into a map
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效地将元素插入到映射中
- en: The `map` class is an associative container that holds *key-value pairs*, where
    keys must be unique within the container.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 类是一个关联容器，它包含 *键值对*，其中键必须在容器内是唯一的。'
- en: 'There are a number of ways to populate a map container. Consider a `map` defined
    like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以填充映射容器。考虑一个如下定义的 `map`：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can add an element with the `[]` operator:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `[]` 操作符添加一个元素：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can use the `insert()` member function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `insert()` 成员函数：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or, you can use the `emplace()` member function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用 `emplace()` 成员函数：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: I tend to gravitate toward the `emplace()` function. Introduced with C++11,
    `emplace()` uses *perfect forwarding* to **emplace** (create in place) the new
    element for the container. The parameters are forwarded directly to the element
    constructors. This is quick, efficient, and easy to code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于使用 `emplace()` 函数。自 C++11 引入以来，`emplace()` 使用 **完美转发** 来 **emplace**（就地创建）容器中的新元素。参数直接转发到元素构造函数。这既快又高效，且易于编码。
- en: Though it's certainly an improvement over the other options, the problem with
    `emplace()` is that it constructs an object even when it's not needed. This involves
    calling the constructors, allocating memory, and moving data around, and then
    discarding that temporary object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实比其他选项有所改进，但 `emplace()` 的问题在于即使不需要也会构造一个对象。这涉及到调用构造函数、分配内存以及移动数据，然后丢弃这个临时对象。
- en: To solve this problem, C++17 provides the new `try_emplace()` function which
    only constructs the *value object* if it's needed. This is especially important
    with large objects or many emplacements.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C++17提供了新的`try_emplace()`函数，它只有在需要时才构造值对象。这对于大型对象或许多插入操作尤为重要。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Each element of a *map* is a key-value *pair*. Within the pair structure, the
    elements are named, `first` and `second`, but their purpose in the map is *key*
    and *value*. I tend to think of the value object as the *payload*, as this is
    usually the point of the map. To search for an existing key, the `try_emplace()`
    function must construct the key object; this cannot be avoided. But it need not
    construct the payload object unless and until it's needed for insertion into the
    map.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的每个元素都是一个键值对。在键值对结构中，元素被命名为`first`和`second`，但它们在映射中的目的是键和值。我倾向于将值对象视为有效载荷，因为这通常是映射的目的。为了搜索现有的键，`try_emplace()`函数必须构造键对象；这是不可避免的。但除非需要将其插入映射中，否则它不需要构造有效载荷对象。
- en: How to do it…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'The new `try_emplace()` function avoids the overhead of constructing the *payload
    object* unless and until it is needed. This creates a valuable efficiency in the
    case of key collisions, especially with large payloads. Let''s take a look:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`try_emplace()`函数避免了在不需要时构造有效载荷对象的开销。这在键冲突的情况下特别有用，尤其是对于大型有效载荷。让我们看看：
- en: 'First, we create a payload class. For demonstration purposes, this class has
    a simple `std::string` payload and displays a message when constructed:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个有效载荷类。为了演示目的，这个类有一个简单的`std::string`有效载荷，并在构造时显示一条消息：
- en: '[PRE51]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This `BigThing` class has only one member function, a constructor that displays
    a message when the object is constructed. We'll use this to keep track of how
    often a `BigThing` object is constructed. In practice, of course, this class would
    be bigger, and use more resources.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`BigThing`类只有一个成员函数，即一个在对象构造时显示消息的构造函数。我们将使用这个来跟踪`BigThing`对象被构造的频率。当然，在实际应用中，这个类会更大，并使用更多资源。
- en: Each map element will consist of a pair of objects, a `std::string` for the
    key and a `BigThing` object for the payload. `Mymap` is just a convenience alias.
    This allows us to focus on function rather than form.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个映射元素将包含一对对象，一个用于键的`std::string`和一个用于有效载荷的`BigThing`对象。`Mymap`只是一个便利别名。这允许我们关注函数而不是形式。
- en: 'We''ll also create a `printm()` function to print the contents of the map:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将创建一个`printm()`函数来打印映射的内容：
- en: '[PRE52]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This uses the C++20 `format()` function to print out the map, so we can keep
    track of the elements as we insert them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了C++20的`format()`函数来打印映射，这样我们可以在插入元素时跟踪它们。
- en: 'In our `main()` function we create the map object and insert some elements:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们创建映射对象并插入一些元素：
- en: '[PRE53]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our output shows the construction of each of the payload objects, and then the
    output from the `printm()` function call.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出显示了每个有效载荷对象的构造，然后是`printm()`函数调用的输出。
- en: 'I used the `emplace()` function to add the elements to the map, and each payload
    element was constructed just once. We can use the `try_emplace()` function and
    the result will be the same:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用了`emplace()`函数将元素添加到映射中，并且每个有效载荷元素只构造了一次。我们可以使用`try_emplace()`函数，结果将相同：
- en: '[PRE55]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The difference between `emplace()` and `try_emplace()` shows up when we try
    to insert new elements with duplicate keys:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们尝试插入具有重复键的新元素时，`emplace()`和`try_emplace()`之间的区别就显现出来了：
- en: '[PRE57]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `emplace()` function tried to add an element with a duplicate key (`"Hendrix"`).
    It failed but *still constructed* the payload object (`"Singer"`). The `try_emplace()`
    function also tried to add an element with a duplicate key (`"Zappa"`). It failed
    and *did not* construct the payload object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`emplace()`函数尝试添加一个具有重复键（`"Hendrix"`）的元素。它失败了，但仍然构造了有效载荷对象（`"Singer"`）。`try_emplace()`函数也尝试添加一个具有重复键（`"Zappa"`）的元素。它失败了，但没有构造有效载荷对象。'
- en: This example demonstrates the distinction between `emplace()` and `try_emplace()`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了`emplace()`和`try_emplace()`之间的区别。
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `try_emplace()` function signature is similar to that of `emplace()`, so
    it should be easy to retrofit legacy code. Here''s the `try_emplace()` function
    signature:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_emplace()`函数签名与`emplace()`类似，因此应该很容易对旧代码进行改造。以下是`try_emplace()`函数签名：'
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At first glance, this looks different from the `emplace()` signature:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这与`emplace()`签名不同：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The distinction is that `try_emplace()` uses a separate parameter for the *key*
    argument, which allows it to be isolated for construction. Functionally, if you''re
    using *template argument deduction*, `try_emplace()` can be a drop-in replacement:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于`try_emplace()`使用一个单独的参数用于*键*参数，这使得它可以独立构建。功能上，如果你使用*模板参数推导*，`try_emplace()`可以作为一个直接替换：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The return value of `try_emplace()` is the same as that of `emplace()`, a pair
    representing an iterator and a bool:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_emplace()`的返回值与`emplace()`相同，是一个表示迭代器和布尔值的对：'
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here I used *structured binding* (`auto [it, success] =`) with an `if` *initializer
    statement* to test the return value and conditionally update the payload. Notice
    that it still just constructs the payload object once.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了*结构化绑定*（`auto [it, success] =`）和`if` *初始化语句*来测试返回值并条件性地更新有效载荷。请注意，它仍然只构建一次有效载荷对象。
- en: 'It''s worth noting that the `try_emplace()` function also works with `unordered_map`.
    We change our alias and everything works the same except unordered:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`try_emplace()`函数也可以与`unordered_map`一起使用。我们更改别名，除了无序之外，一切正常：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The advantage of `try_emplace()` is that it only constructs the payload object
    *if and when* it's ready to store it in the map. In practice, this should save
    significant resources at run-time. You should always favor `try_emplace()` over
    `emplace()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_emplace()`的优势在于它仅在准备好将其存储在映射中时才构建有效载荷对象。在实践中，这应该在运行时节省大量资源。你应该始终优先考虑`try_emplace()`而不是`emplace()`。'
- en: Efficiently modify the keys of map items
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效修改映射项的键
- en: A `map` is an associative container that stores key-value pairs. The container
    is ordered by the keys. The keys must be unique and they are `const`-qualified,
    so they cannot be changed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`是一个关联容器，存储键值对。容器按键排序。键必须是唯一的，并且它们是`const`限定的，因此不能更改。'
- en: 'For example, if I populate a `map` and attempt to change the key, I''ll get
    an error at compilation time:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我填充一个`map`并尝试更改键，我将在编译时得到一个错误：
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you need to re-order a map container, you may do so by swapping keys using
    the `extract()` method.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要重新排序映射容器，你可以通过使用`extract()`方法交换键来实现。
- en: New with C++17, `extract()` is a member function in the `map` class and its
    derivatives. It allows elements of a map to be extracted from the sequence without
    touching the payload. Once extracted, the key is no longer `const`-qualified and
    may be modified.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 新增于C++17，`extract()`是`map`类及其派生类的一个成员函数。它允许从序列中提取映射的元素，而不接触有效载荷。一旦提取，键就不再`const`限定，可以修改。
- en: Let's look at an example.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example we'll define a map that represents contestants in a race. At
    some point during the race, the order changes and we need to modify the keys of
    the map.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义一个表示比赛中参赛者的映射。在比赛过程中，某个时刻顺序发生变化，我们需要修改映射的键。
- en: 'We''ll start by defining an alias for the `map` type:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先为`map`类型定义一个别名：
- en: '[PRE67]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This allows us to use the type consistently throughout our code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在整个代码中一致地使用类型。
- en: 'We''ll write a function for printing out the map:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写一个打印映射的函数：
- en: '[PRE68]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We can pass the map to this function at any time to print out the current rankings
    of our contestants.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何时候将映射传递给这个函数，以打印出我们参赛者的当前排名。
- en: 'In our `main()` function we define a `map` with the initial state of our racers:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们定义一个`map`，其中包含我们参赛者的初始状态：
- en: '[PRE69]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The key is an `int` indicating the rank of the racer. The value is a `string`
    with the name of the racer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 键是一个`int`，表示参赛者的排名。值是一个包含参赛者名字的`string`。
- en: We then call `printm()` to print the current rank. The call to `node_swap()`
    will swap the keys of two racers, then we print gain.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`printm()`来打印当前的排名。`node_swap()`的调用将交换两个参赛者的键，然后我们再次打印。
- en: 'At some point, one of the racers falls behind and another racer takes the opportunity
    to move up in the rankings. The `node_swap()` function will swap the ranking of
    two racers:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个时刻，一名参赛者落后了，另一名参赛者抓住机会提升排名。`node_swap()`函数将交换两名参赛者的排名：
- en: '[PRE70]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This function uses the `map.extract()` method to extract the specified elements
    from the map. These extracted elements are called *nodes*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用`map.extract()`方法从映射中提取指定的元素。这些提取的元素被称为*节点*。
- en: A *node* is a new concept beginning with C++17\. This allows an element to be
    extracted from a map-type structure without touching the element itself. The node
    is unlinked, and a *node handle* is returned. Once extracted, the node handle
    provides *writable* access to the key via the node's `key()` function. We can
    then swap the keys and insert them back into the map, without ever having to copy
    or manipulate the payload.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点* 是从 C++17 开始的一个新概念。这允许从一个映射类型结构中提取一个元素，而不需要触及该元素本身。节点被解链，并返回一个 *节点句柄*。一旦提取，节点句柄通过节点的
    `key()` 函数提供了对键的 *可写* 访问。然后我们可以交换键并将它们重新插入映射中，而无需复制或操作有效负载。'
- en: 'When we run this code we get a printout of the map, before and after the node
    swap:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们会得到在节点交换前后的映射打印输出：
- en: 'Output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is all made possible by the `extract()` method and the new `node_handle`
    class. Let's take a closer look at how this works.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是由 `extract()` 方法和新 `node_handle` 类实现的。让我们更仔细地看看它是如何工作的。
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This technique uses the new `extract()` function, which returns a `node_handle`
    object. As the name suggests, a `node_handle` is a handle to a *node*, which consists
    of an associative element and its related structures. The extract function *disassociates*
    the node while leaving it in place, and returns a `node_handle` object. This has
    the effect of removing the node from the associative container without touching
    the data itself. The `node_handle` allows you to access the disassociated node.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用了新的 `extract()` 函数，它返回一个 `node_handle` 对象。正如其名所示，`node_handle` 是对 *节点*
    的引用，节点由一个关联元素及其相关结构组成。提取函数在保持节点位置的同时 *解关联* 节点，并返回一个 `node_handle` 对象。这相当于在不触及数据本身的情况下从关联容器中移除节点。`node_handle`
    允许你访问解关联的节点。
- en: The `node_handle` has a member function, `key()`, which returns a *writable*
    reference to the node key. This allows you to change the key, while it's disassociated
    from the container.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_handle` 有一个成员函数 `key()`，它返回对节点键的 *可写* 引用。这允许你在键与容器解关联时更改键。'
- en: There's more…
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a few things to keep in mind when using `extract()` and a `node_handle`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `extract()` 和 `node_handle` 时，有几个要点需要注意：
- en: 'If the key is not found, the `extract()` function returns an *empty* node handle.
    You can test if a node handle is empty with the `empty()` function:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到键，`extract()` 函数返回一个 *空的* 节点句柄。你可以使用 `empty()` 函数测试节点句柄是否为空：
- en: '[PRE72]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'There are two overloads of the `exract()` function:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exract()` 函数有两个重载：'
- en: '[PRE73]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We used the first form, by passing a key. You may also use an iterator, which
    should not require a lookup.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了第一种形式，通过传递一个键。你也可以使用一个迭代器，这通常不需要查找。
- en: Keep in mind that you cannot make a reference from a literal, so a call like
    `extract(1)` will usually crash with a segmentation fault.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，你不能从字面量创建引用，所以像 `extract(1)` 这样的调用通常会因段错误而崩溃。
- en: Keys must remain unique when inserted into a `map`.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入到 `map` 中时，键必须保持唯一。
- en: 'For example, if I try to change a key to a value already in the map:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我尝试将一个键更改为映射中已经存在的值：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The insert fails and we get our error message:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 插入失败，我们得到了错误信息：
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this example I've passed the `begin()` iterator to `extract()`. I then assigned
    the key a value that's already in use (5, *Donkey Kong Jr*). The insert failed
    and the resulting `status.inserted` is false. `status.position` is an iterator
    to the found key. In the `if()` block, I used `format()` to print the value the
    found key.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将 `begin()` 迭代器传递给了 `extract()`。然后我给键分配了一个已经使用的值（5，*Donkey Kong Jr*）。插入失败，并且
    `status.inserted` 的结果是 false。`status.position` 是找到的键的迭代器。在 `if()` 块中，我使用了 `format()`
    来打印找到的键的值。
- en: Use unordered_map with custom keys
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带自定义键的 unordered_map
- en: With an ordered `map`, the type of the key must be sortable, which means it
    must at least support the less-than `<` comparison operator. Suppose you want
    to use an associative container with a custom type that is not sortable. For example,
    a vector where `(0, 1)` is not smaller or larger than `(1, 0)`, it simply points
    in a different direction. In such cases, you may still use the `unordered_map`
    type. Let's look at how to do this.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有序的 `map`，键的类型必须是可排序的，这意味着它至少必须支持小于 `<` 比较运算符。假设你想使用一个自定义类型且不可排序的关联容器。例如，一个向量
    `(0, 1)` 不比 `(1, 0)` 小或大，它只是指向不同的方向。在这种情况下，你仍然可以使用 `unordered_map` 类型。让我们看看如何做到这一点。
- en: How to do it…
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe we'll create an `unordered_map` object that uses *x*/*y* coordinates
    for the key. We will need a few support functions for this.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将创建一个使用 *x*/*y* 坐标作为键的 `unordered_map` 对象。为此，我们需要一些支持函数。
- en: 'First, we''ll define a structure for the coordinates:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个坐标的结构：
- en: '[PRE76]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is a simple structure with two members, `x` and `y`, for the coordinates.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的结构，包含两个成员，`x` 和 `y`，用于坐标。
- en: 'Our map will use the `Coord` structure for the key, and an `int` for the value:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的映射将使用 `Coord` 结构作为键，并使用 `int` 作为值：
- en: '[PRE77]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We use a `using` alias to make it convenient to use our map.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `using` 别名来方便地使用我们的映射。
- en: 'To use the `Coord` struct as a key, we need a couple of overloads. These are
    required for use with an `unordered_map`. First, we''ll define an equality comparison
    operator:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 `Coord` 结构作为键，我们需要几个重载。这些是用于 `unordered_map` 的必需项。首先，我们将定义一个相等比较运算符：
- en: '[PRE78]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: It's a simple function that compares the `x` members with each other, and the
    `y` members with each other.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它比较 `x` 成员之间的值，以及 `y` 成员之间的值。
- en: 'We also need a `std::hash` class specialization. This makes it possible to
    retrieve map elements with the key:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要一个 `std::hash` 类的特殊化。这使得使用键检索映射元素成为可能：
- en: '[PRE79]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This provides a specialization for the default `hash` class used by the `std::unordered_map`
    class. It must be in the `std` namespace.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这为 `std::unordered_map` 类使用的默认 `hash` 类提供了一个特殊化。它必须在 `std` 命名空间中。
- en: 'We''ll also write a print function to print a `Coordmap` object:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将编写一个打印函数来打印 `Coordmap` 对象：
- en: '[PRE80]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This uses the C++20 `format()` function to print the *x*/*y* key and the value.
    Notice the use of the double braces, `{{` and `}}`, to print single braces.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 C++20 的 `format()` 函数来打印 *x*/*y* 键和值。注意使用双大括号 `{{` 和 `}}` 来打印单大括号。
- en: Now that we have all our support functions, we can write the `main()` function.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有支持函数，我们可以编写 `main()` 函数。
- en: '[PRE81]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: At this point, we've defined a `Coordmap` object that accepts `Coord` objects
    for the keys and maps them to arbitrary values.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个 `Coordmap` 对象，它接受 `Coord` 对象作为键并将它们映射到任意值。
- en: 'We can also access individual members based on the `Coord` keys:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以根据 `Coord` 键访问单个成员：
- en: '[PRE83]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE84]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here we define a `Coord` object named `k`, and we use that with the `at()` function
    to retrieve a value from the `unordered_map`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `k` 的 `Coord` 对象，并使用它与 `at()` 函数从 `unordered_map` 中检索值。
- en: How it works…
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `unordered_map` class relies on a hash class to lookup elements from the
    key. We normally instantiate an object like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered_map` 类依赖于一个哈希类来从键中查找元素。我们通常以这种方式实例化一个对象：'
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'What''s not obvious here is that, because we haven''t one, it''s using a *default
    hash class*. The full template type definition of the `unordered_map` class looks
    like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不明显的是，因为我们没有定义一个，它正在使用一个 *默认哈希类*。`unordered_map` 类的完整模板类型定义如下所示：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The template provides default values for `Hash`, `KeyEqual`, and `Allocator`,
    so we don't normally include them in our definitions. In our example, we've provided
    a specialization for the default `std::hash` class.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 模板为 `Hash`、`KeyEqual` 和 `Allocator` 提供了默认值，所以我们通常不在我们的定义中包含它们。在我们的例子中，我们为默认的
    `std::hash` 类提供了一个特殊化。
- en: The STL contains specializations of `std::hash` for most of the standard types,
    like `string`, `int`, and so on. For it to work with our class, it needs a specialization.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: STL 包含了 `std::hash` 的大多数标准类型的特殊化，如 `string`、`int` 等。为了与我们的类一起工作，它需要一个特殊化。
- en: 'We could have passed a function to the template parameter, like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个函数传递给模板参数，如下所示：
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: That certainly would work. In my view, the specialization is more general.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然可以工作。在我看来，特殊化更通用。
- en: Use set to sort and filter user input
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合对用户输入进行排序和过滤
- en: The `set` container is an associative container where each element is a *single
    value*, which is used as the key. Elements in a `set` are maintained in sorted
    order and duplicate keys are not allowed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 容器是一个关联容器，其中每个元素都是一个 *单个值*，用作键。`set` 中的元素按顺序维护，不允许重复键。'
- en: The `set` container is often misunderstood, and it does have fewer and more
    specific uses than more general containers such as `vector` and `map`. One common
    use for a `set` is to filter duplicates from a set of values.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 容器通常被误解，它确实比 `vector` 和 `map` 等更通用的容器有更少和更具体的用途。`set` 的一个常见用途是从值集中过滤重复项。'
- en: How to do it…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe we will read words from the *standard input* and filter out the
    duplicates.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将从 *标准输入* 读取单词并过滤掉重复项。
- en: We'll start by defining an alias for an `istream` iterator. We'll use this to
    get input from the command line.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先定义一个 `istream` 迭代器的别名。我们将使用它从命令行获取输入。
- en: '[PRE88]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the `main()` function, we''ll define a `set` for our words:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将为我们的单词定义一个 `set`：
- en: '[PRE89]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `set` is defined as a set of `string` elements.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 被定义为 `string` 元素的集合。'
- en: 'We define a pair of iterators for use with the `inserter()` function:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一对迭代器，用于与 `inserter()` 函数一起使用：
- en: '[PRE90]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `end` iterator is initialized with its default constructor. This is known
    as the *end-of-stream* iterator. When our input ends, this iterator will compare
    equal with the `cin` iterator.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`end` 迭代器使用其默认构造函数进行初始化。这被称为 *流结束* 迭代器。当我们的输入结束时，这个迭代器将与 `cin` 迭代器相等。'
- en: 'The `inserter()` function is used to insert elements into the `set` container:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inserter()` 函数用于将元素插入到 `set` 容器中：'
- en: '[PRE91]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We use `std::copy()` to conveniently copy words from the input stream.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `std::copy()` 来方便地从输入流中复制单词。
- en: 'Now we can print out our `set` to see the results:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以打印出我们的 `set` 来查看结果：
- en: '[PRE92]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can run the program by piping a bunch of words to its input:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将一些单词管道到其输入来运行程序：
- en: '[PRE93]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `set` has eliminated the duplicates and retained a sorted list of the words
    that were inserted.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 已经消除了重复项，并保留了一个排序后的单词列表。'
- en: How it works…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `set` container is the heart of this recipe. It only holds unique elements.
    When you insert a duplicate, that insert will fail. So, you end up with a sorted
    list of each unique element.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 容器是这个菜谱的核心。它只包含唯一的元素。当你插入一个重复项时，该插入操作将失败。因此，你最终会得到一个包含每个唯一元素的排序列表。'
- en: But that's not the only interesting part of this recipe.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是这个菜谱的唯一有趣部分。
- en: 'The `istream_iterator` is an input iterator that reads objects from a stream.
    We instantiated the input iterator like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream_iterator` 是一个输入迭代器，它从流中读取对象。我们这样实例化了输入迭代器：'
- en: '[PRE94]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now we have an input iterator of type `string` from the `cin` stream. Every
    time we dereference this iterator, it will return one word from the input stream.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个来自 `cin` 流的 `string` 类型的输入迭代器。每次我们解引用这个迭代器时，它将返回输入流中的一个单词。
- en: 'We also instantiated another `istream_iterator`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实例化了另一个 `istream_iterator`：
- en: '[PRE95]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This calls the default constructor, which gives us a special *end-of-stream*
    iterator. When the input iterator reaches the end of the stream, it will become
    equal to the *end-of-stream* iterator. This is convenient for ending loops, such
    as the one created by the `copy()` algorithm.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用默认构造函数，它给我们一个特殊的 *流结束* 迭代器。当输入迭代器到达流的末尾时，它将等于 *流结束* 迭代器。这对于结束循环很有用，例如 `copy()`
    算法创建的循环。
- en: 'The `copy()` algorithm takes three iterators, the beginning and end of the
    range to copy, and a destination iterator:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy()` 算法接受三个迭代器，即要复制的范围的开始和结束迭代器，以及一个目标迭代器：'
- en: '[PRE96]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `inserter()` function takes a container and an iterator for the insertion
    point, and returns an `insert_iterator` of the appropriate type for the container
    and its elements.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`inserter()` 函数接受一个容器和一个插入点的迭代器，并返回一个适合容器及其元素的 `insert_iterator`。'
- en: This combination of `copy()` and `inserter()` makes it easy to copy elements
    from a stream into the `set` container.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `copy()` 和 `inserter()` 的组合使得从流中复制元素到 `set` 容器变得容易。
- en: A simple RPN calculator with deque
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的基于 deque 的逆波兰表达式（RPN）计算器
- en: An **RPN** (**Reverse Polish Notation**) calculator is a stack-based calculator
    that uses postfix notation, where the operator follows the operands. It's commonly
    used in printing calculators and, notably, the HP 12C, the most popular electronic
    calculator of all time.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **逆波兰表达式（RPN**）计算器是一个基于栈的计算器，它使用后缀表示法，其中运算符位于操作数之后。它在打印计算器中很常见，尤其是在 HP 12C
    上，这是有史以来最受欢迎的电子计算器。
- en: After becoming familiar with its operational modality, many people prefer an
    RPN calculator. (I've been using the HP 12C and 16C since they were first introduced
    in the early 1980s.) For example, using conventional algebraic notation, to add
    1 and 2 you would type `1 + 2`. Using RPN, you would type `1 2 +`. The operator
    comes *after* the operands.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉其操作模式后，许多人更喜欢使用逆波兰表达式（RPN）计算器。（自从它们在20世纪80年代初首次推出以来，我一直使用 HP 12C 和 16C。）例如，使用传统的代数符号，要加1和2，你会输入
    `1 + 2`。使用逆波兰表达式，你会输入 `1 2 +`。运算符位于操作数之后。
- en: Using an algebraic calculator, you would need to press an `=` key to indicate
    that you want a result. With an RPN calculator this is unnecessary because the
    operator processes immediately, serving a double purpose. On the other hand, an
    RPN calculator often requires an *Enter* keypress to push an operand onto the
    stack.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代数计算器时，你需要按下`=`键来表示你想要一个结果。而在逆波兰表达式（RPN）计算器中，这并不是必需的，因为操作符会立即处理，起到双重作用。另一方面，逆波兰表达式计算器通常需要按下*Enter*键来将操作数推入栈中。
- en: 'We can easily implement an RPN calculator using a stack-based data structure.
    For example, consider an RPN calculator with a four-position stack:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用基于栈的数据结构实现逆波兰表达式计算器。例如，考虑一个具有四个位置的逆波兰表达式计算器：
- en: '![Figure 3.5 – RPN addition operation'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 逆波兰表达式加法操作'
- en: '](img/B18267_03_05.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_03_05.jpg)'
- en: Figure 3.5 – RPN addition operation
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 逆波兰表达式加法操作
- en: 'Each operand is pushed onto the stack as they are entered. When the operator
    is entered, the operands are popped off, operated upon, and the result is pushed
    back onto the stack. The result may then be used in the next operation. For example,
    consider the case of `(3+2)×3`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作数在输入时都会被推入栈中。当输入操作符时，操作数会被弹出，进行操作，并将结果推回栈中。然后结果可以用于下一个操作。例如，考虑`(3+2)×3`的情况：
- en: '![Figure 3.6 – RPN stack operations'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 逆波兰表达式栈操作'
- en: '](img/B18267_03_06.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_03_06.jpg)'
- en: Figure 3.6 – RPN stack operations
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 逆波兰表达式栈操作
- en: 'One advantage of RPN is that you can leave operands on the stack for future
    calculations, reducing the need for separate memory registers. Consider the case
    of `(9×6)+(2×3)`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 逆波兰表达式的一个优点是你可以将操作数留在栈上以供未来的计算，从而减少对单独内存寄存器的需求。考虑`(9×6)+(2×3)`的情况：
- en: '![Figure 3.7 – RPN multiple stack operations'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 逆波兰表达式多栈操作'
- en: '](img/B18267_03_07.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_03_07.jpg)'
- en: Figure 3.7 – RPN multiple stack operations
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 逆波兰表达式多栈操作
- en: Notice that we first perform the operations within the parentheses, then the
    final operation on the intermediate results. This may seem more complex at first,
    but it makes a lot of sense once you get used to it.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们首先执行括号内的操作，然后对中间结果执行最终操作。一开始这可能看起来更复杂，但一旦习惯了，就会觉得非常有道理。
- en: Now, let's build a simple RPN calculator using the STL `deque` container.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用STL的`deque`容器构建一个简单的逆波兰表达式计算器。
- en: How to do it…
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: For this implementation, we'll use a `deque` container for our stack. Why not
    use a `stack` container? The `stack` class is a container-adapter, which uses
    another container (usually a `deque`) for its storage. For our purposes, `stack`
    doesn't provide any tangible advantage over `deque`. And `deque` allows us to
    iterate over and display the RPN stack, like a paper tape calculator.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现，我们将使用`deque`容器作为我们的栈。为什么不使用`stack`容器呢？`stack`类是一个容器适配器，它使用另一个容器（通常是`deque`）来存储。对于我们的目的，`stack`并没有比`deque`提供任何实质性的优势。而且`deque`允许我们像纸带计算器一样迭代和显示逆波兰表达式栈。
- en: 'We''ll encapsulate our RPN calculator in a class. There are a few advantages
    to using a class here. *Encapsulation* provides *safety*, *reusability*, *extensibility*,
    and a *clean interface*. We''ll call our class `RPN`:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把我们的逆波兰表达式计算器封装在一个类中。在这里使用类有几个优点。*封装*提供了*安全性*、*可重用性*、*可扩展性*和*清晰的接口*。我们将把这个类命名为`RPN`：
- en: '[PRE97]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `deque` data store, named `deq_`, is in the private area of the class to
    protect it. This is where we store the RPN stack.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储`deque`，命名为`deq_`，位于类的私有区域，以保护它。这是我们存储逆波兰表达式栈的地方。
- en: The `zero_` constant is used throughout the class, both as a return value and
    as a comparison operand. The `inf_` constant is used for a divide-by-zero error.
    These constants are declared `constexpr static` so they don't take up space in
    every instance.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`zero_`常量在整个类中被使用，既作为返回值也作为比较操作数。`inf_`常量用于除以零错误。这些常量被声明为`constexpr static`，因此它们不会在每个实例中占用空间。'
- en: I like to name private data members with a trailing underscore to remind me
    that they're private.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢用尾随下划线来命名私有数据成员，以提醒自己它们是私有的。
- en: 'We don''t need an explicit constructor or destructor because the `deque` class
    manages its own resources. So, our public interface consists of just three functions:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要显式的构造函数或析构函数，因为`deque`类管理自己的资源。因此，我们的公共接口只包含三个函数：
- en: '[PRE98]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `double op()` function is the main entry point for the RPN class. It takes
    a `string`, with either a number or an operator. If it's a number, it's converted
    into a `double` and pushed onto the stack. If it's an operator, we call `optor()`
    to perform the operation. This is the main logic of the class.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`double op()`函数是`RPN`类的主要入口点。它接受一个包含数字或操作符的`string`。如果是数字，则将其转换为`double`并压入栈中。如果是操作符，我们调用`optor()`来执行操作。这是类的主要逻辑。'
- en: The `void clear()` function simply calls `clear()` on the `deque` to empty the
    stack.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`void clear()`函数简单地调用`deque`的`clear()`来清空栈。'
- en: And finally, the `string get_stack_string()` function returns the contents of
    the stack in a `string`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`string get_stack_string()`函数返回栈的内容，以`string`形式。
- en: 'In the `private` section, we have the supporting utilities that make the interface
    work. The `pop_get2()` function pops two operands from the stack and returns them
    as a pair. We use this as operands for the operators:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`private`部分，我们有支持接口工作的辅助工具。`pop_get2()`函数从栈中弹出两个操作数，并将它们作为一对返回。我们将其用作操作数的操作符：
- en: '[PRE99]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `is_numeric()` function checks to see if the string is entirely numeric.
    We also allow the decimal `.` character.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_numeric()`函数检查字符串是否完全是数字。我们还允许小数点`.`字符。'
- en: '[PRE100]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `optor()` function performs the operators. We use a `map` container to map
    an operator to a corresponding lambda function.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optor()`函数执行操作符。我们使用`map`容器将操作符映射到相应的lambda函数。'
- en: '[PRE101]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `map` container with lambda functions makes a quick and easy jump table.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 带有lambda函数的`map`容器创建了一个快速且简单的跳转表。
- en: We use the `find()` function in `map` to test if we have a valid operator.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`map`中使用`find()`函数来测试我们是否有有效的操作符。
- en: After a test for divide-by-zero, the `map` is dereferenced, and the operator
    is called.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在除以零的测试之后，对`map`进行解引用，并调用操作符。
- en: The result of the operation is pushed onto the stack and returned.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的结果被推入栈中并返回。
- en: 'Those are all the function members of the `RPN` class. Now we can use it in
    our `main()` function:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些都是`RPN`类的函数成员。现在我们可以在`main()`函数中使用它：
- en: '[PRE102]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We'll test this is by piping a string into the program from the command line.
    We use a `for` loop to fetch each word from the `cin` stream and pass it to `rpn.op()`.
    I like the `for` loop here, as it's easy to contain the scope of the `o` variable.
    We then print the stack using the `get_stack_string()` function after each command
    line item.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从命令行将字符串管道输入程序来测试这一点。我们使用`for`循环从`cin`流中获取每个单词，并将其传递给`rpn.op()`。我喜欢这里的`for`循环，因为它很容易包含`o`变量的作用域。然后我们使用`get_stack_string()`函数在每条命令行项之后打印栈。
- en: 'We can run the program by piping in an expression like this:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过输入这样的表达式来运行程序：
- en: '[PRE103]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This looks like a lot of coding but it's actually quite simple. With the comments,
    the `RPN` class is less than 70 lines of code. The full `rpn.cpp` source code
    is in the GitHub repository.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像很多编码，但实际上相当简单。有了注释，`RPN`类只有不到70行代码。完整的`rpn.cpp`源代码在GitHub仓库中。
- en: How it works…
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `RPN` class operates by first determining the nature of each chunk of input.
    If it's a number, we push it onto the stack. If it's an operator, we pop two operands
    off the top of the stack, apply the operation, and push the result back on the
    stack. If we don't recognize the input, we just ignore it.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPN`类通过首先确定每个输入块的性质来操作。如果是数字，我们将其推入栈中。如果是操作符，我们从栈顶弹出两个操作数，应用操作，并将结果推回栈中。如果我们不识别输入，我们只需忽略它。'
- en: The `deque` class is a double-ended queue. To use it as a stack, we pick an
    end and both push and pop from that same end. I chose the `front` end of the deque,
    but it would work just as well from the `back`. We just need to do everything
    from the same end.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`类是一个双端队列。要将其用作栈，我们选择一个端点，并从该端点同时进行压栈和出栈操作。我选择了deque的`front`端，但也可以从`back`端工作。我们只需要从同一端进行所有操作。'
- en: If we determine that an input is numeric, we convert it to a `double` and push
    it onto the front of the `deque` using `push_front()`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定输入是数字，我们将其转换为`double`并使用`push_front()`将其推入deque的前端。
- en: '[PRE104]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: When we need to use values from the stack, we pop them off the front of the
    deque. We use `front()` to get the value, and then `pop_front()` to pop it off
    the stack.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用栈中的值时，我们从deque的前端弹出它们。我们使用`front()`获取值，然后使用`pop_front()`将其从栈中弹出。
- en: '[PRE105]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Using a map for our operators makes it easy to both check if an operator is
    valid, and to execute the operation.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`为我们操作符，使得检查操作符是否有效以及执行操作变得容易。
- en: '[PRE106]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can test for the validity of an operator by using the `find()` function:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `find()` 函数来测试操作符的有效性：
- en: '[PRE107]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'And we can call the operator by dereferencing the `map` with the `at()` function:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `at()` 函数解引用 `map` 来调用操作符：
- en: '[PRE108]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We both call the operator lambda and push the result onto the `deque` in one
    statement:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一次语句中调用操作符 lambda 并将结果推送到 `deque` 中：
- en: '[PRE109]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: There's more…
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we use the `cin` stream to feed operations to the RPN calculator.
    It would be just as easy to do this with an STL container.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `cin` 流将操作传递给 RPN 计算器。用 STL 容器做这件事也同样简单。
- en: '[PRE110]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Output:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE111]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: By putting the RPN calculator in a class with a clean interface, we've created
    a flexible tool that can be used in many different contexts.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 RPN 计算器放入一个具有干净接口的类中，我们创建了一个灵活的工具，可以在许多不同的环境中使用。
- en: A word frequency counter with map
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 map 的单词频率计数器
- en: This recipe uses the unique key property of the `map` container to count duplicate
    words from a stream of text.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用 `map` 容器的唯一键属性来计算文本流中重复单词的数量。
- en: The STL `map` container is an *associative* container. It consists of elements
    organized in *key-value pairs*. The keys are used for lookup and must be unique.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `map` 容器是一个 *关联* 容器。它由组织成 *键值对* 的元素组成。键用于查找，并且必须是唯一的。
- en: In this recipe, we will leverage the unique key requirement of the STL `map`
    container to count the number of occurrences of each word in a text file.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将利用 STL `map` 容器的唯一键要求来计算文本文件中每个单词的出现次数。
- en: How to do it…
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'There are a few parts to this task that we can solve separately:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务有几个部分我们可以单独解决：
- en: We need to get the text from a file. We'll use the `cin` stream for this.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从文件中获取文本。我们将使用 `cin` 流来完成这项任务。
- en: We need to separate words from punctuation and other non-word content. We'll
    use the `regex` (Regular Expression) library for this.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将单词与非单词内容（如标点符号）分开。我们将使用 `regex`（正则表达式）库来完成这项任务。
- en: We need to count the frequency of each word. This is the main objective of the
    recipe. We'll use the STL `map` container for this.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要计算每个单词的频率。这是本菜谱的主要目标。我们将使用 STL 的 `map` 容器来完成这项任务。
- en: Finally, we need to sort the results, first by frequency and then alphabetically
    by word within frequency. For this we'll use a the STL `sort` algorithm with a
    `vector` container.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要按频率和字母顺序对结果进行排序。为此，我们将使用 STL 的 `sort` 算法和 `vector` 容器。
- en: 'Even with all those tasks, the resulting code is relatively short, just about
    70 lines with headers and all. Let''s dive in:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有所有这些任务，生成的代码相对较短，大约有 70 行，包括头文件在内。让我们开始吧：
- en: 'We''ll start with some aliases for convenience:'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将开始使用一些别名以方便起见：
- en: '[PRE112]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: For namespaces within the `std::` space, I like to make aliases that are shorter,
    but still let me know that I'm using a token in a particular namespace. Especially
    with the `ranges` namespace, which often re-uses the names of existing algorithms.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `std::` 空间内的命名空间，我喜欢创建更短的别名，但仍然让我知道我正在使用特定命名空间中的标记。特别是对于经常重用现有算法名称的 `ranges`
    命名空间。
- en: 'We store the regular expression in a constant. I don''t like to clutter up
    the global namespace because that can lead to collisions. I tend to use a namespace
    based on my initials for things like this:'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将正则表达式存储在一个常量中。我不喜欢让全局命名空间变得杂乱，因为这可能导致冲突。我倾向于为这类事情使用基于我首字母的命名空间：
- en: '[PRE113]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: It's easy enough to get it later using `bw::re`, and that tells me exactly what
    it is.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bw::re` 获取它很容易，这告诉我它确切是什么。
- en: 'At the top of `main()`, we define our data structures:'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 的顶部，我们定义我们的数据结构：
- en: '[PRE114]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Our main `map` is called `wordmap`. We have a `vector` named `wordvec` that
    we'll use as a sorting container. And finally, our `regex` class, `word_re`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要 `map` 被称为 `wordmap`。我们有一个名为 `wordvec` 的 `vector`，我们将使用它作为排序容器。最后，我们的 `regex`
    类，`word_re`。
- en: 'The `for` loop is where most of the work happens. We read text from the `cin`
    stream, apply the `regex`, and store words in the `map`:'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环是大部分工作发生的地方。我们从 `cin` 流中读取文本，应用正则表达式，并将单词存储在 `map` 中：'
- en: '[PRE115]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: I like a `for` loop for this because it allows me to contain the scope of the
    `s` variable.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用 `for` 循环，因为它允许我将 `s` 变量的作用域包含在内。
- en: We start by defining iterators for the `regex` results. This allows us to distinguish
    multiple words even when surrounded only by punctuation. The `for(r_it...)` loop
    returns individual words from the `cin` string.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为 `regex` 结果定义迭代器。这允许我们在只有标点符号的情况下区分多个单词。`for(r_it...)` 循环从 `cin` 字符串中返回单个单词。
- en: The `smatch` type is a specialization of a `regex` string match class. It gives
    us the next word from our `regex`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`smatch`类型是`regex`字符串匹配类的特化。它给我们提供了下一个单词从我们的`regex`。'
- en: We then use the `transform` algorithm to make the words lowercase – so we can
    count words regardless of case. (For example, "The" is the same word as "the".)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`transform`算法将单词转换为小写——这样我们就可以不计较大小写来计数单词。（例如，“The”和“the”是同一个单词。）
- en: Next, we use `try_emplace()` to add the word to the map. If it's already there,
    it will not be replaced.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`try_emplace()`将单词添加到map中。如果它已经存在，它不会被替换。
- en: Finally, we increment the count for the word in the `map` with `++count`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`++count`来增加`map`中单词的计数。
- en: 'Now we have the words and their frequency counts in our `map`. But they''re
    in alphabetical order and we want them in descending order of frequency. For this,
    we put them in a vector and sort them:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们在`map`中有单词及其频率计数。但它们是按字母顺序排列的，我们希望它们按频率降序排列。为此，我们将它们放入一个向量中并排序：
- en: '[PRE116]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`wordvec` is a vector of pairs, with the word and the frequency count. We use
    the `ranges::move()` algorithm to populate the `vector`, then the `ranges::sort()`
    algorithm to sort the `vector`. Notice that the *predicate lambda function* sorts
    first by the count (descending) and then by the word (ascending).'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordvec`是一个包含单词和频率计数的对向量。我们使用`ranges::move()`算法填充`vector`，然后使用`ranges::sort()`算法对`vector`进行排序。注意，*谓词lambda函数*首先按计数（降序）排序，然后按单词（升序）排序。'
- en: 'Finally, we print the results:'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们打印出结果：
- en: '[PRE117]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: I set a limit to print only the first 20 entries. You can comment out the `if(--limit
    == 0) break;` line to print the whole list.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个限制，只打印前20个条目。你可以取消注释`if(--limit == 0) break;`行来打印整个列表。
- en: 'In the example files, I''ve included a text file with a copy of *The Raven*,
    by Edgar Allen Poe. The poem is in the public domain. We can use this to test
    the program:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在示例文件中，我包含了一个包含埃德加·爱伦·坡的《乌鸦》副本的文本文件。这首诗是公有领域的。我们可以用它来测试程序：
- en: '[PRE118]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The poem has 1,098 words total, and 439 of them are unique.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这首诗总共有1,098个单词，其中439个是独特的。
- en: How it works…
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The core of the recipe is the use of a `map` object to count duplicate words.
    But there are other parts that merit consideration.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的核心是使用`map`对象来计数重复的单词。但还有其他部分值得考虑。
- en: We use the `cin` stream to read text from the *standard input*. By default,
    `cin` will skip *whitespace* when reading into a `string` object. By putting a
    string object on the right-hand side of the `>>` operator (`cin >> s`) we get
    chunks of text separated by whitespace. This is a good enough definition of a
    word-at-a-time for many purposes, but we need linguistic words. And for that we
    will use a regular expression.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cin`流从*标准输入*读取文本。默认情况下，`cin`在读取到`string`对象时会跳过*空白字符*。通过将一个字符串对象放在`>>`操作符的右侧（`cin
    >> s`），我们可以得到由空白字符分隔的文本块。这对于许多目的来说已经足够定义一个单词一次，但我们需要语言学上的单词。为此，我们将使用正则表达式。
- en: The `regex` class provides a choice of regular expression *grammars* and it
    defaults to *ECMA* grammar. In the ECMA grammar, the regular expression `"(\w+)"`
    is a shortcut for `"([A-Za-z0-9_]+)"`. This will select words that include these
    characters.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex`类提供了正则表达式*语法*的选择，默认为*ECMA*语法。在ECMA语法中，正则表达式`"(\w+)"`是`"([A-Za-z0-9_]+)"`的快捷方式。这将选择包含这些字符的单词。'
- en: Regular expressions are a language unto themselves. To learn more about regular
    expressions, I recommend the book *Mastering Regular Expressions* by Jeffrey Friedl.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种语言。要了解更多关于正则表达式的信息，我推荐Jeffrey Friedl的书籍《精通正则表达式》。
- en: As we get each word from the `regex` engine, we use the map object's `try_emplace()`
    method to conditionally add the word to our `wordmap`. If the word is not in the
    map, we add it with a count of `0`. If the word is already in the map, the count
    is untouched. We increment the count later in the loop, so it's always correct.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从`regex`引擎获取每个单词时，我们使用map对象的`try_emplace()`方法有条件地将单词添加到我们的`wordmap`中。如果单词不在map中，我们将其添加，计数为`0`。如果单词已经在map中，计数保持不变。我们在循环的后面增加计数，所以它总是正确的。
- en: After the map is populated with all the unique words from the file, we transfer
    it to a vector using the `ranges::move()` algorithm. The `move()` algorithm makes
    this transfer quick and efficient. Then we can sort it in the vector using `ranges::sort()`.
    The *predicate lambda function* for sorting includes comparisons for both sides
    of the pair, so we end up with a result that's sorted by both word count (descending)
    and the word.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在将文件中的所有唯一单词填充到map之后，我们使用 `ranges::move()` 算法将其转移到 `vector` 中。`move()` 算法使这种转移快速高效。然后我们可以使用
    `ranges::sort()` 在 `vector` 中对其进行排序。排序的 *谓词lambda函数* 包括对pair两边的比较，所以我们最终得到一个按单词计数（降序）和单词排序的结果。
- en: Find long sentences with a vector of vectors
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用vector of vectors查找长句子
- en: It can be useful for a writer to make sure they are using variety of sentence
    lengths, or to ensure none of their sentences are too long. Let's build a tool
    that evaluates a text file for sentence length.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作家来说，确保他们使用不同长度的句子，或者确保他们的句子没有太长，这可能很有用。让我们构建一个工具来评估文本文件的句子长度。
- en: Choosing the appropriate container is key when using the STL. If you need something
    ordered, it's often best to use an associative container, such as `map` or `multimap`.
    In this case, however, since we need a custom sort, it's easier to sort a `vector`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 STL 时，选择合适的容器是关键。如果你需要有序的容器，通常最好使用关联容器，如 `map` 或 `multimap`。然而，在这种情况下，由于我们需要自定义排序，对
    `vector` 进行排序更容易。
- en: The `vector` is generally the most flexible of the STL containers. Whenever
    another container type seems appropriate, but is missing one important capability,
    the `vector` is often an effective solution. In this case, where we need a custom
    sort, the vector works great.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 通常是最灵活的 STL 容器。当另一个容器类型似乎合适，但缺少一个重要功能时，`vector` 常常是一个有效的解决方案。在这种情况下，由于我们需要自定义排序，`vector`
    工作得很好。'
- en: This recipe uses a *vector of vectors*. The inner `vector` stores the words
    of a sentence, and the outer `vector` stores the inner `vector`s. As you'll see,
    this affords a lot of flexibility while retaining all the relevant data.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了一个 *vector of vectors*。内部的 `vector` 存储句子的单词，外部的 `vector` 存储内部的 `vector`s。正如你将看到的，这提供了很多灵活性，同时保留了所有相关的数据。
- en: How to do it…
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: This program needs to read in words, find the ends of sentences, store and sort
    the sentences, then print out the results.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序需要读取单词，找到句子的结尾，存储和排序句子，然后打印结果。
- en: 'We''ll start by writing a little function to tell us when we''ve hit the end
    of a sentence:'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先编写一个简单的函数来告诉我们何时到达句子的结尾：
- en: '[PRE119]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The `is_eos()` function uses `string_view` because it's efficient and we don't
    need anything more. Then we use the `strchr()` library function to check if a
    word contains one of the end-of-sentence punctuation characters (`".!?"`). These
    are the three possible characters to end a sentence in the English language.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_eos()` 函数使用 `string_view`，因为它效率高，我们不需要更多。然后我们使用 `strchr()` 库函数来检查单词是否包含句号、感叹号或问号等句子结尾标点符号。这些是英语中结束句子的三种可能字符。'
- en: 'In the `main()` function, we start by defining the *vector of vectors*:'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们首先定义了 *vector of vectors*：
- en: '[PRE120]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This defines a `vector` of elements typed `vector<string>` named `vv_sentences`.
    The `vv_sentences` object is initialized with one empty vector for the first sentence.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `vv_sentences` 的 `vector`，其元素类型为 `vector<string>`。`vv_sentences` 对象初始化为一个空的
    `vector`，用于第一个句子。
- en: This creates a vector that contains other vectors. The inner vectors will each
    hold a sentence of words.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个包含其他 `vector` 的 `vector`。内部的 `vector` 将各自包含一个单词句子。
- en: 'Now we can process the stream of words:'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以处理单词流了：
- en: '[PRE121]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `for` loop returns one word at a time from the input stream. The `back()`
    method on the `vv_sentences` object is used to access the current vector of words,
    and the current word is added using `emplace_back()`. Then we call `is_eos()`
    to see if this was the end of a sentence. If so, we add a new empty vector to
    `vv_sentences` to start the next sentence.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环每次从输入流中返回一个单词。`vv_sentences` 对象上的 `back()` 方法用于访问当前的单词 `vector`，当前单词使用
    `emplace_back()` 添加。然后我们调用 `is_eos()` 来查看这是否是句子的结尾。如果是，我们在 `vv_sentences` 中添加一个新的空
    `vector` 以开始下一个句子。'
- en: 'Because we always add a new empty vector to the end of `vv_sentences` after
    each end-of-sentence character, we will usually end up with an empty sentence
    vector at the end. Here we check for this, and delete it if necessary:'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们总是在 `vv_sentences` 的末尾添加一个新的空 `vector`，在每个句号后，我们通常会得到一个空的句子 `vector`。在这里我们检查这一点，并在必要时删除它：
- en: '[PRE122]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now we can sort the `vv_sentences` vector by the size of the sentences:'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以按句子的长度对 `vv_sentences` 向量进行排序：
- en: '[PRE123]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This is why the `vector` is so convenient for this project. It's quick and easy
    to sort using the `ranges::sort()` algorithm with a simple *predicate* for sorting
    by size in descending order.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 `vector` 对于这个项目来说如此方便。使用 `ranges::sort()` 算法和简单的 *谓词* 按大小降序排序非常快速和简单。
- en: 'Now we can print our result:'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以打印我们的结果：
- en: '[PRE124]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The outer loop and the inner loop correspond to the outer and inner vectors.
    We simply loop through the vectors and print out the size of the inner vector
    with `format("{}: ", size)` and then each word with `format("{} ", s)`. We don''t
    want to print the very long sentences in their entirety, so we define a limit
    of 10 words and print an ellipsis if there''s more.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '外部循环和内部循环对应于外部和内部向量。我们只需遍历向量，并使用 `format("{}: ", size)` 打印内部向量的大小，然后使用 `format("{}
    ", s)` 打印每个单词。我们不想打印完整的非常长的句子，所以我们定义了一个10个单词的限制，并在有更多单词时打印省略号。'
- en: 'The output looks like this, using the first few paragraphs of this recipe for
    input:'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出看起来像这样，使用这个菜谱的前几段作为输入：
- en: '[PRE125]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: How it works…
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Finding punctuation is simple using the `strchr()` function from the C Standard
    Library. Remember, all of C and its Standard Library are included in the definition
    of the C++ language. There's no reason not to use it where appropriate.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C 标准库中的 `strchr()` 函数查找标点符号很简单。记住，C 及其标准库都包含在 C++ 语言的定义中。在适当的地方使用它是没有理由不做的。
- en: '[PRE126]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This function will fail to properly separate sentences if there's punctuation
    in the middle of words. That may happen in some forms of poetry or in a badly
    formatted text file. I've seen this done with `std::string` iterators, and with
    regular expressions, but for our purposes this is quick and easy.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单词中间有标点符号，此函数将无法正确分隔句子。这可能在某些形式的诗歌或格式不良的文本文件中发生。我见过使用 `std::string` 迭代器和正则表达式这样做，但就我们的目的而言，这是快速且简单的方法。
- en: 'We read the text file one word at a time using `cin`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `cin` 逐词读取文本文件：
- en: '[PRE127]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This avoids the overhead of reading a large file into memory all at once. The
    `vector` will already be large, containing all the words of the file. It's not
    necessary to also hold the entire text file in memory. In the rare case that a
    file is too large, it would be necessary to find another strategy, or use a database.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了将大文件一次性读入内存的开销。`vector` 已经很大了，包含了文件中的所有单词。没有必要也在内存中保留整个文本文件。在极少数情况下，如果文件太大，就需要找到另一种策略或使用数据库。
- en: The *vector of vectors* may look complex at first glance, but it's no more complicated
    than using two separate vectors.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量数组* 可能一开始看起来很复杂，但它并不比使用两个单独的向量更复杂。'
- en: '[PRE128]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This declares an *outer* `vector`, with *inner* elements of type `vector<string>`.
    The *outer* vector is named `vv_sentences`. The *inner* vectors are anonymous;
    they require no name. This definition initializes the `vv_sentences` object with
    one element, an empty `vector<string>` object.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个 *外部* `vector`，其 *内部* 元素类型为 `vector<string>`。*外部* 向量命名为 `vv_sentences`。*内部*
    向量是匿名的；它们不需要名称。此定义使用一个元素初始化 `vv_sentences` 对象，即一个空的 `vector<string>` 对象。
- en: 'The *current* inner vector will always be available as `vv_senteces.back()`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当前内部向量始终可用，作为 `vv_sentences.back()`：
- en: '[PRE129]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'When we''ve completed one inner vector, we simply create a new one with:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成一个内部向量后，我们只需创建一个新的：
- en: '[PRE130]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This creates a new anonymous `vector<string>` object and *emplaces* it at the
    back of the `vv_sentences` object.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的匿名 `vector<string>` 对象，并将其 *放置* 在 `vv_sentences` 对象的末尾。
- en: A ToDo list using multimap
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 multimap 的待办事项列表
- en: An ordered task list (or a *ToDo list*) is a common computing application. Formally
    stated, it's a list of tasks associated with a priority, sorted in reverse numerical
    order.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 有序任务列表（或 *待办事项列表*）是一种常见的计算应用。正式地说，它是一系列与优先级相关的任务，按逆数值顺序排序。
- en: You may be tempted to use a `priority_queue` for this, because as the name implies,
    it's already sorted in priority (reverse numerical) order. The disadvantage of
    a `priority_queue` is that it has no iterators, so it's difficult to operate on
    it without pushing and popping items to and from the queue.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想使用 `priority_queue` 来做这件事，因为正如其名所示，它已经按优先级（逆数值）顺序排序。`priority_queue` 的缺点是它没有迭代器，因此在不向队列中推入和弹出项目的情况下操作它很困难。
- en: For this recipe, we'll use a `multimap` for the ordered list. The `multimap`
    *associative container* keeps items in order, and it can be accessed using *reverse
    iterators* for the proper sort order.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用一个`multimap`来存储有序列表。这个`multimap` *关联容器*按顺序保存项目，并且可以使用*反向迭代器*以正确的排序顺序访问。
- en: How to do it…
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This is a short and simple recipe that initializes a `multimap` and prints it
    in reverse order.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短且简单的食谱，它初始化一个`multimap`并按反向顺序打印它。
- en: 'We start with a type alias for our `multimap`:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个`multimap`的类型别名开始：
- en: '[PRE131]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Our `todomap` is a `multimap` with an `int` key and a `string` payload.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`todomap`是一个具有`int`键和`string`负载的`multimap`。
- en: 'We have a small utility function for printing the `todomap` in reverse order:'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个用于在反向顺序中打印`todomap`的小工具函数：
- en: '[PRE132]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This uses reverse iterators to print the `todomap`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用反向迭代器来打印`todomap`。
- en: 'The `main()` function is short and sweet:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`函数简短而甜蜜：'
- en: '[PRE133]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We initialize the `todomap` with tasks. Notice that the tasks are not in any
    particular order, but they do have priorities in the keys. The `rprint()` function
    will print them in priority order.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用任务初始化`todomap`。注意，任务没有特定的顺序，但它们在键中确实有优先级。`rprint()`函数将按优先级顺序打印它们。
- en: 'The output looks like this:'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE134]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The ToDo list prints out in priority order, just as we need it.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项列表按优先级顺序打印出来，正如我们所需要的。
- en: How it works…
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's a short and simple recipe. It uses the `multimap` container to hold items
    for a prioritized list.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短且简单的食谱。它使用`multimap`容器来保存优先级列表中的项目。
- en: 'The only trick is in the `rprint()` function:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的技巧在于`rprint()`函数：
- en: '[PRE135]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Notice the reverse iterators, `rbegin()` and `rend()`. It's not possible to
    change the sort order of a `multimap`, but it does provide reverse iterators.
    This makes the `multimap` behave exactly as we need it for our prioritized list.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 注意反向迭代器，`rbegin()`和`rend()`。无法更改`multimap`的排序顺序，但它确实提供了反向迭代器。这使得`multimap`的行为正好符合我们为优先级列表所需的方式。
