- en: '*Chapter 3*: STL Containers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the container classes in the STL. In short,
    a *container* is an object that contains a collection of other objects, or *elements*.
    The STL provides a complete suite of container types that form the foundation
    of the STL itself.
  prefs: []
  type: TYPE_NORMAL
- en: A quick overview of the STL container types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The STL provides a comprehensive set of container types, including *sequential
    containers*, *associative containers*, and *container adapters*. Here''s a brief
    overview:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sequential containers provide an interface where the elements are arranged
    in sequence. While you may use the elements sequentially, some of these containers
    use contiguous storage, and others do not. The STL includes these sequential containers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `array` is a fixed-size sequence that holds a specific number of elements
    in contiguous storage. Once allocated, it cannot change size. This is the simplest
    and fastest contiguous storage container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vector` is like an array that can shrink and grow. Its elements are stored
    contiguously, so changing size may involve the expense of allocating memory and
    moving data. A `vector` may keep extra space in reserve to mitigate that cost.
    Inserting and deleting elements from anywhere other than the *back* of a `vector`
    will trigger realignment of the elements to maintain contiguous storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `list` is a doubly-linked list structure that allows elements to be inserted
    and deleted in constant (*O(1)*) time. Traversing the list happens in linear *O(n)*
    time. A single-linked variant is available as `forward_list`, which only iterates
    forward. A `forward_list` uses less space and is somewhat more efficient than
    a doubly-linked `list`, but lacks some capability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `deque` (commonly pronounced, *deck*) is a `deque` allows random access
    to its elements, much like a `vector`, but does not guarantee contiguous storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An associative container associates a key with each element. Elements are referenced
    by their key, rather than their position in the container. STL associative containers
    include these containers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `set` is an associative container where each element is also its own key.
    Elements are ordered, usually by some sort of binary tree. Elements in a `set`
    are immutable and cannot be modified, but they can be inserted and removed. Elements
    in a `set` are *unique*, duplicates are not allowed. A `set` iterates in order
    according to its sorting operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `multiset` is like a `set` with non-unique keys, where duplicates are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unordered_set` is like a `set` that does not iterate in order. Elements
    are not sorted in any specific order, but are organized according to their hash
    values for fast access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unordered_multiset` is like an `unordered_set` with non-unique keys, where
    duplicates are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map` is an associative container for key-value pairs, where each *key*
    is mapped to a specific *value* (or *payload*). The types of the key and value
    may be different. Keys are unique but values are not. A map iterates in order
    of its keys, according to its sorting operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `multimap` is like a `map` with non-unique keys, where duplicate keys are
    allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unordered_map` is like a map that does not iterate in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unordered_multimap` is like an `unordered_map` with non-unique keys, where
    duplicates are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A container adapter is a class which encapsulates an underlying container.
    The container class provides a specific set of member functions to access the
    underlying container elements. The STL provides these container adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `stack` provides a `vector`, `deque`, or `list`. If no underlying container
    is specified, the default is `deque`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `queue` provides a `deque` or `list`. If no underlying container is specified,
    the default is `deque`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `priority_queue` keeps the greatest value element at the top, according
    to a *strict weak ordering*. It provides a constant time lookup of the greatest
    value element, at the expense of logarithmic time insertion and extraction. The
    underlying container may be one of `vector` or `deque`. If no underlying container
    is specified, the default is `vector`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use uniform erasure functions to delete items from a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete items from an unsorted vector in constant time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access vector elements directly and safely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep vector elements sorted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently insert elements into a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently modify the keys of map items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `unordered_map` with custom keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use set to sort and filter user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple RPN calculator with deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A word frequency counter with map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find long sentences with a vector of vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ToDo list using multimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03).
  prefs: []
  type: TYPE_NORMAL
- en: Use uniform erasure functions to delete items from a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before C++20, the *erase-remove idiom* was commonly used to efficiently delete
    elements from an STL container. This was a little cumbersome, but not a great
    burden. It was common to use a function like this for the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `std::remove()` function is from the `<algorithms>` header. `std::remove()`
    searches for the specified value and removes it by shifting elements forward from
    the end of the container. It does not change the size of the container. It returns
    an iterator past the end of the shifted range. We then call the container's `erase()`
    function to delete the remaining elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This two-step process is now reduced to one step with the new uniform erasure
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This one function call does the same thing as the `remove_value()` function
    we wrote above.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a version that uses a predicate function. For example, to remove
    all even numbered values from a numeric container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the uniform erasure functions in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two forms of the uniform erasure functions. The first form, called
    `erase()`, takes two parameters, a container and a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The container may be any of the sequential containers (`vector`, `list`, `forward_list`,
    `deque`), except `array`, which cannot change size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second form, called `erase_if()`, takes a container and a predicate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This form works with any of the containers that work with `erase()`, plus the
    associative containers, `set`, `map`, and their multi-key and unordered variants.
  prefs: []
  type: TYPE_NORMAL
- en: The functions `erase()` and `erase_if()` are defined, as non-member functions,
    in the header for the corresponding container. There is no need to include another
    header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a simple function to print the size and elements of a
    sequential container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `printc()` function uses the C++20 `format()` function to format a string
    for `cout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `vector` with 10 integer elements, printed with our `printc()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the vector has 10 elements. Now we can use `erase()` to remove
    all elements with the value `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `vector` version of the `std::erase()` function is defined in the `<vector>`
    header. After the `erase()` call, the element with the value 5 has been removed
    and the vector has 9 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works just as well with a `list` container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `list` version of the `std::erase()` function is defined in the `<list>`
    header. After the `erase()` call, the element with the value `5` has been removed
    and the `list` has 9 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `erase_if()` to remove all the even numbered elements with a simple
    predicate function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `erase_if()` function also works with associative containers, like `map`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Because each element of a `map` is returned as a `pair`, we need a different
    function to print them. The `print_assoc()` function unpacks the `pair` elements
    with a *structured binding* in the `for` loop. We also use a structured binding
    in the predicate function of `erase_if()` to isolate the key for filtering the
    even numbered elements.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `erase()` and `erase_if()` functions are simply wrappers that perform the
    *erase-remove idiom* in one step. They perform the same operations as a function,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we consider a simple `vector` of `int`, called `vec`, with the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize `vec` as a one-row table of `int` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 â€“ begin() and end() iterators'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 â€“ begin() and end() iterators
  prefs: []
  type: TYPE_NORMAL
- en: The `begin()` iterator points at the first element, and the `end()` iterator
    points *past* the last element. This configuration is standard for all STL sequential
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `remove(c.begin(), c.end(), 5)`, the algorithm searches for matching
    elements, starting at the `begin()` iterator. For each matching element that it
    finds, it shifts the next element into its place. It continues searching and shifting
    until it reaches the `end()` iterator. The result is a container where all the
    remaining elements are at the beginning, without the deleted elements, and in
    their original order. The `end()` iterator is unchanged and the remaining elements
    are *undefined*. We can visualize the operation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 â€“ Removing an element'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 â€“ Removing an element
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remove()` function returns an iterator (`remove_it`) that points to the
    first element *past* the elements that were shifted. The `end()` iterator remains
    as it was before the `remove()` operation. To further illustrate, if we were to
    remove all even-numbered elements using `remove_if()`, our result would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 â€“ After removing even-numbered elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 â€“ After removing even-numbered elements
  prefs: []
  type: TYPE_NORMAL
- en: In this case, all that remains is the five odd-numbered elements followed by
    five elements of *undefined* value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container''s `erase()` function is then called to erase the remaining elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The container's `erase()` function is called with the `remove_it` and `end()`
    iterators to delete all the undefined elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `erase()` and `erase_if()` functions call both the `remove()` function and
    the container's `erase()` function, in order to perform the *erase-remove idiom*
    in one step.
  prefs: []
  type: TYPE_NORMAL
- en: Delete items from an unsorted vector in constant time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the uniform erasure functions (or the *erase-remove idiom*) to delete
    items from the middle of a vector takes *O(n)* (*linear*) time. This is because
    elements must be shifted from the end of the vector to close the gap of the deleted
    items. If the order of items in the vector is not important, we can optimize this
    process to take *O(1)* (*constant*) time. Here's how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe takes advantage of the fact that removing an element from the end
    of a vector is quick and easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a function to print out a vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `main()` function we define a vector of `int` and print it using `printc()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write the function that will delete an element from the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `quick_delete()` function takes two arguments, a vector `v` and an index
    `idx`. We first check to make sure our index is within boundaries. Then we call
    the `move()` function from the `<algorithms>` header to move the last element
    of the vector to the position of our index. Finally, the `v.pop_back()` function
    is called to shorten the vector from the back.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also include a version of `quick_delete()` for use with an iterator instead
    of an index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This version of `quick_delete()` operates from an iterator instead of an index.
    Otherwise, it works the same as the indexed version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call it from our `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `quick_delete()` uses an iterator from the `std::ranges::find()`algorithm.
    This deletes the value `47` from the vector. Notice the value from the back of
    the vector (`19`) takes its place. The second call to `quick_delete()` uses an
    index (`1`) to delete the second element from the vector (`196`). Again, the value
    from the back of the vector takes its place.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `quick_delete()` function uses a simple trick to delete elements from a
    vector quickly and efficiently. The element at the back of the vector is moved
    (*not copied*) into the position of the element to be deleted. The deleted element
    is discarded in the process. Then, the `pop_back()` function shortens the vector
    by one element from the end.
  prefs: []
  type: TYPE_NORMAL
- en: This takes advantage of the fact that deleting the element at the back of the
    vector is especially cheap. The `pop_back()` function operates at constant complexity,
    as it only needs to change the `end()` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram shows the state of the vector before and after the `quick_delete()`
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 â€“ Before and after quick_delete()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 â€“ Before and after quick_delete()
  prefs: []
  type: TYPE_NORMAL
- en: The `quick_remove()` operation simply *moves* the element from the back of the
    vector into the position of the iterator (`it`), then shortens the vector by one
    element. It's important to use `std::move()` instead of an assignment to move
    the element. The move operation is much faster than a copy-assignment, especially
    for large objects.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't require ordered elements, this is an extremely efficient technique.
    It happens in constant (*O(1)*) time and without touching any other elements.
  prefs: []
  type: TYPE_NORMAL
- en: Access vector elements directly and safely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `vector` is one of the most widely used containers in the STL, and for
    good reason. It''s just as convenient as an `array` but far more powerful and
    flexible. It''s common practice to use the `[]` operator to access elements in
    a vector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `vector` class also provides a member function for the same purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same but there is an important difference. The `at()` function
    does bounds checking and the `[]` operator does not. This is intentional, as it
    allows the `[]` operator to maintain compatibility with the original C-array.
    Let's examine this in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to access an element with an index in a vector. The `at()`
    member function does bounds checking, and the `[]` operator does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple `main()` function that initializes a vector and accesses an
    element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, I used the `[]` operator to directly access the third element in the vector.
    As with most sequential objects in C++, the index starts at `0` so the third element
    is number `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector has five elements, numbered `0` through `4`. If I were to try to
    access element number `5` that would be beyond the boundary of the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This result is extremely deceiving. It's a common error, since humans tend to
    count from 1, not 0\. But there is no guarantee that an element past the end of
    the vector has any particular value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even worse, the `[]` operator will silently allow you to *write* to a position
    beyond the end of the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I have now written to memory that is not under my control and the compiler has
    *silently* allowed it, with no error messages or crashes. But do not be fooledâ€”this
    is extremely dangerous code, and it *will* cause problems at some point in the
    future. Out of bounds memory access is one of the primary causes of security breaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to use the `at()` member function wherever possible, instead
    of the `[]` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we get a run-time exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The code compiles without error, but the `at()` function checks the boundaries
    of the container and throws a *run-time exception* when you try to access memory
    outside of those boundaries. This is the exception message from code compiled
    with the GCC compiler. The message will be different in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[]` operator and the `at()` member function do the same job; they provide
    direct access to container elements based on their indexed position. The `[]`
    operator does it without any bounds checking, so it may be a tiny bit faster in
    some intensely iterative applications.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the `at()` function *should be your default choice*. While the bounds
    checking may take a few CPU cycles, it's cheap insurance. For most applications
    the benefit is well worth the cost.
  prefs: []
  type: TYPE_NORMAL
- en: While the `vector` class is commonly used as a direct-access container, the
    `array` and `deque` containers also support both the `[]` operator and the `at()`
    member function. These caveats apply there as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's moreâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some applications you may not want your application to just *crash* when
    an out-of-bounds condition is encountered. In this case, you can *catch* the exception,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `try` block catches the exception specified in the `catch` clause, in this
    case the exception is `std::out_of_range`. The `e.what()` function returns a C-string
    with the error message from the STL library. Each library will have different
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this also applies to `array` and `deque` containers.
  prefs: []
  type: TYPE_NORMAL
- en: Keep vector elements sorted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vector` is a sequential container that keeps elements in the order in which
    they were inserted. It does not sort elements, nor change their order in any way.
    Other containers, such as `set` and `map`, keep elements sorted, but those containers
    are not random-access and may not have the features you need. You can, however,
    keep your vector sorted. It just requires a little bit of management.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea with this recipe is to create a simple function, `insert_sorted()`,
    that inserts an element into the correct position in a vector to keep the vector
    sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, we''ll start with a *type alias* for a vector of strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I like a type alias here because the exact details of the vector are not so
    important as its application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can define a couple of support functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `printv()` function is simple enough; it prints the elements of the vector
    on one line.
  prefs: []
  type: TYPE_NORMAL
- en: The `psorted()` function uses the *ranges* version of the `is_sorted()` algorithm
    to tell us if the vector is sorted. Then it calls `printv()` to print the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can initialize a `Vstr` vector in our `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At this point we have a `Vstr` vector with the names of some interesting musicians,
    in no particular order.
  prefs: []
  type: TYPE_NORMAL
- en: Let's sort our vector using the `ranges` version of the `sort()` algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we want to be able to insert items into the vector so that they''re
    already in sorted order. The `insert_sorted()` function does this for us:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `insert_sorted()` function uses the *ranges* version of the `lower_bound()`
    algorithm to get an iterator for the `insert()` function that keeps the vector
    sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the `insert_sorted()` function to insert more musicians into
    the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `insert_sorted()` function is used to insert elements into a sorted vector
    while maintaining its order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `lower_bound()` algorithm finds the first element *not less than* the argument.
    We then use the iterator returned by `lower_bound()` to insert an element at the
    correct position.
  prefs: []
  type: TYPE_NORMAL
- en: In this case we're using the ranges version of `lower_bound()`, but either version
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: There's moreâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `insert_sorted()` function can be made more generic by using a template.
    This version will work with other container types, such as `set`, `deque`, and
    `list`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the `std::sort()` algorithm (and its derivatives) requires
    a container that supports random access. Not all STL containers fulfill this requirement.
    Notably, `std::list` does not.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently insert elements into a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map` class is an associative container that holds *key-value pairs*, where
    keys must be unique within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to populate a map container. Consider a `map` defined
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add an element with the `[]` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `insert()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can use the `emplace()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: I tend to gravitate toward the `emplace()` function. Introduced with C++11,
    `emplace()` uses *perfect forwarding* to **emplace** (create in place) the new
    element for the container. The parameters are forwarded directly to the element
    constructors. This is quick, efficient, and easy to code.
  prefs: []
  type: TYPE_NORMAL
- en: Though it's certainly an improvement over the other options, the problem with
    `emplace()` is that it constructs an object even when it's not needed. This involves
    calling the constructors, allocating memory, and moving data around, and then
    discarding that temporary object.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, C++17 provides the new `try_emplace()` function which
    only constructs the *value object* if it's needed. This is especially important
    with large objects or many emplacements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Each element of a *map* is a key-value *pair*. Within the pair structure, the
    elements are named, `first` and `second`, but their purpose in the map is *key*
    and *value*. I tend to think of the value object as the *payload*, as this is
    usually the point of the map. To search for an existing key, the `try_emplace()`
    function must construct the key object; this cannot be avoided. But it need not
    construct the payload object unless and until it's needed for insertion into the
    map.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new `try_emplace()` function avoids the overhead of constructing the *payload
    object* unless and until it is needed. This creates a valuable efficiency in the
    case of key collisions, especially with large payloads. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a payload class. For demonstration purposes, this class has
    a simple `std::string` payload and displays a message when constructed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `BigThing` class has only one member function, a constructor that displays
    a message when the object is constructed. We'll use this to keep track of how
    often a `BigThing` object is constructed. In practice, of course, this class would
    be bigger, and use more resources.
  prefs: []
  type: TYPE_NORMAL
- en: Each map element will consist of a pair of objects, a `std::string` for the
    key and a `BigThing` object for the payload. `Mymap` is just a convenience alias.
    This allows us to focus on function rather than form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also create a `printm()` function to print the contents of the map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses the C++20 `format()` function to print out the map, so we can keep
    track of the elements as we insert them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function we create the map object and insert some elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Our output shows the construction of each of the payload objects, and then the
    output from the `printm()` function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the `emplace()` function to add the elements to the map, and each payload
    element was constructed just once. We can use the `try_emplace()` function and
    the result will be the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between `emplace()` and `try_emplace()` shows up when we try
    to insert new elements with duplicate keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `emplace()` function tried to add an element with a duplicate key (`"Hendrix"`).
    It failed but *still constructed* the payload object (`"Singer"`). The `try_emplace()`
    function also tried to add an element with a duplicate key (`"Zappa"`). It failed
    and *did not* construct the payload object.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates the distinction between `emplace()` and `try_emplace()`.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `try_emplace()` function signature is similar to that of `emplace()`, so
    it should be easy to retrofit legacy code. Here''s the `try_emplace()` function
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, this looks different from the `emplace()` signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The distinction is that `try_emplace()` uses a separate parameter for the *key*
    argument, which allows it to be isolated for construction. Functionally, if you''re
    using *template argument deduction*, `try_emplace()` can be a drop-in replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of `try_emplace()` is the same as that of `emplace()`, a pair
    representing an iterator and a bool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here I used *structured binding* (`auto [it, success] =`) with an `if` *initializer
    statement* to test the return value and conditionally update the payload. Notice
    that it still just constructs the payload object once.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that the `try_emplace()` function also works with `unordered_map`.
    We change our alias and everything works the same except unordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of `try_emplace()` is that it only constructs the payload object
    *if and when* it's ready to store it in the map. In practice, this should save
    significant resources at run-time. You should always favor `try_emplace()` over
    `emplace()`.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently modify the keys of map items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `map` is an associative container that stores key-value pairs. The container
    is ordered by the keys. The keys must be unique and they are `const`-qualified,
    so they cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I populate a `map` and attempt to change the key, I''ll get
    an error at compilation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you need to re-order a map container, you may do so by swapping keys using
    the `extract()` method.
  prefs: []
  type: TYPE_NORMAL
- en: New with C++17, `extract()` is a member function in the `map` class and its
    derivatives. It allows elements of a map to be extracted from the sequence without
    touching the payload. Once extracted, the key is no longer `const`-qualified and
    may be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example we'll define a map that represents contestants in a race. At
    some point during the race, the order changes and we need to modify the keys of
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining an alias for the `map` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to use the type consistently throughout our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll write a function for printing out the map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can pass the map to this function at any time to print out the current rankings
    of our contestants.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function we define a `map` with the initial state of our racers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The key is an `int` indicating the rank of the racer. The value is a `string`
    with the name of the racer.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `printm()` to print the current rank. The call to `node_swap()`
    will swap the keys of two racers, then we print gain.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, one of the racers falls behind and another racer takes the opportunity
    to move up in the rankings. The `node_swap()` function will swap the ranking of
    two racers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function uses the `map.extract()` method to extract the specified elements
    from the map. These extracted elements are called *nodes*.
  prefs: []
  type: TYPE_NORMAL
- en: A *node* is a new concept beginning with C++17\. This allows an element to be
    extracted from a map-type structure without touching the element itself. The node
    is unlinked, and a *node handle* is returned. Once extracted, the node handle
    provides *writable* access to the key via the node's `key()` function. We can
    then swap the keys and insert them back into the map, without ever having to copy
    or manipulate the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this code we get a printout of the map, before and after the node
    swap:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is all made possible by the `extract()` method and the new `node_handle`
    class. Let's take a closer look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique uses the new `extract()` function, which returns a `node_handle`
    object. As the name suggests, a `node_handle` is a handle to a *node*, which consists
    of an associative element and its related structures. The extract function *disassociates*
    the node while leaving it in place, and returns a `node_handle` object. This has
    the effect of removing the node from the associative container without touching
    the data itself. The `node_handle` allows you to access the disassociated node.
  prefs: []
  type: TYPE_NORMAL
- en: The `node_handle` has a member function, `key()`, which returns a *writable*
    reference to the node key. This allows you to change the key, while it's disassociated
    from the container.
  prefs: []
  type: TYPE_NORMAL
- en: There's moreâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few things to keep in mind when using `extract()` and a `node_handle`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the key is not found, the `extract()` function returns an *empty* node handle.
    You can test if a node handle is empty with the `empty()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two overloads of the `exract()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We used the first form, by passing a key. You may also use an iterator, which
    should not require a lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you cannot make a reference from a literal, so a call like
    `extract(1)` will usually crash with a segmentation fault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys must remain unique when inserted into a `map`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if I try to change a key to a value already in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The insert fails and we get our error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this example I've passed the `begin()` iterator to `extract()`. I then assigned
    the key a value that's already in use (5, *Donkey Kong Jr*). The insert failed
    and the resulting `status.inserted` is false. `status.position` is an iterator
    to the found key. In the `if()` block, I used `format()` to print the value the
    found key.
  prefs: []
  type: TYPE_NORMAL
- en: Use unordered_map with custom keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an ordered `map`, the type of the key must be sortable, which means it
    must at least support the less-than `<` comparison operator. Suppose you want
    to use an associative container with a custom type that is not sortable. For example,
    a vector where `(0, 1)` is not smaller or larger than `(1, 0)`, it simply points
    in a different direction. In such cases, you may still use the `unordered_map`
    type. Let's look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe we'll create an `unordered_map` object that uses *x*/*y* coordinates
    for the key. We will need a few support functions for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a structure for the coordinates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple structure with two members, `x` and `y`, for the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our map will use the `Coord` structure for the key, and an `int` for the value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use a `using` alias to make it convenient to use our map.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Coord` struct as a key, we need a couple of overloads. These are
    required for use with an `unordered_map`. First, we''ll define an equality comparison
    operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's a simple function that compares the `x` members with each other, and the
    `y` members with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a `std::hash` class specialization. This makes it possible to
    retrieve map elements with the key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This provides a specialization for the default `hash` class used by the `std::unordered_map`
    class. It must be in the `std` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also write a print function to print a `Coordmap` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses the C++20 `format()` function to print the *x*/*y* key and the value.
    Notice the use of the double braces, `{{` and `}}`, to print single braces.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all our support functions, we can write the `main()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we've defined a `Coordmap` object that accepts `Coord` objects
    for the keys and maps them to arbitrary values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also access individual members based on the `Coord` keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a `Coord` object named `k`, and we use that with the `at()` function
    to retrieve a value from the `unordered_map`.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `unordered_map` class relies on a hash class to lookup elements from the
    key. We normally instantiate an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s not obvious here is that, because we haven''t one, it''s using a *default
    hash class*. The full template type definition of the `unordered_map` class looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The template provides default values for `Hash`, `KeyEqual`, and `Allocator`,
    so we don't normally include them in our definitions. In our example, we've provided
    a specialization for the default `std::hash` class.
  prefs: []
  type: TYPE_NORMAL
- en: The STL contains specializations of `std::hash` for most of the standard types,
    like `string`, `int`, and so on. For it to work with our class, it needs a specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have passed a function to the template parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: That certainly would work. In my view, the specialization is more general.
  prefs: []
  type: TYPE_NORMAL
- en: Use set to sort and filter user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `set` container is an associative container where each element is a *single
    value*, which is used as the key. Elements in a `set` are maintained in sorted
    order and duplicate keys are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The `set` container is often misunderstood, and it does have fewer and more
    specific uses than more general containers such as `vector` and `map`. One common
    use for a `set` is to filter duplicates from a set of values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will read words from the *standard input* and filter out the
    duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by defining an alias for an `istream` iterator. We'll use this to
    get input from the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we''ll define a `set` for our words:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set` is defined as a set of `string` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a pair of iterators for use with the `inserter()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `end` iterator is initialized with its default constructor. This is known
    as the *end-of-stream* iterator. When our input ends, this iterator will compare
    equal with the `cin` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inserter()` function is used to insert elements into the `set` container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `std::copy()` to conveniently copy words from the input stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can print out our `set` to see the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the program by piping a bunch of words to its input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set` has eliminated the duplicates and retained a sorted list of the words
    that were inserted.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `set` container is the heart of this recipe. It only holds unique elements.
    When you insert a duplicate, that insert will fail. So, you end up with a sorted
    list of each unique element.
  prefs: []
  type: TYPE_NORMAL
- en: But that's not the only interesting part of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `istream_iterator` is an input iterator that reads objects from a stream.
    We instantiated the input iterator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Now we have an input iterator of type `string` from the `cin` stream. Every
    time we dereference this iterator, it will return one word from the input stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also instantiated another `istream_iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This calls the default constructor, which gives us a special *end-of-stream*
    iterator. When the input iterator reaches the end of the stream, it will become
    equal to the *end-of-stream* iterator. This is convenient for ending loops, such
    as the one created by the `copy()` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copy()` algorithm takes three iterators, the beginning and end of the
    range to copy, and a destination iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `inserter()` function takes a container and an iterator for the insertion
    point, and returns an `insert_iterator` of the appropriate type for the container
    and its elements.
  prefs: []
  type: TYPE_NORMAL
- en: This combination of `copy()` and `inserter()` makes it easy to copy elements
    from a stream into the `set` container.
  prefs: []
  type: TYPE_NORMAL
- en: A simple RPN calculator with deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **RPN** (**Reverse Polish Notation**) calculator is a stack-based calculator
    that uses postfix notation, where the operator follows the operands. It's commonly
    used in printing calculators and, notably, the HP 12C, the most popular electronic
    calculator of all time.
  prefs: []
  type: TYPE_NORMAL
- en: After becoming familiar with its operational modality, many people prefer an
    RPN calculator. (I've been using the HP 12C and 16C since they were first introduced
    in the early 1980s.) For example, using conventional algebraic notation, to add
    1 and 2 you would type `1 + 2`. Using RPN, you would type `1 2 +`. The operator
    comes *after* the operands.
  prefs: []
  type: TYPE_NORMAL
- en: Using an algebraic calculator, you would need to press an `=` key to indicate
    that you want a result. With an RPN calculator this is unnecessary because the
    operator processes immediately, serving a double purpose. On the other hand, an
    RPN calculator often requires an *Enter* keypress to push an operand onto the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily implement an RPN calculator using a stack-based data structure.
    For example, consider an RPN calculator with a four-position stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 â€“ RPN addition operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 â€“ RPN addition operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Each operand is pushed onto the stack as they are entered. When the operator
    is entered, the operands are popped off, operated upon, and the result is pushed
    back onto the stack. The result may then be used in the next operation. For example,
    consider the case of `(3+2)Ã—3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 â€“ RPN stack operations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 â€“ RPN stack operations
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of RPN is that you can leave operands on the stack for future
    calculations, reducing the need for separate memory registers. Consider the case
    of `(9Ã—6)+(2Ã—3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 â€“ RPN multiple stack operations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 â€“ RPN multiple stack operations
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we first perform the operations within the parentheses, then the
    final operation on the intermediate results. This may seem more complex at first,
    but it makes a lot of sense once you get used to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's build a simple RPN calculator using the STL `deque` container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this implementation, we'll use a `deque` container for our stack. Why not
    use a `stack` container? The `stack` class is a container-adapter, which uses
    another container (usually a `deque`) for its storage. For our purposes, `stack`
    doesn't provide any tangible advantage over `deque`. And `deque` allows us to
    iterate over and display the RPN stack, like a paper tape calculator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll encapsulate our RPN calculator in a class. There are a few advantages
    to using a class here. *Encapsulation* provides *safety*, *reusability*, *extensibility*,
    and a *clean interface*. We''ll call our class `RPN`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `deque` data store, named `deq_`, is in the private area of the class to
    protect it. This is where we store the RPN stack.
  prefs: []
  type: TYPE_NORMAL
- en: The `zero_` constant is used throughout the class, both as a return value and
    as a comparison operand. The `inf_` constant is used for a divide-by-zero error.
    These constants are declared `constexpr static` so they don't take up space in
    every instance.
  prefs: []
  type: TYPE_NORMAL
- en: I like to name private data members with a trailing underscore to remind me
    that they're private.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need an explicit constructor or destructor because the `deque` class
    manages its own resources. So, our public interface consists of just three functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `double op()` function is the main entry point for the RPN class. It takes
    a `string`, with either a number or an operator. If it's a number, it's converted
    into a `double` and pushed onto the stack. If it's an operator, we call `optor()`
    to perform the operation. This is the main logic of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The `void clear()` function simply calls `clear()` on the `deque` to empty the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, the `string get_stack_string()` function returns the contents of
    the stack in a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `private` section, we have the supporting utilities that make the interface
    work. The `pop_get2()` function pops two operands from the stack and returns them
    as a pair. We use this as operands for the operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `is_numeric()` function checks to see if the string is entirely numeric.
    We also allow the decimal `.` character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `optor()` function performs the operators. We use a `map` container to map
    an operator to a corresponding lambda function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `map` container with lambda functions makes a quick and easy jump table.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `find()` function in `map` to test if we have a valid operator.
  prefs: []
  type: TYPE_NORMAL
- en: After a test for divide-by-zero, the `map` is dereferenced, and the operator
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the operation is pushed onto the stack and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those are all the function members of the `RPN` class. Now we can use it in
    our `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll test this is by piping a string into the program from the command line.
    We use a `for` loop to fetch each word from the `cin` stream and pass it to `rpn.op()`.
    I like the `for` loop here, as it's easy to contain the scope of the `o` variable.
    We then print the stack using the `get_stack_string()` function after each command
    line item.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the program by piping in an expression like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This looks like a lot of coding but it's actually quite simple. With the comments,
    the `RPN` class is less than 70 lines of code. The full `rpn.cpp` source code
    is in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RPN` class operates by first determining the nature of each chunk of input.
    If it's a number, we push it onto the stack. If it's an operator, we pop two operands
    off the top of the stack, apply the operation, and push the result back on the
    stack. If we don't recognize the input, we just ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: The `deque` class is a double-ended queue. To use it as a stack, we pick an
    end and both push and pop from that same end. I chose the `front` end of the deque,
    but it would work just as well from the `back`. We just need to do everything
    from the same end.
  prefs: []
  type: TYPE_NORMAL
- en: If we determine that an input is numeric, we convert it to a `double` and push
    it onto the front of the `deque` using `push_front()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: When we need to use values from the stack, we pop them off the front of the
    deque. We use `front()` to get the value, and then `pop_front()` to pop it off
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Using a map for our operators makes it easy to both check if an operator is
    valid, and to execute the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test for the validity of an operator by using the `find()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can call the operator by dereferencing the `map` with the `at()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We both call the operator lambda and push the result onto the `deque` in one
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: There's moreâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use the `cin` stream to feed operations to the RPN calculator.
    It would be just as easy to do this with an STL container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: By putting the RPN calculator in a class with a clean interface, we've created
    a flexible tool that can be used in many different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: A word frequency counter with map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the unique key property of the `map` container to count duplicate
    words from a stream of text.
  prefs: []
  type: TYPE_NORMAL
- en: The STL `map` container is an *associative* container. It consists of elements
    organized in *key-value pairs*. The keys are used for lookup and must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will leverage the unique key requirement of the STL `map`
    container to count the number of occurrences of each word in a text file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few parts to this task that we can solve separately:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to get the text from a file. We'll use the `cin` stream for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to separate words from punctuation and other non-word content. We'll
    use the `regex` (Regular Expression) library for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to count the frequency of each word. This is the main objective of the
    recipe. We'll use the STL `map` container for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to sort the results, first by frequency and then alphabetically
    by word within frequency. For this we'll use a the STL `sort` algorithm with a
    `vector` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Even with all those tasks, the resulting code is relatively short, just about
    70 lines with headers and all. Let''s dive in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with some aliases for convenience:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For namespaces within the `std::` space, I like to make aliases that are shorter,
    but still let me know that I'm using a token in a particular namespace. Especially
    with the `ranges` namespace, which often re-uses the names of existing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store the regular expression in a constant. I don''t like to clutter up
    the global namespace because that can lead to collisions. I tend to use a namespace
    based on my initials for things like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's easy enough to get it later using `bw::re`, and that tells me exactly what
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `main()`, we define our data structures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our main `map` is called `wordmap`. We have a `vector` named `wordvec` that
    we'll use as a sorting container. And finally, our `regex` class, `word_re`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop is where most of the work happens. We read text from the `cin`
    stream, apply the `regex`, and store words in the `map`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I like a `for` loop for this because it allows me to contain the scope of the
    `s` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining iterators for the `regex` results. This allows us to distinguish
    multiple words even when surrounded only by punctuation. The `for(r_it...)` loop
    returns individual words from the `cin` string.
  prefs: []
  type: TYPE_NORMAL
- en: The `smatch` type is a specialization of a `regex` string match class. It gives
    us the next word from our `regex`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `transform` algorithm to make the words lowercase â€“ so we can
    count words regardless of case. (For example, "The" is the same word as "the".)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `try_emplace()` to add the word to the map. If it's already there,
    it will not be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we increment the count for the word in the `map` with `++count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the words and their frequency counts in our `map`. But they''re
    in alphabetical order and we want them in descending order of frequency. For this,
    we put them in a vector and sort them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`wordvec` is a vector of pairs, with the word and the frequency count. We use
    the `ranges::move()` algorithm to populate the `vector`, then the `ranges::sort()`
    algorithm to sort the `vector`. Notice that the *predicate lambda function* sorts
    first by the count (descending) and then by the word (ascending).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we print the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I set a limit to print only the first 20 entries. You can comment out the `if(--limit
    == 0) break;` line to print the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example files, I''ve included a text file with a copy of *The Raven*,
    by Edgar Allen Poe. The poem is in the public domain. We can use this to test
    the program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The poem has 1,098 words total, and 439 of them are unique.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of the recipe is the use of a `map` object to count duplicate words.
    But there are other parts that merit consideration.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `cin` stream to read text from the *standard input*. By default,
    `cin` will skip *whitespace* when reading into a `string` object. By putting a
    string object on the right-hand side of the `>>` operator (`cin >> s`) we get
    chunks of text separated by whitespace. This is a good enough definition of a
    word-at-a-time for many purposes, but we need linguistic words. And for that we
    will use a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `regex` class provides a choice of regular expression *grammars* and it
    defaults to *ECMA* grammar. In the ECMA grammar, the regular expression `"(\w+)"`
    is a shortcut for `"([A-Za-z0-9_]+)"`. This will select words that include these
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are a language unto themselves. To learn more about regular
    expressions, I recommend the book *Mastering Regular Expressions* by Jeffrey Friedl.
  prefs: []
  type: TYPE_NORMAL
- en: As we get each word from the `regex` engine, we use the map object's `try_emplace()`
    method to conditionally add the word to our `wordmap`. If the word is not in the
    map, we add it with a count of `0`. If the word is already in the map, the count
    is untouched. We increment the count later in the loop, so it's always correct.
  prefs: []
  type: TYPE_NORMAL
- en: After the map is populated with all the unique words from the file, we transfer
    it to a vector using the `ranges::move()` algorithm. The `move()` algorithm makes
    this transfer quick and efficient. Then we can sort it in the vector using `ranges::sort()`.
    The *predicate lambda function* for sorting includes comparisons for both sides
    of the pair, so we end up with a result that's sorted by both word count (descending)
    and the word.
  prefs: []
  type: TYPE_NORMAL
- en: Find long sentences with a vector of vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be useful for a writer to make sure they are using variety of sentence
    lengths, or to ensure none of their sentences are too long. Let's build a tool
    that evaluates a text file for sentence length.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the appropriate container is key when using the STL. If you need something
    ordered, it's often best to use an associative container, such as `map` or `multimap`.
    In this case, however, since we need a custom sort, it's easier to sort a `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` is generally the most flexible of the STL containers. Whenever
    another container type seems appropriate, but is missing one important capability,
    the `vector` is often an effective solution. In this case, where we need a custom
    sort, the vector works great.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe uses a *vector of vectors*. The inner `vector` stores the words
    of a sentence, and the outer `vector` stores the inner `vector`s. As you'll see,
    this affords a lot of flexibility while retaining all the relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program needs to read in words, find the ends of sentences, store and sort
    the sentences, then print out the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by writing a little function to tell us when we''ve hit the end
    of a sentence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `is_eos()` function uses `string_view` because it's efficient and we don't
    need anything more. Then we use the `strchr()` library function to check if a
    word contains one of the end-of-sentence punctuation characters (`".!?"`). These
    are the three possible characters to end a sentence in the English language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we start by defining the *vector of vectors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a `vector` of elements typed `vector<string>` named `vv_sentences`.
    The `vv_sentences` object is initialized with one empty vector for the first sentence.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a vector that contains other vectors. The inner vectors will each
    hold a sentence of words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can process the stream of words:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `for` loop returns one word at a time from the input stream. The `back()`
    method on the `vv_sentences` object is used to access the current vector of words,
    and the current word is added using `emplace_back()`. Then we call `is_eos()`
    to see if this was the end of a sentence. If so, we add a new empty vector to
    `vv_sentences` to start the next sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we always add a new empty vector to the end of `vv_sentences` after
    each end-of-sentence character, we will usually end up with an empty sentence
    vector at the end. Here we check for this, and delete it if necessary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can sort the `vv_sentences` vector by the size of the sentences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is why the `vector` is so convenient for this project. It's quick and easy
    to sort using the `ranges::sort()` algorithm with a simple *predicate* for sorting
    by size in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can print our result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The outer loop and the inner loop correspond to the outer and inner vectors.
    We simply loop through the vectors and print out the size of the inner vector
    with `format("{}: ", size)` and then each word with `format("{} ", s)`. We don''t
    want to print the very long sentences in their entirety, so we define a limit
    of 10 words and print an ellipsis if there''s more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this, using the first few paragraphs of this recipe for
    input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding punctuation is simple using the `strchr()` function from the C Standard
    Library. Remember, all of C and its Standard Library are included in the definition
    of the C++ language. There's no reason not to use it where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: This function will fail to properly separate sentences if there's punctuation
    in the middle of words. That may happen in some forms of poetry or in a badly
    formatted text file. I've seen this done with `std::string` iterators, and with
    regular expressions, but for our purposes this is quick and easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We read the text file one word at a time using `cin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This avoids the overhead of reading a large file into memory all at once. The
    `vector` will already be large, containing all the words of the file. It's not
    necessary to also hold the entire text file in memory. In the rare case that a
    file is too large, it would be necessary to find another strategy, or use a database.
  prefs: []
  type: TYPE_NORMAL
- en: The *vector of vectors* may look complex at first glance, but it's no more complicated
    than using two separate vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This declares an *outer* `vector`, with *inner* elements of type `vector<string>`.
    The *outer* vector is named `vv_sentences`. The *inner* vectors are anonymous;
    they require no name. This definition initializes the `vv_sentences` object with
    one element, an empty `vector<string>` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *current* inner vector will always be available as `vv_senteces.back()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''ve completed one inner vector, we simply create a new one with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new anonymous `vector<string>` object and *emplaces* it at the
    back of the `vv_sentences` object.
  prefs: []
  type: TYPE_NORMAL
- en: A ToDo list using multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ordered task list (or a *ToDo list*) is a common computing application. Formally
    stated, it's a list of tasks associated with a priority, sorted in reverse numerical
    order.
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to use a `priority_queue` for this, because as the name implies,
    it's already sorted in priority (reverse numerical) order. The disadvantage of
    a `priority_queue` is that it has no iterators, so it's difficult to operate on
    it without pushing and popping items to and from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll use a `multimap` for the ordered list. The `multimap`
    *associative container* keeps items in order, and it can be accessed using *reverse
    iterators* for the proper sort order.
  prefs: []
  type: TYPE_NORMAL
- en: How to do itâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a short and simple recipe that initializes a `multimap` and prints it
    in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a type alias for our `multimap`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `todomap` is a `multimap` with an `int` key and a `string` payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a small utility function for printing the `todomap` in reverse order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses reverse iterators to print the `todomap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function is short and sweet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We initialize the `todomap` with tasks. Notice that the tasks are not in any
    particular order, but they do have priorities in the keys. The `rprint()` function
    will print them in priority order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ToDo list prints out in priority order, just as we need it.
  prefs: []
  type: TYPE_NORMAL
- en: How it worksâ€¦
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's a short and simple recipe. It uses the `multimap` container to hold items
    for a prioritized list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only trick is in the `rprint()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Notice the reverse iterators, `rbegin()` and `rend()`. It's not possible to
    change the sort order of a `multimap`, but it does provide reverse iterators.
    This makes the `multimap` behave exactly as we need it for our prioritized list.
  prefs: []
  type: TYPE_NORMAL
