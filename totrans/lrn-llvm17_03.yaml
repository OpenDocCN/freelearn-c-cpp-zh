- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Structure of a Compiler
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器的结构
- en: Compiler technology is a well-studied field of computer science. The high-level
    task is to translate a source language into machine code. Typically, this task
    is divided into three parts, the **frontend**, the **middle end**, and the **backend**.
    The frontend deals mainly with the source language, while the middle end performs
    transformation to improve the code and the backend is responsible for the generation
    of machine code. Since the LLVM core libraries provide the middle end and the
    backend, we will focus on the frontend within this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编译技术是计算机科学中一个研究得很好的领域。高级任务是将源语言翻译成机器代码。通常，这个任务被分为三个部分，**前端**、**中间端**和**后端**。前端主要处理源语言，而中间端执行转换以改进代码，后端负责生成机器代码。由于LLVM核心库提供了中间端和后端，因此在本章中我们将重点关注前端。
- en: 'In this chapter, you will cover the following sections and topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将涵盖以下部分和主题：
- en: '*Building blocks of a compiler*, in which you will learn about the components
    typically found in a compiler'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译器的构建块*，其中你将了解在编译器中通常可以找到的组件'
- en: '*An arithmetic expression language*, which will introduce you to an example
    language and show how grammar is used to define a language'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算术表达式语言*，将介绍一个示例语言并展示如何使用语法来定义语言'
- en: '*Lexical analysis*, which discusses how to implement a lexer for the language'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*词法分析*，讨论如何为语言实现一个词法分析器'
- en: '*Syntactical analysis*, which covers the construction of a parser from the
    grammar'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语法分析*，涵盖了从语法构建解析器的构造'
- en: '*Semantic analysis*, in which you will learn how a semantic check can be implemented'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语义分析*，其中你将了解如何实现语义检查'
- en: '*Code generation with the LLVM backend*, which discusses how to interface with
    the LLVM backend and glue all the preceding phases together to create a complete
    compiler'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用LLVM后端进行代码生成*，讨论如何与LLVM后端接口并将所有前面的阶段粘合在一起以创建一个完整的编译器'
- en: Building blocks of a compiler
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器的构建块
- en: Since computers became available, thousands of programming languages have been
    developed. It turns out that all compilers must solve the same tasks and that
    the implementation of a compiler is best structured according to these tasks.
    At a high level, there are three components. The frontend turns the source code
    into an **intermediate representation** (**IR**). Then the middle end performs
    transformations on the IR, with the goal of either improving performance or reducing
    the size of the code. Finally, the backend produces machine code from the IR.
    The LLVM core libraries provide a middle end consisting of very sophisticated
    transformations and backends for all popular platforms. Furthermore, the LLVM
    core libraries also defines an intermediate representation used as input for the
    middle end and the backend. This design has the advantage that you only need to
    care about the frontend for the programming language you want to implement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自从计算机变得可用以来，已经开发了数千种编程语言。结果证明，所有编译器都必须解决相同的问题，并且编译器的实现最好是根据这些任务来结构化。在高级别上，有三个组件。前端将源代码转换为**中间表示**（**IR**）。然后中间端对IR进行转换，目的是提高性能或减少代码的大小。最后，后端从IR生成机器代码。LLVM核心库提供了由非常复杂的转换和所有流行平台的后端组成的中间端。此外，LLVM核心库还定义了一个中间表示，用作中间端和后端的输入。这种设计的好处是，你只需要关注你想要实现的编程语言的前端。
- en: The input for the frontend is the source code, usually a text file. To make
    sense of it, the frontend first identifies the words of the language, such as
    numbers and identifiers, which are usually called tokens. This step is performed
    by the **lexer**. Next, the syntactical structure formed by the tokens is analyzed.
    The so-called **parser** performs this step, and the result is the **abstract
    syntax tree** (**AST**). Last, the frontend needs to check that the rules of the
    programming language are obeyed, which is done by the **semantic analyzer**. If
    no errors were detected, then the AST is transformed into IR and handed over to
    the middle end.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前端输入是源代码，通常是文本文件。为了理解它，前端首先识别语言的单词，如数字和标识符，通常称为标记。这一步由**词法分析器**执行。接下来，分析由标记形成的句法结构。所谓的**解析器**执行这一步，结果是**抽象语法树**（**AST**）。最后，前端需要检查编程语言的规则是否被遵守，这是通过**语义分析器**完成的。如果没有检测到错误，那么AST将转换为IR并传递给中间端。
- en: In the following sections, we will construct a compiler for an expression language,
    which produces LLVM IR from its input. The LLVM `llc` static compiler, representing
    the backend, can then be used to compile the IR into object code. It all begins
    with defining the language. Keep in mind that all of the C++ implementation of
    the files within this chapter will be contained within a directory called `src/`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将构建一个表达式语言的编译器，它将输入转换为 LLVM IR。然后，代表后端的 LLVM `llc` 静态编译器可以用来将 IR
    编译成目标代码。一切始于定义语言。请记住，本章中所有文件的 C++ 实现都将包含在一个名为 `src/` 的目录中。
- en: An arithmetic expression language
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术表达式语言
- en: 'Arithmetic expressions are a part of every programming language. Here is an
    example of an arithmetic expression calculation language called **calc**. The
    calc expressions are compiled into an application that evaluates the following
    expression:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式是每种编程语言的一部分。以下是一个名为 **calc** 的算术表达式计算语言的示例。calc 表达式被编译成一个应用程序，该应用程序评估以下表达式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The used variables in the expression must be declared with the keyword, `with`.
    This program is compiled into an application that asks the user for the values
    of the `a` and `b` variables and prints the result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中所使用的变量必须用关键字 `with` 声明。这个程序被编译成一个应用程序，该应用程序会询问用户 `a` 和 `b` 变量的值，并打印结果。
- en: Examples are always welcome but, as a compiler writer, you need a more thorough
    specification than this for implementation and testing. The vehicle for the syntax
    of the programming language is the grammar.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例总是受欢迎的，但作为一个编译器编写者，你需要比这更详尽的规范来进行实现和测试。编程语言语法的载体是语法。
- en: Formalism for specifying the syntax of a programming language
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程语言语法的形式化规范
- en: The elements of a language, for example, keywords, identifiers, strings, numbers,
    and operators, are called **tokens**. In this sense, a program is a sequence of
    tokens, and the grammar specifies which sequences are valid.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 语言元素，例如，关键字、标识符、字符串、数字和运算符，被称为**标记**。在这个意义上，程序是一系列标记的序列，而语法指定了哪些序列是有效的。
- en: 'Usually, grammar is written in the **extended Backus-Naur form** (**EBNF**).
    A rule in grammar has a left and a right side. The left side is just a single
    symbol called **non-terminal**. The right side of a rule consists of non-terminals,
    tokens, and meta-symbols for alternatives and repetitions. Let’s have a look at
    the grammar of the calc language:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，语法是用**扩展的巴科斯-诺尔范式**（**EBNF**）编写的。语法规则有一个左侧和一个右侧。左侧只是一个称为**非终结符**的单个符号。规则的右侧由非终结符、标记和用于选择和重复的元符号组成。让我们看看
    calc 语言的语法：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line, `calc` is a non-terminal. If not otherwise stated, then the
    first non-terminal of a grammar is the start symbol. The colon (`:`) is the separator
    between the left and the right side of the rule. Here, `"with"`, `","` and `":"`
    are tokens that represent this string. Parentheses are used for grouping. A group
    can be optional or repeated. A question mark (`?`) after the closing parenthesis
    denotes an optional group. A star `*` denotes zero or more repetitions and a plus
    `+` denotes one or more repetitions. `Ident` and `expr` are non-terminals. For
    each of them, another rule exists. The semicolon (`;`) marks the end of a rule.
    The pipe `|`, in the second line, denotes an alternative. And last, the brackets
    `[ ]`, in the last two lines, denote a character class. The valid characters are
    written inside the brackets. For example, the character class `[a-zA-Z]` matches
    an upper- or lower-case letter, and `([a-zA-Z])+` matches one or more of these
    letters. This corresponds to a regular expression.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，`calc` 是一个非终结符。除非另有说明，否则语法中的第一个非终结符是起始符号。冒号 (`:`) 是规则左右两侧的分隔符。在这里，`"with"`、`,`
    和 `":"` 是代表这个字符串的标记。括号用于分组。一个分组可以是可选的或可重复的。在闭括号后面的问号 (`?`) 表示一个可选分组。星号 `*` 表示零个或多个重复，而加号
    `+` 表示一个或多个重复。`Ident` 和 `expr` 是非终结符。对于它们中的每一个，都存在另一个规则。分号 (`;`) 标记规则的结束。在第二行中，竖线
    `|` 表示选择。最后，在最后两行中，方括号 `[ ]` 表示字符类。有效的字符写在方括号内。例如，字符类 `[a-zA-Z]` 匹配大写或小写字母，而 `([a-zA-Z])+"`
    匹配这些字母的一个或多个。这对应于正则表达式。
- en: How does grammar help the compiler writer?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法如何帮助编译器编写者？
- en: Such grammar may look like a theoretical toy, but it is of value to the compiler
    writer. First, all the tokens are defined, which is needed to create the lexical
    analyzer. The rules of the grammar can be translated into the parser. And of course,
    if questions arise about whether the parser works correctly, then the grammar
    serves as a good specification.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的语法可能看起来像是一个理论玩具，但对编译器编写者来说是有价值的。首先，定义所有标记，这是创建词法分析器所需的。语法的规则可以翻译成解析器。当然，如果关于解析器是否正确工作有疑问，那么语法就作为一个好的规范。
- en: However, grammar does not define all aspects of a programming language. The
    meaning – the semantics – of the syntax must also be defined. Formalisms for this
    purpose were developed, too, but very often, they are specified in plain text,
    as they were usually drawn up at the initial introduction of the language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，语法并没有定义编程语言的各个方面。句法的意义——即语义——也必须定义。为此也开发了形式化方法，但它们通常以纯文本形式指定，因为它们通常在语言最初引入时制定。
- en: Equipped with this knowledge, the next two sections show how the lexical analysis
    turns the input into a sequence of tokens and how the grammar is coded in C++
    for the syntactical analysis.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，接下来的两节将展示词法分析如何将输入转换为标记序列，以及语法是如何在 C++ 中编码以进行句法分析的。
- en: Lexical analysis
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法分析
- en: As already seen in the example in the previous section, a programming language
    consists of many elements such as keywords, identifiers, numbers, operators, and
    so on. The task of the lexical analyzer is to take the textual input and create
    a sequence of tokens from it. The calc language consists of the tokens `with`,
    `:`, `+`, `-`, `*`, `/`, `(`, `)`, and regular expressions `([a-zA-Z])+` (an identifier)
    and `([0-9])+` (a number). We assign a unique number to each token to make the
    handling of tokens easier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节示例所示，一种编程语言由许多元素组成，如关键字、标识符、数字、运算符等。词法分析器的任务是从文本输入中创建一个标记序列。calc 语言由以下标记组成：`with`、`:`、`+`、`-`、`*`、`/`、`(`、`)`，以及正则表达式
    `([a-zA-Z])+"`（一个标识符）和 `([0-9])+"`（一个数字）。我们为每个标记分配一个唯一的数字，以便更容易地处理标记。
- en: A hand-written lexer
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手写词法分析器
- en: 'The implementation of a lexical analyzer is often called `Lexer`. Let’s create
    a header file called `Lexer.h` and get started with the definition of `Token`.
    It begins with the usual header guard and the inclusion of the required headers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器的实现通常被称为 `Lexer`。让我们创建一个名为 `Lexer.h` 的头文件，并开始定义 `Token`。它以通常的头文件保护符和包含所需头文件开始：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `llvm::MemoryBuffer` class provides read-only access to a block of memory,
    filled with the content of a file. On request, a trailing zero character (`'\x00'`)
    is added to the end of the buffer. We use this feature to read through the buffer
    without checking the length of the buffer at each access. The `llvm::StringRef`
    class encapsulates a pointer to a C string and its length. Because the length
    is stored, the string need not be terminated with a zero character (`'\x00'`)
    like normal C strings. This allows an instance of `StringRef` to point to the
    memory managed by `MemoryBuffer`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm::MemoryBuffer` 类提供了对包含文件内容的内存块的只读访问。在请求时，会在缓冲区末尾添加一个尾随零字符（`''\x00''`）。我们使用这个特性来读取缓冲区，而无需在每次访问时检查缓冲区的长度。`llvm::StringRef`
    类封装了一个指向 C 字符串及其长度的指针。因为长度被存储，字符串不需要以零字符（`''\x00''`）结尾，就像正常的 C 字符串一样。这允许 `StringRef`
    实例指向由 `MemoryBuffer` 管理的内存。'
- en: 'With this in mind, we begin by implementing the `Lexer` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们开始实现 `Lexer` 类：
- en: 'First, the `Token` class contains the definition of the enumeration for the
    unique token numbers mentioned previously:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`Token` 类包含了之前提到的唯一标记数字枚举的定义：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Besides defining a member for each token, we added two additional values: `eoi`
    and `unknown`. `eoi` stands for *end of input* and is returned when all characters
    of the input are processed. `unknown` is used in the event of an error at the
    lexical level, e.g., `#` is no token of the language and would therefore be mapped
    to `unknown`.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了为每个标记定义一个成员外，我们还添加了两个额外的值：`eoi` 和 `unknown`。`eoi` 代表 *输入结束*，当处理完输入的所有字符时返回。`unknown`
    用于词法层面的错误事件，例如，`#` 不是语言的标记，因此会被映射到 `unknown`。
- en: 'In addition to the enumeration, the class has a `Text` member, which points
    to the start of the text of the token. It uses the `StringRef` class mentioned
    previously:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了枚举之外，该类还有一个 `Text` 成员，它指向标记文本的开始。它使用之前提到的 `StringRef` 类：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is useful for semantic processing, e.g., for an identifier, it is useful
    to know the name.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这对于语义处理很有用，例如，对于一个标识符，知道其名称是有用的。
- en: 'The `is()` and `isOneOf()` methods are used to test whether the token is of
    a certain kind. The `isOneOf()` method uses a variadic template, allowing a variable
    number of arguments:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is()` 和 `isOneOf()` 方法用于测试标记是否属于某种类型。`isOneOf()` 方法使用变长模板，允许有可变数量的参数：'
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Lexer` class itself has a similar simple interface and comes next in the
    header file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Lexer` 类本身也有一个类似的简单接口，并在头文件中紧接着：'
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Except for the constructor, the public interface has only the `next()` method,
    which returns the next token. The method acts like an iterator, always advancing
    to the next available token. The only members of the class are pointers to the
    beginning of the input and the next unprocessed character. It is assumed that
    the buffer ends with a terminating `0` (just like a C string).
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了构造函数外，公共接口只有 `next()` 方法，该方法返回下一个标记。该方法的行为像一个迭代器，总是前进到下一个可用的标记。该类唯一的成员是指向输入开始和下一个未处理字符的指针。假设缓冲区以终止的
    `0` 结尾（就像 C 字符串一样）。
- en: 'Let’s implement the `Lexer` class in the `Lexer.cpp` file. It begins with some
    helper functions to classify characters:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `Lexer.cpp` 文件中实现 `Lexer` 类。它开始于一些辅助函数来分类字符：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions are used to make conditions more readable.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些函数用于使条件更易读。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are not using the functions provided by the `<cctype>` standard library header
    for two reasons. First, these functions change behavior based on the locale defined
    in the environment. For example, if the locale is a German-language area, then
    German umlauts can be classified as letters. This is usually not wanted in a compiler.
    Second, since the functions have `int` as a parameter type, a conversion from
    the `char` type is required. The result of this conversion depends on whether
    `char` is treated as a signed or unsigned type, causing portability problems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用 `<cctype>` 标准库头文件提供的函数有两个原因。首先，这些函数的行为取决于环境中定义的区域设置。例如，如果区域设置为德语区域，那么德语的重音符号可以被分类为字母。在编译器中这通常是不希望的。其次，由于这些函数的参数类型为
    `int`，需要从 `char` 类型进行转换。这个转换的结果取决于 `char` 是否被视为有符号或无符号类型，这会导致可移植性问题。
- en: 'From the grammar in the previous section, we know all the tokens of the language.
    But the grammar does not define the characters that should be ignored. For example,
    a space or newline character adds only whitespace and are often ignored. The `next()`
    method begins with ignoring these characters:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一节中的语法，我们知道该语言的所有标记。但是语法并没有定义应该忽略的字符。例如，空格或换行符仅添加空白，通常会被忽略。`next()` 方法开始时就会忽略这些字符：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, make sure that there are still characters left to process:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保还有字符需要处理：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is at least one character to process.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 至少有一个字符需要处理。
- en: 'We first check whether the character is lowercase or uppercase. In this case,
    the token is either an identifier or the `with` keyword, because the regular expression
    for the identifier also matches the keyword. The most common solution here is
    to collect the characters matched by the regular expression and check whether
    the string happens to be the keyword:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查字符是否为小写或大写。在这种情况下，标记要么是一个标识符，要么是 `with` 关键字，因为标识符的正则表达式也会匹配到关键字。这里最常见的解决方案是收集正则表达式匹配到的字符并检查该字符串是否恰好是关键字：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `formToken()` private method is used to populate the token.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`formToken()` 私有方法用于填充标记。'
- en: 'Next, we check for a number. The code for this is very similar to the preceding
    snippet:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查一个数字。这段代码与前面的代码非常相似：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now only the tokens defined by fixed strings are left.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在只剩下由固定字符串定义的标记。
- en: 'This is done easily with a `switch`. As all of these tokens have only one character,
    the `CASE` preprocessor macro is used to reduce typing:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过 `switch` 实现得很容易。由于所有这些标记只有一个字符，因此使用了 `CASE` 预处理器宏来减少输入：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Last, we need to check for unexpected characters:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要检查意外的字符：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Only the `formToken()` private helper method is still missing.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只缺少 `formToken()` 私有辅助方法。
- en: 'It populates the members of the `Token` instance and updates the pointer to
    the next unprocessed character:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它填充了 `Token` 实例的成员并更新了指向下一个未处理字符的指针：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we have a look at how to construct a parser for syntactical
    analysis.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何构建用于句法分析的解析器。
- en: Syntactical analysis
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 句法分析
- en: The syntactical analysis is done by the parser, which we will implement next.
    The base of this is the grammar and the lexer from the previous sections. The
    result of the parsing process is a dynamic data structure called an **abstract
    syntax tree** (**AST**). The AST is a very condensed representation of the input
    and is well-suited for semantic analysis.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 语法分析由解析器执行，我们将实现它。这是基于前几节中的语法和词法分析器。解析过程的结果是一个称为抽象语法树（**AST**）的动态数据结构。AST 是输入的一个非常紧凑的表示，非常适合语义分析。
- en: First, we will implement the parser, and after that, we will have a look at
    the parsing process within the AST.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现解析器，然后我们将查看在 AST 中的解析过程。
- en: A hand-written parser
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手写解析器
- en: 'The interface of the parser is defined in the header file, `Parser.h`. It begins
    with some `include` declarations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的接口定义在头文件 `Parser.h` 中。它以一些 `include` 声明开始：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `AST.h` header file declares the interface for the AST and is shown later.
    The coding guidelines from LLVM forbid the use of the `<iostream>` library, therefore,
    the header of the equivalent LLVM functionality is included. It is needed to emit
    an error message:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`AST.h` 头文件声明了 AST 的接口，稍后展示。LLVM 的编码指南禁止使用 `<iostream>` 库，因此包含等效 LLVM 功能的头文件。这是发出错误消息所需的：'
- en: 'The `Parser` class first declares some private members:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parser` 类首先声明了一些私有成员：'
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Lex` and `Tok` are instances of the classes from the previous section. `Tok`
    stores the next token (the look-ahead) and `Lex` is used to retrieve the next
    token from the input. The `HasError` flag indicates whether an error was detected.'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Lex` 和 `Tok` 是前几节中类的实例。`Tok` 存储下一个标记（前瞻），`Lex` 用于从输入中检索下一个标记。`HasError` 标志指示是否检测到错误。'
- en: 'A couple of methods deal with the token:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几个方法处理标记：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`advance()` retrieves the next token from the lexer. `expect()` tests whether
    the look-ahead has the expected kind and emits an error message if not. Finally,
    `consume()` retrieves the next token if the look-ahead has the expected kind.
    If an error message is emitted, the `HasError` flag is set to true.'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`advance()` 从词法分析器中检索下一个标记。`expect()` 测试前瞻是否有预期的类型，如果没有，则发出错误消息。最后，`consume()`
    如果前瞻有预期的类型，则检索下一个标记。如果发出错误消息，则将 `HasError` 标志设置为 true。'
- en: 'For each non-terminal of the grammar, a method to parse the rule is declared:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于语法中的每个非终结符，声明了一个解析规则的方法：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: There are no methods for `ident` and `number`. Those rules only return the token
    and are replaced by the corresponding token.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ident` 和 `number` 没有方法。这些规则只返回标记，并被相应的标记替换。
- en: 'The public interface follows. The constructor initializes all members and retrieves
    the first token from the lexer:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共接口如下。构造函数初始化所有成员并从词法分析器中检索第一个标记：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A function is required to get the value of the error flag:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个函数来获取错误标志的值：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And finally, the `parse()` method is the main entry point into parsing:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`parse()` 方法是解析的主要入口点：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Parser implementation
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析器实现
- en: Let’s dive into the implementation of the parser!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解解析器的实现！
- en: 'Our implementation in the `Parser.cpp` file and begins with the `parse()` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `Parser.cpp` 文件中的实现以 `parse()` 方法开始：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The main point of the `parse()` method is that the whole input has been consumed.
    Do you remember that the parsing example in the first section added a special
    symbol to denote the end of the input? We check it here.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`parse()` 方法的要点是整个输入已经被消耗。你还记得第一部分的解析示例添加了一个特殊符号来表示输入的结束吗？我们在这里检查它。'
- en: 'The `parseCalc()` method implements the corresponding rule. It’s worth having
    a closer look at this method as the other parsing methods follow the same patterns.
    Let’s recall the rule from the first section:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parseCalc()` 方法实现了相应的规则。值得仔细看看这个方法，因为其他解析方法遵循相同的模式。让我们回忆一下第一部分的规则：'
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The method begins with declaring some local variables:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法以声明一些局部变量开始：
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first decision to be made is whether the optional group must be parsed
    or not. The group begins with the `with` token, so we compare the token to this
    value:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的决定是是否必须解析可选组。组以 `with` 标记开始，所以我们比较标记与此值：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we expect an identifier:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们期望一个标识符：
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If there is an identifier, then we save it in the `Vars` vector. Otherwise,
    it is a syntax error, which is handled separately.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果有一个标识符，则将其保存到 `Vars` 向量中。否则，它是语法错误，将单独处理。
- en: 'Next in the grammar follows a repeating group, which parses more identifiers,
    separated with commas:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在语法中接下来是一个重复组，它解析更多的标识符，用逗号分隔：
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By now, this should not be surprising. The repetition group begins with the
    token (`,`). The test for the token becomes the condition of the `while` loop,
    implementing zero or more repetition. The identifier inside the loop is treated
    as before.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到现在为止，这应该不会令人惊讶。重复组以标记（`,`）开始。对标记的测试成为`while`循环的条件，实现零次或多次重复。循环内的标识符处理方式与之前相同。
- en: 'Finally, the optional group requires a colon at the end:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可选组需要在末尾有一个冒号：
- en: '[PRE28]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Last, the rule for `expr` must be parsed:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，必须解析`expr`的规则：
- en: '[PRE29]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this call, the parsing of the rule is finished successfully. The collected
    information is now used to create the AST node for this rule:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这个调用，规则的解析成功完成。现在收集到的信息被用来创建这个规则的AST节点：
- en: '[PRE30]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now only the error handling is missing. Detecting a syntax error is easy but
    recovering from it is surprisingly complicated. Here, a simple approach called
    **panic mode** is used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只缺少错误处理。检测语法错误很容易，但从中恢复却出人意料地复杂。在这里，使用了一种称为**恐慌模式**的简单方法。
- en: In panic mode, tokens are deleted from the token stream until one is found that
    the parser can use to continue its work. Most programming languages have symbols
    that denote an end, e.g., in C++, a `;` (end of a statement) or a `}` (end of
    a block). Such tokens are good candidates to look for.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在恐慌模式下，从标记流中删除标记，直到找到一个解析器可以用来继续其工作的标记。大多数编程语言都有表示结束的符号，例如，在C++中，有`;`（语句结束）或`}`（块结束）。这样的标记是寻找的好候选。
- en: On the other hand, the error can be that the symbol we are looking for is missing.
    In this case, probably a lot of tokens are deleted before the parser can continue.
    This is not as bad as it sounds. Today, it is more important that a compiler is
    fast. In the event of an error, the developer looks at the first error message,
    fixes it, and restarts the compiler. This is quite different from using punch
    cards, where it was important to get as many error messages as possible, as the
    next run of the compiler would possibly be only on the next day.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，错误可能是因为我们正在寻找的符号缺失。在这种情况下，解析器在继续之前可能已经删除了大量的标记。这并不像听起来那么糟糕。如今，编译器速度快更重要。一旦发生错误，开发者会查看第一条错误信息，修复它，然后重新启动编译器。这与使用穿孔卡片的情况截然不同，当时尽可能多地获取错误信息很重要，因为下一次编译器的运行可能只有第二天。
- en: Error handling
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Instead of using some arbitrary tokens to look for, another set of tokens is
    used here. For each non-terminal, there is a set of tokens that can follow this
    non-terminal in a rule:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用一些任意的标记来查找，这里使用另一组标记。对于每个非终结符，都有一个可以跟随该非终结符的标记集合：
- en: 'In the case of `calc`, only the end of input follows this non-terminal. The
    implementation is trivial:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`calc`的情况下，只有输入的结束符跟随这个非终结符。实现很简单：
- en: '[PRE31]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The other parsing methods are similarly constructed. `parseExpr()` is the translation
    of the rule for `expr`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他解析方法的结构类似。`parseExpr()`是`expr`规则的翻译：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The repeated group inside the rule is translated as a `while` loop. Note how
    the use of the `isOneOf()` method simplifies the check for several tokens.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则内的重复组被翻译为一个`while`循环。注意`isOneOf()`方法的使用如何简化了对多个标记的检查。
- en: 'The coding of the `term` rule looks the same:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`term`规则的编码看起来相同：'
- en: '[PRE33]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method is strikingly similar to `parseExpr()`, and you may be tempted to
    combine them into one. In a grammar, it is possible to have one rule dealing with
    multiplicative and additive operators. The advantage of using two rules instead
    is that then the precedence of the operators fits well with the mathematical order
    of evaluation. If you combine both rules, then you need to figure out the evaluation
    order somewhere else.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法与`parseExpr()`非常相似，你可能想将它们合并为一个。在语法中，可以有一个规则处理乘法和加法运算符。使用两个规则的优势在于，这样运算符的优先级与数学评估顺序很好地匹配。如果你将两个规则合并，那么你需要在其他地方确定评估顺序。
- en: 'Last, you need to implement the rule for `factor`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要实现`factor`的规则：
- en: '[PRE34]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of using a chain of `if` and `else if` statements, a `switch` statement
    seems more suitable here, because each alternative begins with just one token.
    In general, you should think about which translation patterns you like to use.
    If you later need to change the parsing methods, then it is an advantage if not
    every method has a different way of implementing a grammar rule.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与使用一系列`if`和`else if`语句相比，这里使用`switch`语句似乎更合适，因为每个备选方案都只从单个标记开始。一般来说，你应该考虑你喜欢的翻译模式。如果你以后需要更改解析方法，那么如果每个方法没有不同的语法规则实现方式，这将是一个优点。
- en: 'If you use a `switch` statement, then error handling happens in the `default`
    case:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用`switch`语句，那么错误处理发生在`default`情况下：
- en: '[PRE35]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We guard emitting the error message here because of the fall-through.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里保护发出错误信息，因为存在跌落。
- en: 'If there was a syntax error in the parenthesis’s expression, then an error
    message was already emitted. The guard prevents a second error message:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果括号表达式中有语法错误，那么已经发出了错误信息。保护防止第二个错误信息：
- en: '[PRE36]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That was easy, wasn’t it? Once you have memorized the patterns used, it is almost
    tedious work to code the parser based on the grammar rules. This type of parser
    is called a **recursive** **descent parser**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？一旦你记住了使用的模式，根据语法规则编写解析器几乎是一项枯燥的工作。这种解析器被称为**递归下降解析器**。
- en: A recursive descent parser can’t be constructed from every grammar
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有语法都可以构建递归下降解析器
- en: 'A grammar must satisfy certain conditions to be suitable for the construction
    of a recursive descent parser. This class of grammar is called LL(1). In fact,
    most grammar that you can find on the internet does not belong to this class of
    grammar. Most books about the theory of compiler constructions explain the reason
    for this. The classic book on this topic is the so-called *dragon book*, *Compilers:
    Principles, Techniques, and Tools* by Aho, Lam, Sethi, and Ullman.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 语法必须满足某些条件才能适合构建递归下降解析器。这类语法被称为LL(1)。实际上，你可以在互联网上找到的大多数语法都不属于这类语法。大多数关于编译器构造理论的书籍都解释了这一点。关于这个主题的经典书籍是所谓的*龙书*，Aho、Lam、Sethi和Ullman合著的《编译器：原理、技术和工具》。
- en: The abstract syntax tree
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象语法树
- en: The result of the parsing process is the AST. The AST is another compact representation
    of the input program. It captures the essential information. Many programming
    languages have symbols that are needed as separators but do not carry further
    meaning. For example, in C++, a semicolon`;` denotes the end of a single statement.
    Of course, this information is important for the parser. As soon as we turn the
    statement into an in-memory representation, the semicolon is not important anymore
    and can be dropped.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解析过程的结果是AST。AST是输入程序的另一种紧凑表示。它捕获了关键信息。许多编程语言都有作为分隔符但不含进一步意义的符号。例如，在C++中，分号`;`表示单个语句的结束。当然，这个信息对于解析器来说很重要。一旦我们将语句转换为内存表示，分号就不再重要了，可以省略。
- en: 'If you look at the first rule of the example expression language, then it is
    clear that the `with` keyword, the comma (`,`), and the colon (`:`) are not important
    for the meaning of a program. What is important is the list of declared variables,
    which could be used in the expression. The result is that only a couple of classes
    are required to record the information: `Factor` holds a number or an identifier,
    `BinaryOp` holds the arithmetic operator and the left and right sides of an expression,
    and `WithDecl` stores the list of declared variables and the expression. `AST`
    and `Expr` are only used to create a common class hierarchy.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看示例表达式语言的第一条规则，那么很明显，`with`关键字、逗号（`,`）和冒号（`:`）对于程序的意义并不重要。重要的是声明的变量列表，这些变量可以用在表达式中。结果是，只需要几个类来记录信息：`Factor`保存数字或标识符，`BinaryOp`保存算术运算符和表达式的左右两侧，`WithDecl`存储声明的变量列表和表达式。`AST`和`Expr`仅用于创建一个公共类层次结构。
- en: 'In addition to the information from the parsed input, tree traversal using
    the `AST.h` header file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解析输入的信息外，使用`AST.h`头文件进行树遍历：
- en: 'It begins with the visitor interface:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从访问者接口开始：
- en: '[PRE37]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The visitor pattern needs to know each class to visit. Because each class also
    refers to the visitor, we declare all classes at the top of the file. Please note
    that the `visit()` methods for `AST` and `Expr` have a default implementation,
    which does nothing.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问者模式需要知道要访问的每个类。因为每个类也引用了访问者，所以我们将在文件顶部声明所有类。请注意，`AST`和`Expr`的`visit()`方法有一个默认实现，它什么都不做。
- en: 'The `AST` class is the root of the hierarchy:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AST`类是层次结构的根：'
- en: '[PRE38]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similarly, `Expr` is the root for `AST` classes related to expressions:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，`Expr`是`AST`相关表达式类的根：
- en: '[PRE39]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Factor` class stores a number or the name of a variable:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Factor`类存储一个数字或变量的名称：'
- en: '[PRE40]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, numbers and variables are treated almost identically, therefore,
    we decided to create only one AST node class to represent them. The `Kind` member
    tells us which of both cases the instances represent. In more complex languages,
    you usually want to have different AST classes, such as a `NumberLiteral` class
    for numbers and a `VariableAccess` class for a reference to a variable.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，数字和变量被几乎同等对待，因此我们决定只创建一个AST节点类来表示它们。`Kind`成员告诉我们实例代表的是哪一个情况。在更复杂的语言中，你通常希望有不同的AST类，例如为数字创建一个`NumberLiteral`类，为变量引用创建一个`VariableAccess`类。
- en: 'The `BinaryOp` class holds the data needed for evaluating an expression:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BinaryOp`类包含评估表达式所需的数据：'
- en: '[PRE41]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In contrast to the parser, the `BinaryOp` class makes no distinction between
    multiplicative and additive operators. The precedence of the operators is implicitly
    available in the tree structure.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与解析器不同，`BinaryOp`类在乘法和加法运算符之间没有区别。运算符的优先级在树结构中隐式可用。
- en: 'And last, the `WithDecl` class stores the declared variables and the expression:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`WithDecl`类存储声明的变量和表达式：
- en: '[PRE42]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The AST is constructed during parsing. The semantic analysis checks that the
    tree adheres to the meaning of the language (e.g., that used variables are declared)
    and possibly augments the tree. After that, the tree is used for code generation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: AST在解析过程中构建。语义分析检查树是否遵循语言的意义（例如，使用的变量必须声明），并且可能增强树。之后，树被用于代码生成。
- en: Semantic analysis
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义分析
- en: The semantic analyzer walks the AST and checks various semantic rules of the
    language, e.g. a variable must be declared before use or types of variables must
    be compatible in an expression. The semantic analyzer can also print out warnings
    if it finds a situation that can be improved. For the example expression language,
    the semantic analyzer must check that each used variable is declared because that
    is what the language requires. A possible extension (which is not implemented
    here) is to print a warning if a declared variable is not used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 语义分析器遍历AST并检查语言的各个语义规则，例如，变量在使用前必须声明，或者变量在表达式中的类型必须兼容。如果语义分析器发现可以改进的情况，它还可以打印出警告。对于示例表达式语言，语义分析器必须检查每个使用的变量是否已声明，因为这正是语言的要求。一个可能的扩展（在这里没有实现）是在声明了但未使用的变量上打印警告。
- en: 'The semantic analyzer is implemented in the `Sema` class, which is performed
    by the `semantic()` method. Here is the complete `Sema.h` header file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 语义分析器在`Sema`类中实现，由`semantic()`方法执行。以下是完整的`Sema.h`头文件：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The implementation is in the `Sema.cpp` file. The interesting part is the semantic
    analysis, which is implemented using a visitor. The basic idea is that the name
    of each declared variable is stored in a set. During the creation of the set,
    each name can be checked for uniqueness, and later it can be checked that the
    given name is in the set:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现在`Sema.cpp`文件中。有趣的部分是语义分析，它使用访问者实现。基本思想是每个声明的变量名都存储在一个集合中。在创建集合的过程中，可以检查每个名称的唯一性，稍后可以检查给定的名称是否在集合中：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As in the `Parser` class, a flag is used to indicate that an error occurred.
    The names are stored in a set called `Scope`. On a `Factor` node that holds a
    variable name, it is checked that the variable name is in the set:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Parser`类中，一个标志被用来指示发生了错误。名称存储在一个名为`Scope`的集合中。在一个持有变量名的`Factor`节点上，会检查变量名是否在集合中：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For a `BinaryOp` node, there is nothing to check other than that both sides
    exist and are visited:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BinaryOp`节点，除了检查两边是否存在并且被访问之外，没有其他要检查的内容：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On a `WithDecl` node, the set is populated and the walk over the expression
    is started:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WithDecl`节点上，集合被填充，并开始遍历表达式：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `semantic()` method only starts the tree walk and returns the error flag:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`semantic()`方法仅启动树遍历并返回错误标志：'
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If required, much more could be done here. It would also be possible to print
    a warning if a declared variable is not used. We leave this for you to implement
    as an exercise. If the semantic analysis finishes without error, then we can generate
    the LLVM IR from the AST. This is done in the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，这里可以做得更多。还可以在声明了但未使用的变量上打印警告。我们将其留给你作为练习来实现。如果语义分析没有错误完成，那么我们可以从 AST 生成
    LLVM IR。这将在下一节中完成。
- en: Generating code with the LLVM backend
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLVM 后端生成代码
- en: The task of the backend is to create optimized machine code from the LLVM IR
    of a module. The IR is the interface to the backend and can be created using a
    C++ interface or in textual form. Again, the IR is generated from the AST.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 后端的任务是从模块的 LLVM IR 生成优化的机器代码。IR 是后端接口，可以使用 C++ 接口或文本形式创建。同样，IR 是从 AST 生成的。
- en: Textual representation of LLVM IR
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM IR 的文本表示
- en: 'Before trying to generate the LLVM IR, it should be clear what we want to generate.
    For our example expression language, the high-level plan is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试生成 LLVM IR 之前，应该清楚我们想要生成什么。对于我们的示例表达式语言，高级计划如下：
- en: Ask the user for the value of each variable.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户每个变量的值。
- en: Calculate the value of the expression.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算表达式的值。
- en: Print the result.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'To ask the user to provide a value for a variable and to print the result,
    two library functions are used: `calc_read()` and `calc_write()`. For the `with
    a: 3*a` expression, the generated IR is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '要让用户提供变量的值并打印结果，使用了两个库函数：`calc_read()` 和 `calc_write()`。对于 `with a: 3*a` 表达式，生成的
    IR 如下：'
- en: 'The library functions must be declared, like in C. The syntax also resembles
    C. The type before the function name is the return type. The type names surrounded
    by parenthesis are the argument types. The declaration can appear anywhere in
    the file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库函数必须像在 C 中一样声明。语法也类似于 C。函数名前的类型是返回类型。括号内的类型名是参数类型。声明可以出现在文件的任何位置：
- en: '[PRE49]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `calc_read()` function takes the variable name as a parameter. The following
    construct defines a constant, holding `a` and the null byte used as a string terminator
    in C:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`calc_read()` 函数接受变量名作为参数。以下构造定义了一个常量，包含 `a` 和用作 C 中字符串终止符的空字节：'
- en: '[PRE50]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It follows the `main()` function. The parameter names are omitted because they
    are not used. Just as in C, the body of the function is enclosed in braces:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它跟随 `main()` 函数。省略了参数名称，因为它们没有被使用。就像在 C 中一样，函数体被括号包围：
- en: '[PRE51]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Each basic block must have a label. Because this is the first basic block of
    the function, we name it `entry`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个基本块都必须有一个标签。因为这个是函数的第一个基本块，我们将其命名为 `entry`：
- en: '[PRE52]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `calc_read()` function is called to read the value for the `a` variable.
    The nested `getelemenptr` instruction performs an index calculation to compute
    the pointer to the first element of the string constant. The function result is
    assigned to the unnamed `%``2` variable.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `calc_read()` 函数读取 `a` 变量的值。嵌套的 `getelemenptr` 指令执行索引计算以计算字符串常量第一个元素的指针。函数结果被赋值给未命名的
    `%2` 变量。
- en: '[PRE53]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, the variable is multiplied by `3`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，变量被乘以 `3`：
- en: '[PRE54]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is printed on the console via a call to the `calc_write()` function:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `calc_write()` 函数将结果打印到控制台：
- en: '[PRE55]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Last, the `main()` function returns `0` to indicate a successful execution:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`main()` 函数返回 `0` 以指示执行成功：
- en: '[PRE56]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Each value in the LLVM IR is typed, with `i32` denoting the 32-bit bit integer
    type and `ptr` denoting a pointer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR 中的每个值都有类型，其中 `i32` 表示 32 位整数类型，`ptr` 表示指针。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Previous versions of LLVM used typed pointers. For example, a pointer to a byte
    was expressed as i8* in LLVM. Since LLVM 16, `ptr`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 的早期版本使用有类型的指针。例如，在 LLVM 中，字节的指针表示为 i8*。自 LLVM 16 以来，使用 `ptr`。
- en: Since it is now clear what the IR looks like, let’s generate it from the AST.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在已经很清楚 IR 的样子，让我们从 AST 生成它。
- en: Generating the IR from the AST
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 AST 生成 IR
- en: 'The interface, provided in the `CodeGen.h` header file, is very small:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CodeGen.h` 头文件中提供的接口非常小：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Because the AST contains the information, the basic idea is to use a visitor
    to walk the AST. The `CodeGen.cpp` file is implemented as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AST 包含信息，基本思想是使用访问者遍历 AST。`CodeGen.cpp` 文件实现如下：
- en: 'The required includes are at the top of the file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的包含在文件顶部：
- en: '[PRE58]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The namespace of the LLVM libraries is used for name lookups:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 LLVM 库的命名空间进行名称查找：
- en: '[PRE59]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First, some private members are declared in the visitor. Each compilation unit
    is represented in LLVM by the `Module` class and the visitor has a pointer to
    the module called `M`. For easy IR generation, the `Builder` (of type `IRBuilder<>)`
    is used. LLVM has a class hierarchy to represent types in IR. You can look up
    the instances for basic types such as `i32` from the LLVM context.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在访问者中声明一些私有成员。每个编译单元在LLVM中由`Module`类表示，访问者有一个指向模块的指针，称为`M`。为了方便IR生成，使用`Builder`（类型为`IRBuilder<>)`。LLVM有一个类层次结构来表示IR中的类型。您可以从LLVM上下文中查找基本类型，如`i32`的实例。
- en: 'These basic types are used very often. To avoid repeated lookups, we cache
    the needed type instances: `VoidTy`, `Int32Ty`, `PtrTy`, and `Int32Zero`. The
    `V` member is the current calculated value, which is updated through the tree
    traversal. And last, `nameMap` maps a variable name to the value returned from
    the `calc_read()` function:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些基本类型使用非常频繁。为了避免重复查找，我们缓存所需类型实例：`VoidTy`、`Int32Ty`、`PtrTy`和`Int32Zero`。`V`成员是当前计算值，它通过树遍历更新。最后，`nameMap`将变量名映射到`calc_read()`函数返回的值：
- en: '[PRE60]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The constructor initializes all members:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化所有成员：
- en: '[PRE61]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For each function, a `FunctionType` instance must be created. In C++ terminology,
    this is a function prototype. A function itself is defined with a `Function` instance.
    The `run()` method defines the `main()` function in the LLVM IR first:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个函数，必须创建一个`FunctionType`实例。在C++术语中，这被称为函数原型。函数本身是通过`Function`实例定义的。`run()`方法首先在LLVM
    IR中定义`main()`函数：
- en: '[PRE62]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then we create the `BB` basic block with the `entry` label, and attach it to
    the IR builder:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建带有`entry`标签的`BB`基本块，并将其附加到IR构建器：
- en: '[PRE63]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this preparation done, the tree traversal can begin:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备工作完成后，可以开始树遍历：
- en: '[PRE64]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After the tree traversal, the computed value is printed via a call to the `calc_write()`
    function. Again, a function prototype (an instance of `FunctionType`) has to be
    created. The only parameter is the current value, `V`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树遍历完成后，通过调用`calc_write()`函数打印计算值。同样，必须创建一个函数原型（`FunctionType`的实例）。唯一的参数是当前值`V`：
- en: '[PRE65]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The generation finishes by returning `0` from the `main()` function:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成过程通过从`main()`函数返回`0`结束：
- en: '[PRE66]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A `WithDecl` node holds the names of the declared variables. First, we create
    a function prototype for the `calc_read()` function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WithDecl`节点包含声明的变量名。首先，我们为`calc_read()`函数创建一个函数原型：'
- en: '[PRE67]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The method loops through the variable names:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法遍历变量名：
- en: '[PRE68]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For each variable, a string with a variable name is created:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个变量，创建一个包含变量名的字符串：
- en: '[PRE69]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then the IR code to call the `calc_read()` function is created. The string
    created in the previous step is passed as a parameter:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建调用`calc_read()`函数的IR代码。上一步创建的字符串作为参数传递：
- en: '[PRE70]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The returned value is stored in the `mapNames` map for later use:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回值存储在`mapNames`映射中，以供以后使用：
- en: '[PRE71]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The tree traversal continues with the expression:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树遍历继续进行到表达式：
- en: '[PRE72]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A `Factor` node is either a variable name or a number. For a variable name,
    the value is looked up in the `mapNames` map. For a number, the value is converted
    to an integer and turned into a constant value:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Factor`节点可以是变量名或数字。对于变量名，值在`mapNames`映射中查找。对于数字，值转换为整数并转换为常量值：'
- en: '[PRE73]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And last, for a `BinaryOp` node, the right calculation operation must be used:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于`BinaryOp`节点，必须使用正确的计算操作：
- en: '[PRE74]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With this, the visitor class is complete. The `compile()` method creates the
    global context and the module, runs the tree traversal, and dumps the generated
    IR to the console:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，访问者类就完成了。`compile()`方法创建全局上下文和模块，运行树遍历，并将生成的IR输出到控制台：
- en: '[PRE75]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We now have implemented the frontend of the compiler, from reading the source
    up to generating the IR. Of course, all these components must work together on
    user input, which is the task of the compiler driver. We also need to implement
    the functions needed at runtime. Both are topics of the next section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了编译器的前端，从读取源代码到生成IR。当然，所有这些组件必须协同工作以处理用户输入，这是编译器驱动程序的任务。我们还需要实现运行时所需的函数。这两者都是下一节的主题。
- en: The missing pieces – the driver and the runtime library
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺少的部分——驱动程序和运行时库
- en: 'All the phases from the previous sections are glued together by the `Calc.cpp`
    driver, which we implement as follows: a parameter for the input expression is
    declared, LLVM is initialized, and all the phases from the previous sections are
    called:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节的所有阶段都通过 `Calc.cpp` 驱动程序粘合在一起，我们按照以下方式实现：声明一个输入表达式的参数，初始化 LLVM，并调用前几节的所有阶段：
- en: 'First, we include the required header files:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含所需的头文件：
- en: '[PRE76]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'LLVM comes with its own system for declaring command-line options. You only
    need to declare a static variable for each option you need. In doing so, the option
    is registered with a global command line parser. The advantage of this approach
    is that each component can add command-line options when needed. We declare an
    option for the input expression:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM 自带一套用于声明命令行选项的系统。你只需要为每个需要的选项声明一个静态变量。这样做时，选项会通过全局命令行解析器进行注册。这种方法的优点是每个组件可以在需要时添加命令行选项。我们声明了一个用于输入表达式的选项：
- en: '[PRE77]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Inside the `main()` function, the LLVM libraries are initialized first. You
    need to call the `ParseCommandLineOptions()` function to handle the options given
    on the command line. This also handles the printing of help information. In the
    event of an error, this method exits the application:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数内部，首先初始化 LLVM 库。你需要调用 `ParseCommandLineOptions()` 函数来处理命令行上的选项。这也处理了打印帮助信息。如果发生错误，此方法将退出应用程序：
- en: '[PRE78]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we call the lexer and the parser. After the syntactical analysis, we
    check whether any errors occurred. If this is the case, then we exit the compiler
    with a return code indicating a failure:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用词法分析和语法分析器。在语法分析之后，我们检查是否发生了任何错误。如果是这种情况，则通过返回代码指示失败退出编译器：
- en: '[PRE79]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And we do the same if there was a semantic error:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在语义错误，我们也会这样做：
- en: '[PRE80]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As the last step in the driver, the code generator is called:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在驱动程序的最后一个步骤中，调用代码生成器：
- en: '[PRE81]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now we have successfully created some IR code for the user input. We delegate
    the object code generation to the LLVM `llc` static compiler, so this finishes
    the implementation of our compiler. We link all the components together to create
    the `calc` application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功为用户输入创建了一些 IR 代码。我们将目标代码生成委托给 LLVM 的 `llc` 静态编译器，这样我们就完成了编译器的实现。我们将所有组件链接在一起以创建
    `calc` 应用程序。
- en: 'The runtime library consists of a single file, `rtcalc.c`. It has the implementation
    for the `calc_read()` and `calc_write()` functions, written in C:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库由一个文件 `rtcalc.c` 组成。它包含了 `calc_read()` 和 `calc_write()` 函数的实现，这些函数是用 C 编写的：
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`calc_write()` only writes the result value to the terminal:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_write()` 只将结果值写入终端：'
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`calc_read()` reads an integer number from the terminal. Nothing prevents the
    user from entering letters or other characters, so we must carefully check the
    input. If the input is not a number, we exit the application. A more complex approach
    would be to make the user aware of the problem and ask for a number again.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_read()` 从终端读取一个整数。没有任何东西阻止用户输入字母或其他字符，因此我们必须仔细检查输入。如果输入不是数字，我们退出应用程序。更复杂的方法是让用户意识到问题，并再次请求输入一个数字。'
- en: The next step is to build and try out our compiler, `calc`, which is an application
    that creates IR from an expression.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建并尝试我们的编译器 `calc`，这是一个从表达式创建 IR 的应用程序。
- en: Building and testing the calc application
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建并测试 calc 应用程序
- en: 'In order to build `calc`, we first need to create a new `CMakeLists.txt` file
    outside of the original `src` directory that contains all of the source file implementation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 `calc`，我们首先需要在原始 `src` 目录之外创建一个新的 `CMakeLists.txt` 文件，该文件包含所有源文件实现：
- en: 'First, we set the minimum required CMake version to the number required by
    LLVM, and give the project the name `calc`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将所需的最低 CMake 版本设置为 LLVM 所需的版本，并将项目命名为 `calc`：
- en: '[PRE84]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, the LLVM package needs to be loaded, and we add the directory of the
    CMake modules provided by LLVM to the search path:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要加载 LLVM 包，并将 LLVM 提供的 CMake 模块目录添加到搜索路径：
- en: '[PRE85]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We also need to add the definitions and the include path from LLVM. The used
    LLVM components are mapped to the library names with a function call:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加来自 LLVM 的定义和包含路径。使用的 LLVM 组件通过函数调用映射到库名称：
- en: '[PRE86]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Lastly, we indicate that we need to include the `src` subdirectory in our build,
    as this is where all of the C++ implementation that was done within this chapter
    resides:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们指出需要将 `src` 子目录包含在我们的构建中，因为这个目录包含了本章内完成的全部 C++ 实现：
- en: '[PRE87]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'There also needs to be a new `CMakeLists.txt` file inside of the `src` subdirectory.
    This CMake description inside the `src` directory appears as follows. We simply
    define the name of the executable, called `calc`, then list the source files to
    compile and the library to link against:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 子目录内还需要有一个新的 `CMakeLists.txt` 文件。这个位于 `src` 目录中的 CMake 描述如下。我们简单地定义了可执行文件的名字，称为
    `calc`，然后列出要编译的源文件和要链接的库：
- en: '[PRE88]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we can begin building the `calc` application. Outside of the `src`
    directory, we create a new build directory and change into it. Afterwards, we
    can run the CMake and build invocation as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始构建 `calc` 应用程序。在 `src` 目录之外，我们创建一个新的构建目录并切换到该目录。之后，我们可以按照以下方式运行 CMake
    和构建调用：
- en: '[PRE89]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We now should have a newly built, functional `calc` application that can generate
    LLVM IR code. This can further be used with `llc`, which is the LLVM static backend
    compiler, to compile the IR code into an object file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有一个新构建的、功能齐全的 `calc` 应用程序，它可以生成 LLVM IR 代码。这可以进一步与 `llc` 一起使用，`llc` 是
    LLVM 静态后端编译器，用于将 IR 代码编译成目标文件。
- en: 'You can then use your favorite C compiler to link against the small runtime
    library. On Unix on X86, you can type the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用你喜欢的 C 编译器来链接到小的运行时库。在 Unix 的 X86 上，你可以输入以下内容：
- en: '[PRE90]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: On other Unix platforms such as AArch64 or PowerPC, you have to remove the `-``relocation-model=pic`
    option.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他 Unix 平台，如 AArch64 或 PowerPC 上，你必须移除 `-relocation-model=pic` 选项。
- en: 'On Windows, you need to use the `cl` compiler as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你需要使用 `cl` 编译器，如下所示：
- en: '[PRE91]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You have now created your first LLVM-based compiler! Please take some time to
    play around with various expressions. Especially check that multiplicative operators
    are evaluated before additive operators and that using parentheses changes the
    evaluation order, as we would expect from a basic calculator.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经创建出了你的第一个基于 LLVM 的编译器！请花些时间尝试各种表达式。特别是要检查乘法运算符是否在加法运算符之前被评估，以及使用括号是否会改变评估顺序，正如我们从一个基本的计算器所期望的那样。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about the typical components of a compiler. An
    arithmetic expression language was used to introduce you to the grammar of programming
    languages. You learned how to develop the typical components of a frontend for
    this language: a lexer, a parser, a semantic analyzer, and a code generator. The
    code generator only produced LLVM IR, and the LLVM `llc` static compiler was used
    to create object files from it. You have now developed your first LLVM-based compiler!'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了编译器的典型组件。使用算术表达式语言介绍了编程语言的语法。你学习了如何开发这种语言前端典型的组件：词法分析器、解析器、语义分析器和代码生成器。代码生成器仅生成
    LLVM IR，并使用 LLVM 的 `llc` 静态编译器从它创建目标文件。你现在已经开发出了你的第一个基于 LLVM 的编译器！
- en: In the next chapter, you will deepen this knowledge, constructing the frontend
    for a programming language.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将深化这些知识，构建编程语言的前端。
