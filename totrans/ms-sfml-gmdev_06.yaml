- en: Chapter 6. Adding Some Finishing Touches - Using Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 添加一些收尾工作 - 使用着色器
- en: Having good art is important for any game, as it greatly compliments the content
    game designers bring to the table. However, simply tacking on any and all graphics
    to some logic and calling it a day just does not cut it anymore. Good visual aesthetics
    of a game are now formed by hand-in-hand cooperation of amazing art and the proper
    post-processing that follows. Dealing with graphics as if they are paper cut-outs
    feels dated, while incorporating them in the dynamic universe of your game world
    and making sure they react to their surroundings by properly shading them has
    become the new standard. For a brief moment, let us put aside gameplay and discuss
    the technique of that special kind of post-processing, known as shading.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何游戏来说，拥有好的艺术作品都是重要的，因为它极大地补充了游戏设计师带来的内容。然而，仅仅将任何图形逻辑和逻辑结合起来，称之为一天的工作，已经不再足够了。现在，游戏的良好视觉美学是由出色的艺术和适当的后期处理共同合作形成的。将图形处理成剪纸的感觉已经过时，而将它们融入游戏世界的动态宇宙中，并确保它们通过适当的着色来对周围环境做出反应，已经成为新的标准。让我们暂时放下游戏玩法，讨论一下这种特殊类型的后期处理技术，即着色。
- en: 'In this chapter, we are going to be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要介绍：
- en: The basics of the SFML shader class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML着色器类的基础
- en: Implementing a unified way of drawing objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现统一绘制对象的方式
- en: Adding a day-night cycle to the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏添加日夜循环
- en: Let us get started with giving our project that extra graphical enhancement!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为我们的项目添加额外的图形增强吧！
- en: Understanding shaders
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解着色器
- en: In the modern world of computer graphics, many different calculations are offloaded
    to the GPU. Anything from simple pixel colour calculations, to complex lighting
    effects can and should be handled by hardware that is specifically designed for
    this purpose. This is where shaders come in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机图形的世界中，许多不同的计算都转移到了GPU上。从简单的像素颜色计算到复杂的照明效果，都可以并且应该由专门为此目的设计的硬件来处理。这就是着色器的作用所在。
- en: A **shader** is a little program that runs on your graphics card instead of
    the CPU, and controls how each pixel of a shape is rendered. The main purpose
    of a shader, as the name suggests, is performing lighting and shading calculations,
    but they can be used for much more than that. Because of the power modern GPUs
    have, libraries exist that are designed to perform calculations on the GPU that
    would usually be executed on the CPU, in order to cut down the computation time
    significantly. Anything from physics computations to cracking password hashes
    can be done on the GPU, and the entry point to that horsepower is a shader.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**是一个在您的显卡上而不是CPU上运行的程序，它控制着形状的每个像素的渲染方式。正如其名所示，着色器的主要目的是执行照明和着色计算，但它们可以用于更多的事情。由于现代GPU的强大功能，存在一些库，它们旨在在GPU上执行通常在CPU上执行的计算，以显著减少计算时间。从物理计算到破解密码散列，任何东西都可以在GPU上完成，而进入这种强大马力的入口就是着色器。'
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: GPUs are good at performing tons of very specific calculations in parallel at
    once. Using less predictable or unparallel algorithms is very inefficient on the
    GPU, which is what the CPU excels at. However, as long as the data can be processed
    exactly the same in parallel, the task is deemed worthy of being pushed to the
    GPU for further handling.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GPU擅长同时并行执行大量非常具体的计算。在GPU上使用不可预测或不并行的算法非常低效，这正是CPU擅长的。然而，只要数据可以并行处理，这项任务就被认为值得推送到GPU进行进一步处理。
- en: 'There are two main types of shader that SFML provides: **vertex** and **fragment**.
    Newer versions of SFML (*2.4.0* and up) have added support for geometry shaders
    as well, but it is not necessary to cover this for our purposes.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SFML提供了两种主要的着色器类型：**顶点**和**片段**。SFML的新版本（*2.4.0*及以上）还增加了对几何着色器的支持，但根据我们的目的，不需要涵盖这一点。
- en: A **vertex shader** is executed once per vertex. This process is commonly referred
    to as **per-vertex** shading. For example, any given triangle has three vertices.
    This means that the shader would be executed once for each vertex for a grand
    total of three times.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点着色器**对每个顶点执行一次。这个过程通常被称为**顶点着色**。例如，任何给定的三角形有三个顶点。这意味着着色器将为每个顶点执行一次，总共执行三次。'
- en: A **fragment shader** is executed once per pixel (otherwise known as a fragment),
    which results in the process being referred to as **per-pixel** shading. This
    is much more taxing than simply performing per-vertex calculations, but is much
    more accurate and generally produces better visual results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**片段着色器**对每个像素（也称为片段）执行一次，这导致这个过程被称为**逐像素着色**。这比简单地执行逐顶点计算要耗费更多资源，但更准确，通常会产生更好的视觉效果。'
- en: Both types of shader can be used at once on a single piece of geometry being
    drawn, and can also communicate with each other.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的着色器可以同时用于单个绘制的几何体上，并且还可以相互通信。
- en: Shader examples
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器示例
- en: 'The **OpenGL Shading Language** (**GLSL**) is extremely similar to *C* or *C++*.
    It even uses the same basic syntax, as seen in this vertex shader example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL着色语言**（**GLSL**）与*C*或*C++*非常相似。它甚至使用相同的基语法，如这个顶点着色器示例所示：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the version on the very first line. The number `450` indicates the version
    of OpenGL that should be used, in this case *4.5*. Newer versions of SFML support
    OpenGL versions *3.3+*; however the success of running it also depends on the
    capabilities of your graphics card.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一行上的版本号。数字`450`表示应使用的OpenGL版本，在本例中为*4.5*。较新版本的SFML支持OpenGL版本*3.3+*；然而，运行它的成功也取决于您显卡的能力。
- en: For now, simply ignore the first line of the `main` function. It has to do with
    positions transformations from one coordinate system to another, and is specific
    to a few possible approaches to shading. These concepts will be covered in the
    next chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需忽略`main`函数的第一行。它与从一个坐标系到另一个坐标系的位移动作有关，并且特定于一些可能的着色方法。这些概念将在下一章中介绍。
- en: GLSL provides quite a few *hooks* that allow direct control of vertex and pixel
    information, such as `gl_Position` and `gl_Color`. The former is simply the position
    of the vertex that will be used in further calculations down the line, while the
    latter is the vertex colour, which is being assigned to `gl_FrontColor`, ensuring
    the colour is passed down the pipeline to the fragment shader.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL提供了许多允许直接控制顶点和像素信息的**钩子**，例如`gl_Position`和`gl_Color`。前者只是将在后续计算中使用的顶点位置，而后者是顶点颜色，它被分配给`gl_FrontColor`，确保颜色被传递到片段着色器中。
- en: 'Speaking of the fragment shader, here is a very minimal example of what it
    may look like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 说到片段着色器，这里有一个非常简单的示例，它可能看起来是这样的：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this particular case, `gl_FragColor` is used to set a static value of the
    pixel being rendered. Any shape being rendered while using this shader will come
    out white.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，`gl_FragColor`用于设置正在渲染的像素的静态值。在使用此着色器渲染的任何形状都将呈现为白色。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The values of this vector are normalized, meaning they have to fall in the range
    of *0.f < n <= 1.0f*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量的值是归一化的，这意味着它们必须落在*0.f < n <= 1.0f*的范围内。
- en: 'Keep in mind that `gl_Color` can be used here to sample the colour that is
    passed down from the vertex shader. However, because there may be multiple pixels
    in between vertices, the colour for each fragment is interpolated. In a case where
    each vertex of a triangle is set to colours red, green, and blue, the interpolated
    result would look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这里可以使用`gl_Color`来采样从顶点着色器传递下来的颜色。然而，由于顶点之间可能存在多个像素，每个片段的颜色都会进行插值。在一个三角形每个顶点被设置为红色、绿色和蓝色的情况下，插值结果将如下所示：
- en: '![Shader examples](img/image_06_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![着色器示例](img/image_06_001.jpg)'
- en: 'One last thing to note about any shader is that they support communication
    from outside sources. This is done by using the `uniform` keyword, followed by
    the variable type and capped off by its name like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于任何着色器需要注意的最后一点是，它们支持来自外部源通信。这是通过使用`uniform`关键字，后跟变量类型，并以其名称结尾来完成的：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this particular example, outside code passes in three `float` that will be
    used as color values for the fragment. Uniforms are simply **global** variables
    that can be manipulated by outside code before a shader is used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的示例中，外部代码传入三个`float`，这些值将被用作片段的颜色值。统一体（Uniforms）仅仅是**全局**变量，可以在使用着色器之前由外部代码进行操作。
- en: SFML and shaders
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML和着色器
- en: 'Storing and using shaders in SFML is made simple by introducing the `sf::Shader`
    class. Although shaders are generally supported by most devices out there, it
    is still a good idea to perform a check that determines if the system the code
    is being executed on supports shaders as well:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入`sf::Shader`类，在SFML中存储和使用着色器变得简单。尽管大多数设备都支持着色器，但仍然是一个好主意，要检查正在执行代码的系统是否也支持着色器：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This shader class can hold either one of the two types of shader just by itself
    or a single instance of each type at the same time. Shaders can be loaded in one
    of two ways. The first is by simply reading a text file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器类可以仅通过自身持有两种类型中的任何一种着色器，或者同时持有每种类型的一个实例。着色器可以通过两种方式之一加载。第一种是简单地读取一个文本文件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: File extensions of these shaders do not have to match the preceding ones. Because
    we are working with text files, the extension simply exists for clarity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些着色器的文件扩展名不必与前面的匹配。因为我们正在处理文本文件，扩展名只是为了清晰。
- en: 'The second way to load a shader is by parsing a string loaded in memory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 加载着色器的第二种方式是通过解析内存中加载的字符串：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using a shader is fairly straightforward as well. Its address simply needs
    to be passed in to a render targets `draw()` call as the second argument when
    something is being rendered to it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用着色器也很简单。其地址只需在渲染到它时作为第二个参数传递给渲染目标的`draw()`调用：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since our shaders may need to be communicated with through `uniform` variables,
    there has to be a way to set them. Enter `sf::Shader::setUniform(...)`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的着色器可能需要通过`uniform`变量进行通信，因此必须有一种方法来设置它们。进入`sf::Shader::setUniform(...)`：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple bit of code manipulates the `r` uniform inside whatever shader(s)
    happen to be loaded inside the `shader` instance. The method itself supports many
    more types besides *float*, which we will be covering in the next chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码操作了`shader`实例中加载的任何着色器中的`r`统一变量。该方法本身支持除了*float*之外许多其他类型，我们将在下一章中介绍。
- en: Localizing rendering
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化渲染
- en: Shading is a powerful concept. The only problem with injecting a stream of extra-graphical-fanciness
    to our game at this point is the fact that it is simply not architected to deal
    with using shaders efficiently. Most, if not all of our classes that do any kind
    of drawing do so by having direct access to the `sf::RenderWindow` class, which
    means they would have to pass in their own shader instances as arguments. This
    is not efficient, re-usable, or flexible at all. A better approach, such as a
    separate class dedicated to rendering, is a necessity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 着色是一个强大的概念。目前向我们的游戏注入额外的图形华丽效果的唯一问题是它根本不是为高效使用着色器而设计的。我们大多数（如果不是所有）进行任何类型绘制的类都是通过直接访问`sf::RenderWindow`类来完成的，这意味着它们必须将它们自己的着色器实例作为参数传递。这既不高效，也不可重用，也不灵活。一个更好的方法，比如一个专门用于渲染的独立类，是必需的。
- en: 'In order to be able to switch from shader to shader with relative ease, we
    must work on storing them properly within the class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够相对容易地在着色器之间切换，我们必须在类中正确地存储它们：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because the `sf::Shader` class is a non-copyable object (inherits from `sf::NonCopyable`),
    it is stored as a unique pointer, resulting in avoidance of any and all move semantics.
    This list of shaders is directly owned by the class that is going to do all of
    the rendering, so let us take a look at its definition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sf::Shader`类是一个不可拷贝的对象（继承自`sf::NonCopyable`），它被存储为唯一指针，从而避免了任何和所有的移动语义。这个着色器列表直接由将要执行所有渲染的类拥有，让我们看看它的定义：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since shaders need to be passed in as arguments to the window `draw()` calls,
    it is obviously imperative for the renderer to have access to the `Window` class.
    In addition to that and the list of shaders that can be used at any given time,
    we also keep a pointer to the current shader being used in order to cut down on
    container access time, as well as a couple of flags that will be used when choosing
    the right shader to use, or determining whether the drawing is currently happening
    in the first place. Lastly, a fairly useful debug feature is having information
    about how many draw calls happen during each update. For this, a simple *unsigned
    integer* is going to be used.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于着色器需要作为参数传递给窗口的`draw()`调用，因此渲染器必须能够访问`Window`类。除了这些以及任何给定时间可以使用的着色器列表之外，我们还保留了对当前正在使用的着色器的指针，以减少容器访问时间，以及一些将在选择合适的着色器或确定是否正在绘制时使用的标志。最后，一个相当有用的调试特性是记录每次更新期间发生的绘制调用次数。为此，将使用一个简单的`unsigned
    integer`。
- en: The class itself provides the basic features of enabling/disabling additive
    blending instead of a regular shader, switching between all available shaders,
    and disabling the current shader, as well as obtaining it. The `BeginDrawing()`
    and `EndDrawing()` methods are going to be used by the `Window` class in order
    to provide us with *hooks* for obtaining information about the rendering process.
    Note the overloaded `Draw()` method. It is designed to take in any drawable type
    and draw it on either the current window, or the appropriate render target that
    can be provided as the second argument.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该类本身提供了启用/禁用加法混合而不是常规着色器的基本功能，在所有可用的着色器之间切换，禁用当前着色器以及获取它。`BeginDrawing()`和`EndDrawing()`方法将由`Window`类使用，以为我们提供有关渲染过程的信息的钩子。注意重载的`Draw()`方法。它被设计为接受任何可绘制类型，并将其绘制在当前窗口或作为第二个参数提供的适当渲染目标上。
- en: Finally, the `LoadShaders()` private method is going to be used during the initialization
    stage of the class. It holds all of the logic necessary to load every single shader
    inside the appropriate directory, and store them for later use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在类的初始化阶段将使用`LoadShaders()`私有方法。它包含加载每个着色器所需的所有逻辑，并将它们存储以供以后使用。
- en: Implementing the renderer
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现渲染器
- en: 'Let us begin by quickly going over the construction of the `Renderer` object,
    and the initialization of all of its data members:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速回顾一下`Renderer`对象的构建以及所有数据成员的初始化：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the pointer to the `Window*` instance is safely stored, all of the data
    members of this class are initialized to their default values. The body of the
    constructor simply consists of a private method call, responsible for actually
    loading and storing all of the shader files:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安全地存储了`Window*`实例的指针，这个类的所有数据成员都将初始化为其默认值。构造函数的主体仅由一个私有方法调用组成，负责实际加载和存储所有着色器文件：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We begin by establishing a local variable that is going to hold the path to
    our `shader` directory. It is then used to obtain two lists of files with `.vert`
    and `.frag` extensions respectively. These will be the vertex and fragment shaders
    to be loaded. The goal here is to group vertex and fragment shaders with identical
    names, and assign them to a single instance of `sf::Shader`. Any shaders that
    do not have a vertex or fragment counterpart will simply be loaded alone in a
    separate instance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个局部变量，用于保存我们的`shader`目录的路径。然后使用它来获取两个具有`.vert`和`.frag`扩展名的文件列表。这些将是将要加载的顶点和片段着色器。这里的目的是将具有相同名称的顶点和片段着色器分组，并将它们分配给`sf::Shader`的单个实例。任何没有顶点或片段对应物的着色器将单独加载到单独的实例中。
- en: Vertex shaders are as good a place as any to begin. After the filename is obtained
    and stripped of its extension, a fragment shader with the same name is attempted
    to be located. At the same time, a new `sf::Shader` instance is inserted into
    the shader container, and a reference to it is obtained. If a fragment counterpart
    has been found, both files are loaded into the shader. The fragment shader name
    is then removed from the list, as it will no longer need to be loaded in on its
    own.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器是一个很好的开始地方。在获取文件名并去除扩展名后，尝试找到具有相同名称的片段着色器。同时，一个新的`sf::Shader`实例被插入到着色器容器中，并获取对其的引用。如果找到了片段对应物，这两个文件都会被加载到着色器中。然后，片段着色器名称将从列表中移除，因为它将不再需要单独加载。
- en: As the first part of the code does all of the pairing, all that is really left
    to do at this point is load the fragment shaders. It is safe to assume that anything
    on the fragment shader list is a standalone fragment shader, not associated with
    a vertex counterpart.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代码的第一部分负责所有的配对，此时真正需要做的只剩下加载片段着色器。可以安全地假设片段着色器列表中的任何内容都是一个独立的片段着色器，而不是与顶点着色器相关联。
- en: 'Since shaders can have uniform variables that need to be initialized, it is
    important that outside classes have access to the shaders they use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于着色器可能有需要初始化的统一变量，因此外部类需要能够访问它们所使用的着色器：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the shader with the provided name has not been located, `nullptr` is returned.
    On the other hand, a raw pointer to the `sf::Shader*` instance is obtained from
    the smart pointer and returned instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到提供的名称的着色器，则返回`nullptr`。另一方面，从智能指针中获取`sf::Shader*`实例的原始指针并返回。
- en: 'The same outside classes need to be able to instruct the `Renderer` when a
    specific shader should be used. For this purpose, the `UseShader()` method comes
    in handy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的外部类需要能够在特定着色器应该被使用时指导`Renderer`。为此，`UseShader()`方法派上了用场：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the `GetShader()` method already does the error-checking for us, it is
    used here as well. The value returned from it is stored as the pointer to the
    current shader, if any, and is then evaluated in order to return a *boolean* value,
    signifying success/failure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GetShader()`方法已经为我们做了错误检查，因此在这里也使用了它。从它返回的值被存储为当前着色器的指针（如果有的话），然后对其进行评估以返回一个*布尔值*，表示成功/失败。
- en: 'The actual drawing of geometry is what we are all about here, so let us take
    a look at the overloaded `Draw()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绘制几何图形是我们这里的主要内容，让我们来看看重载的`Draw()`方法：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Whether a `sf::Sprite` or `sf::Shape` is being rendered, the actual idea behind
    this is exactly the same. First, we check if the intention behind the method call
    was indeed to render to the main window by looking at the `l_target` argument.
    If so, a fair thing to do here is to make sure the drawable object actually is
    on screen. It would be pointless to draw it if it was not. Provided the test passes,
    the main `Draw()` method overload is invoked, with the current arguments being
    passed down:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是渲染`sf::Sprite`还是`sf::Shape`，背后的实际想法是完全相同的。首先，我们检查方法调用背后的意图是否确实是为了渲染到主窗口，通过查看`l_target`参数。如果是这样，这里一个合理的事情是确保可绘制对象实际上是在屏幕上的。如果不在，绘制它就没有意义。如果测试通过，主`Draw()`方法重载将被调用，并将当前参数传递下去：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is where all of the actual magic happens. The `l_target` argument is again
    checked for being equal to `nullptr`. If it is, the render window is stored inside
    the argument pointer. Whatever the target, at this point its `Draw()` method is
    invoked, with the drawable being passed in as the first argument, as well as the
    appropriate shader or blend mode passed in as the second. The additive blending
    obviously takes precedence here, enabling a quicker way of switching between using
    a shader and the additive blending modes by simply needing to use the `AdditiveBlend()`
    method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生所有的实际魔法。再次检查`l_target`参数是否等于`nullptr`。如果是，渲染窗口将被存储在参数指针中。无论目标是什么，此时它的`Draw()`方法将被调用，将可绘制对象作为第一个参数传递，以及适当的着色器或混合模式作为第二个参数传递。显然，加法混合在这里具有优先权，通过简单地使用`AdditiveBlend()`方法，可以更快地在使用着色器和加法混合模式之间切换。
- en: Once the drawing is done, the `m_drawCalls` data member is incremented, so that
    we can keep track of how many drawables have been rendered in total at the end
    of each cycle.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制完成后，`m_drawCalls`数据成员将增加，这样我们就可以在每次循环结束时跟踪总共渲染了多少个可绘制对象。
- en: 'Finally, we can wrap this class up by looking at a couple of essential yet
    basic setter/getter code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过查看一些基本但重要的setter/getter代码来结束这个类的封装：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, disabling the use of shaders for whatever is being drawn currently
    is as simple as setting the `m_currentShader` data member to `nullptr`. Also note
    the `BeginDrawing()` method. It conveniently resets the `m_drawCalls` counter,
    which makes it easier to manage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，禁用当前绘制内容的着色器使用只需将`m_currentShader`数据成员设置为`nullptr`。还要注意`BeginDrawing()`方法。它方便地重置了`m_drawCalls`计数器，这使得管理起来更容易。
- en: Integrating the Renderer class
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Renderer类
- en: 'There is obviously no point in even having the `Renderer` class, if it is not
    going to be in its proper place or used at all. Since its only job is to draw
    things on screen with the correct effect being applied, a fitting place for it
    would be inside the `Window` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Renderer`类不在适当的位置或根本不被使用，那么甚至没有拥有它的意义。由于它的唯一任务是使用正确的效果在屏幕上绘制东西，因此它合适的地点应该是`Window`类内部：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because outside classes rely on it as well, it is a good idea to provide a getter
    method for easy retrieval of this object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于外部类也依赖于它，因此提供一个用于轻松检索此对象的getter方法是个好主意。
- en: 'Actually integrating it into the rest of the code is surprisingly easy. A good
    place to start is giving the `Renderer` access to the `Window` class like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际将其集成到其余代码中出奇地简单。一个不错的开始是让`Renderer`类访问`Window`类，如下所示：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The renderer also has *hooks* for knowing when we begin and end the drawing
    process. Luckily, the `Window` class already supports this idea, so it''s really
    easy to tap into it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器也有用于知道何时开始和结束绘图过程的钩子。幸运的是，`Window`类已经支持这个想法，所以实际上很容易利用它：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, in order to make use of the newest versions of OpenGL, the window
    needs to be instructed to create a version of the newest context available:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用最新的OpenGL版本，需要指示窗口创建最新可用的上下文版本：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the shader loading bit at the end of this code snippet. The `Renderer`
    class is instructed to load the shaders available in the designated directory,
    provided shaders are being used in the first place. These several simple additions
    conclude the integration of the `Renderer` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这段代码末尾的着色器加载部分。`Renderer`类被指示加载指定目录中可用的着色器，前提是首先使用着色器。这些几个简单的添加完成了`Renderer`类的集成。
- en: Adapting existing classes
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配现有类
- en: 'Up until this point, rendering something on screen was as simple as passing
    it as a drawable object to a `Draw()` method of a `Window` class. While great
    for smaller projects, this is problematic for us, simply because that heavily
    handicaps any use of shaders. A good way to upgrade from there is to simply take
    in `Window` pointers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在屏幕上渲染某物就像将其作为可绘制对象传递给`Window`类的`Draw()`方法一样简单。虽然这对小型项目来说很好，但这对我们来说是个问题，因为它严重限制了着色器的使用。一个很好的升级方法是简单地接受`Window`指针：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let us go over each of these classes and see what needs to be changed in order
    to add proper support for shaders.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些类，看看为了添加对着色器的适当支持需要做哪些更改。
- en: Updating the ParticleSystem
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新粒子系统
- en: 'Going all the way back to [Chapter 3](ch03.html "Chapter 3.  Make It Rain!
    - Building a Particle System") , *Make it rain! - Building a particle system*
    we have already used a certain amount of shading trickery without even knowing
    it! The additive blending used for fire effects is a nice feature, and in order
    to preserve it without having to write a separate shader for it, we can simply
    use the `AdditiveBlend()` method of the `Renderer` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第3章](ch03.html "第3章。让天下雨！ - 构建粒子系统")，*让天下雨！ - 构建粒子系统*，我们已经在不知情的情况下使用了一定数量的着色技巧！用于火焰效果的添加混合是一个很好的特性，为了保留它而无需为它编写单独的着色器，我们可以简单地使用`Renderer`类的`AdditiveBlend()`方法：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, note the check of the current application state. For now, we do not really
    need to use shaders inside any other states besides `Game` or `MapEditor`. Provided
    we are in one of them, the default shader is used. Otherwise, shading is disabled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意检查当前应用程序的状态。目前，我们实际上并不需要在`Game`或`MapEditor`以外的任何状态中使用着色器。只要我们处于其中之一，就使用默认的着色器。否则，着色器将被禁用。
- en: When dealing with actual particles, the `AdditiveBlend()` method is invoked
    with the blend mode flag being passed in as its argument, either enabling or disabling
    it. The particle drawable is then drawn on screen. After all of them have been
    processed, additive blending is turned off.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理实际粒子时，会调用`AdditiveBlend()`方法，并将混合模式标志作为其参数传递，要么启用要么禁用它。然后粒子可绘制对象将在屏幕上绘制。处理完所有粒子后，将关闭添加混合。
- en: Updating entity and map rendering
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新实体和地图渲染
- en: 'The default shader is not only used when rendering particles. As it happens,
    we want to be able to apply unified shading, at least to some extent, to all world
    objects. Let us begin with entities:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认着色器不仅在渲染粒子时使用。实际上，我们希望至少在一定程度上能够将统一的着色应用到所有世界对象上。让我们从实体开始：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The only real changes to the rendering system are the invocation of the `UseShader()`
    method, and the fact that a pointer to the `Window` class is being passed down
    to the sprite-sheets `Draw()` call as an argument, instead of the usual `sf::RenderWindow`.
    The `SpriteSheet` class, in turn, is also modified to use the `Renderer` class,
    even though it does not actually interact with or modify shaders at all.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对渲染系统的唯一真正改变是调用`UseShader()`方法，以及将`Window`类的指针作为参数传递给精灵图集的`Draw()`调用，而不是通常的`sf::RenderWindow`。反过来，`SpriteSheet`类也被修改为使用`Renderer`类，尽管它实际上并不与或修改着色器进行交互或修改。
- en: 'The game map should be shaded in exactly the same way as well:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏地图也应该以完全相同的方式进行着色：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only real difference here is the fact that the `Map` class already has access
    to the `Window` class internally, so it does not have to be passed in as an argument.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的真正区别是`Map`类已经内部访问了`Window`类，因此不需要将其作为参数传递。
- en: Creating a day/night cycle
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建昼夜循环
- en: 'Unifying the shading across many different world objects in our game gave us
    a very nice way of manipulating how the overall scene is actually represented.
    Many interesting effects are now possible, but we are going to focus on a rather
    simple yet effective one-lighting. The actual subtleties of the lighting subject
    will be covered in later chapters, but what we can do now is build a system that
    allows us to shade the world differently, based on the current time of the day,
    like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中统一多个不同世界对象的着色，为我们提供了一个非常优雅的方式来操纵场景的实际表示方式。现在可以实现许多有趣的效果，但我们将专注于一个相对简单而有效的一种光照。关于光照主题的实际微妙之处将在后面的章节中介绍，但我们现在可以构建一个系统，使我们能够根据当前的时间来以不同的方式着色世界，如下所示：
- en: '![Creating a day/night cycle](img/image_06_002.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![创建昼夜循环](img/image_06_002.jpg)'
- en: As you can tell, this effect can add a lot to a game and make it feel very dynamic.
    Let us take a look at how it can be implemented.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种效果可以为游戏增添很多，使其感觉非常动态。让我们看看它是如何实现的。
- en: Updating the Map class
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`Map`类
- en: 'In order to accurately represent a day/night cycle, the game must keep a clock.
    Because it is relative to the world, the best place to keep track of this information
    is the `Map` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确表示昼夜循环，游戏必须保持一个时钟。因为它与世界相关，所以跟踪这些信息的最佳位置是`Map`类：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the sake of having dynamic and customizable code, two additional data members
    are stored: the current game time, and the overall length of the day. The latter
    allows the user to potentially create maps with a variable length of a day, which
    could offer some interesting opportunities for game designers.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有动态和可定制的代码，存储了两个额外的数据成员：当前游戏时间和一天的总长度。后者允许用户创建具有可变一天长度的地图，这可能为游戏设计师提供一些有趣的机会。
- en: 'Using these values is fairly simple:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些值相当简单：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The actual game time is first manipulated by adding the frame time to it. It
    is then checked for having exceeded the boundaries of twice the value of the length
    of a day, in which case the game time is set back to `0.f`. This relationship
    represents a 1:1 proportion between the length of a day and the length of a night.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际游戏时间首先通过添加帧时间来操作。然后检查它是否超过了天数长度的两倍，在这种情况下，游戏时间被设置为`0.f`。这种关系表示一天长度和夜晚长度之间的1:1比例。
- en: Finally, ensuring the light properly fades between day and night, a `timeNormal`
    local variable is established, and used to calculate the amount of darkness that
    should be cast over the scene. It is then checked for having exceeded the value
    of `1.f`, in which case it is adjusted to start moving back down, representing
    the fade from darkness to dawn. The value is then passed to the default shader.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保光线在白天和夜晚之间正确地渐变，我们建立了一个名为`timeNormal`的局部变量，并使用它来计算应该投射到场景中的黑暗量。然后检查它是否超过了`1.f`的值，如果是，则将其调整以开始向下移动，表示从黑暗到黎明的渐变。然后将该值传递给默认的着色器。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to remember that shaders work with normalized values most of
    the time. This is why we are striving to provide it with a value between `0.f`
    to `1.f`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，着色器大多数时候都使用归一化值。这就是我们努力提供介于`0.f`到`1.f`之间的值的原因。
- en: 'The final piece of the puzzle is actually initializing our two additional data
    members to their default values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分实际上是初始化我们的两个额外数据成员到它们的默认值：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we have given the day length a value of `30.f`, which means
    the full day/night cycle will last a minute. This is obviously not going to be
    very useful for a game, but can come in handy when testing the shaders.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们给白天长度赋值为 `30.f`，这意味着全天/夜间周期将持续一分钟。这显然对游戏来说不会很有用，但在测试着色器时可能会派上用场。
- en: Writing the shaders
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写着色器
- en: 'With all of the *C++* code out of the way, we can finally focus on GLSL. Let
    us begin by implementing the default vertex shader:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有 *C++* 代码移除后，我们终于可以专注于 GLSL。让我们首先实现默认的顶点着色器：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is nothing different from the examples used during the introduction stage
    of this chapter. The purpose of adding the vertex shader now is simply to avoid
    having to write it again later, when something needs to be done in it. With that
    said, let us move on to the fragment shader:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这与本章介绍阶段所使用的例子并无不同。现在添加顶点着色器的目的只是为了避免将来在需要对其进行操作时再次编写它。话虽如此，让我们继续转向片段着色器：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sampler2D` type in this instance is simply the texture being passed into
    the shader by SFML. Other textures may also be passed into the shader manually,
    by using the `shader.setUniform("texture", &texture);` call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`sampler2D` 类型仅仅是 SFML 传递给着色器的纹理。其他纹理也可以通过使用 `shader.setUniform("texture",
    &texture);` 调用手动传递给着色器。
- en: In order to properly draw a pixel, the fragment shader needs to sample the texture
    of the current object being drawn. If a simple shape is being drawn, the pixel
    being sampled from the texture is checked for being completely black. If that's
    the case, it's simply set to a white pixel. In addition to that, we also need
    the `timeNormal` value discussed earlier. After the current pixel of the texture
    has been sampled, it is multiplied by the colour passed in from the vertex shader
    and stored as `gl_FragColor`. The `timeNormal` value is then subtracted from all
    three colour channels. Finally, a slight tint of blue is added to the pixel in
    the end. This gives our scene a blue tint, and is purely an aesthetic choice.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确绘制一个像素，片段着色器需要采样当前绘制对象的纹理。如果正在绘制一个简单的形状，则检查从纹理中采样的像素是否完全为黑色。如果是这样，它就简单地被设置为白色像素。除此之外，我们还需要之前讨论过的
    `timeNormal` 值。在采样当前纹理的当前像素之后，它被乘以从顶点着色器传入的颜色，并存储为 `gl_FragColor`。然后从所有三个颜色通道中减去
    `timeNormal` 值。最后，在像素的末尾添加一点蓝色调。这给我们的场景添加了蓝色调，纯粹是一个美学选择。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Many argue that graphics should be a secondary concern for a game developer.
    While it is clear that the visual side of a project should not be its primary
    concern, the visuals can serve a player more than simply acting as pretty backdrops.
    Graphical enhancements can even help tell a story better by making the player
    feel more engrossed in the environment, using clever visual cues, or simply controlling
    the overall mood and atmosphere. In this chapter, we have taken one of our first
    steps towards building a system that will serve as a massive helper when conquering
    the world of special effects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为图形应该是一个游戏开发者次要的关注点。虽然很明显，项目的视觉方面不应该成为其主要关注点，但视觉效果可以比仅仅作为漂亮的背景更有助于玩家。图形增强甚至可以通过让玩家更加沉浸在环境中、使用巧妙的视觉提示或简单地控制整体氛围和气氛来更好地讲述故事。在本章中，我们迈出了建立系统的第一步，该系统将成为征服特效世界时的巨大助手。
- en: In the next chapter, we will be delving deeper into the lower levels of graphical
    enhancements. See you there!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨图形增强的底层。那里见！
