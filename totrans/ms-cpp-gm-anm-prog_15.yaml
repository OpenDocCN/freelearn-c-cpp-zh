- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading a Game Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 11*! In the previous chapter, we added facial expressions
    to the instances. After a brief introduction of morph target animations, we extended
    the application to load morph meshes and added UI elements to control the face
    animations of an instance. Also, a new graph node type was added to allow using
    face animations in node trees. Finally, we implemented additive blending to move
    the heads of the instances independently of any skeletal and face animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a short break from character control and add
    a game level and level assets to the virtual world. We will start by exploring
    reasons why level data should be handled differently than models and instances;
    plus, we will look at suitable file formats to import level data with the Open
    Asset Importer Library and where to find game levels. Then, we will load level
    data and assets from files into the application and update the quadtree to become
    an octree. As the last step, we will add the level-related data to the renderer
    to draw the game map to the screen, giving us an idea of what the home for the
    inhabitants of our virtual world will look like. In this chapter, we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Differences between map and model data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a file format for a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a game map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the map data to the GPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for this chapter is available in the `chapter11` folder, in
    the `01_opengl_level` subfolder for OpenGL and the `02_vulkan_level` subfolder
    for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between map and model data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some interesting differences between handling models and level data,
    allowing us to apply optimizations in data handling. In the code for this book,
    we will do these optimizations after loading the level data. For larger levels,
    doing a precalculation during level creation is the better approach.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at some of the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Level data does not move around
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most significant difference between models and levels is simple: while
    the properties of a model instance can change, such as position, rotation, and
    speed, and they play animations, react to events, and so on, a level’s architecture
    typically remains unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-movable and non-animated polygons of a level have a big advantage: some
    data can be precalculated, either at creation time or at loading time for collision
    detection or lighting, for example. At runtime, only a lookup into the precalculated
    data is needed. Plus, we do not have to upload the data in every frame to the
    GPU again. All triangles can be processed at loading time and then uploaded once
    into GPU memory, residing there until the level data may be removed from the application
    by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: What about doors, buttons, elevators, or anything that does move in a level?
  prefs: []
  type: TYPE_NORMAL
- en: Movable parts of a level, such as sliding or revolving doors, elevators, buttons
    and switches, locker doors, mechanical platforms... in short, anything that can
    move inside a level, are usually modeled and used like an animated model instead
    of static level data.
  prefs: []
  type: TYPE_NORMAL
- en: Just think of a revolving door as a 3D model of a door, having a single node
    placed on the hinges. And on interaction, the model rotates around the hinge.
    Or, for a sliding door, the door model is translated a specific amount to one
    side, opening the passage to another room. In contrast to those doors, a static
    wall or a static floor in a level will never move or rotate.
  prefs: []
  type: TYPE_NORMAL
- en: Doing split collision detection for static data also helps us to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using a separate collision detection for level data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For collision detection, we can add a quadtree or octree containing only the
    level data. This tree must be recreated when the level is loaded and can be kept
    read-only during runtime, skipping costly operations of adding and removing instances.
    We then use the AABBs of the instances to check the level-data tree if an instance
    is colliding with level geometry. Using different tree structures for instance
    and level data also allows us to configure the trees according to the specific
    needs. A level octree may need entirely different values for maximum depth and
    number of triangles per node due to many triangles in the map, while there are
    only a few instances running around in the virtual world. In addition to the improvements
    for static data, a game level may contain other data that is not needed for models.
  prefs: []
  type: TYPE_NORMAL
- en: Level data may contain additional data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both CPU and GPU time are scarce resources at runtime, and any data that can
    be made available in lookup tables or calculated in a shader can save precious
    milliseconds when creating the next frame. We saw the effect in [*Chapter 2*](Chapter_2.xhtml)
    while moving parts of the animation calculation to a compute shader, and again
    in [*Chapter 7*](Chapter_7.xhtml) after adding animation lookup tables to GPU
    memory. In both chapters, a significant frame time boost was achieved for the
    same number of instances on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For level data, similar accelerations can be done. Four examples of such additional
    data are spatial division, lightmaps, navigation meshes, and hierarchical level
    of detail. Let’s take a brief look at these extra data types. Links to more detailed
    explanations can be found in the *Additional resources* section at the end of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We talked about the spatial division of a level when diving into collision detection
    in [*Chapter 8*](Chapter_8.xhtml). Saving spatial division data to the level file
    is needed to avoid doing the same calculations at loading time, or even at runtime
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating **Binary Space Partition** (**BSP**) trees or dividing the virtual
    world into an octree may take a long time, depending on the number of triangles
    in a level and the overall level complexity. This kind of computation can be moved
    to level creation time, adding only an optimized lookup version to the final level
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the principle of lightmaps was introduced in **id Software**’s **Quake**
    nearly thirty years ago, this technique is still in use today. During level creation,
    the light effects of static lights are “baked” into a texture, with bright pixels
    depicting the parts of the level geometry where the light of a static light source
    shines onto a surface, and dark pixels where shadows are on the level surface.
  prefs: []
  type: TYPE_NORMAL
- en: The lightmap texture is then added as a secondary texture, darkening the areas
    where the light from a light source does not reach the level geometry and simulating
    a shadow. Using a lightmap can drastically speed up light calculations by keeping
    a reasonable visual effect, since less expensive per-pixel calculations are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation mesh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **navmesh**, or **navigation mesh**, is an addition for enemies, NPCs, or
    any other computer-controlled objects. The level geometry will be overlayed with
    an extra mesh made of triangles or other polygons, but only in those places where
    computer-controlled objects should be able to move around. A navmesh accelerates
    pathfinding for the objects and can help to prevent collision checks when placed
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to navigation meshes in [*Chapter 13*](Chapter_13.xhtml),
    when we add simple navigation to the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical level-of-detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Model files can include so-called level-of-detail meshes. When drawing models
    that are far away from the camera, the mesh complexity can be lowered without
    affecting the visual quality as the model will cover only a few pixels of the
    screen. By using different mesh resolutions, the overall number of triangles to
    draw the models can be reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Level data can leverage level-of-detail meshes even more, replacing groups of
    objects with a simpler representation. For example, instead of drawing a large
    number of visually indistinguishable rocks at a great distance, the **Hierarchical
    Level-of-Detail** (**HLOD**) version of the same area could be merged to a single
    mesh with adjusted textures, delivering a similar visual quality with a fraction
    of the polygons and textures.
  prefs: []
  type: TYPE_NORMAL
- en: Level data may be partial or incomplete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your fancy animated 3D model should be fully available all the time, not only
    half of the model, or even less. But for level data, the sheer size of a level
    could be too much for a PC or console to handle at once, especially when taking
    the additional level data into account, like for lighting, navigation, or collision
    detection. But also texture size and quality, or the number and distribution of
    computer-controlled characters can raise the memory requirements by and large.
    Plus, the currently loaded level part could have much more detail, using the available
    resources to draw the visible area instead of keeping invisible and unused data
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the immersion for the player alive is part of the level design. The
    level may be hidden behind a winding passage, where none of the two-level parts
    is visible, allowing the game engine to discard the area where the player is coming
    from and loading the part they are heading to. Another widely used example for
    level switches is to use elevators and load new level data as the next floor of
    a building, spaceship, or similar.
  prefs: []
  type: TYPE_NORMAL
- en: By using precomputed data wisely, the time to render a single frame could be
    reduced to deliver a greater experience to the player. Or the visual details could
    be adjusted with the now unused CPU power, allowing to show more objects on the
    screen, or more detailed objects, while still maintaining the same frame time.
  prefs: []
  type: TYPE_NORMAL
- en: After the differences between maps and instances are clear, let’s see which
    file formats are mostly used for level data, and how to get game maps.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a file format for a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Open Asset Importer Library knows several old and new formats for 3D character
    models, but – sadly – support for level data is pretty limited.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore file formats of level files mostly found on the internet first,
    and then look at alternatives if the available formats do not fit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using levels in file formats supported by Assimp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A couple of file formats are used to create game level data, either by creating
    data from scratch or by using buildings and landscapes from other games as templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get some game maps to import, you should check out these websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sketchfab**: [https://sketchfab.com/](https://sketchfab.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free3D**: [https://free3d.com](https://free3d.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On both sites, an enormous number of free and paid animated and non-animated
    models, levels, and assets can be searched and downloaded. Several models come
    with a Creative Commons license, allowing you to use models in free and even commercial
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, you will find levels in the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Khronos Group glTF (`.gltf`/`.glb`): The open source glTF format can not only
    be used for models like the animated `Woman` and `Man` models we are using in
    the chapters, but also entire levels can be exported as glTF files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collada (`.dae`): Collada is an old but fully open XML-based file format. Collada
    is also managed by the Khronos Group, and even an ISO standard for the file format
    has been created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wavefront (`.obj` + `.mtl`): Many levels can be found in the Wavefront file
    format. Files in Wavefront format are pure text (no binary components) and the
    format is well documented and widely supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Universal Scene Description (`.usd`/`.usdz`): The **Universal Scene Description**
    (**USD**) format is quite new compared to the other file formats. USD is also
    open source and well documented, but the support in Assimp is still experimental
    due to the complexity of the file format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Autodesk FBX (`.fbx`): The “Filmbox” format is proprietary and mostly undocumented,
    but tools such as Blender and Assimp can read and write this file format. Using
    FBX is more or less at your own risk as it is possible that only specific versions
    are working as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If none of these models fits your needs, you may have to extend a file format,
    or even build a custom file format.
  prefs: []
  type: TYPE_NORMAL
- en: Extending existing formats or creating a custom format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating new game levels from scratch or modifying existing game levels may
    require additional information that is not available in the original file format,
    such as baked-in light maps, tree data, navigation meshes, or level-of-detail
    data. See the *Level data may contain additional data* section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: File formats such as glTF have the built-in ability to create extensions, while
    other file formats may be hard or impossible to extend without breaking existing
    importers. In such a case, you could invent your own file format from scratch
    or use a combination of one of the standard file formats for level data and add
    a custom format to store additional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom file format was created earlier in this book in the *Adding a YAML
    parser* section of [*Chapter 5*](Chapter_5.xhtml): the YAML configuration file
    to store all settings of the models, instances, cameras, collision detection,
    and node trees. Although we are relying on a standard textual format to store
    the data on disk, the contents of the file are tailored to fit the needs of our
    example application. Storing the same data in a binary format would also be possible,
    for instance, when decoding the text information will take too long.'
  prefs: []
  type: TYPE_NORMAL
- en: But creating an entirely new file format should the last resort since you will
    have to write all the code to read and write the data, keep track of different
    versions of the file format during read and write operations, and maybe even support
    different operating systems and hardware architectures. Maintaining such an organically
    grown file format can become a nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is to use standard formats and bundle all files into an archive,
    for instance, into a ZIP file. You don’t have to care about missing files when
    the level is distributed to players or other developers, but at the same time,
    you do not need to reinvent the wheel by creating a new, all-encompassing file
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Such archives are more common than you might think. Formats such as WAD from
    the original DOOM and PAK/PK2/PK3 for the Quake series were created to collect
    all game data in a single file, and these file types even support patching as
    files in new archives replace files of the same name in old archives.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own levels
  prefs: []
  type: TYPE_NORMAL
- en: What if you can’t find a suitable game level map on the internet? You still
    have the option to create a small map by yourself, for instance, with Blender.
    Creating a map is out of the scope of this book, but you will find suitable tutorials
    and videos on the internet. You can find links to two example videos in the *Additional
    resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: After we explored the reasons why separating model and level data in the application,
    we will now implement new code for loading and processing level data.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a game map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the first step to load a level, we will add a new C++ class named `AssimpLevel`.
    You can think of the `AssimpLevel` class as a mix of the two classes, `AssimpModel`
    and `AssimpInstance`, containing the static vertex data of the model class and
    dynamic properties such as the position, rotation, or scale of the instance class.
  prefs: []
  type: TYPE_NORMAL
- en: The `AssimpLevel` class consists of two new files, `AssimpLevel.h` and `AssimpLevel.cpp`.
    Both files are in the `model` folder, but we will borrow most of the methods and
    members from the two classes, `AssimpModel` and `AssimpInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do a brief walkthrough of the `AssimpLevel` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a C++ class to hold the level data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the level and model/instance data are so similar, we can reuse parts of
    the functionality we already have in the `AssimpModel` and `AssimpInstance` classes,
    such as loading the model file or doing matrix operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the static data, we can copy the following methods and members from the
    `AssimpModel` class, exchanging the `model` part in the name with `level` to be
    consistent with the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: The `loadModel()` method, but without bones, animations, and lookup table creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `processNode()` method, again without the bone-specific part
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire `draw()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getTriangleCount()`, `getModelFileName()`, and `getModelFileNamePath()`methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setModelSettings()` and `getModelSettings()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mTriangleCount` and `mVertexCount` member variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mRootNode`, `mNodeList`, `mRootTransformMatrix`, `mModelMeshes`, `mVertexBuffers`,
    and `mModelSettings` member variables to store the viable level data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mTextures` and `mPlaceholderTexture` member variables for the textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the dynamic data, the following methods and members can be copied from
    the `AssimpInstance` class, again replacing the word `model` with `level` in the
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: The `updateModelRootMatrix()` and `getWorldTransformMatrix()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mLocalTranslationMatrix`, `mLocalRotationMatrix`, `mLocalScaleMatrix`,
    `mLocalSwapAxisMatrix`, `mLocalTransformMatrix`, and `mModelRootMatrix` member
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To have all the variable level data in one location, we create the `LevelSettings.h`
    file in the `model` folder, containing the `LevelSettings` `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these level settings are also a mix of data taken partially
    from model settings (filenames) and instance settings (position, rotation, scale,
    axis swap). The `LevelSettings` data type will be used to simplify the level settings
    in the user interface and to save and load level-related data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also make the loaded level data available to other parts of the application
    by adding a vector of `AssimpLevel` shared pointers called `micLevels` and the
    `micSelectedlevel` int that holds the currently selected level from the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The main work to manage the `AssimpLevel` objects in the `micLevels` vector
    will be handled by the renderer class, so we add methods and callbacks as the
    second step.
  prefs: []
  type: TYPE_NORMAL
- en: Adding callbacks and renderer code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarities between the new level functionality and existing model functions
    also continue in the callbacks. Three new callback definitions named `levelCheckCallback`,
    `levelAddCallback`, and `levelDeleteCallback` must be added to the `Callbacks.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For the models, we have the same set of callbacks. The first callback, `levelCheckCallback`,
    is used to check if a level file with the same name is already loaded, and the
    other two callbacks, `levelAddCallback` and `levelDeleteCallback`, are used to
    load a new level from a file and to delete an existing level object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like for most of the callbacks, we will also make the functions available in
    the `ModelInstanceCamData` struct in `ModelInstanceCamData.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the renderer class, four new methods are added to handle the level management.
    And again, the new methods, `hasLevel()`, `getLevel()`, `addLevel()`, and `deleteLevel()`,
    are mostly copies from the equivalent model methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While `hasLevel()` is examining the `micLevels` vector to see if a level with
    the same file name is already loaded, `getLevel()` returns a shared pointer to
    the existing `AssimpLevel` object, or a `nullptr` if no level with the requested
    file name exists.
  prefs: []
  type: TYPE_NORMAL
- en: As the names suggest, `addLevel()` will try to load a level data file from local
    storage and add the new `AssimpLevel` object to `micLevels`, and `deleteLevel()`
    will delete the requested level from `micLevels` if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add a `null` level to stop `micLevels` being empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The connection between the three new callbacks and the `hasLevel()`, `addLevel()`,
    and `deleteLevel()` methods is created in the `init()` method of the renderer,
    allowing us to use the level calls in the `UserInterface` class.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s go for the third step on the path to level data management and add
    new elements to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the UI with level property controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like for the `AssimpLevel` class, we can simply copy and adjust existing
    control elements from other parts of the `createSettingsWindow()` method in the
    `UserInterface` class to create the new `CollapsingHeader` named **Levels**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11.1*, the resulting user interface part for the level data is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.1_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: User interface controls for the level data'
  prefs: []
  type: TYPE_NORMAL
- en: The **Levels** combo box is filled from the file names of the levels within
    the `micLevels` vector in the `ModelInstanceCamData` struct. The **Delete Level**
    button for the level data has the same function as the **Delete Model** button
    from the **Models** section of the UI, removing the currently selected level,
    and the controls for axis swap, position, rotation, and scaling are taken from
    the **Instances** UI section, along with the **Reset Values to Zero** button to
    set all controls to default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the new control elements, a new main menu entry named **Levels**
    is created. *Figure 11.2* shows all the elements of the main menu at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.2_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: The new Levels main menu entry'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on **Load Level...** opens the well-known ImGui-based file dialog,
    configured with a list of supported file formats for level data. See *Choosing
    a file format for a map* section about the extensions in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: The **Delete Model** and **Load Level...** UI elements utilize the callbacks
    to add and delete an `AssimpLevel` object from the application, creating a seamless
    workflow for the user when adding level data to the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: The significant difference between level data and model instances in terms of
    user experience is the missing visual selection and modification functionality
    for the level data. Since you will adjust the level data a few times until you
    are happy with position, rotation, and scale, the extra code to continuously move
    the level data around like instances will be used only once or twice. It is even
    more probable that a visual selection harms the workflow if the level data is
    selected when the desired instance is missed by some pixels.
  prefs: []
  type: TYPE_NORMAL
- en: As the last step of level data management, we will add the names of the loaded
    level files and the per-level settings to the YAML config file.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading the level configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing the loaded levels and the level settings in the YAM configuration file
    is quick and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: After adding an Emitter output operator overload for the `LevelSettings` data
    type, we can copy and adjust the emitting code block for models or cameras in
    the `createConfigFile()` method of the `YamlParser` class in the `tools` folder
    to save the level data. In addition, we must also emit the selected level number
    in the `settings` map of our configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, two new methods named `getLevelConfigs()` and `getSelectedLevelNum()`
    are added to the `YamlParser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both methods follow the same process as the model and camera counterparts. The
    first method, `getLevelConfigs()`, tries to load the level data from the YAML
    file, and `getSelectedLevelNum()` returns the index of the selected level at the
    time the configuration was saved.
  prefs: []
  type: TYPE_NORMAL
- en: In the `YamlParserTypes.h` file, a simple pair of `encode()` and `decode()`
    methods for the `LevelSettings` data type must be added to read back the data
    from the YAML file. We should also increase the `mYamlConfigFileVersion` value
    as the configuration structure has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add level data from a file, place the level in the virtual world,
    and store and reload the configuration. Adding the level data to the undo/redo
    stack is left as an exercise for you, but the basic principle level data undo/redo
    is identical to the undo/redo functionality for models.
  prefs: []
  type: TYPE_NORMAL
- en: Since the level data may contain overlapping elements, such as bridges, tunnels,
    or multiple floors of a building, instances could be on the same location in two
    dimensions. The existing collision detection would be triggered even if the instances
    are walking at different heights in the level, causing false reactions to non-existing
    collisions.
  prefs: []
  type: TYPE_NORMAL
- en: We have to extend the quadtree to become an octree to support collision detection
    in all three dimensions. Let’s check out how to upgrade the quadtree.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the quadtree to an octree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating the quadtree to an octree is astonishingly simple, and most of the
    work can be triggered by using the `Rename` function of the `Refactoring` functionality
    of the IDE. For brevity, we will just do a brief walkthrough of the required changes
    here. Please check the example code in the subfolders within the `chapter11` folder
    for the full octree code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we change the name of the `quadtree` folder to `octree`. In the `CMakeLists.txt`
    file, the two occurrences of `quadtree` must be also renamed `octree` to match
    the folder name. And we rename the `QuadTree` class `Octree` and change `BoundingBox2D`
    to `BoundingBox3D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we extend the `Octree` class by using eight instead of four children.
    *Figure 11.3* shows the quadrant IDs of the octree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.3_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Quadrant IDs in the octree'
  prefs: []
  type: TYPE_NORMAL
- en: The four existing child quadrant IDs, 0 to 3, will be used for the four front-facing
    octants, and the four back-facing octants will receive the new IDs 4 to 7\. Moving
    the four new octants to the back of the octree cuboid allows us to retain most
    of the logic from the quadtree. Adding the new logic to find the correct octant
    becomes merely an act of copying and pasting the code, taking front- and back-facing
    octants into account.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we update all `QuadTree`-related `include` statements, classes, and method
    calls in the code to `Octree`, and all `BoundingBox2D` occurrences to `BoundingBox3D`.
    The bounding box upgrade includes the change of all `glm::vec2` types of the old
    `BoundingBox2D` parameters to use `glm::vec3` instead. We also change the name
    of `getTopLeft()` to `getFrontTopLeft()` and add the `getBack()` method to reflect
    the availability of the third dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all callback function types in the code will be renamed from `quadTree`
    to `octree` to reflect the functionality change in all other places in the code
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use the octree to detect collisions in three dimensions. Sadly, the
    **Instance Positions** window still shows a top-down view of the instances, and
    we are unable to see if any instances are placed at different heights. We must
    adjust the rendering of the mini window containing the instances so that we can
    see any instances placed at different heights.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interactive octree view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new octree view is created in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For a better overview of the octree and the instances, the new view can be scaled,
    rotated, and translated by using the mouse. It may still take some extra rotations
    to align the octree with the camera view, but that is hard to do due to the orthogonal
    display and the symmetry of the octree. Fading out far away parts of the octree
    or highlighting the octant containing the camera may help to focus on the current
    area of interest. On the other hand, using a perspective projected octree may
    make it easier to find the right alignment, but the perspective will distort the
    distances between the instances, and we just create a copy of the main level rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The lines of the octree quadrants and the instances are collected into a temporary
    data structure. We will use an `OGLLineMesh` here as this data type contains just
    the bare minimum; we need to draw ImGui lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To achieve the desired view, all points of the octree quadrants and the instance
    bounding boxes must be transformed by the scaling, rotation, and translation from
    the first step. This transformation is done in the same way as we did for the
    cameras and instances: by creating a matrix and a matrix-vector multiplication
    for each point. There should be no surprises in the matrix operations; only the
    translation may need an explanation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s step through the interactive part first.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be able to change the octree view with the mouse button and mouse movements,
    we need three new private variables named `mOctreeZoomFactor`, `mOctreeRotation`,
    and `mOctreeTranslation` in the `UserInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The names of the variables are self-explanatory, so we do not need to dive into
    the details here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after creating the **Instance Positions** window in the `createPositionsWindow()`
    method of the `UserInterface` class, we add a check to see if the current window
    has been hovered over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Without the check, the mouse buttons and motions would trigger the octree view
    changes in all windows, leading to unwanted results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we get a reference to the internal `io` structure of ImGui:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In ImGui’s `io` structure, many internal states are available, like changes
    made to the mouse wheel or the mouse position.
  prefs: []
  type: TYPE_NORMAL
- en: We use the mouse wheel here to adjust the zoom factor of the octree view. Setting
    upper and lower bounds for the zoom factor helps to avoid losing the overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check if the right mouse button has been pressed and rotate the view
    according to the mouse movement while the right mouse button is still pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the right mouse button to change the rotation is also used for the camera,
    so this kind of view change should be known from working with the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we check for the middle mouse button, moving the octree around with
    the mouse motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wonder why we don’t use the left mouse button here: Pressing the left
    mouse button above an ImGui window activates the internal window movement. We
    have only the right and middle mouse buttons left to achieve two different view
    changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the transformation we want to see, we can get the lines from the
    octree and the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To store the lines before drawing, we add a `private` variable named `mOctreeLines`
    to the `UserInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After clearing the vertices vector inside `mOctreeLines`, we get the octree
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For every octree quadrant, we get a `BoundingBox3D` object, containing the
    minimum and maximum point positions. A conversion to an `AABB` is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `getAABBLines()` method to create all lines for the AABB as
    an `OGLLineMesh` and add the lines to the `mOctreeLines` mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we get AABB lines for every instance, coloring colliding instances red
    and all other instances yellow. The currently selected instance also gets an additional
    green border to be able to stop the instance easily.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the loops over both the octants and the instances, `mOctreeLines`
    contains vertices of all lines that should be drawn to the ImGui window. We now
    need to transform the vertices to match the selected scaling, rotation, and translation.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the view and drawing the lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since storing intermediate results is faster than allocating and calculating
    a new transformation matrix for the octree lines in every frame, we add three
    more `private` member variables named `mScaleMat`, `mRotationMat`, and `mOctreeViewMat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, scaling and the two rotations are applied to create the final view matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we loop over the vertices in `mOctreeLines` in groups of two since we need
    a starting point and ending point for each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, we extract the vertex pair for each line and transform the
    vertex positions by multiplication with the `mOctreeViewMat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the point coordinates to the center of the drawing and add the
    translational part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need a separate translation matrix here because the movement of the
    octree lines is only related to the ImGui window, not the position of the vertices
    in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the loop, we draw an ImGui line from the start point to the end
    point using the colors of the line and a fixed alpha value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we start the application after these changes, the octree view can be rotated
    by pressing the right mouse button, moved around by pressing the middle mouse
    button, and zoomed in and out by using the mouse wheel.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.4* shows a view of the octree in the **Instance Positions** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.4_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: A rotated octree with instances and two subdivision levels'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the bounding boxes for all instances in three dimensions. Colliding
    instances are drawn in red, all other instances are yellow (the same colors as
    for the AABB debug lines), and the currently selected instance has an extra outline
    in green.
  prefs: []
  type: TYPE_NORMAL
- en: Another important fact to see is the subdivision level of the octree. At the
    root level of the octree, one subdivision is divided into eight octants – this
    has happened because of the number of instances. In the far lower right octant,
    another subdivision was needed to limit the instance count per octant.
  prefs: []
  type: TYPE_NORMAL
- en: When the application is running, the movement of the instances and changes in
    the octree subdivision can be seen in real time. And the view can be changed to
    focus on any interesting area of the octree.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of the default octree implementation is the growing overhead. A
    subdivision may produce a lot of empty nodes, especially if the threshold per
    node is small and the tree depth is high. For our implementation, each subdivision
    into eight octants adds a memory overhead of roughly one kilobyte in memory usage,
    even if we need to store only one or two instance AABBs in one of the child octants.
  prefs: []
  type: TYPE_NORMAL
- en: Also, each subdivision adds another step to the traversal costs. Even though
    the traversal complexity grows only on a logarithmic basis, the overhead in memory
    and traversal time may become significant in larger levels. In this case, a data
    structure such as a sparse voxel octree could be used instead. A link to a paper
    describing the principles of sparse voxel octrees is available in the *Additional
    resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: A shortcoming of the current level loading is a missing “feeling” about the
    dimensions of the loaded level data. If the level is not flat but contains areas
    with different heights, it is hard to imagine the edges of the level data.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better orientation, we will also add an AABB for the level data.
  prefs: []
  type: TYPE_NORMAL
- en: Building an AABB for the level data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Axis-aligned bounding boxes are a great tool to avoid estimating or guessing
    the dimensions of an object. We are using model instance AABBs as a solution to
    detect collisions by allowing the application to compare the maximum extents of
    two instances.
  prefs: []
  type: TYPE_NORMAL
- en: While unused areas between the vertices of the instances and the bounding box
    are a trade-off between speed and complexity for collision detection, the situation
    is different for level data. The AABB lines will help us to see the maximum extent
    of the level in all three dimensions, especially when the level data has large
    unused areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the AABB is done quick and simple. First, we add a new private member
    variable called `mLevelAABB` in the `AssimpLevel.h` file to store the AABB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate and retrieve the bounding box data, we add two new public methods,
    `generateAABB()` and `getAABB()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Splitting the generation of the AABB data from the retrieval is a clever idea
    as the levels may contain a lot of meshes and vertices. A recalculation is only
    needed if we adjust the level properties such as the scaling or position since
    the level data does not move or change other properties by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the transformation matrix for the level data, so calculating
    the bounding box for the level in `generateAABB()` is only a loop over all vertices
    of all meshes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A crucial step here is changing the `w` element of the vertex position. We are
    using the last element of the position to transport one texture coordinate to
    the shader. For a correct matrix multiplication, we must set the last element
    of position to `1.0f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger an automatic update of the level AABB during property changes of
    the level, we add a simple callback to `Callbacks.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ModelInstanceCamData` `struct`, another callback function is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We bind the `micLevelGenerateAABBCallbackFunction` callback to the `generateLevelAABB()`
    method in the `init()` method of the renderer, along with the other level data
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: To get a nice interactive display in the user interface, we add a Boolean named
    `settingChangedForAABB` to the **Levels** section. On every slider or checkbox
    change, or when pressing the **Reset Values to Zero** button, we trigger a recalculation
    of the level’s AABB.
  prefs: []
  type: TYPE_NORMAL
- en: And what about other static level elements? These objects are called **assets**
    and can be added to a level. Assets also need collision checks to prevent the
    instances from running right through each other, but assets are mostly not animated;
    they remain in the place intended by the level designers.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a shortcut here and utilize the non-animated models to mimic static
    level assets. For dynamic assets, such as buttons or doors, animated models can
    be used; see the *Level data does not move around* section for a brief explanation.
    In the *Practical sessions* section, a task to add dynamic assets to the virtual
    world is available.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see what changes are needed for the non-animated models.
  prefs: []
  type: TYPE_NORMAL
- en: Using non-animated models as assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To avoid adding a new `AssimpAsset` class with mostly the same functionality
    as the non-animated models, we will extend the current `AssimpModel` class and
    the renderer a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the model class, we change the `getAABB()` method to return either a dynamic
    AABB for models with animations or a static AABB for models without animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The new method, `getAnimatedAABB()`, is just a new name for the old `getAABB()`
    method, and it calculates the AABB from the lookup data as before. The other new
    method, `getNonAnimatedAABB()`, is mostly the `updateModelRootMatrix()` method
    from the `AssimpInstance` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we calculate a separate matrix for scaling, rotation, axis swap, and
    translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the transformation matrices and the root transformation matrix from the
    model file are combined into a single transform matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the bounding box data, all vertices of the model mesh are transformed
    to the new positions and the positions are added to a local variable named `modelAABB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For the `w` element of the vertex position, the same adjustment as for the level
    data AABB is needed. By setting the last value to `1.0f`, we guarantee a correct
    matrix multiplication when computing the final position.
  prefs: []
  type: TYPE_NORMAL
- en: With the resulting AABB, the extents of the non-animated instance vertices are
    able to detect AABB collisions with animated models and to draw the debug lines.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations for asset AABBs
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the AABB for non-animated instances is calculated for every instance
    in every frame, like the AABB for the animated instances. If the calculation becomes
    a bottleneck, for example, if a lot of static assets are placed in the virtual
    world, changing the AABB computation only on property changes in the UI can be
    done easily.
  prefs: []
  type: TYPE_NORMAL
- en: Once the level data has been loaded and processed and the AABBs are calculated,
    we are ready to draw the level triangles to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extend the renderer to add the level data to the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the level data to the GPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With every addition of new features, it becomes simpler to reuse code in the
    application. In the case of level data, mesh data is encapsulated in the `AssimpLevel`
    class, and drawing the level’s triangles can be done in a small loop over all
    loaded levels.
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, we create a new shader to draw the level data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we need to draw the level triangles only once, using a separate shader
    for the level data is a clever idea. Add the `private` shader named `mAssimpLevelShader`
    to the header file of the renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The shader will use the two new files, `assimp_level.vert` for the vertex shader
    and `assimp_level.frag` for the fragment shader. We load the files along with
    the other shaders in the `init()` method of the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The fragment shader file, `assimp_level.frag`, is just a copy of the `assimp.frag`
    file without any changes. For the vertex shader file, `assimp_level.vert`, we
    can copy the `assimp.vert` file and keep the `in` and `out` layout portion and
    the `Matrices` uniform buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need the selection buffer since no visual selection has been implemented
    for the level data, and we can change the buffer at binding point `1` to contain
    only a single 4x4 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Uploading only small data elements like a single matrix to a uniform buffer
    on the GPU is not the best idea as every upload may add a small delay to the frame.
    For a real game, or a game engine, the world transform matrix would be part of
    a bigger buffer, but for the sake of simplicity we just do the single upload here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` method of the vertex shader, we use the `worldTransformMat`
    to transform the position and normal vertices to the final position given by the
    matrix created from the level properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `draw()` method of the renderer, we loop over all levels and skip
    the null level by checking for the existence of any triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step of the level display process, the vertex drawing is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We use the new `mAssimpLevelShader`, upload the transformation matrix of the
    level to the shader, and call the `draw()` method of the `AssimpLevel` object.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the level AABB on the screen requires a few more methods and member
    variables in the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the level AABB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The level AABB vertices are stored in a new `private` member variable named
    `mAllLevelAABB` in the renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, two new private methods named `generateLevelAABB()` and `drawLevelAABB()`
    are added to the renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We also split generating and drawing the AABB lines here to avoid costly calculations
    in every frame we draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating the level AABB in `generateLevelAABB()` is done in a simple loop.
    After clearing the level AABB data, we loop over all loaded levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The check for a level without triangles skips the null level since there is
    nothing to draw to the screen. Then, we generate the AABB of each level and add
    the minimum and maximum extents of each level to `mAllLevelAABB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The resulting AABB contains all the level data of all the loaded levels. If
    you want to have separate AABBs for each level, you could use a vector of AABBs
    instead the single AABB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the level AABB in the `drawLevelAABB()` method needs little explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use the `getAABBLines()` method of the AABB to create the line data, upload
    the lines to the `mLineVertexBuffer`, call `use()` on `LineShader`, and then call
    `bindAndDraw()` on the `mLineVertexBuffer` object to draw the axis-aligned bounding
    box of the level data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `draw()` method of the renderer, we call `drawLevelAABB()` when
    `rdDrawLevelAABB` is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The color has been chosen randomly, you may change the color value or even add
    a 3-element float slider to the UI to control the color value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Showing the level AABB lines on screen is done by a new Boolean variable called
    `rdDrawLevelAABB` in the `OGLRenderData` `struct` in the `OGLRenderData.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For the Vulkan version of the code, the variable will be created in the `VKRenderData`
    struct in the `VkRenderData.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: In the `UserInterface` class, we add a checkbox for `rdDrawLevelAABB` in the
    **Levels** section of the `createSettingsWindow()` method, allowing us to toggle
    the level’s AABB lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all! In *Figure 11.5*, an example map from Sketchfab has been loaded
    next to the woman model, and the level’s AABB was activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.5_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Example map (unscaled) and an instance of the woman model (source:
    Counter Strike 1.6 map “de_dust” by Zarudko at https://skfb.ly/6QYJw)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a gamer, you may know this map: It’s “de_dust” from Counter Strike 1.6\.
    The map is available at Sketchfab in several versions and formats, along with
    other popular game maps.'
  prefs: []
  type: TYPE_NORMAL
- en: The bounding box around the level data helps us to see the dimensions of the
    level. Especially for unused areas like in the front right of *Figure 11.5*, finding
    the boundaries of the level data would be hard without the AABB lines.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice the unusual size ratio between the level map and the model
    instance. The map and model have been loaded with their default scaling values,
    and the size values have been chosen arbitrarily by the author of the files. Resizing
    one or both objects is easy thanks to the scaling slider for model and level data,
    but getting a reasonable ratio between levels, models, and other objects from
    various sources and artists can become challenging.
  prefs: []
  type: TYPE_NORMAL
- en: To create a plausible virtual world, the sizes of the game character models
    must match the sizes of furniture, buildings, environmental objects, and so on.
    Even a small mismatch in the proportions of different objects will be visible
    when comparing game characters and objects with the real world. A good way to
    adjust the different elements is to use one fixed-size object with a known size,
    such as a block from Minecraft, which has a (virtual) edge length of one meter,
    or even a simple line of a defined length in the virtual world. By resizing all
    objects to their real-world sizes compared to the known object, models from different
    sources can be made to match visually.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added static level data to the virtual world. After exploring
    the differences between level maps and models, we looked at suitable file formats
    for level data and how to find cool game maps. Then, we added support for level
    data to the application and replaced the quadtree with an octree to support collision
    detection in three dimensions. Finally, we added the new level data and a level
    AABB to the renderer. We will extend the level data in the next two chapters to
    create a virtual world where the instances can roam around freely and by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue the collision detection from [*Chapter
    8*](Chapter_8.xhtml). First, we will extend the existing code to support collisions
    between instances and the level geometry. To ensure the instances are always on
    the ground, we will introduce gravity in the virtual world. As the last step,
    we add inverse kinematics to the legs of the instances, allowing the model to
    climb stairs or slopes with natural motion.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a door or a button to the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the animated level data is more like an animated character model placed
    at a fixed position in the level than static level data, you could try to add
    doors, switches, or buttons to the level, and instead of waving back on interaction,
    the button could play a “pressed” animation, and a door could revolve around the
    hinge or slide to one side.
  prefs: []
  type: TYPE_NORMAL
- en: Add dynamic level loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could use the information about the current position of the playable character
    to decide when to load or unload parts of the level. Maybe add a new mapping of
    coordinates where a specified level data file is loaded, and another coordinate
    where the level data is removed from the application. If you have added animated
    level objects from the first task to the dynamic level part, make sure to save
    the status of these objects on unloading and restore the state when reloading
    the level data. The player could open a door or activate a switch, and upon returning
    to the level part, the player could see the object in the exact same state as
    they left it. To prevent crashes or data corruption caused by assets that are
    not fully loaded or destroyed, use atomic operations or locking mechanisms such
    as mutexes. Also, loading and level data and assets may need synchronization to
    restore the correct state of all elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert difficulty: Load dynamic level parts asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a level file, processing the data, and adding the vertex data takes
    some time, resulting in a visible hitch in the application. Use `std::async` or
    a full worker thread to trigger the loading when a condition to load is met, for
    instance, when the player is at a specific world position. Be aware that adding
    any asynchronous code requires extra measures against data races.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Efficient sparse voxel octrees: [https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf](https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender map creation 1: [https://www.youtube.com/watch?v=IKkOLeAuEHI](https://www.youtube.com/watch?v=IKkOLeAuEHI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender map creation 2: [https://www.youtube.com/watch?v=hdyBgQ77Sdg](https://www.youtube.com/watch?v=hdyBgQ77Sdg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is a lightmap?: [http://wiki.polycount.com/wiki/Light_map](http://wiki.polycount.com/wiki/Light_map)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigation mesh explanation: [https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424](https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HLOD: [https://gamma.cs.unc.edu/HLOD/](https://gamma.cs.unc.edu/HLOD/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to write glTF custom extensions: [https://gltf-transform.dev/extensions](https://gltf-transform.dev/extensions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'itch.io Assets: [https://itch.io/game-assets](https://itch.io/game-assets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sketchfab for models, maps, and assets: [https://sketchfab.com](https://sketchfab.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Free3D: [https://free3d.com](https://free3d.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counter Strike 1.6 map “de_dust” by Zarudko: [https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
