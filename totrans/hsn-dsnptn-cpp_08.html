<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-142"><a id="_idTextAnchor360"/><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-143"><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.2.1">The Curiously Recurring Template Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We are already familiar with the concepts of inheritance, polymorphism, and virtual functions. </span><span class="koboSpan" id="kobo.3.2">A derived class inherits from the base class and customizes the behavior of the base class by overriding its virtual functions. </span><span class="koboSpan" id="kobo.3.3">All operations are done on an instance of the base class, polymorphically. </span><span class="koboSpan" id="kobo.3.4">When the base object is actually an instance of the derived class, the right customized overrides are called. </span><span class="koboSpan" id="kobo.3.5">The base class knows nothing about the derived class, which may not even have been written when the base class code was written and compiled. </span><span class="koboSpan" id="kobo.3.6">The </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">CRTP</span></strong><span class="koboSpan" id="kobo.7.1">) turns this </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.8.1">well-ordered picture on its head, and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">inside out.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">is CRTP?</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">What is static polymorphism and how does it differ from </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">dynamic polymorphism?</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">What are the downsides of virtual function calls, and why may it be preferable to resolve such calls at </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">compile time?</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">What are the other uses </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">of CRTP</span><a id="_idTextAnchor363"/><span class="koboSpan" id="kobo.20.1">?</span></span><a id="_idTextAnchor364"/></li>
</ul>
<h1 id="_idParaDest-144"><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The Google Benchmark </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">library: </span></span><a href="https://github.com/google/benchmark"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/google/benchmark</span></span></a></p>
<p><span class="koboSpan" id="kobo.25.1">Example </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">code: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08</span></span></a><span class="hidden"><a id="_idTextAnchor366"/></span></p>
<p><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.28.1">Wrapping your head </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">around CRTP</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">CRTP was</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.31.1"> first introduced, under this name, by James Coplien in 1995, in his article in </span><em class="italic"><span class="koboSpan" id="kobo.32.1">C++ Report</span></em><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">It is a particular form of a more general bounded polymorphism (Peter S. </span><span class="koboSpan" id="kobo.33.3">Canning et al., </span><em class="italic"><span class="koboSpan" id="kobo.34.1">F-bounded polymorphism for object-oriented programming, Conference on Functional Programming Languages and Computer Architecture</span></em><span class="koboSpan" id="kobo.35.1">, 1989). </span><span class="koboSpan" id="kobo.35.2">While not a general replacement for virtual functions, it provides the C++ programmer with a similar tool that, under the right circumstances, offers </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">several advantage</span><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.37.1">s</span><a id="_idTextAnchor369"/><span class="koboSpan" id="kobo.38.1">.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.39.1">What is wrong with a virtual function?</span></h2>
<p><span class="koboSpan" id="kobo.40.1">Before </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.41.1">we can talk about a </span><em class="italic"><span class="koboSpan" id="kobo.42.1">better</span></em><span class="koboSpan" id="kobo.43.1"> alternative to a virtual function, we should consider why we would want to have an alternative at all. </span><span class="koboSpan" id="kobo.43.2">What is not to like about </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">virtual functions?</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">The problem is the performance overhead. </span><span class="koboSpan" id="kobo.45.2">A virtual function call can be several times more expensive than a non-virtual call, more for very simple functions that would have been inlined were they not virtual (recall that a virtual function can never be inlined). </span><span class="koboSpan" id="kobo.45.3">We can measure this difference with a microbenchmark, the ideal tool for measuring the performance of small fragments of code. </span><span class="koboSpan" id="kobo.45.4">There are many microbenchmark libraries and tools out there; in this book, we will use the Google Benchmark library. </span><span class="koboSpan" id="kobo.45.5">To follow along with the examples in this chapter, you must first download and install the library (the detailed instructions can be found in </span><a href="B19262_05.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.47.1">, </span><em class="italic"><span class="koboSpan" id="kobo.48.1">A Comprehensive Look at RAII</span></em><span class="koboSpan" id="kobo.49.1">). </span><span class="koboSpan" id="kobo.49.2">Then, you can compile and run </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the examples.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Now that we have the microbenchmark library ready, we can measure the overhead of a virtual function call. </span><span class="koboSpan" id="kobo.51.2">We are going to compare a very simple virtual function, with the minimum amount of code, against a non-virtual function doing the same thing. </span><span class="koboSpan" id="kobo.51.3">Here is our </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">virtual function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.53.1">
// Example 01
class B {
  public:
  B() : i_(0) {}
  virtual ~B() {}
  virtual void f(int i) = 0;
  int get() const { return i_; }
  protected:
  int i_;
};
class D : public B {
  public:
  void f(int i) override { i_ += i; }
};</span></pre>
<p><span class="koboSpan" id="kobo.54.1">And, here</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.55.1"> is the equivalent </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">non-virtual one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
// Example 01
class A {
  public:
  A() : i_(0) {}
  void f(int i) { i_ += i; }
  int get() const { return i_; }
  protected:
  int i_;
};</span></pre>
<p><span class="koboSpan" id="kobo.58.1">We can now call both of them in a micro-benchmark fixture and measure how long each </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">call takes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
void BM_none(benchmark::State&amp; state) {
  A* a = new A;
  int i = 0;
  for (auto _ : state) a-&gt;f(++i);
  benchmark::DoNotOptimize(a-&gt;get());
  delete a;
}
void BM_dynamic(benchmark::State&amp; state) {
  B* b = new D;
  int i = 0;
  for (auto _ : state) b-&gt;f(++i);
  benchmark::DoNotOptimize(b-&gt;get());
  delete b;
}</span></pre>
<p><span class="koboSpan" id="kobo.61.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">benchmark::DoNotOptimize</span></strong><span class="koboSpan" id="kobo.63.1"> wrapper prevents the compiler from optimizing away the unused object, and, along with it, removing the entire set of function calls as unnecessary. </span><span class="koboSpan" id="kobo.63.2">Note </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.64.1">that there is a subtlety in measuring the virtual function call time; a simpler way to write the code would be to avoid the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">new</span></strong><span class="koboSpan" id="kobo.66.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">delete</span></strong><span class="koboSpan" id="kobo.68.1"> operators and simply construct the derived object on </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the stack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.70.1">
void BM_dynamic(benchmark::State&amp; state) {
  D d;
  int i = 0;
  for (auto _ : state) d.f(++i);
  benchmark::DoNotOptimize(b-&gt;get());
}</span></pre>
<p><span class="koboSpan" id="kobo.71.1">However, this benchmark is likely to yield the same time as the non-virtual function call. </span><span class="koboSpan" id="kobo.71.2">The reason is not that a virtual function call has no overhead. </span><span class="koboSpan" id="kobo.71.3">Rather, in this code, the compiler is able to deduce that the call to the virtual function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">f()</span></strong><span class="koboSpan" id="kobo.73.1">, is always a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">D::f()</span></strong><span class="koboSpan" id="kobo.75.1"> (it helps that the call is not done through the base class pointer, but rather the derived class reference, so it could hardly be anything else). </span><span class="koboSpan" id="kobo.75.2">A decent optimizing compiler will de-virtualize such a call, for instance, generating a direct call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">D::f()</span></strong><span class="koboSpan" id="kobo.77.1"> without the indirection and the reference to the </span><em class="italic"><span class="koboSpan" id="kobo.78.1">v-table</span></em><span class="koboSpan" id="kobo.79.1">. </span><span class="koboSpan" id="kobo.79.2">Such a call can even </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">be inlined.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Another </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.82.1">possible complication is that both microbenchmarks, especially the non-virtual call, may be too fast—the body of the benchmark loop is likely to take less time than the overhead of the loop. </span><span class="koboSpan" id="kobo.82.2">We can remedy that by making several calls inside the body of the loop. </span><span class="koboSpan" id="kobo.82.3">This can be accomplished with the copy-paste feature of your editor, or with the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">preprocessor macros:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.84.1">
#define REPEAT2(x) x x
#define REPEAT4(x) REPEAT2(x) REPEAT2(x)
#define REPEAT8(x) REPEAT4(x) REPEAT4(x)
#define REPEAT16(x) REPEAT8(x) REPEAT8(x)
#define REPEAT32(x) REPEAT16(x) REPEAT16(x)
#define REPEAT(x) REPEAT32(x)</span></pre>
<p><span class="koboSpan" id="kobo.85.1">Now, inside the benchmark loop, we can write </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
REPEAT(b-&gt;f(++i);)</span></pre>
<p><span class="koboSpan" id="kobo.88.1">The per-iteration time reported by the benchmark now refers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">32</span></strong><span class="koboSpan" id="kobo.90.1"> function calls. </span><span class="koboSpan" id="kobo.90.2">While this does not matter for comparing the two calls, it may be convenient to make the benchmark itself report the true number of calls per second by adding this line to the end of the benchmark fixture, after </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">the loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
state.SetItemsProcessed(32*state.iterations());</span></pre>
<p><span class="koboSpan" id="kobo.93.1">We can now compare the results of the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">two benchmarks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.95.1">
Benchmark           Time UserCounters...
</span><span class="koboSpan" id="kobo.95.2">BM_none          1.60 ns items_per_second=19.9878G/s
BM_dynamic       9.04 ns items_per_second=3.54089G/s</span></pre>
<p><span class="koboSpan" id="kobo.96.1">We see that the virtual function call is almost 10 times more expensive than the non-virtual one. </span><span class="koboSpan" id="kobo.96.2">Note that this is not exactly a fair comparison; the virtual call provides additional functionality. </span><span class="koboSpan" id="kobo.96.3">However, some of this functionality can be implemented in other ways, without paying the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">performance over</span><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.98.1">h</span><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.99.1">ead.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.100.1">Introducing CRTP</span></h2>
<p><span class="koboSpan" id="kobo.101.1">Now, we will</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.102.1"> introduce CRTP, which turns inheritance on </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">its head:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
template &lt;typename D&gt; class B {
  ...
</span><span class="koboSpan" id="kobo.104.2">};
class D : public B&lt;D&gt; {
  ...
</span><span class="koboSpan" id="kobo.104.3">};</span></pre>
<p><span class="koboSpan" id="kobo.105.1">The first change that jumps out is that the base class is now a </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">class</span></strong><span class="koboSpan" id="kobo.107.1"> template. </span><span class="koboSpan" id="kobo.107.2">The derived class still inherits from the base class, but now from the specific instantiation of the base class template—on its own! </span><span class="koboSpan" id="kobo.107.3">Class </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">B</span></strong><span class="koboSpan" id="kobo.109.1"> is instantiated on class </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">D</span></strong><span class="koboSpan" id="kobo.111.1">, and class </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">D</span></strong><span class="koboSpan" id="kobo.113.1"> inherits from that instantiation of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">B</span></strong><span class="koboSpan" id="kobo.115.1">, which is instantiated on class </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">D</span></strong><span class="koboSpan" id="kobo.117.1">, which inherits from class </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">B</span></strong><span class="koboSpan" id="kobo.119.1">, which... </span><span class="koboSpan" id="kobo.119.2">that’s recursion in action. </span><span class="koboSpan" id="kobo.119.3">Get used to it because you will see it often in </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">What is the motivation for this mind-twisting pattern? </span><span class="koboSpan" id="kobo.121.2">Consider that now the base class has compile-time information about the derived class. </span><span class="koboSpan" id="kobo.121.3">Therefore, what used to be a virtual function call can now be bound to the right function at </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">compile time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.123.1">
// Example 01
template &lt;typename D&gt; class B {
  public:
  B() : i_(0) {}
  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f(i); }
  int get() const { return i_; }
  protected:
  int i_;
};
class D : public B&lt;D&gt; {
  public:
  void f(int i) { i_ += i; }
};</span></pre>
<p><span class="koboSpan" id="kobo.124.1">The call itself can still be done on the base </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">class pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
B&lt;D&gt;* b = ...;
b-&gt;f(5);</span></pre>
<p><span class="koboSpan" id="kobo.127.1">There is </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.128.1">no indirection and no overhead for the virtual call. </span><span class="koboSpan" id="kobo.128.2">The compiler can, at compile time, track the call all the way to the actual function called, and even </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">inline it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
void BM_static(benchmark::State&amp; state) {
  B&lt;D&gt;* b = new D;
  int i = 0;
  for (auto _ : state) {
    REPEAT(b-&gt;f(++i);)
  }
  benchmark::DoNotOptimize(b-&gt;get());
  state.SetItemsProcessed(32*state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.131.1">The benchmark shows that the function call made through the CRTP takes exactly as much time as a regular </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">function call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
Benchmark           Time UserCounters...
</span><span class="koboSpan" id="kobo.133.2">BM_none          1.60 ns items_per_second=19.9878G/s
BM_dynamic       9.04 ns items_per_second=3.54089G/s
BM_static        1.55 ns items_per_second=20.646G/s</span></pre>
<p><span class="koboSpan" id="kobo.134.1">The main restriction on the CRTP is that the size of the base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">B</span></strong><span class="koboSpan" id="kobo.136.1">, cannot depend on its template parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">D</span></strong><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">More generally, the template for class </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">B</span></strong><span class="koboSpan" id="kobo.140.1"> has to instantiate with type </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">D</span></strong><span class="koboSpan" id="kobo.142.1"> being an incomplete type. </span><span class="koboSpan" id="kobo.142.2">For example, this will </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
template &lt;typename D&gt; class B {
  using T = typename D::T;
  T* p_;
};
class D : public B&lt;D&gt; {
  using T = int;
};</span></pre>
<p><span class="koboSpan" id="kobo.145.1">The </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.146.1">realization that this code will not compile may come somewhat as a surprise, given how similar it is to many widely used templates that refer to the nested types of their template parameters. </span><span class="koboSpan" id="kobo.146.2">For example, consider this template, which converts any sequence container with </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">push_back()</span></strong><span class="koboSpan" id="kobo.148.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">pop_back()</span></strong><span class="koboSpan" id="kobo.150.1"> functions to </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">a stack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
template &lt;typename C&gt; class stack {
  C c_;
  public:
  using value_type = typename C::value_type;
  void push(const valuetype&amp; v) { c.push_back(v); }
  value_type pop() {
    value_type v = c.back();
    c.pop_back();
    return v;
  }
};
stack&lt;std::vector&lt;int&gt;&gt; s;</span></pre>
<p><span class="koboSpan" id="kobo.153.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">using</span></strong><span class="koboSpan" id="kobo.155.1"> type alias for </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">value_type</span></strong><span class="koboSpan" id="kobo.157.1"> looks exactly the same as the preceding one, in our attempt to declare class </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">B</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">So, what is wrong with the one in </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">B</span></strong><span class="koboSpan" id="kobo.161.1">? </span><span class="koboSpan" id="kobo.161.2">Actually, nothing is wrong with class </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">B</span></strong><span class="koboSpan" id="kobo.163.1"> itself. </span><span class="koboSpan" id="kobo.163.2">It would compile just fine in a context similar to that of our </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">stack class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
class A {
  public:
  using T = int;
  T x_;
};
B&lt;A&gt; b; // Compiles with no problems</span></pre>
<p><span class="koboSpan" id="kobo.166.1">The problem lies not with class </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">B</span></strong><span class="koboSpan" id="kobo.168.1"> itself, but with our intended use </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">of it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
class D : public B&lt;D&gt; ...</span></pre>
<p><span class="koboSpan" id="kobo.171.1">At the </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.172.1">point where </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">B&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.174.1"> has to be known, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">D</span></strong><span class="koboSpan" id="kobo.176.1"> has not been declared yet. </span><span class="koboSpan" id="kobo.176.2">It cannot be—the declaration of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">D</span></strong><span class="koboSpan" id="kobo.178.1"> requires us to know exactly what the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">B&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.180.1"> is. </span><span class="koboSpan" id="kobo.180.2">So, if class </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">D</span></strong><span class="koboSpan" id="kobo.182.1"> has not been declared yet, how does the compiler know that the identified </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">D</span></strong><span class="koboSpan" id="kobo.184.1"> even refers to a type? </span><span class="koboSpan" id="kobo.184.2">After all, you cannot instantiate a template on a completely unknown type. </span><span class="koboSpan" id="kobo.184.3">The answer lies somewhere in between—class </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">D</span></strong><span class="koboSpan" id="kobo.186.1"> is forward-declared, the same as if we had </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
class A;
B&lt;A&gt; b; // Now does not compile</span></pre>
<p><span class="koboSpan" id="kobo.189.1">Some templates can be instantiated on forward-declared types, while others cannot. </span><span class="koboSpan" id="kobo.189.2">The exact rules can be painstakingly gathered from the standard, but the gist is this—anything that might affect the size of the class has to be fully declared. </span><span class="koboSpan" id="kobo.189.3">A reference to a type declared inside an incomplete type, such as our </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">using T = typename D::T</span></strong><span class="koboSpan" id="kobo.191.1">, would be a forward declaration of a nested class, and those are not </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">allowed either.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">On the other hand, the body of a member function of a class template is not instantiated until it’s called. </span><span class="koboSpan" id="kobo.193.2">In fact, for a given template parameter, a member function does not even have to compile, as long as it’s not called. </span><span class="koboSpan" id="kobo.193.3">Therefore, references to the derived class, its nested types, and its member functions, inside the member functions of the base class are perfectly fine. </span><span class="koboSpan" id="kobo.193.4">Also, since the derived class type is considered forward-declared inside the base class, we can declare pointers and references to it. </span><span class="koboSpan" id="kobo.193.5">Here is a very common refactoring of the CRTP base class that consolidates the uses of the static</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.194.1"> cast in </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">one place:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
template &lt;typename D&gt; class B {
  ...
</span><span class="koboSpan" id="kobo.196.2">  void f(int i) { derived()-&gt;f(i); }
  D* derived() { return static_cast&lt;D*&gt;(this); }
};
class D : public B&lt;D&gt; {
  ...
</span><span class="koboSpan" id="kobo.196.3">  void f(int i) { i_ += i; }
};</span></pre>
<p><span class="koboSpan" id="kobo.197.1">The base class declaration owns a pointer to the incomplete (forward-declared) type </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">D</span></strong><span class="koboSpan" id="kobo.199.1">. </span><span class="koboSpan" id="kobo.199.2">It works like any other pointer to an incomplete type; by the time the pointer is de-referenced, the type has to be complete. </span><span class="koboSpan" id="kobo.199.3">In our case, this happens inside the body of the member function; </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">B::f()</span></strong><span class="koboSpan" id="kobo.201.1">, which, as we discussed, is not compiled until it’s called by the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">c</span><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.203.1">lient code.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">So what do we do if we need to use a nested type of the derived class while writing the base class? </span><span class="koboSpan" id="kobo.204.2">Inside a function body, there is no problem. </span><span class="koboSpan" id="kobo.204.3">If we need to use the nested type in the base class itself, it is usually for one of two reasons. </span><span class="koboSpan" id="kobo.204.4">The first is to declare the return type of a </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
// Example 01a
template &lt;typename D&gt; class B {
  typename D::value_type get() const {
    return static_cast&lt;const D*&gt;(this)-&gt;get();
  }
  …
};
D : public B&lt;D&gt; {
  using value_type = int;
  value_type get() const { … };
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.207.1">As we </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.208.1">have just discussed, this will not compile. </span><span class="koboSpan" id="kobo.208.2">Fortunately, this problem is easy to solve, all we have to do is let the compiler deduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">return type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
// Example 01a
template &lt;typename D&gt; class B {
  auto get() const {
    return static_cast&lt;const D*&gt;(this)-&gt;get();
  }
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.211.1">The second case is more difficult: the nested type is needed to declare a data member or a parameter. </span><span class="koboSpan" id="kobo.211.2">In this case, there is only one option left: the type should be passed into the base class as an additional template parameter. </span><span class="koboSpan" id="kobo.211.3">Of course, it introduces some redundancy into the code, but it can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">be helped:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
// Example 01a
template &lt;typename T, typename value_type&gt; class B {
  value_type value_;
  …
};
class D : public B&lt;D, int&gt; {
  using value_type = int;
  value_type get() const { … }
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.214.1">Now that we </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.215.1">know what is CRTP and how to code it, let us see what design problems can be sol</span><a id="_idTextAnchor375"/><span class="koboSpan" id="kobo.216.1">ved </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">with it.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.218.1">CRTP and static polymorphism</span></h1>
<p><span class="koboSpan" id="kobo.219.1">Since CRTP </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.220.1">allows us to override base class functions with those of the derived class, it implements polymorphic behavior. </span><span class="koboSpan" id="kobo.220.2">The </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.221.1">key difference is that polymorphism happens at compile time, n</span><a id="_idTextAnchor377"/><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.222.1">ot </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">at runtime.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor379"/><span class="koboSpan" id="kobo.224.1">Compile-time polymorphism</span></h2>
<p><span class="koboSpan" id="kobo.225.1">As we </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.226.1">have just seen, CRTP can be used to </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.227.1">allow the derived class to customize the behavior of the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
template &lt;typename D&gt; class B {
  public:
  ...
</span><span class="koboSpan" id="kobo.229.2">  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f(i); }
  protected:
  int i_;
};
class D : public B&lt;D&gt; {
  public:
  void f(int i) { i_ += i; }
};</span></pre>
<p><span class="koboSpan" id="kobo.230.1">If the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">B::f()</span></strong><span class="koboSpan" id="kobo.232.1"> method is called, it dispatches the call to the derived class method for the real derived class, just like a virtual function does. </span><span class="koboSpan" id="kobo.232.2">Of course, in order to fully take advantage of this polymorphism, we have to be able to call the methods of the base class through the base class pointer. </span><span class="koboSpan" id="kobo.232.3">Without this ability, we are simply calling methods of the derived class whose type we </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">already know:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
D* d = ...; // Get an object of type D
d-&gt;f(5);
B&lt;D&gt;* b = ...; // Also has to be an object of type D
b-&gt;f(5);</span></pre>
<p><span class="koboSpan" id="kobo.235.1">Note that the</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.236.1"> function call looks exactly like any</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.237.1"> virtual function class, with the base class pointer. </span><span class="koboSpan" id="kobo.237.2">The actual function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">f()</span></strong><span class="koboSpan" id="kobo.239.1">, that is called comes from the derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">D::f()</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">There is, however, a significant difference—the actual type of the derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">D</span></strong><span class="koboSpan" id="kobo.243.1">, has to be known at compile time—the base class pointer is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">B*</span></strong><span class="koboSpan" id="kobo.245.1"> but rather </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">B&lt;D&gt;*</span></strong><span class="koboSpan" id="kobo.247.1">, which implies that the derived object is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">D</span></strong><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">There does not seem to be much point to such </span><em class="italic"><span class="koboSpan" id="kobo.250.1">polymorphism</span></em><span class="koboSpan" id="kobo.251.1"> if the programmer has to know the actual type. </span><span class="koboSpan" id="kobo.251.2">But, that is because we have not fully thought through what </span><em class="italic"><span class="koboSpan" id="kobo.252.1">compile-time polymorphism</span></em><span class="koboSpan" id="kobo.253.1"> really means. </span><span class="koboSpan" id="kobo.253.2">Just as the benefit of a virtual function is that we can call member functions of a type we don’t even know exists, the same has to be true for </span><em class="italic"><span class="koboSpan" id="kobo.254.1">static polymorphism</span></em><span class="koboSpan" id="kobo.255.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">be useful.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">How do we write a function that has to compile for parameters of an unknown type? </span><span class="koboSpan" id="kobo.257.2">With a function template, </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">of course:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
// Example 01
template &lt;typename D&gt; void apply(B&lt;D&gt;* b, int&amp; i) {
  b-&gt;f(++i);
}</span></pre>
<p><span class="koboSpan" id="kobo.260.1">This is a template function that can be called on any base class pointer, and it automatically deduces the type of the derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">D</span></strong><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">Now, we can write what looks like regular </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">polymorphic code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
B&lt;D&gt;* b = new D;    // 1
apply(b);         // 2</span></pre>
<p><span class="koboSpan" id="kobo.265.1">Note that, on line one, the object has to be constructed with the knowledge of the actual type. </span><span class="koboSpan" id="kobo.265.2">This is always the case; the same is true for regular runtime polymorphism with </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">virtual functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
void apply(B* b) { ... </span><span class="koboSpan" id="kobo.267.2">}
B* b = new D;    // 1
apply(b);        // 2</span></pre>
<p><span class="koboSpan" id="kobo.268.1">In both </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.269.1">cases, on line two, we invoke some code that was written only with the knowledg</span><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.270.1">e of the base class. </span><span class="koboSpan" id="kobo.270.2">The difference is that, with </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.271.1">run-time polymorphism, we have a common base class and some functions that operate on it. </span><span class="koboSpan" id="kobo.271.2">With CRTP and static polymorphism, there is a common base class template but no single common base class (a template is not a type) and every function that operates on this base template becomes a template itself. </span><span class="koboSpan" id="kobo.271.3">To make the symmetry (not equivalence!) between the two types of polymorphism complete, we just need to figure out two more special cases: pure virtual functions and polymorphic destruction. </span><span class="koboSpan" id="kobo.271.4">Let’s st</span><a id="_idTextAnchor381"/><span class="koboSpan" id="kobo.272.1">art with </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">the former.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.274.1">The compile-time pure virtual function</span></h2>
<p><span class="koboSpan" id="kobo.275.1">What would </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.276.1">be the equivalent of the pure virtual function in the CRTP scenario? </span><span class="koboSpan" id="kobo.276.2">A pure virtual function must be</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.277.1"> implemented in all derived classes. </span><span class="koboSpan" id="kobo.277.2">A class that declares a pure virtual function, or inherits one and does not override it, is an abstract class; it can be further derived from, but it cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">be instantiated.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">When we contemplate the equivalent of a pure virtual function for static polymorphism, we realize that our CRTP implementation suffers from a major vulnerability. </span><span class="koboSpan" id="kobo.279.2">What happens if we forget to override the </span><em class="italic"><span class="koboSpan" id="kobo.280.1">compile-time virtual function,</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.281.1">f()</span></strong><span class="koboSpan" id="kobo.282.1">, in one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">derived classes?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
// Example 02
template &lt;typename D&gt; class B {
  public:
  ...
</span><span class="koboSpan" id="kobo.284.2">  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f(i); }
};
class D : public B&lt;D&gt; {
  // no f() here!
</span><span class="koboSpan" id="kobo.284.3">};
...
</span><span class="koboSpan" id="kobo.284.4">B&lt;D&gt;* b = ...;
b-&gt;f(5); // 1</span></pre>
<p><span class="koboSpan" id="kobo.285.1">This</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.286.1"> code compiles with no errors or warnings—on line one, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">B::f()</span></strong><span class="koboSpan" id="kobo.288.1">, which, in turn, calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">D::f()</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">Class </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">D</span></strong><span class="koboSpan" id="kobo.292.1"> does not declare its own version of the member </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">f()</span></strong><span class="koboSpan" id="kobo.294.1">, so the one inherited from the base class is the one that is called. </span><span class="koboSpan" id="kobo.294.2">That is, of course, the member function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">B::f()</span></strong><span class="koboSpan" id="kobo.296.1">, that we have already seen, which again calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">D::f()</span></strong><span class="koboSpan" id="kobo.298.1">, which is really </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">B::f()</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.300.1">...</span></strong><span class="koboSpan" id="kobo.301.1"> and we have an </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">infinite loop.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">The problem here</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.304.1"> is that nothing requires us to override the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">f()</span></strong><span class="koboSpan" id="kobo.306.1"> in the derived class, but the program is malformed if we don’t. </span><span class="koboSpan" id="kobo.306.2">The root of the problem is that we are mixing together the interface and the implementation—the public member function declaration in the base class says that all derived classes must have a function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">void f(int)</span></strong><span class="koboSpan" id="kobo.308.1">, as a part of their public interface. </span><span class="koboSpan" id="kobo.308.2">The derived class’s version of the same function provides the actual implementation. </span><span class="koboSpan" id="kobo.308.3">We will cover separating the interface and the implementation in </span><a href="B19262_14.xhtml#_idTextAnchor640"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.309.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.310.1">, </span><em class="italic"><span class="koboSpan" id="kobo.311.1">The Template Method Pattern and the Non-Virtual Idiom</span></em><span class="koboSpan" id="kobo.312.1">, but for now, suffice it to say that our life would be a lot easier if these functions had </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">different names:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
// Example 03
template &lt;typename D&gt; class B {
  public:
  ...
</span><span class="koboSpan" id="kobo.314.2">  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f_impl(i); }
};
class D : public B&lt;D&gt; {
  void f_impl(int i) { i_ += i; }
};
...
</span><span class="koboSpan" id="kobo.314.3">B&lt;D&gt;* b = ...;
b-&gt;f(5);</span></pre>
<p><span class="koboSpan" id="kobo.315.1">What happens now if we forget to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">D::f_impl()</span></strong><span class="koboSpan" id="kobo.317.1">? </span><span class="koboSpan" id="kobo.317.2">The code does not compile, because</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.318.1"> there is no such member function in class </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">D</span></strong><span class="koboSpan" id="kobo.320.1">, either directly or through inheritance. </span><span class="koboSpan" id="kobo.320.2">So, we have implemented a compile-time pure virtual function! </span><span class="koboSpan" id="kobo.320.3">Note that the virtual function is actually </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">f_impl()</span></strong><span class="koboSpan" id="kobo.322.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">f()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">With that </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.327.1">accomplished, how would we implement a regular virtual function, with a default implementation that can be optionally overridden? </span><span class="koboSpan" id="kobo.327.2">If we follow the same pattern of separating the interface and the implementation, we only have to provide the default implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">B::f_impl()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
// Example 03
template &lt;typename D&gt; class B {
  public:
  ...
</span><span class="koboSpan" id="kobo.331.2">  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f_impl(i); }
  void f_impl(int i) {}
};
class D1 : public B&lt;D1&gt; {
  void f_impl(int i) { i_ += i; }
};
class D2 : public B&lt;D2&gt; {
  // No f() here
};
...
</span><span class="koboSpan" id="kobo.331.3">B&lt;D1&gt;* b = ...;
b-&gt;f(5); // Calls D1::f_impl()
B&lt;D2&gt;* b1 = ...;
b1-&gt;f(5); // C</span><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.332.1">a</span><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.333.1">lls B::f_impl() by default</span></pre>
<p><span class="koboSpan" id="kobo.334.1">The last special </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.335.1">case we need to </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.336.1">cover is </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">polymorphic destruction.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor385"/><span class="koboSpan" id="kobo.338.1">Destructors and polymorphic deletion</span></h2>
<p><span class="koboSpan" id="kobo.339.1">So far, we have willfully avoided tackling the issue of </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.340.1">deleting objects implemented with CRTP in some sort of polymorphic fashion. </span><span class="koboSpan" id="kobo.340.2">In fact, if you go back and reread the examples that presented complete code, such as the benchmark fixture, </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">BM_static</span></strong><span class="koboSpan" id="kobo.342.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.343.1">Introducing CRTP</span></em><span class="koboSpan" id="kobo.344.1"> section, we either avoided deleting the object altogether or constructed a derived object on the stack. </span><span class="koboSpan" id="kobo.344.2">This is because polymorphic deletion presents an additional complication that we are finally ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">deal with.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">First of all, let’s note that, in many cases, polymorphic deletion</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.347.1"> is not a concern. </span><span class="koboSpan" id="kobo.347.2">All objects are created with their actual types known. </span><span class="koboSpan" id="kobo.347.3">If the code that constructs the objects also owns and eventually deletes them, the question </span><em class="italic"><span class="koboSpan" id="kobo.348.1">what is the type of the deleted object?</span></em><span class="koboSpan" id="kobo.349.1"> is never really asked. </span><span class="koboSpan" id="kobo.349.2">Similarly, if the objects are stored in a container, they are not deleted through the base class pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">or reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
template &lt;typename D&gt; void apply(B&lt;D&gt;&amp; b) {
  ... </span><span class="koboSpan" id="kobo.351.2">operate on b ...
</span><span class="koboSpan" id="kobo.351.3">}
{
  std::vector&lt;D&gt; v;
  v.push_back(D(...)); // Objects created as D
  ...
</span><span class="koboSpan" id="kobo.351.4">  apply(v[0]); // Objects processed as B&amp;
} // Objects deleted as D</span></pre>
<p><span class="koboSpan" id="kobo.352.1">In many cases, as </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.353.1">shown in the preceding example, the objects are constructed and deleted with their actual type known and no </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.354.1">polymorphism involved, but the code that works on them in between is universal, written to work on the base type and, therefore, any class derived from that </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">base type.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">But, what if we need to actually delete the object through the base class pointer? </span><span class="koboSpan" id="kobo.356.2">Well, that is not easy. </span><span class="koboSpan" id="kobo.356.3">First of all, a simple call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">delete</span></strong><span class="koboSpan" id="kobo.358.1"> operator will do the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">wrong thing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
B&lt;D&gt;* b = new D;
...
</span><span class="koboSpan" id="kobo.360.2">delete b;</span></pre>
<p><span class="koboSpan" id="kobo.361.1">This code compiles. </span><span class="koboSpan" id="kobo.361.2">Worse, even the compilers that normally warn when a class has a virtual function but a non-virtual destructor do not generate any warnings in this case, because there are no virtual functions, and CRTP polymorphism is not recognized by the compiler as a potential source of trouble. </span><span class="koboSpan" id="kobo.361.3">However, the trouble there is that only the destructor of the base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">B&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.363.1">, itself is called; the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">D</span></strong><span class="koboSpan" id="kobo.365.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">never called!</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">You may be tempted to resolve this problem the same way as we deal with other </span><em class="italic"><span class="koboSpan" id="kobo.368.1">compile-time virtual</span></em><span class="koboSpan" id="kobo.369.1"> functions, by casting to the known derived type and calling the indented member function of the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">derived class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
template &lt;typename D&gt; class B {
  public:
  ~B() { static_cast&lt;D*&gt;(this)-&gt;~D(); }
};</span></pre>
<p><span class="koboSpan" id="kobo.372.1">Unlike the regular functions, this attempt at polymorphism is badly broken, for not one but two reasons—first of all, in the destructor of the base class, the actual object is not of the derived type anymore, and calling any member functions of the derived class on it results in undefined behavior. </span><span class="koboSpan" id="kobo.372.2">Secondly, even if this somehow worked, the destructor of the derived class is going to do its work and then call the destructor of the base class, which results in an </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">infinite loop.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">There are two solutions to this problem. </span><span class="koboSpan" id="kobo.374.2">One option is to extend the compile-time polymorphism to the act of deletion in the same way as we do for any other operation, with a </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">function template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
template &lt;typename D&gt; void destroy(B&lt;D&gt;* b) {
  delete static_cast&lt;D*&gt;(b);
}</span></pre>
<p><span class="koboSpan" id="kobo.377.1">This is </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.378.1">well-defined. </span><span class="koboSpan" id="kobo.378.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">delete</span></strong><span class="koboSpan" id="kobo.380.1"> operator is called on the pointer of the actual type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">D</span></strong><span class="koboSpan" id="kobo.382.1">, and the right destructor is called. </span><span class="koboSpan" id="kobo.382.2">However, you must </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.383.1">take care to always delete these objects using this </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">destroy()</span></strong><span class="koboSpan" id="kobo.385.1"> function, instead of calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">delete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1"> operator.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">The second option is to actually make the destructor virtual. </span><span class="koboSpan" id="kobo.388.2">This does bring back the overhead of the virtual function call, but only for the destructor. </span><span class="koboSpan" id="kobo.388.3">It also increases the object size by the size of the virtual pointer. </span><span class="koboSpan" id="kobo.388.4">If neither of these two sources of overhead is a concern, you could use this hybrid static-dynamic polymorphism, where all virtual function calls are bound at compile time and with </span><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.389.1">n</span><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.390.1">o overhead, except </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the destructor.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.392.1">CRTP and access control</span></h2>
<p><span class="koboSpan" id="kobo.393.1">When</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.394.1"> implementing CRTP classes, you do have to worry about access—any method you want to call has to be accessible. </span><span class="koboSpan" id="kobo.394.2">Either the method has to be public, or the caller has to have special access. </span><span class="koboSpan" id="kobo.394.3">This is a little different from the way virtual functions are called—when calling a virtual function, the caller must have access to the member function that is named in the call. </span><span class="koboSpan" id="kobo.394.4">For example, a call to the base class function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">B::f()</span></strong><span class="koboSpan" id="kobo.396.1">, requires that either </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">B::f()</span></strong><span class="koboSpan" id="kobo.398.1"> is public or the caller has access to non-public member functions (another member function of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">B</span></strong><span class="koboSpan" id="kobo.400.1"> can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">B::f()</span></strong><span class="koboSpan" id="kobo.402.1"> even if it’s private). </span><span class="koboSpan" id="kobo.402.2">Then, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">B::f()</span></strong><span class="koboSpan" id="kobo.404.1"> is virtual and overridden by the derived class </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">D</span></strong><span class="koboSpan" id="kobo.406.1">, the override </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">D::f()</span></strong><span class="koboSpan" id="kobo.408.1"> is actually </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.409.1">called at </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">runtime</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">There is no requirement that </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">D::f()</span></strong><span class="koboSpan" id="kobo.413.1"> be accessible from the original call site; for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">D::f()</span></strong><span class="koboSpan" id="kobo.415.1"> can </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">be private.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">The situation with CRTP polymorphic calls is somewhat different. </span><span class="koboSpan" id="kobo.417.2">All calls are explicit in the code, and the callers must have access to the functions they call. </span><span class="koboSpan" id="kobo.417.3">Usually, it means that the base class must have access to the member functions of the derived class. </span><span class="koboSpan" id="kobo.417.4">Consider the following example from an earlier section, but now with explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">access control:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
template &lt;typename D&gt; class B {
  public:
  ...
</span><span class="koboSpan" id="kobo.419.2">  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f_impl(i); }
  private:
  void f_impl(int i) {}
};
class D : public B&lt;D&gt; {
  private:
  void f_impl(int i) { i_ += i; }
  friend class B&lt;D&gt;;
};</span></pre>
<p><span class="koboSpan" id="kobo.420.1">Here, both</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.421.1"> functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">B::f_impl()</span></strong><span class="koboSpan" id="kobo.423.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">D::f_impl()</span></strong><span class="koboSpan" id="kobo.425.1">, are private in their respective classes. </span><span class="koboSpan" id="kobo.425.2">The base class has no special access to the derived class, and cannot call its private member functions. </span><span class="koboSpan" id="kobo.425.3">Unless we want to change the member function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">D::f_impl()</span></strong><span class="koboSpan" id="kobo.427.1">, from private to public and allow any caller access to it, we have to declare the base class to be a friend of the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">derived class.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">There is also some benefit in doing the reverse. </span><span class="koboSpan" id="kobo.429.2">Let’s create a new derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">D1</span></strong><span class="koboSpan" id="kobo.431.1">, with a different override of the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">function, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">f_impl()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
class D1 : public B&lt;D&gt; {
  private:
  void f_impl(int i) { i_ -= i; }
  friend class B&lt;D1&gt;;
};</span></pre>
<p><span class="koboSpan" id="kobo.436.1">This class has a subtle error—it is not actually derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">B&lt;D1&gt;</span></strong><span class="koboSpan" id="kobo.438.1"> but from the old class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">B&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.440.1">; a mistake that is easy to make when creating a new class from an old template. </span><span class="koboSpan" id="kobo.440.2">This mistake will be found if we attempt to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">class polymorphically:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
B&lt;D1&gt;* b = new D1;</span></pre>
<p><span class="koboSpan" id="kobo.443.1">This does not </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.444.1">compile because </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">B&lt;D1&gt;</span></strong><span class="koboSpan" id="kobo.446.1"> is not a base class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">D1</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">However, not all uses of CRTP involve a polymorphic call. </span><span class="koboSpan" id="kobo.448.3">In any case, it would be better if the error was caught when class </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">D1</span></strong><span class="koboSpan" id="kobo.450.1"> was first declared. </span><span class="koboSpan" id="kobo.450.2">We can accomplish that by making class </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">B</span></strong><span class="koboSpan" id="kobo.452.1"> into a sort of abstract class, only in the sense of static polymorphism. </span><span class="koboSpan" id="kobo.452.2">All it takes is to make the constructor of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">B</span></strong><span class="koboSpan" id="kobo.454.1"> private and to declare the derived class to be </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">a friend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
template &lt;typename D&gt; class B {
  int i_;
  B() : i_(0) {}
  friend D;
  public:
  void f(int i) { static_cast&lt;D*&gt;(this)-&gt;f_impl(i); }
  private:
  void f_impl(int i) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.457.1">Note the somewhat unusual form of the friend declaration—</span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">friend D</span></strong><span class="koboSpan" id="kobo.459.1"> and not </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">friend class D</span></strong><span class="koboSpan" id="kobo.461.1">. </span><span class="koboSpan" id="kobo.461.2">This is how you write a friend declaration for the template parameter. </span><span class="koboSpan" id="kobo.461.3">Now, the only type that can construct an instance of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">B&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.463.1"> is that specific derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">D</span></strong><span class="koboSpan" id="kobo.465.1">, which is used as the template parameter, and the erroneous code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">class D1 : pu</span><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.467.1">blic B&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.468.1">, does not compile </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">any longer.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">Now that we know how CRTP wor</span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.471.1">ks, let us see what it is </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">useful for.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.473.1">CRTP as a delegation pattern</span></h1>
<p><span class="koboSpan" id="kobo.474.1">So far, we</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.475.1"> have used</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.476.1"> CRTP as a compile-time equivalent of dynamic polymorphism, including virtual-like calls through the base pointer (compile-time, of course, with a template function). </span><span class="koboSpan" id="kobo.476.2">This is not the only way CRTP can be used. </span><span class="koboSpan" id="kobo.476.3">In fact, more often than not, the function is called directly on the derived class. </span><span class="koboSpan" id="kobo.476.4">This is a very fundamental difference—typically, public inheritance expresses the </span><em class="italic"><span class="koboSpan" id="kobo.477.1">is-a</span></em><span class="koboSpan" id="kobo.478.1"> relationship—the derived object is a kind of a base object. </span><span class="koboSpan" id="kobo.478.2">The interface and the generic code are in the base class, while the derived class overrides the specific implementation. </span><span class="koboSpan" id="kobo.478.3">This relation </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.479.1">continues to hold when a CRTP object is accessed through the base class pointer or reference. </span><span class="koboSpan" id="kobo.479.2">Such use of</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.480.1"> CRTP is sometimes also called a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.481.1">static interface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">When the derived object is used directly, the situation is quite different—the base class is no longer the interface, and the derived class is not just the implementation. </span><span class="koboSpan" id="kobo.483.2">The derived class expands the interface of the base class, and the base class delegates</span><a id="_idTextAnchor392"/> <a id="_idTextAnchor393"/><span class="koboSpan" id="kobo.484.1">some of its behavior to the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">derived class.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor394"/><span class="koboSpan" id="kobo.486.1">Expanding the interface</span></h2>
<p><span class="koboSpan" id="kobo.487.1">Let’s </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.488.1">consider several examples where CRTP is used to delegate behavior from the base class to the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">derived one.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">The first example is a very simple one—for any class that provides </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">operator+=()</span></strong><span class="koboSpan" id="kobo.492.1">, we want to generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">operator+()</span></strong><span class="koboSpan" id="kobo.494.1"> automatically that used </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the former:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
// Example 04
template &lt;typename D&gt; struct plus_base {
  D operator+(const D&amp; rhs) const {
    D tmp = rhs;
    tmp += static_cast&lt;const D&amp;&gt;(*this);
    return tmp;
  }
};
class D : public plus_base&lt;D&gt; {
  int i_;
  public:
  explicit D(int i) : i_(i) {}
  D&amp; operator+=(const D&amp; rhs) {
    i_ += rhs.i_;
    return *this;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.497.1">Any</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.498.1"> class that inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">plus_base</span></strong><span class="koboSpan" id="kobo.500.1"> in this manner automatically acquires the addition operator that is guaranteed to match the provided increment operator. </span><span class="koboSpan" id="kobo.500.2">The observant among you might point out that the way we have declared the operator </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">+</span></strong><span class="koboSpan" id="kobo.502.1"> here is, well, strange. </span><span class="koboSpan" id="kobo.502.2">Aren’t two-argument operators supposed to be non-member functions? </span><span class="koboSpan" id="kobo.502.3">Indeed, they usually are. </span><span class="koboSpan" id="kobo.502.4">Nothing in the standard requires them to be, and the preceding code is technically valid. </span><span class="koboSpan" id="kobo.502.5">The reason binary operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">==</span></strong><span class="koboSpan" id="kobo.504.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">+</span></strong><span class="koboSpan" id="kobo.506.1">, and so on are usually declared as non-member functions has to do with implicit conversions—if we have an addition, </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">x + y</span></strong><span class="koboSpan" id="kobo.508.1">, and the intended </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">operator+</span></strong><span class="koboSpan" id="kobo.510.1"> is a member function, it has to be a member function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">x</span></strong><span class="koboSpan" id="kobo.512.1"> object. </span><span class="koboSpan" id="kobo.512.2">Not any object implicitly convertible to the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">x</span></strong><span class="koboSpan" id="kobo.514.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">x</span></strong><span class="koboSpan" id="kobo.516.1"> itself—it’s a member function call on </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">x</span></strong><span class="koboSpan" id="kobo.518.1">. </span><span class="koboSpan" id="kobo.518.2">In contrast, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">y</span></strong><span class="koboSpan" id="kobo.520.1"> object has to be implicitly convertible to the type of the argument of that member </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">operator+</span></strong><span class="koboSpan" id="kobo.522.1"> usually, the same type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">x</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">To restore the symmetry and allow implicit conversions (if any are provided) on both the left- and right-hand side of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">+</span></strong><span class="koboSpan" id="kobo.526.1"> sign, we have to declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">operator+</span></strong><span class="koboSpan" id="kobo.528.1"> as a non-member function. </span><span class="koboSpan" id="kobo.528.2">Usually, such a function needs to have access to the private data members of the class, as in the example previously, so it has to be declared a friend. </span><span class="koboSpan" id="kobo.528.3">Putting all of this together, we arrive at this </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">alternative implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
// Example 05
template &lt;typename D&gt; struct plus_base {
  friend D operator+(const D&amp; lhs, const D&amp; rhs) {
    D tmp = lhs;
    tmp += rhs;
    return tmp;
  }
};
class D : public plus_base&lt;D&gt; {
  int i_;
  public:
  explicit D(int i) : i_(i) {}
  D&amp; operator+=(const D&amp; rhs) {
    i_ += rhs.i_;
    return *this;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.531.1">There is </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.532.1">a significant difference between this use of CRTP and the one we saw earlier—the object that is going to be used in the program is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">C</span></strong><span class="koboSpan" id="kobo.534.1">, and it will never be accessed through a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">plus_base&lt;C&gt;</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">The latter isn’t a complete interface for anything but is really an implementation that makes use of the interface provided by the derived class. </span><span class="koboSpan" id="kobo.536.3">CRTP here is used as an implementation technique, not as a design pattern. </span><span class="koboSpan" id="kobo.536.4">However, the boundary between the two is not always clear: some implementation techniques are so powerful that they can alter </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">design choices.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">One example is the generated comparison and ordering operations. </span><span class="koboSpan" id="kobo.538.2">In C++20, the recommended choice for designing interfaces of value types (or any other comparable and ordered types) is to provide only two operators, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">operator==()</span></strong><span class="koboSpan" id="kobo.540.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">operator&lt;=&gt;()</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">The compiler will generate the rest. </span><span class="koboSpan" id="kobo.542.3">If you like this approach to interface design and want to use it in earlier versions of C++, you need a way to implement it. </span><span class="koboSpan" id="kobo.542.4">CRTP offers us a possible implementation. </span><span class="koboSpan" id="kobo.542.5">We will need a base class that will generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">operator!=()</span></strong><span class="koboSpan" id="kobo.544.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">operator==()</span></strong><span class="koboSpan" id="kobo.546.1"> of the derived class. </span><span class="koboSpan" id="kobo.546.2">It will also generate all ordering operators; of course, we cannot use </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">operator&lt;=&gt;()</span></strong><span class="koboSpan" id="kobo.548.1"> before C++20, but we can use any member function name we agree on, such </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">cmp()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
template &lt;typename D&gt; struct compare_base {
  friend bool operator!=(const D&amp; lhs, const D&amp; rhs) {
    return !(lhs == rhs); }
  friend bool operator&lt;=(const D&amp; lhs, const D&amp; rhs) {
    return lhs.cmp(rhs) &lt;= 0;
  }
  friend bool operator&gt;=(const D&amp; lhs, const D&amp; rhs) {
    return lhs.cmp(rhs) &gt;= 0;
  }
  friend bool operator&lt; (const D&amp; lhs, const D&amp; rhs) {
    return lhs.cmp(rhs) &lt;  0;
  }
  friend bool operator&gt; (const D&amp; lhs, const D&amp; rhs) {
    return lhs.cmp(rhs) &gt;  0;
  }
};
class D : public compare_base&lt;D&gt; {
  int i_;
  public:
  explicit D(int i) : i_(i) {}
  auto cmp(const D&amp; rhs) const {
    return (i_ &lt; rhs.i_) ? </span><span class="koboSpan" id="kobo.552.2">-1 : ((i_ &gt; rhs.i_) ? </span><span class="koboSpan" id="kobo.552.3">1 : 0);
  }
  bool operator==(const D&amp; rhs) const {
    return i_ == rhs.i_;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.553.1">There are many such examples to be found in the literature on CRTP. </span><span class="koboSpan" id="kobo.553.2">Along with these examples, you can find discussions on whether C++20 concepts offer a better alternative. </span><span class="koboSpan" id="kobo.553.3">The next section explains what this </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">is about.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.555.1">CRTP and concepts</span></h2>
<p><span class="koboSpan" id="kobo.556.1">At the first glance, it</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.557.1"> is unclear how concepts could replace CRTP. </span><span class="koboSpan" id="kobo.557.2">Concepts (which you can read more about in </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.558.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.559.1">, </span><em class="italic"><span class="koboSpan" id="kobo.560.1">SFINAE, Concepts, and Overload Resolution Management</span></em><span class="koboSpan" id="kobo.561.1">) are all about restricting interfaces, while CRTP extends </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">the interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">There are discussions inspired by cases where both concepts and CRTP can solve the same problem by totally different means. </span><span class="koboSpan" id="kobo.563.2">Recall our use of CRTP to automatically generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">operator+()</span></strong><span class="koboSpan" id="kobo.565.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">operator+=()</span></strong><span class="koboSpan" id="kobo.567.1">; all we had to do was to inherit from the special base </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">class template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
// Example 05
template &lt;typename D&gt; struct plus_base {
  friend D operator+(const D&amp; lhs, const D&amp; rhs) { … }
};
class D : public plus_base&lt;D&gt; {
  D&amp; operator+=(const D&amp; rhs) { … }
};</span></pre>
<p><span class="koboSpan" id="kobo.570.1">Our base class serves two purposes. </span><span class="koboSpan" id="kobo.570.2">First, it generates </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">operator+()</span></strong><span class="koboSpan" id="kobo.572.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">operator+=()</span></strong><span class="koboSpan" id="kobo.574.1">. </span><span class="koboSpan" id="kobo.574.2">Second, it provides a mechanism for classes to opt into this automation: to receive the generated </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">operator+()</span></strong><span class="koboSpan" id="kobo.576.1">, a class must inherit </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">plus_base</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">The first problem by itself is easy to solve, we can just define a global </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">operator+()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.582.1"> template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
template &lt;typename T&gt;
T operator+(const T&amp; lhs, const T&amp; rhs) {
  T tmp = lhs;
  tmp += rhs;
  return tmp;
}</span></pre>
<p><span class="koboSpan" id="kobo.584.1">There</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.585.1"> is a “slight” problem with this template: we just provided a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">operator+()</span></strong><span class="koboSpan" id="kobo.587.1"> for every type in our program, whether it needs one or not. </span><span class="koboSpan" id="kobo.587.2">Furthermore, most of the time it won’t even compile since not all classes </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">define </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">operator+=()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">This is where the concepts come in: we can restrict the applicability of our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">operator+()</span></strong><span class="koboSpan" id="kobo.593.1"> so, in the end, it is generated for the same types that we would have otherwise inherited from </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">plus_base</span></strong><span class="koboSpan" id="kobo.595.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">no other.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">One way to do this is to require that the template parameter type T at least have the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">increment operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
template &lt;typename T&gt;
requires( requires(T a, T b) { a += b; } )
T operator+(const T&amp; lhs, const T&amp; rhs) { … }</span></pre>
<p><span class="koboSpan" id="kobo.600.1">However, this is not the same result as what we got with CRTP. </span><span class="koboSpan" id="kobo.600.2">In some cases, it may be a better result: instead of having to opt every class into the automatic generation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">operator+()</span></strong><span class="koboSpan" id="kobo.602.1">, we did it for every class that satisfies certain restrictions. </span><span class="koboSpan" id="kobo.602.2">But in other cases, any reasonable description of these restrictions produces overly broad results, and we have to opt into our types one by one. </span><span class="koboSpan" id="kobo.602.3">This is easy to do with concepts as well, but the technique used is not widely known. </span><span class="koboSpan" id="kobo.602.4">All you need to do is to define a concept whose general case is false (a Boolean variable </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">will suffice):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
template &lt;typename T&gt;
constexpr inline bool gen_plus = false; // General
template &lt;typename T&gt;
requires gen_plus&lt;T&gt;
T operator+(const T&amp; lhs, const T&amp; rhs) { … }</span></pre>
<p><span class="koboSpan" id="kobo.605.1">Then, for every type that needs to opt in, we specialize </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">the concept:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
class D { // No special base
  D&amp; operator+=(const D&amp; rhs) { … }
};
template &lt;&gt;
constexpr inline bool generate_plus&lt;D&gt; = true; // Opt-in</span></pre>
<p><span class="koboSpan" id="kobo.608.1">There are </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.609.1">some advantages to both approaches: CRTP uses a base class that can be more complex than just a wrapper for a definition of an operator; while concepts can combine explicit opt-in with some more general restrictions when appropriate. </span><span class="koboSpan" id="kobo.609.2">However, these discussions miss a much more important distinction: CRTP can be used to expand class interface with both member and non-member functions, while concepts can be used only with non-member functions, including non-member operators. </span><span class="koboSpan" id="kobo.609.3">When both concepts and CRTP-based solutions are applicable, you should choose the most appropriate one (for simple functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">operator+()</span></strong><span class="koboSpan" id="kobo.611.1">, concepts are probably easier to read). </span><span class="koboSpan" id="kobo.611.2">Also, you don’t have to wait until C++20 to use the concept-based restrictions: the methods of emulating concepts shown in </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.612.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.613.1">, </span><em class="italic"><span class="koboSpan" id="kobo.614.1">SFINAE, Concepts, and Overload Resolution Management</span></em><span class="koboSpan" id="kobo.615.1">, are more than </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">adequate here.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">Of course, we can use concepts with CRTP instead of trying to replace CRTP: if the CRTP base class template has some requirements on the type we want to derive from it, we can enforce these with concepts. </span><span class="koboSpan" id="kobo.617.2">The use of concepts here is no different from what we find in the chapter dedicated to them. </span><span class="koboSpan" id="kobo.617.3">But we are going to stay with CRTP and what else can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">with it.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor396"/><span class="koboSpan" id="kobo.619.1">CRTP as an implementation technique</span></h1>
<p><span class="koboSpan" id="kobo.620.1">As we pointed </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.621.1">out earlier, CRTP is </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.622.1">often used as a purely implementation pattern; however, even in this role, it can influence design: some design choices are desirable but hard to implement, and, if a good implementation technique comes along, the design choices often change. </span><span class="koboSpan" id="kobo.622.2">So, let us see what problems can be solved </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">with CRTP.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.624.1">CRTP for code reuse</span></h2>
<p><span class="koboSpan" id="kobo.625.1">Let us </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.626.1">start with a specific implementation issue: we have multiple classes that have some common code. </span><span class="koboSpan" id="kobo.626.2">Ordinarily, we would write a base class for them. </span><span class="koboSpan" id="kobo.626.3">But the common code is not really common: it does the same thing for all classes except it for the types it uses. </span><span class="koboSpan" id="kobo.626.4">What we need is not a common base class but a common base class template. </span><span class="koboSpan" id="kobo.626.5">And that brings us </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">to CRTP.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">An example is an object registry. </span><span class="koboSpan" id="kobo.628.2">It may be desirable, often for debugging purposes, to know how many objects of a certain type are currently in existence, and perhaps even to maintain a list of such objects. </span><span class="koboSpan" id="kobo.628.3">We definitely do not want to instrument every class with the registry mechanism, so we want to move it to the base class. </span><span class="koboSpan" id="kobo.628.4">But, now we have a problem—if we have two derived classes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">C</span></strong><span class="koboSpan" id="kobo.630.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">D</span></strong><span class="koboSpan" id="kobo.632.1">, both inherit from the same base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">B</span></strong><span class="koboSpan" id="kobo.634.1">, and the count of instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">B</span></strong><span class="koboSpan" id="kobo.636.1"> will be the total for both </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">C</span></strong><span class="koboSpan" id="kobo.638.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">D</span></strong><span class="koboSpan" id="kobo.640.1">. </span><span class="koboSpan" id="kobo.640.2">The problem is not that the base class can’t determine what the real type of the derived class is—it can, if we’re willing to pay the cost of runtime polymorphism. </span><span class="koboSpan" id="kobo.640.3">The problem is that the base class has only one counter (or however many are coded in the class), while the number of different derived classes is unlimited. </span><span class="koboSpan" id="kobo.640.4">We could implement a very complex, expensive, and non-portable solution that uses </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">Run-Time Type Information</span></strong><span class="koboSpan" id="kobo.642.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.643.1">RTTI</span></strong><span class="koboSpan" id="kobo.644.1">), such</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.645.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">typeid</span></strong><span class="koboSpan" id="kobo.647.1">, to determine the class name and maintain a map of names and counters. </span><span class="koboSpan" id="kobo.647.2">But, what we really need is one counter per derived type, and the only way to do it is to make the base class aware of the derived class type at compile time. </span><span class="koboSpan" id="kobo.647.3">This brings us back </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">to CRTP:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
// Example 08
template &lt;typename D&gt; class registry {
  public:
  static size_t count;
  static D* head;
  D* prev;
  D* next;
  protected:
  registry() {
    ++count;
    prev = nullptr;
    next = head;
    head = static_cast&lt;D*&gt;(this);
    if (next) next-&gt;prev = head;
  }
  registry(const registry&amp;) {
    ++count;
    prev = nullptr;
    next = head;
    head = static_cast&lt;D*&gt;(this);
    if (next) next-&gt;prev = head;
  }
  ~registry() {
    --count;
    if (prev) prev-&gt;next = next;
    if (next) next-&gt;prev = prev;
    if (head == this) head = next;
  }
};
template &lt;typename D&gt; size_t registry&lt;D&gt;::count(0);
template &lt;typename D&gt; D* registry&lt;D&gt;::head(nullptr);</span></pre>
<p><span class="koboSpan" id="kobo.650.1">We have </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.651.1">declared the constructor and the destructor protected because we don’t want any registry objects created, except by the derived classes. </span><span class="koboSpan" id="kobo.651.2">It is also important to not forget the copy constructor, otherwise, the default one is generated by the compiler, and it does not increment the counter or update the list (but the destructor does, so the counter will go negative and overflow). </span><span class="koboSpan" id="kobo.651.3">For each derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">D</span></strong><span class="koboSpan" id="kobo.653.1">, the base class is </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">registry&lt;D&gt;</span></strong><span class="koboSpan" id="kobo.655.1">, which is a separate type with its own static data members, </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">count</span></strong><span class="koboSpan" id="kobo.657.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">head</span></strong><span class="koboSpan" id="kobo.659.1"> (the latter is the head </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.660.1">of the list of currently active objects). </span><span class="koboSpan" id="kobo.660.2">Any type that needs to maintain the runtime registry of active objects now only needs to inherit </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">registry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
// Example 08
class C : public registry&lt;C&gt; {
  int i_;
  public:
  C(int i) : i_(i) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.665.1">A similar example, where the base class needs to know the type of the derived class and use it to declare its own members, can be found in </span><a href="B19262_09.xhtml#_idTextAnchor406"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.666.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.667.1">, </span><em class="italic"><span class="koboSpan" id="kobo.668.1">Named Arguments, Method Chaining, and Builder Pattern</span></em><span class="koboSpan" id="kobo.669.1">. </span><span class="koboSpan" id="kobo.669.2">Next, we will see another example of CRTP, and this time the availability of the implementation opens the door to a particular </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">design choice.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor398"/><span class="koboSpan" id="kobo.671.1">CRTP for generic interfaces</span></h2>
<p><span class="koboSpan" id="kobo.672.1">Another </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.673.1">scenario where it is often necessary to delegate behavior to derived classes is the problem of visitation. </span><span class="koboSpan" id="kobo.673.2">Visitors, in a general sense, are objects that are invoked to process a collection of data objects and execute a function on each one in turn. </span><span class="koboSpan" id="kobo.673.3">Often, there are hierarchies of visitors, where the derived classes customize or alter some aspect of the behavior of the base classes. </span><span class="koboSpan" id="kobo.673.4">While the most common implementation of visitors uses dynamic polymorphism and virtual function calls, a static visitor offers the same sort of performance benefits we saw earlier. </span><span class="koboSpan" id="kobo.673.5">Visitors are not usually invoked polymorphically; you create the visitor you want and run it. </span><span class="koboSpan" id="kobo.673.6">The base visitor class, however, does call the member functions that may be dispatched, at compile time, to the derived classes if they have the right overrides. </span><span class="koboSpan" id="kobo.673.7">Consider this generic visitor for a collection </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">of animals:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.675.1">
// Example 09
struct Animal {
  public:
  enum Type { CAT, DOG, RAT };
  Animal(Type t, const char* n) : type(t), name(n) {}
  const Type type;
  const char* const name;
};
template &lt;typename D&gt; class GenericVisitor {
  public:
  template &lt;typename it&gt; void visit(it from, it to) {
    for (it i = from; i != to; ++i) {
      this-&gt;visit(*i);
    }
  }
  private:
  D&amp; derived() { return *static_cast&lt;D*&gt;(this); }
  void visit(const Animal&amp; animal) {
    switch (animal.type) {
      case Animal::CAT:
        derived().visit_cat(animal); break;
      case Animal::DOG:
        derived().visit_dog(animal); break;
      case Animal::RAT:
        derived().visit_rat(animal); break;
    }
  }
  void visit_cat(const Animal&amp; animal) {
    cout &lt;&lt; "Feed the cat " &lt;&lt; animal.name &lt;&lt; endl;
  }
  void visit_dog(const Animal&amp; animal) {
    cout &lt;&lt; "Wash the dog " &lt;&lt; animal.name &lt;&lt; endl;
  }
  void visit_rat(const Animal&amp; animal) {
  cout &lt;&lt; "Eeek!" </span><span class="koboSpan" id="kobo.675.2">&lt;&lt; endl;
}
  friend D;
  GenericVisitor() = default;
};</span></pre>
<p><span class="koboSpan" id="kobo.676.1">Note that</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.677.1"> the main visitation method is a template member function (a template within a template!), and it accepts any kind of iterator that can iterate over a sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Animal</span></strong><span class="koboSpan" id="kobo.679.1"> objects. </span><span class="koboSpan" id="kobo.679.2">Also, by declaring a private default constructor at the bottom of the class, we are protecting ourselves from making a mistake where the derived class incorrectly specifies its own type for the inheritance. </span><span class="koboSpan" id="kobo.679.3">Now, we can start creating some visitors. </span><span class="koboSpan" id="kobo.679.4">The default visitor simply accepts the default actions provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">generic visitor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
class DefaultVisitor :
  public GenericVisitor&lt;DefaultVisitor&gt; {
};</span></pre>
<p><span class="koboSpan" id="kobo.682.1">We can visit any sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">Animal</span></strong><span class="koboSpan" id="kobo.684.1"> objects, for example, </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">a vector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.686.1">
std::vector&lt;Animal&gt; animals {
  {Animal::CAT, "Fluffy"},
  {Animal::DOG, "Fido"},
  {Animal::RAT, "Stinky"}};
DefaultVisitor().visit(animals.begin(), animals.end());</span></pre>
<p><span class="koboSpan" id="kobo.687.1">The visitation yields the </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">expected result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
Feed the cat Fluffy
Wash the dog Fido
Eeek!</span></pre>
<p><span class="koboSpan" id="kobo.690.1">But, we </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.691.1">don’t have to constrain ourselves to the default actions—we can override the visitation actions for one or more </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">animal types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
class TrainerVisitor :
  public GenericVisitor&lt;TrainerVisitor&gt; {
  friend class GenericVisitor&lt;TrainerVisitor&gt;;
  void visit_dog(const Animal&amp; animal) {
    cout &lt;&lt; "Train the dog " &lt;&lt; animal.name &lt;&lt; endl;
  }
};
class FelineVisitor :
  public GenericVisitor&lt;FelineVisitor&gt; {
  friend class GenericVisitor&lt;FelineVisitor&gt;;
  void visit_cat(const Animal&amp; animal) {
    cout &lt;&lt; "Hiss at the cat " &lt;&lt; animal.name &lt;&lt; endl;
  }
  void visit_dog(const Animal&amp; animal) {
    cout &lt;&lt; "Growl at the dog " &lt;&lt; animal.name &lt;&lt; endl;
  }
  void visit_rat(const Animal&amp; animal) {
    cout &lt;&lt; "Eat the rat " &lt;&lt; animal.name &lt;&lt; endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.694.1">When a dog trainer chooses to visit our animals, we </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">TrainerVisitor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
Feed the cat Fluffy
Train the dog Fido
Eeek!</span></pre>
<p><span class="koboSpan" id="kobo.699.1">Finally, a </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.700.1">visiting cat would have a set of actions all of </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">its own:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.702.1">
Hiss at the cat Fluffy
Growl at the dog Fido
Eat the rat Stinky</span></pre>
<p><span class="koboSpan" id="kobo.703.1">We will learn a lot more about different kinds of visitors later</span><a id="_idTextAnchor399"/><span class="koboSpan" id="kobo.704.1">, in </span><a href="B19262_17.xhtml#_idTextAnchor783"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.705.1">Chapter 17</span></em></span></a><span class="koboSpan" id="kobo.706.1">, </span><em class="italic"><span class="koboSpan" id="kobo.707.1">The Visitor Pattern and Multiple Dispatch</span></em><span class="koboSpan" id="kobo.708.1">. </span><span class="koboSpan" id="kobo.708.2">Now, however, we are going to explore the use of CRTP in conjunction with another </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">common pattern.</span></span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.710.1">CRTP and policy-based design</span></h1>
<p><span class="koboSpan" id="kobo.711.1">Policy-based design</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.712.1"> is a</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.713.1"> compile-time variant of the well-known Strategy pattern; we have an entire chapter dedicated to it, </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.714.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.715.1">, aptly named </span><em class="italic"><span class="koboSpan" id="kobo.716.1">Policy-Based Design</span></em><span class="koboSpan" id="kobo.717.1">. </span><span class="koboSpan" id="kobo.717.2">Here, we’re going to stay focused on the use of CRTP to provide additional functionality to the derived classes. </span><span class="koboSpan" id="kobo.717.3">Specifically, we are going to generalize the use of CRTP base classes to extend the interface of the </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">derived class.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">So far, we have used one base class to add features to the </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">derived class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.721.1">
template &lt;typename D&gt; struct plus_base {…};
class D : public plus_base&lt;D&gt; {…};</span></pre>
<p><span class="koboSpan" id="kobo.722.1">However, if we want to extend the interface of the derived class in multiple ways, a single base class presents an unnecessary restriction. </span><span class="koboSpan" id="kobo.722.2">First of all, if we add several member functions, the base class can get quite large. </span><span class="koboSpan" id="kobo.722.3">Second, we may want a more modular approach to the interface design. </span><span class="koboSpan" id="kobo.722.4">For example, we can have one base class template that </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.723.1">adds factory construction methods to any </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">derived class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
// Example 10
template &lt;typename D&gt; struct Factory {
  template &lt;typename... </span><span class="koboSpan" id="kobo.725.2">Args&gt;
  static D* create(Args&amp;&amp;... </span><span class="koboSpan" id="kobo.725.3">args) {
    return new D(std::forward&lt;Args&gt;(args)...);
  }
  static void destroy(D* d) { delete d; }
};</span></pre>
<p><span class="koboSpan" id="kobo.726.1">We can even have several different factories that present the same interface but allocate memory differently. </span><span class="koboSpan" id="kobo.726.2">We can have another base class template that adds the conversion to string to any class that has the stream </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">inserter operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.728.1">
// Example 10
template &lt;typename D&gt; struct Stringify {
  operator std::string() const {
    std::stringstream S;
    S &lt;&lt; *static_cast&lt;const D*&gt;(this);
    return S.str();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.729.1">It makes no sense to combine the two into a single base. </span><span class="koboSpan" id="kobo.729.2">In a large system, there can be many more of these classes, each adds a specific feature to the derived class and uses CRTP to implement it. </span><span class="koboSpan" id="kobo.729.3">But not every derived class needs every one of these features. </span><span class="koboSpan" id="kobo.729.4">With multiple base classes to choose from, it is easy to construct a derived class that has a specific set </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">of features:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.731.1">
// Example 10
class C1 : public Stringify&lt;C1&gt;, public Factory&lt;C1&gt; {…};</span></pre>
<p><span class="koboSpan" id="kobo.732.1">This works, but we are in danger of repeating nearly identical code if we need to implement several derived classes that have very similar behavior, except for the features provided by the CRTP bases. </span><span class="koboSpan" id="kobo.732.2">For example, if we have another factory that constructs objects in thread-local memory to speed up the performance of concurrent programs (let’s call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">TLFactory</span></strong><span class="koboSpan" id="kobo.734.1">), we might have to </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">write this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.736.1">
class C2 : public Stringify&lt;C2&gt;, public TLFactory&lt;C2&gt; {…};</span></pre>
<p><span class="koboSpan" id="kobo.737.1">But the</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.738.1"> two classes </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">C1</span></strong><span class="koboSpan" id="kobo.740.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">C2</span></strong><span class="koboSpan" id="kobo.742.1"> are exactly the same except for the base classes, and yet, as written we would have to implement and maintain two copies of identical code. </span><span class="koboSpan" id="kobo.742.2">It would be better if we could write a single class template and plug different base classes into it as needed. </span><span class="koboSpan" id="kobo.742.3">This is the main idea of policy-based design; there are different approaches to it and you can learn about them in </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.743.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.744.1">, </span><em class="italic"><span class="koboSpan" id="kobo.745.1">Policy-Based Design</span></em><span class="koboSpan" id="kobo.746.1">. </span><span class="koboSpan" id="kobo.746.2">For now, let us focus on using CRTP base classes in a template. </span><span class="koboSpan" id="kobo.746.3">Since we now need a class template that accepts multiple base class types, we will need to use a variadic template. </span><span class="koboSpan" id="kobo.746.4">We need something </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
template &lt;typename… Policies&gt;
class C : public Policies… {};</span></pre>
<p><span class="koboSpan" id="kobo.749.1">There are versions of the policy-based design that use this exact template; but in our case, it won’t compile if we try to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">Factory</span></strong><span class="koboSpan" id="kobo.751.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">Stringify</span></strong><span class="koboSpan" id="kobo.753.1"> as policies. </span><span class="koboSpan" id="kobo.753.2">The reason is that they are not types (classes) and, therefore, cannot be used as a type name. </span><span class="koboSpan" id="kobo.753.3">They are templates, so we have to declare the template parameters of the template </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">C</span></strong><span class="koboSpan" id="kobo.755.1"> as templates themselves (this is known as a template template parameter). </span><span class="koboSpan" id="kobo.755.2">The syntax is easier to understand if we first recall how to declare a single template </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">template parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.757.1">
template &lt;template &lt;typename&gt; class B&gt; class C;</span></pre>
<p><span class="koboSpan" id="kobo.758.1">If we wanted to inherit from a specific instantiation of this class template </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">B</span></strong><span class="koboSpan" id="kobo.760.1">, we </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">would write</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.762.1">
template &lt;template &lt;typename&gt; class B&gt;
class C : public B&lt;template argument&gt; {…};</span></pre>
<p><span class="koboSpan" id="kobo.763.1">When using CRTP, the template argument is the type of the derived class </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">itself, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">C&lt;B&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
template &lt;template &lt;typename&gt; class B&gt;
class C : public B&lt;C&lt;B&gt;&gt; {…};</span></pre>
<p><span class="koboSpan" id="kobo.768.1">Generalizing this to a parameter pack </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">is straightforward:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.770.1">
// Example 11
template &lt;template &lt;typename&gt; class... </span><span class="koboSpan" id="kobo.770.2">Policies&gt;
class C : public Policies&lt;C&lt;Policies...&gt;&gt;... </span><span class="koboSpan" id="kobo.770.3">{…};</span></pre>
<p><span class="koboSpan" id="kobo.771.1">The </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.772.1">template parameter is a pack (any number of templates instead of a single class). </span><span class="koboSpan" id="kobo.772.2">The derived class inherits from the entire pack </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">Policies…</span></strong><span class="koboSpan" id="kobo.774.1">, except </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">Policies</span></strong><span class="koboSpan" id="kobo.776.1"> are templates and we need to specify the actual instantiations of these templates. </span><span class="koboSpan" id="kobo.776.2">Each template in the pack is instantiated on the derived class, whose type </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">C&lt;Policies…&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">If we need additional template parameters, for example, to enable using different value types in the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">C</span></strong><span class="koboSpan" id="kobo.782.1">, we can combine them </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">with policies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.784.1">
// Example 11
template &lt;typename T,
          template &lt;typename&gt; class... </span><span class="koboSpan" id="kobo.784.2">Policies&gt;
class C : public Policies&lt;C&lt;T, Policies...&gt;&gt;... </span><span class="koboSpan" id="kobo.784.3">{
  T t_;
  public:
  explicit C(T t) : t_(t) {}
  const T&amp; get() const { return t_; }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, const C c) {
    out &lt;&lt; c.t_;
    return out;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.785.1">To use this class with a particular set of policies, it is convenient to define </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">some aliases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.787.1">
using X = C&lt;int, Factory, Stringify&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.788.1">If we want </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.789.1">to use several classes with the same Policies, we can define a template alias </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
template &lt;typename T&gt; using Y = C&lt;T, Factory, Stringify&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.792.1">We will learn more about policies in the </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.793.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.794.1">, </span><em class="italic"><span class="koboSpan" id="kobo.795.1">Policy-Based Design</span></em><span class="koboSpan" id="kobo.796.1">. </span><span class="koboSpan" id="kobo.796.2">We will encounter the technique we just studied, CRPT, there and in ot</span><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.797.1">her chapters of this book – it is a flexible and </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">powerful tool.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.799.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.800.1">We have examined a rather convoluted design pattern that combines both sides of C++—generic programming (templates) and object-oriented programming (inheritance). </span><span class="koboSpan" id="kobo.800.2">True to its name, the Curiously Recurring Template Pattern creates a circular loop, where the derived class inherits the interface and the implementation from the base class, while the base class has access to the interface of the derived class through the template parameters. </span><span class="koboSpan" id="kobo.800.3">CRTP has two main use modes—true static polymorphism, or </span><em class="italic"><span class="koboSpan" id="kobo.801.1">static interface</span></em><span class="koboSpan" id="kobo.802.1">, where the object is primarily accessed as the base type, and expanding the interface, or delegation, where the derived class is accessed directly but the implementation uses CRTP to provide common functionality. </span><span class="koboSpan" id="kobo.802.2">The latter can vary from a simple addition of one or two methods to a complex task of composing the interfaces of derived classes from multiple building blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">or policies.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">The next chapter introduces an idiom that makes use of the pattern we have just learned. </span><span class="koboSpan" id="kobo.804.2">This idiom also changes the standard way we pass arguments to functions, in order of the parameters, and lets us have or</span><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.805.1">d</span><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.806.1">er-independent named arguments instead. </span><span class="koboSpan" id="kobo.806.2">Read on to find </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">out how!</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.808.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.809.1">How expensive is a virtual function call, </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">and why?</span></span></li>
<li><span class="koboSpan" id="kobo.811.1">Why does a similar function call, resolved at compile time, have no such </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">performance overhead?</span></span></li>
<li><span class="koboSpan" id="kobo.813.1">How would you make compile-time polymorphic </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">function calls?</span></span></li>
<li><span class="koboSpan" id="kobo.815.1">How would you use CRTP to expand the interface of the </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">base class?</span></span></li>
<li><span class="koboSpan" id="kobo.817.1">What is necessary to use multiple CRTP base classes in a single </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">derived class?.</span></span></li>
</ol>
</div>
</body></html>