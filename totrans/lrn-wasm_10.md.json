["```cpp\nnpm install -g webassembly\n```", "```cpp\nwa\n```", "```cpp\n#include <stdbool.h>\n\n#define BOUNDS 255\n#define RECT_SIDE 50\n#define BOUNCE_POINT (BOUNDS - RECT_SIDE)\n\nbool isRunning = true;\n\ntypedef struct Rect {\n  int x;\n  int y;\n  char direction;\n} Rect;\n\nstruct Rect rect;\n\nvoid updateRectLocation() {\n    if (rect.x == BOUNCE_POINT) rect.direction = 'L';\n    if (rect.x == 0) rect.direction = 'R';\n    int incrementer = 1;\n    if (rect.direction == 'L') incrementer = -1;\n    rect.x = rect.x + incrementer;\n    rect.y = rect.y + incrementer;\n}\n\nextern \"C\" {\nextern int jsClearRect();\nextern int jsFillRect(int x, int y, int width, int height);\n\n__attribute__((visibility(\"default\")))\nvoid moveRect() {\n    jsClearRect();\n    updateRectLocation();\n    jsFillRect(rect.x, rect.y, RECT_SIDE, RECT_SIDE);\n}\n\n__attribute__((visibility(\"default\")))\nbool getIsRunning() {\n    return isRunning;\n}\n\n__attribute__((visibility(\"default\")))\nvoid setIsRunning(bool newIsRunning) {\n    isRunning = newIsRunning;\n}\n\n__attribute__((visibility(\"default\")))\nvoid init() {\n    rect.x = 0;\n    rect.y = 0;\n    rect.direction = 'R';\n    setIsRunning(true);\n}\n}\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>LLVM Test</title>\n</head>\n<body>\n  <h1>LLVM Test</h1>\n  <canvas id=\"myCanvas\" width=\"255\" height=\"255\"></canvas>\n  <div style=\"margin-top: 16px;\">\n    <button id=\"actionButton\" style=\"width: 100px; height: 24px;\">\n      Pause\n    </button>\n  </div>\n  <script type=\"application/javascript\">\n    const canvas = document.querySelector('#myCanvas');\n    const ctx = canvas.getContext('2d');\n\n    const importObj = {\n      env: {\n        memoryBase: 0,\n        tableBase: 0,\n        memory: new WebAssembly.Memory({ initial: 256 }),\n        table: new WebAssembly.Table({ initial: 8, element: 'anyfunc' }),\n        abort: console.log,\n        jsFillRect: function(x, y, w, h) {\n          ctx.fillStyle = '#0000ff';\n          ctx.fillRect(x, y, w, h);\n        },\n        jsClearRect: function() {\n          ctx.fillStyle = '#ff0000';\n          ctx.fillRect(0, 0, 255, 255);\n        }\n      }\n    };\n\n    WebAssembly.instantiateStreaming(fetch('main.wasm'), importObj)\n      .then(({ instance }) => {\n        const m = instance.exports;\n        m.init();\n\n        const loopRectMotion = () => {\n          setTimeout(() => {\n            m.moveRect();\n            if (m.getIsRunning()) loopRectMotion();\n          }, 20)\n        };\n\n    document.querySelector('#actionButton')\n      .addEventListener('click', event => {\n        const newIsRunning = !m.getIsRunning();\n        m.setIsRunning(newIsRunning);\n        event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';\n        if (newIsRunning) loopRectMotion();\n      });\n\n      loopRectMotion();\n    });\n  </script>\n</body>\n</html>\n```", "```cpp\nwa compile main.cpp -o main.wasm\n```", "```cpp\nserve -l 8080\n```", "```cpp\nint calculate(int firstVal, int secondVal) {\n    return firstVal + secondVal;\n}\n```", "```cpp\nint calculate(int firstVal, int secondVal) {\n    return firstVal - secondVal;\n}\n```", "```cpp\nvar wasmInstance = null;\n\nself.addEventListener('message', event => {\n  /**\n   * Once the WebAssembly compilation is complete, this posts a message\n   * back with whether or not the instantiation was successful. If the\n   * payload is null, the compilation succeeded.\n   */\n  const sendCompilationMessage = (error = null) => {\n    self.postMessage({\n      type: 'COMPILE_WASM_RESPONSE',\n      payload: error\n    });\n  };\n\n  const { type, payload } = event.data;\n  switch (type) {\n    // Instantiates the compiled Wasm module and posts a message back to\n    // the main thread indicating if the instantiation was successful:\n    case 'COMPILE_WASM_REQUEST':\n      const importObj = {\n        env: {\n          memoryBase: 0,\n          tableBase: 0,\n          memory: new WebAssembly.Memory({ initial: 256 }),\n          table: new WebAssembly.Table({ initial: 2, element: 'anyfunc' }),\n          abort: console.log\n        }\n      };\n\n      WebAssembly.instantiate(payload, importObj)\n        .then(instance => {\n          wasmInstance = instance.exports;\n          sendCompilationMessage();\n        })\n        .catch(error => {\n          sendCompilationMessage(error);\n        });\n      break;\n\n    // Calls the `calculate` method associated with the instance (add or\n    // subtract, and posts the result back to the main thread:\n    case 'CALC_REQUEST':\n      const { firstVal, secondVal } = payload;\n      const result = wasmInstance._calculate(firstVal, secondVal);\n\n      self.postMessage({\n        type: 'CALC_RESPONSE',\n        payload: result\n      });\n      break;\n\n    default:\n      break;\n  }\n}, false);\n```", "```cpp\n/**\n * Web Worker associated with an instantiated Wasm module.\n * @class\n */\nexport default class WasmWorker {\n  constructor(workerUrl) {\n    this.worker = new Worker(workerUrl);\n    this.listenersByType = {};\n    this.addListeners();\n  }\n\n  // Add a listener associated with the `type` value from the\n  // Worker message:\n  addListenerForType(type, listener) {\n    this.listenersByType[type] = listener;\n  }\n\n  // Add event listeners for error and message handling.\n  addListeners() {\n    this.worker.addEventListener('error', event => {\n      console.error(`%cError: ${event.message}`, 'color: red;');\n    }, false);\n\n    // If a handler was specified using the `addListener` method,\n    // fire that method if the `type` matches:\n    this.worker.addEventListener('message', event => {\n      if (\n        event.data instanceof Object &&\n        event.data.hasOwnProperty('type') &&\n        event.data.hasOwnProperty('payload')\n      ) {\n        const { type, payload } = event.data;\n        if (this.listenersByType[type]) {\n          this.listenersByType[type](payload);\n        }\n      } else {\n        console.log(event.data);\n      }\n    }, false);\n  }\n\n  // Fetches the Wasm file, compiles it, and passes the compiled result\n  // to the corresponding worker. The compiled module is instantiated\n  // in the worker.\n  initialize(name) {\n    return fetch(`calc-${name}.wasm`)\n      .then(response => response.arrayBuffer())\n      .then(bytes => WebAssembly.compile(bytes))\n      .then(wasmModule => {\n        this.worker.postMessage({\n          type: 'COMPILE_WASM_REQUEST',\n          payload: wasmModule\n      });\n      return Promise.resolve();\n    });\n  }\n\n  // Posts a message to the worker thread to call the `calculate`\n  // method from the Wasm instance:\n  calculate(firstVal, secondVal) {\n    this.worker.postMessage({\n      type: 'CALC_REQUEST',\n        payload: {\n        firstVal,\n        secondVal\n      }\n    });\n  }\n}\n```", "```cpp\nimport WasmWorker from './WasmWorker.js';\n\n/**\n * If you add ?blob=true to the end of the URL (e.g.\n * http://localhost:8080/index.html?blob=true), the worker will be\n * created from a Blob rather than a URL. This returns the\n * URL to use for the Worker either as a string or created from a Blob.\n */\nconst getWorkerUrl = async () => {\n  const url = new URL(window.location);\n  const isBlob = url.searchParams.get('blob');\n  var workerUrl = 'worker.js';\n  document.title = 'Wasm Worker (String URL)';\n\n  // Create a Blob instance from the text contents of `worker.js`:\n  if (isBlob === 'true') {\n    const response = await fetch('worker.js');\n    const results = await response.text();\n    const workerBlob = new Blob([results]);\n    workerUrl = window.URL.createObjectURL(workerBlob);\n    document.title = 'Wasm Worker (Blob URL)';\n  }\n\n  return Promise.resolve(workerUrl);\n};\n\n/**\n * Instantiates the Wasm module associated with the specified worker\n * and adds event listeners to the \"Add\" and \"Subtract\" buttons.\n */\nconst initializeWorker = async (wasmWorker, name) => {\n  await wasmWorker.initialize(name);\n  wasmWorker.addListenerForType('CALC_RESPONSE', payload => {\n    document.querySelector('#result').value = payload;\n  });\n\n  document.querySelector(`#${name}`).addEventListener('click', () => {\n    const inputs = document.querySelectorAll('input');\n    var [firstInput, secondInput] = inputs.values();\n    wasmWorker.calculate(+firstInput.value, +secondInput.value);\n  });\n};\n\n/**\n * Spawns (2) workers: one associated with calc-add.wasm and another\n * with calc-subtract.wasm. Adds an event listener to the \"Reset\"\n * button to clear all the input values.\n */\nconst loadPage = async () => {\n  document.querySelector('#reset').addEventListener('click', () => {\n    const inputs = document.querySelectorAll('input');\n    inputs.forEach(input => (input.value = 0));\n  });\n\n  const workerUrl = await getWorkerUrl();\n  const addWorker = new WasmWorker(workerUrl);\n  await initializeWorker(addWorker, 'add');\n\n  const subtractWorker = new WasmWorker(workerUrl);\n  await initializeWorker(subtractWorker, 'subtract');\n};\n\nloadPage()\n  .then(() => console.log('%cPage loaded!', 'color: green;'))\n  .catch(error => console.error(error));\n```", "```cpp\nvar worker = new Worker('worker.js');\n```", "```cpp\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Wasm Workers</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\" />\n</head>\n<body>\n  <form class=\"valueForm\">\n    <div class=\"valueForm\">\n      <label for=\"firstVal\">First Value:</label>\n      <input id=\"firstVal\" type=\"number\" value=\"0\" />\n    </div>\n    <div class=\"valueForm\">\n      <label for=\"secondVal\">Second Value:</label>\n      <input id=\"secondVal\" type=\"number\" value=\"0\" />\n    </div>\n    <div class=\"valueForm\">\n      <label for=\"result\">Result:</label>\n      <input id=\"result\" type=\"number\" value=\"0\" readonly />\n    </div>\n  </form>\n  <div>\n    <button id=\"add\">Add</button>\n    <button id=\"subtract\">Subtract</button>\n    <button id=\"reset\">Reset</button>\n  </div>\n  <script type=\"module\" src=\"img/index.js\"></script>\n</body>\n</html>\n```", "```cpp\n* {\n  font-family: sans-serif;\n  font-size: 14px;\n}\n\nbody {\n  margin: 16px;\n}\n\nform.valueForm {\n  display: table;\n}\n\ndiv.valueForm {\n  display: table-row;\n}\n\nlabel, input {\n  display: table-cell;\n  margin-bottom: 16px;\n}\n\nlabel {\n  font-weight: bold;\n  padding-right: 16px;\n}\n\nbutton {\n  border: 1px solid black;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: bold;\n  height: 24px;\n  margin-right: 4px;\n  width: 80px;\n}\n\nbutton:hover {\n  background: lightgray;\n}\n```", "```cpp\n# First, compile the add.c file: emcc -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 lib/add.c -o src/calc-add.wasm # Next, compile the subtract.c fileemcc -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 lib/subtract.c -o src/calc-subtract.wasm\n```", "```cpp\nserve -l 8080 src\n```"]