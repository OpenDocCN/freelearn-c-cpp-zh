# 第11章 网络通信

在本章中，我们将讨论通过创建通信网络来连接对象并使它们通过通信进行交流。我们将学习如何通过网络链路和协议使多个Arduino和计算机进行通信。

在定义了什么是网络（特别是数据网络）之后，我们将描述如何在Arduino和计算机之间使用有线以太网链路。这将使Arduino世界通向互联网。然后，我们将探讨如何创建蓝牙通信。

我们将学习如何使用以太网Wi-Fi将Arduino连接到计算机或其他Arduino，而无需被网络电缆所束缚。

最后，我们将研究几个例子，从向微博服务Twitter发送消息的例子，到解析和响应从互联网接收到的数据的例子。

我们还将介绍广泛用于与交互设计、音乐和多媒体相关的一切的OSC交换协议。

# 网络概述

网络是由相互连接的元素组成的系统。我们周围有许多网络，如公路系统、电网和数据网络。数据网络包围着我们。它们与视频服务网络、电话和全球电信网络、计算机网络等相关。我们将通过讨论如何通过不同类型的媒体（如传输电脉冲的电线或促进无线通信的电磁波）共享数据来关注这些类型的网络。

在我们深入Arduino板网络实现细节之前，我们将描述一个名为OSI模型（开放系统互连模型）的模型。这是一个非常有用的表示，说明了数据网络是什么以及它涉及的内容。

## OSI模型概述

**开放** **系统** **互连**模型（**OSI**模型）于1977年由国际标准化组织发起，旨在定义关于通信系统功能的抽象层的规定和要求。

基本上，这是一个基于层的模型，描述了设计通信系统所需的功能。以下是具有七层的OSI模型：

![OSI模型概述](img/7584_11_001.jpg)

描述通信系统要求的七层抽象的OSI模型

## 协议和通信

通信协议是一组消息格式和规则，提供了一种至少两个参与者之间通信的方式。在每一层中，一个或多个实体实现其功能，每个实体直接且仅与下一层交互，同时为上层提供使用设施。协议使一个主机中的一个实体能够与另一个主机中同一层的相应实体进行交互。这可以通过以下图表表示：

![协议和通信](img/7584_11_002.jpg)

协议帮助主机层之间进行通信

## 数据封装和解封装

如果一个主机的应用程序需要将数据发送到另一个主机的应用程序，有效数据，也称为有效载荷，将直接传递到其下的一层。为了使应用程序能够检索其数据，根据每一层使用的协议，将添加头部和尾部到这些数据。这被称为**封装**，并且一直发生到最低层，即物理层。在这一点，一个比特流被调制到介质上以供接收器使用。

接收器必须使数据逐步爬升层堆栈，将数据从一层传递到更高一层，并使用之前添加的头部和尾部将其地址指向每一层的正确实体。这些头部和尾部在整个路径上都被移除；这被称为**解封装**。

在旅程结束时，接收器的应用程序接收其数据并可以处理它。整个过程可以用以下图表表示：

![数据封装和解封装](img/7584_11_003.jpg)

在层堆栈中沿层进行封装和解封装

我们也可以将这些过程表示如下图所示。小灰色矩形是层 N+1 的数据有效载荷。

![数据封装和解封装](img/7584_11_004.jpg)

根据使用的协议添加和移除特定的头部和尾部

在每一级，两个主机使用传输的协议进行交互，我们称之为**协议数据单元**或**PDU**。我们还将从一层传递到下一层且尚未封装的特定数据单元称为**服务数据单元**或**SDU**。

每一层都将接收到的数据视为自己的数据，并根据所使用的协议添加/移除头部和尾部。

我们现在将通过示例来阐述每一层和协议。

## 每一层的角色

我们将在这里描述每一层的用途和角色。

### 物理层

物理层定义了通信所需的电气和物理规范。

引脚布局、电压和线路阻抗、信号时序、网络适配器或主机总线适配器在此层定义。基本上，这一层执行三个主要功能/服务：

+   初始化和终止与通信介质的连接

+   参与共享资源控制过程

+   通信数据与携带它们的电气信号之间的转换

我们可以引用一些已知的标准，它们位于这一物理层：

+   ADSL 和 ISDN（网络和模拟服务提供商）

+   蓝牙

+   IEEE 1394（FireWire）

+   USB

+   IrDA（通过红外链路的数据传输）

+   SONET、SDH（由提供商运营的广域光纤网络）

### 数据链路层

这一层由两个子层组成：

+   逻辑链路控制 (LLC)

+   媒体访问控制 (MAC)

它们都负责在网络实体之间传输数据，并检测物理层可能发生的错误，最终修复它们。基本上，这一层提供以下功能/服务：

+   封装

+   物理寻址

+   流控制

+   错误控制

+   访问控制

+   媒体访问控制

我们可以引用该数据链路层的一些已知标准：

+   以太网

+   Wi-Fi

+   PPP

+   I2C

我们必须记住，第二层也是局域网的领域，只有物理地址。它可以通过局域网交换机进行联邦。

顺便说一下，我们经常需要分段网络并更广泛地通信，因此我们需要另一个寻址概念；这引入了网络层。

### 网络层

这一层提供了在不同网络中的主机之间传输数据序列的方法。它提供以下功能/服务：

+   路由

+   分片和重组

+   报告交付错误

路由提供了一种使不同网络上的主机能够通过使用网络寻址系统进行通信的方法。

分片和重组也发生在这一级。这些提供了一种将数据流切割成片段并在传输后重新组装部分的方法。我们可以引用这一层的一些已知标准：

+   ARP（解析和将物理MAC地址转换为网络地址）

+   BOOTP（为主机通过网络启动提供一种方式）

+   BGP、OSPF、RIP和其他路由协议

+   IPv4和IPv6（互联网协议）

路由器通常是路由发生的地方。它们连接到多个网络，使数据从一个网络传输到另一个网络。这也是我们可以放置一些访问列表以根据IP地址控制访问的地方。

### 传输层

这一层负责在终端用户之间进行数据传输，位于网络层和应用层的交汇处。这一层提供以下功能/服务：

+   流控制以确保链路的可靠性

+   数据单元的分割/解分割

+   错误控制

通常，我们将协议分为两类：

+   面向状态

+   面向连接

这意味着这一层可以跟踪发出的段，并在之前传输失败的情况下最终重新传输它们。

在这一层，我们可以引用IP套件的两个著名标准：

+   TCP

+   UDP

TCP是面向连接的。它通过在每个传输或每个x个传输的段中检查许多元素来保持通信的可靠性。

UDP更简单且无状态。它不提供通信状态控制，因此更轻量。它更适合于面向事务的查询/响应协议，如DNS（域名系统）或NTP（网络时间协议）。如果有问题，例如一个分段没有很好地传输，上面的层必须负责重新发送请求，例如。

### 应用/主机层

我将最高三层归类为应用和主机。

事实上，它们不被视为网络层，但它们是OSI模型的一部分，因为它们通常是任何网络通信的最终目的。

我们在那里发现了许多客户端/服务器应用程序：

+   FTP用于基本和轻量级文件传输

+   POP3、IMAP和SMTP用于邮件服务

+   SSH用于安全的远程shell通信

+   HTTP用于网页浏览和下载（以及如今更多）

我们还发现了许多与加密和安全相关的标准，例如TLS（传输层安全性）。我们的固件，一个正在执行的Processing代码，Max 6运行补丁都在这一层。

如果我们想让它们通过广泛的网络进行通信，我们需要一些OSI栈。我的意思是，我们需要一个传输和网络协议以及一个传输数据的中介。

如果我们的现代计算机拥有整个网络栈并准备好使用，那么如果我们想让它们能够与世界通信，我们就必须在Arduino的固件中稍后构建这个功能。这就是我们在下一小节将要做的。

## 一些关于IP地址和端口的方面

我们每天倾向于使用的协议栈之一是TCP/IP。TCP是第4层传输协议，IP是第3层网络。

这是世界上使用最广泛的网络协议，无论是对于终端用户还是对于公司。

我们将更详细地解释IP寻址系统、子网掩码和通信端口。我不会描述一个完整的网络课程。

### IP地址

IP地址是任何想要通过IP网络通信的设备引用的数值地址。IP目前使用2个版本：IPv4和IPv6。在这里我们考虑IPv4，因为它目前是终端用户唯一使用的版本。IPv4地址由32位编码。它们通常被写成由点分隔的4个字节的易读集合。192.168.1.222是我的计算机当前的IP地址。有2^(32)个可能的唯一地址，并且并不是所有都可以在互联网上路由。一些被保留用于私有用途。一些公司分配可路由互联网地址。实际上，我们不能使用这两个地址，因为这是由全球组织处理的。每个国家都有为自身目的分配的地址集合。

### 子网

子网是一种将我们的网络分割成多个更小网络的方法。设备网络的配置通常包含地址、子网掩码和网关。

地址和子网掩码定义了网络范围。了解发送器是否可以直接与接收器通信是必要的。实际上，如果后者在同一网络内，通信可以直接发生；如果它在另一个网络中，发送器必须将其数据发送到网关，网关将数据路由到正确的下一个节点，以便尽可能到达接收器。

网关了解它所连接的网络。它可以跨不同网络路由数据，并最终根据某些规则过滤一些数据。

通常，子网掩码也以人类可读的4字节集合的形式编写。显然，有一个位表示法，对于那些不习惯于操作数字的人来说更难。

我的计算机的子网掩码是255.255.255.0。这些信息和我的IP地址定义了我的家庭网络从192.168.1.0（这是基本网络地址）开始，到192.168.1.255（这是广播地址）结束。我不能使用这些地址为我的设备分配，而只能使用从192.168.1.1到192.168.1.254的地址。

### 通信端口

通信端口是定义并相关于第4层，即传输层的某个东西。

假设你想向特定应用的主机发送一条消息。接收者必须处于监听模式，以便接收他想要接收的消息。

这意味着它必须为连接打开并保留一个特定的套接字，这就是通信端口。通常，应用程序为它们自己的目的打开特定的端口，一旦一个端口被一个应用程序打开并保留，在第一个应用程序打开期间，它就不能被另一个应用程序使用。

这提供了一种强大的数据交换系统。实际上，如果我们想向一个主机发送超过一个应用的数据，我们可以将我们的消息特别指向这个主机上的不同端口，以到达不同的应用。

当然，为了全球通信，必须定义标准。

TCP端口80用于与Web服务器数据交换相关的HTTP协议。

UDP端口53用于与DNS相关的任何事物。

如果你好奇，你可以阅读以下包含所有声明和保留端口及其相关服务的巨大官方文本文件：[http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt](http://www.ietf.org/assignments/service-names-port-numbers/service-names-port-numbers.txt)。

这些是惯例。有人可以很容易地在非80端口的端口上运行Web服务器。然后，这个Web服务器的特定客户端必须知道使用的端口。这就是为什么惯例和标准是有用的。

# 将Arduino连接到有线以太网

以太网是现在最常用的局域网。

常规的Arduino板不提供以太网功能。有一个名为Arduino Ethernet的板提供了本地的以太网和网络功能。顺便说一下，它不提供任何USB原生功能。

你可以在这里找到参考页面：[http://arduino.cc/en/Main/ArduinoBoardEthernet](http://arduino.cc/en/Main/ArduinoBoardEthernet)。

![将Arduino连接到有线以太网](img/7584_11_005.jpg)

带有以太网连接器的Arduino以太网板

我们将使用Arduino以太网盾和一根100BASE-T电缆与Arduino UNO R3连接。它保留了USB功能，并增加了以太网网络连接性，通过比USB更长的电缆，为我们提供了一个将计算机与Arduino连接的便捷方式。

![将Arduino连接到有线以太网](img/7584_11_006.jpg)

Arduino以太网盾

如果你寻找Arduino以太网模块，你必须知道它们是带PoE模块或不带PoE模块销售的。

**PoE**代表**以太网供电**，是一种通过以太网连接为设备供电的方式。这需要两个部分：

+   设备上必须供电的模块

+   一台能够提供PoE支持的网路设备

在我们这里，我们不会使用PoE。

## 通过以太网使Processing和Arduino通信

让我们设计一个基本系统，展示如何设置Arduino板和processing小程序之间的以太网通信。

这里，我们将使用一个通过以太网连接到我们电脑的Arduino板。我们按下一个按钮，触发Arduino通过UDP向电脑上的Processing小程序发送消息。小程序通过绘制某些内容并发送回消息给Arduino，Arduino内置的LED灯就会亮起。

### 基本接线

这里，我们连接一个开关并使用内置的LED板。我们必须使用以太网线将我们的Arduino板连接到电脑。

这种接线与第5章中MonoSwitch项目的接线非常相似，除了我们在这里使用的是Arduino以太网屏蔽板而不是Arduino板本身。

![基本接线](img/7584_11_007.jpg)

连接到Arduino以太网屏蔽板的开关和下拉电阻

对应的电路图如下：

![基本接线](img/7584_11_008.jpg)

连接到Arduino以太网屏蔽板的开关和下拉电阻

### 在Arduino中编码网络连接实现

正如我们描述的，如果我们想让我们的Arduino能够通过以太网线（更普遍地说，通过以太网网络）进行通信，我们必须在固件中实现所需的标准。

有一个名为`Ethernet`的库可以提供大量的功能。

如同往常，我们必须包含这个本地库本身。你可以通过导航到**草图** **|** **导入库**来选择这样做，这几乎包含了你需要的一切。

然而，由于Arduino版本0018中SPI的实现，以及Arduino以太网屏蔽板通过SPI与Arduino板通信，我们必须包含一些额外的内容。请注意这一点。

对于这个代码，你需要：

[PRE0]

这是一段Arduino代码的示例，后面将进行解释。

你可以在`Chapter11/WiredEthernet`找到完整的Arduino代码。

[PRE1]

在之前的代码块中，首先我们包含`Ethernet`库。然后我们声明与开关去抖动和LED处理相关的完整变量集。在这些语句之后，我们定义了一些与网络功能相关的变量。

首先，我们必须设置与我们自己的屏蔽板相关的MAC地址。这个唯一的标识符通常标示在你的以太网屏蔽板上的标签上。请务必在代码中放入你的MAC地址。

然后，我们设置Arduino的IP地址。只要它遵守IP地址方案，并且我们的计算机可以访问，我们就可以使用任何地址。这意味着在同一网络或另一网络，但两者之间有一个路由器。然而，请注意，您选择的IP地址必须在本地网络段中是唯一的。

我们还为我们的通信选择一个UDP端口。我们使用与我们的计算机相关的网络参数相同的定义，这是通信中的第二组参与者。

我们声明一个缓冲区来存储每次接收到的当前消息。注意常量`UDP_TX_PACKET_MAX_SIZE`。它在Ethernet库中定义。基本上，它被定义为24字节，以节省内存。我们可以更改它。然后，我们实例化`EthernetUDP`对象，以便通过UDP接收和发送数据报。`setup()`函数块包含开关和LED的语句，然后是Ethernet本身的语句。

我们使用MAC和IP地址开始以太网通信。然后我们打开并监听定义中指定的UDP端口，在我们的例子中是9999。`loop()`函数看起来有点复杂，但我们可以将其分为两部分。

在第一部分，我们检查Arduino是否已收到数据包。如果收到了，它将通过调用Ethernet库的`parsePacket()`函数并检查它是否返回一个非零的数据包大小来检查。我们读取数据并将其存储在`packetBuffer`变量中。

然后我们检查这个变量是否等于`Light`或`Dark`，并相应地通过在Arduino板上打开或关闭LED来采取行动。

在第二部分，我们可以看到与我们在[第5章](ch05.html "第5章. 使用数字输入进行感应")中看到的相同的防抖结构。在这一部分的末尾，我们检查开关是否被按下或释放，并根据状态向计算机发送UDP消息。

现在我们来检查Processing/计算机部分。

### 编写一个通过以太网通信的Processing Applet

让我们检查`Chapter11/WiredEthernetProcessing`中的代码。

我们需要超媒体库。我们可以在[http://ubaa.net/shared/processing/udp](http://ubaa.net/shared/processing/udp)找到它。

[PRE2]

我们首先导入库。然后我们定义UDP对象和用于当前接收消息的String变量。

在这里，我们也必须定义远程参与者，即Arduino的IP地址。我们还要定义在Arduino侧打开并可用于通信的端口，这里为9999。

当然，这必须与在Arduino固件中定义的相匹配。在`setup()`函数中，我们定义了一些绘图参数，然后实例化UDP端口10000上的UDP套接字，并将其设置为监听模式，等待传入的消息。

在`draw()`函数中，我们画一个圆。`receive()`函数是代码在接收到数据包时调用的回调函数。我们测试数据包的字节数长度，因为我们只想对两种不同的消息做出反应（`Pushed`或`Released`），所以我们检查长度是否为6或8字节。所有其他数据包都不会被处理。我们可以实现一个更好的检查机制，但这个方法已经足够好。

一旦这些长度中的任何一个匹配，我们就将每个字节连接到String变量`currentMessage`中。这提供了一种方便的方法来比较内容与任何其他字符串。

然后，我们将它与`Pushed`和`Released`进行比较，并相应地通过向Arduino发送消息`Light`来填充我们绘制的圆圈为白色，或者通过向Arduino发送消息`Dark`来填充我们绘制的圆圈为黑色。

我们刚刚使用以太网和UDP设计了我们第一个基本的通信协议。

## 关于TCP的一些话

在我的设计中，我经常使用UDP在系统之间进行通信。它比TCP轻得多，并且对我们的目的来说已经足够。

在某些情况下，你可能需要TCP提供的流控制。我们刚刚使用的以太网库也提供了TCP功能。你可以在[http://arduino.cc/en/Reference/Ethernet](http://arduino.cc/en/Reference/Ethernet)找到参考页面。

`Server`和`Client`类可以特别用于此目的，实现功能测试，例如检查是否已打开连接，是否仍然有效等。

在本章的结尾，我们将学习如何将我们的Arduino连接到互联网上的某个实时服务器。

# 蓝牙通信

蓝牙是一种无线技术标准。它提供了一种使用2,400到2,480 MHz频段内的短波无线电传输在短距离内交换数据的方法。

它允许创建具有“正确”安全级别的PANs（个人区域网络）。它被应用于各种类型的设备上，例如计算机、智能手机、音响系统等，这些设备可以从远程源读取数字音频。

Arduino BT板原生实现了这项技术。它现在配备了ATmega328和Bluegiga WT11蓝牙模块。参考页面是`http://www.arduino.cc/en/Main/ArduinoBoardBluetooth`。

在我看来，在许多项目中，最好的做法是将通用板放在设计的核心，并通过添加外部模块仅添加我们需要的功能。因此，我们将在这里使用Arduino UNO R3和一个外部蓝牙模块。

我们将再次使用Processing制作一个小项目。你可以在Processing画布上点击某个位置，Processing应用程序将通过蓝牙向Arduino发送消息，Arduino会通过切换其内置LED的开或关来做出反应。

## 连接蓝牙模块

检查以下图示：

![连接蓝牙模块](img/7584_11_009.jpg)

RN41蓝牙模块通过串行链路连接到Arduino

对应的电路图如下：

![连接蓝牙模块](img/7584_11_010.jpg)

将Roving Networks RN41模块连接到Arduino板

有一个Roving Networks RN41蓝牙模块连接到Arduino板。

您可以在[https://www.sparkfun.com/products/10559](https://www.sparkfun.com/products/10559)找到它。

这里我们使用Arduino本身和蓝牙模块之间的基本串行链路通信。

我们假设我们的计算机具有蓝牙功能，并且这些功能已被激活。

## 编写固件和Processing小程序

固件如下。您可以在`Chapter11/Bluetooth`中找到它。

[PRE3]

我们基本上使用蓝牙模块实例化`Serial`通信，然后检查是否有任何字节从其中可用并解析它们。如果有一个消息可用并且等于1，我们打开LED；如果它等于0，我们关闭LED。

处理代码如下：

[PRE4]

我们首先包含串行库。在`setup()`函数中，我们定义了一些绘图位，然后我们将串行设备列表打印到Processing日志区域。这显示了一个列表，我们必须找到我们计算机的正确蓝牙模块。在我的情况下，这是第三个，我使用这个在`setup()`函数的最后一条语句中实例化`Serial`通信：

[PRE5]

`draw()`函数只设置：

+   背景颜色根据变量`bgcolor`

+   轮廓颜色根据变量`fgcolor`

+   填充颜色根据变量`fgcolor`

然后我们画一个正方形。

`mousePressed()`和`mouseReleased()`函数是Processing回调函数，分别在鼠标事件发生时调用，当你按下鼠标按钮并释放它时。

当鼠标按下时，我们检查按下时的光标位置。在我的情况下，我定义了正方形内的区域。

如果我们按下正方形中的按钮，会出现视觉反馈，以告诉我们已收到命令，但当然最重要的是`digitalWrite('1')`函数。

我们将值1写入蓝牙模块。

同样，当我们释放鼠标按钮时，一个“0”被写入计算机的蓝牙模块。当然，这些消息被发送到Arduino，后者打开或关闭LED。

我们刚刚检查了一个外部模块提供无线蓝牙通信功能的Arduino的示例。

正如我们所注意到的，我们不需要为此目的使用特定的库，因为模块本身只有当我们向它发送串行数据时，才能自行连接和发送/接收数据。确实，Arduino和模块之间的通信是一种基本的串行通信。

让我们通过以太网Wi-Fi改进我们的空中数据通信。

# 玩转Wi-Fi

我们之前学习了如何使用以太网库。然后，我们测试了蓝牙进行短距离网络通信。现在，让我们测试Wi-Fi进行中等距离通信，仍然没有任何线缆。

## 什么是Wi-Fi？

Wi-Fi 是一套由 IEEE 802.11 标准驱动的无线通信协议。这些标准描述了无线局域网（WLAN）的特性。

基本上，拥有 Wi-Fi 模块的多个主机可以通过它们的 IP 堆栈无线通信。Wi-Fi 使用了多种网络模式。

### 基础设施模式

在这种模式下，Wi-Fi 主机可以通过接入点相互通信。

这个接入点和主机必须使用相同的**服务集标识符**（SSID），这是一个用作参考的网络名称。

这种模式很有趣，因为它通过每个主机必须通过接入点才能访问全局网络的事实来提供安全性。我们可以配置一些访问列表来控制哪些主机可以连接，哪些不能。

![基础设施模式](img/7584_11_011.jpg)

在基础设施模式下通过接入点交换数据的宿主

### 临时模式

在这种模式下，每个主机可以直接连接到另一个主机，而不需要接入点。这对于快速连接两个主机以共享文档和交换数据非常有用。

![临时模式](img/7584_11_012.jpg)

在临时模式下直接连接的两个主机

### 其他模式

还有两种其他模式。**桥接模式**是一种连接多个接入点的方式。我们可以想象一个分散在两座建筑中的工作组；我们可以使用两个不同的接入点，并通过桥接模式将它们连接起来。

还有一个名为 **范围扩展模式** 的简单模式。它用于重复信号，并在两个主机、两个接入点或主机和接入点之间提供连接，当它们距离太远时。

## Arduino Wi-Fi 扩展板

这个扩展板为 Arduino 板增加了无线网络功能。官方扩展板还包含一个 SD 卡槽，提供存储功能。它提供：

+   通过 802.11b/g 网络进行连接

+   使用 WEP 或 WPA2 个人加密

+   用于扩展板本身串行调试的 FTDI 连接

+   Mini-USB 用于更新 Wi-Fi 扩展板的固件

![Arduino Wi-Fi 扩展板](img/7584_11_013.jpg)

Arduino Wi-Fi 扩展板

它基于 HDG104 无线局域网 802.11b/g 系统封装。适当的 Atmega 32 UC3 提供了网络 IP 堆栈。

一个名为 **WiFi 库** 的专用本地库提供了我们将板子无线连接到任何网络所需的所有功能。参考信息可在[http://arduino.cc/en/Reference/WiFi](http://arduino.cc/en/Reference/WiFi)找到。

这个扩展板可以从许多分销商以及 Arduino 商店购买：[http://store.arduino.cc/ww/index.php?main_page=product_info&cPath=11_5&products_id=237](http://store.arduino.cc/ww/index.php?main_page=product_info&cPath=11_5&products_id=237)。

让我们尝试将我们的 Arduino 连接到 Wi-Fi 网络。

## 无加密的基本 Wi-Fi 连接

这里，我们不需要绘制任何原理图。基本上，我们将盾牌连接到Arduino并上传我们的代码。我们首先将测试一个不进行加密的基本连接。

接受点必须提供DHCP服务器；后者将为我们的基于Arduino的系统提供一个IP地址。

让我们检查`WiFi`库提供的示例`ConnectNoEncryption`。

[PRE6]

首先，我们包含`WiFi`库。然后，我们设置我们网络的名称，即SSID。请务必将其更改为您自己的SSID。

在`setup()`函数中，我们实例化`Serial`连接。然后，我们通过调用函数`WiFi.status()`来检查盾牌的存在。

如果后者返回的值是`WL_NO_SHIELD`（这是在WiFi库内部定义的一个常量），这意味着没有盾牌。在这种情况下，将执行一个无限循环，使用`while(true)`语句而没有`break`关键字。

如果它返回的值不同于`WL_CONNECTED`，那么我们将打印一条语句来通知它正在尝试连接。然后，`WiFi.begin()`尝试连接。这是一个常见的结构，提供了一种在不连接时不断尝试连接的方法，并且每10秒调用一次`delay()`函数。

然后，如果连接成功，状态变为`WL_CONNECTED`，我们退出`while`循环并继续。

同时也会在串行中打印一些信息，表示板子已经达到连接状态。

我们还调用了两个函数。这些函数会打印与网络参数和状态相关的许多元素。我将让您通过之前引用的[http://arduino.cc/en/Reference/WiFi](http://arduino.cc/en/Reference/WiFi)参考来发现每个函数。

在此连接之后，我们可以开始交换数据。正如您可能知道的，使用Wi-Fi（尤其是没有安全措施的情况下）可能会导致问题。事实上，从未受保护的Wi-Fi网络捕获数据包非常容易。

让我们使用更安全的`WiFi`库。

## 使用WEP或WPA2的Arduino Wi-Fi连接

如果您打开`ConnectWithWEP`和`ConnectWithWPA`这两个代码，与前面的例子相比只有一些细微的差别。

### 使用WiFi库中的WEP

如果我们使用40位WEP，我们需要一个包含10个字符的密钥，这些字符必须是十六进制的。如果我们使用128位WEP，我们需要一个包含26个字符的密钥，这些字符也必须是十六进制的。这个密钥必须在代码中指定。

我们用两个与WEP加密相关的新参数替换了只带一个参数的`WiFi.begin()`调用。这是唯一的区别。

由于许多我们在这里不会讨论的原因，WEP在安全性方面被认为太弱，因此大多数人和组织已经转向更安全的WPA2替代方案。

### 使用WiFi库中的WPA2

按照相同的方案，这里我们只需要一个密码。然后，我们用两个参数调用`WiFi.begin()`：SSID和密码。

在我们检查的两种情况下，我们只需要在`WiFi.begin()`中传递一些额外的参数，以便使事情更加安全。

## Arduino有一个（轻量级）网络服务器

在这里，我们使用库中提供的`WifiWebServer`代码。

在这个例子中，Arduino在连接到WEP或WPA Wi-Fi网络后充当一个网络服务器。

[PRE7]

让我们解释这些语句背后的概念。

我们只解释代码的新部分，而不是自动连接和加密语句，因为我们之前已经做过这些。

`WiFiServer server(80)`语句在特定端口上实例化一个服务器。在这里，选择的TCP端口是80，这是标准的HTTP服务器TCP端口。

在`setup()`函数中，我们自动将Arduino连接到Wi-Fi网络，然后启动服务器。基本上，它会在TCP端口80上打开一个套接字并开始监听该端口。

在`loop()`函数中，我们检查是否有客户端连接到Arduino上嵌入的网络服务器。这是通过`WiFiClient client = server.available();`来完成的。

然后，我们对客户端实例有一个条件。如果没有客户端，我们基本上什么都不做，并再次执行循环，直到我们有客户端。

一旦我们有了连接，我们就将其打印到串行端口以提供反馈。然后，我们检查客户端是否真正连接，以及读取缓冲区中是否有数据。如果有数据，我们就将其打印出来，并通过发送标准的HTTP响应头来回答客户端。这基本上是通过将字节打印到客户端实例本身来完成的。

代码包括一些动态特性，并发送一些从板上读取的值，如来自每个模拟输入的ADC值。

我们可以尝试连接一些传感器，并通过Arduino直接处理的一个网页直接提供它们的值。我会让你检查代码的其他部分。这部分处理标准的HTTP消息。

# 通过按开关来发推文

将Arduino连接到网络显然让人联想到互联网。我们可以尝试创建一个可以发送互联网消息的小系统。我选择使用微博服务Twitter，因为它提供了一个很好的通信API。

我们将使用与“将Arduino连接到以太网”部分相同的电路，但在这里我们使用的是与一些内存约束相关的Arduino MEGA，板子更小。

## API概述

**API**代表**应用程序** **编程** **接口**。基本上，它定义了与考虑的系统交换数据的方式。我们可以在我们的系统中定义API，以便它们可以与其他系统通信。

例如，我们可以在我们的Arduino固件中定义一个API，说明如何以及发送什么数据来使板上的LED开关。我们不会描述整个固件，但我们会向世界提供一个基本文档，精确地说明从互联网发送的格式和数据，例如，用于远程使用。那将是一个API。

## Twitter的API

Twitter，就像互联网上许多其他与社交网络相关的系统一样，提供了一个API。其他程序员可以使用它来获取数据，也可以发送数据。与Twitter API相关的所有数据规范都可以在[https://dev.twitter.com](https://dev.twitter.com)找到。

为了使用API，我们必须在Twitter开发者网站上创建一个应用程序。有一些特殊的设置安全参数，我们必须同意一些使用规则，这些规则尊重数据请求速率和其他技术规范。

我们可以通过访问[https://dev.twitter.com/apps/new](https://dev.twitter.com/apps/new)来创建一个应用程序。

这将为我们提供一些凭证信息，特别是访问令牌和令牌密钥。这些是必须按照某些协议使用才能访问API的字符字符串。

## 使用具有OAuth支持的Twitter库

*马克库·罗西*创建了一个非常强大且可靠的库，它嵌入OAuth支持，并旨在直接从Arduino发送推文。官方库网站是[http://www.markkurossi.com/ArduinoTwitter](http://www.markkurossi.com/ArduinoTwitter)。

这个库需要与具有比通常更多内存的板子一起使用。Arduino MEGA可以完美运行它。

OAuth是一种开放协议，允许以简单和标准的方法从Web、移动和桌面应用程序进行安全授权。这定义在[http://oauth.net](http://oauth.net)。

基本上，这是一种使第三方应用程序能够获得对HTTP服务的有限访问的方法。通过发送一些特定的字符字符串，我们可以授予对主机的访问权限，并使其与API通信。

这就是我们将要一起作为一个很好的示例来做的，你可以将其用于Web上的其他API。

### 从Twitter获取凭证

马克库的库实现了OAuth请求签名，但没有实现OAuth访问令牌检索流程。我们可以通过使用我们在创建应用程序的Twitter网站上提供的此指南来检索我们的令牌：[https://dev.twitter.com/docs/auth/tokens-devtwittercom](https://dev.twitter.com/docs/auth/tokens-devtwittercom)。

你需要随身携带访问令牌和访问令牌密钥，因为我们将它们包含在我们的固件中。

### 编写连接到Twitter的固件

马克库的库易于使用。以下是将Arduino连接到你的以太网网络以便直接发送推文的可能代码。

你可以在`Chapter11/tweetingButton/`中找到它。

[PRE8]

让我们在这里解释一下。请注意，这是一个包含我们已共同发现和学习的许多内容的代码：

+   带有去抖动系统的按钮按下

+   使用Arduino以太网盾片的以太网连接

+   Twitter库示例

我们首先包含大量的库头文件：

+   用于网络连接的SPI和以太网

+   Sha1用于凭证加密

+   Twitter库中用于时间和日期特定功能的时间

+   使用EEPROM在板子的EEPROM中存储凭证

+   Twitter库本身

然后，我们包括与按钮本身和防抖系统相关的变量。

我们配置网络参数。请注意，您必须根据您的网络和以太网屏蔽器在此处放置自己的元素。然后，我们定义 Twitter 的 IP 地址。

我们定义 `TWEET_DELTA` 常量以供以后使用，考虑到 Twitter API 使用禁止我们一次性发送过多推文。然后，我们存储我们的凭据。请使用与您在 Twitter 网站上创建的应用程序相关的凭据。最后，我们创建对象 twitter。

在 `setup()` 函数中，我们启动 `Serial` 连接以便向我们发送一些反馈。我们配置开关的数字引脚并启动以太网连接。然后，我们有了关于 Twitter 的所有魔法。我们首先选择由 Twitter API 文档本身定义的入口点。我们还需要在这里放置我们的访问令牌和令牌密钥。然后，我们有一个编译条件：`#if TOKEN_IN_MEMORY`。

`TOKEN_IN_MEMORY` 之前定义为 0 或 1。根据其值，编译以某种方式或另一种方式进行。

为了将凭据存储到板的 EEPROM 中，我们首先必须将值设置为 0。我们编译它并在板上运行。固件运行并将令牌写入内存。然后，我们将值更改为 1（因为令牌现在在内存中），我们编译它并在板上运行。从现在起，固件将读取 EEPROM 中的凭据。

然后，考虑到我们之前学到的内容，`loop()` 函数相当简单。

我们首先测试与 API 的 Twitter 连接是否正常。如果一切正常，我们将时间和最后一条推文的最后时间存储在一个初始值中。我们读取数字输入的防抖值。

如果我们按下按钮，我们会测试是否在 `TWEET_DELTA` 时间内完成。如果是这样，我们就符合 Twitter API 规则，可以发推文。

最后，我们在字符数组 `msg` 中存储一条消息。我们通过使用 `twitter.post_status()` 函数来发推文。在使用它时，我们还测试它返回的内容。如果它返回 `1`，这意味着推文已成功。通过串行监视器向用户提供此信息。

所有 API 提供商都以相同的方式工作。在这里，我们得到了我们使用的 Twitter 库的很大帮助，但还有其他库也适用于互联网上的其他服务。每个服务都提供了使用其 API 的完整文档。Facebook API 资源在此处可用：[https://developers.facebook.com/](https://developers.facebook.com/)。Google+ API 资源在此处可用：[https://developers.google.com/+/api/](https://developers.google.com/+/api/)。Instagram API 资源在此处可用：[http://instagram.com/developer](http://instagram.com/developer)。我们还可以找到很多其他资源。

# 摘要

在本章中，我们学习了如何扩展我们的Arduino板通信范围。我们以前习惯于进行非常局部的连接；现在我们能够将我们的板连接到互联网，并且有可能与整个地球进行通信。

我们描述了有线以太网、Wi-Fi、蓝牙连接，以及如何使用Twitter的API。

我们本可以描述使用无线电频率的Xbee板，但我更倾向于描述与IP相关的内容，因为我认为这是传输数据最安全的方式。当然，Xbee的屏蔽解决方案也是一个非常好的选择，我自己在许多项目中都使用过它。

在下一章中，我们将描述并深入研究Max 6框架。这是一个非常强大的编程工具，可以生成和解析数据，我们将解释如何将其与Arduino结合使用。
