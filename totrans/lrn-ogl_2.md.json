["```cpp\n#include <iostream>\n// GLEW\n#define GLEW_STATIC\n#include <GL/glew.h>\n// GLFW\n#include <GLFW/glfw3.h>\n// Window dimensions\nconst GLuint WIDTH = 800, HEIGHT = 600;\n```", "```cpp\n// Shaders\nconst GLchar* vertexShaderSource = \"#version 330 core\\n\"\n```", "```cpp\n\"layout (location = 0) in vec3 position;\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"gl_Position = vec4(position.x, position.y, position.z, 1.0);\\n\"\n\"}\\0\";\n```", "```cpp\nconst GLchar* fragmentShaderSource = \"#version 330 core\\n\"\n\"out vec4 color;\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"\n\"}\\n\\0\";\n```", "```cpp\n // The MAIN function, from here we start the application and run the game loop\n int main()\n {\n // Init GLFW\n glfwInit( );\n\n // Set all the required options for GLFW\n glfwWindowHint( GLFW_CONTEXT_VERSION_MAJOR, 3 );\n glfwWindowHint( GLFW_CONTEXT_VERSION_MINOR, 3 );\n glfwWindowHint( GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE );\n glfwWindowHint( GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE );\n\n glfwWindowHint( GLFW_RESIZABLE, GL_FALSE );\n\n // Create a GLFWwindow object that we can use for GLFW's functions\n GLFWwindow *window = glfwCreateWindow( WIDTH, HEIGHT, \"LearnOpenGL\", nullptr, nullptr );\n\n int screenWidth, screenHeight;\n glfwGetFramebufferSize( window, &screenWidth, &screenHeight );\n\n if ( nullptr == window )\n {\n std::cout << \"Failed to create GLFW window\" << std::endl;\n glfwTerminate( );\n\n return EXIT_FAILURE;\n }\n\n glfwMakeContextCurrent( window );\n// Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions\n glewExperimental = GL_TRUE;\n // Initialize GLEW to setup the OpenGL Function pointers\n if ( GLEW_OK != glewInit( ) )\n {\n std::cout << \"Failed to initialize GLEW\" << std::endl;\n return EXIT_FAILURE;\n }\n\n // Define the viewport dimensions\n glViewport( 0, 0, screenWidth, screenHeight );\n```", "```cpp\n // Build and compile our shader program\n // Vertex shader\n GLuint vertexShader = glCreateShader( GL_VERTEX_SHADER );\n glShaderSource( vertexShader, 1, &vertexShaderSource, NULL );\n```", "```cpp\nglCompileShader( vertexShader );\n // Check for compile time errors\n GLint success;\n GLchar infoLog[512];\n```", "```cpp\nglGetShaderiv( vertexShader, GL_COMPILE_STATUS, &success );\n```", "```cpp\nif ( !success )\n {\n glGetShaderInfoLog( vertexShader, 512, NULL, infoLog );\n std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n }\n```", "```cpp\n // Fragment shader\n GLuint fragmentShader = glCreateShader( GL_FRAGMENT_SHADER );\n glShaderSource( fragmentShader, 1, &fragmentShaderSource, NULL );\n glCompileShader( fragmentShader );\n\n // Check for compile time errors\n glGetShaderiv( fragmentShader,GL_COMPILE_STATUS, &success );\n\n if ( !success )\n {\n   glGetShaderInfoLog( fragmentShader,512, NULL, infoLog );\n   std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog <<    std::endl;\n }\n```", "```cpp\n // Link shaders\n GLuint shaderProgram = glCreateProgram( );\n glAttachShader( shaderProgram, vertexShader );\n glAttachShader( shaderProgram, fragmentShader );\n glLinkProgram( shaderProgram );\n```", "```cpp\n // Check for linking errors\n glGetProgramiv( shaderProgram, GL_LINK_STATUS, &success );\n\n if ( !success )\n {\n glGetProgramInfoLog( shaderProgram, 512, NULL, infoLog );\n std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << std::endl;\n }\nglDeleteShader( vertexShader );\nglDeleteShader( fragmentShader );\n```", "```cpp\n // Set up vertex data (and buffer(s)) and attribute pointers\n GLfloat vertices[] =\n {\n      -0.5f, -0.5f, 0.0f, // Left\n      0.5f, -0.5f, 0.0f,  // Right\n      0.0f, 0.5f, 0.0f    // Top\n };\n```", "```cpp\n GLuint VBO, VAO;\n glGenVertexArrays( 1, &VAO );\n glGenBuffers( 1, &VBO );\n```", "```cpp\n// Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).\n glBindVertexArray( VAO );\n\n glBindBuffer( GL_ARRAY_BUFFER, VBO );\n glBufferData( GL_ARRAY_BUFFER, sizeof( vertices ), vertices, GL_STATIC_DRAW );\n```", "```cpp\n glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof( GLfloat ), ( GLvoid * ) 0 );\n glEnableVertexAttribArray( 0 );\n```", "```cpp\nglBindBuffer( GL_ARRAY_BUFFER, 0 ); \n// Note that this is allowed, the call to glVertexAttribPointer //registered VBO as the currently bound vertex buffer object so //afterwards we can safely unbind\n\n glBindVertexArray( 0 ); \n// Unbind VAO (it's always a good thing to unbind any buffer/array //to prevent strange bugs)\n```", "```cpp\n // Game loop\n while ( !glfwWindowShouldClose( window ) )\n {\n // Check if any events have been activiated (key pressed, mouse moved //etc.) and call corresponding response functions\n\nglfwPollEvents( );\n\n // Render\n // Clear the colorbuffer\n glClearColor( 0.2f, 0.3f, 0.3f, 1.0f );\n glClear( GL_COLOR_BUFFER_BIT );\n\n // Draw our first triangle\n glUseProgram( shaderProgram );\n glBindVertexArray( VAO );\n glDrawArrays( GL_TRIANGLES, 0, 3 );\n glBindVertexArray( 0 );\n\n // Swap the screen buffers\n glfwSwapBuffers( window );\n }\n\n // Properly de-allocate all resources once they've outlived their purpose\n glDeleteVertexArrays( 1, &VAO );\n glDeleteBuffers( 1, &VBO );\n\n // Terminate GLFW, clearing any resources allocated by GLFW.\n glfwTerminate( );\n\n return EXIT_SUCCESS;\n }\n\n```", "```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 color;\nout vec3 ourColor;\nvoid main()\n{\n gl_Position = vec4(position, 1.0f);\n ourColor = color;\n}\n```", "```cpp\n#version 330 core\nin vec3 ourColor;\nout vec4 color;\nvoid main()\n{\n color = vec4(ourColor, 1.0f);\n}\n```", "```cpp\n #ifndef SHADER_H\n #define SHADER_H\n #include <string>\n #include <fstream>\n #include <sstream>\n #include <iostream>\n #include <GL/glew.h>\n```", "```cpp\nclass Shader\n {\n public:\n GLuint Program;\n // Constructor generates the shader on the fly\n Shader( const GLchar *vertexPath, const GLchar *fragmentPath )\n {\n```", "```cpp\n// 1\\. Retrieve the vertex/fragment source code from filePath\n std::string vertexCode;\n std::string fragmentCode;\n std::ifstream vShaderFile;\n std::ifstream fShaderFile;\n```", "```cpp\n// ensures ifstream objects can throw exceptions:\n vShaderFile.exceptions ( std::ifstream::badbit );\n fShaderFile.exceptions ( std::ifstream::badbit );\n```", "```cpp\ntry\n {\n      // Open files\n      vShaderFile.open( vertexPath );\n      fShaderFile.open( fragmentPath );\n      std::stringstream vShaderStream, fShaderStream;\n      // Read file's buffer contents into streams\n      vShaderStream << vShaderFile.rdbuf( );\n      fShaderStream << fShaderFile.rdbuf( );\n      // close file handlers\n      vShaderFile.close( );\n      fShaderFile.close( );\n      // Convert stream into string\n      vertexCode = vShaderStream.str( );\n      fragmentCode = fShaderStream.str( );\n }\n\ncatch ( std::ifstream::failure e )\n {\n     std::cout << \"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ\" << std::endl;\n }\n```", "```cpp\n const GLchar *vShaderCode = vertexCode.c_str( );\n const GLchar *fShaderCode = fragmentCode.c_str( );\n\n // Compile shaders\n\n GLuint vertex, fragment;\n GLint success;\n GLchar infoLog[512];\n\n// Vertex Shader\n vertex = glCreateShader( GL_VERTEX_SHADER );\n glShaderSource( vertex, 1, &vShaderCode, NULL );\n glCompileShader( vertex );\n // Print compile errors if any\n glGetShaderiv( vertex, GL_COMPILE_STATUS, &success );\n if ( !success )\n {\n glGetShaderInfoLog( vertex, 512, NULL, infoLog );\n std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n }\n\n// Fragment Shader\n fragment = glCreateShader( GL_FRAGMENT_SHADER );\n glShaderSource( fragment, 1, &fShaderCode, NULL );\n glCompileShader( fragment );\n // Print compile errors if any\n glGetShaderiv( fragment, GL_COMPILE_STATUS, &success );\n if ( !success )\n {\n    glGetShaderInfoLog( fragment, 512, NULL, infoLog );\n    std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n }\n\n// Shader Program\n this->Program = glCreateProgram( );\n glAttachShader( this->Program, vertex );\n glAttachShader( this->Program, fragment );\n glLinkProgram( this->Program );\n // Print linking errors if any\n glGetProgramiv( this->Program, GL_LINK_STATUS, &success );\n if (!success)\n {\n    glGetProgramInfoLog( this->Program, 512, NULL, infoLog );\n    std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << std::endl;\n }\n\n// Delete the shaders as they're linked into our program now and no //longer necessery\n glDeleteShader( vertex );\n glDeleteShader( fragment );\n\n }\n```", "```cpp\n// Uses the current shader\n void Use( )\n {\n glUseProgram( this->Program );\n }\n };\n#endif\n```", "```cpp\n#include \"Shader.h\"\n```", "```cpp\n// Build and compile our shader program\n Shader ourShader( \"core.vs\", \"core.frag\" );\n```", "```cpp\nGLfloat vertices[] =\n {\n     // Positions          // Colors\n     0.5f, -0.5f, 0.0f,    1.0f, 0.0f, 0.0f,  // Bottom Right\n     -0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,  // Bottom Left\n     0.0f, 0.5f, 0.0f,     0.0f, 0.0f, 1.0f   // Top\n };\n```", "```cpp\n// Position attribute\n glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof( GLfloat ), ( GLvoid * ) 0 );\n glEnableVertexAttribArray( 0 );\n // Color attribute\n glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 1 );\n```", "```cpp\nglBindBuffer( GL_ARRAY_BUFFER, 0 );\n```", "```cpp\nourShader.Use( );\n```", "```cpp\n#include SOIL2/SOIL2.h\n```", "```cpp\n// enable alpha support\n glEnable( GL_BLEND );\n glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );\n```", "```cpp\n// Set up vertex data (and buffer(s)) and attribute pointers\n GLfloat vertices[] =\n {\n // Positions         // Colors             // Texture Coords\n 0.5f, 0.5f, 0.0f,    1.0f, 0.0f, 0.0f,     1.0f, 1.0f, // Top Right\n 0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,     1.0f, 0.0f, // Bottom Right\n-0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,     0.0f, 0.0f, // Bottom Left\n-0.5f, 0.5f, 0.0f,    1.0f, 1.0f, 0.0f,     0.0f, 1.0f  // Top Left\n }; \n```", "```cpp\nGLuint indices[] =\n { // Note that we start from 0!\n 0, 1, 3, // First Triangle\n 1, 2, 3 // Second Triangle\n };\n```", "```cpp\nGLuint VBO, VAO, EBO;\n```", "```cpp\n glGenVertexArrays(1,&VAO);\n glGenBuffers(1,&VBO );\n//Generating EBO\n glGenBuffers(1,&EBO );\n\n glBindVertexArray( VAO );\n\n glBindBuffer( GL_ARRAY_BUFFER, VBO );\n glBufferData( GL_ARRAY_BUFFER, sizeof( vertices ), vertices, GL_STATIC_DRAW );\n //Binding the EBO\n glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, EBO );\n glBufferData( GL_ELEMENT_ARRAY_BUFFER, sizeof( indices ), indices, GL_STATIC_DRAW );\n```", "```cpp\n // Position attribute\n glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof( GLfloat ), ( GLvoid * ) 0 );\n glEnableVertexAttribArray(0);\n // Color attribute\n glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray(1);\n // Texture Coordinate attribute\n glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof( GLfloat ), ( GLvoid * )( 6 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 2 );\n```", "```cpp\nglBindVertexArray( 0 ); // Unbind VAO\n\n // Load and create a texture\n GLuint texture;\n int width, height;\n // Texture\n glGenTextures( 1, &texture );\n glBindTexture( GL_TEXTURE_2D, texture );\n```", "```cpp\n// Set our texture parameters\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );\n```", "```cpp\n// Set texture filtering\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n```", "```cpp\n unsigned char *image = SOIL_load_image( \"res/images/image1.jpg\", &width, &height, 0, SOIL_LOAD_RGBA );\n```", "```cpp\n// Load, create texture \nglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image );\n```", "```cpp\n//Generate mipmaps\nglGenerateMipmap( GL_TEXTURE_2D );\nSOIL_free_image_data( image );\nglBindTexture( GL_TEXTURE_2D, 0 );\n```", "```cpp\n// Draw the triangle\n ourShader.Use( );\n glActiveTexture( GL_TEXTURE0 );\n glBindTexture( GL_TEXTURE_2D, texture );\n glUniform1i( glGetUniformLocation( ourShader.Program, \"ourTexture\" ), 0 );\n\n```", "```cpp\n // Draw container\n glBindVertexArray( VAO );\n glDrawElements( GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0 );\n glBindVertexArray( 0 );\n```", "```cpp\n// Properly de-allocate all resources once they've outlived their purpose\n glDeleteVertexArrays( 1, &VAO );\n glDeleteBuffers( 1, &VBO );\n glDeleteBuffers( 1, &EBO );\n\n // Terminate GLFW, clearing any resources allocated by GLFW.\n glfwTerminate( );\n```", "```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 color;\nlayout (location = 2) in vec2 texCoord;\nout vec3 ourColor;\nout vec2 TexCoord;\nvoid main()\n{\n gl_Position = vec4(position, 1.0f);\n ourColor = color;\n // We swap the y-axis by substracing our coordinates from 1\\. This is done because most images have the top y-axis inversed with OpenGL's top y-axis.\n // TexCoord = texCoord;\n TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);\n}\n```", "```cpp\n#version 330 core\nin vec3 ourColor;\nin vec2 TexCoord;\nout vec4 color;\n// Texture samplers\nuniform sampler2D ourTexture1;\nvoid main()\n{\n // Linearly interpolate between both textures (second texture is //only slightly combined)\n color = texture(ourTexture1, TexCoord);\n}\n```"]