<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-298" class="chapter-number"><a id="_idTextAnchor298"/>8</h1>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor299"/>Advanced Unordered Associative Container Usage</h1>
			<p>While our journey with ordered associative containers has provided us with the prowess of relationship mapping and the power of ordering, it is time to venture into a domain that prioritizes speed over sorted behavior: unordered associative containers. As their name suggests, these containers do not guarantee any specific order of their elements, but they make up for it with potentially faster <span class="No-Break">access times.</span></p>
			<p>In the world of computing, there are always trade-offs. Unordered associative containers might relinquish the beauty of order, but in many scenarios, they make up for it with speed, especially when hashing operates at its best. Whether you’re developing a high-frequency trading system, a caching mechanism, or a real-time multiplayer game backend, understanding when to harness the power of unordered associated containers can make <span class="No-Break">a difference.</span></p>
			<p>This chapter provides references for the <span class="No-Break">following containers:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">std::unordered_set</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::unordered_map</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::unordered_multiset</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::unordered_multimap</strong></span></li>
			</ul>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor300"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub: </p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor301"/>std::unordered_set</h1>
			<p>This <a id="_idIndexMarker484"/>container is akin to <strong class="source-inline">std::set</strong> but with a twist: it does not maintain the elements in any particular order. Instead, it employs a hashing mechanism to access its elements quickly. This hash-based approach can offer constant time average complexity for most operations, given a good <span class="No-Break">hash function.</span></p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor302"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::unordered_set</strong> is a <a id="_idIndexMarker485"/>hash-based container in the C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) that stores unique elements in no particular order. Its core strengths include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Providing average constant-time operations for insertions, deletions, <span class="No-Break">and searches</span></li>
				<li>Handling non-trivial data <span class="No-Break">types effectively</span></li>
			</ul>
			<p>You should<a id="_idIndexMarker486"/> choose <strong class="source-inline">std::unordered_set</strong> in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When you need rapid checks for the existence <span class="No-Break">of elements</span></li>
				<li>When the order of elements is not <span class="No-Break">a concern</span></li>
				<li>When frequent insertions and deletions <span class="No-Break">are expected</span></li>
			</ul>
			<p>However, if the ordering of elements is crucial, <strong class="source-inline">std::set</strong> might be a <span class="No-Break">better alternative.</span></p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor303"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker487"/> some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::unordered_set</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Fast membership checks</strong>: If the primary goal is determining whether a particular item exists in a collection, <strong class="source-inline">std::unordered_set</strong> is <span class="No-Break">your candidate.</span></li>
				<li><strong class="bold">Eliminating duplicates</strong>: You can use <strong class="source-inline">std::unordered_set</strong>  to create a collection of unique items from an <span class="No-Break">existing dataset.</span></li>
				<li><strong class="bold">High-volume data storage</strong>: You can use <strong class="source-inline">std::unordered_set</strong>  where quick insertions and deletions are more critical than <span class="No-Break">maintaining order.</span></li>
				<li><strong class="bold">When the order doesn’t matter</strong>: Prefer <strong class="source-inline">std::unordered_set</strong> over <strong class="source-inline">std::set</strong> when<a id="_idIndexMarker488"/> the order of elements doesn’t matter since <strong class="source-inline">std::unordered_set</strong> provides faster lookup, insertion, and removal operations. However, <strong class="source-inline">std::unordered_set</strong> may use more memory <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">std::set</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor304"/>Performance</h2>
			<p>The <a id="_idIndexMarker489"/>algorithmic performance of <strong class="source-inline">std::unordered_set</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em> due to potential <span class="No-Break">hash collisions</span></li>
				<li><strong class="bold">Deletion</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em> due to potential <span class="No-Break">hash collisions</span></li>
				<li><span class="No-Break"><strong class="bold">Access</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than ordered containers due to <span class="No-Break">hashing mechanisms</span></li>
			</ul>
			<p>The key trade-off here revolves around average versus worst-case scenarios, especially concerning <span class="No-Break">hash collisions.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor305"/>Memory management</h2>
			<p><strong class="source-inline">std::unordered_set</strong> manages<a id="_idIndexMarker490"/> its memory using a series of buckets to store elements. The number of buckets can grow, usually when the load factor exceeds a certain threshold. Using custom allocators can help tailor <span class="No-Break">this behavior.</span></p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor306"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker491"/>reading is safe. However, operations that modify the set (such as insertions or deletions) require external synchronization mechanisms, such <span class="No-Break">as mutexes.</span></p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor307"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::unordered_multiset</strong> is a<a id="_idIndexMarker492"/> close relative, allowing multiple instances of an element to be used. If ordered storage is vital, <strong class="source-inline">std::set</strong> and <strong class="source-inline">std::multiset</strong> come <span class="No-Break">into play.</span></p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor308"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker493"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: This is not inherently supported as <strong class="source-inline">std::unordered_set</strong> is <span class="No-Break">not ordered.</span></li>
				<li><strong class="bold">Searching</strong>: It has an average <em class="italic">O(1)</em> time due to hashing, but its worst-case scenario can be <em class="italic">O(n)</em> with <span class="No-Break">poor hashing.</span></li>
			</ul>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor309"/>Special interface and member functions</h2>
			<p>Some handy <a id="_idIndexMarker494"/>member functions to note are<a id="_idIndexMarker495"/> <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: This allows elements to be <span class="No-Break">constructed directly.</span></li>
				<li><strong class="source-inline">bucket</strong>: This can retrieve the bucket number for a <span class="No-Break">given element.</span></li>
				<li><strong class="source-inline">load_factor</strong> and <strong class="source-inline">max_load_factor</strong>: These are required for managing <span class="No-Break">performance characteristics.</span></li>
			</ul>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor310"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker496"/> to <strong class="source-inline">std::set</strong>, <strong class="source-inline">std::unordered_set</strong> generally offers faster operations but loses the inherent order and might have a higher <span class="No-Break">memory overhead.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor311"/>Interactions with algorithms</h2>
			<p>Due to its <a id="_idIndexMarker497"/>unordered nature, <strong class="source-inline">std::unordered_set</strong> might not be the best candidate for STL algorithms that require ordered data. However, algorithms revolving around unique elements can <span class="No-Break">fit well.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor312"/>Exceptions</h2>
			<p>Operations can<a id="_idIndexMarker498"/> throw exceptions if allocations fail or if hash functions throw. Ensure your hash functions are exception-free to guarantee the container’s <span class="No-Break">exception safety.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor313"/>Customization</h2>
			<p>Custom hash<a id="_idIndexMarker499"/> functions and equality predicates can be applied to fine-tune the container’s behavior for specific data types. Moreover, custom allocators can also be beneficial in <span class="No-Break">some scenarios.</span></p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor314"/>Example</h2>
			<p><strong class="source-inline">std::unordered_set</strong> stores<a id="_idIndexMarker500"/> unique elements in no particular order. The primary operations it supports are insertion, deletion, and member checking. Unlike <strong class="source-inline">std::set</strong>, which uses a balanced binary tree internally, <strong class="source-inline">std::unordered_set</strong> uses a hash table, making the average insertion, deletion, and search complexities <em class="italic">O(1)</em>, albeit with higher constants and worse <span class="No-Break">worst-case performance.</span></p>
			<p>The following code shows an example demonstrating best practices when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_set</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
void displaySet(const std::unordered_set&lt;int&gt; &amp;set) {
  for (const int &amp;num : set) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; '\n';
}
int main() {
  std::unordered_set&lt;int&gt; numbers;
  for (int i = 0; i &lt; 10; ++i) { numbers.insert(i); }
  displaySet(numbers);
  int searchValue = 5;
  if (numbers.find(searchValue) != numbers.end()) {
    std::cout &lt;&lt; searchValue &lt;&lt; " found in the set."
              &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; searchValue &lt;&lt; " not found in the set."
              &lt;&lt; '\n';
  }
  numbers.erase(5);
  displaySet(numbers);
  std::cout &lt;&lt; "Size: " &lt;&lt; numbers.size() &lt;&lt; '\n';
  std::cout &lt;&lt; "Load factor: " &lt;&lt; numbers.load_factor()
            &lt;&lt; '\n';
  numbers.rehash(50);
  std::cout &lt;&lt; "Number of buckets after rehash: "
            &lt;&lt; numbers.bucket_count() &lt;&lt; '\n';
  std::vector&lt;int&gt; moreNumbers = {100, 101, 102, 103};
  numbers.insert(moreNumbers.begin(), moreNumbers.end());
  displaySet(numbers);
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker501"/><span class="No-Break">example output:</span></p>
			<pre class="console">
9 8 7 6 5 4 3 2 1 0
5 found in the set.
9 8 7 6 4 3 2 1 0
Size: 9
Load factor: 0.818182
Number of buckets after rehash: 53
103 102 101 100 9 8 7 6 4 3 2 1 0</pre>			<p>Here are some key takeaways from the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li><strong class="source-inline">std::unordered_set</strong> allows rapid insertions, deletions, <span class="No-Break">and lookups.</span></li>
				<li><strong class="source-inline">find</strong> can be used to check for the existence of <span class="No-Break">an element.</span></li>
				<li>The <strong class="source-inline">rehash</strong> method can change the number of buckets in the underlying hash table, which might help when you know the number of elements in advance and wish to reduce the overhead <span class="No-Break">of rehashing.</span></li>
				<li>Always be <a id="_idIndexMarker502"/>cautious about the load factor (covered in the following Best practices section) and consider rehashing when necessary to maintain <span class="No-Break">efficient performance.</span></li>
				<li>Remember that the order of elements in <strong class="source-inline">std::unordered_set</strong> is not guaranteed. The order can change over time as elements are inserted <span class="No-Break">or deleted.</span></li>
			</ul>
			<p>Using <strong class="source-inline">std::unordered_set</strong> is appropriate when you need rapid lookups and are not worried about the order of elements. If ordering is essential, you might want to consider using <span class="No-Break"><strong class="source-inline">std::set</strong></span><span class="No-Break"> instead.</span></p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor315"/>Best practices</h2>
			<p>Let’s explore the<a id="_idIndexMarker503"/> best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_set</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Order assumptions</strong>: <strong class="source-inline">std::unordered_set</strong> is designed without the need to maintain any specific order of its elements. Never rely on any sequential consistency within <span class="No-Break">this container.</span></li>
				<li><strong class="bold">Hash collision awareness</strong>: Hash collisions can detrimentally affect performance, transforming average-case constant-time operations into worst-case linear-time operations. Always be aware of this, especially when designing hash functions or handling <span class="No-Break">large datasets.</span></li>
				<li><strong class="bold">Bucket count and load factor management</strong>: The performance of <strong class="source-inline">std::unordered_set</strong> can be intimately tied to its bucket count and load factor. Consider the load factor and rehashing policies of <strong class="source-inline">std::unordered_set</strong> for performance tuning. The <strong class="bold">load factor</strong> is the ratio of the number of elements in the container to the size of the bucket array. If the load factor is too high, too many elements are in each bucket, which can slow down lookup and insertion operations. On the other hand, if the load factor is too low, the bucket array is too large, which can waste memory. Ensure <a id="_idIndexMarker504"/>you understand and monitor <span class="No-Break">the following:</span><ul><li><strong class="source-inline">bucket_count()</strong>: The current number <span class="No-Break">of buckets</span></li><li><strong class="source-inline">load_factor()</strong>: The current number of elements divided by the <span class="No-Break">bucket count</span></li><li><strong class="source-inline">max_load_factor()</strong>: The load factor threshold, which, when surpassed, triggers <span class="No-Break">a rehash</span></li></ul></li>
				<li><strong class="bold">Hash function customization</strong>: The default hash function might not always provide optimal performance, especially for user-defined types. Consider implementing custom hash functions using the C++11 <strong class="source-inline">std::hash</strong> standard template specialization. This allows hashing behavior to <span class="No-Break">be fine-tuned.</span></li>
				<li><strong class="bold">Rehashing</strong>: Monitor the load factor and proactively invoke <strong class="source-inline">rehash()</strong> or <strong class="source-inline">reserve()</strong> when necessary. This can help prevent unexpected performance drops, especially when inserting <span class="No-Break">new elements.</span></li>
				<li><strong class="bold">Uniform hash distribution</strong>: A good hash function will distribute values uniformly across buckets, minimizing the chance of collisions. Ensure your hash function achieves this by testing its distribution with sample data before deploying it in performance-critical applications. Use a well-designed hash function that distributes elements evenly across the buckets to avoid <span class="No-Break">performance degradation.</span></li>
				<li><strong class="bold">Ordered container alternatives</strong>: If element ordering becomes necessary for your application, <strong class="source-inline">std::unordered_set</strong> is not the ideal choice. Consider migrating to <strong class="source-inline">std::set</strong> or leveraging other ordered containers within <span class="No-Break">the STL.</span></li>
				<li><strong class="bold">Concurrency concerns</strong>: When using <strong class="source-inline">std::unordered_set</strong> in multi-threaded applications, ensure proper synchronization mechanisms are in place. Concurrent reads are safe, but writes or simultaneous reads and writes demand <span class="No-Break">external synchronization.</span></li>
				<li><strong class="bold">Size and capacity management</strong>: Although <strong class="source-inline">std::unordered_set</strong> dynamically manages its size, it is beneficial to <a id="_idIndexMarker505"/>use functions such as <strong class="source-inline">reserve()</strong> if you have an estimate of the number of elements to be stored. This can help in reducing the number of rehashes and <span class="No-Break">improve performance.</span></li>
				<li><strong class="bold">Erase elements efficiently</strong>: Utilize the <strong class="source-inline">erase</strong> member function judiciously. Remember that erasing by the iterator is faster (<em class="italic">O(1)</em>) than erasing by the key value (<em class="italic">O(n)</em> in the <span class="No-Break">worst case.</span></li>
				<li><strong class="bold">Memory footprint</strong>: Be aware that <strong class="source-inline">std::unordered_set</strong>, due to its hashing mechanism, might have a higher memory overhead than other containers. Consider this aspect, especially in <span class="No-Break">memory-sensitive applications.</span></li>
			</ul>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor316"/>std::unordered_map</h1>
			<p>Think of this container<a id="_idIndexMarker506"/> as an unsorted version of <strong class="source-inline">std::map</strong>. It associates keys with values but without imposing any order. Instead, it banks on hashing for <span class="No-Break">swift operations.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor317"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::unordered_map</strong> is a <a id="_idIndexMarker507"/>hash table-based key-value container in the STL. Its core strengths are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Fast average-case key-based access, insertion, <span class="No-Break">and removal</span></li>
				<li>Ability to maintain a <span class="No-Break">key-value association</span></li>
			</ul>
			<p>This container is the go-to in the <span class="No-Break">following circumstances:</span></p>
			<ul>
				<li>When insertions, deletions, and lookups must be swift <span class="No-Break">on average</span></li>
				<li>When the order of elements isn’t <span class="No-Break">a concern</span></li>
			</ul>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor318"/>Ideal use cases</h2>
			<p>The following are some <a id="_idIndexMarker508"/>of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::unordered_map</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Fast associative lookups</strong>: When you need quick access to values based on unique keys, <strong class="source-inline">std::unordered_map</strong> provides average constant-time complexity for <strong class="source-inline">search</strong>, <strong class="source-inline">insert</strong>, and <span class="No-Break"><strong class="source-inline">delete</strong></span><span class="No-Break"> operations</span></li>
				<li><strong class="bold">Cache systems</strong>: When implementing cache mechanisms where the priority is rapid key-based access over the order of items, <strong class="source-inline">std::unordered_map</strong> <span class="No-Break">is ideal</span></li>
				<li><strong class="bold">Frequency analysis</strong>: For tasks such as counting the occurrence of words in a document or the number of visits to a website from unique IP addresses, <strong class="source-inline">std::unordered_map</strong> allows you to map items to their occurrence <span class="No-Break">counts efficiently</span></li>
				<li><strong class="bold">Grouping or bucketing</strong>: In scenarios such as classifying objects or grouping records based on certain attributes, <strong class="source-inline">std::unordered_map</strong> can map the attribute to a list or set <span class="No-Break">of objects</span></li>
				<li><strong class="bold">Dynamic configuration</strong>: In applications that require dynamic settings that can be modified at runtime, <strong class="source-inline">std::unordered_map</strong> can associate setting keys with their current values for quick lookups <span class="No-Break">and modifications</span></li>
				<li><strong class="bold">Database indexing</strong>: While traditional databases have indexing mechanisms, for simpler or in-memory databases, <strong class="source-inline">std::unordered_map</strong> can serve as an efficient index for quick record access based on <span class="No-Break">unique identifiers</span></li>
				<li><strong class="bold">Real-time analytics</strong>: In real-time systems that analyze and categorize streaming data, <strong class="source-inline">std::unordered_map</strong> offers an efficient way to update and access data categories or counters based on <span class="No-Break">unique keys</span></li>
				<li><strong class="bold">Networking applications</strong>: For tasks such as tracking the number of packets sent<a id="_idIndexMarker509"/> from different network nodes or routing tables in networking applications, <strong class="source-inline">std::unordered_map</strong> provides an efficient structure to handle <span class="No-Break">key-value pairs</span></li>
				<li><strong class="bold">Game scoreboards</strong>: In gaming, where scores or the attributes of players need to be constantly updated and retrieved based on player IDs or names, <strong class="source-inline">std::unordered_map</strong> <span class="No-Break">proves invaluable</span></li>
				<li><strong class="bold">Resource management</strong>: In systems or applications that need to manage resources, such as thread pools or connection pools, <strong class="source-inline">std::unordered_map</strong> can associate resource keys with their status <span class="No-Break">or attributes</span></li>
			</ul>
			<p>To summarize, <strong class="source-inline">std::unordered_map</strong> is optimal for scenarios that demand quick associative lookups, insertions, and deletions without needing the keys to maintain any specific order. If a key’s sequence or sorted nature is a priority, structures such as <strong class="source-inline">std::map</strong> would be <span class="No-Break">more suitable.</span></p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor319"/>Performance</h2>
			<p>The <a id="_idIndexMarker510"/>algorithmic performance of <strong class="source-inline">std::unordered_map</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(1)</em> average-case, <span class="No-Break"><em class="italic">O(n)</em></span><span class="No-Break"> worst-case</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(1)</em> average-case, <span class="No-Break"><em class="italic">O(n)</em></span><span class="No-Break"> worst-case</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(1)</em> average-case, <em class="italic">O(n)</em> worst-case due to potential <span class="No-Break">hash collisions</span></li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than ordered map counterparts due to the <span class="No-Break">hashing infrastructure</span></li>
			</ul>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor320"/>Memory management</h2>
			<p><strong class="source-inline">std::unordered_map</strong> manages<a id="_idIndexMarker511"/> its memory automatically, resizing when load factors exceed certain thresholds. Allocators can offer finer control over <span class="No-Break">this process.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor321"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker512"/>reading is safe. However, modifications or mixed read-writes necessitate external synchronization, such as <span class="No-Break">using mutexes.</span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor322"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::map</strong> is the ordered <a id="_idIndexMarker513"/>counterpart, providing log(n) guarantees at the cost of maintaining order. Based on your requirements, decide whether you need order or <span class="No-Break">average-case speed.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor323"/>Sorting and searching complexity</h2>
			<p>Its<a id="_idIndexMarker514"/> sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Not applicable as <strong class="source-inline">std::unordered_map</strong> is <span class="No-Break">inherently unordered</span></li>
				<li><strong class="bold">Searching</strong>: Fast <em class="italic">O(1)</em> average-case <span class="No-Break">key-based lookups</span></li>
			</ul>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor324"/>Special interface and member functions</h2>
			<p>Apart from the <a id="_idIndexMarker515"/>standard functions (<strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, <strong class="source-inline">find</strong>), become <a id="_idIndexMarker516"/>familiar with <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: Constructs key-value pairs <span class="No-Break">in place</span></li>
				<li><strong class="source-inline">bucket_count</strong>: Returns the number <span class="No-Break">of buckets</span></li>
				<li><strong class="source-inline">load_factor</strong>: Provides the current <span class="No-Break">load factor</span></li>
			</ul>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor325"/>Comparisons</h2>
			<p>Compared to <strong class="source-inline">std::map</strong>, <strong class="source-inline">std::unordered_map</strong> trades order for faster average-case operations. The<a id="_idIndexMarker517"/> unordered variant often outperforms in scenarios where constant order <span class="No-Break">isn’t vital.</span></p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor326"/>Interactions with algorithms</h2>
			<p>Most STL algorithms<a id="_idIndexMarker518"/> that work with sequences aren’t directly applicable to key-value map structures. Still, the container provides methods that are optimized for its <span class="No-Break">use case.</span></p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor327"/>Exceptions</h2>
			<p>Failures in memory <a id="_idIndexMarker519"/>allocation or the hash function can throw exceptions. Some operations, such as <strong class="source-inline">at()</strong>, can throw <strong class="source-inline">std::out_of_range</strong>. It’s crucial to ensure exception safety, especially during insertions <span class="No-Break">or emplacements.</span></p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor328"/>Customization</h2>
			<p>You can supply <a id="_idIndexMarker520"/>custom hash functions and key equality functions to optimize further or adapt behavior. Additionally, custom allocators are available for memory <span class="No-Break">management tweaks.</span></p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor329"/>Example</h2>
			<p><strong class="source-inline">std::unordered_map</strong> is a container <a id="_idIndexMarker521"/>that associates keys with values. It is similar to <strong class="source-inline">std::map</strong>, but while <strong class="source-inline">std::map</strong> maintains its elements in a sorted manner (based on keys), <strong class="source-inline">std::unordered_map</strong> does not maintain any order. Internally, it uses a hash table, which gives it an <em class="italic">O(1)</em> complexity for insertions, deletions, <span class="No-Break">and lookups.</span></p>
			<p>The following code shows an example demonstrating best practices when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_map</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
void displayMap(
    const std::unordered_map&lt;std::string, int&gt; &amp;map) {
  for (const auto &amp;[key, value] : map) {
    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; '\n';
  }
}
int main() {
  std::unordered_map&lt;std::string, int&gt; ageMap;
  ageMap[„Lisa"] = 28;
  ageMap[„Corbin"] = 25;
  ageMap[„Aaron"] = 30;
  std::cout &lt;&lt; "Corbin's age: " &lt;&lt; ageMap["Corbin"]
            &lt;&lt; '\n';
  if (ageMap.find("Daisy") == ageMap.end()) {
    std::cout &lt;&lt; "Daisy not found in the map." &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "Daisy's age: " &lt;&lt; ageMap["Daisy"]
              &lt;&lt; '\n';
  }
  ageMap["Lisa"] = 29;
  std::cout &lt;&lt; "Lisa's updated age: " &lt;&lt; ageMap["Lisa"]
            &lt;&lt; '\n';
  displayMap(ageMap);
  std::cout &lt;&lt; "Load factor: " &lt;&lt; ageMap.load_factor()
            &lt;&lt; '\n';
  std::cout &lt;&lt; "Bucket count: " &lt;&lt; ageMap.bucket_count()
            &lt;&lt; '\n';
  ageMap.rehash(50);
  std::cout &lt;&lt; "Bucket count after rehash:"
            &lt;&lt; ageMap.bucket_count() &lt;&lt; '\n';
  // Remove an entry
  ageMap.erase("Aaron");
  displayMap(ageMap);
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker522"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Corbin's age: 25
Daisy not found in the map.
Lisa's updated age: 29
Aaron: 30
Corbin: 25
Lisa: 29
Load factor: 0.6
Bucket count: 5
Bucket count after rehash:53
Corbin: 25
Lisa: 29</pre>			<p>Here are some <a id="_idIndexMarker523"/>key takeaways from the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>Use the <strong class="source-inline">operator[]</strong> or the <strong class="source-inline">insert</strong> method to add elements to the map. Note that using an index operator on a non-existent key will create it with a <span class="No-Break">default value.</span></li>
				<li>The <strong class="source-inline">find</strong> method checks for the existence of a key. It’s more efficient than using the <strong class="source-inline">index</strong> operator when you want to check a key’s existence without <span class="No-Break">potential insertion.</span></li>
				<li>Always be aware of the map’s load factor and consider rehashing if necessary to maintain <span class="No-Break">efficient performance.</span></li>
				<li>As with <strong class="source-inline">std::unordered_set</strong>, the order of elements in <strong class="source-inline">std::unordered_map</strong> is not guaranteed. It can change as elements are inserted <span class="No-Break">or removed.</span></li>
			</ul>
			<p><strong class="source-inline">std::unordered_map</strong> is suitable when you need quick key-based access and don’t care about the order of elements. If ordering is essential, then <strong class="source-inline">std::map</strong> would be a more <span class="No-Break">appropriate choice.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor330"/>Best practices</h2>
			<p>Let’s explore the <a id="_idIndexMarker524"/>best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_map</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Element order is not guaranteed</strong>: Do not assume the map maintains <span class="No-Break">element order.</span></li>
				<li><strong class="bold">Beware of hash collisions</strong>: Ensure you account for potential worst-case performance in <span class="No-Break">hash-collision scenarios.</span></li>
				<li><strong class="bold">Monitor bucket count and load factors</strong>: Be mindful of the bucket count and load factors in <strong class="source-inline">std::unordered_map</strong> to maintain optimal performance. Regularly check the load factor and consider rehashing <span class="No-Break">if necessary.</span></li>
				<li><strong class="bold">Use custom hash functions</strong>: Employ suitable hash functions for your key type. The<a id="_idIndexMarker525"/> performance of <strong class="source-inline">std::unordered_map</strong> is highly dependent on the effectiveness of the hash function used. A poorly designed hash function can lead to poor performance due to cache misses and collision <span class="No-Break">resolution overhead.</span></li>
				<li><strong class="bold">Use custom allocators</strong>: Use custom allocators for <strong class="source-inline">std::unordered_map</strong> to improve memory efficiency, particularly in scenarios with high insertions <span class="No-Break">and deletions.</span></li>
				<li><strong class="bold">Check for an existing key</strong>: Always check for an existing key before insertion to <span class="No-Break">avoid overwriting.</span></li>
				<li><strong class="bold">Use emplace</strong>: Use <strong class="source-inline">emplace</strong> to construct entries in place, <span class="No-Break">reducing overhead.</span></li>
				<li><strong class="bold">Avoid default initialization</strong>: Using the default initialization in <strong class="source-inline">std::unordered_map</strong> is expensive when using <strong class="source-inline">operator[]</strong> for accessing elements, which can be a <span class="No-Break">performance pitfall.</span></li>
			</ul>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor331"/>std::unordered_multiset</h1>
			<p>This container is a<a id="_idIndexMarker526"/> flexible counterpart to <strong class="source-inline">std::unordered_set</strong>, allowing multiple occurrences of an element. It amalgamates the speed of hashing with the liberty of <span class="No-Break">non-unique elements.</span></p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor332"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::unordered_multiset</strong> is a hash table-based container that allows you to store multiple<a id="_idIndexMarker527"/> equivalent items in an unordered manner. Its primary attractions are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Quick average-case insertion and <span class="No-Break">lookup times</span></li>
				<li>The ability to store multiple items with the <span class="No-Break">same value</span></li>
			</ul>
			<p>It’s particularly <a id="_idIndexMarker528"/>suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When the order of elements <span class="No-Break">doesn’t matter</span></li>
				<li>When you anticipate having multiple elements with the <span class="No-Break">same value</span></li>
				<li>When you want average-case constant time complexity for insertions <span class="No-Break">and lookups</span></li>
			</ul>
			<p>When searching for a container where duplicates are permissible and order isn’t crucial, <strong class="source-inline">std::unordered_multiset</strong> is a <span class="No-Break">compelling choice.</span></p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor333"/>Ideal use cases</h2>
			<p>The following <a id="_idIndexMarker529"/>are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::unordered_multiset</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Non-unique element storage</strong>: When storing elements where duplicates are allowed and the order is not important, <strong class="source-inline">std::unordered_multiset</strong> is suitable. It permits the storage of multiple <span class="No-Break">identical elements.</span></li>
				<li><strong class="bold">Frequency distribution analysis</strong>: For tasks such as identifying the distribution of values, <strong class="source-inline">std::unordered_multiset</strong> can be an efficient structure where each unique value is stored alongside <span class="No-Break">its duplicates.</span></li>
				<li><strong class="bold">Collisions in hashing mechanisms</strong>: In applications that utilize hashing, <strong class="source-inline">std::unordered_multiset</strong> can be useful for managing hash collisions by storing collided <span class="No-Break">items together.</span></li>
				<li><strong class="bold">Networking</strong>: When analyzing packets with duplicate signatures or patterns, <strong class="source-inline">std::unordered_multiset</strong> can store these repeating patterns for <span class="No-Break">further analysis.</span></li>
				<li><strong class="bold">Real-time data duplication analysis</strong>: In scenarios where you want to analyze and identify repeated data in real-time, <strong class="source-inline">std::unordered_multiset</strong> is efficient as it allows constant time average complexity <span class="No-Break">for inserts.</span></li>
				<li><strong class="bold">Tag systems</strong>: For <a id="_idIndexMarker530"/>applications that allow users to tag items, where a tag can be associated with multiple items and vice versa, <strong class="source-inline">std::unordered_multiset</strong> can efficiently manage these <span class="No-Break">tag occurrences.</span></li>
				<li><strong class="bold">Multi-criteria grouping</strong>: In applications that need to group items based on more than one attribute, and duplicates for each attribute are allowed, <strong class="source-inline">std::unordered_multiset</strong> provides a way to manage these <span class="No-Break">grouped items.</span></li>
				<li><strong class="bold">Database record redundancy</strong>: In some database tasks, where the redundancy of certain records or attributes is necessary, <strong class="source-inline">std::unordered_multiset</strong> can be an efficient in-memory tool to manage these redundant <span class="No-Break">data points.</span></li>
			</ul>
			<p><strong class="source-inline">std::unordered_multiset</strong> is best suited for scenarios where quick insertions and lookups are needed, duplicates are allowed, and the order of elements is not significant. When unique keys or ordered data structures are a requirement, other containers, such as <strong class="source-inline">std::unordered_set</strong> or <strong class="source-inline">std::map</strong>, may be <span class="No-Break">more appropriate.</span></p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor334"/>Performance</h2>
			<p>The <a id="_idIndexMarker531"/>algorithmic performance of <strong class="source-inline">std::unordered_multiset</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(1)</em> average-case though worst-case can <span class="No-Break">be </span><span class="No-Break"><em class="italic">O(n)</em></span></li>
				<li><strong class="bold">Deletion:</strong> <span class="No-Break"><em class="italic">O(1)</em></span><span class="No-Break"> average-case</span></li>
				<li><strong class="bold">Access</strong>: No direct access like an array, but finding an element is <span class="No-Break"><em class="italic">O(1)</em></span><span class="No-Break"> average-case</span></li>
				<li><strong class="bold">Memory overhead</strong>: Typically, this is higher than ordered containers due to <span class="No-Break">hashing mechanisms</span></li>
			</ul>
			<p>One trade-off is<a id="_idIndexMarker532"/> that while <strong class="source-inline">std::unordered_multiset</strong> offers average-case <em class="italic">O(1)</em> insertion, lookup, and deletion, worst-case performance can degrade <span class="No-Break">to </span><span class="No-Break"><em class="italic">O(n)</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor335"/>Memory management</h2>
			<p><strong class="source-inline">std::unordered_multiset</strong> dynamically <a id="_idIndexMarker533"/>manages its bucket list. The container can be resized, which might happen automatically when elements are inserted and the size exceeds <strong class="source-inline">max_load_factor</strong>. Allocators can be used to influence <span class="No-Break">memory allocation.</span></p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor336"/>Thread safety</h2>
			<p>Reading from <a id="_idIndexMarker534"/>the container is thread-safe, but modifications (for example, insertions or deletions) require external synchronization. Multiple threads writing to <strong class="source-inline">std::unordered_multiset</strong> simultaneously can lead to <span class="No-Break">race conditions.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor337"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::unordered_set</strong> functions<a id="_idIndexMarker535"/> similarly but doesn’t allow duplicate elements. It contrasts with <strong class="source-inline">std::multiset</strong>, which keeps its elements ordered but <span class="No-Break">permits duplicates.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor338"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker536"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Not inherently sorted, but you can copy elements to a vector and <span class="No-Break">sort them</span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(1)</em> average-case complexity for lookups due <span class="No-Break">to hashing</span></li>
			</ul>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor339"/>Special interface and member functions</h2>
			<p>While it offers <a id="_idIndexMarker537"/>standard<a id="_idIndexMarker538"/> functions (<strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, <strong class="source-inline">find</strong>), you can also explore <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">count</strong>: Returns the number of elements that match a <span class="No-Break">specific value</span></li>
				<li><strong class="source-inline">bucket</strong>: Returns the bucket number for a <span class="No-Break">given value</span></li>
				<li><strong class="source-inline">max_load_factor</strong>: Manages when the container decides <span class="No-Break">to resize</span></li>
			</ul>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor340"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker539"/> to <strong class="source-inline">std::multiset</strong>, this container offers faster average-case performance but at the expense of order and potentially higher <span class="No-Break">memory usage.</span></p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor341"/>Interactions with algorithms</h2>
			<p>Hash-based <a id="_idIndexMarker540"/>containers such as <strong class="source-inline">std::unordered_multiset</strong> don’t always benefit as much from STL algorithms that have been optimized for ordered containers. Algorithms that don’t rely on element order are preferable (that is, <strong class="source-inline">std::for_each</strong>, <strong class="source-inline">std::count</strong>, <strong class="source-inline">std::all_of</strong>, <strong class="source-inline">std::transform</strong>, <span class="No-Break">and others).</span></p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor342"/>Exceptions</h2>
			<p>Standard <a id="_idIndexMarker541"/>exceptions can be thrown for bad allocations. It’s critical to know that operations on <strong class="source-inline">std::unordered_multiset</strong> offer strong <span class="No-Break">exception safety.</span></p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor343"/>Customization</h2>
			<p>The <a id="_idIndexMarker542"/>container supports custom allocators and hash functions, allowing for refined control over memory allocation and <span class="No-Break">hashing behavior.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor344"/>Example</h2>
			<p><strong class="source-inline">std::unordered_multiset</strong> is similar to <strong class="source-inline">std::unordered_set</strong> but allows multiple <a id="_idIndexMarker543"/>occurrences of the same element. Like other unordered containers, it uses a hash table internally, so it doesn’t maintain any order of elements. The key characteristic of <strong class="source-inline">unordered_multiset</strong> is its ability to store duplicates, which can be useful in certain applications, such as counting or categorizing items based on <span class="No-Break">some criterion.</span></p>
			<p>The following example demonstrates some best practices when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_multiset</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
int main() {
  std::unordered_multiset&lt;std::string&gt; fruits;
  fruits.insert("apple");
  fruits.insert("banana");
  fruits.insert("apple");
  fruits.insert("orange");
  fruits.insert("apple");
  fruits.insert("mango");
  fruits.insert("banana");
  const auto appleCount = fruits.count("apple");
  std::cout &lt;&lt; "Number of apples: " &lt;&lt; appleCount &lt;&lt; '\n';
  auto found = fruits.find("orange");
  if (found != fruits.end()) {
    std::cout &lt;&lt; "Found: " &lt;&lt; *found &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "Orange not found!" &lt;&lt; '\n';
  }
  auto range = fruits.equal_range("banana");
  for (auto itr = range.first; itr != range.second;
       ++itr) {
    std::cout &lt;&lt; *itr &lt;&lt; " ";
  }
  std::cout &lt;&lt; '\n';
  fruits.erase("apple");
  std::cout &lt;&lt; "Number of apples after erase:"
            &lt;&lt; fruits.count("apple") &lt;&lt; '\n';
  std::cout &lt;&lt; "Load factor: " &lt;&lt; fruits.load_factor()
            &lt;&lt; '\n';
  std::cout &lt;&lt; "Bucket count: " &lt;&lt; fruits.bucket_count()
            &lt;&lt; '\n';
  fruits.rehash(50);
  std::cout &lt;&lt; "Bucket count after rehashing: "
            &lt;&lt; fruits.bucket_count() &lt;&lt; '\n';
  for (const auto &amp;fruit : fruits) {
    std::cout &lt;&lt; fruit &lt;&lt; " ";
  }
  std::cout &lt;&lt; '\n';
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker544"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Number of apples: 3
Found: orange
banana banana
Number of apples after erase:0
Load factor: 0.363636
Bucket count: 11
Bucket count after rehashing: 53
mango banana banana orange</pre>			<p>Here are some key takeaways from the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li><strong class="source-inline">std::unordered_multiset</strong> can store duplicate values. Use the <strong class="source-inline">count</strong> method to check how many occurrences of a given element exist in <span class="No-Break">the container.</span></li>
				<li>The <strong class="source-inline">equal_range</strong> function<a id="_idIndexMarker545"/> provides a range of iterators pointing to all instances of a <span class="No-Break">specific element.</span></li>
				<li>As with other unordered containers, be conscious of the load factor and consider rehashing <span class="No-Break">when necessary.</span></li>
				<li>Remember that the elements in <strong class="source-inline">unordered_multiset</strong> are unordered. If you need ordered data with duplicate values, you should <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">std::multiset</strong></span><span class="No-Break">.</span></li>
				<li>You’d need to iterate through the set and use the iterator-based <strong class="source-inline">erase()</strong> method to erase specific occurrences of a duplicate value. In the preceding example, we removed all occurrences of <strong class="source-inline">apple</strong> <span class="No-Break">for simplicity.</span></li>
			</ul>
			<p>Use <strong class="source-inline">std::unordered_multiset</strong>  to keep track of elements where the order doesn’t matter, and duplicates are allowed. It offers efficient constant-time average complexity for insertions, deletions, <span class="No-Break">and lookups.</span></p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor345"/>Best practices</h2>
			<p>Let’s <a id="_idIndexMarker546"/>explore the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_multiset</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Distinguish from std::unordered_set</strong>: It’s crucial to recognize the key differences between <strong class="source-inline">std::unordered_multiset</strong> and <strong class="source-inline">std::unordered_set</strong>. Unlike <strong class="source-inline">std::unordered_set</strong>, <strong class="source-inline">std::unordered_multiset</strong> allows duplicates. Choose <strong class="source-inline">std::unordered_multiset</strong> if your application must store multiple <span class="No-Break">equivalent keys.</span></li>
				<li><strong class="bold">Handle duplicates</strong>: One of the primary features of <strong class="source-inline">std::unordered_multiset</strong> is its ability to handle duplicate elements. This is particularly useful in scenarios where you need to track multiple instances of an element. However, this also means that operations such as <strong class="source-inline">find()</strong> will return an iterator to the first instance of the element, and iterating through all duplicates might be necessary for <span class="No-Break">certain operations.</span></li>
				<li><strong class="bold">Load factor and performance</strong>: Similar to <strong class="source-inline">std::unordered_set</strong>, the performance of <strong class="source-inline">std::unordered_multiset</strong> is affected by the load factor. A <a id="_idIndexMarker547"/>higher load factor can cause more hash collisions, impacting performance. Conversely, a lower load factor, while reducing collisions, can lead to memory inefficiency. Use <strong class="source-inline">load_factor()</strong> to monitor and <strong class="source-inline">rehash()</strong> or <strong class="source-inline">max_load_factor()</strong> to manage the load <span class="No-Break">factor effectively.</span></li>
				<li><strong class="bold">Custom hash function</strong>: Customizing the hash function is especially important in <strong class="source-inline">std::unordered_multiset</strong> for efficient element distribution, especially when dealing with custom or complex data types. Implement a specialized hash function using <strong class="source-inline">std::hash</strong> template specialization to ensure uniform distribution and <span class="No-Break">minimize collision.</span></li>
				<li><strong class="bold">Unordered nature and alternatives</strong>: If your application logic requires ordered data, <strong class="source-inline">std::unordered_multiset</strong> may not be the right choice due to its unordered nature. In such cases, consider using <strong class="source-inline">std::multiset</strong>, which maintains order but still <span class="No-Break">allows duplicates.</span></li>
				<li><strong class="bold">Efficient element erasure</strong>: Use the <strong class="source-inline">erase()</strong> function to remove elements. Removing an element by an iterator is an <em class="italic">O(1)</em> operation, whereas removing by value can take up to <em class="italic">O(n)</em> in the worst case. Be mindful of this when designing your erasure strategy, especially in <span class="No-Break">performance-critical applications.</span></li>
				<li><strong class="bold">Memory usage considerations</strong>: Like <strong class="source-inline">std::unordered_set</strong>, <strong class="source-inline">std::unordered_multiset</strong> can have higher memory overhead due to its hashing mechanism. This should be a consideration in environments where memory is <span class="No-Break">a constraint.</span></li>
				<li><strong class="bold">Concurrency and synchronization</strong>: Similar to other unordered containers, <strong class="source-inline">std::unordered_multiset</strong> supports concurrent reads but requires external synchronization mechanisms for writes or concurrent reads and writes. This is crucial in multi-threaded environments to avoid data races and maintain <span class="No-Break">data integrity.</span></li>
				<li><strong class="bold">Interactions with STL algorithms</strong>: While most STL algorithms are compatible with <strong class="source-inline">std::unordered_multiset</strong>, be aware of algorithms that <a id="_idIndexMarker548"/>expect a sorted range since they are not suitable for an unordered container. Always ensure that the chosen algorithm aligns with the characteristics <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::unordered_multiset</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor346"/>std::unordered_multimap</h1>
			<p>By blending the principles of <strong class="source-inline">std::unordered_map</strong> and the flexibility of multiplicity, this <a id="_idIndexMarker549"/>container allows a single key to be associated with multiple values without the need to maintain a <span class="No-Break">specific order.</span></p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor347"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::unordered_multimap</strong> is a hash-based container that permits multiple values to <a id="_idIndexMarker550"/>be associated with a single key. Unlike <strong class="source-inline">std::unordered_map</strong>, it doesn’t enforce <a id="_idIndexMarker551"/>unique keys. It’s especially apt in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When quick average-case lookup times <span class="No-Break">are desired</span></li>
				<li>When you anticipate multiple values for the <span class="No-Break">same key</span></li>
				<li>When key order doesn’t matter, as elements aren’t stored in any <span class="No-Break">particular order</span></li>
			</ul>
			<p>Choose <strong class="source-inline">std::unordered_multimap</strong> for situations that require non-unique keys and swift lookups. If order or unique keys matter, consider <span class="No-Break">other options.</span></p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor348"/>Ideal use cases</h2>
			<p>The following<a id="_idIndexMarker552"/> are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::unordered_multimap</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">One-to-many relationships</strong>: When one key can be associated with multiple values, <strong class="source-inline">std::unordered_multimap</strong> is a suitable container. For example, one author (key) can have numerous books in a database of authors and their <span class="No-Break">books (values).</span></li>
				<li><strong class="bold">Reverse lookup tables</strong>: If you need a fast way to associate several items with one key, such as in applications that find all items linked to a particular attribute, <strong class="source-inline">std::unordered_multimap</strong> <span class="No-Break">is beneficial.</span></li>
				<li><strong class="bold">Collisions in hashing systems</strong>: In scenarios that use hashing mechanisms, <strong class="source-inline">std::unordered_multimap</strong> can manage hash collisions by linking collided keys to their <span class="No-Break">respective values.</span></li>
				<li><strong class="bold">Tagging systems</strong>: In systems where multiple tags can be associated with a single item or a single tag can be associated with multiple items, <strong class="source-inline">std::unordered_multimap</strong> can organize these tag-to-item or <span class="No-Break">item-to-tag relationships.</span></li>
				<li><strong class="bold">Database joins</strong>: When simulating inner joins in databases where multiple records from one table match with multiple records from another table, <strong class="source-inline">std::unordered_multimap</strong> can be an efficient <span class="No-Break">in-memory tool.</span></li>
				<li><strong class="bold">Grouping by attributes</strong>: If you need to group items based on an attribute that isn’t unique, <strong class="source-inline">std::unordered_multimap</strong> can serve as a storage system. As an example, this can be useful if you’re grouping people by their birth year, where one year (key) can correspond to many <span class="No-Break">people (values).</span></li>
				<li><strong class="bold">Lookup systems with variations</strong>: For lookup systems where one key might correspond to multiple slight variations in values, <strong class="source-inline">std::unordered_multimap</strong> is useful. An example would be color-naming systems, where one color can have several <span class="No-Break">associated names.</span></li>
				<li><strong class="bold">Spatial indexing</strong>: In applications such as game development, you might need to find objects in a <a id="_idIndexMarker553"/>particular location quickly. Using spatial keys (such as grid coordinates), <strong class="source-inline">std::unordered_multimap</strong> can associate one coordinate with multiple objects in <span class="No-Break">that space.</span></li>
			</ul>
			<p><strong class="source-inline">std::unordered_multimap</strong> is a highly versatile tool that’s apt for applications where fast insertions and lookups are crucial, and one key should be linked to multiple values. When unique keys or ordered data structures are required, other containers, such as <strong class="source-inline">std::unordered_map</strong> or <strong class="source-inline">std::set</strong>, might be <span class="No-Break">more fitting.</span></p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor349"/>Performance</h2>
			<p>The <a id="_idIndexMarker554"/>algorithmic performance of <strong class="source-inline">std::unordered_multimap</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Average-case <em class="italic">O(1)</em>, <span class="No-Break">worst-case </span><span class="No-Break"><em class="italic">O(n)</em></span></li>
				<li><strong class="bold">Deletion</strong>: Average-case <em class="italic">O(1)</em>, <span class="No-Break">worst-case </span><span class="No-Break"><em class="italic">O(n)</em></span></li>
				<li><strong class="bold">Access</strong>: Average-case <em class="italic">O(1)</em>, <span class="No-Break">worst-case </span><span class="No-Break"><em class="italic">O(n)</em></span></li>
				<li><strong class="bold">Memory overhead</strong>: Moderate due to hashing infrastructure, potentially increasing with <span class="No-Break">hash collisions</span></li>
			</ul>
			<p>Its trade-offs include speedy average-case operations but potential slowdowns if hash collisions <span class="No-Break">become prevalent.</span></p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor350"/>Memory management</h2>
			<p><strong class="source-inline">std::unordered_multimap</strong> resizes<a id="_idIndexMarker555"/> when the load factor exceeds its maximum value. Allocators can be used to customize memory behavior, including allocation and <span class="No-Break">deallocation strategies.</span></p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor351"/>Thread safety</h2>
			<p>Reading<a id="_idIndexMarker556"/> from different instances is thread-safe. However, concurrent reading and writing to the same instance necessitates <span class="No-Break">external synchronization.</span></p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor352"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::unordered_map</strong> is a <a id="_idIndexMarker557"/>variant that holds unique keys. If you need ordered key behavior, <strong class="source-inline">std::multimap</strong> and <strong class="source-inline">std::map</strong> are <span class="No-Break">tree-based alternatives.</span></p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor353"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker558"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Not inherently sortable as it is unordered; must be copied to a <span class="No-Break">sortable container</span></li>
				<li><strong class="bold">Searching</strong>: Average-case <em class="italic">O(1)</em> due to hashing, but can degrade in the presence of many <span class="No-Break">hash collisions</span></li>
			</ul>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor354"/>Special interface and member functions</h2>
			<p>Beyond <a id="_idIndexMarker559"/>common functions (<strong class="source-inline">insert</strong>, <strong class="source-inline">find</strong>, <strong class="source-inline">erase</strong>), dive into <a id="_idIndexMarker560"/><span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: Directly constructs the element in <span class="No-Break">the container</span></li>
				<li><strong class="source-inline">bucket</strong>: Fetches the bucket number for a <span class="No-Break">given key</span></li>
				<li><strong class="source-inline">load_factor</strong>: Provides the ratio of elements <span class="No-Break">to buckets</span></li>
			</ul>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor355"/>Comparisons</h2>
			<p>Compared <a id="_idIndexMarker561"/>to <strong class="source-inline">std::unordered_map</strong>, this container allows non-unique keys. If key order matters, <strong class="source-inline">std::multimap</strong> is a <span class="No-Break">tree-based alternative.</span></p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor356"/>Interactions with algorithms</h2>
			<p>Being<a id="_idIndexMarker562"/> unordered, many STL algorithms designed for ordered sequences might not be directly applicable or would necessitate a <span class="No-Break">different approach.</span></p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor357"/>Exceptions</h2>
			<p>Failures in<a id="_idIndexMarker563"/> memory allocation or hash function complications can throw exceptions. Container operations offer basic exception safety, ensuring the container <span class="No-Break">remains valid.</span></p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor358"/>Customization</h2>
			<p>You can <a id="_idIndexMarker564"/>use custom allocators for memory adjustments. Custom hash functions or key equality predicates can also optimize behavior for specific <span class="No-Break">use cases.</span></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor359"/>Example</h2>
			<p><strong class="source-inline">std::unordered_multimap</strong> is <a id="_idIndexMarker565"/>similar to <strong class="source-inline">std::unordered_map</strong> but allows for multiple key-value pairs with equivalent keys. It is an associative container, meaning its value type is formed by combining its key and <span class="No-Break">mapped types.</span></p>
			<p>The following code example demonstrates some best practices when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_multimap</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
int main() {
  std::unordered_multimap&lt;std::string, int&gt; grades;
  grades.insert({"Lisa", 85});
  grades.insert({"Corbin", 92});
  grades.insert({"Lisa", 89});
  grades.insert({"Aaron", 76});
  grades.insert({"Corbin", 88});
  grades.insert({"Regan", 91});
  size_t lisaCount = grades.count("Lisa");
  std::cout &lt;&lt; "Number of grade entries for Lisa: "
            &lt;&lt; lisaCount &lt;&lt; '\n';
  auto range = grades.equal_range("Lisa");
  for (auto it = range.first; it != range.second; ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " has grade: " &lt;&lt; it-&gt;second
              &lt;&lt; '\n';
  }
  auto lisaGrade = grades.find("Lisa");
  if (lisaGrade != grades.end()) {
    lisaGrade-&gt;second = 90; // Updating the grade
  }
  grades.erase("Corbin"); // This will erase all grade
                          // entries for Corbin
  std::cout
      &lt;&lt; "Number of grade entries for Corbin after erase: "
      &lt;&lt; grades.count("Corbin") &lt;&lt; '\n';
  std::cout &lt;&lt; "Load factor: " &lt;&lt; grades.load_factor()
            &lt;&lt; '\n';
  std::cout &lt;&lt; "Bucket count: " &lt;&lt; grades.bucket_count()
            &lt;&lt; '\n';
  grades.rehash(50);
  std::cout &lt;&lt; "Bucket count after rehashing: "
            &lt;&lt; grades.bucket_count() &lt;&lt; '\n';
  for (const auto &amp;entry : grades) {
    std::cout &lt;&lt; entry.first
              &lt;&lt; " received grade: " &lt;&lt; entry.second
              &lt;&lt; '\n';
  }
  return 0;
}</pre>			<p>Here’s the<a id="_idIndexMarker566"/> <span class="No-Break">example output:</span></p>
			<pre class="console">
Number of grade entries for Lisa: 2
Lisa has grade: 85
Lisa has grade: 89
Number of grade entries for Corbin after erase: 0
Load factor: 0.363636
Bucket count: 11
Bucket count after rehashing: 53
Regan received grade: 91
Aaron received grade: 76
Lisa received grade: 90
Lisa received grade: 89</pre>			<p>Here are some <a id="_idIndexMarker567"/>key takeaways from the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>With <strong class="source-inline">std::unordered_multimap</strong>, it is possible to insert multiple key-value pairs with the <span class="No-Break">same key.</span></li>
				<li>You can use <strong class="source-inline">equal_range</strong> to get a range of iterators to all the key-value pairs with a <span class="No-Break">specific key.</span></li>
				<li>The <strong class="source-inline">count</strong> method helps you determine the number of key-value pairs with a <span class="No-Break">specific key.</span></li>
				<li>Like other unordered containers, you should be aware of the load factor and might want to rehash it if necessary to achieve <span class="No-Break">optimal performance.</span></li>
				<li>Using the <strong class="source-inline">erase()</strong> method with a key will remove all the key-value pairs associated with <span class="No-Break">that key.</span></li>
				<li>Since it is an unordered container, the order of the elements is <span class="No-Break">not guaranteed.</span></li>
				<li>Use <strong class="source-inline">std::unordered_multimap</strong> when you need to keep track of multiple values associated with the same key and don’t need the key-value pairs to be sorted. It provides average constant-time complexity for <span class="No-Break">most operations.</span></li>
			</ul>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor360"/>Best practices</h2>
			<p>Let’s explore the<a id="_idIndexMarker568"/> best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::unordered_multimap</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Avoid assuming order</strong>: The <em class="italic">unordered</em> part of <strong class="source-inline">std::unordered_multimap</strong> signifies that the container maintains no specific order for its key-value pairs. Iterating through the container does not guarantee any <span class="No-Break">particular sequence.</span></li>
				<li><strong class="bold">Handle non-unique keys</strong>: One of the distinguishing features of <strong class="source-inline">std::unordered_multimap</strong> is its ability to store multiple entries for a single key. Remember this when inserting, erasing, or searching to avoid unintended <span class="No-Break">logic errors.</span></li>
				<li><strong class="bold">Load factor management</strong>: The load factor (calculated as the ratio of the number of elements to the number of buckets) impacts performance. A higher load factor increases the likelihood of hash collisions, potentially degrading access/insertion performance. Use the <strong class="source-inline">load_factor()</strong> function to monitor the current load factor. If it gets too high, consider rehashing the container using the <strong class="source-inline">rehash()</strong> function. It’s also possible to set a desired upper limit on the load factor with the <span class="No-Break"><strong class="source-inline">max_load_factor()</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="bold">Efficient hash function design</strong>: The default hash function might not be ideal for all data types. Inefficient hash functions can degrade performance significantly. Crafting a specialized hash function ensures a more uniform distribution across buckets, thus reducing the chances of collisions. Utilize the <strong class="source-inline">std::hash</strong> template specialization for custom data types to ensure efficient and <span class="No-Break">consistent hashing.</span></li>
				<li><strong class="bold">Handle hash collisions</strong>: Even with an efficient hash function, collisions might occur. The container handles these internally, but awareness of them helps with making better design decisions. Collisions can lead to a performance drop in insertion and search operations, so balancing the load factor and the <a id="_idIndexMarker569"/>number of buckets <span class="No-Break">is essential.</span></li>
				<li><strong class="bold">Mindful iteration</strong>: When iterating, one key might appear multiple times with different associated values due to the possibility of multiple values for a single key. Use <strong class="source-inline">equal_range()</strong> when iterating through all values associated with a <span class="No-Break">specific key.</span></li>
				<li><strong class="bold">Iterator invalidation</strong>: Iterator invalidation can be a concern, especially after operations such as rehashing. Always ensure that iterators, pointers, or references to the elements are not used after they might have <span class="No-Break">been invalidated.</span></li>
				<li><strong class="bold">In-place construction</strong>: To efficiently insert elements without the overhead of temporary object creation, use the <strong class="source-inline">emplace</strong> or <strong class="source-inline">emplace_hint</strong> methods. These allow the key-value pair to be constructed directly within <span class="No-Break">the container.</span></li>
				<li><strong class="bold">Concurrency considerations</strong>: Concurrent reads are thread-safe, but you’ll need external synchronization for any modifications or concurrent reads and writes. Use synchronization primitives such as mutexes in <span class="No-Break">multi-threaded scenarios.</span></li>
				<li><strong class="bold">Interactions with STL algorithms</strong>: Many STL algorithms can be employed with <strong class="source-inline">std::unordered_multimap</strong>. However, ensure the selected algorithm doesn’t expect ordering or unique keys, since those assumptions would contradict the <span class="No-Break">container’s properties.</span></li>
			</ul>
		</div>
	</body></html>