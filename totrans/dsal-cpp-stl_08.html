<html><head></head><body>
		<div><h1 id="_idParaDest-298" class="chapter-number"><a id="_idTextAnchor298"/>8</h1>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor299"/>Advanced Unordered Associative Container Usage</h1>
			<p>While our journey with ordered associative containers has provided us with the prowess of relationship mapping and the power of ordering, it is time to venture into a domain that prioritizes speed over sorted behavior: unordered associative containers. As their name suggests, these containers do not guarantee any specific order of their elements, but they make up for it with potentially faster access times.</p>
			<p>In the world of computing, there are always trade-offs. Unordered associative containers might relinquish the beauty of order, but in many scenarios, they make up for it with speed, especially when hashing operates at its best. Whether you’re developing a high-frequency trading system, a caching mechanism, or a real-time multiplayer game backend, understanding when to harness the power of unordered associated containers can make a difference.</p>
			<p>This chapter provides references for the following containers:</p>
			<ul>
				<li><code>std::unordered_set</code></li>
				<li><code>std::unordered_map</code></li>
				<li><code>std::unordered_multiset</code></li>
				<li><code>std::unordered_multimap</code></li>
			</ul>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor300"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub: </p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor301"/>std::unordered_set</h1>
			<p>This <a id="_idIndexMarker484"/>container is akin to <code>std::set</code> but with a twist: it does not maintain the elements in any particular order. Instead, it employs a hashing mechanism to access its elements quickly. This hash-based approach can offer constant time average complexity for most operations, given a good hash function.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor302"/>Purpose and suitability</h2>
			<p><code>std::unordered_set</code> is a <a id="_idIndexMarker485"/>hash-based container in the C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) that stores unique elements in no particular order. Its core strengths include the following:</p>
			<ul>
				<li>Providing average constant-time operations for insertions, deletions, and searches</li>
				<li>Handling non-trivial data types effectively</li>
			</ul>
			<p>You should<a id="_idIndexMarker486"/> choose <code>std::unordered_set</code> in the following scenarios:</p>
			<ul>
				<li>When you need rapid checks for the existence of elements</li>
				<li>When the order of elements is not a concern</li>
				<li>When frequent insertions and deletions are expected</li>
			</ul>
			<p>However, if the ordering of elements is crucial, <code>std::set</code> might be a better alternative.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor303"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker487"/> some of the ideal use cases for <code>std::unordered_set</code>:</p>
			<ul>
				<li><code>std::unordered_set</code> is your candidate.</li>
				<li><code>std::unordered_set</code>  to create a collection of unique items from an existing dataset.</li>
				<li><code>std::unordered_set</code>  where quick insertions and deletions are more critical than maintaining order.</li>
				<li><code>std::unordered_set</code> over <code>std::set</code> when<a id="_idIndexMarker488"/> the order of elements doesn’t matter since <code>std::unordered_set</code> provides faster lookup, insertion, and removal operations. However, <code>std::unordered_set</code> may use more memory than <code>std::set</code>.</li>
			</ul>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor304"/>Performance</h2>
			<p>The <a id="_idIndexMarker489"/>algorithmic performance of <code>std::unordered_set</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em> due to potential hash collisions</li>
				<li><strong class="bold">Deletion</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em> due to potential hash collisions</li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(1)</em></li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than ordered containers due to hashing mechanisms</li>
			</ul>
			<p>The key trade-off here revolves around average versus worst-case scenarios, especially concerning hash collisions.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor305"/>Memory management</h2>
			<p><code>std::unordered_set</code> manages<a id="_idIndexMarker490"/> its memory using a series of buckets to store elements. The number of buckets can grow, usually when the load factor exceeds a certain threshold. Using custom allocators can help tailor this behavior.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor306"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker491"/>reading is safe. However, operations that modify the set (such as insertions or deletions) require external synchronization mechanisms, such as mutexes.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor307"/>Extensions and variants</h2>
			<p><code>std::unordered_multiset</code> is a<a id="_idIndexMarker492"/> close relative, allowing multiple instances of an element to be used. If ordered storage is vital, <code>std::set</code> and <code>std::multiset</code> come into play.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor308"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker493"/>sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><code>std::unordered_set</code> is not ordered.</li>
				<li><strong class="bold">Searching</strong>: It has an average <em class="italic">O(1)</em> time due to hashing, but its worst-case scenario can be <em class="italic">O(n)</em> with poor hashing.</li>
			</ul>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor309"/>Special interface and member functions</h2>
			<p>Some handy <a id="_idIndexMarker494"/>member functions to note are<a id="_idIndexMarker495"/> as follows:</p>
			<ul>
				<li><code>emplace</code>: This allows elements to be constructed directly.</li>
				<li><code>bucket</code>: This can retrieve the bucket number for a given element.</li>
				<li><code>load_factor</code> and <code>max_load_factor</code>: These are required for managing performance characteristics.</li>
			</ul>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor310"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker496"/> to <code>std::set</code>, <code>std::unordered_set</code> generally offers faster operations but loses the inherent order and might have a higher memory overhead.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor311"/>Interactions with algorithms</h2>
			<p>Due to its <a id="_idIndexMarker497"/>unordered nature, <code>std::unordered_set</code> might not be the best candidate for STL algorithms that require ordered data. However, algorithms revolving around unique elements can fit well.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor312"/>Exceptions</h2>
			<p>Operations can<a id="_idIndexMarker498"/> throw exceptions if allocations fail or if hash functions throw. Ensure your hash functions are exception-free to guarantee the container’s exception safety.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor313"/>Customization</h2>
			<p>Custom hash<a id="_idIndexMarker499"/> functions and equality predicates can be applied to fine-tune the container’s behavior for specific data types. Moreover, custom allocators can also be beneficial in some scenarios.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor314"/>Example</h2>
			<p><code>std::unordered_set</code> stores<a id="_idIndexMarker500"/> unique elements in no particular order. The primary operations it supports are insertion, deletion, and member checking. Unlike <code>std::set</code>, which uses a balanced binary tree internally, <code>std::unordered_set</code> uses a hash table, making the average insertion, deletion, and search complexities <em class="italic">O(1)</em>, albeit with higher constants and worse worst-case performance.</p>
			<p>The following code shows an example demonstrating best practices when using <code>std::unordered_set</code>:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
void displaySet(const std::unordered_set&lt;int&gt; &amp;set) {
  for (const int &amp;num : set) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; '\n';
}
int main() {
  std::unordered_set&lt;int&gt; numbers;
  for (int i = 0; i &lt; 10; ++i) { numbers.insert(i); }
  displaySet(numbers);
  int searchValue = 5;
  if (numbers.find(searchValue) != numbers.end()) {
    std::cout &lt;&lt; searchValue &lt;&lt; " found in the set."
              &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; searchValue &lt;&lt; " not found in the set."
              &lt;&lt; '\n';
  }
  numbers.erase(5);
  displaySet(numbers);
  std::cout &lt;&lt; "Size: " &lt;&lt; numbers.size() &lt;&lt; '\n';
  std::cout &lt;&lt; "Load factor: " &lt;&lt; numbers.load_factor()
            &lt;&lt; '\n';
  numbers.rehash(50);
  std::cout &lt;&lt; "Number of buckets after rehash: "
            &lt;&lt; numbers.bucket_count() &lt;&lt; '\n';
  std::vector&lt;int&gt; moreNumbers = {100, 101, 102, 103};
  numbers.insert(moreNumbers.begin(), moreNumbers.end());
  displaySet(numbers);
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker501"/>example output:</p>
			<pre class="console">
9 8 7 6 5 4 3 2 1 0
5 found in the set.
9 8 7 6 4 3 2 1 0
Size: 9
Load factor: 0.818182
Number of buckets after rehash: 53
103 102 101 100 9 8 7 6 4 3 2 1 0</pre>			<p>Here are some key takeaways from the preceding code:</p>
			<ul>
				<li><code>std::unordered_set</code> allows rapid insertions, deletions, and lookups.</li>
				<li><code>find</code> can be used to check for the existence of an element.</li>
				<li>The <code>rehash</code> method can change the number of buckets in the underlying hash table, which might help when you know the number of elements in advance and wish to reduce the overhead of rehashing.</li>
				<li>Always be <a id="_idIndexMarker502"/>cautious about the load factor (covered in the following Best practices section) and consider rehashing when necessary to maintain efficient performance.</li>
				<li>Remember that the order of elements in <code>std::unordered_set</code> is not guaranteed. The order can change over time as elements are inserted or deleted.</li>
			</ul>
			<p>Using <code>std::unordered_set</code> is appropriate when you need rapid lookups and are not worried about the order of elements. If ordering is essential, you might want to consider using <code>std::set</code> instead.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor315"/>Best practices</h2>
			<p>Let’s explore the<a id="_idIndexMarker503"/> best practices of using <code>std::unordered_set</code>:</p>
			<ul>
				<li><code>std::unordered_set</code> is designed without the need to maintain any specific order of its elements. Never rely on any sequential consistency within this container.</li>
				<li><strong class="bold">Hash collision awareness</strong>: Hash collisions can detrimentally affect performance, transforming average-case constant-time operations into worst-case linear-time operations. Always be aware of this, especially when designing hash functions or handling large datasets.</li>
				<li><code>std::unordered_set</code> can be intimately tied to its bucket count and load factor. Consider the load factor and rehashing policies of <code>std::unordered_set</code> for performance tuning. The <code>bucket_count()</code>: The current number of buckets</li><li><code>load_factor()</code>: The current number of elements divided by the bucket count</li><li><code>max_load_factor()</code>: The load factor threshold, which, when surpassed, triggers a rehash</li></ul></li>
				<li><code>std::hash</code> standard template specialization. This allows hashing behavior to be fine-tuned.</li>
				<li><code>rehash()</code> or <code>reserve()</code> when necessary. This can help prevent unexpected performance drops, especially when inserting new elements.</li>
				<li><strong class="bold">Uniform hash distribution</strong>: A good hash function will distribute values uniformly across buckets, minimizing the chance of collisions. Ensure your hash function achieves this by testing its distribution with sample data before deploying it in performance-critical applications. Use a well-designed hash function that distributes elements evenly across the buckets to avoid performance degradation.</li>
				<li><code>std::unordered_set</code> is not the ideal choice. Consider migrating to <code>std::set</code> or leveraging other ordered containers within the STL.</li>
				<li><code>std::unordered_set</code> in multi-threaded applications, ensure proper synchronization mechanisms are in place. Concurrent reads are safe, but writes or simultaneous reads and writes demand external synchronization.</li>
				<li><code>std::unordered_set</code> dynamically manages its size, it is beneficial to <a id="_idIndexMarker505"/>use functions such as <code>reserve()</code> if you have an estimate of the number of elements to be stored. This can help in reducing the number of rehashes and improve performance.</li>
				<li><code>erase</code> member function judiciously. Remember that erasing by the iterator is faster (<em class="italic">O(1)</em>) than erasing by the key value (<em class="italic">O(n)</em> in the worst case.</li>
				<li><code>std::unordered_set</code>, due to its hashing mechanism, might have a higher memory overhead than other containers. Consider this aspect, especially in memory-sensitive applications.</li>
			</ul>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor316"/>std::unordered_map</h1>
			<p>Think of this container<a id="_idIndexMarker506"/> as an unsorted version of <code>std::map</code>. It associates keys with values but without imposing any order. Instead, it banks on hashing for swift operations.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor317"/>Purpose and suitability</h2>
			<p><code>std::unordered_map</code> is a <a id="_idIndexMarker507"/>hash table-based key-value container in the STL. Its core strengths are as follows:</p>
			<ul>
				<li>Fast average-case key-based access, insertion, and removal</li>
				<li>Ability to maintain a key-value association</li>
			</ul>
			<p>This container is the go-to in the following circumstances:</p>
			<ul>
				<li>When insertions, deletions, and lookups must be swift on average</li>
				<li>When the order of elements isn’t a concern</li>
			</ul>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor318"/>Ideal use cases</h2>
			<p>The following are some <a id="_idIndexMarker508"/>of the ideal use cases for <code>std::unordered_map</code>:</p>
			<ul>
				<li><code>std::unordered_map</code> provides average constant-time complexity for <code>search</code>, <code>insert</code>, and <code>delete</code> operations</li>
				<li><code>std::unordered_map</code> is ideal</li>
				<li><code>std::unordered_map</code> allows you to map items to their occurrence counts efficiently</li>
				<li><code>std::unordered_map</code> can map the attribute to a list or set of objects</li>
				<li><code>std::unordered_map</code> can associate setting keys with their current values for quick lookups and modifications</li>
				<li><code>std::unordered_map</code> can serve as an efficient index for quick record access based on unique identifiers</li>
				<li><code>std::unordered_map</code> offers an efficient way to update and access data categories or counters based on unique keys</li>
				<li><code>std::unordered_map</code> provides an efficient structure to handle key-value pairs</li>
				<li><code>std::unordered_map</code> proves invaluable</li>
				<li><code>std::unordered_map</code> can associate resource keys with their status or attributes</li>
			</ul>
			<p>To summarize, <code>std::unordered_map</code> is optimal for scenarios that demand quick associative lookups, insertions, and deletions without needing the keys to maintain any specific order. If a key’s sequence or sorted nature is a priority, structures such as <code>std::map</code> would be more suitable.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor319"/>Performance</h2>
			<p>The <a id="_idIndexMarker510"/>algorithmic performance of <code>std::unordered_map</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(1)</em> average-case, <em class="italic">O(n)</em> worst-case</li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(1)</em> average-case, <em class="italic">O(n)</em> worst-case</li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(1)</em> average-case, <em class="italic">O(n)</em> worst-case due to potential hash collisions</li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than ordered map counterparts due to the hashing infrastructure</li>
			</ul>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor320"/>Memory management</h2>
			<p><code>std::unordered_map</code> manages<a id="_idIndexMarker511"/> its memory automatically, resizing when load factors exceed certain thresholds. Allocators can offer finer control over this process.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor321"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker512"/>reading is safe. However, modifications or mixed read-writes necessitate external synchronization, such as using mutexes.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor322"/>Extensions and variants</h2>
			<p><code>std::map</code> is the ordered <a id="_idIndexMarker513"/>counterpart, providing log(n) guarantees at the cost of maintaining order. Based on your requirements, decide whether you need order or average-case speed.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor323"/>Sorting and searching complexity</h2>
			<p>Its<a id="_idIndexMarker514"/> sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><code>std::unordered_map</code> is inherently unordered</li>
				<li><strong class="bold">Searching</strong>: Fast <em class="italic">O(1)</em> average-case key-based lookups</li>
			</ul>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor324"/>Special interface and member functions</h2>
			<p>Apart from the <a id="_idIndexMarker515"/>standard functions (<code>insert</code>, <code>erase</code>, <code>find</code>), become <a id="_idIndexMarker516"/>familiar with the following:</p>
			<ul>
				<li><code>emplace</code>: Constructs key-value pairs in place</li>
				<li><code>bucket_count</code>: Returns the number of buckets</li>
				<li><code>load_factor</code>: Provides the current load factor</li>
			</ul>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor325"/>Comparisons</h2>
			<p>Compared to <code>std::map</code>, <code>std::unordered_map</code> trades order for faster average-case operations. The<a id="_idIndexMarker517"/> unordered variant often outperforms in scenarios where constant order isn’t vital.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor326"/>Interactions with algorithms</h2>
			<p>Most STL algorithms<a id="_idIndexMarker518"/> that work with sequences aren’t directly applicable to key-value map structures. Still, the container provides methods that are optimized for its use case.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor327"/>Exceptions</h2>
			<p>Failures in memory <a id="_idIndexMarker519"/>allocation or the hash function can throw exceptions. Some operations, such as <code>at()</code>, can throw <code>std::out_of_range</code>. It’s crucial to ensure exception safety, especially during insertions or emplacements.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor328"/>Customization</h2>
			<p>You can supply <a id="_idIndexMarker520"/>custom hash functions and key equality functions to optimize further or adapt behavior. Additionally, custom allocators are available for memory management tweaks.</p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor329"/>Example</h2>
			<p><code>std::unordered_map</code> is a container <a id="_idIndexMarker521"/>that associates keys with values. It is similar to <code>std::map</code>, but while <code>std::map</code> maintains its elements in a sorted manner (based on keys), <code>std::unordered_map</code> does not maintain any order. Internally, it uses a hash table, which gives it an <em class="italic">O(1)</em> complexity for insertions, deletions, and lookups.</p>
			<p>The following code shows an example demonstrating best practices when using <code>std::unordered_map</code>:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
void displayMap(
    const std::unordered_map&lt;std::string, int&gt; &amp;map) {
  for (const auto &amp;[key, value] : map) {
    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; '\n';
  }
}
int main() {
  std::unordered_map&lt;std::string, int&gt; ageMap;
  ageMap[„Lisa"] = 28;
  ageMap[„Corbin"] = 25;
  ageMap[„Aaron"] = 30;
  std::cout &lt;&lt; "Corbin's age: " &lt;&lt; ageMap["Corbin"]
            &lt;&lt; '\n';
  if (ageMap.find("Daisy") == ageMap.end()) {
    std::cout &lt;&lt; "Daisy not found in the map." &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "Daisy's age: " &lt;&lt; ageMap["Daisy"]
              &lt;&lt; '\n';
  }
  ageMap["Lisa"] = 29;
  std::cout &lt;&lt; "Lisa's updated age: " &lt;&lt; ageMap["Lisa"]
            &lt;&lt; '\n';
  displayMap(ageMap);
  std::cout &lt;&lt; "Load factor: " &lt;&lt; ageMap.load_factor()
            &lt;&lt; '\n';
  std::cout &lt;&lt; "Bucket count: " &lt;&lt; ageMap.bucket_count()
            &lt;&lt; '\n';
  ageMap.rehash(50);
  std::cout &lt;&lt; "Bucket count after rehash:"
            &lt;&lt; ageMap.bucket_count() &lt;&lt; '\n';
  // Remove an entry
  ageMap.erase("Aaron");
  displayMap(ageMap);
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker522"/>example output:</p>
			<pre class="console">
Corbin's age: 25
Daisy not found in the map.
Lisa's updated age: 29
Aaron: 30
Corbin: 25
Lisa: 29
Load factor: 0.6
Bucket count: 5
Bucket count after rehash:53
Corbin: 25
Lisa: 29</pre>			<p>Here are some <a id="_idIndexMarker523"/>key takeaways from the preceding code:</p>
			<ul>
				<li>Use the <code>operator[]</code> or the <code>insert</code> method to add elements to the map. Note that using an index operator on a non-existent key will create it with a default value.</li>
				<li>The <code>find</code> method checks for the existence of a key. It’s more efficient than using the <code>index</code> operator when you want to check a key’s existence without potential insertion.</li>
				<li>Always be aware of the map’s load factor and consider rehashing if necessary to maintain efficient performance.</li>
				<li>As with <code>std::unordered_set</code>, the order of elements in <code>std::unordered_map</code> is not guaranteed. It can change as elements are inserted or removed.</li>
			</ul>
			<p><code>std::unordered_map</code> is suitable when you need quick key-based access and don’t care about the order of elements. If ordering is essential, then <code>std::map</code> would be a more appropriate choice.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor330"/>Best practices</h2>
			<p>Let’s explore the <a id="_idIndexMarker524"/>best practices of using <code>std::unordered_map</code>:</p>
			<ul>
				<li><strong class="bold">Element order is not guaranteed</strong>: Do not assume the map maintains element order.</li>
				<li><strong class="bold">Beware of hash collisions</strong>: Ensure you account for potential worst-case performance in hash-collision scenarios.</li>
				<li><code>std::unordered_map</code> to maintain optimal performance. Regularly check the load factor and consider rehashing if necessary.</li>
				<li><code>std::unordered_map</code> is highly dependent on the effectiveness of the hash function used. A poorly designed hash function can lead to poor performance due to cache misses and collision resolution overhead.</li>
				<li><code>std::unordered_map</code> to improve memory efficiency, particularly in scenarios with high insertions and deletions.</li>
				<li><strong class="bold">Check for an existing key</strong>: Always check for an existing key before insertion to avoid overwriting.</li>
				<li><code>emplace</code> to construct entries in place, reducing overhead.</li>
				<li><code>std::unordered_map</code> is expensive when using <code>operator[]</code> for accessing elements, which can be a performance pitfall.</li>
			</ul>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor331"/>std::unordered_multiset</h1>
			<p>This container is a<a id="_idIndexMarker526"/> flexible counterpart to <code>std::unordered_set</code>, allowing multiple occurrences of an element. It amalgamates the speed of hashing with the liberty of non-unique elements.</p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor332"/>Purpose and suitability</h2>
			<p><code>std::unordered_multiset</code> is a hash table-based container that allows you to store multiple<a id="_idIndexMarker527"/> equivalent items in an unordered manner. Its primary attractions are as follows:</p>
			<ul>
				<li>Quick average-case insertion and lookup times</li>
				<li>The ability to store multiple items with the same value</li>
			</ul>
			<p>It’s particularly <a id="_idIndexMarker528"/>suitable in the following scenarios:</p>
			<ul>
				<li>When the order of elements doesn’t matter</li>
				<li>When you anticipate having multiple elements with the same value</li>
				<li>When you want average-case constant time complexity for insertions and lookups</li>
			</ul>
			<p>When searching for a container where duplicates are permissible and order isn’t crucial, <code>std::unordered_multiset</code> is a compelling choice.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor333"/>Ideal use cases</h2>
			<p>The following <a id="_idIndexMarker529"/>are some of the ideal use cases for <code>std::unordered_multiset</code>:</p>
			<ul>
				<li><code>std::unordered_multiset</code> is suitable. It permits the storage of multiple identical elements.</li>
				<li><code>std::unordered_multiset</code> can be an efficient structure where each unique value is stored alongside its duplicates.</li>
				<li><code>std::unordered_multiset</code> can be useful for managing hash collisions by storing collided items together.</li>
				<li><code>std::unordered_multiset</code> can store these repeating patterns for further analysis.</li>
				<li><code>std::unordered_multiset</code> is efficient as it allows constant time average complexity for inserts.</li>
				<li><code>std::unordered_multiset</code> can efficiently manage these tag occurrences.</li>
				<li><code>std::unordered_multiset</code> provides a way to manage these grouped items.</li>
				<li><code>std::unordered_multiset</code> can be an efficient in-memory tool to manage these redundant data points.</li>
			</ul>
			<p><code>std::unordered_multiset</code> is best suited for scenarios where quick insertions and lookups are needed, duplicates are allowed, and the order of elements is not significant. When unique keys or ordered data structures are a requirement, other containers, such as <code>std::unordered_set</code> or <code>std::map</code>, may be more appropriate.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor334"/>Performance</h2>
			<p>The <a id="_idIndexMarker531"/>algorithmic performance of <code>std::unordered_multiset</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(1)</em> average-case though worst-case can be <em class="italic">O(n)</em></li>
				<li><strong class="bold">Deletion:</strong> <em class="italic">O(1)</em> average-case</li>
				<li><strong class="bold">Access</strong>: No direct access like an array, but finding an element is <em class="italic">O(1)</em> average-case</li>
				<li><strong class="bold">Memory overhead</strong>: Typically, this is higher than ordered containers due to hashing mechanisms</li>
			</ul>
			<p>One trade-off is<a id="_idIndexMarker532"/> that while <code>std::unordered_multiset</code> offers average-case <em class="italic">O(1)</em> insertion, lookup, and deletion, worst-case performance can degrade to <em class="italic">O(n)</em>.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor335"/>Memory management</h2>
			<p><code>std::unordered_multiset</code> dynamically <a id="_idIndexMarker533"/>manages its bucket list. The container can be resized, which might happen automatically when elements are inserted and the size exceeds <code>max_load_factor</code>. Allocators can be used to influence memory allocation.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor336"/>Thread safety</h2>
			<p>Reading from <a id="_idIndexMarker534"/>the container is thread-safe, but modifications (for example, insertions or deletions) require external synchronization. Multiple threads writing to <code>std::unordered_multiset</code> simultaneously can lead to race conditions.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor337"/>Extensions and variants</h2>
			<p><code>std::unordered_set</code> functions<a id="_idIndexMarker535"/> similarly but doesn’t allow duplicate elements. It contrasts with <code>std::multiset</code>, which keeps its elements ordered but permits duplicates.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor338"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker536"/>sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Not inherently sorted, but you can copy elements to a vector and sort them</li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(1)</em> average-case complexity for lookups due to hashing</li>
			</ul>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor339"/>Special interface and member functions</h2>
			<p>While it offers <a id="_idIndexMarker537"/>standard<a id="_idIndexMarker538"/> functions (<code>insert</code>, <code>erase</code>, <code>find</code>), you can also explore the following:</p>
			<ul>
				<li><code>count</code>: Returns the number of elements that match a specific value</li>
				<li><code>bucket</code>: Returns the bucket number for a given value</li>
				<li><code>max_load_factor</code>: Manages when the container decides to resize</li>
			</ul>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor340"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker539"/> to <code>std::multiset</code>, this container offers faster average-case performance but at the expense of order and potentially higher memory usage.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor341"/>Interactions with algorithms</h2>
			<p>Hash-based <a id="_idIndexMarker540"/>containers such as <code>std::unordered_multiset</code> don’t always benefit as much from STL algorithms that have been optimized for ordered containers. Algorithms that don’t rely on element order are preferable (that is, <code>std::for_each</code>, <code>std::count</code>, <code>std::all_of</code>, <code>std::transform</code>, and others).</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor342"/>Exceptions</h2>
			<p>Standard <a id="_idIndexMarker541"/>exceptions can be thrown for bad allocations. It’s critical to know that operations on <code>std::unordered_multiset</code> offer strong exception safety.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor343"/>Customization</h2>
			<p>The <a id="_idIndexMarker542"/>container supports custom allocators and hash functions, allowing for refined control over memory allocation and hashing behavior.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor344"/>Example</h2>
			<p><code>std::unordered_multiset</code> is similar to <code>std::unordered_set</code> but allows multiple <a id="_idIndexMarker543"/>occurrences of the same element. Like other unordered containers, it uses a hash table internally, so it doesn’t maintain any order of elements. The key characteristic of <code>unordered_multiset</code> is its ability to store duplicates, which can be useful in certain applications, such as counting or categorizing items based on some criterion.</p>
			<p>The following example demonstrates some best practices when using <code>std::unordered_multiset</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
int main() {
  std::unordered_multiset&lt;std::string&gt; fruits;
  fruits.insert("apple");
  fruits.insert("banana");
  fruits.insert("apple");
  fruits.insert("orange");
  fruits.insert("apple");
  fruits.insert("mango");
  fruits.insert("banana");
  const auto appleCount = fruits.count("apple");
  std::cout &lt;&lt; "Number of apples: " &lt;&lt; appleCount &lt;&lt; '\n';
  auto found = fruits.find("orange");
  if (found != fruits.end()) {
    std::cout &lt;&lt; "Found: " &lt;&lt; *found &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "Orange not found!" &lt;&lt; '\n';
  }
  auto range = fruits.equal_range("banana");
  for (auto itr = range.first; itr != range.second;
       ++itr) {
    std::cout &lt;&lt; *itr &lt;&lt; " ";
  }
  std::cout &lt;&lt; '\n';
  fruits.erase("apple");
  std::cout &lt;&lt; "Number of apples after erase:"
            &lt;&lt; fruits.count("apple") &lt;&lt; '\n';
  std::cout &lt;&lt; "Load factor: " &lt;&lt; fruits.load_factor()
            &lt;&lt; '\n';
  std::cout &lt;&lt; "Bucket count: " &lt;&lt; fruits.bucket_count()
            &lt;&lt; '\n';
  fruits.rehash(50);
  std::cout &lt;&lt; "Bucket count after rehashing: "
            &lt;&lt; fruits.bucket_count() &lt;&lt; '\n';
  for (const auto &amp;fruit : fruits) {
    std::cout &lt;&lt; fruit &lt;&lt; " ";
  }
  std::cout &lt;&lt; '\n';
  return 0;
}</pre>			<p>Here’s the <a id="_idIndexMarker544"/>example output:</p>
			<pre class="console">
Number of apples: 3
Found: orange
banana banana
Number of apples after erase:0
Load factor: 0.363636
Bucket count: 11
Bucket count after rehashing: 53
mango banana banana orange</pre>			<p>Here are some key takeaways from the preceding code:</p>
			<ul>
				<li><code>std::unordered_multiset</code> can store duplicate values. Use the <code>count</code> method to check how many occurrences of a given element exist in the container.</li>
				<li>The <code>equal_range</code> function<a id="_idIndexMarker545"/> provides a range of iterators pointing to all instances of a specific element.</li>
				<li>As with other unordered containers, be conscious of the load factor and consider rehashing when necessary.</li>
				<li>Remember that the elements in <code>unordered_multiset</code> are unordered. If you need ordered data with duplicate values, you should use <code>std::multiset</code>.</li>
				<li>You’d need to iterate through the set and use the iterator-based <code>erase()</code> method to erase specific occurrences of a duplicate value. In the preceding example, we removed all occurrences of <code>apple</code> for simplicity.</li>
			</ul>
			<p>Use <code>std::unordered_multiset</code>  to keep track of elements where the order doesn’t matter, and duplicates are allowed. It offers efficient constant-time average complexity for insertions, deletions, and lookups.</p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor345"/>Best practices</h2>
			<p>Let’s <a id="_idIndexMarker546"/>explore the best practices of using <code>std::unordered_multiset</code>:</p>
			<ul>
				<li><code>std::unordered_multiset</code> and <code>std::unordered_set</code>. Unlike <code>std::unordered_set</code>, <code>std::unordered_multiset</code> allows duplicates. Choose <code>std::unordered_multiset</code> if your application must store multiple equivalent keys.</li>
				<li><code>std::unordered_multiset</code> is its ability to handle duplicate elements. This is particularly useful in scenarios where you need to track multiple instances of an element. However, this also means that operations such as <code>find()</code> will return an iterator to the first instance of the element, and iterating through all duplicates might be necessary for certain operations.</li>
				<li><code>std::unordered_set</code>, the performance of <code>std::unordered_multiset</code> is affected by the load factor. A <a id="_idIndexMarker547"/>higher load factor can cause more hash collisions, impacting performance. Conversely, a lower load factor, while reducing collisions, can lead to memory inefficiency. Use <code>load_factor()</code> to monitor and <code>rehash()</code> or <code>max_load_factor()</code> to manage the load factor effectively.</li>
				<li><code>std::unordered_multiset</code> for efficient element distribution, especially when dealing with custom or complex data types. Implement a specialized hash function using <code>std::hash</code> template specialization to ensure uniform distribution and minimize collision.</li>
				<li><code>std::unordered_multiset</code> may not be the right choice due to its unordered nature. In such cases, consider using <code>std::multiset</code>, which maintains order but still allows duplicates.</li>
				<li><code>erase()</code> function to remove elements. Removing an element by an iterator is an <em class="italic">O(1)</em> operation, whereas removing by value can take up to <em class="italic">O(n)</em> in the worst case. Be mindful of this when designing your erasure strategy, especially in performance-critical applications.</li>
				<li><code>std::unordered_set</code>, <code>std::unordered_multiset</code> can have higher memory overhead due to its hashing mechanism. This should be a consideration in environments where memory is a constraint.</li>
				<li><code>std::unordered_multiset</code> supports concurrent reads but requires external synchronization mechanisms for writes or concurrent reads and writes. This is crucial in multi-threaded environments to avoid data races and maintain data integrity.</li>
				<li><code>std::unordered_multiset</code>, be aware of algorithms that <a id="_idIndexMarker548"/>expect a sorted range since they are not suitable for an unordered container. Always ensure that the chosen algorithm aligns with the characteristics of <code>std::unordered_multiset</code>.</li>
			</ul>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor346"/>std::unordered_multimap</h1>
			<p>By blending the principles of <code>std::unordered_map</code> and the flexibility of multiplicity, this <a id="_idIndexMarker549"/>container allows a single key to be associated with multiple values without the need to maintain a specific order.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor347"/>Purpose and suitability</h2>
			<p><code>std::unordered_multimap</code> is a hash-based container that permits multiple values to <a id="_idIndexMarker550"/>be associated with a single key. Unlike <code>std::unordered_map</code>, it doesn’t enforce <a id="_idIndexMarker551"/>unique keys. It’s especially apt in the following scenarios:</p>
			<ul>
				<li>When quick average-case lookup times are desired</li>
				<li>When you anticipate multiple values for the same key</li>
				<li>When key order doesn’t matter, as elements aren’t stored in any particular order</li>
			</ul>
			<p>Choose <code>std::unordered_multimap</code> for situations that require non-unique keys and swift lookups. If order or unique keys matter, consider other options.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor348"/>Ideal use cases</h2>
			<p>The following<a id="_idIndexMarker552"/> are some of the ideal use cases for <code>std::unordered_multimap</code>:</p>
			<ul>
				<li><code>std::unordered_multimap</code> is a suitable container. For example, one author (key) can have numerous books in a database of authors and their books (values).</li>
				<li><code>std::unordered_multimap</code> is beneficial.</li>
				<li><code>std::unordered_multimap</code> can manage hash collisions by linking collided keys to their respective values.</li>
				<li><code>std::unordered_multimap</code> can organize these tag-to-item or item-to-tag relationships.</li>
				<li><code>std::unordered_multimap</code> can be an efficient in-memory tool.</li>
				<li><code>std::unordered_multimap</code> can serve as a storage system. As an example, this can be useful if you’re grouping people by their birth year, where one year (key) can correspond to many people (values).</li>
				<li><code>std::unordered_multimap</code> is useful. An example would be color-naming systems, where one color can have several associated names.</li>
				<li><code>std::unordered_multimap</code> can associate one coordinate with multiple objects in that space.</li>
			</ul>
			<p><code>std::unordered_multimap</code> is a highly versatile tool that’s apt for applications where fast insertions and lookups are crucial, and one key should be linked to multiple values. When unique keys or ordered data structures are required, other containers, such as <code>std::unordered_map</code> or <code>std::set</code>, might be more fitting.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor349"/>Performance</h2>
			<p>The <a id="_idIndexMarker554"/>algorithmic performance of <code>std::unordered_multimap</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em></li>
				<li><strong class="bold">Deletion</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em></li>
				<li><strong class="bold">Access</strong>: Average-case <em class="italic">O(1)</em>, worst-case <em class="italic">O(n)</em></li>
				<li><strong class="bold">Memory overhead</strong>: Moderate due to hashing infrastructure, potentially increasing with hash collisions</li>
			</ul>
			<p>Its trade-offs include speedy average-case operations but potential slowdowns if hash collisions become prevalent.</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor350"/>Memory management</h2>
			<p><code>std::unordered_multimap</code> resizes<a id="_idIndexMarker555"/> when the load factor exceeds its maximum value. Allocators can be used to customize memory behavior, including allocation and deallocation strategies.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor351"/>Thread safety</h2>
			<p>Reading<a id="_idIndexMarker556"/> from different instances is thread-safe. However, concurrent reading and writing to the same instance necessitates external synchronization.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor352"/>Extensions and variants</h2>
			<p><code>std::unordered_map</code> is a <a id="_idIndexMarker557"/>variant that holds unique keys. If you need ordered key behavior, <code>std::multimap</code> and <code>std::map</code> are tree-based alternatives.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor353"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker558"/>sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Not inherently sortable as it is unordered; must be copied to a sortable container</li>
				<li><strong class="bold">Searching</strong>: Average-case <em class="italic">O(1)</em> due to hashing, but can degrade in the presence of many hash collisions</li>
			</ul>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor354"/>Special interface and member functions</h2>
			<p>Beyond <a id="_idIndexMarker559"/>common functions (<code>insert</code>, <code>find</code>, <code>erase</code>), dive into <a id="_idIndexMarker560"/>the following:</p>
			<ul>
				<li><code>emplace</code>: Directly constructs the element in the container</li>
				<li><code>bucket</code>: Fetches the bucket number for a given key</li>
				<li><code>load_factor</code>: Provides the ratio of elements to buckets</li>
			</ul>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor355"/>Comparisons</h2>
			<p>Compared <a id="_idIndexMarker561"/>to <code>std::unordered_map</code>, this container allows non-unique keys. If key order matters, <code>std::multimap</code> is a tree-based alternative.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor356"/>Interactions with algorithms</h2>
			<p>Being<a id="_idIndexMarker562"/> unordered, many STL algorithms designed for ordered sequences might not be directly applicable or would necessitate a different approach.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor357"/>Exceptions</h2>
			<p>Failures in<a id="_idIndexMarker563"/> memory allocation or hash function complications can throw exceptions. Container operations offer basic exception safety, ensuring the container remains valid.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor358"/>Customization</h2>
			<p>You can <a id="_idIndexMarker564"/>use custom allocators for memory adjustments. Custom hash functions or key equality predicates can also optimize behavior for specific use cases.</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor359"/>Example</h2>
			<p><code>std::unordered_multimap</code> is <a id="_idIndexMarker565"/>similar to <code>std::unordered_map</code> but allows for multiple key-value pairs with equivalent keys. It is an associative container, meaning its value type is formed by combining its key and mapped types.</p>
			<p>The following code example demonstrates some best practices when using <code>std::unordered_multimap</code>:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
int main() {
  std::unordered_multimap&lt;std::string, int&gt; grades;
  grades.insert({"Lisa", 85});
  grades.insert({"Corbin", 92});
  grades.insert({"Lisa", 89});
  grades.insert({"Aaron", 76});
  grades.insert({"Corbin", 88});
  grades.insert({"Regan", 91});
  size_t lisaCount = grades.count("Lisa");
  std::cout &lt;&lt; "Number of grade entries for Lisa: "
            &lt;&lt; lisaCount &lt;&lt; '\n';
  auto range = grades.equal_range("Lisa");
  for (auto it = range.first; it != range.second; ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " has grade: " &lt;&lt; it-&gt;second
              &lt;&lt; '\n';
  }
  auto lisaGrade = grades.find("Lisa");
  if (lisaGrade != grades.end()) {
    lisaGrade-&gt;second = 90; // Updating the grade
  }
  grades.erase("Corbin"); // This will erase all grade
                          // entries for Corbin
  std::cout
      &lt;&lt; "Number of grade entries for Corbin after erase: "
      &lt;&lt; grades.count("Corbin") &lt;&lt; '\n';
  std::cout &lt;&lt; "Load factor: " &lt;&lt; grades.load_factor()
            &lt;&lt; '\n';
  std::cout &lt;&lt; "Bucket count: " &lt;&lt; grades.bucket_count()
            &lt;&lt; '\n';
  grades.rehash(50);
  std::cout &lt;&lt; "Bucket count after rehashing: "
            &lt;&lt; grades.bucket_count() &lt;&lt; '\n';
  for (const auto &amp;entry : grades) {
    std::cout &lt;&lt; entry.first
              &lt;&lt; " received grade: " &lt;&lt; entry.second
              &lt;&lt; '\n';
  }
  return 0;
}</pre>			<p>Here’s the<a id="_idIndexMarker566"/> example output:</p>
			<pre class="console">
Number of grade entries for Lisa: 2
Lisa has grade: 85
Lisa has grade: 89
Number of grade entries for Corbin after erase: 0
Load factor: 0.363636
Bucket count: 11
Bucket count after rehashing: 53
Regan received grade: 91
Aaron received grade: 76
Lisa received grade: 90
Lisa received grade: 89</pre>			<p>Here are some <a id="_idIndexMarker567"/>key takeaways from the preceding code:</p>
			<ul>
				<li>With <code>std::unordered_multimap</code>, it is possible to insert multiple key-value pairs with the same key.</li>
				<li>You can use <code>equal_range</code> to get a range of iterators to all the key-value pairs with a specific key.</li>
				<li>The <code>count</code> method helps you determine the number of key-value pairs with a specific key.</li>
				<li>Like other unordered containers, you should be aware of the load factor and might want to rehash it if necessary to achieve optimal performance.</li>
				<li>Using the <code>erase()</code> method with a key will remove all the key-value pairs associated with that key.</li>
				<li>Since it is an unordered container, the order of the elements is not guaranteed.</li>
				<li>Use <code>std::unordered_multimap</code> when you need to keep track of multiple values associated with the same key and don’t need the key-value pairs to be sorted. It provides average constant-time complexity for most operations.</li>
			</ul>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor360"/>Best practices</h2>
			<p>Let’s explore the<a id="_idIndexMarker568"/> best practices of using <code>std::unordered_multimap</code>:</p>
			<ul>
				<li><code>std::unordered_multimap</code> signifies that the container maintains no specific order for its key-value pairs. Iterating through the container does not guarantee any particular sequence.</li>
				<li><code>std::unordered_multimap</code> is its ability to store multiple entries for a single key. Remember this when inserting, erasing, or searching to avoid unintended logic errors.</li>
				<li><code>load_factor()</code> function to monitor the current load factor. If it gets too high, consider rehashing the container using the <code>rehash()</code> function. It’s also possible to set a desired upper limit on the load factor with the <code>max_load_factor()</code> function.</li>
				<li><code>std::hash</code> template specialization for custom data types to ensure efficient and consistent hashing.</li>
				<li><strong class="bold">Handle hash collisions</strong>: Even with an efficient hash function, collisions might occur. The container handles these internally, but awareness of them helps with making better design decisions. Collisions can lead to a performance drop in insertion and search operations, so balancing the load factor and the <a id="_idIndexMarker569"/>number of buckets is essential.</li>
				<li><code>equal_range()</code> when iterating through all values associated with a specific key.</li>
				<li><strong class="bold">Iterator invalidation</strong>: Iterator invalidation can be a concern, especially after operations such as rehashing. Always ensure that iterators, pointers, or references to the elements are not used after they might have been invalidated.</li>
				<li><code>emplace</code> or <code>emplace_hint</code> methods. These allow the key-value pair to be constructed directly within the container.</li>
				<li><strong class="bold">Concurrency considerations</strong>: Concurrent reads are thread-safe, but you’ll need external synchronization for any modifications or concurrent reads and writes. Use synchronization primitives such as mutexes in multi-threaded scenarios.</li>
				<li><code>std::unordered_multimap</code>. However, ensure the selected algorithm doesn’t expect ordering or unique keys, since those assumptions would contradict the container’s properties.</li>
			</ul>
		</div>
	</body></html>