- en: '*Chapter 1*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Antithesis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Telling an Object What to Do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The big idea is "messaging" – that is, what the kernal [sic] of Smalltalk/Squeak
    is all about (and it''s something that was never quite completed in our Xerox
    PARC phase). The Japanese have a small word – ma – for "that which is in between"
    – perhaps the nearest English equivalent is "interstitial." The key in making
    great and growable systems is much more to design how its modules communicate
    rather than what their internal properties and behaviors should be.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Alan Kay, (squeak-dev mailing list —* [http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html](http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A huge amount of complexity is wrapped up in that most common of operations:
    invoking an object''s method. In many programming languages – C++, Java, Python,
    and others – this takes the form `anObject.methodName()`, which means "there will
    be a method on the class that `anObject` is an instance of, or some antecedent
    class, where the method is called `methodName`, please find it and run it, with
    the `self` or `this` value aliased to `anObject`." So, for example, in Java we
    would expect to find a (non-abstract) `public void methodName() { /* ... */ }`
    somewhere in `anObject`''s class or parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This guarantee introduces a lot of coupling between the caller and the object
    that holds the method:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller knows that the object is an instance of some class (there are so
    many issues bound up with inheritance that it gets its own chapter, later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caller knows that the object's class, or some ancestor of it, provides a
    method with the given name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method will run to completion in this context, then give control back to
    the caller (this is not particularly evident from the syntax in isolation, but
    nonetheless is assumed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would it mean to lift those assumptions? It would make the object a truly
    independent computer program, communicating from a distance over an agreed protocol
    based on message passing. What that object does, how it does it, even what programming
    language it's implemented in, are all private to the object. Does it collaborate
    with a class to find out how to respond to the message? Does that class have one
    parent or multiple parents?
  prefs: []
  type: TYPE_NORMAL
- en: 'The *idea* behind message-passing is exactly that arms-length separation of
    concerns, but even programming languages that are based on the message-passing
    scheme usually treat it as a special case of "look up a method," to be followed
    only if the usual method-resolution fails. These languages typically have a particular
    named method that will be run when the requested method isn''t found. In Smalltalk,
    it''s called `doesNotUnderstand:`, while in Ruby it''s called `method_missing()`.
    Each one receives the *selector* (that is, the unique name of the method the caller
    was hoping to invoke) to decide what to do with it. This gets us a higher level
    of decoupling: objects can send messages to one another without having to peek
    at the others'' implementations to discover whether they implement a method matching
    the message.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is that decoupling valuable? It lets us build our objects as truly standalone
    programs, considering only what their contract is with the outside world and how
    their implementation supports that contract. By requiring, for example, that an
    object will only receive a message if it is an instance of a class that contains
    a Java function of the same name that can be pushed onto the call stack, even
    if via a Java interface (a list of methods that a Java class can provide), we
    adopt a lot of assumptions about the implementation of the message receiver, turning
    them into constraints that the programmer must deal with when building the sender.
    We do not have independent, decoupled programs collaborating over a message interface,
    but a rigid system with a limited amount of modularity. Understanding one object
    means pulling in information about other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '*This is not merely an academic distinction, as it constrains the design of
    real systems. Consider an application to visualize some information about a company''s
    staff, which is located in a key-value store. If I need every object between the
    view and the store to know about all of the available methods, then I either duplicate
    my data schema everywhere in the app by defining methods like* `salary()` *or*
    `payrollNumber()`*, or I provide meaningless generic interfaces like* `getValue(String
    key)` *that remove the useful information that I''m working with representations
    of people in the company.*'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, I could say to my `Employee` object "if you get a message you do
    not recognize, but it looks like a key in the key-value store, reply with the
    value you find for that key." I could say to my view object "if you get a message
    you do not recognize, but the `Employee` gives you a value in response to it,
    prepare that value for display and use the selector name as the label for that
    value." The behavior – looking up arbitrary values in the key-value store – remains
    the same but the message network tells us more about *why* the application is
    doing what it does.
  prefs: []
  type: TYPE_NORMAL
- en: By providing lazy resolution paths like `method_missing`, systems like Ruby
    partially lift these assumptions and provide tools to enable greater decoupling
    and independence of objects in the network. To fully take advantage of this, we
    must change the language used and the way we think about these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'A guide to OOP in Ruby will probably tell you that methods are looked up by
    name, but if that fails, the class can optionally implement `method_missing` to
    supply custom behavior. This is exactly backwards: saying that objects are bags
    of named methods until that stops working, when they gain some autonomy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flip this language: an object is responsible for deciding how it handles messages,
    and one particular convenience is that they automatically run methods that match
    a received selector without any extra processing. Now your object truly is an
    autonomous actor responding to messages, rather than a place to store particular
    named routines in a procedural program.'
  prefs: []
  type: TYPE_NORMAL
- en: There are object systems that expose this way of thinking about objects, a good
    example being the CMU Mach system. Mach is an operating system kernel that supplies
    communication between threads (in the same or different tasks) using message passing.
    A sender need know nothing about the receiver other than its port (the place to
    put outgoing messages) and how to arrange a message to be put in the port. The
    receiver knows nothing about the sender; just that a message has appeared on its
    port and can be acted on. The two could be in the same task, or not even on the
    same computer. They do not even need to be written in the same language, they
    just need to know what the messages are and how to put them on a port.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of service-oriented architecture, a microservice is an independent
    program that collaborates with peers over a loosely coupled interface comprised
    of messages sent over some implementation-independent transport mechanism – often
    HTTPS or protocol buffers. This sounds a lot like OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice adopters are able to implement different services in different
    technologies, to think about changes to a given service only in terms of how they
    satisfy the message contract, and to independently replace individual services
    without disrupting the whole system. This, too, sounds a lot like OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The object-oriented approach attempts to manage the complexity inherent in
    real-world problems by abstracting out knowledge and encapsulating it within objects.
    Finding or creating these objects is a problem of structuring knowledge and activities.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener, Designing Object-Oriented
    Software*'
  prefs: []
  type: TYPE_NORMAL
- en: An early goal of OOP was to simplify the work of software system design by reducing
    the big problem "design this large system to solve these problems" into the small
    problems "design these small systems" and "combine these small systems such that
    they solve these problems in concert". Brad Cox, an object technologist who built
    the Objective-C language and cofounded a company to exploit it, wrote an article
    "*What if there's a Silver Bullet...And the Competition Gets It First?*" in which
    he asserted that OOP represented a significant reduction in software complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '*In the broadest sense, "object-oriented" refers to the war and not the weapons,
    the ends and not the means, an objective rather than technologies for achieving
    it. It means orienting on objects rather than on processes for building them;
    wielding all the tools programmers can muster, from well-proven antiques like
    Cobol to as-yet missing ones like specification/testing languages, to enable software
    consumers, letting them reason about software products with the common-sense skills
    we all use to understand the tangible objects of everyday experience.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*It means relinquishing the traditional process-centered paradigm with the
    programmer-machine relationship at the center of the software universe in favor
    of a product-centered paradigm with the producer-consumer relationship at the
    center.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, many "object-oriented" design techniques still rely on considering
    the system as a whole, building artisanal, bespoke objects from scratch that will
    comprise the system that satisfies the customer''s needs. In this sense, Cox''s
    vision has not come to pass: he hoped for the "software industrial revolution"
    in which standardized components (software-ICs, analogous with integrated circuits
    in electronics design) could be specified based on their externally visible behavior
    and composed into a system relevant to the task at hand. Rather, we still have
    a craft industry, but now the application-specific components we build every time
    are called "objects."'
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach – designing a whole system as a single software product but calling
    the bits "objects" – goes under the name of **Object-Oriented Analysis and Design**.
    Typically, it is expressed as a way to decompose big problems according to the
    *data* used to solve the problem, so that OOP becomes an "alternative" to functional
    programming, in which the big problem is decomposed according to the *operations*
    used in its solution. An uncaptioned table in "Using Functions for Easier Programming"
    by Neil Savage — [https://dl.acm.org/citation.cfm?id=3193776](https://dl.acm.org/citation.cfm?id=3193776)
    from 2018 describes the term Object-Oriented:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The central mode for abstraction is the data itself, thus the value of a term
    isn''t always predetermined by the input (stateful approach).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term Functional programming is described as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The central mode for abstraction is the function, not the data structure,
    thus the value of a term is always predetermined by the input (stateless approach).*'
  prefs: []
  type: TYPE_NORMAL
- en: Never mind that "functional" languages like Haskell have mechanisms designed
    for handling state, or that plenty of problems we might want to solve in the world
    have both stateful and stateless aspects!
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea of objects-as-data does have its roots in the OOP movement. In his
    textbook "*A Touch of Class*" from 2009, in Section 2.3 "*What is an object*?",
    Bertrand Meyer uses the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An object is a software machine allowing programs to access and modify a collection
    of data.*'
  prefs: []
  type: TYPE_NORMAL
- en: This is in exact opposition to the usual goals of "encapsulation" or "data hiding"
    that we have heard about, in which we try to *forbid* programs from accessing
    and modifying our data! In this view, we have the object as a "software machine,"
    which is good as it suggests some kind of independent, autonomous function, but
    unfortunately, we get the idea that the purpose of this machine is to look after
    some slice of our data from the overall collection used throughout the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is this mindset that leads to objects as "active structures," like this
    typical example in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This satisfies our requirement for encapsulation (the field is private), and
    our requirement that an object allows programs to access and modify a collection
    of data. What we have ended up with is no different from a plain old data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The exception is that the C# example requires a function call on each access
    of the field. There is no *real* encapsulation; objects with their own fields
    can make no guesses about the status of those fields, and a system including such
    objects can only be understood by considering the whole system. The hoped-for
    advantage that we could turn our big problem into a composition of small problems
    has been lost.
  prefs: []
  type: TYPE_NORMAL
- en: A contributor to this objects-as-data approach seems to have been the attempt
    to square object-oriented programming with **Software Engineering**, a field of
    interest launched in 1968 that aimed to bring product design and construction
    skills to computer scientists by having very clever computer scientists think
    about what product design and construction might be like and not ask anybody.
    Process-heavy and design-artefact-heavy systems, approaches, and "methodologies"
    (a word that used to mean "the study of method" until highfalutin software engineers
    took it to mean "method, but a longer word") recommended deciding on the objects,
    their methods, and properties; the data involved; and the presentation and storage
    of that data in excruciating detail, all in the name of satisfying a **Use Case**,
    which is Software Engineering speak for "a thing somebody might want to do."
  prefs: []
  type: TYPE_NORMAL
- en: The inside cover of "*Applying UML and Patterns*" by Craig Larman (1997) has
    22 detailed steps to follow before **Construction** when constructing a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects can be thought of as *simulations* of some part of the problem we''re
    trying to solve, and a great way to learn from a simulation is to *interact* with
    it. If our objects are just active structures that hold some data on behalf of
    a program, then we don''t get that benefit: we can''t interact with the simulation
    without building out all of the rest of the program. And indeed that is the goal
    behind a lot of the "engineering" processes that use objects: while they may pay
    lip service to iterative and incremental development, they still talk about building
    a system at once, with each object being a jigsaw puzzle piece that satisfactorily
    fits its given gap in the puzzle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go back to Bertrand Meyer''s definition, and remove the problematic
    bit about letting a program access an object''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An object is a software machine*'
  prefs: []
  type: TYPE_NORMAL
- en: A machine is a useful analogy. It's a device (so something that was built by
    people) that uses energy to produce some effect. Notice the absence of any statement
    about *how* the machine produces that effect, *how* the machine consumes its materials,
    or *how* the machine's output is supplied. We've got a thing that does a thing,
    but if we're going to compose these things together to do other things, we're
    going to need to know how to do that composition. Adding a constraint takes us
    from "it's a machine" to "it's a machine that we can use like this".
  prefs: []
  type: TYPE_NORMAL
- en: '*An object is a software machine that can collaborate with other software machines
    by sending and receiving messages.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ve got things that do things and can be used together. We don''t restrict
    the level of complexity of the things that are done by each machine (so booking
    a flight and representing a number are both things that we could build machines
    to do); just how we would combine them. This has parallels with Brad Cox''s software
    ICs analogy, too. An "integrated circuit" could be anything from a **NAND** gate
    to an **UltraSPARC T2**. We can use any of the IC''s together, of any size, if
    we just know how to deal with their inputs and outputs: what voltage should appear
    on each pin and what that represents.'
  prefs: []
  type: TYPE_NORMAL
- en: This analogy tells us that our software system is like a big machine that does
    something useful by composing, powering, and employing smaller component machines.
    It tells us to worry about whether the things coming out of one machine are useful
    as inputs to another machine, but not to worry about what's going on inside each
    machine except in the restricted context of the maintenance of those machines.
    It tells us to consider at each point whether the machine we have is more useful
    than not having that machine, rather than tracking the progress toward the construction
    of some all-powerful supermachine.
  prefs: []
  type: TYPE_NORMAL
- en: It even tells us that building an **assembly line** in which input of a certain
    type is transformed into output of a certain type is a thing we might want to
    do; something that, otherwise, we might believe is solely the domain of the functional
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*I see a red door and I want to paint it black. No colors any more I want them
    to turn black.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rolling Stones, Paint it Black*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If object-oriented programming is the activity of modelling a problem in software,
    then the kinds of diagrams (and verbal descriptions) that software teams use to
    convey the features and behavior of those objects are metamodeling – the modeling
    of models. The rules, for example, the constraints implied when using `metametamodels`:
    the models that describe how the models of the models of the problems will work.'
  prefs: []
  type: TYPE_NORMAL
- en: Unified Modeling Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plenty of such systems (I will avoid the word `metametamodels` from now on)
    have been used over time to describe object systems. The **UML** (**Unified Modeling
    Language**) is the result of combining three prior techniques: the three Elven
    Kings, Grady Booch, Ivar Jacobson, and James Rumbaugh bent their rings of power
    (respectively, the **Booch Method**, **Object-Oriented Software Engineering**,
    and the **Object Modelling Technique** – the latter mostly recognized today because
    the majority of diagrams in the famous *Design Patterns* book are drawn to its
    rules) to the *One Rational Ring*, wielded by Mike Devlin.'
  prefs: []
  type: TYPE_NORMAL
- en: '*As an aside, Rational started as a company making better Ada applications
    and tools for other Ada programmers to make better Ada applications, including
    the R1000 workstation, optimized for running Ada programs and featuring an integrated
    development environment. The R1000 did not take off but the idea of an IDE did,
    and through a couple of iterations of their Rose product (as well as the UML and
    Rational Unified Process), made significant inroads into changing the way organizations
    planned, designed, and built software.*'
  prefs: []
  type: TYPE_NORMAL
- en: The UML and, to differing extents, its precursor modelling techniques, represent
    a completist approach to object modelling in which all aspects of the implementation
    can be represented diagrammatically. Indeed, tools exist to "round-trip" convert
    UML into compatible languages like Java and back again into the UML representation.
  prefs: []
  type: TYPE_NORMAL
- en: The model you create that both encapsulates enough of the "business" aspects
    of the system to demonstrate that you have solved a problem and enough of the
    implementation aspects to generate the executable program is not really a model,
    it *is* the program source. In shooting for completeness, the UML family of modelling
    tools have missed "modelling" completely and simply introduced another implementation
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the goal of message-passing is to solve our big problem through the concerted
    operation of lots of small, independent computer programs loosely coupled by the
    communications protocol, then we should be able to look at each object through
    one of two lenses: internal or external. In fact, the boundary itself deserves
    special consideration, so there are three views:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The "external" lens: What messages can I send to this object? What do I need
    to arrange in order to send them? What can I expect as a result?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The "internal" lens: What does this object do in response to its messages?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The "boundary" lens: Does the behavior of this object satisfy the external
    expectations?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final two of these things are closely intertwingled. Indeed some popular
    implementation disciplines, such as **Test-Driven Development** lead you to implement
    the object internals only through the boundary lens, by saying "I need this to
    happen when this message is received," then arranging the object's internals so
    that it does, indeed, happen.
  prefs: []
  type: TYPE_NORMAL
- en: The first is separated from the others, though. From the outside of an object
    I *only* need to know what I can ask it to do; if I also need to know how it does
    it or what goes on inside, then I have not decomposed my big problem into independent,
    small problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'UML class diagrams include all class features at all levels of visibility:
    public, package, protected, and private; simultaneously. Either they show a lot
    of redundant information (which is not to a diagram''s benefit) or they expect
    the modeler to take the completist approach and solve the whole big problem at
    once, using the word "objects" to give some of that 1980s high-technology feel
    to their solution. This is a downhill development from Booch''s earlier method,
    in which objects and classes were represented as fluffy cloud-shaped things, supporting
    the idea that there''s probably some dynamism and complexity inside there but
    that it''s not relevant right now.'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, as with Bertrand Meyer's statement that "an object is a software
    machine allowing programs to access and modify a collection of data," explored
    in the section on *analysis and design*, we can find the point at which Grady
    Booch overshot the world of modelling tools in a single sentence in *Chapter One
    of his 1991 book Object-Oriented Design with Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps there is a general principle in which the left half of a sentence about
    making software is always more valuable than the right half. If so, then the (**Agile
    Manifesto** — [http://agilemanifesto.org/](http://agilemanifesto.org/)) is the
    most insightfully-designed document in our history.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sentence runs thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented design''s underlying concept is that one should model software
    systems as collections of cooperating objects...*'
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: '*... treating individual objects as instances of a class ...*'
  prefs: []
  type: TYPE_NORMAL
- en: I would suggest that this is not necessary, and that classes, and particularly
    inheritance, deserve their own section in this part of the book (see *Finding
    a Method to Run* section).
  prefs: []
  type: TYPE_NORMAL
- en: '*... within a hierarchy of classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: And here we just diverge completely. By situating his objects within "a hierarchy
    of classes," Booch *is* encouraging us to think about the whole system, relating
    objects taxonomically and defining shared features. This comes from a good intention
    – inheritance was long seen as the object-oriented way to achieve reuse – but
    promotes thinking about reuse over thinking about *use*.
  prefs: []
  type: TYPE_NORMAL
- en: Class-Responsibility-Collaborator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as the UML represents a snapshot in the development of a way of describing
    objects, so do CRC cards, introduced by Kent Beck and Ward Cunningham in 1989,
    and propagated by Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener in their
    textbook *Designing Object-Oriented Software*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CRC card describes three aspects of an object, none of which is a cyclic
    redundancy check:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Class* names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Responsibilities* of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Collaborators* that the object will need to work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only does this school of design focus on the messaging aspect of objects
    (the responsibilities will be things I can ask it to do and the collaborators
    will be other objects it asks to do things), but it introduces a fun bit of *anthropomorphism*.
    You and I can each pick up a card and "play object," having a conversation to
    solve a problem, and letting that drive our understanding of what messages will
    be exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'David West, in his 2004 book, *Object Thinking*, presents the object cube,
    which extends the CRC card into three dimensions by adding five more faces:'
  prefs: []
  type: TYPE_NORMAL
- en: A textual description of instances of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of named contracts (these are supposed to indicate "the intent of the
    class creator as to who should be able to send particular messages," and in his
    examples are all either "public" or "private")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "knowledge required" by an object and an indication of where it will get
    that knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message protocol is a list of messages the object will respond to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events generated by the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some bad news: you can''t make a cube out of 3x5 index cards; and you can''t
    buy 5x5 index cards. But that''s just an aside. Again, as with using the UML,
    we''ve got to record the internals and externals of our object in the same place,
    and now we need to use large shelves rather than index boxes to store them.'
  prefs: []
  type: TYPE_NORMAL
- en: With both of these techniques, the evolution seems to have been one of additive
    complexity. Yes, you can draw out the network of objects and messages, oh and
    while you're here you can also...
  prefs: []
  type: TYPE_NORMAL
- en: And rationally, each part of each of these metamodels seems to make sense. Of
    course, at some point, I need to think about the internals of this object; at
    some point, I need to consider its instance variables; and at some point, I need
    to plan the events emitted by the object. Yes, but not at the *same* point, so
    they don't need to be visible at the same time on the same model.
  prefs: []
  type: TYPE_NORMAL
- en: Jelly Donuts and Soccer Balls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ironically, there *is* a form of object diagram that makes this separation
    between the externals and internals clear, though I have only seen it in one place:
    The NeXT (and subsequently Apple) **jelly-donut model** — [http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html](http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html)
    This isn''t a tool that programmers use for designing objects, though: it''s an
    analogy used in some documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: It's an analogy that some authors disagree with. In *Object Thinking*, David
    West says that the jelly donut model (which he calls the **soccer-ball model**,
    after Ken Auer) is the model of choice of the "traditional developer," while "an
    object thinker" would represent an object anthropomorphically, using a person.
  prefs: []
  type: TYPE_NORMAL
- en: 'West may well argue that the jelly donut/soccer ball model represents traditional
    thinking because it reflects the Meyer-ish view that your system is designed by
    working out what data it needs and then carving that up between different objects.
    Ironically, Bertrand Meyer would probably also reject the soccer ball model, for
    an unrelated reason: Eiffel follows the **Principle of Uniform Reference**, in
    which an object field or a member function (method) is accessed using the same
    notation. To an Eiffel programmer, the idea that the data is "surrounded" by the
    methods is superfluous; the jelly donut indicates the use of a broken language
    that allows the sweet jelly to escape and make everything else sticky.'
  prefs: []
  type: TYPE_NORMAL
- en: Opposing Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*[An] important aspect of functional programming is that functions do not change
    the data with which they work [...] Object-oriented imperative languages such
    as C, Java, or Python change their state as they run.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Neil Savage, (Using Functions for Easier Programming —* [https://dl.acm.org/citation.cfm?id=3193776](https://dl.acm.org/citation.cfm?id=3193776)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: Many programmers define themselves through their tools, and therefore define
    themselves as *against* certain other tools. If you are a .NET programmer, then
    you do not use Java. If you are a native mobile programmer, then you do not use
    JavaScript. If you are a React programmer, then you do not use Angular. An affiliation
    with one tool automatically means a disaffiliation with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such partisanship is a confirming example of Sayre''s law: the arguments are
    so fierce because the stakes are so low. For people who supposedly work in a field
    of rationality and science, we''re really good at getting emotionally brittle
    when somebody wants to use a different library, language, text editor, or whitespace
    symbol than the one we have chosen.'
  prefs: []
  type: TYPE_NORMAL
- en: This fierce disagreement over strongly defended similarities extends to the
    programming paradigm, too. If you are an object-oriented programmer, then your
    mortal enemy is the functional programmer—[http://www.sicpers.info/2015/03/inspired-by-swift/](http://www.sicpers.info/2015/03/inspired-by-swift/),
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Messages Are Just Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not so fast! Recall the working definition of objects I have used throughout
    the antithesis: an object is an isolated, independent computer program that communicates
    with other programs by passing messages. This tells us nothing about *how* to
    build those isolated, independent computer programs. Particularly, there is no
    *mandate* to have mutable state anywhere. The following interface works as a messaging
    interface for a time-varying list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And so, does this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first, time in the list''s lifespan is modeled using successive states
    of the computer memory. In the second, time in the list''s lifespan is modeled
    explicitly, and the history of the list is preserved. Another option is to model
    evolution using *different objects*, turning time into space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now the list looks a lot like a sort of a functional programming list. But it's
    still an object. In each case, we have defined what *messages* the object responds
    to but, remembering the section on *Telling an Object What to Do*, we have not
    said *anything* about what methods exist on that object, and certainly not how
    they are implemented. The `MutableList` and `TemporalList` interfaces use Bertrand
    Meyer's principle of `Datalog` programs, or SQL programs, or be stored as a chain
    of events that is replayed when a query message is received.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ImmutableList` interface, commands are replaced by transforms, which
    ask for a new list that reflects the result of applying a change to the existing
    list. Again, no restriction on *how* you implement those transforms is stated
    (I could imagine building `addObject()` by having a new list that delegates every
    call to the original list, adding 1 to the result of `count()` and supplying its
    own value for `at(originalCount)`; or I could just build a new list with all of
    the existing elements and the new element), but in this case, it's clear to see
    that every method can be a pure function based on the content of the object and
    the message parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that "pure function based on the content of the object and the message
    parameters" is the same as "pure function" more clearly by rewriting the interface
    in Python syntax (skipping the implementations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's now easier to see that each of these methods is a pure function in its
    parameters, where `this`/`self` is a parameter that's automatically prepared in
    other languages (or a part of the method's environment that's automatically closed
    over in others).
  prefs: []
  type: TYPE_NORMAL
- en: Nothing about message-passing says, "please do not use functional programming
    techniques."
  prefs: []
  type: TYPE_NORMAL
- en: An Object's Boundary is Just a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following subsections were deeply informed by the article Objects as Closures:
    abstract semantics of object-oriented languages — [https://dl.acm.org/citation.cfm?id=62721](https://dl.acm.org/citation.cfm?id=62721),
    which builds this view of objects much more rigorously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface to an object is the collection of messages it responds to. In
    many cases, this is backed by a collection of methods, each with the same name
    as the message selector that will invoke it. Not only is this the easiest thing
    to do, it''s also an implementation constraint in many programming languages.
    The preceding Python implementation of `ImmutableList` can be visualized in this
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15099_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Visualization of ImmutableList after implementation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This table can equivalently be replaced by a pure function of type `Message
    Selector->Method to Invoke`. A trivial implementation of the function would look
    up its input in the left-hand column of the table and return the value it finds
    in the same row in the right-hand column. An implementation of `ImmutableList`
    doesn''t need to have any methods at all, choosing functions based on the message
    selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this object works the same way as using an object where the methods were
    defined in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, whichever way you write out an object, its methods are functions that have
    access to (close over) the object's internals, and its message interface is one
    such function that uses the message selector to choose which method to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: Freed from the fetters of the language's idea of where methods live, we see
    that the function to look up implementations from selectors can use *any* information
    available to it. If the object knows about another object, it can send the message
    on to the other object, send a different method in its place, or it could compile
    a new function and use that. The important idea is that *an object is a function
    for finding other functions*.
  prefs: []
  type: TYPE_NORMAL
- en: That Function-Like Boundary? Actually, a Closure Over the Constructor Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `ImmutableList` has a constructor method called `__init__`, which sets up
    the initial state of the object using its arguments, and then the message-finding
    `__getattr__` function, which chooses functions to respond to the messages that
    are sent to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An equivalent way to arrange this is to have the constructor function return
    the message-finding function as a closure over the constructor''s arguments (and
    any transformation implied in "setting up the initial state of the object" can
    be arranged using local variables that are captured in the closure, too). So,
    all in all, an object is a single higher-order function: a function that captures
    its arguments and returns a closure over those arguments that accept messages
    and then chooses a method to execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sticking with Python, and using this insight, `ImmutableList` is reduced to
    a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By the way, this demonstrates why so many object-oriented languages don't seem
    to have a type system. If "*everything is an object*," then even in the most stringent
    of type systems, everything is a `message->method` function, so everything has
    the same type, and everything type checks.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding definition of `ImmutableList` does escape the "everything is an
    object" type scheme by ending with the phrase `else False`, meaning "if I didn't
    find a method, return something that isn't callable, so the user gets a `TypeError`."
    A more complete object system would have the object send itself a `doesNotRespond`
    message here, and no breaking out into Python's usual world of computation would
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Elements of Reusable Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*A pattern for increased monitoring for intellectual property theft by departing
    insiders*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Title of (an article in the Proceedings of the 18th Conference of Pattern
    Languages of Programs —* [https://dl.acm.org/citation.cfm?id=2579157](https://dl.acm.org/citation.cfm?id=2579157)*),
    PLoP''11*'
  prefs: []
  type: TYPE_NORMAL
- en: Christopher Alexander, while evidently seminal in the field of built architecture,
    seems pretty lazy as architects go. Why? Because rather than designing a building
    or even a town *himself*, he expects the people who will live, work, shop, and
    play there to do that for him, and even to build its prototype.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this has little to do with laziness; it's because he believes that
    they are the best people to do the designing as they are the people who best know
    the uses to which the structure will be put and the problems it will solve. What
    does he know about that? Not much; what he knows is the expertise architects have
    gained in solving problems that crop up when designing and constructing towns
    and buildings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *A Pattern Language: Towns, Buildings and Construction*, Alexander and his
    coauthors and reviewers sought to encapsulate that professional knowledge in a
    grammar that would allow a user to solve their own construction problems by taking
    advantage of the solutions known to work by the expert architects. Each pattern
    describes the problem it solves, the context in which it solves it, and the advantages
    and limitations of the solution. Some represent instant decisions to be made –
    the placement of columns in a building construction; others represent experiences
    to be nurtured gradually – the opening of street cafes to facilitate relaxed interaction
    between people and their environment. The grammar developed in *A Pattern Language*
    is additive, so each pattern develops ideas that have been introduced previously
    without depending on patterns that will be seen later, and there are no cyclic
    references. Each pattern is hyperlinked (old-school and using page numbers) to
    the preceding patterns it builds upon.'
  prefs: []
  type: TYPE_NORMAL
- en: We could expect that, in taking inspiration from *A Pattern Language*, software
    designers and builders would create a pattern language that allowed users of computers
    to design and build their own software, by elucidating the problems the users
    are facing and expressing known approaches to solving those problems. And indeed,
    that is exactly what happened when Kent Beck and Ward Cunningham published *Using
    Pattern Languages for Object-Oriented Programs* — [http://c2.com/doc/oopsla87.html](http://c2.com/doc/oopsla87.html).
    The five Smalltalk UI patterns listed in that report are like a microcosm of a
    **Human Interface Guidelines** document, written for the *people who will use
    the interface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what most of us will find when looking for examples of a pattern language
    for software construction are the 23 patterns in the 1994 "Gang of Four" book
    *Design Patterns: Elements of Reusable Design* by Gamma, Helm, Johnson, and Vlissides.
    Compared with the 253 architectural design patterns documented by Alexander et
    al., the software pattern language seems positively anemic. Compared with practice,
    the situation looks even worse. Here are the three patterns that see regular use
    in modern development:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterator` pattern yourself; it''s the one that programming language designers
    have worked out how to supply for you, via the `for (element in collection)` construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: You''ll have only built *Singleton* so that you could write
    that blog post about why *Singleton* is "Considered Harmful."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract Factory**: The butt of all jokes about Java frameworks by people
    who haven''t used Java frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the thing: the *Gang of Four* book is actually very good, and the patterns
    are genuinely repeatable patterns that can be identified in software design and
    that solve common problems. But as Brian Marick argued in Patterns Failed. Why?
    Should we care?—[https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care](https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care),
    the 23 patterns discussed therein are *implementation* patterns, and software
    implementors (that''s us) don''t want repeatable patterns; we want *abstraction*.
    Don''t tell me "Oh, I''ve seen that before, what you do is..."; tell me "Oh, I''ve
    seen that before, here''s the `npm` module I wrote."'
  prefs: []
  type: TYPE_NORMAL
- en: The big winner for software reuse was not information that could be passed from
    one programmer to another, but information that could be passed from one *lawyer*
    to another, which allowed other information to be passed from one programmer to
    *another's program*. The free software license (particularly, due to the conservative
    nature of technologists in business, the non-copyleft free software licenses like
    the MIT or BSD) permitted some programmers to publish libraries to CTAN and its
    spiritual successors, and permitted a whole lot of other programmers to incorporate
    those libraries into their works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that sense, the end situation for software reuse has been incredibly similar
    to the "software ICs" that Brad Cox described, for example, in *Object-Oriented
    Programming: An Evolutionary Approach*. He proposed that we would browse the catalogue
    (the `npm` repository) for software ICs that look like they do what we want, compare
    their data sheets (the `README.md` or Swagger docs), then pick one and download
    it for integration into our applications (`npm install`).'
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, back to design patterns. Marick suggested that the way we work means
    that we can't benefit from implementation patterns because we don't rely on repeated
    practice in implementation. Some programmers do participate in **Code Kata** —
    [http://codekata.com/](http://codekata.com/), a technique for instilling repeated
    practice in programming, but by and large we try to either incorporate an existing
    solution or try something new, not find existing solutions and solve problems
    in similar ways.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, we could vastly shrink the Gang of Four book by introducing **Strategy
    (315)** and describing all of the other problems in its terms. Abstract Factory?
    A **Strategy (315)** for creating objects. Factory Method? The same. Adapter?
    A **Strategy (315)** for choosing integration technologies. State? A **Strategy
    (315)** for dealing with time. But we don't do that, because we think of these
    as different problems, so describe them in different terms and look for different
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: So, abstraction has to stop somewhere. Particularly, it has to stop by the time
    we're talking to the product owners or sponsors, as we're typically building specific
    software tools to support specific tasks. Built architecture has techniques for
    designing residences, offices, shops, and hotels, rather than "buildings," A house
    for a young single worker is different from a house for a retired widow, although
    both are residences with one occupant. So, this points us, as Brian Marick concludes,
    to having design patterns in our software's problem domain, telling us how domain
    experts address the problems they encounter. We might have good abstractions for
    stateful software, or desktop application widgets, or microservice-based service
    architecture, but we have to put them to specific ends, and the people who know
    the field know the problems they're trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'And indeed, that is one of the modern goals of the Pattern Language of Programming
    conference series and the software patterns community. I expected that, on first
    reading, the pull quote chosen for this section ("A pattern for increased monitoring
    for intellectual property theft by departing insiders") would raise a few cynical
    laughs: "Wow, the patterns folks are so far down the rabbit hole that they''re
    writing patterns for *that*?" Well, yes, they are, because it''s a problem that
    is encountered multiple times by multiple people and where knowledge of the common
    aspects of the solution can help designers. Any enterprise IT architect, CISO,
    or small company HR person is going to know that leavers, particularly those who
    left due to disagreements with management or being poached by competitors, represent
    an increased risk of IP theft and will want a way to solve that problem. Here,
    the pattern language shows the important dimensions of the problem, the facets
    of the solution, and the benefits and drawbacks of the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quote from the pattern description is revealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The authors are unaware of any implementation of the pattern in a production
    environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that, while the solution does (presumably and hopefully) capture
    expert knowledge about the problem and how to solve it, it is not tested. The
    design patterns from the Beck and Cunningham paper (and Beck's later *Smalltalk
    Best Practice Patterns*), and indeed the Gang of Four book, were all based on
    *observation* of how problems had commonly been solved. There were not lots of
    C++ or Smalltalk programs that all had classes called `AbstractFactory`, but there
    *were* lots of C++ or Smalltalk programs that solved the "We need to create families
    of related or dependent objects without specifying their concrete classes" problem.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there is nobody outside of an SEI lab who has used "Increased
    Monitoring for Intellectual Property Theft by Departing Insiders" as their solution
    to, well, that. So, perhaps patterns have gotten out of hand.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Method to Run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Don''t go out of your way to justify stuff that''s obviously cool. Don''t
    ridicule ideas merely because they''re not the latest and greatest. Pick your
    own fashions. Don''t let someone else tell you what you should like.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Larry Wall, (Perl, the first postmodern computer language—*[https://www.perl.com/pub/1999/03/pm.html/](https://www.perl.com/pub/1999/03/pm.html/))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Perl community has a mantra: *TIMTOWTDI* (pronounced "Tim Toady"). It stands
    for "There Is More Than One Way to Do It" and reflects the design principle that
    the language should enable its users to write programs in the way in which they
    are thinking and not in the way that the language designer thought about it. Of
    course, TIMTOWTDI is not the only way to do it, and the **Zen of Python**—[http://wiki.c2.com/?PythonPhilosophy](http://wiki.c2.com/?PythonPhilosophy)
    takes a different (though not incompatible) tack:'
  prefs: []
  type: TYPE_NORMAL
- en: '*There should be one-- and preferably only one --obvious way to do it.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how is a method found? There is more than one way to do it. The first,
    and easiest to understand, is that an object has a method with the same name as
    the message selector, and the language assumes that when you send that message,
    it''s because you want to invoke that method. That''s how this looks in Javascript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next way is the most general, and doesn''t exist in all languages and is
    made difficult to use in some. The idea is to have the object *itself* decide
    what to do in response to a message. In Javascript that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While there are many languages that don't have *syntax* for finding methods
    in this way, it's actually very easy to write yourself. We saw in the section
    on functional programming that an object is just a function that turns a message
    into a method, and so any language that lets you write functions returning functions
    will let you write objects that work the way you want them to. This argument is
    also pursued in the talk Object-Oriented Programming in Functional Programming
    in Swift—[https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift](https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift).
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all programming languages that have objects have a fall-through mechanism,
    in which an object that does not have a method matching the message selector will
    look by default at *another* object to find the method. In Javascript, fully bought
    into the worldview of Tim Toady, there are two ways to do this (remember that
    this is already the *third* way to find methods in Javascript). The first, classic,
    original recipe Javascript way, is to look at the object''s prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second way, which in some other languages is the *only* way to define
    a method, is to have the object look at its class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A little bit of honesty at the expense of clarity here: these last two are
    actually just different syntax for the same thing; the method ends up being defined
    on the object''s prototype and is found there. The mental model is different,
    and that''s what is important.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can''t stop there. What if *that* object can''t find the method? In
    the prototype case, the answer is clear: it could look at its prototype, and so
    on, until the method is found, or we run out of prototypes. To an external user
    of an object, it looks like the object has all of the behavior of its prototype
    *and* the things it defines (which may be other, distinct features, or they may
    be replacements for things that the prototype already did). We could say that
    the object *inherits* the behavior of its prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: The situation with inheritance when it comes to classes is muddier. If my object's
    class doesn't implement a method to respond to a message, where do we look next?
    A common approach, used in early object environments such as Simula and Smalltalk,
    and in Objective-C, Java, C#, and others, is to say that a class is a refinement
    of a *single* other class, often called the superclass, and to have instances
    of a class inherit the behavior defined for instances of the superclass, and its
    superclass, until we run out of `superclasses`.
  prefs: []
  type: TYPE_NORMAL
- en: But that's quite limiting. What if there are two different classes of object
    that one object can be seen as a refinement of? Or two different classes that
    describe distinct behaviors it would make sense for this object to inherit? Python,
    C++, and others allow a class to inherit from *multiple* other classes. When a
    message is sent to an object, it will look for a method implementation in its
    class, then in...
  prefs: []
  type: TYPE_NORMAL
- en: '...and now we get confused. It could look breadth-first up the tree, considering
    each of its parents, then each of *their* parents, and so on. Or it could look
    depth-first, considering its first superclass, and *its* first superclass, and
    so on. If there are multiple methods that match a single selector, then which
    is found will depend on the search strategy. And of course, if there are two matching
    methods but with different behavior, then the presence of one may break features
    that depend on the behavior of the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Attempts have been made to get the benefits of multiple inheritance without
    the confusion. **Mixins**—[https://dl.acm.org/citation.cfm?id=97982](https://dl.acm.org/citation.cfm?id=97982)
    represent "abstract subclasses," which can be attached to any superclass. This
    turns a single-superclass inheritance system into one that's capable of supporting
    a limited form of multiple inheritance, by delegating messages to the superclass
    *and any mixins*.
  prefs: []
  type: TYPE_NORMAL
- en: However, this does not address the problem that conflicts will arise if multiple
    mixins, or a superclass and a mixin, supply the same method. A refinement to the
    idea of mixins, called **traits**, introduces additional rules that avoid the
    conflicts. Each trait exposes the features it provides, and the features it requires,
    on the class into which it is mixed. If the same feature is provided by two traits,
    it must either be renamed in one or be removed from both and turned into a requirement.
    In other words, the programmer can choose to resolve the conflict themselves by
    building a method that does what both of the traits need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, inheritance is a great tool for code reuse, allowing one object to borrow
    features from another to complete its task. In "*Smalltalk-80: The Language and
    its Implementation*," that is the justification for inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lack of intersection in class membership is a limitation on design in an object-oriented
    system since it does not allow any sharing between class descriptions. We might
    want two objects to be substantially similar, but to differ in some particular
    way.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, inheritance came to have stronger implications for the intention
    of the designer. While there was always an "is-a" relationship between an instance
    and its class (as in, an instance of the `OrderedCollection` class *is* an `OrderedCollection`),
    there came to be a subset relationship between a class and its subclasses (as
    in, `SmallInteger` is a subclass of `Number`, so any instance of `SmallInteger`
    is also an instance of `Number`). This then evolved into a subtype relationship
    (as in, you have only used inheritance correctly if any program that expects an
    instance of a class also works correctly when given an instance of any subclass
    of that class), which led to the restrictions that tied object-oriented developers
    in knots and led to "favor composition over inheritance": you can only get reuse
    through inheritance if you also conform to these other, unrelated requirements.
    The rules around subtypes are perfectly clear, and mathematically sound, but the
    premise that a subclass *must* be a subtype does not need to be upheld.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, there''s another assumption commonly made that implies a lot of design
    intent: the existence of classes. We have seen that Javascript gets on fine without
    classes, and when classes were added to the language, they were implemented in
    such a way that there is really no "class-ness" at all, with classes being turned
    into prototypes behind the scenes. But the *presence* of classes in the design
    of a system implies, well, the presence of classes: that there is some set of
    objects that share common features and are defined in a particular way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if your object truly is a hand-crafted, artisanal one-off? Well, the
    class design community has a solution for that: Singleton – the design pattern
    that says, "class of one." But why have a *class* at all? At this point, it''s
    just additional work, when all you want is an *object*. Your class is now responsible
    for three aspects of the system''s behavior: the object''s work, the work of making
    the object, and the work of making sure that there is only one of those objects.
    This is a less cohesive design than if you just made one object that did the work.'
  prefs: []
  type: TYPE_NORMAL
- en: If it were possible (as it is in Javascript) to first make an object, then make
    another, similar object, then more, then notice the similarities and differences
    and encapsulate that knowledge in the design of a class that encompasses all of
    those objects, then that one-off object would not need to be anything more than
    an object that was designed once and used multiple times. There would be no need
    to make a class of all objects that are similar to that one, only to constrain
    class membership again to ensure that the singleton instance cannot be joined
    by any compatriots.
  prefs: []
  type: TYPE_NORMAL
- en: But as you've probably experienced, most programming languages only give you
    one kind of inheritance, and *that* is often the "single inheritance, which we
    also assume to mean subtyping" variety. It's easy to construct situations where
    multiple inheritance makes sense (a book is both a *publication* that can be catalogued
    and shelved and it is a *product* that can be priced and sold); situations where
    single inheritance makes sense (a *bag* has all the operations of a *set*, but
    adding the same object twice means it's in the *bag* twice); and situations where
    customizing a prototype makes sense (our hypothesis is that simplifying the **Checkout**
    interaction by applying a fixed shipping cost instead of letting the customer
    choose from a range of options will increase completion among customers attempting
    to check out). It's easy to consider situations in which all three of those cases
    would simultaneously apply (an online bookstore could easily represent books,
    bags, and checkouts in a single system), so why is it difficult to model all of
    those in the same object system?
  prefs: []
  type: TYPE_NORMAL
- en: When it comes down to it, inheritance is just a particular way to introduce
    delegation – one object finding another to forward a message on to. The fact that
    inheritance is constrained to specific forms doesn't stop us from delegating messages
    to whatever objects we like, but it does stop us from making the *reasons* for
    doing so obvious in our designs.
  prefs: []
  type: TYPE_NORMAL
- en: Building Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*What then is a personal computer? One would hope that it would be both a medium
    for containing and expressing arbitrary symbolic notions, and also a collection
    of useful tools for manipulating these structures, with ways to add new tools
    to the repertoire.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Alan C. Kay, "A Personal Computer for Children of All Ages"*'
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk is both a very personal and a very live system. This affected the
    experience of using, building, and sharing objects built in the system, which
    were all done in a way very different from the edit-compile-assemble-link-run
    workflow associated with COBOL and later languages.
  prefs: []
  type: TYPE_NORMAL
- en: '*As an aside, I''m mostly using "Smalltalk" here to mean "Smalltalk-80 and
    later things that derived from it without changing the experience much." Anything
    that looks and feels "quite a lot like" a Smalltalk environment, such as Pharo
    or Squeak, is included. Things that involve a clearly more traditional workflow,
    like Java or Objective-C, are excluded. Where to draw the line is left intentionally
    ambiguous: try out* **GNU Smalltalk***—*[http://smalltalk.gnu.org/](http://smalltalk.gnu.org/)*)
    and decide whether you think it is "a Smalltalk" or not.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Smalltalk environment is composed of two parts: the virtual machine can execute
    Smalltalk bytecode, and the image contains Smalltalk sources, bytecode, and the
    definitions of classes and objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the image is both personal and universal. Personal in the sense that it
    is unique to me, containing the objects that I have created or acquired from others;
    universal in the sense that it contains the whole system: there are no private
    frameworks, no executables that contain the Directory Services objects but not
    the GUI objects, and no libraries to link before I can use networking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it very easy to build things: I make the objects I need, and I find
    and use the objects that I can already take advantage of. On the other hand, it
    makes sharing quite fraught: if I need to make a change to a system object for
    some reason, you cannot take in my change without considering the impact that
    change will have on everything else in your image. If you want to add my class
    to your image, you have to make sure that you don''t already have a class with
    that name. We cannot both use the same key on the `Smalltalk` dictionary for different
    purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: It's also live, in that the way you modify the image is by interacting with
    it. Methods are implemented as Smalltalk bytecode (though that bytecode may simply
    be a request to execute a "primitive method" stored on the virtual machine) by
    writing the method into a text field and sending a message to the compiler object
    asking it to compile the method. Classes are added by sending a message to an
    existing class, asking it to create a subclass. Objects are created by sending
    a `new` message to a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is editing, compilation and debugging, this all takes place within
    the image. This makes for a very rapid prototype and feedback experience (unsurprising,
    as one vision behind Smalltalk was to let children explore the world and computers
    in tandem — [https://mprove.de/diplom/gui/kay72.html](https://mprove.de/diplom/gui/kay72.html).
    Any change you make affects the system you are using, and its effects can be seen
    without rebuilding or quitting an application to launch it again. Similarly, the
    system you are using affects the changes you are making: if an object encounters
    a message to which it does not respond or an assertion is not satisfied, then
    the debugger is brought up, so you can correct your code and carry on.'
  prefs: []
  type: TYPE_NORMAL
- en: The fast feedback afforded by building UIs out of the objects that represent
    UI widgets was used by lots of **Rapid Application Development** tools, such as
    NeXT's Interface Builder, Borland's Delphi and Microsoft's Visual Basic. These
    tools otherwise took a very different position to the trade-offs described previously.
  prefs: []
  type: TYPE_NORMAL
- en: While an IDE like Eclipse might be made out of Java, a Java developer using
    Eclipse is not writing Java that modifies the Eclipse environment, even where
    the Java package they are writing is an Eclipse plugin. Instead, they use the
    IDE to host tools that produce *another* program containing their code, along
    with references to other packages and libraries needed for the code to work.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is generic rather than personal (anyone with the same collection
    of packages and libraries can make the standalone code work without any step integrating
    things into their image) and specific rather than universal (the resulting program
    – mistakes aside – contains only the things needed by that program).
  prefs: []
  type: TYPE_NORMAL
- en: This one key difference – that there is a "build phase" separating the thing
    you're making from the thing you're making it in – is the big distinction between
    the two ways of building objects, and one of the ways in which the transfer of
    ideas in either direction remains imperfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those Rapid Application Development tools with their GUI builders let you set
    up the UI widgets from the vendor framework and configure their properties, by
    working with live objects rather than writing static code to construct a UI. In
    practice, the limitations on being able to do so are:'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the quality of a UI, you need to work with the real information
    and workflows the interface exposes, and that is all in the program source that's
    sat around in the editor panes and code browsers, waiting to be compiled and integrated
    with the UI layout into the (currently dormant) application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes outside the capability of the UI editor tool cannot be reflected within
    it. Changing the font on a label is easily tested; writing a new text transform
    to be applied to the label's contents is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bits of a UI that you can test within a UI builder are usually well-defined
    by the platform's interface guidelines anyway, so you never *want* to change the
    font on a label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, even with a UI builder you still have an edit-build-debug workflow.
  prefs: []
  type: TYPE_NORMAL
- en: A similar partial transfer of ideas can be seen in test-driven development.
    A quick summary (obviously, if you want the long version, you could always *buy
    my book*—[https://qualitycoding.org/test-driven-ios-development-book/](https://qualitycoding.org/test-driven-ios-development-book/))
    is that you create an object incrementally by thinking of the messages you want
    to send it, then what it should do in response, then you send those messages and
    record whether you get the expected responses. You probably do not get the expected
    response, as you have not told the object how to behave yet, so you add the bit
    of behavior that yields the correct response and move on to the next message,
    after doing a bit of tidying up.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of Smalltalk, we have already seen that something unexpected happening
    leaves you in the debugger, where you can patch up the thing that's broken. So,
    the whole of the preceding process can be resummarised as "think of a message,
    type it in, hit *do it*, edit the source until the debugger stops showing up,"
    and now you have an increment of working software in your image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of Java, even though the same person wrote both the SUnit and
    JUnit testing tools, the process is (assuming you already have a test project
    with the relevant artefacts):'
  prefs: []
  type: TYPE_NORMAL
- en: Write the code to send the message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Appease the compiler
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run the test target
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the output to guide changes, back in the editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat 3 and 4 until the test passes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, there's a much longer feedback loop. That applies to any kind of feedback,
    from acceptance testing to correctness testing. You can't build the thing you're
    building from within itself, so there's always a pause as you and your computer
    switch context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this context switch is only partly due to technology: in 2003,
    when Apple introduced Xcode, they made a big deal of "fix and continue," a facility
    also available in Java environments, amongst others: when the source code is changed,
    within certain limits, the associated object file can be rebuilt and injected
    into the running application without having to terminate and re-link it. However,
    that is typically not how programmers *think* about their activities. The worldview
    that lends us words like "toolchain" and "pipeline" is one of sequential activities,
    where a program may *end up* "in production" but certainly doesn''t *start* there.
    People using the programs happens at the end, when the fun is over.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion to Part One
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that Object-Oriented Programming is indeed, as many detractors
    suggest, a complex paradigm with many moving parts. We have also seen that this
    complexity is not essential: at its core is a single idea that a problem can be
    modeled as lots of distinct, interacting agents, and that each of those agents
    can be modeled as a small, isolated computer program. The solution to the original
    problem is found in the interaction between those agents, which is mediated by
    message passing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the incidental complexity seems to have been added by people wanting
    to make their mark: the proliferation in design patterns appears to have occurred
    because it is always easier to add a new pattern than to consolidate existing
    ones; however much some people might like to erase Singleton from history. Objects
    are not "just" decomposition and message-passing, they are that *and* providing
    access to a program''s data, or that *and* a hierarchy of classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of the complexity associated with objects comes from another source: trying
    to treat object-oriented programming as much like the structured, procedural,
    imperative processes that came before, and map its terminology onto the thought
    structures and workflows of the established ways of writing software. This is
    the "structured on-ramp" of this section''s introduction, in which OOP is seen
    as an extension to existing ideas, and programs are made "better" by adding objects
    in the same way that food is made "better" by sprinkling paprika on top. Thus,
    it is that Ann Weintz could say that "A NeXT Object is simply a piece of C code"
    in *Writing NeXT Applications.* Thus, object-oriented software engineering is
    about building complex software systems by careful, top-down analysis of the procedures
    (or bottom-up analysis of the data and its manipulations), while also as a side
    activity creating a hierarchy of classes with particular relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: If objects are something you do *as well as* writing software, then no wonder
    it is harder than not using the objects! OOP seems to have failed, but it may
    not even have been attempted.
  prefs: []
  type: TYPE_NORMAL
