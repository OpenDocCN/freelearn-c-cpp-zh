<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor090"/>7</h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor091"/>A Perfectly Decoupled System</h1>
<p>In the previous chapter, we learned about interfaces and event delegates and how they can be used as tools to remove the need for unnecessary object references within our program structures. This was the concept of decoupling.</p>
<p>In this chapter, we will take the concept of decoupling and extrapolate it throughout our system design. We will look at a structure that should provide a robust framework for any system and the standard method for planning it.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>Using UML to plan a sample hierarchy</li>
<li>Decoupling the reference train</li>
</ul>
<p>By the end of this chapter, you will be able to architect complex game communication hierarchies in a fully decoupled and modular way. This will allow you to build more maintainable and expandable systems that enable development team cohesion.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/>Technical requirements</h1>
<p>This chapter will be focused on implementing the tools from <a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a> in the same project, linked on GitHub.</p>
<p>If you want to jump straight in at this point, you can download the <em class="italic">chapter7</em> branch from GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07</a></p>
<p>Otherwise, the planning section only really requires a pen and paper or a free drawing tool. Once the purpose and vocabulary of UML diagrams have been grasped, there are helpful online tools for speeding up their generation. The easiest to use is Mermaid (<a href="https://mermaid.live">https://mermaid.live</a>), which provides a text editing interface for diagram editing. It presents as a paid service if you wish to save multiple diagrams, but seeing as every element of your diagram or chart is serialized as text in the URL, shown in the address bar of your browser, a simple copy and paste of the URL into a notes app will save the diagram. Other tools include Photoshop and Paint or dedicated drawing tools such as drawio.com (<a href="https://www.drawio.com/">https://www.drawio.com/</a>) and whimsical.com (<a href="https://whimsical.com/">https://whimsical.com/</a>).</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/>Using UML to plan a sample hierarchy</h1>
<p><strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) is <a id="_idIndexMarker263"/>a tool that programmers use to visually communicate the structure of large systems during the design phase and when creating technical documentation. Classes<a id="_idIndexMarker264"/> are represented as boxes, with relationships<a id="_idIndexMarker265"/> shown through different types of arrows linking the boxes.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>What are the types of class relations?</h2>
<p>Let us take a look at different types of <a id="_idIndexMarker266"/>class relations and how they are presented using UML class diagrams.</p>
<h3>Inheritance</h3>
<p>Standard<a id="_idIndexMarker267"/> arrows, as seen in <em class="italic">Figure 7</em><em class="italic">.1</em>, show inheritance with the parent being indicated by the end with the arrow head.</p>
<div><div><img alt="Figure 7.1 – An example of a UML class diagram showing inheritance syntax" src="img/Figure_07.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – An example of a UML class diagram showing inheritance syntax</p>
<p>In <em class="italic">Figure 7</em><em class="italic">.1</em>, the <strong class="bold">Character</strong> and <strong class="bold">Vehicle</strong> classes inherit from the <strong class="bold">Pawn</strong> class.</p>
<h3>Composition</h3>
<p><strong class="bold">Composition</strong> is a <a id="_idIndexMarker268"/>type of class relation where the composed classes give the parent<a id="_idIndexMarker269"/> class the functionality. This tool is seen a lot with multi-functional classes being broken down into their separate functions then composed together into a wrapper. You can show composition with a solid diamond at the end of a line.</p>
<div><div><img alt="Figure 7.2 – An example UML class diagram showing composition syntax" src="img/Figure_07.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – An example UML class diagram showing composition syntax</p>
<p>In <em class="italic">Figure 7</em><em class="italic">.2</em>, <strong class="bold">GameGrid</strong> composes a reference to <strong class="bold">Pathfinder</strong> and <strong class="bold">FogManager</strong>.</p>
<h3>Aggregation</h3>
<p><strong class="bold">Aggregation</strong> is a <a id="_idIndexMarker270"/>concept crucial to designing decoupled systems as it quite literally represents the coupling that is present. At some point in the communication chain, for<a id="_idIndexMarker271"/> objects to communicate, at least a one-way connection must be established. Aggregation is when that connection is between two non-dependent classes. Similar to composition, aggregation is also shown by a line with a diamond at the head but the diamond for aggregation is just an outline.</p>
<div><div><img alt="Figure 7.3 – An example UML class diagram showing aggregation syntax" src="img/Figure_07.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – An example UML class diagram showing aggregation syntax</p>
<p><em class="italic">Figure 7</em><em class="italic">.3</em> shows <strong class="bold">Pawn</strong> and <strong class="bold">Widget</strong> aggregated into <strong class="bold">PlayerController</strong>. Both can exist and function<a id="_idIndexMarker272"/> without<a id="_idIndexMarker273"/> this connection so it is an aggregation.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>What is a sequence diagram?</h2>
<p>In addition to the UML class <a id="_idIndexMarker274"/>diagrams we’ve explored so far, UML has more forms it can take. A <strong class="bold">sequence diagram</strong>, shown in <em class="italic">Figure 7</em><em class="italic">.4</em>, shows the execution of functions between objects over time. This is a crucial way to show how signals get around your class structures. Using a sequence diagram after something goes wrong can help identify what a call stack should look like at different lines of execution to pinpoint errors.</p>
<div><div><img alt="Figure 7.4 – An example UML sequence diagram" src="img/Figure_07.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – An example UML sequence diagram</p>
<p>In <em class="italic">Figure 7</em><em class="italic">.4</em>, we are <a id="_idIndexMarker275"/>communicating an initialization chain from <strong class="bold">GameMode</strong> through <strong class="bold">PlayerController</strong> to <strong class="bold">Character</strong>. The sequence diagram helps us see that when the <strong class="bold">Character Init</strong> function is executing, our call stack should be three deep and what order each class is in the chain. These diagrams are necessary for clarifying key communications but, as with all UML, it can have the opposite effect if it tries to encompass too much at once.</p>
<p>With these tools in our belt, we can better describe the structures coming up in this chapter to other developers. The benefit of using UML over coding segments is in its standardization and agnosticism, meaning the programmer we show this to doesn’t need to speak the same language to understand what we mean.</p>
<p>Decoupling references is a key skill for all developers in all object-oriented languages to understand. With universal methods of communication such as UML, we can establish a precedent and enforce it across all levels of development. Let's now use loads of sequence diagrams and aggregation to fix some messy, heavily coupled code.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/>Decoupling the reference train</h1>
<p>Now let’s take knowledge of these <a id="_idIndexMarker276"/>three connection types and see how we can associate every class in the example UML class diagram that follows, using a few rules. Once everything is associated, we’ll implement decoupling in an example and look at the benefits this brings.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>Modularity and decoupling</h2>
<p>We’ll start with a bunch of <a id="_idIndexMarker277"/>scattered classes, which are organized in a way that will function but is messy to work with, as shown in <em class="italic">Figure 7</em><em class="italic">.5</em>. To make everything function here<a id="_idIndexMarker278"/> clearly, the developer has added references, as and when needed, to any class.</p>
<div><div><img alt="Figure 7.5 – Example UML showing a messy system" src="img/Figure_07.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Example UML showing a messy system</p>
<p>Let’s analyze how the <strong class="bold">Character</strong> to <strong class="bold">Projectile</strong> interaction occurs by looking at the sequence diagram in <em class="italic">Figure 7</em><em class="italic">.6</em>. When the character <em class="italic">fires</em>, it spawns a projectile but then doesn’t hold onto the reference. Instead, the projectile grabs a reference to the character and when it hits an AI unit, this reference is used to feed back whether it killed anything through a function call. Why is this bad? It’s not necessarily going to impact the final built game, but it does make the code involved in this interaction single-use. If an enemy unit wants to fire, due to it being a different setup, we are left with two bad options:</p>
<ul>
<li>Bastardization through inheritance and overloading functions, thereby breaking several of our SOLID principles</li>
<li>Repeat ourselves in a new actor, which, as we know, should ring alarm bells</li>
</ul>
<div><div><img alt="Figure 7.6 – Example UML sequence diagram showing the complexity of a messy interaction" src="img/Figure_07.06_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Example UML sequence diagram showing the complexity of a messy interaction</p>
<p>The solution to this <a id="_idIndexMarker279"/>problem is<a id="_idIndexMarker280"/> modularity and decoupling. We need to establish a hierarchy where each class is connected to a single tree, where connections represent ownership. The first step is to analyze class responsibilities. The <strong class="bold">Character</strong> class currently takes care of too many areas. It deals with player representation in the world but also weapon logic. Due to this logic possibly being duplicated in the AI enemy class, it makes sense to spin it out into its own class that can be shared. Linking this into an aggregation chain with the <strong class="bold">GameMode</strong> at the top, flowing down through the <strong class="bold">Character</strong> and <strong class="bold">Weapon</strong> to the <strong class="bold">Projectile</strong>, gives us the tree we were aiming for from the start, as shown in <em class="italic">Figure 7</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 7.7 – A UML class diagram showing classes in a tree structure" src="img/Figure_07.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – A UML class diagram showing classes in a tree structure</p>
<p>In general terms, the <a id="_idIndexMarker281"/>tree we established in <em class="italic">Figure 7</em><em class="italic">.7</em> is conceptual. There could be pointers to o<a id="_idIndexMarker282"/>wned classes in parents for practicality, but it mostly exists in the design document. In Unreal, everything below the PlayerController can be spawned at runtime, which helps to make the structure more concrete. All spawned objects can be cached as <code>TObjectPtr&lt;T&gt;</code> variables, with <code>T</code> being the exact type we need. To link the tree up above the <code>PostLogin</code> and <code>Logout</code> functions of <code>AGameModeBase</code>, PlayerControllers can be cached in a <code>TArray&lt;TObjectPtr&lt;APlayerController&gt;&gt;</code> for later use. If you want to make a distinction between AIController and PlayerController in the structure, then you will need to store them separately. PlayerControllers can be cached via the <code>PostLogin</code> function with a cast to the respective base type as needed, but AIControllers must<a id="_idIndexMarker283"/> be cached when the AI-controlled pawn is spawned and<a id="_idIndexMarker284"/> accessed via the instigator reference.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Be aware that <code>PostLogin</code> only fires for PlayerControllers, yet <code>Logout</code> deals with all controller types, including AI. This makes defensive coding important in <code>Logout</code>.</p>
<div><div><img alt="Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes are connected" src="img/Figure_07.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes are connected</p>
<p><em class="italic">Figure 7</em><em class="italic">.8</em> shows how the different methods described in this section could be used to connect the classes in memory.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Establishing infrastructure</h2>
<p>The next step is to start establishing infrastructure, such as public functions, event delegates, and interfaces, to provide entry and exit points for signals. Each fulfills a very specific purpose:</p>
<ul>
<li><strong class="bold">Public functions</strong> are used for <a id="_idIndexMarker285"/>communication when there is a cached variable reference of the correct type. Following the aggregation lines that represent this connection, as shown in <em class="italic">Figure 7</em><em class="italic">.8</em>, all function calls will happen to head down the tree through the chain of ownership.</li>
<li><strong class="bold">Event delegates</strong> allow <a id="_idIndexMarker286"/>anonymous communication when the listener has a cached variable reference for the event’s class. This ends up being the exact opposite of the public function calls, allowing communication to back up the reference chain toward the top of the tree.</li>
<li><code>AActor*</code> reference that can be gained at runtime, usually via some kind of collision event, the interface can be used to invoke some kind of function without needing to know the exact type of the receiver.</li>
</ul>
<p>This boils down to a simple communication rule: <em class="italic">functions down, events up, and interfaces sideways</em>. The result is a decoupled system in which each class only has reference to the one layer below it and yet signals can be sent all over with ease.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Implementing decoupled design in an example</h2>
<p>The best way to embed <a id="_idIndexMarker288"/>decoupled design into your process is to practice it. As a start, we will focus on how using the player character in our example project can receive points shown on the UI for eliminating enemy units. We will start with the UML class diagram shown in <em class="italic">Figure 7</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 7.9 – Planned UML class diagram for the linked project" src="img/Figure_07.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Planned UML class diagram for the linked project</p>
<p>Next, we will overlay the <a id="_idIndexMarker289"/>signal path onto the UML, as shown in <em class="italic">Figure 7</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 7.10 – Signal path overlayed on UML class diagram" src="img/Figure_07.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Signal path overlayed on UML class diagram</p>
<p>Overlaying the signal path onto the UML will allow us to plan the infrastructure effectively, producing a UML sequence diagram, as shown in <em class="italic">Figure 7</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 7.11 – UML sequence diagram showing the signal path for killing an enemy" src="img/Figure_07.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – UML sequence diagram showing the signal path for killing an enemy</p>
<p>To put this decoupled<a id="_idIndexMarker290"/> plan into practice, head to the folder labeled <a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic">Chapter 7</em></a> in the example project. Open the level in this folder and take the following steps. Whenever a class is mentioned, please use the <a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic">Chapter 7</em></a> version denoted by  <code>_CH7</code> in the class and filenames. All of the following code is for you to add and embellish as you see fit. All the needed classes have been created already. This exercise only requires you to add the new code to the areas specified by the protection-level tags. Any new variables will need to be linked up in the inspectors of the Blueprint children in the editor, but this is made clear at the end of this section.</p>
<p>Stepping through the implementation, let’s start at the top in the game mode. <code>GameMode_CH7</code> will have links to <code>PlayerController_CH7</code> and any AI spawned in the level. This may work better with an AI manager for larger games, but we have no need to over-complicate the process. These references are cast to the correct types and cached. After casting, <code>listener</code> functions can be attached to the event delegates on the controllers, establishing the first link, but we haven’t made any controllers yet so we will return here once the initialization chain is complete.</p>
<p>The GameMode header is a simple set of holder variables and the start of the initialization chain in a <code>BeginPlay</code> override.</p>
<p>Let's get started with the header file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GameMode_CH7.h excerpt</p>
<pre class="source-code">
class AGameMode_CH7 : public AGameModeBase
{
public:
    virtual void PostLogin(APlayerController* NewPlayer) override;
    virtual void Logout(AController* Exiting) override;
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;APlayerController_CH7&gt; _PlayerController;
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TArray&lt;TObjectPtr&lt;AAIController_CH7&gt;&gt; _AIControllers;
    virtual void BeginPlay() override;
};</pre> <p>The GameMode body deals with PlayerController initialization and reference registry in the <code>PostLogin</code> and <code>Logout</code> functions as that is what Unreal will automatically call when PlayerControllers enter and exit the game. This can be confusing as it is networking<a id="_idIndexMarker291"/> terminology but Unreal still uses it for single-player games. On the other hand, AIControllers are gathered and initialized on <code>BeginPlay</code> as they are assumed to be in the level already.</p>
<p>So, now, we can set these up in the body file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GameMode_CH7.cpp excerpt</p>
<pre class="source-code">
void AGameMode_CH7::PostLogin(APlayerController* NewPlayer)
{
    if (APlayerController_CH7* castedPC = Cast&lt;APlayerController_CH7&gt;        (NewPlayer))
    {
        _PlayerController = castedPC;
        _PlayerController-&gt;Init();
    }
    Super::PostLogin(NewPlayer);
}
void AGameMode_CH7::Logout(AController* Exiting)
{
    if (Exiting == _PlayerController)
    {
        _PlayerController = nullptr;
    }
    Super::Logout(Exiting);
}
void AGameMode_CH7::BeginPlay()
{
    Super::BeginPlay();
    TArray&lt;AActor*&gt; outActors;
    UGameplayStatics::GetAllActorsOfClass         (GetWorld(), AAIController::StaticClass(), outActors);
    
    for (AActor* actor : outActors)
    {
        _AIControllers.Add(Cast&lt;AAIController_CH7&gt;(actor));
    }
    
    for (AAIController_CH7* ai : _AIControllers)
    {
        ai-&gt;Init();
    }
}</pre> <p>Next, the controllers need to gain reference to and initialize the characters they are controlling. This is a simpler process than before as the controllers all spawn in their characters via an initialization chain. This means there is no need for casting; the characters are already the correct type. This also applies to the <code>ScoreWidget</code> class we will use to display the<a id="_idIndexMarker292"/> player’s score, which has been provided as part of the <code>Chapter </code><code>Resources</code> folder.</p>
<p>The PlayerController header has a custom public function for initialization, a class reference to the type of pawn it would like to spawn, and an object reference to the actual pawn it has spawned.</p>
<p>Write out the PlayerController header file as shown in the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PlayerController_CH7.h excerpt</p>
<pre class="source-code">
class APlayerController_CH7 : public APlayerController
{
public:
    void Init();
protected:
    UPROPERTY(EditAnywhere)
    TSubclassOf&lt;APawn&gt; _PlayerPawn;
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;ACharacter_CH7&gt; _Character;
};</pre> <p>In the PlayerController body, we use the functions provided to us by Unreal within the GameMode class to spawn a new pawn of the type specified in the header at one of the player start points. The <a id="_idIndexMarker293"/>PlayerController then possesses it and calls the initialization function on that pawn.</p>
<p>Let's set that up.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PlayerController_CH7.cpp excerpt</p>
<pre class="source-code">
void APlayerController_CH7::Init()
{
    if (GetPawn() != nullptr)
    {
        GetPawn()-&gt;Destroy();
    }
    UWorld* const world = GetWorld();
    AActor* tempStart = UGameplayStatics::GetGameMode         (world)-&gt;FindPlayerStart(this);
    FVector spawnLoc = tempStart != nullptr ?         tempStart-&gt;GetActorLocation() : FVector::ZeroVector;
    FRotator spawnRot = tempStart != nullptr ?         tempStart-&gt;GetActorRotation() : FRotator::ZeroRotator;
    FActorSpawnParameters spawnParams;
    spawnParams.SpawnCollisionHandlingOverride =         ESpawnCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
    APawn* tempPawn = world-&gt;SpawnActor&lt;APawn&gt;        (_PlayerPawn, spawnLoc, spawnRot, spawnParams);
    Possess(tempPawn);
    if (ACharacter_CH7* _Character = Cast&lt;ACharacter_CH7&gt;(tempPawn))
    {
        _Character-&gt;Init();
    }
}</pre> <p>Down the other branch <a id="_idIndexMarker294"/>from the GameMode, our AIController header is similar to the PlayerController minus the reference to the class it would like to spawn, as with a standard Unreal AI setup the pawn is already in the world.</p>
<p>So, the header file for the AIController needs to be set out like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIController_CH7.h excerpt</p>
<pre class="source-code">
class AAIController_CH7 : public AController
{
public:
    void Init();
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;AAIUnit_CH7&gt; _Unit;
};</pre> <p>This point of the AIController being a generally simpler implementation extends to the initialization function. As there is no need to spawn any new pawns, we can simply get a reference to the currently possessed one and call its initialization function, passing the communication on.</p>
<p>Write the Initialization function as shown:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIController_CH7.cpp excerpt</p>
<pre class="source-code">
void AAIController_CH7::Init()
{
    if (APawn* pawn = GetPawn())
    {
        if (_Unit = Cast&lt;AAIUnit_CH7&gt;(pawn))
        {
            _Unit-&gt;Init();
        }
    }
}</pre> <p>The last initialization is the <code>AIUnit</code> class. In the header, we have a variable to hold a <code>HealthComponent</code>, like the one we made at the end of <a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a>, and a <code>listener</code> function to<a id="_idIndexMarker295"/> bind to the component’s event for death.</p>
<p>So, let's setup the AIUnit header.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIUnit _CH7.h excerpt</p>
<pre class="source-code">
class AAIUnit_CH7 : public APawn
{
public:
    AAIUnit_CH7();
    void Init();
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;UHealthComponent&gt; _HealthComp;
    UFUNCTION()
    void Handle_HealthDeath(AController* causer);
};</pre> <p>The body makes a new instance of a <code>HealthComponent</code> in the constructor and binds the <code>listener</code> function in the initialization.</p>
<p>We should now add the <code>HealthComponent</code> and initialization functions to the AIUnit body file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIUnit _CH7.cpp excerpt</p>
<pre class="source-code">
AAIUnit_CH7::AAIUnit_CH7()
{
    _HealthComp = CreateDefaultSubobject&lt;UHealthComponent&gt;
    (TEXT("Health"));
}
void AAIUnit_CH7::Init()
{
    _HealthComp-&gt;OnDead.AddDynamic         (this, &amp;AAIUnit_CH7::Handle_HealthDeath);
}</pre> <p>Now that all classes are<a id="_idIndexMarker296"/> initialized, we can step back up through the chain, adding the event delegates and their <code>listener</code> functions, starting with how the <code>AIUnit</code> responds to the health component death event. This needs to be done on both branches of the tree for the player and AI side, but we will only show the AI side as that is where the points come from. The listener should broadcast the <code>AIUnit</code> death event for now, including however many points this <code>AIUnit</code> was worth. This link is where animations and sound effects could be played to provide feedback to the player.</p>
<p class="callout-heading">Extension task</p>
<p class="callout">The ot<a id="_idTextAnchor100"/>her damage event in the <code>HealthComponent</code> is being ignored for the purpose of explaining the process. As an extension task after finishing the chapter, try to hook this up so that when an AI character receives damage, it feeds through the chain to the controller and updates the health bar from there.</p>
<p>Adding the following code through the <code>AIUnit</code> header, we declare a n<a id="_idTextAnchor101"/>ew delegate type called <code>FAIUnitDeathSignature</code> with two parameters. This type is then used in the c<a id="_idTextAnchor102"/>lass header to make the <code>OnUnitDeath</code> public delegate. We also add an integer here so that we can <a id="_idIndexMarker297"/>balance the value of destroying the unit to the player.</p>
<p>So, lets add those to the header file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIUnit _CH7.h excerpt</p>
<pre class="source-code">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams     (FAIUnitDeathSignature, AController*, causer, int, points);
class AAIUnit_CH7 : public APawn
{
public:
    UPROPERTY(BlueprintAssignable)
    FAIUnitDeathSignature OnUnitDeath;
protected:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int _PointValue;
};</pre> <p>The <code>AIUnit</code> body is much simpler though, as we are just using it to be a link in a chain, so once the <code>HealthComponent</code> death listener function fires, it can broadcast the new <code>OnUnitDeath </code>delegate and destroy the pawn.</p>
<p>Add the following code to the body file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIUnit _CH7.cpp excerpt</p>
<pre class="source-code">
void AAIUnit_CH7::Handle_HealthDeath(AController* causer)
{
    OnUnitDeath.Broadcast(causer, _PointValue);
    Destroy();
}</pre> <p>Following up the chain, the AIController can start listening to the AIUnit’s pass-through death event. This level is another pass-through for now, but could be where the controller recycles itself and finds another <code>AIUnit</code> to spawn depending on the gameplay loop.</p>
<p>The AIController <a id="_idIndexMarker298"/>header gets a similar set of items to the <code>AIUnit</code> with a new delegate type definition that takes two parameters. We don’t reuse the definition in the unit so that when we come to expand the game, these two classes aren’t tied to each other and can be swapped out as necessary. There is also a <code>private</code> function that matches the<a id="_idTextAnchor103"/> signature for the <code>AIUnit</code> <code>OnUnitDeath</code> delegate so it can be added as a listener.</p>
<p>Go ahead and add the following code to the header file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIController_CH7.h excerpt</p>
<pre class="source-code">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams     (FControllerDeathSignature, AController*, causer, int, points);
class AAIController_CH7 : public AController
{
public:
    UPROPERTY(BlueprintAssignable)
    FControllerDeathSignature OnControllerDeath;
protected:
    UFUNCTION()
    void Handle_UnitDeath(AController* causer, int points);
};</pre> <p>The AIController body binds the<a id="_idTextAnchor104"/> <code>listener</code> function to the <code>AIUnit OnUnitDeath</code> delegate right after the <code>Init</code> function is called. This way, we know that all variables inside the <code>AIUnit</code> have been set up correctly before we start listening for gameplay signals. The listener function itself is then just a pas<a id="_idTextAnchor105"/>sthrough broadcasting the <code>OnControllerDeath</code> delegate.</p>
<p>Let's add that to the code in the body file.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">AIController_CH7.cpp excerpt</p>
<pre class="source-code">
void AAIController_CH7::Init()
{
    if(APawn* pawn = GetPawn())
{
if(_Unit = Cast&lt;AAIUnit_CH7&gt;(pawn))
        {
            _Unit-&gt;Init();
            _Unit-&gt;OnUnitDeath.AddDynamic(this,
                &amp;AAIController::Handle_UnitDeath);
        }
    }
}
void AAIController_CH7::Handle_UnitDeath(
    AController* casuer, int points)
{
    OnControllerDeath.Broadcast(causer, points);
}</pre> <p>The GameMode can<a id="_idIndexMarker299"/> now link a listener function to all the AIControllers. <a id="_idTextAnchor106"/>This function just calls a <code>public</code> function on the PlayerController to increment its points for now, but it can be used as a jumping-off point to check against win conditions, and in a multiplayer scenario, make sure all players have an <a id="_idTextAnchor107"/>updated scoreboard via the <code>GameState</code>.</p>
<p>This following excerpt shows where to add the listener function declaration in the GameMode header.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GameMode_CH7.h excerpt</p>
<pre class="source-code">
class AgameMode_CH7 : public AgameModeBase
{
protected:
    void Handle_ControllerDeath(AController* causer, int points);
}</pre> <p>In the GameMode body, we then bind the listener function to each AIControll<a id="_idTextAnchor108"/>er right after we call the <code>Init</code> function on each one. This time, the listener function doesn’t simply broadcast another event, as this is where the communication reverses and starts going down another branch of the communication hierarchy that we designed earlier in the chapter. Instead, we call a function on the PlayerController telling it to add points. This is not strictly the best way of do<a id="_idTextAnchor109"/>ing this, but it does show the structure cleanly. Ideally, you would check which controller needed the points based on the <code>causer</code> argument passed <a id="_idIndexMarker300"/>through the delegate chain.</p>
<p>So, add the following code to the body file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GameMode_CH7.cpp excerpt</p>
<pre class="source-code">
void AGameMode_CH7::BeginPlay()
{
    … other code from before …
for(AAIController_CH7* ai : _AIControllers)
{
    ai-&gt;Init();
    ai-&gt;OnControllerDeath.AddDynamic(this,
        &amp;AgameMode_CH7::Handle_ControllerDeath);
}
}
void AGameMode_CH7::Handle_ControllerDeath(
    AController* causer, int points)
{
    _PlayerController-&gt;AddPoints(points);
}</pre> <p>The Player controller then needs to implement this <code>public</code> function so that when the game mode tells it to add points, it updates the UI as well. The UI references are included in the class for you already – that’s why they are missing from the header in the following code.</p>
<p>The PlayerController<a id="_idIndexMarker301"/> header just needs the public accessor <code>AddPoints</code> function and a variable to store the current number of points. This is arbitrary but they must be stored somewhere, and this seems like as good a place as any to store them.</p>
<p>So, let's add these:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PlayerController_CH7.h excerpt</p>
<pre class="source-code">
class APlayerController_CH7 : public APlayerController
{
public:
    void AddPoints(int points);
protected:
    int _Points;
}</pre> <p><code>AddPoints</code> does what it says on the tin, but also serves as a signal passthrough for the UI where we tell it to update the value shown onscreen with the new points value.</p>
<p>Add the following excerpt to the body file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PlayerController_CH7.cpp excerpt</p>
<pre class="source-code">
void APlayerController_CH7::AddPoints(int points)
{
    _Points += points;
    _PointsWidget.UpdatePoints(_Points);
}</pre> <p>With that all done, you<a id="_idIndexMarker302"/> should be able to play the game as before from this new level, but when you destroy enemy AI units, the number at the top left of the viewport increases each time. This is the core of a game loop built in a decoupled way. Of course, our AI needs to fight back and there needs to be some balancing to make this into a good gameplay experience, but functionally it is all there.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor110"/>Benefits of decoupling</h2>
<p>The benefit of setting <a id="_idIndexMarker303"/>things up in a decoupled way should now be evident. If we need to swap out game modes for a different objective-based mode, then we can do that as no class needs a direct reference to the game mode. As long as all the same functions are called and the events are listened to, everything will function. You can also check the size of the dependencies for each class using the method shown in <a href="B18297_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> to see how small each class is in memory now that it has a reference to only one layer below itself and maybe an interface or two.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor111"/>Summary</h1>
<p>With this chapter completed, you should be equipped to design communication hierarchies for games with a focus on anonymous modular design in UML for implementation within Unreal. We have covered the basics of UML and why it is useful as a planning and communication tool. Using this UML, we then set about taking a simple communication and anonymizing it using the event delegate tool from <a href="B18297_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a> to decouple the reference chain as much as we could. This anonymous modular should work for most communications you design from here on, with exceptions being extremely rare.</p>
<p>In the next chapter, we are going to look at patterns you can set up as a library to move around with you between projects. We will look at why you should not overuse the singleton pattern, as most people do, and why you should make use of the command and state patterns in almost every project.</p>
</div>


<div><h1 id="_idParaDest-101" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor112"/>Part 3: Building on Top of Unreal</h1>
</div>
<div><p>In this part, we will take the leap from looking at patterns that have already been scaffolded to making some of our own.</p>
<p>Each chapter deals with a different category of pattern, starting with behavioral patterns that allow classes to serve their use more cleanly, through structural patterns that assist you when building systems for a large team to work on, to optimization patterns that aim to speed up your code. By the end of this section, you should have a host of patterns built in a modular way, ready to be transferred between projects.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18297_08.xhtml#_idTextAnchor113"><em class="italic">Chapter 8</em></a><em class="italic">, Building Design Patterns – Singleton, Command, and State</em></li>
<li><a href="B18297_09.xhtml#_idTextAnchor130"><em class="italic">Chapter 9</em></a><em class="italic">, Structuring Code with Behavioral Patterns – Template, Subclass Sandbox, and Type Object</em></li>
<li><a href="B18297_10.xhtml#_idTextAnchor148"><em class="italic">Chapter 10</em></a><em class="italic">, Optimisation through Patterns</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>