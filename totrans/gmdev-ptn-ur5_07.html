<html><head></head><body>
<div id="_idContainer136">
<h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.2.1">A Perfectly Decoupled System</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about interfaces and event delegates and how they can be used as tools to remove the need for unnecessary object references within our program structures. </span><span class="koboSpan" id="kobo.3.2">This was the concept </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">of decoupling.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will take the concept of decoupling and extrapolate it throughout our system design. </span><span class="koboSpan" id="kobo.5.2">We will look at a structure that should provide a robust framework for any system and the standard method for </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">planning it.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Using UML to plan a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">sample hierarchy</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Decoupling the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">reference train</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will be able to architect complex game communication hierarchies in a fully decoupled and modular way. </span><span class="koboSpan" id="kobo.13.2">This will allow you to build more maintainable and expandable systems that enable development </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">team cohesion.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">This chapter will be focused on implementing the tools from </span><a href="B18297_06.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.18.1"> in the same project, linked </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">on GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">If you want to jump straight in at this point, you can download the </span><em class="italic"><span class="koboSpan" id="kobo.21.1">chapter7</span></em><span class="koboSpan" id="kobo.22.1"> branch from GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07</span></span></a></p>
<p><span class="koboSpan" id="kobo.25.1">Otherwise, the planning section only really requires a pen and paper or a free drawing tool. </span><span class="koboSpan" id="kobo.25.2">Once the purpose and vocabulary of UML diagrams have been grasped, there are helpful online tools for speeding up their generation. </span><span class="koboSpan" id="kobo.25.3">The easiest to use is Mermaid (</span><a href="https://mermaid.live"><span class="koboSpan" id="kobo.26.1">https://mermaid.live</span></a><span class="koboSpan" id="kobo.27.1">), which provides a text editing interface for diagram editing. </span><span class="koboSpan" id="kobo.27.2">It presents as a paid service if you wish to save multiple diagrams, but seeing as every element of your diagram or chart is serialized as text in the URL, shown in the address bar of your browser, a simple copy and paste of the URL into a notes app will save the diagram. </span><span class="koboSpan" id="kobo.27.3">Other tools include Photoshop and Paint or dedicated drawing tools such as drawio.com (</span><a href="https://www.drawio.com/"><span class="koboSpan" id="kobo.28.1">https://www.drawio.com/</span></a><span class="koboSpan" id="kobo.29.1">) and </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">whimsical.com (</span></span><a href="https://whimsical.com/"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://whimsical.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.32.1">).</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.33.1">Using UML to plan a sample hierarchy</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.34.1">Unified Modeling Language</span></strong><span class="koboSpan" id="kobo.35.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.36.1">UML</span></strong><span class="koboSpan" id="kobo.37.1">) is </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.38.1">a tool that programmers use to visually communicate the structure of large systems during the design phase and when creating technical documentation. </span><span class="koboSpan" id="kobo.38.2">Classes</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.39.1"> are represented as boxes, with relationships</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.40.1"> shown through different types of arrows linking </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">the boxes.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.42.1">What are the types of class relations?</span></h2>
<p><span class="koboSpan" id="kobo.43.1">Let us take a look at different types of </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.44.1">class relations and how they are presented using UML </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">class diagrams.</span></span></p>
<h3><span class="koboSpan" id="kobo.46.1">Inheritance</span></h3>
<p><span class="koboSpan" id="kobo.47.1">Standard</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.48.1"> arrows, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.50.1">.1</span></em><span class="koboSpan" id="kobo.51.1">, show inheritance with the parent being indicated by the end with the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">arrow head.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.53.1"><img alt="Figure 7.1 – An example of a UML class diagram showing inheritance syntax" src="image/Figure_07.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.54.1">Figure 7.1 – An example of a UML class diagram showing inheritance syntax</span></p>
<p><span class="koboSpan" id="kobo.55.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.56.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.57.1">.1</span></em><span class="koboSpan" id="kobo.58.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Character</span></strong><span class="koboSpan" id="kobo.60.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">Vehicle</span></strong><span class="koboSpan" id="kobo.62.1"> classes inherit from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.63.1">Pawn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.64.1"> class.</span></span></p>
<h3><span class="koboSpan" id="kobo.65.1">Composition</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.66.1">Composition</span></strong><span class="koboSpan" id="kobo.67.1"> is a </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.68.1">type of class relation where the composed classes give the parent</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.69.1"> class the functionality. </span><span class="koboSpan" id="kobo.69.2">This tool is seen a lot with multi-functional classes being broken down into their separate functions then composed together into a wrapper. </span><span class="koboSpan" id="kobo.69.3">You can show composition with a solid diamond at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">a line.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.71.1"><img alt="Figure 7.2 – An example UML class diagram showing composition syntax" src="image/Figure_07.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.72.1">Figure 7.2 – An example UML class diagram showing composition syntax</span></p>
<p><span class="koboSpan" id="kobo.73.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.75.1">.2</span></em><span class="koboSpan" id="kobo.76.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">GameGrid</span></strong><span class="koboSpan" id="kobo.78.1"> composes a reference to </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Pathfinder</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.80.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.81.1">FogManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.83.1">Aggregation</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.84.1">Aggregation</span></strong><span class="koboSpan" id="kobo.85.1"> is a </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.86.1">concept crucial to designing decoupled systems as it quite literally represents the coupling that is present. </span><span class="koboSpan" id="kobo.86.2">At some point in the communication chain, for</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.87.1"> objects to communicate, at least a one-way connection must be established. </span><span class="koboSpan" id="kobo.87.2">Aggregation is when that connection is between two non-dependent classes. </span><span class="koboSpan" id="kobo.87.3">Similar to composition, aggregation is also shown by a line with a diamond at the head but the diamond for aggregation is just </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">an outline.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 7.3 – An example UML class diagram showing aggregation syntax" src="image/Figure_07.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 7.3 – An example UML class diagram showing aggregation syntax</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.92.1">.3</span></em><span class="koboSpan" id="kobo.93.1"> shows </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Pawn</span></strong><span class="koboSpan" id="kobo.95.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">Widget</span></strong><span class="koboSpan" id="kobo.97.1"> aggregated into </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">PlayerController</span></strong><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">Both can exist and function</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.100.1"> without</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.101.1"> this connection so it is </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">an aggregation.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.103.1">What is a sequence diagram?</span></h2>
<p><span class="koboSpan" id="kobo.104.1">In addition to the UML class </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.105.1">diagrams we’ve explored so far, UML has more forms it can take. </span><span class="koboSpan" id="kobo.105.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">sequence diagram</span></strong><span class="koboSpan" id="kobo.107.1">, shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.108.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.109.1">.4</span></em><span class="koboSpan" id="kobo.110.1">, shows the execution of functions between objects over time. </span><span class="koboSpan" id="kobo.110.2">This is a crucial way to show how signals get around your class structures. </span><span class="koboSpan" id="kobo.110.3">Using a sequence diagram after something goes wrong can help identify what a call stack should look like at different lines of execution to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">pinpoint errors.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.112.1"><img alt="Figure 7.4 – An example UML sequence diagram" src="image/Figure_07.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Figure 7.4 – An example UML sequence diagram</span></p>
<p><span class="koboSpan" id="kobo.114.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.115.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.116.1">.4</span></em><span class="koboSpan" id="kobo.117.1">, we are </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.118.1">communicating an initialization chain from </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">GameMode</span></strong><span class="koboSpan" id="kobo.120.1"> through </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">PlayerController</span></strong><span class="koboSpan" id="kobo.122.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Character</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">The sequence diagram helps us see that when the </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Character Init</span></strong><span class="koboSpan" id="kobo.126.1"> function is executing, our call stack should be three deep and what order each class is in the chain. </span><span class="koboSpan" id="kobo.126.2">These diagrams are necessary for clarifying key communications but, as with all UML, it can have the opposite effect if it tries to encompass too much </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">With these tools in our belt, we can better describe the structures coming up in this chapter to other developers. </span><span class="koboSpan" id="kobo.128.2">The benefit of using UML over coding segments is in its standardization and agnosticism, meaning the programmer we show this to doesn’t need to speak the same language to understand what </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">we mean.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Decoupling references is a key skill for all developers in all object-oriented languages to understand. </span><span class="koboSpan" id="kobo.130.2">With universal methods of communication such as UML, we can establish a precedent and enforce it across all levels of development. </span><span class="koboSpan" id="kobo.130.3">Let's now use loads of sequence diagrams and aggregation to fix some messy, heavily </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">coupled code.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.132.1">Decoupling the reference train</span></h1>
<p><span class="koboSpan" id="kobo.133.1">Now let’s take knowledge of these </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.134.1">three connection types and see how we can associate every class in the example UML class diagram that follows, using a few rules. </span><span class="koboSpan" id="kobo.134.2">Once everything is associated, we’ll implement decoupling in an example and look at the benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">this brings.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.136.1">Modularity and decoupling</span></h2>
<p><span class="koboSpan" id="kobo.137.1">We’ll start with a bunch of </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.138.1">scattered classes, which are organized in a way that will function but is messy to work with, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.140.1">.5</span></em><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">To make everything function here</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.142.1"> clearly, the developer has added references, as and when needed, to </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">any class.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.144.1"><img alt="Figure 7.5 – Example UML showing a messy system" src="image/Figure_07.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.145.1">Figure 7.5 – Example UML showing a messy system</span></p>
<p><span class="koboSpan" id="kobo.146.1">Let’s analyze how the </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">Character</span></strong><span class="koboSpan" id="kobo.148.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Projectile</span></strong><span class="koboSpan" id="kobo.150.1"> interaction occurs by looking at the sequence diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.151.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.152.1">.6</span></em><span class="koboSpan" id="kobo.153.1">. </span><span class="koboSpan" id="kobo.153.2">When the character </span><em class="italic"><span class="koboSpan" id="kobo.154.1">fires</span></em><span class="koboSpan" id="kobo.155.1">, it spawns a projectile but then doesn’t hold onto the reference. </span><span class="koboSpan" id="kobo.155.2">Instead, the projectile grabs a reference to the character and when it hits an AI unit, this reference is used to feed back whether it killed anything through a function call. </span><span class="koboSpan" id="kobo.155.3">Why is this bad? </span><span class="koboSpan" id="kobo.155.4">It’s not necessarily going to impact the final built game, but it does make the code involved in this interaction single-use. </span><span class="koboSpan" id="kobo.155.5">If an enemy unit wants to fire, due to it being a different setup, we are left with two </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">bad options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.157.1">Bastardization through inheritance and overloading functions, thereby breaking several of our </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">SOLID principles</span></span></li>
<li><span class="koboSpan" id="kobo.159.1">Repeat ourselves in a new actor, which, as we know, should ring </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">alarm bells</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 7.6 – Example UML sequence diagram showing the complexity of a messy interaction" src="image/Figure_07.06_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 7.6 – Example UML sequence diagram showing the complexity of a messy interaction</span></p>
<p><span class="koboSpan" id="kobo.163.1">The solution to this </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.164.1">problem is</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.165.1"> modularity and decoupling. </span><span class="koboSpan" id="kobo.165.2">We need to establish a hierarchy where each class is connected to a single tree, where connections represent ownership. </span><span class="koboSpan" id="kobo.165.3">The first step is to analyze class responsibilities. </span><span class="koboSpan" id="kobo.165.4">The </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Character</span></strong><span class="koboSpan" id="kobo.167.1"> class currently takes care of too many areas. </span><span class="koboSpan" id="kobo.167.2">It deals with player representation in the world but also weapon logic. </span><span class="koboSpan" id="kobo.167.3">Due to this logic possibly being duplicated in the AI enemy class, it makes sense to spin it out into its own class that can be shared. </span><span class="koboSpan" id="kobo.167.4">Linking this into an aggregation chain with the </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">GameMode</span></strong><span class="koboSpan" id="kobo.169.1"> at the top, flowing down through the </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Character</span></strong><span class="koboSpan" id="kobo.171.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Weapon</span></strong><span class="koboSpan" id="kobo.173.1"> to the </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">Projectile</span></strong><span class="koboSpan" id="kobo.175.1">, gives us the tree we were aiming for from the start, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.177.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 7.7 – A UML class diagram showing classes in a tree structure" src="image/Figure_07.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 7.7 – A UML class diagram showing classes in a tree structure</span></p>
<p><span class="koboSpan" id="kobo.181.1">In general terms, the </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.182.1">tree we established in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.184.1">.7</span></em><span class="koboSpan" id="kobo.185.1"> is conceptual. </span><span class="koboSpan" id="kobo.185.2">There could be pointers to o</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.186.1">wned classes in parents for practicality, but it mostly exists in the design document. </span><span class="koboSpan" id="kobo.186.2">In Unreal, everything below the PlayerController can be spawned at runtime, which helps to make the structure more concrete. </span><span class="koboSpan" id="kobo.186.3">All spawned objects can be cached as </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">TObjectPtr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.188.1"> variables, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">T</span></strong><span class="koboSpan" id="kobo.190.1"> being the exact type we need. </span><span class="koboSpan" id="kobo.190.2">To link the tree up above the </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Character</span></strong><span class="koboSpan" id="kobo.192.1"> level, it gets more specific. </span><span class="koboSpan" id="kobo.192.2">When a new level loads, it creates new Controllers automatically, but it does so using multiplayer terminology and a networked method. </span><span class="koboSpan" id="kobo.192.3">Overriding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">PostLogin</span></strong><span class="koboSpan" id="kobo.194.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Logout</span></strong><span class="koboSpan" id="kobo.196.1"> functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">AGameModeBase</span></strong><span class="koboSpan" id="kobo.198.1">, PlayerControllers can be cached in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">TArray&lt;TObjectPtr&lt;APlayerController&gt;&gt;</span></strong><span class="koboSpan" id="kobo.200.1"> for later use. </span><span class="koboSpan" id="kobo.200.2">If you want to make a distinction between AIController and PlayerController in the structure, then you will need to store them separately. </span><span class="koboSpan" id="kobo.200.3">PlayerControllers can be cached via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">PostLogin</span></strong><span class="koboSpan" id="kobo.202.1"> function with a cast to the respective base type as needed, but AIControllers must</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.203.1"> be cached when the AI-controlled pawn is spawned and</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.204.1"> accessed via the </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">instigator reference.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.206.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.207.1">Be aware that </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">PostLogin</span></strong><span class="koboSpan" id="kobo.209.1"> only fires for PlayerControllers, yet </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Logout</span></strong><span class="koboSpan" id="kobo.211.1"> deals with all controller types, including AI. </span><span class="koboSpan" id="kobo.211.2">This makes defensive coding important </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Logout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.215.1"><img alt="Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes are connected" src="image/Figure_07.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.216.1">Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes are connected</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.217.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.218.1">.8</span></em><span class="koboSpan" id="kobo.219.1"> shows how the different methods described in this section could be used to connect the classes </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">in memory.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.221.1">Establishing infrastructure</span></h2>
<p><span class="koboSpan" id="kobo.222.1">The next step is to start establishing infrastructure, such as public functions, event delegates, and interfaces, to provide entry and exit points for signals. </span><span class="koboSpan" id="kobo.222.2">Each fulfills a very </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">specific purpose:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.224.1">Public functions</span></strong><span class="koboSpan" id="kobo.225.1"> are used for </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.226.1">communication when there is a cached variable reference of the correct type. </span><span class="koboSpan" id="kobo.226.2">Following the aggregation lines that represent this connection, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.227.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.228.1">.8</span></em><span class="koboSpan" id="kobo.229.1">, all function calls will happen to head down the tree through the chain </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">of ownership.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.231.1">Event delegates</span></strong><span class="koboSpan" id="kobo.232.1"> allow </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.233.1">anonymous communication when the listener has a cached variable reference for the event’s class. </span><span class="koboSpan" id="kobo.233.2">This ends up being the exact opposite of the public function calls, allowing communication to back up the reference chain toward the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">the tree.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.235.1">Interfaces</span></strong><span class="koboSpan" id="kobo.236.1"> are the </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.237.1">final tool and allow communication between different branches without creating a link. </span><span class="koboSpan" id="kobo.237.2">Providing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">AActor*</span></strong><span class="koboSpan" id="kobo.239.1"> reference that can be gained at runtime, usually via some kind of collision event, the interface can be used to invoke some kind of function without needing to know the exact type of </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">the receiver.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.241.1">This boils down to a simple communication rule: </span><em class="italic"><span class="koboSpan" id="kobo.242.1">functions down, events up, and interfaces sideways</span></em><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">The result is a decoupled system in which each class only has reference to the one layer below it and yet signals can be sent all over </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">with ease.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.245.1">Implementing decoupled design in an example</span></h2>
<p><span class="koboSpan" id="kobo.246.1">The best way to embed </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.247.1">decoupled design into your process is to practice it. </span><span class="koboSpan" id="kobo.247.2">As a start, we will focus on how using the player character in our example project can receive points shown on the UI for eliminating enemy units. </span><span class="koboSpan" id="kobo.247.3">We will start with the UML class diagram shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.249.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.251.1"><img alt="Figure 7.9 – Planned UML class diagram for the linked project" src="image/Figure_07.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">Figure 7.9 – Planned UML class diagram for the linked project</span></p>
<p><span class="koboSpan" id="kobo.253.1">Next, we will overlay the </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.254.1">signal path onto the UML, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.255.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.256.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.258.1"><img alt="Figure 7.10 – Signal path overlayed on UML class diagram" src="image/Figure_07.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">Figure 7.10 – Signal path overlayed on UML class diagram</span></p>
<p><span class="koboSpan" id="kobo.260.1">Overlaying the signal path onto the UML will allow us to plan the infrastructure effectively, producing a UML sequence diagram, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.261.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.262.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<span class="koboSpan" id="kobo.264.1"><img alt="Figure 7.11 – UML sequence diagram showing the signal path for killing an enemy" src="image/Figure_07.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">Figure 7.11 – UML sequence diagram showing the signal path for killing an enemy</span></p>
<p><span class="koboSpan" id="kobo.266.1">To put this decoupled</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.267.1"> plan into practice, head to the folder labeled </span><a href="B18297_07.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.268.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.269.1"> in the example project. </span><span class="koboSpan" id="kobo.269.2">Open the level in this folder and take the following steps. </span><span class="koboSpan" id="kobo.269.3">Whenever a class is mentioned, please use the </span><a href="B18297_07.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.270.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.271.1"> version denoted by  </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">_CH7</span></strong><span class="koboSpan" id="kobo.273.1"> in the class and filenames. </span><span class="koboSpan" id="kobo.273.2">All of the following code is for you to add and embellish as you see fit. </span><span class="koboSpan" id="kobo.273.3">All the needed classes have been created already. </span><span class="koboSpan" id="kobo.273.4">This exercise only requires you to add the new code to the areas specified by the protection-level tags. </span><span class="koboSpan" id="kobo.273.5">Any new variables will need to be linked up in the inspectors of the Blueprint children in the editor, but this is made clear at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Stepping through the implementation, let’s start at the top in the game mode. </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">GameMode_CH7</span></strong><span class="koboSpan" id="kobo.277.1"> will have links to </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">PlayerController_CH7</span></strong><span class="koboSpan" id="kobo.279.1"> and any AI spawned in the level. </span><span class="koboSpan" id="kobo.279.2">This may work better with an AI manager for larger games, but we have no need to over-complicate the process. </span><span class="koboSpan" id="kobo.279.3">These references are cast to the correct types and cached. </span><span class="koboSpan" id="kobo.279.4">After casting, </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">listener</span></strong><span class="koboSpan" id="kobo.281.1"> functions can be attached to the event delegates on the controllers, establishing the first link, but we haven’t made any controllers yet so we will return here once the initialization chain </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">is complete.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">The GameMode header is a simple set of holder variables and the start of the initialization chain in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">BeginPlay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> override.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Let's get started with the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">header file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.288.1">GameMode_CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
class AGameMode_CH7 : public AGameModeBase
{
public:
    virtual void PostLogin(APlayerController* NewPlayer) override;
    virtual void Logout(AController* Exiting) override;
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;APlayerController_CH7&gt; _PlayerController;
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TArray&lt;TObjectPtr&lt;AAIController_CH7&gt;&gt; _AIControllers;
    virtual void BeginPlay() override;
};</span></pre> <p><span class="koboSpan" id="kobo.290.1">The GameMode body deals with PlayerController initialization and reference registry in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">PostLogin</span></strong><span class="koboSpan" id="kobo.292.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Logout</span></strong><span class="koboSpan" id="kobo.294.1"> functions as that is what Unreal will automatically call when PlayerControllers enter and exit the game. </span><span class="koboSpan" id="kobo.294.2">This can be confusing as it is networking</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.295.1"> terminology but Unreal still uses it for single-player games. </span><span class="koboSpan" id="kobo.295.2">On the other hand, AIControllers are gathered and initialized on </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.297.1"> as they are assumed to be in the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">level already.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">So, now, we can set these up in the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">body file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.301.1">GameMode_CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
void AGameMode_CH7::PostLogin(APlayerController* NewPlayer)
{
    if (APlayerController_CH7* castedPC = Cast&lt;APlayerController_CH7&gt;        (NewPlayer))
    {
        _PlayerController = castedPC;
        _PlayerController-&gt;Init();
    }
    Super::PostLogin(NewPlayer);
}
void AGameMode_CH7::Logout(AController* Exiting)
{
    if (Exiting == _PlayerController)
    {
        _PlayerController = nullptr;
    }
    Super::Logout(Exiting);
}
void AGameMode_CH7::BeginPlay()
{
    Super::BeginPlay();
    TArray&lt;AActor*&gt; outActors;
    UGameplayStatics::GetAllActorsOfClass         (GetWorld(), AAIController::StaticClass(), outActors);
    
    for (AActor* actor : outActors)
    {
        _AIControllers.Add(Cast&lt;AAIController_CH7&gt;(actor));
    }
    
    for (AAIController_CH7* ai : _AIControllers)
    {
        ai-&gt;Init();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.303.1">Next, the controllers need to gain reference to and initialize the characters they are controlling. </span><span class="koboSpan" id="kobo.303.2">This is a simpler process than before as the controllers all spawn in their characters via an initialization chain. </span><span class="koboSpan" id="kobo.303.3">This means there is no need for casting; the characters are already the correct type. </span><span class="koboSpan" id="kobo.303.4">This also applies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">ScoreWidget</span></strong><span class="koboSpan" id="kobo.305.1"> class we will use to display the</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.306.1"> player’s score, which has been provided as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Chapter </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Resources</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">The PlayerController header has a custom public function for initialization, a class reference to the type of pawn it would like to spawn, and an object reference to the actual pawn it </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">has spawned.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">Write out the PlayerController header file as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">PlayerController_CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.315.1">
class APlayerController_CH7 : public APlayerController
{
public:
    void Init();
protected:
    UPROPERTY(EditAnywhere)
    TSubclassOf&lt;APawn&gt; _PlayerPawn;
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;ACharacter_CH7&gt; _Character;
};</span></pre> <p><span class="koboSpan" id="kobo.316.1">In the PlayerController body, we use the functions provided to us by Unreal within the GameMode class to spawn a new pawn of the type specified in the header at one of the player start points. </span><span class="koboSpan" id="kobo.316.2">The </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.317.1">PlayerController then possesses it and calls the initialization function on </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">that pawn.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Let's set </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">that up.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">PlayerController_CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
void APlayerController_CH7::Init()
{
    if (GetPawn() != nullptr)
    {
        GetPawn()-&gt;Destroy();
    }
    UWorld* const world = GetWorld();
    AActor* tempStart = UGameplayStatics::GetGameMode         (world)-&gt;FindPlayerStart(this);
    FVector spawnLoc = tempStart != nullptr ? </span><span class="koboSpan" id="kobo.322.2">        tempStart-&gt;GetActorLocation() : FVector::ZeroVector;
    FRotator spawnRot = tempStart != nullptr ? </span><span class="koboSpan" id="kobo.322.3">        tempStart-&gt;GetActorRotation() : FRotator::ZeroRotator;
    FActorSpawnParameters spawnParams;
    spawnParams.SpawnCollisionHandlingOverride =         ESpawnCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
    APawn* tempPawn = world-&gt;SpawnActor&lt;APawn&gt;        (_PlayerPawn, spawnLoc, spawnRot, spawnParams);
    Possess(tempPawn);
    if (ACharacter_CH7* _Character = Cast&lt;ACharacter_CH7&gt;(tempPawn))
    {
        _Character-&gt;Init();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.323.1">Down the other branch </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.324.1">from the GameMode, our AIController header is similar to the PlayerController minus the reference to the class it would like to spawn, as with a standard Unreal AI setup the pawn is already in </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the world.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">So, the header file for the AIController needs to be set out </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.328.1">AIController_CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
class AAIController_CH7 : public AController
{
public:
    void Init();
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;AAIUnit_CH7&gt; _Unit;
};</span></pre> <p><span class="koboSpan" id="kobo.330.1">This point of the AIController being a generally simpler implementation extends to the initialization function. </span><span class="koboSpan" id="kobo.330.2">As there is no need to spawn any new pawns, we can simply get a reference to the currently possessed one and call its initialization function, passing the </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">communication on.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Write the Initialization function </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">as shown:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.334.1">AIController_CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
void AAIController_CH7::Init()
{
    if (APawn* pawn = GetPawn())
    {
        if (_Unit = Cast&lt;AAIUnit_CH7&gt;(pawn))
        {
            _Unit-&gt;Init();
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.336.1">The last initialization is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">AIUnit</span></strong><span class="koboSpan" id="kobo.338.1"> class. </span><span class="koboSpan" id="kobo.338.2">In the header, we have a variable to hold a </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">HealthComponent</span></strong><span class="koboSpan" id="kobo.340.1">, like the one we made at the end of </span><a href="B18297_06.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.342.1">, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">listener</span></strong><span class="koboSpan" id="kobo.344.1"> function to</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.345.1"> bind to the component’s event </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">for death.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">So, let's setup the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">AIUnit header.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.349.1">AIUnit _CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
class AAIUnit_CH7 : public APawn
{
public:
    AAIUnit_CH7();
    void Init();
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    TObjectPtr&lt;UHealthComponent&gt; _HealthComp;
    UFUNCTION()
    void Handle_HealthDeath(AController* causer);
};</span></pre> <p><span class="koboSpan" id="kobo.351.1">The body makes a new instance of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">HealthComponent</span></strong><span class="koboSpan" id="kobo.353.1"> in the constructor and binds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">listener</span></strong><span class="koboSpan" id="kobo.355.1"> function in </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the initialization.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">We should now add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">HealthComponent</span></strong><span class="koboSpan" id="kobo.359.1"> and initialization functions to the AIUnit </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">body file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.361.1">AIUnit _CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
AAIUnit_CH7::AAIUnit_CH7()
{
    _HealthComp = CreateDefaultSubobject&lt;UHealthComponent&gt;
    (TEXT("Health"));
}
void AAIUnit_CH7::Init()
{
    _HealthComp-&gt;OnDead.AddDynamic         (this, &amp;AAIUnit_CH7::Handle_HealthDeath);
}</span></pre> <p><span class="koboSpan" id="kobo.363.1">Now that all classes are</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.364.1"> initialized, we can step back up through the chain, adding the event delegates and their </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">listener</span></strong><span class="koboSpan" id="kobo.366.1"> functions, starting with how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">AIUnit</span></strong><span class="koboSpan" id="kobo.368.1"> responds to the health component death event. </span><span class="koboSpan" id="kobo.368.2">This needs to be done on both branches of the tree for the player and AI side, but we will only show the AI side as that is where the points come from. </span><span class="koboSpan" id="kobo.368.3">The listener should broadcast the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">AIUnit</span></strong><span class="koboSpan" id="kobo.370.1"> death event for now, including however many points this </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">AIUnit</span></strong><span class="koboSpan" id="kobo.372.1"> was worth. </span><span class="koboSpan" id="kobo.372.2">This link is where animations and sound effects could be played to provide feedback to </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">the player.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.374.1">Extension task</span></p>
<p class="callout"><span class="koboSpan" id="kobo.375.1">The ot</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.376.1">her damage event in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">HealthComponent</span></strong><span class="koboSpan" id="kobo.378.1"> is being ignored for the purpose of explaining the process. </span><span class="koboSpan" id="kobo.378.2">As an extension task after finishing the chapter, try to hook this up so that when an AI character receives damage, it feeds through the chain to the controller and updates the health bar </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">from there.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Adding the following code through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">AIUnit</span></strong><span class="koboSpan" id="kobo.382.1"> header, we declare a n</span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.383.1">ew delegate type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">FAIUnitDeathSignature</span></strong><span class="koboSpan" id="kobo.385.1"> with two parameters. </span><span class="koboSpan" id="kobo.385.2">This type is then used in the c</span><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.386.1">lass header to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">OnUnitDeath</span></strong><span class="koboSpan" id="kobo.388.1"> public delegate. </span><span class="koboSpan" id="kobo.388.2">We also add an integer here so that we can </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.389.1">balance the value of destroying the unit to </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">the player.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">So, lets add those to the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">header file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.393.1">AIUnit _CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams     (FAIUnitDeathSignature, AController*, causer, int, points);
class AAIUnit_CH7 : public APawn
{
public:
    UPROPERTY(BlueprintAssignable)
    FAIUnitDeathSignature OnUnitDeath;
protected:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int _PointValue;
};</span></pre> <p><span class="koboSpan" id="kobo.395.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">AIUnit</span></strong><span class="koboSpan" id="kobo.397.1"> body is much simpler though, as we are just using it to be a link in a chain, so once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">HealthComponent</span></strong><span class="koboSpan" id="kobo.399.1"> death listener function fires, it can broadcast the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">OnUnitDeath </span></strong><span class="koboSpan" id="kobo.401.1">delegate and destroy </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">the pawn.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Add the following code to the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">body file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.405.1">AIUnit _CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
void AAIUnit_CH7::Handle_HealthDeath(AController* causer)
{
    OnUnitDeath.Broadcast(causer, _PointValue);
    Destroy();
}</span></pre> <p><span class="koboSpan" id="kobo.407.1">Following up the chain, the AIController can start listening to the AIUnit’s pass-through death event. </span><span class="koboSpan" id="kobo.407.2">This level is another pass-through for now, but could be where the controller recycles itself and finds another </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">AIUnit</span></strong><span class="koboSpan" id="kobo.409.1"> to spawn depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">gameplay loop.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">The AIController </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.412.1">header gets a similar set of items to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">AIUnit</span></strong><span class="koboSpan" id="kobo.414.1"> with a new delegate type definition that takes two parameters. </span><span class="koboSpan" id="kobo.414.2">We don’t reuse the definition in the unit so that when we come to expand the game, these two classes aren’t tied to each other and can be swapped out as necessary. </span><span class="koboSpan" id="kobo.414.3">There is also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">private</span></strong><span class="koboSpan" id="kobo.416.1"> function that matches the</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.417.1"> signature for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">AIUnit</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.419.1">OnUnitDeath</span></strong><span class="koboSpan" id="kobo.420.1"> delegate so it can be added as </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">a listener.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Go ahead and add the following code to the </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">header file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.424.1">AIController_CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams     (FControllerDeathSignature, AController*, causer, int, points);
class AAIController_CH7 : public AController
{
public:
    UPROPERTY(BlueprintAssignable)
    FControllerDeathSignature OnControllerDeath;
protected:
    UFUNCTION()
    void Handle_UnitDeath(AController* causer, int points);
};</span></pre> <p><span class="koboSpan" id="kobo.426.1">The AIController body binds the</span><a id="_idTextAnchor104"/> <strong class="source-inline"><span class="koboSpan" id="kobo.427.1">listener</span></strong><span class="koboSpan" id="kobo.428.1"> function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">AIUnit OnUnitDeath</span></strong><span class="koboSpan" id="kobo.430.1"> delegate right after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Init</span></strong><span class="koboSpan" id="kobo.432.1"> function is called. </span><span class="koboSpan" id="kobo.432.2">This way, we know that all variables inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">AIUnit</span></strong><span class="koboSpan" id="kobo.434.1"> have been set up correctly before we start listening for gameplay signals. </span><span class="koboSpan" id="kobo.434.2">The listener function itself is then just a pas</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.435.1">sthrough broadcasting the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">OnControllerDeath</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> delegate.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Let's add that to the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">body file.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">AIController_CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
void AAIController_CH7::Init()
{
    if(APawn* pawn = GetPawn())
{
if(_Unit = Cast&lt;AAIUnit_CH7&gt;(pawn))
        {
            _Unit-&gt;Init();
            _Unit-&gt;OnUnitDeath.AddDynamic(this,
                &amp;AAIController::Handle_UnitDeath);
        }
    }
}
void AAIController_CH7::Handle_UnitDeath(
    AController* casuer, int points)
{
    OnControllerDeath.Broadcast(causer, points);
}</span></pre> <p><span class="koboSpan" id="kobo.442.1">The GameMode can</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.443.1"> now link a listener function to all the AIControllers. </span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.444.1">This function just calls a </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">public</span></strong><span class="koboSpan" id="kobo.446.1"> function on the PlayerController to increment its points for now, but it can be used as a jumping-off point to check against win conditions, and in a multiplayer scenario, make sure all players have an </span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.447.1">updated scoreboard via </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">GameState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">This following excerpt shows where to add the listener function declaration in the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">GameMode header.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.453.1">GameMode_CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
class AgameMode_CH7 : public AgameModeBase
{
protected:
    void Handle_ControllerDeath(AController* causer, int points);
}</span></pre> <p><span class="koboSpan" id="kobo.455.1">In the GameMode body, we then bind the listener function to each AIControll</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.456.1">er right after we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Init</span></strong><span class="koboSpan" id="kobo.458.1"> function on each one. </span><span class="koboSpan" id="kobo.458.2">This time, the listener function doesn’t simply broadcast another event, as this is where the communication reverses and starts going down another branch of the communication hierarchy that we designed earlier in the chapter. </span><span class="koboSpan" id="kobo.458.3">Instead, we call a function on the PlayerController telling it to add points. </span><span class="koboSpan" id="kobo.458.4">This is not strictly the best way of do</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.459.1">ing this, but it does show the structure cleanly. </span><span class="koboSpan" id="kobo.459.2">Ideally, you would check which controller needed the points based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">causer</span></strong><span class="koboSpan" id="kobo.461.1"> argument passed </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.462.1">through the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">delegate chain.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">So, add the following code to the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">body file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.466.1">GameMode_CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
void AGameMode_CH7::BeginPlay()
{
    … other code from before …
for(AAIController_CH7* ai : _AIControllers)
{
    ai-&gt;Init();
    ai-&gt;OnControllerDeath.AddDynamic(this,
        &amp;AgameMode_CH7::Handle_ControllerDeath);
}
}
void AGameMode_CH7::Handle_ControllerDeath(
    AController* causer, int points)
{
    _PlayerController-&gt;AddPoints(points);
}</span></pre> <p><span class="koboSpan" id="kobo.468.1">The Player controller then needs to implement this </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">public</span></strong><span class="koboSpan" id="kobo.470.1"> function so that when the game mode tells it to add points, it updates the UI as well. </span><span class="koboSpan" id="kobo.470.2">The UI references are included in the class for you already – that’s why they are missing from the header in the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">following code.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">The PlayerController</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.473.1"> header just needs the public accessor </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">AddPoints</span></strong><span class="koboSpan" id="kobo.475.1"> function and a variable to store the current number of points. </span><span class="koboSpan" id="kobo.475.2">This is arbitrary but they must be stored somewhere, and this seems like as good a place as any to </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">store them.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">So, let's </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">add these:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.479.1">PlayerController_CH7.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
class APlayerController_CH7 : public APlayerController
{
public:
    void AddPoints(int points);
protected:
    int _Points;
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">AddPoints</span></strong><span class="koboSpan" id="kobo.482.1"> does what it says on the tin, but also serves as a signal passthrough for the UI where we tell it to update the value shown onscreen with the new </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">points value.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Add the following excerpt to the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">body file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.486.1">PlayerController_CH7.cpp excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.487.1">
void APlayerController_CH7::AddPoints(int points)
{
    _Points += points;
    _PointsWidget.UpdatePoints(_Points);
}</span></pre> <p><span class="koboSpan" id="kobo.488.1">With that all done, you</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.489.1"> should be able to play the game as before from this new level, but when you destroy enemy AI units, the number at the top left of the viewport increases each time. </span><span class="koboSpan" id="kobo.489.2">This is the core of a game loop built in a decoupled way. </span><span class="koboSpan" id="kobo.489.3">Of course, our AI needs to fight back and there needs to be some balancing to make this into a good gameplay experience, but functionally it is </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">all there.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.491.1">Benefits of decoupling</span></h2>
<p><span class="koboSpan" id="kobo.492.1">The benefit of setting </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.493.1">things up in a decoupled way should now be evident. </span><span class="koboSpan" id="kobo.493.2">If we need to swap out game modes for a different objective-based mode, then we can do that as no class needs a direct reference to the game mode. </span><span class="koboSpan" id="kobo.493.3">As long as all the same functions are called and the events are listened to, everything will function. </span><span class="koboSpan" id="kobo.493.4">You can also check the size of the dependencies for each class using the method shown in </span><a href="B18297_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.494.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.495.1"> to see how small each class is in memory now that it has a reference to only one layer below itself and maybe an interface </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">or two.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.497.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.498.1">With this chapter completed, you should be equipped to design communication hierarchies for games with a focus on anonymous modular design in UML for implementation within Unreal. </span><span class="koboSpan" id="kobo.498.2">We have covered the basics of UML and why it is useful as a planning and communication tool. </span><span class="koboSpan" id="kobo.498.3">Using this UML, we then set about taking a simple communication and anonymizing it using the event delegate tool from </span><a href="B18297_06.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.499.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.500.1"> to decouple the reference chain as much as we could. </span><span class="koboSpan" id="kobo.500.2">This anonymous modular should work for most communications you design from here on, with exceptions being </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">extremely rare.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">In the next chapter, we are going to look at patterns you can set up as a library to move around with you between projects. </span><span class="koboSpan" id="kobo.502.2">We will look at why you should not overuse the singleton pattern, as most people do, and why you should make use of the command and state patterns in almost </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">every project.</span></span></p>
</div>


<div class="Content" id="_idContainer137">
<h1 id="_idParaDest-101" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1.1">Part 3: Building on Top of Unreal</span></h1>
</div>
<div id="_idContainer138">
<p><span class="koboSpan" id="kobo.2.1">In this part, we will take the leap from looking at patterns that have already been scaffolded to making some of </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">our own.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">Each chapter deals with a different category of pattern, starting with behavioral patterns that allow classes to serve their use more cleanly, through structural patterns that assist you when building systems for a large team to work on, to optimization patterns that aim to speed up your code. </span><span class="koboSpan" id="kobo.4.2">By the end of this section, you should have a host of patterns built in a modular way, ready to be transferred </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">between projects.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B18297_08.xhtml#_idTextAnchor113"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Building Design Patterns – Singleton, Command, and State</span></em></li>
<li><a href="B18297_09.xhtml#_idTextAnchor130"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Structuring Code with Behavioral Patterns – Template, Subclass Sandbox, and Type Object</span></em></li>
<li><a href="B18297_10.xhtml#_idTextAnchor148"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, Optimisation through Patterns</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer139">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer140">
</div>
</div>
</body></html>