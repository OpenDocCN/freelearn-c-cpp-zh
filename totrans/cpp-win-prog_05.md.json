["```cpp\nenum FigureId {LineId, ArrowId, RectangleId, EllipseId}; \nclass DrawDocument; \n\nclass Draw { \n  public: \n    Draw(const Window* windowPtr); \n\n```", "```cpp\n    virtual FigureId GetId() const = 0; \n    virtual void SetFirstPoint(Point point) = 0; \n\n```", "```cpp\n    virtual bool IsClick(Point mousePoint) = 0; \n    virtual bool IsInside(Rect area) = 0; \n    virtual void DoubleClick(Point mousePoint) = 0; \n\n```", "```cpp\n    virtual void Modify(Size distanceSize) = 0; \n    virtual void Move(Size distanceSize) = 0; \n\n```", "```cpp\n    virtual Rect Area() const = 0; \n    virtual void Draw(Graphics& graphics) const = 0; \n    void Invalidate() const {windowPtr->Invalidate(Area());} \n\n```", "```cpp\n    virtual bool IsFillable() const {return false;} \n    virtual bool IsFilled() const {return false;} \n    virtual void Fill(bool fill) {/* Empty. */} \n\n```", "```cpp\n    virtual bool WriteFigureToStream(ostream& outStream) const; \n    virtual bool ReadFigureFromStream(istream& inStream); \n\n```", "```cpp\n    virtual void WriteFigureToClipboard(InfoList& infoList) const; \n    virtual void ReadFigureFromClipboard(InfoList& infoList); \n\n```", "```cpp\n    bool IsMarked() const {return marked;} \n    void Mark(bool mark); \n\n    Color GetColor() const {return color;} \n    void SetColor(Color color); \n\n```", "```cpp\n    virtual CursoTyper GetCursor() const = 0; \n\n```", "```cpp\n    static const Size MarkRadius; \n\n```", "```cpp\n  private: \n    const Window* windowPtr; \n\n```", "```cpp\n    Color color; \n    bool marked = false; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"Draw.h\"\n```", "```cpp\nconst Size DrawFigure::MarkRadius(100, 100); \n\n```", "```cpp\nDrawFigure::Draw(const Window* windowPtr) \n :windowPtr(windowPtr) { \n    // Empty. \n} \n\n```", "```cpp\nvoid DrawFigure::Mark(bool mark) { \n  if (!marked && mark) { \n    marked = true; \n    Invalidate(); \n  } \n  else if (marked && !mark) { \n    Invalidate(); \n    marked = false; \n  } \n} \n\n```", "```cpp\nbool DrawFigure::WriteFigureToStream(ostream& outStream) const { \n  color.WriteColorToStream(outStream); \n  return ((bool) outStream); \n} \n\nbool DrawFigure::ReadFigureFromStream(istream& inStream) { \n  color.ReadColorFromStream(inStream); \n  return ((bool) inStream); \n} \n\nvoid DrawFigure::WriteFigureToClipboard(InfoList& infoList) const{ \n  color.WriteColorToClipboard(charList); \n} \n\nvoid DrawFigure::ReadFigureFromClipboard(InfoList& infoList) { \n  color.ReadColorFromClipboard(infoList); \n} \n\n```", "```cpp\nclass LineFigure : public DrawFigure { \n  public: \n    LineFigure(const Window* windowPtr); \n    virtual FigureId GetId() const {return LineId;} \n    virtual void SetFirstPoint(Point point); \n\n    virtual bool IsClick(Point mousePoint); \n    virtual bool IsInside(Rect rectangleArea); \n    virtual void DoubleClick(Point mousePoint) {/* Empty. */} \n\n    virtual void Modify(Size distanceSize); \n    virtual void Move(Size distanceSize); \n\n    virtual Rect Area() const; \n    virtual void Draw(Graphics& graphics) const; \n    virtual CursorType GetCursor() const; \n\n    virtual bool WriteFigureToStream(ostream& outStream) const; \n    virtual bool ReadFigureFromStream(istream& inStream); \n\n    virtual void WriteFigureToClipboard(InfoList& infoList) const; \n    virtual void ReadFigureFromClipboard(InfoList& infoList); \n\n  protected: \n    enum {CreateLine, FirstPoint, LastPoint, MoveLine} lineMode; \n    Point firstPoint, lastPoint; \n    static bool IsPointInLine(Point firstPoint, Point lastPoint, \n                              Point point); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"Draw.h\"\n#include \"LineFigure.h\"\n\nLineFigure::LineFigure(const Window* windowPtr)\n :Draw(windowPtr), lineMode(CreateLine) {\n // Empty. \n}\n```", "```cpp\nvoid LineFigure::SetFirstPoint(Point point) { \n  firstPoint = point; \n  lastPoint = point; \n} \n\n```", "```cpp\nbool LineFigure::IsClick(Point mousePoint) { \n  Rect firstSquare(firstPoint - MarkRadius, \n                   firstPoint + MarkRadius); \n  firstSquare.Normalize(); \n\n  if (firstSquare.PointInside(mousePoint)) { \n    lineMode = FirstPoint; \n    return true; \n  } \n\n  Rect lastSquare(lastPoint - MarkRadius, lastPoint + MarkRadius); \n  lastSquare.Normalize(); \n\n  if (lastSquare.PointInside(mousePoint)) { \n    lineMode = LastPoint; \n    return true; \n  } \n\n  if (IsPointInLine(firstPoint, lastPoint, mousePoint)) { \n    lineMode = MoveLine; \n    return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nbool LineFigure::IsPointInLine(Point firstPoint, Point lastPoint, \n                               Point point) { \n  if (firstPoint.X() == lastPoint.X()) { \n    Rect lineRect(firstPoint - MarkRadius, \n                  lastPoint + MarkRadius); \n    lineRect.Normalize(); \n    return lineRect.PointInside(point); \n  } \n\n```", "```cpp\n  else { \n    Point minPoint = Min(firstPoint, lastPoint), \n          maxPoint = Max(firstPoint, lastPoint); \n\n    if ((minPoint.X() <= point.X()) && \n        (point.X() <= maxPoint.X())) { \n      int lineWidth = maxPoint.X() - minPoint.X(), \n          lineHeight = maxPoint.Y() - minPoint.Y(); \n\n      int diffWidth = point.X() - minPoint.X(), \n          diffHeight = point.Y() - minPoint.Y(); \n\n      double delta = fabs(diffHeight - (diffWidth * \n                          ((double) lineHeight) / lineWidth)); \n      return (delta <= 100); \n    } \n\n    return false; \n  } \n} \n\n```", "```cpp\nbool LineFigure::IsInside(Rect rect) { \n  return (rect.PointInside(firstPoint) && \n          rect.PointInside(lastPoint)); \n} \n\n```", "```cpp\nvoid LineFigure::Modify(Size distanceSize) { \n  Invalidate(); \n  switch (lineMode) { \n    case FirstPoint: \n      firstPoint += distanceSize; \n      break; \n\n    case CreateLine: \n    case LastPoint: \n      lastPoint += distanceSize; \n      break; \n\n    case MoveLine: \n      Move(distanceSize); \n      break; \n  } \n\n  Invalidate(); \n} \n\n```", "```cpp\nvoid LineFigure::Move(Size distanceSize) { \n  Invalidate(); \n  firstPoint += distanceSize; \n  lastPoint += distanceSize; \n  Invalidate(); \n} \n\n```", "```cpp\nvoid LineFigure::Draw(Graphics& graphics) const { \n  graphics.DrawLine(firstPoint, lastPoint, GetColor()); \n\n  if (IsMarked()) { \n    graphics.FillRectangle(Rect(firstPoint - MarkRadius, \n                           firstPoint + MarkRadius), Black,Black); \n    graphics.FillRectangle(Rect(lastPoint - MarkRadius, \n                           lastPoint + MarkRadius), Black, Black); \n  } \n} \n\n```", "```cpp\nRect LineFigure::Area() const { \n  Rect lineArea(firstPoint.X(), firstPoint.Y(), \n                lastPoint.X(), lastPoint.Y()); \n  lineArea.Normalize(); \n\n  if (IsMarked()) { \n    lineArea -= MarkRadius; \n    lineArea += MarkRadius; \n  } \n\n  return lineArea; \n} \n\n```", "```cpp\nCursorType LineFigure::GetCursor() const { \n  switch (lineMode) { \n    case CreateLine: \n    case FirstPoint: \n    case LastPoint: \n      return Cursor::Crosshair; \n\n    case MoveLine: \n      return Cursor::SizeAll; \n\n    default: \n      return Cursor::Normal; \n  } \n} \n\n```", "```cpp\nbool LineFigure::WriteFigureToStream(ostream& outStream) const { \n  DrawFigure::WriteFigureToStream(outStream); \n  firstPoint.WritePointToStream(outStream); \n  lastPoint.WritePointToStream(outStream); \n  return ((bool) outStream); \n} \n\nbool LineFigure::ReadFigureFromStream (istream& inStream) { \n  DrawFigure::ReadFigureFromStream(inStream); \n  firstPoint.ReadPointFromStream(inStream); \n  lastPoint.ReadPointFromStream(inStream); \n  return ((bool) inStream); \n} \n\nvoid LineFigure::WriteFigureToClipboard(InfoList& infoList) const{ \n  DrawFigure::WriteFigureToClipboard(charList); \n  firstPoint.WritePointToClipboard(charList); \n  lastPoint.WritePointToClipboard(charList); \n} \n\nvoid LineFigure::ReadFigureFromClipboard(InfoList& infoList) { \n  DrawFigure::ReadFigureFromClipboard(infoList); \n  firstPoint.ReadPointFromClipboard(infoList); \n  lastPoint.ReadPointFromClipboard(infoList); \n} \n\n```", "```cpp\nclass ArrowFigure : public LineFigure { \n  public: \n    ArrowFigure(const Window* windowPtr); \n    FigureId GetId() const {return ArrowId;}; \n\n    bool IsClick(Point mousePoint); \n    bool IsInside(Rect area); \n    void DoubleClick(Point mousePoint); \n\n    void Modify(Size distanceSize); \n    void Move(Size distanceSize); \n    Rect Area() const; \n    void Draw(Graphics& graphics) const; \n\n    bool WriteFigureToStream(ostream& outStream) const; \n    bool ReadFigureFromStream(istream& inStream); \n\n    void WriteFigureToClipboard(InfoList& infoList) const; \n    void ReadFigureFromClipboard(InfoList& infoList); \n\n  private: \n    static const int ArrowLength = 500; \n    Point leftPoint, rightPoint; \n    void CalculateArrowHead(); \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Draw.h\" \n#include \"LineFigure.h\" \n#include \"ArrowFigure.h\" \n\nArrowFigure::ArrowFigure(const Window* windowPtr) \n :LineFigure(windowPtr) { \n  CalculateArrowHead(); \n} \n\n```", "```cpp\nbool ArrowFigure::IsClick(Point mousePoint) { \n  return LineFigure::IsClick(mousePoint) || \n         IsPointInLine(firstPoint, leftPoint, mousePoint) || \n         IsPointInLine(firstPoint, rightPoint, mousePoint) || \n         IsPointInLine(leftPoint, rightPoint, mousePoint); \n} \n\n```", "```cpp\nbool ArrowFigure::IsInside(Rect area) { \n  return area.PointInside(firstPoint) && \n         area.PointInside(lastPoint) && \n         area.PointInside(leftPoint) && \n         area.PointInside(rightPoint); \n} \n\n```", "```cpp\nvoid ArrowFigure::Modify(Size distanceSize) { \n  LineFigure::Modify(distanceSize); \n  CalculateArrowHead(); \n} \n\n```", "```cpp\nvoid ArrowFigure::Move(Size distanceSize) { \n  LineFigure::Move(distanceSize); \n  leftPoint += distanceSize; \n  rightPoint += distanceSize; \n} \n\n```", "```cpp\nvoid ArrowFigure::DoubleClick(Point mousePoint) { \n  if (IsClick(mousePoint)) { \n    Invalidate(); \n    Point tempPoint = firstPoint; \n    firstPoint = lastPoint; \n    lastPoint = tempPoint; \n    CalculateArrowHead(); \n    Invalidate(); \n  } \n} \n\n```", "```cpp\nRect ArrowFigure::Area() const { \n  Point topLeft(min(firstPoint.X(), min(lastPoint.X(), \n                    min(leftPoint.X(), rightPoint.X()))), \n                min(firstPoint.Y(), min(lastPoint.Y(), \n                    min(leftPoint.Y(), rightPoint.Y())))), \n        bottomRight(max(firstPoint.X(), max(lastPoint.X(), \n                        max(leftPoint.X(), rightPoint.X()))), \n                    max(firstPoint.Y(), max(lastPoint.Y(), \n                        max(leftPoint.Y(), rightPoint.Y())))); \n\n  if (IsMarked()) { \n    topLeft -= MarkRadius; \n    bottomRight += MarkRadius; \n  } \n\n  return Rect(topLeft, bottomRight); \n} \n\n```", "```cpp\nvoid ArrowFigure::Draw(Graphics& graphics) const { \n  LineFigure::Draw(graphics); \n\n  graphics.DrawLine(lastPoint, leftPoint, GetColor()); \n  graphics.DrawLine(lastPoint, rightPoint, GetColor()); \n  graphics.DrawLine(leftPoint, rightPoint, GetColor());  \n  if (IsMarked()) { \n    graphics.FillRectangle(Rect(leftPoint - MarkRadius, \n                           leftPoint + MarkRadius), Black, Black); \n    graphics.FillRectangle(Rect(rightPoint - MarkRadius, \n                           rightPoint + MarkRadius), Black,Black); \n  } \n} \n\n```", "```cpp\nbool ArrowFigure::WriteFigureToStream(ostream& outStream) const { \n  LineFigure::WriteFigureToStream(outStream); \n  leftPoint.WritePointToStream(outStream); \n  rightPoint.WritePointToStream(outStream); \n  return ((bool) outStream); \n} \n\nbool ArrowFigure::ReadFigureFromStream(istream& inStream) { \n  LineFigure::ReadFigureFromStream(inStream); \n  leftPoint.ReadPointFromStream(inStream); \n  rightPoint.ReadPointFromStream(inStream); \n  return ((bool) inStream); \n} \n\nvoid ArrowFigure::WriteFigureToClipboard(InfoList& infoList)const{ \n  LineFigure::WriteFigureToClipboard(charList); \n  leftPoint.WritePointToClipboard(charList); \n  rightPoint.WritePointToClipboard(charList); \n} \n\nvoid ArrowFigure::ReadFigureFromClipboard(InfoList& infoList) { \n  LineFigure::ReadFigureFromClipboard(infoList); \n  leftPoint.ReadPointFromClipboard(infoList); \n  rightPoint.ReadPointFromClipboard(infoList); \n} \n\n```", "```cpp\nvoid ArrowFigure::CalculateArrowHead() { \n  int height = lastPoint.Y() - firstPoint.Y(); \n  int width = lastPoint.X() - firstPoint.X(); \n\n  const double Pi = 3.14159265; \n  double alpha = atan2((double) height, (double) width); \n  double beta = alpha + Pi; \n\n  double leftAngle = beta - (Pi / 4); \n  double rightAngle = beta + (Pi / 4); \n\n  leftPoint.X() = lastPoint.X() + \n                  (int) (ArrowLength * cos(leftAngle)); \n  leftPoint.Y() = lastPoint.Y() + \n                  (int) (ArrowLength * sin(leftAngle)); \n\n  rightPoint.X() = lastPoint.X() + \n                   (int) (ArrowLength * cos(rightAngle)); \n  rightPoint.Y() = lastPoint.Y() + \n                   (int) (ArrowLength * sin(rightAngle)); \n} \n\n```", "```cpp\nclass RectangleFigure : public DrawFigure { \n  public: \n    RectangleFigure(const Window* windowPtr); \n\n    virtual void SetFirstPoint(Point point); \n    virtual FigureId GetId() const {return RectangleId;} \n\n    virtual bool IsClick(Point mousePoint); \n    virtual bool IsInside(Rect rectangleArea); \n    virtual void DoubleClick(Point mousePoint); \n\n    virtual void Modify(Size distanceSize); \n    virtual void Move(Size distanceSize); \n\n    virtual Rect Area() const; \n    virtual void Draw(Graphics& graphics) const; \n    virtual CursorType GetCursor() const; \n\n    bool IsFillable() const {return true;} \n    bool IsFilled() const {return filled;} \n    void Fill(bool fill) {filled = fill; Invalidate();} \n\n    virtual bool WriteFigureToStream(ostream& outStream) const; \n    virtual bool ReadFigureFromStream(istream& inStream); \n\n    virtual void WriteFigureToClipboard(InfoList& infoList) const; \n    virtual void ReadFigureFromClipboard(InfoList& infoList); \n\n  private: \n    enum {CreateRectangle, TopLeftPoint, TopRightPoint, \n          BottomRightPoint, BottomLeftPoint, MoveRectangle} \n         rectangleMode; \n\n  protected: \n    bool filled = false; \n    Point topLeft, bottomRight; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"Draw.h\"\n#include \"RectangleFigure.h\"\nRectangleFigure::RectangleFigure(const Window* windowPtr)\n:Draw(windowPtr), rectangleMode(CreateRectangle) { /* Empty. */ }\nvoid RectangleFigure::SetFirstPoint(Point point) { topLeft = point; bottomRight = point; }\n```", "```cpp\nbool RectangleFigure::IsClick(Point mousePoint) { \n  Rect topLeftRect(topLeft - MarkRadius, topLeft + MarkRadius); \n\n  if (topLeftRect.PointInside(mousePoint)) { \n    rectangleMode = TopLeftPoint; \n    return true; \n  } \n\n  Point topRightPoint(bottomRight.X(), topLeft.Y()); \n  Rect topRectRight(topRightPoint - MarkRadius, \n                    topRightPoint + MarkRadius); \n\n  if (topRectRight.PointInside(mousePoint)) { \n    rectangleMode = TopRightPoint; \n    return true; \n  } \n\n  Rect bottomRightRect(bottomRight - MarkRadius, \n                       bottomRight + MarkRadius); \n\n  if (bottomRightRect.PointInside(mousePoint)) { \n    rectangleMode = BottomRightPoint; \n    return true; \n  } \n\n  Point bottomLeftPoint(topLeft.X(), bottomRight.Y()); \n  Rect bottomLeftRect(bottomLeftPoint - MarkRadius, \n                      bottomLeftPoint + MarkRadius); \n\n  if (bottomLeftRect.PointInside(mousePoint)) { \n    rectangleMode = BottomLeftPoint; \n    return true; \n  } \n\n  Rect areaRect(topLeft, bottomRight); \n  areaRect.Normalize(); \n\n  if (IsFilled()) { \n    areaRect.PointInside(mousePoint);    \n\n    if (areaRect.PointInside(mousePoint)) { \n      rectangleMode = MoveRectangle; \n      return true; \n    } \n  } \n\n  else { \n    Rect largeAreaRect(areaRect.TopLeft() - MarkRadius, \n                       areaRect.BottomRight() + MarkRadius), \n         smallAreaRect(areaRect.TopLeft() + MarkRadius, \n                       areaRect.BottomRight() - MarkRadius); \n\n    if (largeAreaRect.PointInside(mousePoint) && \n        !smallAreaRect.PointInside(mousePoint)) { \n      rectangleMode = MoveRectangle; \n      return true; \n    } \n  } \n\n  return false; \n} \n\n```", "```cpp\nbool RectangleFigure::IsInside(Rect area) { \n  return area.PointInside(topLeft) && \n         area.PointInside(bottomRight); \n} \n\n```", "```cpp\nvoid RectangleFigure::DoubleClick(Point mousePoint) { \n  if (IsClick(mousePoint)) { \n    filled = !filled; \n    Invalidate(); \n  } \n} \n\n```", "```cpp\nvoid RectangleFigure::Modify(Size distanceSize) { \n  Invalidate(); \n\n  switch (rectangleMode) { \n    case TopLeftPoint: \n      topLeft += distanceSize; \n      break; \n\n    case TopRightPoint: \n      topLeft.Y() += distanceSize.Height(); \n      bottomRight.X() += distanceSize.Width(); \n      break; \n\n    case CreateRectangle: \n    case BottomRightPoint: \n      bottomRight += distanceSize; \n      break; \n\n    case BottomLeftPoint: \n      topLeft.X() += distanceSize.Width(); \n      bottomRight.Y() += distanceSize.Height(); \n      break; \n\n    case MoveRectangle: \n      Move(distanceSize); \n      break; \n  } \n\n  Invalidate(); \n} \n\n```", "```cpp\nvoid RectangleFigure::Move(Size distanceSize) { \n  Invalidate(); \n  topLeft += distanceSize; \n  bottomRight += distanceSize; \n  Invalidate(); \n} \n\n```", "```cpp\nRect RectangleFigure::Area() const {\n  Rect areaRect(topLeft, bottomRight); \n  areaRect.Normalize(); \n\n  if (IsMarked()) { \n    areaRect -= MarkRadius; \n    areaRect += MarkRadius; \n  }  \n  return areaRect; \n} \n\n```", "```cpp\nvoid RectangleFigure::Draw(Graphics& graphics) const { \n  if (filled) { \n    graphics.FillRectangle(Rect(topLeft, bottomRight), \n                           GetColor(), GetColor()); \n  } \n  else { \n    graphics.DrawRectangle(Rect(topLeft, bottomRight), \n                           GetColor()); \n  } \n\n  if (IsMarked()) { \n    graphics.FillRectangle(Rect(topLeft - MarkRadius, \n                           topLeft + MarkRadius), Black, Black); \n\n    Point topRight(bottomRight.X(), topLeft.Y()); \n    graphics.FillRectangle(Rect(topRight - MarkRadius, \n                           topRight + MarkRadius), Black, Black); \n\n    graphics.FillRectangle(Rect(bottomRight - MarkRadius, \n                           bottomRight + MarkRadius),Black,Black); \n\n    Point bottomLeft(topLeft.X(), bottomRight.Y()); \n    graphics.FillRectangle(Rect(bottomLeft - MarkRadius, \n                 bottomLeft + MarkRadius.Height()), Black, Black); \n  } \n} \n\n```", "```cpp\nCursorType RectangleFigure::GetCursor() const { \n  switch (rectangleMode) { \n    case TopLeftPoint: \n    case BottomRightPoint: \n      return Cursor::SizeNorthWestSouthEast; \n\n    case TopRightPoint: \n    case BottomLeftPoint: \n      return Cursor::SizeNorthEastSouthWest; \n\n    case MoveRectangle: \n      return Cursor::SizeAll; \n\n    default: \n      return Cursor::Normal; \n  } \n} \n\n```", "```cpp\nbool RectangleFigure::WriteFigureToStream(ostream& outStream) \n                                          const { \n  DrawFigure::WriteFigureToStream(outStream); \n  topLeft.WritePointToStream(outStream); \n  bottomRight.WritePointToStream(outStream); \n  outStream.write((char*) &filled, sizeof filled); \n  return ((bool) outStream); \n} \n\nbool RectangleFigure::ReadFigureFromStream (istream& inStream) { \n  DrawFigure::ReadFigureFromStream(inStream); \n  topLeft.ReadPointFromStream(inStream); \n  bottomRight.ReadPointFromStream(inStream); \n  inStream.read((char*) &filled, sizeof filled); \n  return ((bool) inStream); \n} \n\nvoid RectangleFigure::WriteFigureToClipboard(InfoList& infoList) \n                                             const { \n  DrawFigure::WriteFigureToClipboard(infoList); \n  topLeft.WritePointToClipboard(infoList); \n  bottomRight.WritePointToClipboard(infoList); \n  infoList.AddValue<bool>(filled); \n} \n\nvoid RectangleFigure::ReadFigureFromClipboard(InfoList& infoList) { \n  DrawFigure::ReadFigureFromClipboard(infoList); \n  topLeft.ReadPointFromClipboard(infoList); \n  bottomRight.ReadPointFromClipboard(infoList); \n  infoList.GetValue<bool>(filled); \n} \n\n```", "```cpp\nclass EllipseFigure : public RectangleFigure { \n  public: \n    EllipseFigure(const Window* windowPtr); \n    FigureId GetId() const {return EllipseId;} \n\n    bool IsClick(Point mousePoint); \n    void Modify(Size distanceSize); \n    void Draw(Graphics& graphics) const; \n    CursoTyper GetCursor() const; \n\n  private: \n    enum {CreateEllipse, LeftPoint, TopPoint, RightPoint, \n          BottomPoint, MoveEllipse} ellipseMode; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"Draw.h\"\n#include \"RectangleFigure.h\"\n#include \"EllipseFigure.h\"\nEllipseFigure::EllipseFigure(const Window* windowPtr) \n :RectangleFigure(windowPtr), \n  ellipseMode(CreateEllipse) { \n  // Empty. \n} \n\n```", "```cpp\nbool EllipseFigure::IsClick(Point mousePoint) { \n  Point leftPoint(topLeft.X(), (topLeft.Y() + bottomRight.Y())/2); \n  Rect leftRect(leftPoint - MarkRadius, leftPoint + MarkRadius); \n\n  if (leftRect.PointInside(mousePoint)) { \n    ellipseMode = LeftPoint; \n    return true; \n  } \n\n  Point topPoint((topLeft.X() + bottomRight.X()) / 2,topLeft.Y()); \n  Rect topRect(topPoint - MarkRadius, topPoint + MarkRadius); \n\n  if (topRect.PointInside(mousePoint)) { \n    ellipseMode = TopPoint; \n    return true; \n  } \n\n  Point rightPoint(bottomRight.X(), \n                   (topLeft.Y() + bottomRight.Y()) / 2); \n  Rect rightRect(rightPoint - MarkRadius, \n                 rightPoint + MarkRadius); \n\n  if (rightRect.PointInside(mousePoint)) { \n    ellipseMode = RightPoint; \n    return true; \n  } \n  Point bottomPoint((topLeft.X() + bottomRight.X()) / 2, \n                    bottomRight.Y()); \n  Rect bottomRect(bottomPoint - MarkRadius, \n                  bottomPoint + MarkRadius); \n\n  if (bottomRect.PointInside(mousePoint)) { \n    ellipseMode = BottomPoint; \n    return true; \n  } \n\n```", "```cpp\n  ellipseMode = MoveEllipse; \n  Point minPoint = Min(topLeft, bottomRight), \n        maxPoint = Max(topLeft, bottomRight);  \n  if (IsFilled()) { \n    HRGN ellipseRegion = \n      CreateEllipticRgn(minPoint.X(), minPoint.Y(), \n                        maxPoint.X(), maxPoint.Y()); \n    return (PtInRegion(ellipseRegion, mousePoint.X(), \n                       mousePoint.Y()) != 0); \n  } \n  else { \n    HRGN smallRegion = \n      CreateEllipticRgn(minPoint.X() + MarkRadius.Width(), \n                        minPoint.Y() + MarkRadius.Height(), \n                        maxPoint.X() - MarkRadius.Width(), \n                        maxPoint.Y() - MarkRadius.Height()); \n    HRGN largeRegion = \n      CreateEllipticRgn(minPoint.X() - MarkRadius.Width(), \n                        minPoint.Y() - MarkRadius.Height(), \n                        maxPoint.X() + MarkRadius.Width(), \n                        maxPoint.Y() + MarkRadius.Height()); \n    return ((PtInRegion(largeRegion, mousePoint.X(), \n                        mousePoint.Y()) != 0) && \n            (PtInRegion(smallRegion, mousePoint.X(), \n                        mousePoint.Y()) == 0)); \n  } \n\n  return false; \n} \n\n```", "```cpp\nvoid EllipseFigure::Modify(Size distanceSize) { \n  Invalidate(); \n\n  switch (ellipseMode) { \n    case CreateEllipse: \n      bottomRight += distanceSize; \n      break; \n\n    case LeftPoint: \n      topLeft.X() += distanceSize.Width(); \n      break; \n\n    case RightPoint: \n      bottomRight.X() += distanceSize.Width(); \n      break; \n\n    case TopPoint: \n      topLeft.Y() += distanceSize.Height(); \n      break; \n\n    case BottomPoint: \n      bottomRight.Y() += distanceSize.Height(); \n      break; \n\n    case MoveEllipse: \n      Move(distanceSize); \n      break; \n  } \n\n  Invalidate(); \n} \n\n```", "```cpp\nvoid EllipseFigure::Draw(Graphics& graphics) const { \n  if (filled) { \n    graphics.FillEllipse(Rect(topLeft, bottomRight), \n                         GetColor(), GetColor()); \n  } \n  else { \n    graphics.DrawEllipse(Rect(topLeft, bottomRight), GetColor()); \n  } \n\n  if (IsMarked()) { \n    Point leftPoint(topLeft.X(), (topLeft.Y()+bottomRight.Y())/2); \n    graphics.FillRectangle(Rect(leftPoint - MarkRadius,  \n                           leftPoint + MarkRadius), Black, Black); \n\n    Point topPoint((topLeft.X() + bottomRight.X())/2,topLeft.Y()); \n    graphics.FillRectangle(Rect(topPoint - MarkRadius, \n                           topPoint + MarkRadius),Black, Black); \n\n    Point rightPoint(bottomRight.X(), \n                     (topLeft.Y() + bottomRight.Y()) / 2); \n    graphics.FillRectangle(Rect(rightPoint - MarkRadius, \n                           rightPoint + MarkRadius), Black,Black); \n\n    Point bottomPoint((topLeft.X() + bottomRight.X()) / 2, \n                      bottomRight.Y()); \n    graphics.FillRectangle(Rect(bottomPoint - MarkRadius, \n                           bottomPoint + MarkRadius),Black,Black); \n  } \n} \n\n```", "```cpp\nCursorType EllipseFigure::GetCursor() const { \n  switch (ellipseMode) { \n    case CreateEllipse: \n      return Cursor::Crosshair; \n\n    case LeftPoint: \n    case RightPoint: \n      return Cursor::SizeWestEast; \n\n    case TopPoint: \n    case BottomPoint: \n      return Cursor::SizeNorthSouth; \n\n    case MoveEllipse: \n      return Cursor::SizeAll; \n\n    default: \n      return Cursor::Normal; \n  } \n} \n\n```"]