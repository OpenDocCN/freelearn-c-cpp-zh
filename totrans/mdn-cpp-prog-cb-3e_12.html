<html><head></head><body>
<div><h1 class="chapterNumber">12</h1>
<h1 class="chapterTitle" id="_idParaDest-754">C++ 20 Core Features</h1>
<p class="normal">The new C++20 standard is a major step in the development of the C++ language. C++20 brings many new features both to the language and to the standard library. Some of these have already been discussed in previous chapters, such as the text formatting library, the calendar extensions to the chrono library, the changes to the thread support library, and many others. However, the features that impact the language the most are modules, concepts, coroutines, and the new ranges library. The specification of these features is very lengthy, which makes it difficult to cover them in great detail in this book. Therefore, in this chapter, we will look at the most important aspects and use cases of these features. This chapter is intended to help you start using these features.</p>
<p class="normal">This chapter includes the following recipes:</p>
<ul>
<li class="bulletList">Working with modules</li>
<li class="bulletList">Understanding module partitions</li>
<li class="bulletList">Specifying requirements on template arguments with concepts</li>
<li class="bulletList">Using requires expressions and clauses</li>
<li class="bulletList">Exploring abbreviated function templates</li>
<li class="bulletList">Iterating over collections with the ranges library</li>
<li class="bulletList">Exploring the standard range adaptors</li>
<li class="bulletList">Converting a range to a container</li>
<li class="bulletList">Creating your own range view</li>
<li class="bulletList">Using constrained algorithms</li>
<li class="bulletList">Creating a coroutine task type for asynchronous computations</li>
<li class="bulletList">Creating a coroutine generator type for sequences of values</li>
<li class="bulletList">Generating a sequence of values with the std::generator type</li>
</ul>
<p class="normal">Let’s start this chapter by learning about modules, which are the most disruptive change that’s happened to the C++ language in decades.</p>
<h1 class="heading-1" id="_idParaDest-755">Working with modules</h1>
<p class="normal">Modules are<a id="_idIndexMarker1421"/> one of the most important changes in the C++20 standard. They represent a fundamental change to the C++ language and the way we write and consume code. Modules are made available in source files that are compiled separately from the translation units that consume them.</p>
<p class="normal">Modules provide multiple<a id="_idIndexMarker1422"/> advantages, especially in comparison to the use of header files:</p>
<ul>
<li class="bulletList">They are only imported once, and the order they’re imported in does not matter.</li>
<li class="bulletList">They do not require splitting interfaces and implementation in different source files, although this is still possible.</li>
<li class="bulletList">Modules have the potential to reduce compilation time, in some cases significantly. The entities exported from a module are described in a binary file that the compiler can process faster than traditional precompiled headers.</li>
<li class="bulletList">Moreover, this file can potentially be used to build integrations and interoperability with C++ code from other languages.</li>
</ul>
<p class="normal">In this recipe, you will learn how to get started with modules.</p>
<h2 class="heading-2" id="_idParaDest-756">Getting ready</h2>
<p class="normal">At the time of writing, the major compilers (VC++, Clang, and GCC) provide different levels of support for modules. Build systems, such as CMake, are lagging in terms of adoption for modules (although this is likely to change in the near future). Because different compilers have different ways of, and different compiler options for, supporting modules, this book will not provide details on how to build these samples. You are invited to consult online documentation for specific compilers.</p>
<div><p class="normal">The source code accompanying this book includes scripts for building the source code presented in this recipe and the next one, using the MSVC compiler (cl.exe) from Visual Studio 2019 16.8 and, respectively, Visual Studio 2022 17.x.</p>
</div>
<p class="normal">There are several types of module files: <em class="italic">module interface units</em>, <em class="italic">module interface partitions</em>, and <em class="italic">module implementation partitions</em>. In this recipe, we’ll refer solely to the first; the other two, we will learn about in the next recipe.</p>
<h2 class="heading-2" id="_idParaDest-757">How to do it…</h2>
<p class="normal">When you<a id="_idIndexMarker1423"/> modularize your code, you can do the following:</p>
<ul>
<li class="bulletList">Import a module using the <code class="inlineCode">import</code> directive, followed by the module name. The standard library is available in the <code class="inlineCode">std</code> module, but only starting with C++23. This allows us to write the following in C++23:
        <pre class="programlisting code"><code class="hljs-code">import std;
int main()
{
   std::println("Hello, world!");
}
</code>
std.core</code> module from Visual C++, which contains most of the functionality of the standard library, including the streams library:</pre>
<pre class="programlisting code"><code class="hljs-code">import std.core;
int main()
{
  std::cout &lt;&lt; "Hello, World!\n";
}
</code></pre></li>
</ul>
<ul>
<li class="bulletList">Export a module by creating <a id="_idIndexMarker1424"/>a <strong class="keyWord">module interface unit</strong> (<strong class="keyWord">MIU</strong>) that can contain functions, types, constants, and even macros. Their declaration must be preceded by the keyword <code class="inlineCode">export</code>. The module interface unit file must have the extension <code class="inlineCode">.ixx</code> for VC++. Clang accepts different extensions, including <code class="inlineCode">.cpp</code>, <code class="inlineCode">.cppm</code>, and even <code class="inlineCode">.ixx</code>. The following sample exports a class template called <code class="inlineCode">point</code>, a function called <code class="inlineCode">distance()</code> that computes the distance between two <a id="_idIndexMarker1425"/>points, and a user-defined literal operator called <code class="inlineCode">_ip</code> that creates objects of the type <code class="inlineCode">point</code> from strings, in the form <code class="inlineCode">"0,0"</code> or <code class="inlineCode">"12,-3"</code>:
        <pre class="programlisting code"><code class="hljs-code">// --- geometry.ixx/.cppm ---
export module geometry;
#ifdef __cpp_lib_modules
import std;
#else
import std.core;
#endif
export template &lt;class T,
   typename = typename std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
struct point
{
   T x;
   T y;
};
export using int_point = point&lt;int&gt;;
export constexpr int_point int_point_zero{ 0,0 };
export template &lt;class T&gt;
double distance(point&lt;T&gt; const&amp; p1, point&lt;T&gt; const&amp; p2)
{
   return std::sqrt((p2.x - p1.x) * (p2.x - p1.x) +
                    (p2.y - p1.y) * (p2.y - p1.y));
}
namespace geometry_literals
{
   export int_point operator ""_ip(const char* ptr, std::size_t size)
   {
      int x = 0, y = 0;
      if(ptr)
      {
         while (*ptr != ',' &amp;&amp; *ptr != ' ')
            x = x * 10 + (*ptr++ - '0');
         while (*ptr == ',' || *ptr == ' ') ptr++;
         while (*ptr != 0)
            y = y * 10 + (*ptr++ - '0');
      }
      return { x, y };
   }
}
// --- main.cpp ---
#ifdef __cpp_lib_modules
import std;
#else
import std.core;
#endif
import geometry;
int main()
{
   int_point p{ 3, 4 };
   std::cout &lt;&lt; distance(int_point_zero, p) &lt;&lt; '\n';
   {
      using namespace geometry_literals;
      std::cout &lt;&lt; distance("0,0"_ip, "30,40"_ip) &lt;&lt; '\n';
   }
}
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">import</code> directive to also import the content of a header. The example<a id="_idIndexMarker1426"/> presented here uses the same type and functions seen in the preceding example:
        <pre class="programlisting code"><code class="hljs-code">// --- geometry.h ---
#pragma once
#include &lt;cmath&gt;
template &lt;class T,
   typename = typename std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
struct point
{
   T x;
   T y;
};
using int_point = point&lt;int&gt;;
constexpr int_point int_point_zero{ 0,0 };
template &lt;class T&gt;
double distance(point&lt;T&gt; const&amp; p1, point&lt;T&gt; const&amp; p2)
{
   return std::sqrt((p2.x – p1.x) * (p2.x – p1.x) +
                    (p2.y – p1.y) * (p2.y – p1.y));
}
namespace geometry_literals
{
   int_point operator ""_ip(const char* ptr, std::size_t)
   {
      int x = 0, y = 0;
      if(ptr)
      {
while (*ptr != ',' &amp;&amp; *ptr != ' ')
            x = x * 10 + (*ptr++ - '0');
         while (*ptr == ',' || *ptr == ' ') ptr++;
         while (*ptr != 0)
            y = y * 10 + (*ptr++ - '0');
      }
      return { x, y };
   }
}
// --- main.cpp ---
#ifdef __cpp_lib_modules
import std;
#else
import std.core;
#endif
import "geometry.h";
int main()
{
   int_point p{ 3, 4 };
   std::cout &lt;&lt; distance(int_point_zero, p) &lt;&lt; '\n';
   {
      using namespace geometry_literals;
      std::cout &lt;&lt; distance("0,0"_ip, "30,40"_ip) &lt;&lt; '\n';
   }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-758">How it works...</h2>
<p class="normal">A module unit<a id="_idIndexMarker1427"/> is composed of several parts, mandatory or optional:</p>
<ul>
<li class="bulletList">The <em class="italic">global module fragment</em>, introduced with a <code class="inlineCode">module;</code> statement. This part is optional and, if present, may<a id="_idIndexMarker1428"/> only contain preprocessor directives. Everything that is added here is said to belong to the <em class="italic">global module</em>, which is<a id="_idIndexMarker1429"/> a collection of all the global module fragments and all the translation units that are not modules.</li>
<li class="bulletList">The <em class="italic">module declaration</em>, which is<a id="_idIndexMarker1430"/> a required statement of the form <code class="inlineCode">export</code> <code class="inlineCode">module name;</code>.</li>
<li class="bulletList">The <em class="italic">module preamble</em>, which is<a id="_idIndexMarker1431"/> optional and may only contain import declarations.</li>
<li class="bulletList">The <em class="italic">module purview</em>, which is<a id="_idIndexMarker1432"/> the content of the unit, starting with the module declaration and extending to the end of the module unit.</li>
</ul>
<p class="normal">The following <a id="_idIndexMarker1433"/>diagram shows a module unit containing all of the aforementioned parts. On the left side, we have the source code of the module, and on the right side, the module parts are explained:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_12_01.png"/></figure>
<p class="packt_figref">Figure 12.1: An example of a module (on the left side) with each part highlighted and explained (on the right side)</p>
<p class="normal">A module <a id="_idIndexMarker1434"/>can export any entity, such as functions, classes, and constants. Every export must be preceded by the <code class="inlineCode">export</code> keyword. This keyword is always the first keyword, preceding others such as <code class="inlineCode">class</code>/<code class="inlineCode">struct</code>, <code class="inlineCode">template</code>, or <code class="inlineCode">using</code>. Several examples have been<a id="_idIndexMarker1435"/> provided in the <strong class="keyWord">geometry</strong> module shown in the previous section:</p>
<ul>
<li class="bulletList">An E class template called <code class="inlineCode">point</code>, which represents a point in the two-dimensional space</li>
<li class="bulletList">A type alias for <code class="inlineCode">point&lt;int&gt;</code> called <code class="inlineCode">int_point</code></li>
<li class="bulletList">A compile-time constant called <code class="inlineCode">int_point_zero</code></li>
<li class="bulletList">A function template, <code class="inlineCode">distance()</code>, that computes the distance between two points</li>
<li class="bulletList">A user-defined literal <code class="inlineCode">_ip</code> that creates <code class="inlineCode">int_point</code> objects from strings such as <code class="inlineCode">"3,4"</code></li>
</ul>
<p class="normal">A translation unit that uses modules instead of headers does not require any other changes, except for replacing <code class="inlineCode">#include</code> preprocessor directives with <code class="inlineCode">import</code> directives. Moreover, headers can also be imported as modules using the same <code class="inlineCode">import</code> directive, as shown in an example earlier.</p>
<p class="normal">There is no relationship between modules and namespaces. These two are independent concepts. The module <code class="inlineCode">geometry</code> exports the user-defined literal <code class="inlineCode">""_ip</code> in the namespace <code class="inlineCode">geometry_literals</code>, while all the other exports in the module are available in the global namespace.</p>
<p class="normal">There is also no relationship between the module names and the name of the unit file. The geometry module was defined in a file called <code class="inlineCode">geometry.ixx</code>/<code class="inlineCode">.cppm</code>, although any filename would have had the same result. It is recommended that you follow a consistent naming scheme and use the module name for the module filename too. On the other hand, the extension used for module units differs with each compiler, although this could be something that may change in the future when module support reaches maturity.</p>
<p class="normal">Prior to C++23, the standard library was not yet modularized. However, compilers have already made it available in modules. The Clang compiler provides a different module for each header. On the other hand, the Visual C++ compiler provides the following modules for the standard library:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std.regex</code>: The content of the <code class="inlineCode">&lt;regex&gt;</code> header</li>
<li class="bulletList"><code class="inlineCode">std.filesystem</code>: The content of the <code class="inlineCode">&lt;filesystem&gt;</code> header</li>
<li class="bulletList"><code class="inlineCode">std.memory</code>: The content of the <code class="inlineCode">&lt;memory&gt;</code> header</li>
<li class="bulletList"><code class="inlineCode">std.threading</code>: The content of the headers <code class="inlineCode">&lt;atomic&gt;</code>, <code class="inlineCode">&lt;condition_variable&gt;</code>, <code class="inlineCode">&lt;future&gt;</code>, <code class="inlineCode">&lt;mutex&gt;</code>, <code class="inlineCode">&lt;shared_mutex&gt;</code>, and <code class="inlineCode">&lt;thread&gt;</code></li>
<li class="bulletList"><code class="inlineCode">std.core</code>: The rest of the C++ standard library</li>
</ul>
<p class="normal">As you can <a id="_idIndexMarker1436"/>see from these module names, such as <code class="inlineCode">std.core</code> or <code class="inlineCode">std.regex</code>, the name of the module can be a series of identifiers concatenated with a dot (<code class="inlineCode">.</code>). The dot has no significance other than helping to split the name into parts representing a logical hierarchy, such as <code class="inlineCode">company.project.module</code>. The use of a dot can arguably provide better readability compared to the use of an underscore (such as in <code class="inlineCode">std_core</code> or <code class="inlineCode">std_regex</code>), which is also legal, like anything else that may form an identifier.</p>
<p class="normal">The C++23 standard, on the other<a id="_idIndexMarker1437"/> hand, provides two standardized named modules:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std</code>, which imports everything from the C++ standard headers (such as <code class="inlineCode">&lt;vector&gt;</code>, <code class="inlineCode">&lt;string&gt;</code>, <code class="inlineCode">&lt;algorithm&gt;</code>, etc.) and C wrapper headers (such as <code class="inlineCode">&lt;cstdio&gt;</code>) into the <code class="inlineCode">std</code> namespace. You should use this module if you qualify everything with <code class="inlineCode">std</code> and don’t want to pollute the global namespace.</li>
<li class="bulletList"><code class="inlineCode">std.compat</code>, which imports everything that <code class="inlineCode">std</code> does and, in addition, the global namespace counterparts of the C wrapper headers. For instance, if <code class="inlineCode">std</code> imports <code class="inlineCode">std::fopen</code> and <code class="inlineCode">std::fclose</code> (along with everything else) from <code class="inlineCode">&lt;cstdio&gt;</code>, then <code class="inlineCode">std.compat</code> imports <code class="inlineCode">::fopen</code> and <code class="inlineCode">::fclose</code>. You should use this module if you want to migrate code more easily without having to qualify names with the <code class="inlineCode">std</code> namespace (such as <code class="inlineCode">std::fopen</code> instead of <code class="inlineCode">fopen</code>, <code class="inlineCode">std::size_t</code> instead of <code class="inlineCode">size_t</code>, etc.).</li>
</ul>
<p class="normal">As a programmer, you are familiar with the typical introductory program to any programming language called <em class="italic">“Hello, world!”</em> that simply prints this text to the console. In C++, the canonical form of this program used to be the following:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;iostream&gt;
int main()
{
   std::cout &lt;&lt; "Hello, world!\n";
}
</code></pre>
<p class="normal">In C++23, with support for standardized modules and the new printing capabilities of the text formatting library, this program can look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">import std;
int main()
{
   std::println("Hello, world!");
}
</code></pre>
<p class="normal">You can check<a id="_idIndexMarker1438"/> whether the standard modules <code class="inlineCode">std</code> and <code class="inlineCode">std.compat</code> are available using the <code class="inlineCode">__cpp_lib_modules</code> feature macro.</p>
<h2 class="heading-2" id="_idParaDest-759">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding module partitions</em>, to learn about interface and implementation partitions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-760">Understanding module partitions</h1>
<p class="normal">The source code of a module may become large and difficult to maintain. Moreover, a module may be composed of logically separate parts. To help with scenarios such as these, modules support composition from parts <a id="_idIndexMarker1439"/>called <em class="italic">partitions</em>. A module unit that is a partition that<a id="_idIndexMarker1440"/> exports entities is called a <em class="italic">module interface partition</em>.</p>
<p class="normal">However, there could also be internal partitions that do not export anything. Such a partition unit is called <a id="_idIndexMarker1441"/>a <em class="italic">module implementation partition</em>. In this recipe, you will learn how to work with interface and implementation partitions.</p>
<h2 class="heading-2" id="_idParaDest-761">Getting ready</h2>
<p class="normal">You should read the previous recipe, <em class="italic">Working with modules</em>, before continuing with this one. You will need both the module fundamentals we discussed there and the code examples that we will continue with in this recipe.</p>
<div><p class="normal">In the following examples, we will use the <code class="inlineCode">std</code> module, which is only available in C++23. For previous versions, use <code class="inlineCode">std.core</code> in VC++ or other particular modules supported by your compiler.</p>
</div>
<h2 class="heading-2" id="_idParaDest-762">How to do it...</h2>
<p class="normal">You can split a <a id="_idIndexMarker1442"/>module into several partitions, as follows:</p>
<ul>
<li class="bulletList">Each partition unit must start with a statement of the form <code class="inlineCode">export module</code> <code class="inlineCode">modulename:partitionname;</code>. Only the global module fragment may precede this declaration:
        <pre class="programlisting code"><code class="hljs-code">// --- geometry-core.ixx/.cppm ---
export module geometry:core;
import std;
export template &lt;class T,
   typename = typename std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
struct point
{
   T x;
   T y;
};
export using int_point = point&lt;int&gt;;
export constexpr int_point int_point_zero{ 0,0 };
export template &lt;class T&gt;
double distance(point&lt;T&gt; const&amp; p1, point&lt;T&gt; const&amp; p2)
{
   return std::sqrt((p2.x - p1.x) * (p2.x - p1.x) +
                    (p2.y - p1.y) * (p2.y - p1.y));
}
// --- geometry-literals.ixx/.cppm ---
export module geometry:literals;
import :core;
namespace geometry_literals
{
   export int_point operator ""_ip(const char* ptr, std::size_t)
   {
      int x = 0, y = 0;
      if(ptr)
      {
while (*ptr != ',' &amp;&amp; *ptr != ' ')
            x = x * 10 + (*ptr++ - '0');
         while (*ptr == ',' || *ptr == ' ') ptr++;
         while (*ptr != 0)
            y = y * 10 + (*ptr++ - '0');
      }
      return { x, y };
   }
}
</code></pre>
</li>
<li class="bulletList">In the <a id="_idIndexMarker1443"/>primary module interface unit, import and then export the partitions with statements of the form <code class="inlineCode">export import :partitionname</code>, such as in the following example:
        <pre class="programlisting code"><code class="hljs-code">// --- geometry.ixx/.cppm ---
export module geometry;
export import :core;
export import :literals;
</code></pre>
</li>
<li class="bulletList">The code importing a module composed from multiple partitions only sees the module as a whole if it was built from a single module unit:
        <pre class="programlisting code"><code class="hljs-code">// --- main.cpp ---
import std;
import geometry;
int main()
{
   int_point p{ 3, 4 };
   std::cout &lt;&lt; distance(int_point_zero, p) &lt;&lt; '\n';
   {
      using namespace geometry_literals;
      std::cout &lt;&lt; distance("0,0"_ip, "30,40"_ip) &lt;&lt; '\n';
   }
}
</code></pre>
</li>
<li class="bulletList">It is possible to create<a id="_idIndexMarker1444"/> internal partitions that do not export anything but contain code that can be used in the same module. Such a partition must start with a statement of the form <code class="inlineCode">module modulename:partitionname;</code> (without the keyword <code class="inlineCode">export</code>). Different compilers may also require a different extension for the file containing an internal partition. For VC++, the extension must be <code class="inlineCode">.cpp</code>:
        <pre class="programlisting code"><code class="hljs-code">// --- geometry-details.cpp --
module geometry:details;
import std;
std::pair&lt;int, int&gt; split(const char* ptr)
{
  int x = 0, y = 0;
  if(ptr)
  {
while (*ptr != ',' &amp;&amp; *ptr != ' ')
      x = x * 10 + (*ptr++ - '0');
    while (*ptr == ',' || *ptr == ' ') ptr++;
    while (*ptr != 0)
      y = y * 10 + (*ptr++ - '0');
  }
  return { x, y };
}
// --- geometry-literals.ixx/.cppm ---
export module geometry:literals;
import :core;
import :details;
namespace geometry_literals
{
  export int_point operator ""_ip(const char* ptr, std::size_t)
  {
    auto [x, y] = split(ptr);
    return {x, y};
  }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-763">How it works...</h2>
<p class="normal">The code<a id="_idIndexMarker1445"/> shown earlier is a follow-up of the modules example presented in the previous recipe. The <code class="inlineCode">geometry</code> module has been split into two different partitions called <code class="inlineCode">core</code> and <code class="inlineCode">literals</code>.</p>
<p class="normal">However, when you declare the partition, you must use the name in the form <code class="inlineCode">modulename:partitionname</code>, such as in <code class="inlineCode">geometry:core</code> and <code class="inlineCode">geometry:literals</code>. This is not necessary when you import a partition elsewhere in the module. This can be seen both in the primary partition unit <code class="inlineCode">geometry.ixx</code> and in the module interface partition <code class="inlineCode">geometry-literals.ixx</code>. Here are the snippets again, for clarity:</p>
<pre class="programlisting code"><code class="hljs-code">// --- geometry-literals.ixx/.cppm ---
export module geometry:literals;
// import the core partition
import :core;
// --- geometry.ixx/.cppm ---
export module geometry;
// import the core partition and then export it
export import :core;
// import the literals partition and then export it
export import :literals;
</code></pre>
<p class="normal">Although module partitions are distinct files, they are not available as separate modules or submodules to translation units using a module. They are exported together as a single, aggregated module. If you compare the source code in the <code class="inlineCode">main.cpp</code> file with the one from the previous recipe, you will see no difference.</p>
<div><p class="normal">As with module interface units, there are no rules for naming the files containing partitions. However, compilers may require different extensions or support some particular naming schemes. For instance, VC++ uses the scheme <code class="inlineCode">&lt;module-name&gt;-&lt;partition-name&gt;.ixx</code>, which simplifies build commands.</p>
</div>
<p class="normal">Partitions, just like modules, may contain code that is not exported from the module. A partition may contain no exports at all, in which case it is an internal partition only. Such a partition is called<a id="_idIndexMarker1446"/> a <em class="italic">module implementation partition</em>. It is defined without using the <code class="inlineCode">export</code> keyword in the module’s declaration.</p>
<p class="normal">An example of an<a id="_idIndexMarker1447"/> internal partition is the <code class="inlineCode">geometry:details</code> partition shown earlier. It provides a helper function, called <code class="inlineCode">split()</code>, to parse two integers separated with a comma from a string. This partition is then imported into the <code class="inlineCode">geometry:literals</code> partitions, where the <code class="inlineCode">split()</code> function is used to implement the user-defined literal <code class="inlineCode">_ip</code>.</p>
<h2 class="heading-2" id="_idParaDest-764">There’s more...</h2>
<p class="normal">Partitions are divisions of a module. However, they are not submodules. They do not logically exist outside of the module. There is no concept of a submodule in the C++ language. The code shown in this recipe using partitions could be written slightly differently using modules:</p>
<pre class="programlisting code"><code class="hljs-code">// --- geometry-core.ixx ---
export module geometry.core;
import std;
export template &lt;class T,
   typename = typename std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
struct point
{
   T x;
   T y;
};
export using int_point = point&lt;int&gt;;
export constexpr int_point int_point_zero{ 0,0 };
export template &lt;class T&gt;
double distance(point&lt;T&gt; const&amp; p1, point&lt;T&gt; const&amp; p2)
{
   return std::sqrt(
      (p2.x - p1.x) * (p2.x - p1.x) +
      (p2.y - p1.y) * (p2.y - p1.y));
}
// --- geometry-literals.ixx ---
export module geometry.literals;
import geometry.core;
namespace geometry_literals
{
   export int_point operator ""_ip(const char* ptr, std::size_t)
   {
      int x = 0, y = 0;
      if(ptr)
      {
while (*ptr != ',' &amp;&amp; *ptr != ' ')
            x = x * 10 + (*ptr++ - '0');
         while (*ptr == ',' || *ptr == ' ') ptr++;
         while (*ptr != 0)
            y = y * 10 + (*ptr++ - '0');
      }
      return { x, y };
   }
}
// --- geometry.ixx ---
export module geometry;
export import geometry.core;
export import geometry.literals;
</code></pre>
<p class="normal">In this example, we have three modules: <code class="inlineCode">geometry.core</code>, <code class="inlineCode">geometry.literals</code>, and <code class="inlineCode">geometry</code>. Here, <code class="inlineCode">geometry</code> imports and then re-exports the entire content of the first two. Because of this, the code in <code class="inlineCode">main.cpp</code> does not need to change. </p>
<p class="normal">By solely importing the <code class="inlineCode">geometry</code> module, we get access to the content of the <code class="inlineCode">geometry.core</code> and <code class="inlineCode">geometry.literals</code> modules.</p>
<p class="normal">However, if we do not <a id="_idIndexMarker1448"/>define the <code class="inlineCode">geometry</code> module anymore, then we need to explicitly import the two modules, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">import std;
import geometry.core;
import geometry.literals;
int main()
{
   int_point p{ 3, 4 };
   std::cout &lt;&lt; distance(int_point_zero, p) &lt;&lt; '\n';
   {
      using namespace geometry_literals;
      std::cout &lt;&lt; distance("0,0"_ip, "30,40"_ip) &lt;&lt; '\n';
   }
}
</code></pre>
<p class="normal">Choosing between using <a id="_idIndexMarker1449"/>partitions or multiple modules to componentize your source code should depend on the particularities of your project. If you use multiple smaller modules, you provide better granularity for imports. This can be important if you’re developing a large library because users should only import things they use (and not a very large module when they only need some functionalities).</p>
<h2 class="heading-2" id="_idParaDest-765">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Working with modules</em>, to explore the fundamentals of C++20 modules</li>
</ul>
<h1 class="heading-1" id="_idParaDest-766">Specifying requirements on template arguments with concepts</h1>
<p class="normal">Template metaprogramming<a id="_idIndexMarker1450"/> is an important part of the C++ language, empowering the development of general-purpose libraries, including the standard library. However, template metaprogramming is not trivial. On the contrary, complex tasks could be tedious and difficult to get right without a lot of experience. In fact, the C++ Core Guidelines, an initiative created by Bjarne Stroustrup and Herb Sutter, have a rule called <em class="italic">Use template metaprogramming only when you really need to,</em> which reasons that:</p>
<blockquote class="packt_quote">
<p class="quote">Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain.</p>
</blockquote>
<p class="normal">An important aspect concerning template metaprogramming has been the specification of constraints for type template parameters, in order to impose restrictions on the types that a template can be instantiated with. The C++20 concepts library is designed to solve this problem. A concept<a id="_idIndexMarker1451"/> is a named set of constraints, and a constraint is a requirement for a template argument. These are used to select the appropriate function overloads and template specializations.</p>
<p class="normal">In this recipe, we will see how we can use C++20 concepts to specify requirements on template arguments.</p>
<h2 class="heading-2" id="_idParaDest-767">Getting ready</h2>
<p class="normal">Before we <a id="_idIndexMarker1452"/>begin learning about <a id="_idIndexMarker1453"/>concepts, let’s consider the following class template, called <code class="inlineCode">NumericalValue</code>, which is supposed to hold a value of an integral or floating-point type. This C++11 implementation employs the use of <code class="inlineCode">std::enable_if</code> to specify requirements for the <code class="inlineCode">T</code> template argument:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;,
          typename = typename std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
struct NumericalValue
{
  T value;
};
template &lt;typename T&gt;
NumericalValue&lt;T&gt; wrap(T value) { return { value }; }
template &lt;typename T&gt;
T unwrap(NumericalValue&lt;T&gt; t) { return t.value; }
auto nv = wrap(42);
std::cout &lt;&lt; nv.value &lt;&lt; '\n';   // prints 42
auto v = unwrap(nv);
std::cout &lt;&lt; v &lt;&lt; '\n';          // prints 42
using namespace std::string_literals;
auto ns = wrap("42"s);           // error
</code></pre>
<p class="normal">This snippet will be the basis for the examples shown in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-768">How to do it...</h2>
<p class="normal">You can specify requirements for template arguments as follows:</p>
<ul>
<li class="bulletList">Create a concept using the <code class="inlineCode">concept</code> keyword with the following form:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
concept Numerical = std::is_arithmetic_v&lt;T&gt;;
</code></pre>
</li>
<li class="bulletList">Alternatively, you can use one of the standard-defined concepts, available in the header <code class="inlineCode">&lt;concepts&gt;</code> (or one of the other standard library headers):
        <pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
concept Numerical = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;
</code></pre>
</li>
<li class="bulletList">Use the concept name instead of the <code class="inlineCode">class</code> or <code class="inlineCode">typename</code> keywords in function templates, class templates, or variable templates:
        <pre class="programlisting code"><code class="hljs-code">template &lt;Numerical T&gt;
struct NumericalValue
{
  T value;
};
template &lt;Numerical T&gt;
NumericalValue&lt;T&gt; wrap(T value) { return { value }; }
template &lt;Numerical T&gt;
T unwrap(NumericalValue&lt;T&gt; t) { return t.value; }
</code></pre>
</li>
<li class="bulletList">Instantiate<a id="_idIndexMarker1454"/> class templates <a id="_idIndexMarker1455"/>and call function templates with no changes in syntax:
        <pre class="programlisting code"><code class="hljs-code">auto nv = wrap(42);
std::cout &lt;&lt; nv.value &lt;&lt; '\n';   // prints 42
auto v = unwrap(nv);
std::cout &lt;&lt; v &lt;&lt; '\n';          // prints 42
using namespace std::string_literals;
auto ns = wrap("42"s);           // error
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-769">How it works...</h2>
<p class="normal">A concept is a set of one or more constraints that is always defined in a namespace scope. The definition of a concept is similar to a variable template. The following snippet shows a concept being used for a variable template:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
concept Real = std::is_floating_point_v&lt;T&gt;;
template&lt;Real T&gt;
constexpr T pi = T(3.1415926535897932385L);
std::cout &lt;&lt; pi&lt;double&gt; &lt;&lt; '\n';
std::cout &lt;&lt; pi&lt;int&gt;    &lt;&lt; '\n'; // error
</code></pre>
<p class="normal">Concepts<a id="_idIndexMarker1456"/> cannot be constrained<a id="_idIndexMarker1457"/> themselves, nor can they refer to themselves recursively. In the examples shown so far, the <code class="inlineCode">Numerical</code> and <code class="inlineCode">Real</code> concepts are composed of a single, atomic constraint. However, concepts can be created from multiple constraints. A constraint created from two constraints using the <code class="inlineCode">&amp;&amp;</code> logical operator is called a <em class="italic">conjunction</em>, while a constraint created from two constraints using the <code class="inlineCode">||</code> logical operator is called a <em class="italic">disjunction</em>.</p>
<p class="normal">The <code class="inlineCode">Numerical</code> concept defined in the <em class="italic">How to do it...</em> section was defined using the <code class="inlineCode">std::is_arithmetic_v</code> type trait. However, we could have two concepts, <code class="inlineCode">Real</code> and <code class="inlineCode">Integral</code>, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
concept Integral = std::is_integral_v&lt;T&gt;;
template &lt;class T&gt;
concept Real = std::is_floating_point_v&lt;T&gt;;
</code></pre>
<p class="normal">From these two, we can compose the <code class="inlineCode">Numerical</code> concept, using the <code class="inlineCode">||</code> logical operator. The result is a disjunction:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
concept Numerical = Integral&lt;T&gt; || Real&lt;T&gt;;
</code></pre>
<p class="normal">Semantically, there is no difference between these two versions of the <code class="inlineCode">Numerical</code> concept, although they are defined in different ways.</p>
<p class="normal">To understand conjunctions, let’s look at another example. Consider two base classes, <code class="inlineCode">IComparableToInt</code> and <code class="inlineCode">IConvertibleToInt</code>, that are supposed to be derived by classes that should support comparison or conversion to <code class="inlineCode">int</code>. These could be defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct IComparableToInt
{
  virtual bool CompareTo(int const o) = 0;
};
struct IConvertibleToInt
{
  virtual int ConvertTo() = 0;
};
</code></pre>
<p class="normal">Some<a id="_idIndexMarker1458"/> classes can implement <a id="_idIndexMarker1459"/>both of them, others only one or the other. The <code class="inlineCode">SmartNumericalValue&lt;T&gt;</code> class here implements both, while <code class="inlineCode">DullNumericalValue&lt;T&gt;</code> only implements the <code class="inlineCode">IConvertibleToInt</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct SmartNumericalValue : public IComparableToint, IConvertibleToInt
{
  T value;
  SmartNumericalValue(T v) :value(v) {}
  bool CompareTo(int const o) override
 { return static_cast&lt;int&gt;(value) == o; }
  int ConvertTo() override
 { return static_cast&lt;int&gt;(value); }
};
template &lt;typename T&gt;
struct DullNumericalValue : public IConvertibleToInt
{
  T value;
  DullNumericalValue(T v) :value(v) {}
  int ConvertTo() override
 { return static_cast&lt;int&gt;(value); }
};
</code></pre>
<p class="normal">What we want to do is write a function template that only accepts arguments that are both comparable and can be converted to <code class="inlineCode">int</code>. The <code class="inlineCode">IComparableAndConvertible</code> concept shown here is a conjunction of the <code class="inlineCode">IntComparable</code> and <code class="inlineCode">IntConvertible</code> concepts. They can be implemented as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
concept IntComparable = std::is_base_of_v&lt;IComparableToInt, T&gt;;
template &lt;class T&gt;
concept IntConvertible = std::is_base_of_v&lt;IConvertibleToInt, T&gt;;
template &lt;class T&gt;
concept IntComparableAndConvertible = IntComparable&lt;T&gt; &amp;&amp; IntConvertible&lt;T&gt;;
template &lt;IntComparableAndConvertible T&gt;
void print(T o)
{
  std::cout &lt;&lt; o.value &lt;&lt; '\n';
}
int main()
{
   auto snv = SmartNumericalValue&lt;double&gt;{ 42.0 };
   print(snv);                      // prints 42
auto dnv = DullNumericalValue&lt;short&gt;{ 42 };
   print(dnv);                      // error
}
</code></pre>
<p class="normal">Conjunctions <a id="_idIndexMarker1460"/>and disjunctions are <a id="_idIndexMarker1461"/>evaluated left to right and are short-circuited. This means that for a conjunction, the right constraint is evaluated only if the left one is satisfied, and for a disjunction, the right constraint is evaluated only if the left one is not satisfied.</p>
<div><p class="normal">The third category of<a id="_idIndexMarker1462"/> constraints is <em class="italic">atomic constraints</em>. These are composed of an expression <code class="inlineCode">E</code> and a mapping between the type parameters from <code class="inlineCode">E</code> and the template arguments of the constrained entity, called <em class="italic">parameter mapping</em>. The <a id="_idIndexMarker1463"/>atomic constraints are formed during <em class="italic">constraint normalization</em>, which is the process of transforming a constraint expression into a<a id="_idIndexMarker1464"/> sequence of conjunctions and disjunctions of atomic constraints. An atomic constraint is checked by substituting the parameter mapping and the template arguments into the expression <code class="inlineCode">E</code>. The result must be a valid prvalue constant expression of type <code class="inlineCode">bool</code>; otherwise, the constraint is not satisfied.</p>
</div>
<p class="normal">The standard library defines a series of concepts that can be used to define compile-time requirements on template arguments. Although most of these concepts impose both syntactic and semantic requirements, the compiler can usually ensure only the former. When the semantic requirements are not met, the program is considered ill-formed, and the compiler is not required to provide any diagnostics about the problem. The standard concepts are available in several places:</p>
<ul>
<li class="bulletList">In the concepts library, in the <code class="inlineCode">&lt;concepts&gt;</code> header and the <code class="inlineCode">std</code> namespace. This includes core language concepts (such as <code class="inlineCode">same_as</code>, <code class="inlineCode">integral</code>, <code class="inlineCode">floating_point</code>, <code class="inlineCode">copy_constructible</code>, and <code class="inlineCode">move_constructible</code>), comparison concepts (such as <code class="inlineCode">equality_comparable</code> and <code class="inlineCode">totally_ordered</code>), object concepts (such as <code class="inlineCode">copyable</code>, <code class="inlineCode">moveable</code>, and <code class="inlineCode">regular</code>), and callable concepts (such as <code class="inlineCode">invocable</code> and <code class="inlineCode">predicate</code>).</li>
<li class="bulletList">In the algorithms library, in the <code class="inlineCode">&lt;iterator&gt;</code> header and the <code class="inlineCode">std</code> namespace. This includes algorithm requirements (such as <code class="inlineCode">sortable</code>, <code class="inlineCode">permutable</code>, and <code class="inlineCode">mergeable</code>) and indirect callable concepts (such as <code class="inlineCode">indirect_unary_predicate</code> and <code class="inlineCode">indirect_binary_predicate</code>).</li>
<li class="bulletList">In the ranges library, in the <code class="inlineCode">&lt;ranges&gt;</code> header and the <code class="inlineCode">std::ranges</code> namespace. This<a id="_idIndexMarker1465"/> includes<a id="_idIndexMarker1466"/> concepts specific for ranges, such as <code class="inlineCode">range</code>, <code class="inlineCode">view</code>, <code class="inlineCode">input_range</code>, <code class="inlineCode">output_range</code>, <code class="inlineCode">forward_range</code>, and <code class="inlineCode">random_access_range</code>.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-770">There’s more...</h2>
<p class="normal">The concepts defined in this recipe used the already available type traits. However, there are many cases when requirements on template arguments cannot be described in this way. For this reason, concepts can be defined with a <em class="italic">requires expression</em>, which is a prvalue expression of type <code class="inlineCode">bool</code>, describing a template argument requirement. This will be the topic of the next recipe.</p>
<h2 class="heading-2" id="_idParaDest-771">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using requires expressions and clauses</em>, to learn about in-place constraints</li>
</ul>
<h1 class="heading-1" id="_idParaDest-772">Using requires expressions and clauses</h1>
<p class="normal">In the previous recipe, we <a id="_idIndexMarker1467"/>introduced the topic of concepts and constraints, learning about them with the help of several examples that were solely based on already existing type<a id="_idIndexMarker1468"/> traits. Moreover, we also used the terser syntax to specify concepts, with the concept name used instead of the <code class="inlineCode">typename</code> or the <code class="inlineCode">class</code> keyword in the template declaration. However, it is possible to define more complex concepts with the help of <em class="italic">requires expressions</em>. These are prvalues of the type <code class="inlineCode">bool</code> that describe the constraints on some template arguments.</p>
<p class="normal">In this recipe, we will learn how to write requires expressions and an alternative way to specify constraints on template arguments.</p>
<h2 class="heading-2" id="_idParaDest-773">Getting ready</h2>
<p class="normal">The class template <code class="inlineCode">NumericalValue&lt;T&gt;</code> and the function template <code class="inlineCode">wrap()</code> defined in the previous recipe will be used in the code snippets presented in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-774">How to do it...</h2>
<p class="normal">To specify requirements for <a id="_idIndexMarker1469"/>template arguments, you can use requires<a id="_idIndexMarker1470"/> expressions, introduced with the <code class="inlineCode">requires</code> keyword, such as the following:</p>
<ul>
<li class="bulletList">Use a simple expression that the compiler validates for correctness. In the following snippet, the operator <code class="inlineCode">+</code> must be overloaded for the <code class="inlineCode">T</code> template argument:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
concept Addable = requires (T a, T b) {a + b;};
template &lt;Addable T&gt;
T add(T a, T b)
{
  return a + b;
}
add(1, 2);        // OK, integers
add("1"s, "2"s);  // OK, std::string user-defined literals
NumericalValue&lt;int&gt; a{1};
NumericalValue&lt;int&gt; b{2};
add(a, b); // error: no matching function for call to 'add'
// 'NumericalValue&lt;int&gt;' does not satisfy 'Addable'
</code></pre>
</li>
<li class="bulletList">Use a simple expression to require the existence of a particular function. In the following snippet, a function called <code class="inlineCode">wrap()</code>, which is overloaded with a parameter of the <code class="inlineCode">T</code> template argument, must exist:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
concept Wrapable = requires(T x) { wrap(x); };
template &lt;Wrapable T&gt;
void do_wrap(T x)
{
  [[maybe_unused]] auto v = wrap(x);
}
do_wrap(42);    // OK, can wrap an int
do_wrap(42.0);  // OK, can wrap a double
do_wrap("42"s); // error, cannot wrap a std::string
</code></pre>
</li>
<li class="bulletList">Use a<a id="_idIndexMarker1471"/> type requirement, specified with the keyword <code class="inlineCode">typename</code>, followed by the name of a type, optionally qualified, to specify <a id="_idIndexMarker1472"/>requirements such as member names, class template specializations, or alias template substitutions. In the following snippet, the <code class="inlineCode">T</code> template argument must have two inner types called <code class="inlineCode">value_type</code> and <code class="inlineCode">iterator</code>. Additionally, two functions, <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code>, which take a <code class="inlineCode">T</code> argument, must be available:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
concept Container = requires(T x)
{
  typename T::value_type;
  typename T::iterator;
  begin(x);
  end(x);
};
template &lt;Container T&gt;
void pass_container(T const &amp; c)
{
  for(auto const &amp; x : c)
    std::cout &lt;&lt; x &lt;&lt; '\n';
}
std::vector&lt;int&gt; v { 1, 2, 3};
std::array&lt;int, 3&gt; a {1, 2, 3};
int arr[] {1,2,3};
pass_container(v);   // OK
pass_container(a);   // OK
pass_container(arr); // error: 'int [3]' does not satisfy
// 'Container'
</code></pre>
</li>
<li class="bulletList">Use a<a id="_idIndexMarker1473"/> compound requirement to specify the requirements of an expression, as well as the result of the evaluation of the expression. In<a id="_idIndexMarker1474"/> the following example, there must be a function called <code class="inlineCode">wrap()</code> that can be called with an argument of the <code class="inlineCode">T</code> template argument type, and the result of calling the function must be of the <code class="inlineCode">NumericalValue&lt;T&gt;</code> type:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
concept NumericalWrapable =
requires(T x)
{
  {wrap(x)} -&gt; std::same_as&lt;NumericalValue&lt;T&gt;&gt;;
};
template &lt;NumericalWrapable T&gt;
void do_wrap_numerical(T x)
{
  [[maybe_unused]] auto v = wrap(x);
}
template &lt;typename T&gt;
class any_wrapper
{
public:
  T value;
};
any_wrapper&lt;std::string&gt; wrap(std::string s)
{
  return any_wrapper&lt;std::string&gt;{s};
}
// OK, wrap(int) returns NumericalValue&lt;int&gt;
do_wrap_numerical(42);
// error, wrap(string) returns any_wrapper&lt;string&gt;
do_wrap_numerical("42"s);
</code></pre>
</li>
</ul>
<p class="normal">Constraints on the<a id="_idIndexMarker1475"/> template arguments can also be specified using a syntax, involving <a id="_idIndexMarker1476"/>the <code class="inlineCode">requires</code> keyword. These are called <em class="italic">requires clauses</em> and can be used as follows:</p>
<ul>
<li class="bulletList">Use a requires clause after the template parameter list:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt; requires Addable&lt;T&gt;
T add(T a, T b)
{
  return a + b;
}
</code></pre>
</li>
<li class="bulletList">Alternatively, use the requires clause after the last element of a function declarator:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T add(T a, T b) requires Addable&lt;T&gt;
{
  return a + b;
}
</code></pre>
</li>
<li class="bulletList">Combine a requires clause with a requires expression, instead of a named concept. In this case, the <code class="inlineCode">requires</code> keyword appears twice, as shown in the following snippet:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T add(T a, T b) requires requires (T a, T b) {a + b;}
{
  return a + b;
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-775">How it works...</h2>
<p class="normal">The new <code class="inlineCode">requires</code> keyword has multiple purposes. On one hand, it is used to introduce a requires clause that specifies constraints on template arguments. On the other hand, it is used to define a requires expression that is a prvalue of type <code class="inlineCode">bool</code> used to define constraints on template arguments.</p>
<div><p class="normal">If you are not familiar with C++ value categories (<em class="italic">lvalue</em>, <em class="italic">rvalue</em>, <em class="italic">prvalue</em>, <em class="italic">xvalue</em>, <em class="italic">glvalue</em>), you are recommended to check <a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a>. The term <em class="italic">prvalue</em>, meaning <em class="italic">pure rvalue</em>, specifies an rvalue that is not an xvalue (expiring value). Examples of prvalues are literals, function calls whose return type is not a reference type, an enumerator, or the <code class="inlineCode">this</code> pointer. </p>
</div>
<p class="normal">In a requires clause, the <code class="inlineCode">requires</code> keyword must be followed by a constant expression of the type <code class="inlineCode">bool</code>. The expression must be either a primary expression (such as <code class="inlineCode">std::is_arithmetic_v&lt;T&gt;</code> or <code class="inlineCode">std::integral&lt;T&gt;</code>), an expression in parentheses, or any sequence of such expressions joined with either the <code class="inlineCode">&amp;&amp;</code> or the <code class="inlineCode">||</code> operator.</p>
<p class="normal">A requires <a id="_idIndexMarker1477"/>expression has the form <code class="inlineCode">requires (parameters-list) { requirements }</code>. The parameters list is optional and can be entirely omitted (including the parentheses). The specified requirements may refer to:</p>
<ul>
<li class="bulletList">The template parameters that are in scope</li>
<li class="bulletList">The local parameters introduced in <code class="inlineCode">parameters-list</code></li>
<li class="bulletList">Any other declarations that are visible from the enclosing context</li>
</ul>
<p class="normal">The requirements sequence of the requires expression can contain requirements of the following types:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Simple requirements</strong>: These are<a id="_idIndexMarker1478"/> arbitrary expressions that do not start with the <code class="inlineCode">requires</code> keyword. The compiler only checks its language correctness.</li>
<li class="bulletList"><strong class="keyWord">Type requirements</strong>: These are<a id="_idIndexMarker1479"/> expressions that start with the keyword <code class="inlineCode">typename</code> followed by a type name, which must be valid. This enables the compiler to validate that a certain nested name exists, or that a class template specialization or an alias template substitution exists.</li>
<li class="bulletList"><strong class="keyWord">Compound requirements</strong>: They <a id="_idIndexMarker1480"/>have the form <code class="inlineCode">{expression} noexcept -&gt; type-constraint</code>. The <code class="inlineCode">noexcept</code> keyword is optional, in which case the expression must not be potentially throwing. The requirement for the return type, introduced with <code class="inlineCode">-&gt;</code>, is also optional. However, if it is present, then <code class="inlineCode">decltype(expression)</code> must satisfy the constraints imposed by <code class="inlineCode">type-constraint</code>.</li>
<li class="bulletList"><strong class="keyWord">Nested requirements</strong>: These are more complex expressions that specify constraints defined as a requires expression, which can, in turn, be another nested requirement. A<a id="_idIndexMarker1481"/> requirement that starts with the keyword <code class="inlineCode">requires</code> is considered a nested requirement.</li>
</ul>
<p class="normal">Before they are evaluated, the body of every name concept and every <code class="inlineCode">requires</code> expression is substituted until a sequence of conjunctions and disjunctions of atomic constraints is obtained. This process is <a id="_idIndexMarker1482"/>called <em class="italic">normalization</em>. The actual details of normalization and the analysis the compiler performs are beyond the scope of this book.</p>
<h2 class="heading-2" id="_idParaDest-776">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Specifying requirements on template arguments with concepts</em>, to explore the fundamentals of C++20 concepts</li>
</ul>
<h1 class="heading-1" id="_idParaDest-777">Exploring abbreviated function templates</h1>
<p class="normal">In <em class="chapterRef">Chapter 3</em>, we learned about function templates as well as lambda expressions, including generic and template lambdas. A generic lambda is a lambda expression that uses <code class="inlineCode">auto</code> specified for one of its parameters. The result is a function object with a templated call operator. The same is produced as a result of defining a lambda template that has the advantage, over generic lambdas, of allowing better control over the types of the parameters. In C++20, this idea of using the <code class="inlineCode">auto</code> specifier for parameter types is generalized for all functions. </p>
<p class="normal">This introduces a simplified syntax of defining function templates, and functions that are defined in this<a id="_idIndexMarker1483"/> way are called <strong class="keyWord">abbreviated function templates</strong>. We will see in this recipe how to use them.</p>
<h2 class="heading-2" id="_idParaDest-778">How to do it…</h2>
<p class="normal">You can define the following categories of abbreviated function templates in C++20:</p>
<ul>
<li class="bulletList">Unconstrained abbreviated function templates<a id="_idIndexMarker1484"/> that use the <code class="inlineCode">auto</code> specifier to define parameters:
        <pre class="programlisting code"><code class="hljs-code">auto sum(auto a, auto b)
{
   return a + b;
}
auto a = sum(40, 2);    // 42
auto b = sum(42.0, 2);  // 44.0
</code></pre>
</li>
<li class="bulletList">Constrained abbreviated function templates<a id="_idIndexMarker1485"/> that use concepts, specified before the <code class="inlineCode">auto</code> specifier, to constrain the parameters of the function template:
        <pre class="programlisting code"><code class="hljs-code">auto sum(std::integral auto a, std::integral auto b)
{
   return a + b;
}
auto a = sum(40, 2);    // 42
auto b = sum(42.0, 2);  // error
</code></pre>
</li>
<li class="bulletList">Constrained variadic abbreviated function templates<a id="_idIndexMarker1486"/> that use the syntax seen above but with a parameter pack:
        <pre class="programlisting code"><code class="hljs-code">auto sum(std::integral auto ... args)
{
   return (args + ...);
}
auto a = sum(10, 30, 2);   // 42
</code></pre>
</li>
<li class="bulletList">Constrained abbreviated <a id="_idIndexMarker1487"/>lambda expressions<a id="_idIndexMarker1488"/> that use the syntax seen above but with a lambda expression:
        <pre class="programlisting code"><code class="hljs-code">int main()
{
   auto lsum = [](std::integral auto a, std::integral auto b)
   {
      return a + b;
   };
   auto a = lsum(40, 2);    // 42
auto b = lsum(42.0, 2);  // error
}
</code></pre>
</li>
<li class="bulletList">Specializations of abbreviated function templates can be defined just as for function templates defined with the regular template syntax:
        <pre class="programlisting code"><code class="hljs-code">auto sum(auto a, auto b)
{
   return a + b;
}
template &lt;&gt;
auto sum(char const* a, char const* b)
{
   return std::string(a) + std::string(b);
}
auto a = sum(40, 2);       // 42
auto b = sum("40", "2");   // "402"
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-779">How it works…</h2>
<p class="normal">The template <a id="_idIndexMarker1489"/>syntax is considered by many rather cumbersome. Abbreviated function templates are meant to simplify writing some categories of function templates. They do so by using the <code class="inlineCode">auto</code> specifier as a placeholder for parameter types, instead of the typical template syntax. The following two definitions are equivalent:</p>
<pre class="programlisting code"><code class="hljs-code">auto sum(auto a, auto b)
{
   return a + b;
}
template &lt;typename T, typename U&gt;
auto sum(T a, U b)
{
   return a + b;
}
</code></pre>
<p class="normal">If the intention is to define a function template with both arguments of the same type, then this form of the abbreviated function template is not enough. These abbreviated function templates are<a id="_idIndexMarker1490"/> called <strong class="keyWord">unconstrained</strong> because there are no constraints placed on the arguments of the function. </p>
<p class="normal">Such constraints can be defined with the help of concepts, as shown below:</p>
<pre class="programlisting code"><code class="hljs-code">auto sum(std::integral auto a, std::integral auto b)
{
   return a + b;
}
</code></pre>
<p class="normal">The category of abbreviated function <a id="_idIndexMarker1491"/>templates is called <strong class="keyWord">constrained</strong>. The function above is equivalent to the following regular function template:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T sum(T a, T b);
template&lt;&gt;
int sum(int a, int b)
{
   return a + b;
}
</code></pre>
<p class="normal">Since an abbreviated function template is a function template, it can also be specialized like any function declared with the standard template syntax:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;&gt;
auto sum(char const* a, char const* b)
{
   return std::string(a) + std::string(b);
}
</code></pre>
<p class="normal">Constrained <a id="_idIndexMarker1492"/>abbreviated function templates can also be variadic; that is, they have a variable number of arguments. There is nothing special about them, other than what we already learned in <em class="chapterRef">Chapter 5</em>. Moreover, the syntax can also be used to define lambda templates. Examples of these were given in the previous section.</p>
<h2 class="heading-2" id="_idParaDest-780">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Using generic lambdas</em>, to learn about the use of both generic lambdas and lambda templates</li>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Writing function templates</em> to explore the syntax for writing function templates</li>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Writing a function template with a variable number of arguments</em>, to see how you can write functions that take a variable number of arguments</li>
<li class="bulletList"><em class="italic">Specifying requirements on template arguments with concepts</em>, to learn how to constrain the arguments with a function template, with the help of concepts</li>
</ul>
<h1 class="heading-1" id="_idParaDest-781">Iterating over collections with the ranges library</h1>
<p class="normal">The C++ standard library<a id="_idIndexMarker1493"/> provides three important pillars—containers, iterators, and algorithms—that enable us to work with collections. Because these algorithms are for general purposes and are designed to work with iterators, which define a range, they often require writing explicit and sometimes complex code to achieve simple tasks. The C++20 ranges library has been designed to solve this problem by providing components for handling ranges of elements. These components include range adapters (or views) and constrained algorithms that work with a range instead of iterators. In this recipe, we will look at some of these views and algorithms and see how they can simplify coding.</p>
<h2 class="heading-2" id="_idParaDest-782">Getting ready</h2>
<p class="normal">In the following snippets, we will refer to a function called <code class="inlineCode">is_prime()</code>, which takes an integer and returns a Boolean, indicating whether the number is prime or not. A simple implementation is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">bool is_prime(int const number)
{
  if (number != 2)
  {
    if (number &lt; 2 || number % 2 == 0) return false;
    auto root = std::sqrt(number);
    for (int i = 3; i &lt;= root; i += 2)
      if (number % i == 0) return false;
  }
  return true;
}
</code></pre>
<div><p class="normal">For an efficient algorithm, which is beyond the scope of this recipe, I recommend the Miller–Rabin primality test.</p>
</div>
<p class="normal">The ranges library is available in the new <code class="inlineCode">&lt;ranges&gt;</code> header, in the <code class="inlineCode">std::ranges</code> namespace. For simplicity, the following namespace aliases will be used in this recipe:</p>
<pre class="programlisting code"><code class="hljs-code">namespace rv = std::ranges::views;
namespace rg = std::ranges;
</code></pre>
<p class="normal">We will explore various uses of the ranges library in the next section.</p>
<h2 class="heading-2" id="_idParaDest-783">How to do it...</h2>
<p class="normal">The ranges library<a id="_idIndexMarker1494"/> can be used to iterate through ranges with operations such as the following:</p>
<ul>
<li class="bulletList">Generate a sequence of consecutive integers with the <code class="inlineCode">iota_view</code> / <code class="inlineCode">views::iota</code> view. The following snippet prints all integers from 1 to 9:
        <pre class="programlisting code"><code class="hljs-code">for (auto i : rv::iota(1, 10))
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
</li>
<li class="bulletList">Filter the elements of a range with <code class="inlineCode">filter_view</code> / <code class="inlineCode">views::filter</code>, by retaining only those that satisfy a predicate. The first snippet here prints all the prime numbers from 1 to 99. However, the second snippet retains and prints all the prime numbers from a vector of integers:
        <pre class="programlisting code"><code class="hljs-code">// prints 2 3 5 7 11 13 ... 79 83 89 97
for (auto i : rv::iota(1, 100) | rv::filter(is_prime))
  std::cout &lt;&lt; i &lt;&lt; ' ';
// prints 2 3 5 13
std::vector&lt;int&gt; nums{ 1, 1, 2, 3, 5, 8, 13, 21 };
for (auto i : nums | rv::filter(is_prime))
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
</li>
<li class="bulletList">Transform the elements of a range with <code class="inlineCode">transform_view</code> / <code class="inlineCode">views::transform</code> by applying a unary function to each element. The following snippet prints the successor of all the prime numbers from 1 to 99:
        <pre class="programlisting code"><code class="hljs-code">// prints 3 4 6 8 12 14 ... 80 84 90 98
for (auto i : rv::iota(1, 100) |
              rv::filter(is_prime) |
              rv::transform([](int const n) {return n + 1; }))
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
</li>
<li class="bulletList">Retain only the first <em class="italic">N</em> elements of a view with <code class="inlineCode">take_view</code> / <code class="inlineCode">views::take</code>. The following snippet prints only the first 10 prime numbers from 1 and 99:
        <pre class="programlisting code"><code class="hljs-code">// prints 2 3 5 7 11 13 17 19 23 29
for (auto i : rv::iota(1, 100) |
              rv::filter(is_prime) |
              rv::take(10))
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
</li>
<li class="bulletList">Iterate <a id="_idIndexMarker1495"/>a range in reverse order with <code class="inlineCode">reverse_view</code> / <code class="inlineCode">views::reverse</code>. The first snippet here prints the first 10 prime numbers from 99 to 1 (in descending order), while the second snippet prints the last 10 prime numbers from 1 to 99 (in ascending order):
        <pre class="programlisting code"><code class="hljs-code">// prints 97 89 83 79 73 71 67 61 59 53
for (auto i : rv::iota(1, 100) |
              rv::reverse |
              rv::filter(is_prime) |
              rv::take(10))
  std::cout &lt;&lt; i &lt;&lt; ' ';
// prints 53 59 61 67 71 73 79 83 89 97
for (auto i : rv::iota(1, 100) |
              rv::reverse |
              rv::filter(is_prime) |
              rv::take(10) |
              rv::reverse)
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
</li>
<li class="bulletList">Skip the first <em class="italic">N</em> elements of a range with <code class="inlineCode">drop_view</code> / <code class="inlineCode">views::drop</code>. The snippet here prints, in ascending order, the prime numbers between 1 and 99, but it skips the first and last 10 primes in the sequence:
        <pre class="programlisting code"><code class="hljs-code">// prints 31 37 41 43 47
for (auto i : rv::iota(1, 100) |
              rv::filter(is_prime) |
              rv::drop(10) |
              rv::reverse |
              rv::drop(10) |
              rv::reverse)
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
</li>
</ul>
<p class="normal">The ranges library can also be used to call algorithms using a range instead of iterators. Most algorithms have overloads for this purpose. Examples are shown here:</p>
<ul>
<li class="bulletList">Determine the maximum element of a range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 5, 2, 7, 1, 4, 2, 9, 5 };
auto m = rg::max(v); // 5
</code></pre>
</li>
<li class="bulletList">Sort a range:
        <pre class="programlisting code"><code class="hljs-code">rg::sort(v); // 1 2 2 4 5 5 7 9
</code></pre>
</li>
<li class="bulletList">Copy a range. The following snippet copies the elements of the range to the standard output stream:
        <pre class="programlisting code"><code class="hljs-code">rg::copy(v, std::ostream_iterator&lt;int&gt;(std::cout, " "));
</code></pre>
</li>
<li class="bulletList">Reverse the elements of a range:
        <pre class="programlisting code"><code class="hljs-code">rg::reverse(v);
</code></pre>
</li>
<li class="bulletList">Count the elements of a range (that verify a predicate):
        <pre class="programlisting code"><code class="hljs-code">auto primes = rg::count_if(v, is_prime);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-784">How it works...</h2>
<p class="normal">The C++20 ranges library<a id="_idIndexMarker1496"/> provides various components for dealing with ranges of elements. These include:</p>
<ul>
<li class="bulletList">Range concepts, such as <code class="inlineCode">range</code> and <code class="inlineCode">view</code>.</li>
<li class="bulletList">Range access functions, such as <code class="inlineCode">begin()</code>, <code class="inlineCode">end()</code>, <code class="inlineCode">size()</code>, <code class="inlineCode">empty()</code>, and <code class="inlineCode">data()</code>.</li>
<li class="bulletList">Range factories that create sequences of elements, such as <code class="inlineCode">empty_view</code>, <code class="inlineCode">single_view</code>, and <code class="inlineCode">iota_view</code>.</li>
<li class="bulletList">Range adaptors, or views, that create a lazy evaluated view from a range, such as <code class="inlineCode">filter_view</code>, <code class="inlineCode">transform_view</code>, <code class="inlineCode">take_view</code>, and <code class="inlineCode">drop_view</code>.</li>
</ul>
<p class="normal">A range is <a id="_idIndexMarker1497"/>defined as a sequence of elements that can be iterated over with an iterator and an end sentinel. Ranges are of different types, depending on the capabilities of the iterators that define the range. The following concepts define types of ranges:</p>
<table class="table-container" id="table001-8">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Concept</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Iterator type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Capabilities</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">input_range</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">input_iterator</code></p>
</td>
<td class="table-cell">
<p class="normal">Can be iterated at least once for reading.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">output_range</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">output_iterator</code></p>
</td>
<td class="table-cell">
<p class="normal">Can be iterated For writing.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">forward_range</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">forward_iterator</code></p>
</td>
<td class="table-cell">
<p class="normal">Can be iterated multiple times.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bidirectional_range</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">bidirectional_iterator</code></p>
</td>
<td class="table-cell">
<p class="normal">Can be iterated also in reverse order.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">random_access_range</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">random_access_iterator</code></p>
</td>
<td class="table-cell">
<p class="normal">Elements can be accessed randomly in constant time.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">contiguous_range</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">contiguous_iterator</code></p>
</td>
<td class="table-cell">
<p class="normal">Elements are stored contiguously in memory.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 12.1: The list of concepts that define the types of ranges</p>
<p class="normal">Because a <code class="inlineCode">forward_iterator</code> satisfies the requirements of an <code class="inlineCode">input_iterator</code>, and a <code class="inlineCode">bidirectional_iterator</code> satisfies those of a <code class="inlineCode">forward_iterator</code>, and so on (from top to bottom in the preceding table), so do the ranges. A <code class="inlineCode">forward_range</code> satisfies the requirements of an <code class="inlineCode">input_range</code>, and a <code class="inlineCode">bidirectional_range</code> satisfies those of a <code class="inlineCode">forward_range</code>, and so on. Apart from the range concepts listed in the preceding table, there are other range concepts. One worth mentioning is <code class="inlineCode">sized_range</code>, which requires that a range must know its size in constant time.</p>
<p class="normal">The standard containers meet the requirements of different range concepts. The most important of them are listed in the following table:</p>
<table class="table-container" id="table002-7">
<tbody>
<tr>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Input range</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Forward range</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Bidirectional range</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Random access range</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Contiguous range</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">forward_list</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">list</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">dequeue</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">array</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">vector</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">set</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">map</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">multiset</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">multimap</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unordered_set</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unordered_map</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unordered_multiset</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unordered_multimap</code></p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell">
<p class="normal">✓</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 12.2: A list of standard containers and the requirements they meet</p>
<p class="normal">A<a id="_idIndexMarker1498"/> central concept of the ranges library is the range <em class="italic">adaptor</em>, also called a <em class="italic">view</em>. A view is a non-owning wrapper of a range of elements that requires constant time to copy, move, or assign elements. Views are composable adaptations of ranges. However, these adaptations happen lazily, only when the view is iterated.</p>
<p class="normal">In the previous section, we saw examples of using various views: filter, transform, take, drop, and reverse. There are a total of 16 views available in the library. All the views are available in the namespace <code class="inlineCode">std::ranges</code> and have names such as <code class="inlineCode">filter_view</code>, <code class="inlineCode">transform_view</code>, <code class="inlineCode">take_view</code>, <code class="inlineCode">drop_view</code>, and <code class="inlineCode">reverse_view</code>. However, for simplicity of use, these views can be used with expressions of the form <code class="inlineCode">views::filter</code>, <code class="inlineCode">views::take</code>, <code class="inlineCode">views::reverse</code>, and so on. Notice that the types and values of these expressions are unspecified and are a compiler implementation detail.</p>
<p class="normal">To understand how the views work, let’s take a look at the following example:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; nums{ 1, 1, 2, 3, 5, 8, 13, 21 };
auto v = nums | rv::filter(is_prime) | rv::take(3) | rv::reverse;
for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; // prints 5 3 2
</code>
for</code> statement. The views are said to be lazy. The pipe operator (<code class="inlineCode">|</code>) is overloaded to simplify the composition of views.</pre>
<p class="normal">The composition of views is equivalent to the following:</p>
<pre class="programlisting code"><code class="hljs-code">auto v = rv::reverse(rv::take(rv::filter(nums, is_prime), 3));
</code></pre>
<p class="normal">In general, the following rules apply:</p>
<ul>
<li class="bulletList">If an adaptor <code class="inlineCode">A</code> takes only one argument, a range <code class="inlineCode">R</code>, then <code class="inlineCode">A(R)</code> and <code class="inlineCode">R|A</code> are equivalent.</li>
<li class="bulletList">If an adaptor <code class="inlineCode">A</code> takes multiple arguments, a range <code class="inlineCode">R</code> and <code class="inlineCode">args...</code>, then the following three are equivalent: <code class="inlineCode">A(R, args...)</code>, <code class="inlineCode">A(args...)(R)</code>, and <code class="inlineCode">R|A(args...)</code>.</li>
</ul>
<p class="normal">Apart from ranges and range adaptors (or views), overloads of the general-purpose algorithms are also available in C++20, in the same <code class="inlineCode">std::ranges</code> namespace. These overloads are<a id="_idIndexMarker1499"/> called <em class="italic">constrained algorithms</em>. A range can be provided either as a single argument (as seen in the examples in this recipe) or as an iterator-sentinel pair. Also, for these overloads, the <a id="_idIndexMarker1500"/>return type has been changed to provide additional information that’s computed during the execution of the algorithm.</p>
<h2 class="heading-2" id="_idParaDest-785">There’s more...</h2>
<p class="normal">The standard ranges library has been designed based<a id="_idIndexMarker1501"/> on the <strong class="keyWord">range-v3</strong> library, created by Eric Niebler and available on GitHub at <a href="https://github.com/ericniebler/range-v3">https://github.com/ericniebler/range-v3</a>. This<a id="_idIndexMarker1502"/> library provides a larger set of range adaptors (views), as well as actions that provide mutating operations (such as sorting, erasing, shuffling, and so on). The transition from the range-v3 library to the C++20 ranges library can be very smooth. In fact, all the samples provided in this recipe work with both libraries. All you have to do is include the appropriate header files and use the range-v3-specific namespaces:</p>
<pre class="programlisting code"><code class="hljs-code">#include "range/v3/view.hpp"
#include "range/v3/algorithm/sort.hpp"
#include "range/v3/algorithm/copy.hpp"
#include "range/v3/algorithm/reverse.hpp"
#include "range/v3/algorithm/count_if.hpp"
#include "range/v3/algorithm/max.hpp"
namespace rv = ranges::views;
namespace rg = ranges;
</code></pre>
<p class="normal">With these replacements, all the snippets from the <em class="italic">How to do it...</em> section will continue to work using a C++17-compliant compiler.</p>
<h2 class="heading-2" id="_idParaDest-786">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating your own range view</em>, to see how to extend the ranges library’s capabilities with user-defined range adaptors</li>
<li class="bulletList"><em class="italic">Specifying requirements on template arguments with concepts</em>, to explore the fundamentals of C++20 concepts</li>
</ul>
<h1 class="heading-1" id="_idParaDest-787">Exploring the standard range adaptors</h1>
<p class="normal">In the previous recipe, we <a id="_idIndexMarker1503"/>looked at how the ranges library helps us simplify various tasks when working with collections (ranges), such as enumerating, filtering, transforming, and reversing. We did so with the help of range adaptors. However, we have only looked at a small set of adaptors. There are more available in the standard library, some included in C++20 and others in C++23. In this recipe, we will explore all the adapters in the standard library.</p>
<h2 class="heading-2" id="_idParaDest-788">Getting ready</h2>
<p class="normal">In the snippets shown in this recipe, we will use the following namespace aliases:</p>
<pre class="programlisting code"><code class="hljs-code">namespace rv = std::ranges::views;
namespace rg = std::ranges;
</code></pre>
<p class="normal">Also, to compile the snippets below, you need to include the <code class="inlineCode">&lt;ranges&gt;</code> and <code class="inlineCode">&lt;algorithm&gt;</code> headers (for the ranges library).</p>
<h2 class="heading-2" id="_idParaDest-789">How to do it…</h2>
<p class="normal">In C++20, the following<a id="_idIndexMarker1504"/> adaptors are available to use:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ranges::filter_view</code> / <code class="inlineCode">views::filter</code> represents a view of the underlying sequence but without the elements that do not satisfy a specified predicate:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto primes = numbers | rv::filter(is_prime);
rg::copy(primes, std::ostream_iterator&lt;int&gt;{ std::cout, " " }); 
</code></pre>
<pre class="programlisting con"><code class="hljs-con">2 3 5 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::transform_view</code> / <code class="inlineCode">views::transform</code> represents a view of the underlying sequence after applying a specified function to each element of the range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto letters = numbers | 
               rv::transform([](int i) { 
                  return static_cast&lt;char&gt;('A' + i); });
rg::copy(letters, std::ostream_iterator&lt;char&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">B B C D F I N
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::take_view</code> / <code class="inlineCode">views::take</code> represents a view of the underlying sequence, starting at the beginning and containing the specified number of elements:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto some_numbers = numbers | rv::take(3);
rg::copy(some_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::take_while_view</code> / <code class="inlineCode">views::take_while</code> represents a view of the underlying sequence, starting at the beginning and containing all the consecutive elements that satisfy a given predicate:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto some_numbers = numbers | 
                    rv::take_while([](int i) { 
                       return i &lt; 3; });});
rg::copy(some_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::drop_view</code> / <code class="inlineCode">views::drop</code> represents a view of the underlying sequence after skipping the specified number of elements:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto some_numbers = numbers | rv::drop(3);
rg::copy(some_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">3 5 8 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::drop_while_view</code> / <code class="inlineCode">views::drop_while</code> represents a view of the underlying sequence after skipping all the consecutive elements (from the beginning) that <a id="_idIndexMarker1505"/>satisfy a given predicate:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto some_numbers = numbers | 
                    rv::drop_while([](int i) { 
                       return i &lt; 3; });
rg::copy(some_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">3 5 8 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::join_view</code> / <code class="inlineCode">views::join</code> flattens a view of ranges; it represents a view consisting of all the elements of a sequence of sequences:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::vector&lt;int&gt;&gt; numbers{ {1, 1}, {2, 3}, {5, 8}, {13} };
auto joined_numbers = numbers | rv::join;
rg::copy(joined_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2 3 5 8 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::split_view</code> / <code class="inlineCode">views::split</code> represents a view of subranges obtained by splitting a view with a specified delimiter. The delimiter is not part of the resulting subranges:
        <pre class="programlisting code"><code class="hljs-code">std::string text{ "Hello, world!" };
auto words = text | rv::split(' ');
for (auto const word : words)
{
   std::cout &lt;&lt; std::quoted(std::string_view(word)) &lt;&lt; ' ';
}
</code></pre>
<pre class="programlisting con"><code class="hljs-con">"Hello," "world!"
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::lazy_split_view</code> / <code class="inlineCode">views::lazy_split</code> is similar to <code class="inlineCode">split</code>, except that it works in a <em class="italic">lazy mode</em>, meaning that it does not look ahead for the next delimiter until we iterate for the next element of the result. It works with constant <a id="_idIndexMarker1506"/>ranges, which are not supported by <code class="inlineCode">split_view</code>:
        <pre class="programlisting code"><code class="hljs-code">std::string text{ "Hello, world!" };
auto words = text | rv::lazy_split(' ');
for (auto const word : words)
{
   std::cout &lt;&lt; 
      std::quoted(std::ranges::to&lt;std::string&gt;(word)) &lt;&lt; ' ';
}
</code></pre>
<pre class="programlisting con"><code class="hljs-con">"Hello," "world!"
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::reverse_view</code> / <code class="inlineCode">views::reverse</code> represents a view of an underlying sequence with the elements presented in the reverse order:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto reversed_numbers = numbers | rv::reverse;
rg::copy(reversed_numbers, 
         std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">13 8 5 3 2 1 1
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::elements_view</code> / <code class="inlineCode">views::elements</code> represents a view of the <em class="italic">N</em>th element of an underlying sequence of tuple-like values:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::tuple&lt;int, std::string_view&gt;&gt; numbers{
   {1, "one"},
   {1, "one"},
   {2, "two"},
   {3, "three"},
   {5, "five"},
   {8, "eight"},
   {13, "thirteen"} };
auto some_numbers = numbers | rv::elements&lt;0&gt;;
rg::copy(some_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2 3 5 8 13
</code></pre>
<pre class="programlisting code"><code class="hljs-code">auto some_names = numbers | rv::elements&lt;1&gt;;
rg::copy(some_names, 
         std::ostream_iterator&lt;std::string_view&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">one one two three five eight thirteen
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::keys_view</code> / <code class="inlineCode">views::keys</code> represent <a id="_idIndexMarker1507"/>an alias for <code class="inlineCode">ranges::elements_view&lt;R, 0&gt;</code> and, respectively, an object of type <code class="inlineCode">views::elements&lt;0&gt;</code>.</li>
</ul>
<p class="normal"><code class="inlineCode">ranges::values_view</code> / <code class="inlineCode">views::values</code> represent an alias for <code class="inlineCode">ranges::elements_view&lt;R, 1&gt;</code> and, respectively, an object of type <code class="inlineCode">views::elements&lt;1&gt;</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::pair&lt;int, std::string_view&gt;&gt; numbers{
   {1, "one"},
   {1, "one"},
   {2, "two"},
   {3, "three"},
   {5, "five"},
   {8, "eight"},
   {13, "thirteen"} };
auto some_numbers = numbers | rv::keys;
rg::copy(some_numbers, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2 3 5 8 13
</code></pre>
<pre class="programlisting code"><code class="hljs-code">auto some_names = numbers | rv::values;
rg::copy(some_names, 
         std::ostream_iterator&lt;std::string_view&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">one one two three five eight thirteen
</code></pre>
<p class="normal">In C++23, the following<a id="_idIndexMarker1508"/> adaptors were added to the standard library:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ranges::enumerate_view</code> / <code class="inlineCode">views::enumerate</code> represents a view of tuples, with the first element being the zero-based index of the element of the underlying sequence, and the second element being a reference to the underlying element:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::string&gt; words{ "one", "two", "three", 
                                "four", "five" };
auto enumerated_words = words | rv::enumerate;
for (auto const [index, word] : enumerated_words)
{
   std::println("{} : {}", index, word);
}
</code></pre>
<pre class="programlisting con"><code class="hljs-con">0 : one
1 : two
2 : three
3 : four
4 : five
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::zip_view</code> / <code class="inlineCode">views::zip</code> represents a view of tuples created from two or more underlying<a id="_idIndexMarker1509"/> views, with the <em class="italic">N</em>th tuple created from the <em class="italic">N</em>th element of each underlying view:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
std::vector&lt;std::string&gt; words{ "one", "two", "three", 
                                "four", "five" };
auto zipped = rv::zip(numbers, words);
for (auto const [number, word] : zipped)
{
   std::println("{} : {}", number, word);
}
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 : one
1 : two
2 : three
3 : four
5 : five
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::zip_transform_view</code> / <code class="inlineCode">views::</code> <code class="inlineCode">zip_transform</code> represents a view of elements produced by applying a given function to two or more views. The <em class="italic">N</em>th element of the result view is produced from the <em class="italic">N</em>th element of all the specified underlying views:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
std::vector&lt;std::string&gt; words{ "one", "two", "three", 
                                "four", "five" };
auto zipped = rv::zip_transform(
   [](int number, std::string word) {
      return std::to_string(number) + " : " + word;
   },
   numbers, 
   words);
std::ranges::for_each(zipped, 
                      [](auto e) {std::println("{}", e); });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 : one
1 : two
2 : three
3 : four
5 : five
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::adjacent_view</code> / <code class="inlineCode">views::adjacent</code> represents a view of tuples of <em class="italic">N</em> elements from an underlying view; each tuple is a window in the underlying view, the <em class="italic">i</em>th tuple containing the elements with the indexes in the range <code class="inlineCode">[i, i + N - 1]</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto adjacent_numbers = numbers | rv::adjacent&lt;3&gt;;
std::ranges::for_each(
   adjacent_numbers, 
   [](auto t) {
      auto [a, b, c] = t;
      std::println("{},{},{}", a, b, c); 
   });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1,1,2
1,2,3
2,3,5
3,5,8
5,8,13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::adjacent_transform_view</code> / <code class="inlineCode">views::adjacent_transform</code> represents a view of elements produced by applying a specified function to <em class="italic">N</em>-adjacent elements of an underlying view; the <em class="italic">i</em>th element of the resulting view is produced<a id="_idIndexMarker1510"/> by applying the function to the elements of the underlying range with the indexes in the range <code class="inlineCode">[i, i + N - 1]</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto adjacent_numbers = 
   numbers | 
   rv::adjacent_transform&lt;3&gt;(
      [](int a, int b, int c) {return a * b * c; });
std::ranges::for_each(adjacent_numbers, 
                      [](auto e) {std::print("{} ", e); });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">2 6 30 120 520
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::join_with_view</code> / <code class="inlineCode">views::join_with</code> is similar to <code class="inlineCode">join_view</code> because it flattens a view of ranges to a single view; however, it takes a delimiter that it inserts between the elements of the underlying ranges:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::vector&lt;int&gt;&gt; numbers{ {1, 1, 2}, {3, 5, 8}, 
                                       {13} };
auto joined_numbers = numbers | rv::join_with(0);
rg::copy(joined_numbers, 
         std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2 0 3 5 8 0 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::slide_view</code> / <code class="inlineCode">views::slide</code> is a range adaptor similar to <code class="inlineCode">ranges::adjacent_view</code> / <code class="inlineCode">views::adjacent</code>, except that the size of the windows from the underlying sequence is specified at runtime:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto slide_numbers = numbers | rv::slide(3);
std::ranges::for_each(
   slide_numbers,
   [](auto r) {
      rg::copy(r, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
      std::println("");
   });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2
1 2 3
2 3 5
3 5 8
5 8 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::chunk_view</code> / <code class="inlineCode">views::chunk</code> represents a view of sub-views of <em class="italic">N</em> elements of the <a id="_idIndexMarker1511"/>underlying view. The last chunk may have fewer than <em class="italic">N</em> elements (if the size of the underlying view is not a multiple of <em class="italic">N</em>):
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto chunk_numbers = numbers | rv::chunk(3);
std::ranges::for_each(
   chunk_numbers,
   [](auto r) {
      rg::copy(r, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
      std::println("");
   });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1 2
3 5 8
13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::chunk_by_view</code> / <code class="inlineCode">views::chunk_by</code> represents a view of sub-views of an underlying view, produced by splitting the underlying view each time a supplied <a id="_idIndexMarker1512"/>binary predicate applied to two adjacent elements returns <code class="inlineCode">false</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto chunk_numbers = 
   numbers | 
   rv::chunk_by([](int a, int b) {return a * b % 2 == 1; });
std::ranges::for_each(
   chunk_numbers,
   [](auto r) {
      rg::copy(r, std::ostream_iterator&lt;int&gt;{ std::cout, " " });
      std::println("");
   });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 1
2
3 5
8
13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::stride_view</code> / <code class="inlineCode">views::stride</code> is a view of some elements from an underlying view, starting with the first and advancing over <em class="italic">N</em> elements each time:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
auto stride_numbers = numbers | rv::stride(3);
rg::copy(stride_numbers, 
         std::ostream_iterator&lt;int&gt;{ std::cout, " " });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 3 13
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">ranges::cartesian_product_view</code> / <code class="inlineCode">views::cartesian_product</code> represents a view of <a id="_idIndexMarker1513"/>tuples computed as the cartesian product of 1 or more underlying views:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 2 };
std::vector&lt;std::string&gt; words{ "one", "two", "three" };
auto product = rv::cartesian_product(numbers, words);
rg::for_each(
   product,
   [](auto t) {
      auto [number, word] = t;
      std::println("{} : {}", number, word);
   });
</code></pre>
<pre class="programlisting con"><code class="hljs-con">1 : one
1 : two
1 : three
2 : one
2 : two
2 : three
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-790">How it works…</h2>
<p class="normal">We saw how range adaptors work in the previous recipe. In this section, we will only look at some of the details and differences between some adaptors that you should be aware of.</p>
<p class="normal">To start, let’s consider <code class="inlineCode">adjacent_view</code> and <code class="inlineCode">slide_view</code>. They are similar in the sense that they take one view and produce another view of sub-views of this underlying view. These sub-views are referred to as <em class="italic">windows</em> and have a specified size, <em class="italic">N</em>. </p>
<p class="normal">The first window starts from the first element, the second from the second element, etc. However, they differ in two significant ways:</p>
<ul>
<li class="bulletList">The size <em class="italic">N</em> of the windows is specified at compile time for <code class="inlineCode">adjacent_view</code> and at runtime for <code class="inlineCode">slide_view</code>.</li>
<li class="bulletList">The elements of the view represented by <code class="inlineCode">adjacent_view</code> are tuples, while the elements of the view represented by <code class="inlineCode">slide_view</code> are other views.</li>
</ul>
<p class="normal">The following diagram presents a<a id="_idIndexMarker1514"/> comparison of these two adaptors:</p>
<figure class="mediaobject"><img alt="" src="img/B21549_12_02.png"/></figure>
<p class="packt_figref">Figure 12.2: Comparison of adjacent_view&lt;3&gt;(R) and slide_view(R, 3)</p>
<p class="normal">When the size of the windows is 2, you can use <code class="inlineCode">views::pairwise</code> and <code class="inlineCode">views::pairwise_transform</code>, which are objects of type <code class="inlineCode">adjacent&lt;2&gt;</code> and <code class="inlineCode">adjacent_transform&lt;2&gt;</code>, respectively.</p>
<p class="normal">The next pair of adaptors to look at are <code class="inlineCode">split_view</code> and <code class="inlineCode">lazy_split_view</code>. They both do the same thing: split a view into subranges based on a given delimiter, which can be either a single element or a view of elements. Neither of the two adaptors include the delimiter in the resulting subranges. These two, however, differ in a key aspect: the <code class="inlineCode">lazy_split_view</code> adaptor is, as the name implies, <em class="italic">lazy</em>, meaning that it does not look ahead to the next delimiter until we iterate for the next element of the result, which <code class="inlineCode">split_view</code> does. Moreover, <code class="inlineCode">split_view</code> supports ranges of the <code class="inlineCode">forward_range</code> type or higher but cannot split a constant range, while <code class="inlineCode">lazy_split_view</code> supports ranges of the <code class="inlineCode">input_range</code> type or higher and can split a constant range.</p>
<p class="normal">The question that arises is which one to use and when? Typically, you should prefer <code class="inlineCode">split_view</code> because it is more efficient than <code class="inlineCode">lazy_split_view</code> (which has a less efficient iterator incrementation and comparison). However, if you need to split a constant range, then <code class="inlineCode">split_view</code> is not an option, and you should use <code class="inlineCode">lazy_split_view</code>.</p>
<p class="normal">There are two adaptors, <code class="inlineCode">join_view</code> (in C++20) and <code class="inlineCode">join_with_view</code> (in C++23), that perform a join operation, transforming a range of ranges into a single (flattened) range. The difference between them is that the latter, <code class="inlineCode">join_with_view</code>, takes a delimiter that is inserted in the result <a id="_idIndexMarker1515"/>between the elements of two consecutive underlying ranges.</p>
<p class="normal">For more details about the <a id="_idIndexMarker1516"/>standard range adaptors, you can consult the online documentation available at <a href="https://en.cppreference.com/w/cpp/ranges">https://en.cppreference.com/w/cpp/ranges</a>.</p>
<h2 class="heading-2" id="_idParaDest-791">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Iterating over collections with the ranges library</em>, to learn about the fundamentals of the C++ ranges library</li>
<li class="bulletList"><em class="italic">Using constrained algorithms</em>, to learn about the standard generic algorithms that work with ranges</li>
</ul>
<h1 class="heading-1" id="_idParaDest-792">Converting a range to a container</h1>
<p class="normal">The result of <a id="_idIndexMarker1517"/>applying various range adapters to a range (such as a container) is a <a id="_idIndexMarker1518"/>complex type that is difficult to type or remember. Typically, we’d use the <code class="inlineCode">auto</code> specifier to indicate the type of the result of chaining adaptors, as we saw in the previous recipes. Ranges are lazy, which means they are evaluated, and they produce results only when we iterate over them. However, we often need to store the result of applying one or more range adaptors in a container, such as a vector or a map. Prior to C++23, this required explicit coding. However, C++23 provides a range conversion function, called <code class="inlineCode">std::ranges::to</code>, which makes this an easy task. It also enables conversion between different containers. In this recipe, we will learn how to use it.</p>
<h2 class="heading-2" id="_idParaDest-793">Getting ready</h2>
<p class="normal">The <code class="inlineCode">is_prime()</code> function used in the following snippets was shown in the recipe <em class="italic">Exploring the standard range adaptors</em> and will not be listed again here.</p>
<h2 class="heading-2" id="_idParaDest-794">How to do it…</h2>
<p class="normal">You can convert a range<a id="_idIndexMarker1519"/> to a container using the <code class="inlineCode">std::ranges::to</code> range<a id="_idIndexMarker1520"/> conversion function, as follows:</p>
<ul>
<li class="bulletList">Convert a range to a <code class="inlineCode">std::vector</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
std::vector&lt;int&gt; primes = numbers | 
                          std::views::filter(is_prime) | 
                          std::ranges::to&lt;std::vector&gt;();
std::ranges::copy(primes, 
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
std::println("");
std::string text{ "server=demo123;db=optimus" };
auto parts = text | 
             std::views::lazy_split(';') | 
             std::ranges::to&lt;std::vector&lt;std::string&gt;&gt;();
std::ranges::copy(parts, 
                  std::ostream_iterator&lt;std::string&gt;(std::cout, " "));
std::println("");
</code></pre>
</li>
<li class="bulletList">Convert a range to a map type, such as <code class="inlineCode">std::unordered_multimap</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
std::vector&lt;std::string&gt; words{"one", "two", "three", "four"};
auto zipped = std::views::zip(numbers, words) | 
              std::ranges::to&lt;
                 std::unordered_multimap&lt;int, std::string&gt;&gt;();
for (auto const [number, word] : zipped)
{
   std::println("{} = {}", number, word);
}
</code></pre>
</li>
<li class="bulletList">Convert a range to a <code class="inlineCode">std::string</code>:
        <pre class="programlisting code"><code class="hljs-code">std::string text{ "server=demo123;db=optimus" };
std::string text2 = text | 
                    std::views::stride(3) | 
                    std::ranges::to&lt;std::string&gt;();
std::println("{}", text2);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-795">How it works…</h2>
<p class="normal">The <code class="inlineCode">std::ranges::to</code> range conversion function is available in the <code class="inlineCode">&lt;ranges&gt;</code> header, starting with C++23 (the feature-test macro <code class="inlineCode">__cpp_lib_ranges_to_container</code> can be used to test<a id="_idIndexMarker1521"/> whether it is <a id="_idIndexMarker1522"/>supported or not).</p>
<p class="normal">Although the previous examples showed how to convert from one range to another, <code class="inlineCode">std::ranges::to</code> can also be used to convert between different types of containers, such as a vector to a list, or a map to a vector of pairs:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; numbers{ 1, 1, 2, 3, 5, 8, 13 };
std::list&lt;int&gt; list = numbers | std::ranges::to&lt;std::list&gt;();
</code>
std::list</code> and not <code class="inlineCode">std::list&lt;int&gt;</code>. However, there are scenarios where this is not possible, and you will get compiler errors unless you explicitly provide the full type. Such an example is shown next:</pre>
<pre class="programlisting code"><code class="hljs-code">std::map&lt;int, std::string&gt; m{ {1, "one"}, {2, "two"}, {3, "three"} };
std::vector&lt;std::pair&lt;int, std::string&gt;&gt; words = 
   m | rg::to&lt;std::vector&lt;std::pair&lt;int, std::string&gt;&gt;&gt;();
</code></pre>
<p class="normal">When you use the pipe (<code class="inlineCode">|</code>) syntax, the parentheses are mandatory; otherwise, you will get compiler errors (which are difficult to read):</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v {1, 1, 2, 3, 5, 8};
auto r = v | std::ranges::to&lt;std::vector&gt;;   // error
</code></pre>
<p class="normal">The correct <a id="_idIndexMarker1523"/>syntax is <a id="_idIndexMarker1524"/>the following:</p>
<pre class="programlisting code"><code class="hljs-code">auto r = v | std::ranges::to&lt;std::vector&gt;();  // OK
</code></pre>
<h2 class="heading-2" id="_idParaDest-796">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Exploring the standard range adaptors</em>, to learn about the range adaptors available in C++20 and C++23</li>
<li class="bulletList"><em class="italic">Using constrained algorithms</em>, to learn about the standard generic algorithms that work with ranges</li>
</ul>
<h1 class="heading-1" id="_idParaDest-797">Creating your own range view</h1>
<p class="normal">The C++20 ranges<a id="_idIndexMarker1525"/> library simplifies the handling of ranges of elements. The 16 range adaptors (views) defined in the library provide useful operations, as seen in the previous recipe. However, you can create your own view that can be used together with the standard ones. In this recipe, you will learn how to do that. We will create a view called <code class="inlineCode">trim</code> that, given a range and a unary predicate, returns a new range without the front and back elements that satisfy the predicate.</p>
<h2 class="heading-2" id="_idParaDest-798">Getting ready</h2>
<p class="normal">In this recipe, we will use the same namespace aliases used in the previous one, with <code class="inlineCode">rg</code> as an alias for <code class="inlineCode">std::ranges</code> and <code class="inlineCode">rv</code> as an alias for <code class="inlineCode">std::ranges::views</code>.</p>
<h2 class="heading-2" id="_idParaDest-799">How to do it...</h2>
<p class="normal">To create a view, do the following:</p>
<ul>
<li class="bulletList">Create a class template, called <code class="inlineCode">trim_view</code>, derived from <code class="inlineCode">std::ranges::view_interface</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;rg::input_range R, typename P&gt;
    requires rg::view&lt;R&gt;
class trim_view :
    public rg::view_interface&lt;trim_view&lt;R, P&gt;&gt;
{
};
</code></pre>
</li>
<li class="bulletList">Define the internal state of the class, which, at a minimum, should include a begin and end iterator and the viewable range that is adapted by the view. For this <a id="_idIndexMarker1526"/>adapter, we also need a predicate, as well as a Boolean variable to flag whether the iterators have been evaluated or not:
        <pre class="programlisting code"><code class="hljs-code">private:
  R base_ {};
  P pred_;
  mutable rg::iterator_t&lt;R&gt; begin_ {std::begin(base_)};
  mutable rg::iterator_t&lt;R&gt; end_   {std::end(base_)};
  mutable bool evaluated_ = false;
  void ensure_evaluated() const
 {
    if(!evaluated_)
    {
      while(begin_ != std::end(base_) &amp;&amp; pred_(*begin_))
      {begin_ = std::next(begin_);}
      while(end_ != begin_ &amp;&amp; pred_(*std::prev(end_)))
      {end_ = std::prev(end_);}
      evaluated_ = true;
    }
  }
</code></pre>
</li>
<li class="bulletList">Define a default constructor (that can be defaulted) and a <code class="inlineCode">constexpr</code> constructor with the required parameters. The first parameter is always the range. For this view, the other parameter is a predicate:
        <pre class="programlisting code"><code class="hljs-code">public:
  trim_view() = default;
  constexpr trim_view(R base, P pred)
    : base_(std::move(base))
    , pred_(std::move(pred))
    , begin_(std::begin(base_))
    , end_(std::end(base_))
  {}
</code></pre>
</li>
<li class="bulletList">Provide accessors to the internal data, such as the base range and the predicate:
        <pre class="programlisting code"><code class="hljs-code"> constexpr R base() const &amp;       {return base_;}
  constexpr R base() &amp;&amp;            {return std::move(base_);}
  constexpr P const &amp; pred() const { return pred_; }
</code></pre>
</li>
<li class="bulletList">Provide functions to retrieve the begin and end iterators. To make sure the view is lazy, these iterators should only be evaluated by their first use:
        <pre class="programlisting code"><code class="hljs-code"> constexpr auto begin() const
 { ensure_evaluated(); return begin_; }
  constexpr auto end() const
 { ensure_evaluated(); return end_ ; }
</code></pre>
</li>
<li class="bulletList">Provide other useful members, such as a function, to return the size of the range:
        <pre class="programlisting code"><code class="hljs-code"> constexpr auto size() requires rg::sized_range&lt;R&gt;
 { return std::distance(begin_, end_); }
  constexpr auto size() const requires rg::sized_range&lt;const R&gt;
 { return std::distance(begin_, end_); }
</code></pre>
</li>
</ul>
<p class="normal">Put all together, the <a id="_idIndexMarker1527"/>view appears as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;rg::input_range R, typename P&gt; requires rg::view&lt;R&gt;
class trim_view : public rg::view_interface&lt;trim_view&lt;R, P&gt;&gt;
{
private:
  R base_ {};
  P pred_;
  mutable rg::iterator_t&lt;R&gt; begin_ {std::begin(base_)};
  mutable rg::iterator_t&lt;R&gt; end_   {std::end(base_)};
  mutable bool evaluated_ = false;
private:
  void ensure_evaluated() const
 {
    if(!evaluated_)
    {
      while(begin_ != std::end(base_) &amp;&amp; pred_(*begin_))
      {begin_ = std::next(begin_);}
      while(end_ != begin_ &amp;&amp; pred_(*std::prev(end_)))
      {end_ = std::prev(end_);}
      evaluated_ = true;
    }
  }
public:
  trim_view() = default;
  constexpr trim_view(R base, P pred)
    : base_(std::move(base))
    , pred_(std::move(pred))
    , begin_(std::begin(base_))
    , end_(std::end(base_))
  {}
  constexpr R base() const &amp;       {return base_;}
  constexpr R base() &amp;&amp;            {return std::move(base_);}
  constexpr P const &amp; pred() const { return pred_; }
  constexpr auto begin() const
 { ensure_evaluated(); return begin_; }
  constexpr auto end() const
 { ensure_evaluated(); return end_ ; }
  constexpr auto size() requires rg::sized_range&lt;R&gt;
 { return std::distance(begin_, end_); }
  constexpr auto size() const requires rg::sized_range&lt;const R&gt;
 { return std::distance(begin_, end_); }
};
</code></pre>
<p class="normal">To simplify the<a id="_idIndexMarker1528"/> composability of this user-defined view with the standard ones, the following should also be done:</p>
<ul>
<li class="bulletList">Create a user-defined deduction guide for the class template argument deduction of the <code class="inlineCode">trim_view</code> class template:
        <pre class="programlisting code"><code class="hljs-code">template&lt;class R, typename P&gt;
trim_view(R&amp;&amp; base, P pred)
  -&gt; trim_view&lt;rg::views::all_t&lt;R&gt;, P&gt;;
</code></pre>
</li>
<li class="bulletList">Create function objects that can instantiate the <code class="inlineCode">trim_view</code> adaptor with the proper arguments. These can be made available in a separate namespace because they represent implementation details:
        <pre class="programlisting code"><code class="hljs-code">namespace details
{
  template &lt;typename P&gt;
  struct trim_view_range_adaptor_closure
  {
    P pred_;
    constexpr trim_view_range_adaptor_closure(P pred)
      : pred_(pred)
    {}
    template &lt;rg::viewable_range R&gt;
    constexpr auto operator()(R &amp;&amp; r) const
 {
      return trim_view(std::forward&lt;R&gt;(r), pred_);
    }
  };
  struct trim_view_range_adaptor
  {
    template&lt;rg::viewable_range R, typename P&gt;
 constexpr auto operator () (R &amp;&amp; r, P pred)
 {
      return trim_view( std::forward&lt;R&gt;(r), pred ) ;
    }
    template &lt;typename P&gt;
    constexpr auto operator () (P pred)
 {
      return trim_view_range_adaptor_closure(pred);
    }
  };
}
</code></pre>
</li>
<li class="bulletList">Overload the<a id="_idIndexMarker1529"/> pipe operator for the <code class="inlineCode">trim_view_range_adaptor_closure</code> class defined previously:
        <pre class="programlisting code"><code class="hljs-code">namespace details
{
  template &lt;rg::viewable_range R, typename P&gt;
  constexpr auto operator | (
    R&amp;&amp; r,
    trim_view_range_adaptor_closure&lt;P&gt; const &amp; a)
  {
    return a(std::forward&lt;R&gt;(r)) ;
  }
}
</code></pre>
</li>
<li class="bulletList">Create an object of the <code class="inlineCode">trim_view_range_adaptor</code> type that can be used to create <code class="inlineCode">trim_view</code> instances. This can be done in a namespace called <code class="inlineCode">views</code> to create a similarity with the namespaces of the ranges library:
        <pre class="programlisting code"><code class="hljs-code">namespace views
{
  inline static details::trim_view_range_adaptor trim;
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-800">How it works...</h2>
<p class="normal">The <code class="inlineCode">trim_view</code> class template we defined here is derived from the <code class="inlineCode">std::ranges::view_interface</code> class template. This is a<a id="_idIndexMarker1530"/> helper class in the ranges library to define views, using the <strong class="keyWord">curiously recurring template pattern</strong> (<strong class="keyWord">CRTP</strong>). There are two template arguments for the <code class="inlineCode">trim_view</code> class: the range type, which must satisfy the <code class="inlineCode">std::ranges::input_range</code> concept, and the predicate type.</p>
<p class="normal">The <code class="inlineCode">trim_view</code> class<a id="_idIndexMarker1531"/> stores the base range and the predicate internally. Additionally, it requires a beginning and end (sentinel) iterator. These iterators must point to the first element and the ones past the last element of the range that do not satisfy the trimming predicate. However, because the view is a lazy object, these iterators should not be resolved before they are needed to iterate over the range. The following diagram shows the positions of these iterators in a range of integers, for when the view must trim the odd numbers from the beginning and end of the range <code class="inlineCode">{1,1,2,3,5,6,4,7,7,9}</code>:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" src="img/B21549_12_03.png"/></figure>
<p class="packt_figref">Figure 12.3: A visual conceptual representation of the range and the position of the start and end iterators before the iteration starts (above) and when it starts (below)</p>
<p class="normal">We can use the <code class="inlineCode">trim_view</code> class to write the following snippets:</p>
<pre class="programlisting code"><code class="hljs-code">auto is_odd = [](int const n){return n%2 == 1;};
std::vector&lt;int&gt; n { 1,1,2,3,5,6,4,7,7,9 };
auto v = trim_view(n, is_odd);
rg::copy(v, std::ostream_iterator&lt;int&gt;(std::cout, " "));
// prints 2 3 5 6 4
for(auto i : rv::reverse(trim_view(n, is_odd)))
  std::cout &lt;&lt; i &lt;&lt; ' ';
// prints 4 6 5 3 2
</code></pre>
<p class="normal">Using the <code class="inlineCode">trim_view</code> class, as well as composition with other views, is simplified through the use of the function objects declared in the <code class="inlineCode">details</code> namespace, which represent implementation details. However, these, together with the overloaded pipe operator (<code class="inlineCode">|</code>), make it possible to rewrite the preceding code as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto v = n | views::trim(is_odd);
rg::copy(v, std::ostream_iterator&lt;int&gt;(std::cout, " "));
for(auto i : n | views::trim(is_odd) | rv::reverse)
  std::cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
<p class="normal">It should be mentioned <a id="_idIndexMarker1532"/>that the <strong class="keyWord">range-v3</strong> library<a id="_idIndexMarker1533"/> does contain a range view called <code class="inlineCode">trim</code>, but it was not ported to the C++20 ranges library. This may happen in a future version of the standard.</p>
<h2 class="heading-2" id="_idParaDest-801">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Iterating over collections with the ranges library</em>, to learn about the fundamentals of the C++ ranges library</li>
<li class="bulletList"><em class="italic">Specifying requirements on template arguments with concepts</em>, to explore the fundamentals of C++20 concepts</li>
<li class="bulletList"><em class="chapterRef">Chapter 10</em><em class="italic">, Static polymorphism with the curiously recurring template pattern </em>to see how the CRTP works</li>
</ul>
<h1 class="heading-1" id="_idParaDest-802">Using constrained algorithms</h1>
<p class="normal">The C++ standard library features over 100 generic-purpose algorithms (most of them in the <code class="inlineCode">&lt;algorithm&gt;</code> header, and some of them in the <code class="inlineCode">&lt;numeric&gt;</code> header). Some of these algorithms we saw in <em class="chapterRef">Chapter 5</em>, over the course of several recipes, when we learned how to search elements in a range, sort a range, initialize a range, and more. The generic aspect of algorithms comes from the fact they work with iterators (a beginning and end iterator to a sequence of elements–a range) but this has the downside of requiring more explicit code that needs to be repeated over and over again. To ease the use of these algorithms, the C++20 standard provides matching algorithms in the <code class="inlineCode">std::ranges</code> namespace that work with ranges (but also have overloads for iterators). These algorithms from the ranges library are <a id="_idIndexMarker1534"/>called <strong class="keyWord">constrained algorithms</strong> and are available in the <code class="inlineCode">&lt;algorithm&gt;</code> header. Although it’s not possible to look at all of them here, in this recipe we will see how to use several of them for initializing, sorting, and finding elements in a range.</p>
<h2 class="heading-2" id="_idParaDest-803">How to do it…</h2>
<p class="normal">You can perform <a id="_idIndexMarker1535"/>various operations on ranges, including initializing, finding, and sorting, as follows:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">std::ranges::fill()</code> to assign a value to all the elements of a range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(5);
std::ranges::fill(v, 42);
// v = {42, 42, 42, 42, 42}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::fill_n()</code> to assign a value to a specified number of elements of a range. The first element to be assigned is indicated by an output iterator:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(10);
std::ranges::fill_n(v.begin(), 5, 42);
// v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::generate_n()</code> to assign the value returned by successive invocations of a given function to a number of elements of a range. The first element is indicated by an iterator:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(5);
auto i = 1;
std::ranges::generate_n(v.begin(), v.size(), 
                        [&amp;i] { return I * i++; });
// v = {1, 4, 9, 16, 25}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::iota()</code> to assign sequentially increasing values to the elements of a range. The values are incremented using the prefix <code class="inlineCode">operator++</code> from an initial specified value:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v(5);
std::ranges::iota(v, 1);
// v = {1, 2, 3, 4, 5}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::find()</code> to find a value in a range; this algorithm returns an iterator to the first element equal to the supplied value, if such a value exists, or an iterator equal to the end of the range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto it = std::ranges::find(v, 3);
if (it != v.cend()) std::cout &lt;&lt; *it &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::find_if()</code> to find a value in a range that meets the criteria defined by a unary predicate. The algorithm returns an iterator to the first element in the range for which the predicate returns <code class="inlineCode">true</code>, or an iterator to the end of the range if no such element exists:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto it = std::ranges::find_if(v, [](int const n) { return n &gt; 10; });
if (it != v.cend()) std::cout &lt;&lt; *it &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::find_first_of()</code> to search for the occurrence of any value <a id="_idIndexMarker1536"/>from a range in another range; the algorithm returns an iterator to the first element (in the searched range) that is found, or one equal to the end of the range, otherwise:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
std::vector&lt;int&gt; p{ 5, 7, 11 };
auto it = std::ranges::find_first_of(v, p);
if (it != v.cend())
   std::cout &lt;&lt; "found " &lt;&lt; *it
   &lt;&lt; " at index " &lt;&lt; std::ranges::distance(v.cbegin(), it)
   &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::sort()</code> to sort a range. You can supply a comparison function to be applied to the elements. This can include <code class="inlineCode">std::ranges::greater</code>, <code class="inlineCode">std::ranges::less</code>, and the other function objects from the <code class="inlineCode">&lt;functional&gt;</code> header corresponding to the <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&gt;=</code>, <code class="inlineCode">==</code>, and <code class="inlineCode">!=</code> operators:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
std::ranges::sort(v);
// v = {1, 1, 2, 3, 5, 8, 13}
std::ranges::sort(v, std::ranges::greater());
// v = {13, 8, 5, 3, 2, 1 ,1}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::is_sorted()</code> to check that a range is sorted:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto sorted = std::ranges::is_sorted(v);
sorted = std::ranges::is_sorted(v, std::ranges::greater());
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::ranges::is_sorted_until()</code> to find a sorted subrange from the beginning of a <a id="_idIndexMarker1537"/>range:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
auto it = std::ranges::is_sorted_until(v);
auto length = std::ranges::distance(v.cbegin(), it);
// length = 2
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-804">How it works…</h2>
<p class="normal">All but one of the<a id="_idIndexMarker1538"/> constrained algorithms are located in the <code class="inlineCode">&lt;algorithm&gt;</code> header. The exception is <code class="inlineCode">std::ranges::iota()</code>, which is found in the <code class="inlineCode">&lt;numeric&gt;</code> header. The algorithms listed in the <em class="italic">How to do it… </em>section are only a small selection of the available constrained algorithms. They are called constrained because there are requirements defined in their arguments with the help of concepts and constraints. Here is the definition of one of the overloads of <code class="inlineCode">std::ranges::find()</code> that we used previously:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;ranges::input_range R, class T, class Proj = std::identity&gt;
requires std::indirect_binary_predicate&lt;
    ranges::equal_to,
    std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
    const T*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
</code>
std::ranges::find()</code> algorithm, also presented in the previous section, invoked with a beginning and ending iterator:</pre>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };
auto it = std::ranges::find(v.begin(), v.end(), 3);
if (it != v.cend()) std::cout &lt;&lt; *it &lt;&lt; '\n';
</code></pre>
<p class="normal">On the other <a id="_idIndexMarker1539"/>hand, there are some algorithms, such as <code class="inlineCode">std::ranges::fill_n()</code> and <code class="inlineCode">std::ranges::generate_n()</code>, seen earlier, that have a single overload that takes only one iterator, from the beginning of the range.</p>
<p class="normal">Another difference between the traditional algorithms and the constrained algorithms is that the latter do not have overloads to specify an execution policy, unlike the former, which do.</p>
<p class="normal">The constrained algorithms have <a id="_idIndexMarker1540"/>several advantages over the traditional algorithms:</p>
<ul>
<li class="bulletList">There is less code to write because you don’t have to retrieve the beginning and ending iterator of a range.</li>
<li class="bulletList">They are constrained, using concepts and constraints, which help provide better error messages in case of misuse.</li>
<li class="bulletList">They can be used with ranges/views as defined by the ranges library.</li>
<li class="bulletList">Some of them have overloads that allow you to specify a projection to apply to the elements, on which, in turn, a specified predicate is applied.</li>
</ul>
<p class="normal">Let’s first see how the constrained algorithms interact with ranges. For this, we consider the following example:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 3, 13, 5, 8, 1, 2, 1 };
auto range =
   v |
   std::views::filter([](int const n) {return n % 2 == 1; }) |
   std::views::transform([](int const n) {return n * n; }) |
   std::views::take(4);
std::ranges::for_each(range, 
                      [](int const n) {std::cout &lt;&lt; n &lt;&lt; ' '; });
std::cout &lt;&lt; '\n';
auto it = std::ranges::find_if(range, 
                               [](int const n) {return n &gt; 10; });
if (it != range.end())
   std::cout &lt;&lt; *it &lt;&lt; '\n';
</code></pre>
<p class="normal">In this<a id="_idIndexMarker1541"/> example, we have a vector of integers. From this vector, we filter out the even numbers, transform the rest by their square, and, finally, retain four of the resulting numbers. The result is a range. Its type is too complex to remember or write; therefore, we use the <code class="inlineCode">auto</code> specifier and let the compiler infer it. </p>
<div><p class="normal">For those of you who wonder what the actual type is (in this previous example), it is <code class="inlineCode">std::ranges::take_view&lt;std::ranges::transform_view&lt;std::ranges::filter_view&lt;std::ranges::ref_view&lt;std::vector&lt;int&gt;&gt;, lambda [](int n)-&gt;bool&gt;, lambda [](int n)-&gt;int&gt;&gt;</code>.</p>
</div>
<p class="normal">We want to print the resulting values to the console and find the first value greater than 10 (if any exists). For this purpose, we use <code class="inlineCode">std::ranges::for_each()</code> and <code class="inlineCode">std::ranges::find_if()</code>, passing the <code class="inlineCode">range</code> object without having to deal directly with iterators.</p>
<p class="normal">The last advantage mentioned earlier in the list is the ability to specify a projection. A projection is a callable object (for instance, a function object, or a reference to a member). This projection is applied to the elements of the range. On the result of the projection, another predicate is applied. </p>
<p class="normal">To understand how this works, let’s consider a list of products with an ID, name, and price. From this list, we want to find the product with a certain price and print its name. The list is defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct Product
{
   int         id;
   std::string name;
   double      price;
};
std::vector&lt;Product&gt; products
{
   {1, "pen", 15.50},
   {2, "pencil", 9.99},
   {3, "rubber", 5.0},
   {4, "ruler", 5.50},
   {5, "notebook", 12.50}
};
</code></pre>
<p class="normal">With the <a id="_idIndexMarker1542"/>traditional algorithms, we need to use <code class="inlineCode">std::find_if()</code> and pass a lambda function that performs the checking of each element:</p>
<pre class="programlisting code"><code class="hljs-code">auto pos = std::find_if(
   products.begin(), products.end(),
   [](Product const&amp; p) { return p.price == 12.5; });
if (pos != products.end())
   std::cout &lt;&lt; pos-&gt;name &lt;&lt; '\n';
</code></pre>
<p class="normal">With constrained algorithms, we can use one of the overloads of <code class="inlineCode">std::ranges::find()</code> that take a range, a value, and a projection, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto it = std::ranges::find(products, 12.50, &amp;Product::price);
if (it != products.end())
   std::cout &lt;&lt; it-&gt;name &lt;&lt; '\n';
</code></pre>
<p class="normal">Another similar example is sorting the range alphabetically (in ascending order) by the name of the products:</p>
<pre class="programlisting code"><code class="hljs-code">std::ranges::sort(products, std::ranges::less(), &amp;Product::name);
std::ranges::for_each(products, [](Product const&amp; p) {
      std::cout &lt;&lt; std::format("{} = {}\n", p.name, p.price); });
</code></pre>
<p class="normal">Hopefully, these<a id="_idIndexMarker1543"/> examples show there are compelling arguments to prefer, in general, the new C++20 constrained algorithms over the traditional ones. However, keep in mind that you cannot use constrained algorithms when you want to specify an execution policy (for instance, to parallelize or vectorize the execution of an algorithm), as such overloads are not available.</p>
<h2 class="heading-2" id="_idParaDest-805">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 5</em>, <em class="italic">Finding elements in a range</em>, to learn about the standard algorithms to search through sequences of values</li>
<li class="bulletList"><em class="chapterRef">Chapter 5</em>, <em class="italic">Sorting a range</em>, to learn about the standard algorithms for sorting ranges</li>
<li class="bulletList"><em class="chapterRef">Chapter 5</em>, <em class="italic">Initializing a range</em>, to explore the standard algorithms for filling a range with values</li>
<li class="bulletList"><em class="italic">Specify requirements on template arguments with concepts</em>, to explore the fundamentals of C++20 concepts</li>
</ul>
<h1 class="heading-1" id="_idParaDest-806">Creating a coroutine task type for asynchronous computations</h1>
<p class="normal">A major component of the C++20 <a id="_idIndexMarker1544"/>standard is represented by coroutines. Simply put, coroutines are functions that can be suspended and resumed. Coroutines are an alternative to writing asynchronous code. They help simplify asynchronous I/O code, lazy computations, or event-driven applications. When a coroutine is suspended, the execution returns to the caller, and the data necessary to resume the coroutine is stored separately from the stack. For this reason, the C++20 coroutines are called <em class="italic">stackless</em>. Unfortunately, the C++20 standard does not define actual coroutine types and only a framework for building them. This makes writing asynchronous code with coroutines difficult without relying on third-party components.</p>
<p class="normal">In this recipe, you will learn how to write a coroutine task type that represents an asynchronous computation, which starts executing when the task is awaited.</p>
<h2 class="heading-2" id="_idParaDest-807">Getting ready</h2>
<p class="normal">The several <a id="_idIndexMarker1545"/>standard library types and functions that define the coroutine framework are available in the <code class="inlineCode">&lt;coroutine&gt;</code> header, in the <code class="inlineCode">std</code> namespace. However, you need to use a minimum compiler version to support coroutines: MSVC 19.28 (from Visual Studio 2019 16.8), Clang 17, or GCC 10.</p>
<p class="normal">The goal of this recipe is to create a task type that enables us to write asynchronous functions, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">task&lt;int&gt; get_answer()
{
  co_return 42;
}
task&lt;&gt; print_answer()
{
  auto t = co_await get_answer();
  std::cout &lt;&lt; "the answer is " &lt;&lt; t &lt;&lt; '\n';
}
template &lt;typename T&gt;
void execute(T&amp;&amp; t)
{
  while (!t.is_ready()) t.resume();
};
int main()
{
  auto t = get_answer();
  execute(t);
  std::cout &lt;&lt; "the answer is " &lt;&lt; t.value() &lt;&lt; '\n';
  execute(print_answer());
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-808">How to do it...</h2>
<p class="normal">To create a task <a id="_idIndexMarker1546"/>type that supports coroutines that return nothing (<code class="inlineCode">task&lt;&gt;</code>), a value (<code class="inlineCode">task&lt;T&gt;</code>), or a reference (<code class="inlineCode">task&lt;T&amp;&gt;</code>), you should do the following:</p>
<ul>
<li class="bulletList">Create a class called <code class="inlineCode">promise_base</code> with the following content:
        <pre class="programlisting code"><code class="hljs-code">namespace details
{
  struct promise_base
  {
    auto initial_suspend() noexcept
 { return std::suspend_always{}; }
    auto final_suspend() noexcept
 { return std::suspend_always{}; }
    void unhandled_exception()
 { std::terminate(); }
   };
}
</code></pre>
</li>
<li class="bulletList">Create a class template called <code class="inlineCode">promise</code>, derived from <code class="inlineCode">promise_base</code>, that adds the methods <code class="inlineCode">get_return_object()</code> and <code class="inlineCode">return_value()</code> and holds the value returned from the coroutine:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct task;
namespace details
{
  template &lt;typename T&gt;
  struct promise final : public promise_base
  {
    task&lt;T&gt; get_return_object() noexcept;
    template&lt;typename V,
             typename = std::enable_if_t&lt;
                std::is_convertible_v&lt;V&amp;&amp;, T&gt;&gt;&gt;
    void return_value(V&amp;&amp; value)
    noexcept(std::is_nothrow_constructible_v&lt;T, V&amp;&amp;&gt;)
    {
      value_ = value;
    }
    T get_value() const noexcept { return value_; }
  private:
    T value_;
  };
}
</code></pre>
</li>
<li class="bulletList">Specialize the <code class="inlineCode">promise</code> class template for the <code class="inlineCode">void</code> type, and provide implementations for the <code class="inlineCode">get_return_object()</code> and <code class="inlineCode">return_void()</code> methods:
        <pre class="programlisting code"><code class="hljs-code">namespace details
{
  template &lt;&gt;
  struct promise&lt;void&gt; final : public promise_base
  {
    task&lt;void&gt; get_return_object() noexcept;
    void return_void() noexcept {}
  };
}
</code></pre>
</li>
<li class="bulletList">Specialize<a id="_idIndexMarker1547"/> the <code class="inlineCode">promise</code> class template for <code class="inlineCode">T&amp;</code>. Provide implementations for <code class="inlineCode">get_return_object()</code> and <code class="inlineCode">return_value()</code>, and store a pointer to the reference returned by the coroutine:
        <pre class="programlisting code"><code class="hljs-code">namespace details
{
  template &lt;typename T&gt;
  struct promise&lt;T&amp;&gt; final : public promise_base
  {    
    task&lt;T&amp;&gt; get_return_object() noexcept;
    void return_value(T&amp; value) noexcept
 {
      value_ = std::addressof(value);
    }
    T&amp; get_value() const noexcept { return *value_; }
  private:
    T* value_ = nullptr;
  };
}
</code></pre>
</li>
<li class="bulletList">Create a class<a id="_idIndexMarker1548"/> template called <code class="inlineCode">task</code>, with the stub content shown below. This type must have an inner type called <code class="inlineCode">promise_type</code> and hold a handle to the executing coroutine. The <code class="inlineCode">task_awaiter</code> and the class members are listed here:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T = void&gt;
struct task
{
  using promise_type = details::promise&lt;T&gt;;
  // task_awaiter
// members
private:
  std::coroutine_handle&lt;promise_type&gt; handle_ = nullptr;
};
</code></pre>
</li>
<li class="bulletList">Create an awaitable class called <code class="inlineCode">task_awaiter</code> that implements the <code class="inlineCode">await_ready()</code>, <code class="inlineCode">await_suspend()</code>, and <code class="inlineCode">await_resume()</code> methods:
        <pre class="programlisting code"><code class="hljs-code">struct task_awaiter
{
  task_awaiter(std::coroutine_handle&lt;promise_type&gt; coroutine)
  noexcept
    : handle_(coroutine)
  {}
  bool await_ready() const noexcept
 {
     return !handle_ || handle_.done();
  }
  void await_suspend(
    std::coroutine_handle&lt;&gt; continuation) noexcept
 {
    handle_.resume();
  }
  decltype(auto) await_resume()
 {
    if (!handle_)
      throw std::runtime_error{ "broken promise" };
    return handle_.promise().get_value();
  }
  friend struct task&lt;T&gt;;
private:
  std::coroutine_handle&lt;promise_type&gt; handle_;
};
</code></pre>
</li>
<li class="bulletList">Provide <a id="_idIndexMarker1549"/>class members, including a conversion constructor, a move constructor and move assignment operator, a destructor, a <code class="inlineCode">co_await</code> operator, a method to check whether the coroutine has completed, a method to resume a suspended coroutine, and a method to get the value returned from the coroutine:
        <pre class="programlisting code"><code class="hljs-code">explicit task(std::coroutine_handle&lt;promise_type&gt; handle)
  : handle_(handle)
{
}
~task()
{
  if (handle_) handle_.destroy();
}
task(task&amp;&amp; t) noexcept : handle_(t.handle_)
{
  t.handle_ = nullptr;
}
task&amp; operator=(task&amp;&amp; other) noexcept
{
  if (std::addressof(other) != this)
  {
    if (handle_) handle_.destroy();
    handle_ = other.handle_;
    other.handle_ = nullptr;
  }
  return *this;
}
task(task const &amp;) = delete;
task&amp; operator=(task const &amp;) = delete;
T value() const noexcept
{ return handle_.promise().get_value(); }
void resume() noexcept
{ handle_.resume(); }
bool is_ready() const noexcept
{ return !handle_ || handle_.done(); }
auto operator co_await() const&amp; noexcept
{
  return task_awaiter{ handle_ };
}
</code></pre>
</li>
<li class="bulletList">Implement<a id="_idIndexMarker1550"/> the <code class="inlineCode">get_return_object()</code> member of the <code class="inlineCode">promise</code> primary template as well as its specializations. This must be done after the definition of the <code class="inlineCode">task</code> class:
        <pre class="programlisting code"><code class="hljs-code">namespace details
{
   template &lt;typename T&gt;
   task&lt;T&gt; promise&lt;T&gt;::get_return_object() noexcept
   {
      return task&lt;T&gt;{
        std::coroutine_handle&lt;promise&lt;T&gt;&gt;::from_promise(*this)};
   }
   task&lt;void&gt; promise&lt;void&gt;::get_return_object() noexcept
   {
      return task&lt;void&gt;{
        std::coroutine_handle&lt;promise&lt;void&gt;&gt;::from_promise(*this)};
   }
   template &lt;typename T&gt;
   task&lt;T&amp;&gt; promise&lt;T&amp;&gt;::get_return_object() noexcept
   {
      return task&lt;T&amp;&gt;{
        std::coroutine_handle&lt;promise&lt;T&amp;&gt;&gt;::from_promise(
        *this)};
   }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-809">How it works...</h2>
<p class="normal">Functions are <a id="_idIndexMarker1551"/>blocks of code that execute one or more statements. You can assign them to variables, pass them as arguments, take their address, and, of course, invoke them. These features make them first-class citizens in the C++ language. Functions are sometimes called <em class="italic">subroutines</em>. Coroutines, on the other hand, are functions that support two additional operations: suspending and resuming their execution.</p>
<p class="normal">In C++20, a function<a id="_idIndexMarker1552"/> is a coroutine if it uses any of the following:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">co_await</code> operator, which suspends the execution until resumed</li>
<li class="bulletList">The <code class="inlineCode">co_return</code> keyword, to complete the execution and optionally return a value</li>
<li class="bulletList">The <code class="inlineCode">co_yield</code> keyword, to suspend the execution and return a value</li>
</ul>
<p class="normal">Not every function, however, can be a coroutine. The following cannot be coroutines:</p>
<ul>
<li class="bulletList">Constructors and destructors</li>
<li class="bulletList">Constexpr functions</li>
<li class="bulletList">Functions with a variable number of arguments</li>
<li class="bulletList">Functions that return <code class="inlineCode">auto</code> or a concept type</li>
<li class="bulletList">The <code class="inlineCode">main()</code> function</li>
</ul>
<p class="normal">A coroutine<a id="_idIndexMarker1553"/> consists of the following three parts:</p>
<ul>
<li class="bulletList">A <em class="italic">promise object</em>, which is <a id="_idIndexMarker1554"/>manipulated inside the coroutine and is used to pass the return value or an exception from the coroutine.</li>
<li class="bulletList">A <em class="italic">coroutine handle</em>, which is <a id="_idIndexMarker1555"/>manipulated outside the coroutine and is used to either resume the execution or destroy the coroutine frame.</li>
<li class="bulletList">The <em class="italic">coroutine frame</em>, typically <a id="_idIndexMarker1556"/>allocated on the heap and containing the promise object, the coroutine parameters copied by value, local variables, temporaries whose lifetimes exceed the current suspension point, and a representation of the suspension point so that resuming and destroying can be performed.</li>
</ul>
<p class="normal">The promise object<a id="_idIndexMarker1557"/> can be any type that implements the following interface, as <a id="_idIndexMarker1558"/>expected by the compiler:</p>
<table class="table-container" id="table003-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Default constructor</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">The promise must be default constructible</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">initial_suspend()</code></p>
</td>
<td class="table-cell">
<p class="normal">Indicates whether suspension happens at the initial suspend point.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">final_suspend()</code></p>
</td>
<td class="table-cell">
<p class="normal">Indicates whether suspension happens at the last suspend point.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">unhandled_exception()</code></p>
</td>
<td class="table-cell">
<p class="normal">Called when an exception propagates out of a coroutine block.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">get_return_object()</code></p>
</td>
<td class="table-cell">
<p class="normal">The return value of the function.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">return_value(v)</code></p>
</td>
<td class="table-cell">
<p class="normal">Enables the <code class="inlineCode">co_return v</code> statement. Its return type must be <code class="inlineCode">void</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">return_void()</code></p>
</td>
<td class="table-cell">
<p class="normal">Enables the <code class="inlineCode">co_return</code> statement. Its return type must be <code class="inlineCode">void</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">yield_value(v)</code></p>
</td>
<td class="table-cell">
<p class="normal">Enables the <code class="inlineCode">co_yield v</code> statement.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 12.3: The members of the interface implemented by a promise</p>
<p class="normal">The implementation of <code class="inlineCode">initial_suspend()</code> and <code class="inlineCode">final_suspend()</code> we have seen for the <code class="inlineCode">promise</code> type implemented here returns an instance of <code class="inlineCode">std::suspend_always</code>. This is one of the two trivial awaitables that the standard defines, the other being <code class="inlineCode">std::suspend_never</code>. Their implementation is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct suspend_always
{
  constexpr bool await_ready() noexcept { return false; }
  constexpr void await_suspend(coroutine_handle&lt;&gt;) noexcept {}
  constexpr void await_resume() noexcept {}
};
struct suspend_never
{
  constexpr bool await_ready() noexcept { return true; }
  constexpr void await_suspend(coroutine_handle&lt;&gt;) noexcept {}
  constexpr void await_resume() noexcept {}
};
</code></pre>
<p class="normal">These types implement the <em class="italic">awaitable</em> concept, which enables the use of the <code class="inlineCode">co_await</code> operator. There are three functions required by this concept. These can be either free functions or class member functions. They are listed in the following table:</p>
<table class="table-container" id="table004-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">await_ready()</code></p>
</td>
<td class="table-cell">
<p class="normal">Indicates whether the result is ready. If the return value is <code class="inlineCode">false</code> (or a value convertible to <code class="inlineCode">false</code>), then <code class="inlineCode">await_suspend()</code> is called.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">await_suspend()</code></p>
</td>
<td class="table-cell">
<p class="normal">Schedules the coroutine to resume or to be destroyed.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">await_resume()</code></p>
</td>
<td class="table-cell">
<p class="normal">Provides the result for the entire <code class="inlineCode">co_await e</code> expression.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 12.4: Functions that the awaitable concepts require</p>
<p class="normal">The <code class="inlineCode">task&lt;T&gt;</code> type we built in this<a id="_idIndexMarker1559"/> recipe has several members:</p>
<ul>
<li class="bulletList">An explicit constructor that takes an argument of the <code class="inlineCode">std::coroutine_handle&lt;T&gt;</code> type, representing a non-owning handle to the coroutine.</li>
<li class="bulletList">A destructor that destroys the coroutine frame.</li>
<li class="bulletList">A move constructor and move assignment operator.</li>
<li class="bulletList">A deleted copy constructor and copy assignment operator, making the class moveable-only.</li>
<li class="bulletList">The <code class="inlineCode">co_await</code> operator, which returns a <code class="inlineCode">task_awaiter</code> value that implements the awaitable concept.</li>
<li class="bulletList"><code class="inlineCode">is_ready()</code>, a method that returns a Boolean value indicating whether the coroutine value is ready.</li>
<li class="bulletList"><code class="inlineCode">resume()</code>, a method that resumes the execution of the coroutine.</li>
<li class="bulletList"><code class="inlineCode">value()</code>, a method that returns the value held by the promise object.</li>
<li class="bulletList">An inner promise type called <code class="inlineCode">promise_type</code> (this name is mandatory).</li>
</ul>
<p class="normal">If an exception <a id="_idIndexMarker1560"/>occurs during the execution of the coroutine, and this exception leaves the coroutine without being handled, then the <code class="inlineCode">unhandled_exception()</code> method of the promise is invoked. In this simple implementation, this situation is not handled, and the program is abnormally terminated with a call to <code class="inlineCode">std::terminate()</code>. In the following recipe, we will see an awaitable implementation that handles exceptions.</p>
<p class="normal">Let’s take the following coroutine as an example to see how the compiler handles it:</p>
<pre class="programlisting code"><code class="hljs-code">task&lt;&gt; print_answer()
{
  auto t = co_await get_answer();
  std::cout &lt;&lt; "the answer is " &lt;&lt; t &lt;&lt; '\n';
}
</code></pre>
<p class="normal">Because of all the mechanisms we built in this recipe, the compiler transforms this code into the following (this snippet is pseudocode):</p>
<pre class="programlisting code"><code class="hljs-code">task&lt;&gt; print_answer()
{
  __frame* context;
  task&lt;&gt;::task_awaiter t = operator co_await(get_answer());
  if(!t.await_ready())
  {
    coroutine_handle&lt;&gt; resume_co =
      coroutine_handle&lt;&gt;::from_address(context);
    y.await_suspend(resume_co);
    __suspend_resume_point_1:
  }
  auto value = t.await_resume();
  std::cout &lt;&lt; "the answer is " &lt;&lt; value &lt;&lt; '\n';
}
</code></pre>
<p class="normal">As mentioned earlier, the <code class="inlineCode">main()</code> function is one of the functions that cannot be a coroutine. For this reason, it is not possible to use the <code class="inlineCode">co_await</code> operator in <code class="inlineCode">main()</code>. This means that waiting for a coroutine to complete must be done differently in <code class="inlineCode">main()</code>.</p>
<p class="normal">This is handled with the help of a function template called <code class="inlineCode">execute()</code> that runs the following loop:</p>
<pre class="programlisting code"><code class="hljs-code">while (!t.is_ready()) t.resume();
</code></pre>
<p class="normal">This loop ensures<a id="_idIndexMarker1561"/> that the coroutine is resumed after each suspension point, until its final completion.</p>
<h2 class="heading-2" id="_idParaDest-810">There’s more...</h2>
<p class="normal">The C++20 standard does not provide any coroutine types, and writing your own is a cumbersome task. Fortunately, third-party libraries can offer these abstractions. Such a library is <strong class="keyWord">libcoro</strong>, an <a id="_idIndexMarker1562"/>open-source experimental library that provides a set of general-purpose primitives to make use of the coroutines described in the C++20 standard. The library is<a id="_idIndexMarker1563"/> available at <a href="https://github.com/jbaldwin/libcoro">https://github.com/jbaldwin/libcoro</a>. Among the components it provides is the <code class="inlineCode">task&lt;T&gt;</code> coroutine type, similar to what we built in this recipe. Using the <code class="inlineCode">coro::task&lt;T&gt;</code> type, we can rewrite our examples as follows:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;iostream&gt;
#include &lt;coro/task.hpp&gt;
#include &lt;coro/sync_wait.hpp&gt;
coro::task&lt;int&gt; get_answer()
{
  co_return 42;
}
coro::task&lt;&gt; print_answer()
{
  auto t = co_await get_answer();
  std::cout &lt;&lt; "the answer is " &lt;&lt; t &lt;&lt; '\n';
}
coro::task&lt;&gt; demo()
{
  auto t = co_await get_answer();
  std::cout &lt;&lt; "the answer is " &lt;&lt; t &lt;&lt; '\n';
  co_await print_answer();
}
int main()
{
   coro::sync_wait(demo());
}
</code></pre>
<p class="normal">As you can see, the code is very similar to what we wrote in the first part of this recipe. The changes are minimal. By using<a id="_idIndexMarker1564"/> this <strong class="keyWord">libcoro</strong> library or others that are similar, you do not need to be concerned with the details of implementing coroutine types and instead focus on their use.</p>
<div><p class="normal">Another library that was used in the second edition of the book was <strong class="keyWord">cppcoro</strong>, which is available at <a href="https://github.com/lewissbaker/cppcoro">https://github.com/lewissbaker/cppcoro</a>. However, the <strong class="keyWord">cppcoro</strong> library has not been maintained for several years. Although it’s still available on<a id="_idIndexMarker1565"/> GitHub, it relies on the experimental implementation of technical specifications for coroutines. For instance, when using MSVC, this requires the use of the now obsolete <code class="inlineCode">/await</code> compiler flag. You should only use this library as a source of inspiration to write coroutine primitives, such as the one we will see in the next recipe.</p>
</div>
<h2 class="heading-2" id="_idParaDest-811">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating a coroutine generator type for sequences of values</em>, to learn how to enable the use of <code class="inlineCode">co_yield</code> to return multiple values from a coroutine</li>
</ul>
<h1 class="heading-1" id="_idParaDest-812">Creating a coroutine generator type for sequences of values</h1>
<p class="normal">In the previous recipe, we saw<a id="_idIndexMarker1566"/> how to create a coroutine task that enables asynchronous computations. We used the <code class="inlineCode">co_await</code> operator to suspend execution until resumed and the <code class="inlineCode">co_return</code> keyword to complete execution and return a value. However, another keyword, <code class="inlineCode">co_yield</code>, also defines a function as a coroutine. It suspends the execution of the coroutine and returns a value. It enables a coroutine to return multiple values, one each time it is resumed. To support this feature, another type of coroutine is required. This type is called a <em class="italic">generator</em>. Conceptually, it’s like a stream that produces a sequence of values of type <code class="inlineCode">T</code> in a lazy manner (when iterated). In this recipe, we will see how we can implement a simple generator.</p>
<h2 class="heading-2" id="_idParaDest-813">Getting ready</h2>
<p class="normal">The goal of this <a id="_idIndexMarker1567"/>recipe is to create a generator coroutine type that enables us to write code like the following:</p>
<pre class="programlisting code"><code class="hljs-code">generator&lt;int&gt; iota(int start = 0, int step = 1) noexcept
{
  auto value = start;
  for (int i = 0;; ++i)
  {
    co_yield value;
    value += step;
  }
}
generator&lt;std::optional&lt;int&gt;&gt; iota_n(
  int start = 0, int step = 1,
  int n = std::numeric_limits&lt;int&gt;::max()) noexcept
{
  auto value = start;
  for (int i = 0; i &lt; n; ++i)
  {
    co_yield value;
    value += step;
  }
}
generator&lt;int&gt; fibonacci() noexcept
{
  int a = 0, b = 1;
  while (true)
  {
    co_yield b;
    auto tmp = a;
    a = b;
    b += tmp;
  }
}
int main()
{
  for (auto i : iota())
  {
    std::cout &lt;&lt; i &lt;&lt; ' ';
    if (i &gt;= 10) break;
  }
  for (auto i : iota_n(0, 1, 10))
  {
    if (!i.has_value()) break;
    std::cout &lt;&lt; i.value() &lt;&lt; ' ';
  }
  int c = 1;
  for (auto i : fibonacci())
  {
    std::cout &lt;&lt; i &lt;&lt; ' ';
    if (++c &gt; 10) break;
  }
}
</code></pre>
<p class="normal">It is recommended that you follow the previous recipe, <em class="italic">Creating a coroutine task type for asynchronous computations</em>, before you continue with this one.</p>
<h2 class="heading-2" id="_idParaDest-814">How to do it...</h2>
<p class="normal">To create a <a id="_idIndexMarker1568"/>generator coroutine type that supports synchronous lazy production of a sequence of values, you should do the following:</p>
<ul>
<li class="bulletList">Create a class template, called <code class="inlineCode">generator</code>, with the following content (the details of each part are presented in the following bullet points):
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct generator
{
  // struct promise_type
// struct iterator
// member functions
// iterators
private:
   std::coroutine_handle&lt;promise_type&gt; handle_ = nullptr;
};
</code></pre>
</li>
<li class="bulletList">Create an<a id="_idIndexMarker1569"/> inner class called <code class="inlineCode">promise_type</code> (the name is mandatory) with the following content:
        <pre class="programlisting code"><code class="hljs-code">struct promise_type
{
  T const*             value_;
  std::exception_ptr   eptr_;
  auto get_return_object()
 { return generator{ *this }; }
  auto initial_suspend() noexcept
 { return std::suspend_always{}; }
  auto final_suspend() noexcept
 { return std::suspend_always{}; }
  void unhandled_exception() noexcept
 {
     eptr_ = std::current_exception();
  }
  void rethrow_if_exception()
 {
     if (eptr_)
     {
        std::rethrow_exception(eptr_);
     }
  }
  auto yield_value(T const&amp; v)
 {
     value_ = std::addressof(v);
     return std::suspend_always{};
  }
  void return_void() {}
  template &lt;typename U&gt;
  U&amp;&amp; await_transform(U&amp;&amp; v)
 {
     return std::forward&lt;U&gt;(v);
  }
};
</code></pre>
</li>
<li class="bulletList">Create an <a id="_idIndexMarker1570"/>inner class called <code class="inlineCode">iterator</code> with the following content:
        <pre class="programlisting code"><code class="hljs-code">struct iterator
{
  using iterator_category = std::input_iterator_tag;
  using difference_type   = ptrdiff_t;
  using value_type        = T;
  using reference         = T const&amp;;
  using pointer           = T const*;
  std::coroutine_handle&lt;promise_type&gt; handle_ = nullptr;
  iterator() = default;
  iterator(nullptr_t) : handle_(nullptr) {}
  iterator(std::coroutine_handle&lt;promise_type&gt; arg)
    : handle_(arg)
  {}
  iterator&amp; operator++()
  {
     handle_.resume();
     if (handle_.done())
     {
        std::exchange(handle_, {}).promise()
                                  .rethrow_if_exception();
     }
     return *this;
  }
  void operator++(int)
  {
     ++*this;
  }
  bool operator==(iterator const&amp; _Right) const
  {
     return handle_ == _Right.handle_;
  }
  bool operator!=(iterator const&amp; _Right) const
  {
     return !(*this == _Right);
  }
  reference operator*() const
  {
     return *handle_.promise().value_;
  }
  pointer operator-&gt;() const
  {
     return std::addressof(handle_.promise().value_);
  }
};
</code></pre>
</li>
<li class="bulletList">Provide a<a id="_idIndexMarker1571"/> default constructor, an explicit constructor from a <code class="inlineCode">promise_type</code> object, a move constructor and a move assignment operator, and a destructor. Delete the copy constructor and copy assignment operator so that the type is moveable only:
        <pre class="programlisting code"><code class="hljs-code">explicit generator(promise_type&amp; p)
  : handle_(
      std::coroutine_handle&lt;promise_type&gt;::from_promise(p))
{}
generator() = default;
generator(generator const&amp;) = delete;
generator&amp; operator=(generator const&amp;) = delete;
generator(generator&amp;&amp; other) : handle_(other.handle_)
{
  other.handle_ = nullptr;
}
generator&amp; operator=(generator&amp;&amp; other)
{
  if (this != std::addressof(other))
  {
     handle_ = other.handle_;
     other.handle_ = nullptr;
  }
  return *this;
}
~generator()
{
  if (handle_)
  {
     handle_.destroy();
  }
}
</code></pre>
</li>
<li class="bulletList">Provide<a id="_idIndexMarker1572"/> the <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions to enable iteration over the generator sequence:
        <pre class="programlisting code"><code class="hljs-code">iterator begin()
{
  if (handle_)
  {
     handle_.resume();
     if (handle_.done())
     {
        handle_.promise().rethrow_if_exception();
        return { nullptr };
     }
  }
  return { handle_ };
}
iterator end()
{
  return { nullptr };
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-815">How it works...</h2>
<p class="normal">The promise type implemented in this recipe is similar to the one from the previous recipe, although there are some differences:</p>
<ul>
<li class="bulletList">It is implemented as an inner type, so the name is <code class="inlineCode">promise_type</code>, since the coroutine framework requires the coroutine type to have an inner promise type with this name.</li>
<li class="bulletList">It supports handling exceptions that leave the coroutine block uncaught. In the previous recipe, this situation was not treated, and an <code class="inlineCode">unhandled_exception()</code> called <code class="inlineCode">std::terminate()</code> to abnormally terminate the process. This implementation, however, retries a pointer to the current exception and stores it in an <code class="inlineCode">std::exception_ptr</code> object. This exception is rethrown when iterating through the generated sequence (either when calling <code class="inlineCode">begin()</code> or when incrementing the iterator).</li>
<li class="bulletList">The functions <code class="inlineCode">return_value()</code> and <code class="inlineCode">return_void()</code> are not present, but replaced with <code class="inlineCode">yield_value()</code>, which is called when the <code class="inlineCode">co_yield expr</code> expression is resolved.</li>
</ul>
<p class="normal">The generator<a id="_idIndexMarker1573"/> class also bears some similarities to the task class from the previous recipe:</p>
<ul>
<li class="bulletList">It is default-constructible</li>
<li class="bulletList">It can be constructed from a promise object</li>
<li class="bulletList">It is not copy-constructible and copyable</li>
<li class="bulletList">It is move-constructible and moveable</li>
<li class="bulletList">Its destructor destroys the coroutine frame</li>
</ul>
<p class="normal">This class does not overload the <code class="inlineCode">co_await</code> operator, as it does not make sense to wait on the generator; instead, it provides the functions <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code>, which return iterator objects that enable iterating over the sequence of values. This generator is said to be lazy because it does not produce new values until the coroutine is resumed, either by calling <code class="inlineCode">begin()</code> or incrementing an iterator. The coroutine is created suspended, and its first execution begins only when calling the <code class="inlineCode">begin()</code> function. The execution continues either until the first <code class="inlineCode">co_yield</code> statement or until the coroutine completes its execution. Similarly, incrementing the iterator will resume the execution of the coroutine, which continues either until the next <code class="inlineCode">co_yield</code> statement or until its completion.</p>
<p class="normal">The following example shows a coroutine that produces several integer values. It does so not by using a loop but by repeating <code class="inlineCode">co_yield</code> statements:</p>
<pre class="programlisting code"><code class="hljs-code">generator&lt;int&gt; get_values() noexcept
{
  co_yield 1;
  co_yield 2;
  co_yield 3;
}
int main()
{
  for (auto i : get_values())
  {
    std::cout &lt;&lt; i &lt;&lt; ' ';
  }
}
</code></pre>
<p class="normal">An important<a id="_idIndexMarker1574"/> thing to note is that the coroutine can only use the <code class="inlineCode">co_yield</code> keyword and produce values synchronously. The use of the <code class="inlineCode">co_await</code> operator within the coroutine is not supported with this particular implementation. To be able to suspend execution by using the <code class="inlineCode">co_await</code> operator, a different implementation is required.</p>
<h2 class="heading-2" id="_idParaDest-816">There’s more...</h2>
<p class="normal">The <strong class="keyWord">libcoro</strong> library, mentioned <a id="_idIndexMarker1575"/>in the previous recipe, has a <code class="inlineCode">generator&lt;T&gt;</code> type that can be used instead of the one we created here. In fact, by replacing our <code class="inlineCode">generator&lt;T&gt;</code> with <code class="inlineCode">coro::generator&lt;T&gt;</code>, the snippets of code shown previously will continue to work as expected.</p>
<h2 class="heading-2" id="_idParaDest-817">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating a coroutine task type for asynchronous computations</em>, for an introduction to the C++20 coroutines</li>
</ul>
<h1 class="heading-1" id="_idParaDest-818">Generating a sequence of values with the std::generator type</h1>
<p class="normal">The C++20 standard includes two major updates to the standard library: the ranges library and coroutines. However, with regard to the latter, the support is minimal. The C++20 standard only defines a framework for building coroutines. Because of this, libraries such as <strong class="keyWord">libcoro</strong>, which <a id="_idIndexMarker1576"/>we have previously seen, were created to provide actual coroutines, such as <code class="inlineCode">task</code> and <code class="inlineCode">generator</code>, which we also saw in the previous two recipes. The C++23 standard introduces the first standard coroutine, called <code class="inlineCode">std::generator</code>. This <a id="_idIndexMarker1577"/>brings together ranges and coroutines because <code class="inlineCode">std::generator</code> is a view that represents a synchronous coroutine generator. This is a standard implementation for what we explicitly built in the previous recipe, <em class="italic">Creating a coroutine generator type for sequences of values</em>. Let’s see how it works.</p>
<div><p class="normal">At the time of writing, only GCC 14 supports this standard coroutine.</p>
</div>
<h2 class="heading-2" id="_idParaDest-819">How to do it…</h2>
<p class="normal">To generate a sequence of elements, in a lazy manner, write a coroutine that:</p>
<ul>
<li class="bulletList">Uses <code class="inlineCode">std::generator&lt;T&gt;</code> as the return type.</li>
<li class="bulletList">Uses the <code class="inlineCode">co_yield</code> statement to return a value.</li>
</ul>
<pre class="programlisting code"><code class="hljs-code">std::generator&lt;int&gt; iota(int start = 0, int step = 1) noexcept
{
  auto value = start;
  for (int i = 0;; ++i)
  {
    co_yield value;
    value += step;
  }
}
int main()
{
  for (auto i : iota())
  {
    std::cout &lt;&lt; i &lt;&lt; ' ';
    if (i &gt;= 10) break;
  }
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-820">How it works…</h2>
<p class="normal">The new <code class="inlineCode">std::generator</code> class template is available in its own header, called <code class="inlineCode">&lt;generator&gt;</code>. It derives from <code class="inlineCode">std::ranges::view_interface</code>; therefore, it is a view of elements that are yielded from the evaluation of a coroutine (an interruptible function). The class is defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class Ref, class V = void, class Allocator = void&gt;
class generator
 : public ranges::view_interface&lt;generator&lt;Ref, V, Allocator&gt;&gt;;
</code></pre>
<p class="normal">Every time the<a id="_idIndexMarker1578"/> coroutine is resumed and a <code class="inlineCode">co_yield</code> statement is evaluated, a new element of a sequence is produced. The following is an example that contains a series of <code class="inlineCode">co_yield</code> statements (not a loop). In total, this coroutine produces three elements. However, if the <code class="inlineCode">get_values()</code> coroutine is only evaluated once, it will only produce one element. We call this a lazy evaluation:</p>
<pre class="programlisting code"><code class="hljs-code">std::generator&lt;int&gt; get_values() noexcept
{
  co_yield 1;
  co_yield 2;
  co_yield 3;
}
</code></pre>
<p class="normal">The <code class="inlineCode">std::generator</code> type is a synchronous generator; the coroutine can only use the <code class="inlineCode">co_yield</code> statement to return values. It is not possible to use the <code class="inlineCode">co_await</code> operator within the coroutine. A different kind of generator would be required for that, and such a generator is not currently available.</p>
<p class="normal">Another example of using the <code class="inlineCode">std::generator</code> type to produce a sequence of values is the following, which generates the series of Fibonacci numbers. This is the same example that we saw in the previous recipe. The only change is that we replaced <code class="inlineCode">generator&lt;int&gt;</code> (which we wrote) with <code class="inlineCode">std::generator&lt;int&gt;</code>, which is available in the C++23<a id="_idIndexMarker1579"/> standard:</p>
<pre class="programlisting code"><code class="hljs-code">std::generator&lt;int&gt; fibonacci() noexcept
{
  int a = 0, b = 1;
  while (true)
  {
    co_yield b;
    auto tmp = a;
    a = b;
    b += tmp;
  }
}
int main()
{
  int c = 1;
  for (auto i : fibonacci())
  {
    std::cout &lt;&lt; i &lt;&lt; ' ';
    if (++c &gt; 10) break;
  }
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-821">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Iterating over collections with the ranges library</em>, to learn about the fundamentals of the C++ ranges library</li>
<li class="bulletList"><em class="italic">Creating a coroutine task type for asynchronous computations</em>, for an introduction to the C++20 coroutines</li>
<li class="bulletList"><em class="italic">Creating a coroutine generator type for sequences of values</em>, to learn how to enable the use of <code class="inlineCode">co_yield</code> to return multiple values from a coroutine</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_12.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>