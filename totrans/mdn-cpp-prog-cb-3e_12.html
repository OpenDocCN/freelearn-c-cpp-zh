<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer175">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 class="chapterTitle" id="_idParaDest-754"><span class="koboSpan" id="kobo.2.1">C++ 20 Core Features</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The new C++20 standard is a major step in the development of the C++ language. </span><span class="koboSpan" id="kobo.3.2">C++20 brings many new features both to the language and to the standard library. </span><span class="koboSpan" id="kobo.3.3">Some of these have already been discussed in previous chapters, such as the text formatting library, the calendar extensions to the chrono library, the changes to the thread support library, and many others. </span><span class="koboSpan" id="kobo.3.4">However, the features that impact the language the most are modules, concepts, coroutines, and the new ranges library. </span><span class="koboSpan" id="kobo.3.5">The specification of these features is very lengthy, which makes it difficult to cover them in great detail in this book. </span><span class="koboSpan" id="kobo.3.6">Therefore, in this chapter, we will look at the most important aspects and use cases of these features. </span><span class="koboSpan" id="kobo.3.7">This chapter is intended to help you start using these features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">This chapter includes the following recipes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Working with modules</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Understanding module partitions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Specifying requirements on template arguments with concepts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Using requires expressions and clauses</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Exploring abbreviated function templates</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Iterating over collections with the ranges library</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Exploring the standard range adaptors</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Converting a range to a container</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Creating your own range view</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Using constrained algorithms</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Creating a coroutine task type for asynchronous computations</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Creating a coroutine generator type for sequences of values</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Generating a sequence of values with the std::generator type</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.18.1">Let’s start this chapter by learning about modules, which are the most disruptive change that’s happened to the C++ language in decades.</span></p>
<h1 class="heading-1" id="_idParaDest-755"><span class="koboSpan" id="kobo.19.1">Working with modules</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.20.1">Modules are</span><a id="_idIndexMarker1421"/><span class="koboSpan" id="kobo.21.1"> one of the most important changes in the C++20 standard. </span><span class="koboSpan" id="kobo.21.2">They represent a fundamental change to the C++ language and the way we write and consume code. </span><span class="koboSpan" id="kobo.21.3">Modules are made available in source files that are compiled separately from the translation units that consume them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.22.1">Modules provide multiple</span><a id="_idIndexMarker1422"/><span class="koboSpan" id="kobo.23.1"> advantages, especially in comparison to the use of header files:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">They are only imported once, and the order they’re imported in does not matter.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">They do not require splitting interfaces and implementation in different source files, although this is still possible.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">Modules have the potential to reduce compilation time, in some cases significantly. </span><span class="koboSpan" id="kobo.26.2">The entities exported from a module are described in a binary file that the compiler can process faster than traditional precompiled headers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Moreover, this file can potentially be used to build integrations and interoperability with C++ code from other languages.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.28.1">In this recipe, you will learn how to get started with modules.</span></p>
<h2 class="heading-2" id="_idParaDest-756"><span class="koboSpan" id="kobo.29.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.30.1">At the time of writing, the major compilers (VC++, Clang, and GCC) provide different levels of support for modules. </span><span class="koboSpan" id="kobo.30.2">Build systems, such as CMake, are lagging in terms of adoption for modules (although this is likely to change in the near future). </span><span class="koboSpan" id="kobo.30.3">Because different compilers have different ways of, and different compiler options for, supporting modules, this book will not provide details on how to build these samples. </span><span class="koboSpan" id="kobo.30.4">You are invited to consult online documentation for specific compilers.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.31.1">The source code accompanying this book includes scripts for building the source code presented in this recipe and the next one, using the MSVC compiler (cl.exe) from Visual Studio 2019 16.8 and, respectively, Visual Studio 2022 17.x.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.32.1">There are several types of module files: </span><em class="italic"><span class="koboSpan" id="kobo.33.1">module interface units</span></em><span class="koboSpan" id="kobo.34.1">, </span><em class="italic"><span class="koboSpan" id="kobo.35.1">module interface partitions</span></em><span class="koboSpan" id="kobo.36.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.37.1">module implementation partitions</span></em><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">In this recipe, we’ll refer solely to the first; the other two, we will learn about in the next recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-757"><span class="koboSpan" id="kobo.39.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.40.1">When you</span><a id="_idIndexMarker1423"/><span class="koboSpan" id="kobo.41.1"> modularize your code, you can do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.42.1">Import a module using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">import</span></code><span class="koboSpan" id="kobo.44.1"> directive, followed by the module name. </span><span class="koboSpan" id="kobo.44.2">The standard library is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">std</span></code><span class="koboSpan" id="kobo.46.1"> module, but only starting with C++23. </span><span class="koboSpan" id="kobo.46.2">This allows us to write the following in C++23:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.47.1">import</span></span><span class="koboSpan" id="kobo.48.1"> std;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.49.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.50.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.51.1">()</span></span><span class="koboSpan" id="kobo.52.1">
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.53.1">println</span></span><span class="koboSpan" id="kobo.54.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.55.1">"Hello, world!"</span></span><span class="koboSpan" id="kobo.56.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.57.1">Prior to C++23, the standard library may be available as compiler-specific modules. </span><span class="koboSpan" id="kobo.57.2">The following snippet uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">std.core</span></code><span class="koboSpan" id="kobo.59.1"> module from Visual C++, which contains most of the functionality of the standard library, including the streams library:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.60.1">import</span></span><span class="koboSpan" id="kobo.61.1"> std.core;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.62.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.63.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.64.1">()</span></span><span class="koboSpan" id="kobo.65.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.66.1">"Hello, World!\n"</span></span><span class="koboSpan" id="kobo.67.1">;
}
</span></code></pre></li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.68.1">Export a module by creating </span><a id="_idIndexMarker1424"/><span class="koboSpan" id="kobo.69.1">a </span><strong class="keyWord"><span class="koboSpan" id="kobo.70.1">module interface unit</span></strong><span class="koboSpan" id="kobo.71.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.72.1">MIU</span></strong><span class="koboSpan" id="kobo.73.1">) that can contain functions, types, constants, and even macros. </span><span class="koboSpan" id="kobo.73.2">Their declaration must be preceded by the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">export</span></code><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">The module interface unit file must have the extension </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">.ixx</span></code><span class="koboSpan" id="kobo.77.1"> for VC++. </span><span class="koboSpan" id="kobo.77.2">Clang accepts different extensions, including </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">.cpp</span></code><span class="koboSpan" id="kobo.79.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">.cppm</span></code><span class="koboSpan" id="kobo.81.1">, and even </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">.ixx</span></code><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">The following sample exports a class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">point</span></code><span class="koboSpan" id="kobo.85.1">, a function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">distance()</span></code><span class="koboSpan" id="kobo.87.1"> that computes the distance between two </span><a id="_idIndexMarker1425"/><span class="koboSpan" id="kobo.88.1">points, and a user-defined literal operator called </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">_ip</span></code><span class="koboSpan" id="kobo.90.1"> that creates objects of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">point</span></code><span class="koboSpan" id="kobo.92.1"> from strings, in the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">"0,0"</span></code><span class="koboSpan" id="kobo.94.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">"12,-3"</span></code><span class="koboSpan" id="kobo.96.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.97.1">// --- geometry.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.98.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.99.1">module</span></span><span class="koboSpan" id="kobo.100.1"> geometry;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.101.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.102.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.103.1"> __cpp_lib_modules</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.104.1">import</span></span><span class="koboSpan" id="kobo.105.1"> std;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.106.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.107.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.108.1">import</span></span><span class="koboSpan" id="kobo.109.1"> std.core;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.110.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.111.1">endif</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.112.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">template</span></span><span class="koboSpan" id="kobo.114.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.115.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.116.1">T</span></span><span class="koboSpan" id="kobo.117.1">,
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.118.1">typename</span></span><span class="koboSpan" id="kobo.119.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.120.1">typename</span></span><span class="koboSpan" id="kobo.121.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.122.1">enable_if_t</span></span><span class="koboSpan" id="kobo.123.1">&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.124.1">struct</span></span><span class="koboSpan" id="kobo.125.1"> point
{
   T x;
   T y;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.126.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.127.1">using</span></span><span class="koboSpan" id="kobo.128.1"> int_point = point&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.129.1">int</span></span><span class="koboSpan" id="kobo.130.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.131.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.132.1">constexpr</span></span><span class="koboSpan" id="kobo.133.1"> int_point int_point_zero{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.134.1">0</span></span><span class="koboSpan" id="kobo.135.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.136.1">0</span></span><span class="koboSpan" id="kobo.137.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.139.1">template</span></span><span class="koboSpan" id="kobo.140.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.141.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.142.1">T</span></span><span class="koboSpan" id="kobo.143.1">&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.144.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.145.1">distance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.146.1">(point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.147.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.148.1">&amp; p1, point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.149.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.150.1">&amp; p2)</span></span><span class="koboSpan" id="kobo.151.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.152.1">return</span></span><span class="koboSpan" id="kobo.153.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.154.1">sqrt</span></span><span class="koboSpan" id="kobo.155.1">((p2.x - p1.x) * (p2.x - p1.x) +
                    (p2.y - p1.y) * (p2.y - p1.y));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.156.1">namespace</span></span><span class="koboSpan" id="kobo.157.1"> geometry_literals
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.158.1">export</span></span><span class="koboSpan" id="kobo.159.1"> int_point </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.161.1">""</span></span><span class="koboSpan" id="kobo.162.1">_ip(</span><span class="hljs-type"><span class="koboSpan" id="kobo.163.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.164.1">char</span></span><span class="koboSpan" id="kobo.165.1">* ptr, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.166.1">size_t</span></span><span class="koboSpan" id="kobo.167.1"> size)
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.168.1">int</span></span><span class="koboSpan" id="kobo.169.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.170.1">0</span></span><span class="koboSpan" id="kobo.171.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.172.1">0</span></span><span class="koboSpan" id="kobo.173.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.174.1">if</span></span><span class="koboSpan" id="kobo.175.1">(ptr)
      {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.176.1">while</span></span><span class="koboSpan" id="kobo.177.1"> (*ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.178.1">','</span></span><span class="koboSpan" id="kobo.179.1"> &amp;&amp; *ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.180.1">' '</span></span><span class="koboSpan" id="kobo.181.1">)
            x = x * </span><span class="hljs-number"><span class="koboSpan" id="kobo.182.1">10</span></span><span class="koboSpan" id="kobo.183.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.184.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.185.1">0'</span></span><span class="koboSpan" id="kobo.186.1">);
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.187.1">while</span></span><span class="koboSpan" id="kobo.188.1"> (*ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.189.1">','</span></span><span class="koboSpan" id="kobo.190.1"> || *ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.191.1">' '</span></span><span class="koboSpan" id="kobo.192.1">) ptr++;
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.193.1">while</span></span><span class="koboSpan" id="kobo.194.1"> (*ptr != </span><span class="hljs-number"><span class="koboSpan" id="kobo.195.1">0</span></span><span class="koboSpan" id="kobo.196.1">)
            y = y * </span><span class="hljs-number"><span class="koboSpan" id="kobo.197.1">10</span></span><span class="koboSpan" id="kobo.198.1"> + (*ptr++ - '</span><span class="hljs-number"><span class="koboSpan" id="kobo.199.1">0</span></span><span class="koboSpan" id="kobo.200.1">');
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">return</span></span><span class="koboSpan" id="kobo.202.1"> { x, y };
   }
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.203.1">// --- main.cpp ---</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.204.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.205.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.206.1"> __cpp_lib_modules</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.207.1">import</span></span><span class="koboSpan" id="kobo.208.1"> std;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.209.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.210.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.211.1">import</span></span><span class="koboSpan" id="kobo.212.1"> std.core;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.213.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">endif</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.215.1">import</span></span><span class="koboSpan" id="kobo.216.1"> geometry;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.217.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.218.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.219.1">()</span></span><span class="koboSpan" id="kobo.220.1">
{
   int_point p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.221.1">3</span></span><span class="koboSpan" id="kobo.222.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.223.1">4</span></span><span class="koboSpan" id="kobo.224.1"> };
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.225.1">distance</span></span><span class="koboSpan" id="kobo.226.1">(int_point_zero, p) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.227.1">'\n'</span></span><span class="koboSpan" id="kobo.228.1">;
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.229.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.230.1">namespace</span></span><span class="koboSpan" id="kobo.231.1"> geometry_literals;
      std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.232.1">distance</span></span><span class="koboSpan" id="kobo.233.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.234.1">"0,0"</span></span><span class="koboSpan" id="kobo.235.1">_ip, </span><span class="hljs-string"><span class="koboSpan" id="kobo.236.1">"30,40"</span></span><span class="koboSpan" id="kobo.237.1">_ip) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.238.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.239.1">\n'</span></span><span class="koboSpan" id="kobo.240.1">;
   }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.241.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">import</span></code><span class="koboSpan" id="kobo.243.1"> directive to also import the content of a header. </span><span class="koboSpan" id="kobo.243.2">The example</span><a id="_idIndexMarker1426"/><span class="koboSpan" id="kobo.244.1"> presented here uses the same type and functions seen in the preceding example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.245.1">// --- geometry.h ---</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.246.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.247.1">pragma</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.248.1"> once</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.249.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.251.1">&lt;cmath&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">template</span></span><span class="koboSpan" id="kobo.253.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.254.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.255.1">T</span></span><span class="koboSpan" id="kobo.256.1">,
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.257.1">typename</span></span><span class="koboSpan" id="kobo.258.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.259.1">typename</span></span><span class="koboSpan" id="kobo.260.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.261.1">enable_if_t</span></span><span class="koboSpan" id="kobo.262.1">&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">struct</span></span><span class="koboSpan" id="kobo.264.1"> point
{
   T x;
   T y;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.265.1">using</span></span><span class="koboSpan" id="kobo.266.1"> int_point = point&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.267.1">int</span></span><span class="koboSpan" id="kobo.268.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.269.1">constexpr</span></span><span class="koboSpan" id="kobo.270.1"> int_point int_point_zero{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.271.1">0</span></span><span class="koboSpan" id="kobo.272.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.273.1">0</span></span><span class="koboSpan" id="kobo.274.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.275.1">template</span></span><span class="koboSpan" id="kobo.276.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.277.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.278.1">T</span></span><span class="koboSpan" id="kobo.279.1">&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.280.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.281.1">distance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.282.1">(point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.283.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.284.1">&amp; p1, point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.285.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.286.1">&amp; p2)</span></span><span class="koboSpan" id="kobo.287.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.288.1">return</span></span><span class="koboSpan" id="kobo.289.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.290.1">sqrt</span></span><span class="koboSpan" id="kobo.291.1">((p2.x – p1.x) * (p2.x – p1.x) +
                    (p2.y – p1.y) * (p2.y – p1.y));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.292.1">namespace</span></span><span class="koboSpan" id="kobo.293.1"> geometry_literals
{
   int_point </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.295.1">""</span></span><span class="koboSpan" id="kobo.296.1">_ip(</span><span class="hljs-type"><span class="koboSpan" id="kobo.297.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.298.1">char</span></span><span class="koboSpan" id="kobo.299.1">* ptr, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.300.1">size_t</span></span><span class="koboSpan" id="kobo.301.1">)
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.302.1">int</span></span><span class="koboSpan" id="kobo.303.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.304.1">0</span></span><span class="koboSpan" id="kobo.305.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.306.1">0</span></span><span class="koboSpan" id="kobo.307.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.308.1">      if(ptr)</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.309.1">      {</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.310.1">while</span></span><span class="koboSpan" id="kobo.311.1"> (*ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.312.1">','</span></span><span class="koboSpan" id="kobo.313.1"> &amp;&amp; *ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.314.1">' '</span></span><span class="koboSpan" id="kobo.315.1">)
            x = x * </span><span class="hljs-number"><span class="koboSpan" id="kobo.316.1">10</span></span><span class="koboSpan" id="kobo.317.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.318.1">'0'</span></span><span class="koboSpan" id="kobo.319.1">);
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.320.1">while</span></span><span class="koboSpan" id="kobo.321.1"> (*ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.322.1">','</span></span><span class="koboSpan" id="kobo.323.1"> || *ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.324.1">' '</span></span><span class="koboSpan" id="kobo.325.1">) ptr++;
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.326.1">while</span></span><span class="koboSpan" id="kobo.327.1"> (*ptr != </span><span class="hljs-number"><span class="koboSpan" id="kobo.328.1">0</span></span><span class="koboSpan" id="kobo.329.1">)
            y = y * </span><span class="hljs-number"><span class="koboSpan" id="kobo.330.1">10</span></span><span class="koboSpan" id="kobo.331.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.332.1">'0'</span></span><span class="koboSpan" id="kobo.333.1">);
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.334.1">return</span></span><span class="koboSpan" id="kobo.335.1"> { x, y };
   }
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.336.1">// --- main.cpp ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.337.1">#ifdef __cpp_lib_modules</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">import std;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">#else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.340.1">import</span></span><span class="koboSpan" id="kobo.341.1"> std.core;
#endif
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.342.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.343.1">"geometry.h"</span></span><span class="koboSpan" id="kobo.344.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.345.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.346.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.347.1">()</span></span><span class="koboSpan" id="kobo.348.1">
{
   int_point p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.349.1">3</span></span><span class="koboSpan" id="kobo.350.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.351.1">4</span></span><span class="koboSpan" id="kobo.352.1"> };
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.353.1">distance</span></span><span class="koboSpan" id="kobo.354.1">(int_point_zero, p) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.355.1">'\n'</span></span><span class="koboSpan" id="kobo.356.1">;
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.357.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.358.1">namespace</span></span><span class="koboSpan" id="kobo.359.1"> geometry_literals;
      std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.360.1">distance</span></span><span class="koboSpan" id="kobo.361.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.362.1">"0,0"</span></span><span class="koboSpan" id="kobo.363.1">_ip, </span><span class="hljs-string"><span class="koboSpan" id="kobo.364.1">"30,40"</span></span><span class="koboSpan" id="kobo.365.1">_ip) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.366.1">'\n'</span></span><span class="koboSpan" id="kobo.367.1">;
   }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-758"><span class="koboSpan" id="kobo.368.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.369.1">A module unit</span><a id="_idIndexMarker1427"/><span class="koboSpan" id="kobo.370.1"> is composed of several parts, mandatory or optional:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.371.1">The </span><em class="italic"><span class="koboSpan" id="kobo.372.1">global module fragment</span></em><span class="koboSpan" id="kobo.373.1">, introduced with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">module;</span></code><span class="koboSpan" id="kobo.375.1"> statement. </span><span class="koboSpan" id="kobo.375.2">This part is optional and, if present, may</span><a id="_idIndexMarker1428"/><span class="koboSpan" id="kobo.376.1"> only contain preprocessor directives. </span><span class="koboSpan" id="kobo.376.2">Everything that is added here is said to belong to the </span><em class="italic"><span class="koboSpan" id="kobo.377.1">global module</span></em><span class="koboSpan" id="kobo.378.1">, which is</span><a id="_idIndexMarker1429"/><span class="koboSpan" id="kobo.379.1"> a collection of all the global module fragments and all the translation units that are not modules.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.380.1">The </span><em class="italic"><span class="koboSpan" id="kobo.381.1">module declaration</span></em><span class="koboSpan" id="kobo.382.1">, which is</span><a id="_idIndexMarker1430"/><span class="koboSpan" id="kobo.383.1"> a required statement of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">export</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.385.1">module name;</span></code><span class="koboSpan" id="kobo.386.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.387.1">The </span><em class="italic"><span class="koboSpan" id="kobo.388.1">module preamble</span></em><span class="koboSpan" id="kobo.389.1">, which is</span><a id="_idIndexMarker1431"/><span class="koboSpan" id="kobo.390.1"> optional and may only contain import declarations.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.391.1">The </span><em class="italic"><span class="koboSpan" id="kobo.392.1">module purview</span></em><span class="koboSpan" id="kobo.393.1">, which is</span><a id="_idIndexMarker1432"/><span class="koboSpan" id="kobo.394.1"> the content of the unit, starting with the module declaration and extending to the end of the module unit.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.395.1">The following </span><a id="_idIndexMarker1433"/><span class="koboSpan" id="kobo.396.1">diagram shows a module unit containing all of the aforementioned parts. </span><span class="koboSpan" id="kobo.396.2">On the left side, we have the source code of the module, and on the right side, the module parts are explained:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.397.1"><img alt="" src="../Images/B21549_12_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.398.1">Figure 12.1: An example of a module (on the left side) with each part highlighted and explained (on the right side)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.399.1">A module </span><a id="_idIndexMarker1434"/><span class="koboSpan" id="kobo.400.1">can export any entity, such as functions, classes, and constants. </span><span class="koboSpan" id="kobo.400.2">Every export must be preceded by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">export</span></code><span class="koboSpan" id="kobo.402.1"> keyword. </span><span class="koboSpan" id="kobo.402.2">This keyword is always the first keyword, preceding others such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">class</span></code><span class="koboSpan" id="kobo.404.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">struct</span></code><span class="koboSpan" id="kobo.406.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">template</span></code><span class="koboSpan" id="kobo.408.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">using</span></code><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">Several examples have been</span><a id="_idIndexMarker1435"/><span class="koboSpan" id="kobo.411.1"> provided in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.412.1">geometry</span></strong><span class="koboSpan" id="kobo.413.1"> module shown in the previous section:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.414.1">An E class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">point</span></code><span class="koboSpan" id="kobo.416.1">, which represents a point in the two-dimensional space</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.417.1">A type alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">point&lt;int&gt;</span></code><span class="koboSpan" id="kobo.419.1"> called </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">int_point</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.421.1">A compile-time constant called </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">int_point_zero</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.423.1">A function template, </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">distance()</span></code><span class="koboSpan" id="kobo.425.1">, that computes the distance between two points</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.426.1">A user-defined literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.427.1">_ip</span></code><span class="koboSpan" id="kobo.428.1"> that creates </span><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">int_point</span></code><span class="koboSpan" id="kobo.430.1"> objects from strings such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">"3,4"</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.432.1">A translation unit that uses modules instead of headers does not require any other changes, except for replacing </span><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">#include</span></code><span class="koboSpan" id="kobo.434.1"> preprocessor directives with </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">import</span></code><span class="koboSpan" id="kobo.436.1"> directives. </span><span class="koboSpan" id="kobo.436.2">Moreover, headers can also be imported as modules using the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">import</span></code><span class="koboSpan" id="kobo.438.1"> directive, as shown in an example earlier.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">There is no relationship between modules and namespaces. </span><span class="koboSpan" id="kobo.439.2">These two are independent concepts. </span><span class="koboSpan" id="kobo.439.3">The module </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">geometry</span></code><span class="koboSpan" id="kobo.441.1"> exports the user-defined literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">""_ip</span></code><span class="koboSpan" id="kobo.443.1"> in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">geometry_literals</span></code><span class="koboSpan" id="kobo.445.1">, while all the other exports in the module are available in the global namespace.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.446.1">There is also no relationship between the module names and the name of the unit file. </span><span class="koboSpan" id="kobo.446.2">The geometry module was defined in a file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">geometry.ixx</span></code><span class="koboSpan" id="kobo.448.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">.cppm</span></code><span class="koboSpan" id="kobo.450.1">, although any filename would have had the same result. </span><span class="koboSpan" id="kobo.450.2">It is recommended that you follow a consistent naming scheme and use the module name for the module filename too. </span><span class="koboSpan" id="kobo.450.3">On the other hand, the extension used for module units differs with each compiler, although this could be something that may change in the future when module support reaches maturity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.451.1">Prior to C++23, the standard library was not yet modularized. </span><span class="koboSpan" id="kobo.451.2">However, compilers have already made it available in modules. </span><span class="koboSpan" id="kobo.451.3">The Clang compiler provides a different module for each header. </span><span class="koboSpan" id="kobo.451.4">On the other hand, the Visual C++ compiler provides the following modules for the standard library:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">std.regex</span></code><span class="koboSpan" id="kobo.453.1">: The content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">&lt;regex&gt;</span></code><span class="koboSpan" id="kobo.455.1"> header</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">std.filesystem</span></code><span class="koboSpan" id="kobo.457.1">: The content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">&lt;filesystem&gt;</span></code><span class="koboSpan" id="kobo.459.1"> header</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">std.memory</span></code><span class="koboSpan" id="kobo.461.1">: The content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">&lt;memory&gt;</span></code><span class="koboSpan" id="kobo.463.1"> header</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">std.threading</span></code><span class="koboSpan" id="kobo.465.1">: The content of the headers </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">&lt;atomic&gt;</span></code><span class="koboSpan" id="kobo.467.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">&lt;condition_variable&gt;</span></code><span class="koboSpan" id="kobo.469.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">&lt;future&gt;</span></code><span class="koboSpan" id="kobo.471.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">&lt;mutex&gt;</span></code><span class="koboSpan" id="kobo.473.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">&lt;shared_mutex&gt;</span></code><span class="koboSpan" id="kobo.475.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">&lt;thread&gt;</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">std.core</span></code><span class="koboSpan" id="kobo.478.1">: The rest of the C++ standard library</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.479.1">As you can </span><a id="_idIndexMarker1436"/><span class="koboSpan" id="kobo.480.1">see from these module names, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">std.core</span></code><span class="koboSpan" id="kobo.482.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">std.regex</span></code><span class="koboSpan" id="kobo.484.1">, the name of the module can be a series of identifiers concatenated with a dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">.</span></code><span class="koboSpan" id="kobo.486.1">). </span><span class="koboSpan" id="kobo.486.2">The dot has no significance other than helping to split the name into parts representing a logical hierarchy, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">company.project.module</span></code><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">The use of a dot can arguably provide better readability compared to the use of an underscore (such as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">std_core</span></code><span class="koboSpan" id="kobo.490.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">std_regex</span></code><span class="koboSpan" id="kobo.492.1">), which is also legal, like anything else that may form an identifier.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.493.1">The C++23 standard, on the other</span><a id="_idIndexMarker1437"/><span class="koboSpan" id="kobo.494.1"> hand, provides two standardized named modules:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">std</span></code><span class="koboSpan" id="kobo.496.1">, which imports everything from the C++ standard headers (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">&lt;vector&gt;</span></code><span class="koboSpan" id="kobo.498.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">&lt;string&gt;</span></code><span class="koboSpan" id="kobo.500.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.502.1">, etc.) and C wrapper headers (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">&lt;cstdio&gt;</span></code><span class="koboSpan" id="kobo.504.1">) into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">std</span></code><span class="koboSpan" id="kobo.506.1"> namespace. </span><span class="koboSpan" id="kobo.506.2">You should use this module if you qualify everything with </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">std</span></code><span class="koboSpan" id="kobo.508.1"> and don’t want to pollute the global namespace.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">std.compat</span></code><span class="koboSpan" id="kobo.510.1">, which imports everything that </span><code class="inlineCode"><span class="koboSpan" id="kobo.511.1">std</span></code><span class="koboSpan" id="kobo.512.1"> does and, in addition, the global namespace counterparts of the C wrapper headers. </span><span class="koboSpan" id="kobo.512.2">For instance, if </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">std</span></code><span class="koboSpan" id="kobo.514.1"> imports </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">std::fopen</span></code><span class="koboSpan" id="kobo.516.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">std::fclose</span></code><span class="koboSpan" id="kobo.518.1"> (along with everything else) from </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">&lt;cstdio&gt;</span></code><span class="koboSpan" id="kobo.520.1">, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">std.compat</span></code><span class="koboSpan" id="kobo.522.1"> imports </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">::fopen</span></code><span class="koboSpan" id="kobo.524.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">::fclose</span></code><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">You should use this module if you want to migrate code more easily without having to qualify names with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">std</span></code><span class="koboSpan" id="kobo.528.1"> namespace (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">std::fopen</span></code><span class="koboSpan" id="kobo.530.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">fopen</span></code><span class="koboSpan" id="kobo.532.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">std::size_t</span></code><span class="koboSpan" id="kobo.534.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">size_t</span></code><span class="koboSpan" id="kobo.536.1">, etc.).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.537.1">As a programmer, you are familiar with the typical introductory program to any programming language called </span><em class="italic"><span class="koboSpan" id="kobo.538.1">“Hello, world!”</span></em><span class="koboSpan" id="kobo.539.1"> that simply prints this text to the console. </span><span class="koboSpan" id="kobo.539.2">In C++, the canonical form of this program used to be the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.540.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.541.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.542.1">&lt;iostream&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.543.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.544.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.545.1">()</span></span><span class="koboSpan" id="kobo.546.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.547.1">"Hello, world!\n"</span></span><span class="koboSpan" id="kobo.548.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.549.1">In C++23, with support for standardized modules and the new printing capabilities of the text formatting library, this program can look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.550.1">import</span></span><span class="koboSpan" id="kobo.551.1"> std;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.552.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.553.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.554.1">()</span></span><span class="koboSpan" id="kobo.555.1">
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.556.1">println</span></span><span class="koboSpan" id="kobo.557.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.558.1">"Hello, world!"</span></span><span class="koboSpan" id="kobo.559.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.560.1">You can check</span><a id="_idIndexMarker1438"/><span class="koboSpan" id="kobo.561.1"> whether the standard modules </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">std</span></code><span class="koboSpan" id="kobo.563.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">std.compat</span></code><span class="koboSpan" id="kobo.565.1"> are available using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">__cpp_lib_modules</span></code><span class="koboSpan" id="kobo.567.1"> feature macro.</span></p>
<h2 class="heading-2" id="_idParaDest-759"><span class="koboSpan" id="kobo.568.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.569.1">Understanding module partitions</span></em><span class="koboSpan" id="kobo.570.1">, to learn about interface and implementation partitions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-760"><span class="koboSpan" id="kobo.571.1">Understanding module partitions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.572.1">The source code of a module may become large and difficult to maintain. </span><span class="koboSpan" id="kobo.572.2">Moreover, a module may be composed of logically separate parts. </span><span class="koboSpan" id="kobo.572.3">To help with scenarios such as these, modules support composition from parts </span><a id="_idIndexMarker1439"/><span class="koboSpan" id="kobo.573.1">called </span><em class="italic"><span class="koboSpan" id="kobo.574.1">partitions</span></em><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">A module unit that is a partition that</span><a id="_idIndexMarker1440"/><span class="koboSpan" id="kobo.576.1"> exports entities is called a </span><em class="italic"><span class="koboSpan" id="kobo.577.1">module interface partition</span></em><span class="koboSpan" id="kobo.578.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.579.1">However, there could also be internal partitions that do not export anything. </span><span class="koboSpan" id="kobo.579.2">Such a partition unit is called </span><a id="_idIndexMarker1441"/><span class="koboSpan" id="kobo.580.1">a </span><em class="italic"><span class="koboSpan" id="kobo.581.1">module implementation partition</span></em><span class="koboSpan" id="kobo.582.1">. </span><span class="koboSpan" id="kobo.582.2">In this recipe, you will learn how to work with interface and implementation partitions.</span></p>
<h2 class="heading-2" id="_idParaDest-761"><span class="koboSpan" id="kobo.583.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.584.1">You should read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.585.1">Working with modules</span></em><span class="koboSpan" id="kobo.586.1">, before continuing with this one. </span><span class="koboSpan" id="kobo.586.2">You will need both the module fundamentals we discussed there and the code examples that we will continue with in this recipe.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.587.1">In the following examples, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.588.1">std</span></code><span class="koboSpan" id="kobo.589.1"> module, which is only available in C++23. </span><span class="koboSpan" id="kobo.589.2">For previous versions, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">std.core</span></code><span class="koboSpan" id="kobo.591.1"> in VC++ or other particular modules supported by your compiler.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-762"><span class="koboSpan" id="kobo.592.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.593.1">You can split a </span><a id="_idIndexMarker1442"/><span class="koboSpan" id="kobo.594.1">module into several partitions, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.595.1">Each partition unit must start with a statement of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.596.1">export module</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.597.1">modulename:partitionname;</span></code><span class="koboSpan" id="kobo.598.1">. </span><span class="koboSpan" id="kobo.598.2">Only the global module fragment may precede this declaration:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.599.1">// --- geometry-core.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">module</span></span><span class="koboSpan" id="kobo.602.1"> geometry:core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.603.1">import</span></span><span class="koboSpan" id="kobo.604.1"> std;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.605.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">template</span></span><span class="koboSpan" id="kobo.607.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.609.1">T</span></span><span class="koboSpan" id="kobo.610.1">,
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.611.1">typename</span></span><span class="koboSpan" id="kobo.612.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.613.1">typename</span></span><span class="koboSpan" id="kobo.614.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.615.1">enable_if_t</span></span><span class="koboSpan" id="kobo.616.1">&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">struct</span></span><span class="koboSpan" id="kobo.618.1"> point
{
   T x;
   T y;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.619.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.620.1">using</span></span><span class="koboSpan" id="kobo.621.1"> int_point = point&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.622.1">int</span></span><span class="koboSpan" id="kobo.623.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.625.1">constexpr</span></span><span class="koboSpan" id="kobo.626.1"> int_point int_point_zero{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.627.1">0</span></span><span class="koboSpan" id="kobo.628.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.629.1">0</span></span><span class="koboSpan" id="kobo.630.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.631.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.632.1">template</span></span><span class="koboSpan" id="kobo.633.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.634.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.635.1">T</span></span><span class="koboSpan" id="kobo.636.1">&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.637.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.638.1">distance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.639.1">(point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.640.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.641.1">&amp; p1, point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.642.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.643.1">&amp; p2)</span></span><span class="koboSpan" id="kobo.644.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.645.1">return</span></span><span class="koboSpan" id="kobo.646.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.647.1">sqrt</span></span><span class="koboSpan" id="kobo.648.1">((p2.x - p1.x) * (p2.x - p1.x) +
                    (p2.y - p1.y) * (p2.y - p1.y));
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.649.1">// --- geometry-literals.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.650.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">module</span></span><span class="koboSpan" id="kobo.652.1"> geometry:literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.653.1">import</span></span><span class="koboSpan" id="kobo.654.1"> :core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.655.1">namespace</span></span><span class="koboSpan" id="kobo.656.1"> geometry_literals
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.657.1">export</span></span><span class="koboSpan" id="kobo.658.1"> int_point </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.660.1">""</span></span><span class="koboSpan" id="kobo.661.1">_ip(</span><span class="hljs-type"><span class="koboSpan" id="kobo.662.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.663.1">char</span></span><span class="koboSpan" id="kobo.664.1">* ptr, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.665.1">size_t</span></span><span class="koboSpan" id="kobo.666.1">)
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.667.1">int</span></span><span class="koboSpan" id="kobo.668.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.669.1">0</span></span><span class="koboSpan" id="kobo.670.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.671.1">0</span></span><span class="koboSpan" id="kobo.672.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.673.1">      if(ptr)</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.674.1">      {</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.675.1">while</span></span><span class="koboSpan" id="kobo.676.1"> (*ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.677.1">','</span></span><span class="koboSpan" id="kobo.678.1"> &amp;&amp; *ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.679.1">' '</span></span><span class="koboSpan" id="kobo.680.1">)
            x = x * </span><span class="hljs-number"><span class="koboSpan" id="kobo.681.1">10</span></span><span class="koboSpan" id="kobo.682.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.683.1">'0'</span></span><span class="koboSpan" id="kobo.684.1">);
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.685.1">while</span></span><span class="koboSpan" id="kobo.686.1"> (*ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.687.1">','</span></span><span class="koboSpan" id="kobo.688.1"> || *ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.689.1">' '</span></span><span class="koboSpan" id="kobo.690.1">) ptr++;
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.691.1">while</span></span><span class="koboSpan" id="kobo.692.1"> (*ptr != </span><span class="hljs-number"><span class="koboSpan" id="kobo.693.1">0</span></span><span class="koboSpan" id="kobo.694.1">)
            y = y * </span><span class="hljs-number"><span class="koboSpan" id="kobo.695.1">10</span></span><span class="koboSpan" id="kobo.696.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.697.1">'0'</span></span><span class="koboSpan" id="kobo.698.1">);
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">return</span></span><span class="koboSpan" id="kobo.700.1"> { x, y };
   }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.701.1">In the </span><a id="_idIndexMarker1443"/><span class="koboSpan" id="kobo.702.1">primary module interface unit, import and then export the partitions with statements of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">export import :partitionname</span></code><span class="koboSpan" id="kobo.704.1">, such as in the following example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.705.1">// --- geometry.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.706.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.707.1">module</span></span><span class="koboSpan" id="kobo.708.1"> geometry;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.709.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.710.1">import</span></span><span class="koboSpan" id="kobo.711.1"> :core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.712.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.713.1">import</span></span><span class="koboSpan" id="kobo.714.1"> :literals;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.715.1">The code importing a module composed from multiple partitions only sees the module as a whole if it was built from a single module unit:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.716.1">// --- main.cpp ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">import</span></span><span class="koboSpan" id="kobo.718.1"> std;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.719.1">import</span></span><span class="koboSpan" id="kobo.720.1"> geometry;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.721.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.722.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.723.1">()</span></span><span class="koboSpan" id="kobo.724.1">
{
   int_point p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.725.1">3</span></span><span class="koboSpan" id="kobo.726.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.727.1">4</span></span><span class="koboSpan" id="kobo.728.1"> };
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.729.1">distance</span></span><span class="koboSpan" id="kobo.730.1">(int_point_zero, p) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.731.1">'\n'</span></span><span class="koboSpan" id="kobo.732.1">;
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.733.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.734.1">namespace</span></span><span class="koboSpan" id="kobo.735.1"> geometry_literals;
      std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.736.1">distance</span></span><span class="koboSpan" id="kobo.737.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.738.1">"0,0"</span></span><span class="koboSpan" id="kobo.739.1">_ip, </span><span class="hljs-string"><span class="koboSpan" id="kobo.740.1">"30,40"</span></span><span class="koboSpan" id="kobo.741.1">_ip) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.742.1">'\n'</span></span><span class="koboSpan" id="kobo.743.1">;
   }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.744.1">It is possible to create</span><a id="_idIndexMarker1444"/><span class="koboSpan" id="kobo.745.1"> internal partitions that do not export anything but contain code that can be used in the same module. </span><span class="koboSpan" id="kobo.745.2">Such a partition must start with a statement of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">module modulename:partitionname;</span></code><span class="koboSpan" id="kobo.747.1"> (without the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">export</span></code><span class="koboSpan" id="kobo.749.1">). </span><span class="koboSpan" id="kobo.749.2">Different compilers may also require a different extension for the file containing an internal partition. </span><span class="koboSpan" id="kobo.749.3">For VC++, the extension must be </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">.cpp</span></code><span class="koboSpan" id="kobo.751.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.752.1">// --- geometry-details.cpp --</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.753.1">module</span></span><span class="koboSpan" id="kobo.754.1"> geometry:details;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.755.1">import</span></span><span class="koboSpan" id="kobo.756.1"> std;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.757.1">std::pair&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.758.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.759.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.760.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.761.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.762.1">split</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.763.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.764.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.765.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.766.1">* ptr)</span></span><span class="koboSpan" id="kobo.767.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.768.1">int</span></span><span class="koboSpan" id="kobo.769.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.770.1">0</span></span><span class="koboSpan" id="kobo.771.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.772.1">0</span></span><span class="koboSpan" id="kobo.773.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.774.1">  if(ptr)</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.775.1">  {</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">while</span></span><span class="koboSpan" id="kobo.777.1"> (*ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.778.1">','</span></span><span class="koboSpan" id="kobo.779.1"> &amp;&amp; *ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.780.1">' '</span></span><span class="koboSpan" id="kobo.781.1">)
      x = x * </span><span class="hljs-number"><span class="koboSpan" id="kobo.782.1">10</span></span><span class="koboSpan" id="kobo.783.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.784.1">'0'</span></span><span class="koboSpan" id="kobo.785.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.786.1">while</span></span><span class="koboSpan" id="kobo.787.1"> (*ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.788.1">','</span></span><span class="koboSpan" id="kobo.789.1"> || *ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.790.1">' '</span></span><span class="koboSpan" id="kobo.791.1">) ptr++;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.792.1">while</span></span><span class="koboSpan" id="kobo.793.1"> (*ptr != </span><span class="hljs-number"><span class="koboSpan" id="kobo.794.1">0</span></span><span class="koboSpan" id="kobo.795.1">)
      y = y * </span><span class="hljs-number"><span class="koboSpan" id="kobo.796.1">10</span></span><span class="koboSpan" id="kobo.797.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.798.1">'0'</span></span><span class="koboSpan" id="kobo.799.1">);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.800.1">return</span></span><span class="koboSpan" id="kobo.801.1"> { x, y };
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.802.1">// --- geometry-literals.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.803.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.804.1">module</span></span><span class="koboSpan" id="kobo.805.1"> geometry:literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.806.1">import</span></span><span class="koboSpan" id="kobo.807.1"> :core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.808.1">import</span></span><span class="koboSpan" id="kobo.809.1"> :details;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.810.1">namespace</span></span><span class="koboSpan" id="kobo.811.1"> geometry_literals
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.812.1">export</span></span><span class="koboSpan" id="kobo.813.1"> int_point </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.814.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.815.1">""</span></span><span class="koboSpan" id="kobo.816.1">_ip(</span><span class="hljs-type"><span class="koboSpan" id="kobo.817.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.818.1">char</span></span><span class="koboSpan" id="kobo.819.1">* ptr, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.820.1">size_t</span></span><span class="koboSpan" id="kobo.821.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">auto</span></span><span class="koboSpan" id="kobo.823.1"> [x, y] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.824.1">split</span></span><span class="koboSpan" id="kobo.825.1">(ptr);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.826.1">return</span></span><span class="koboSpan" id="kobo.827.1"> {x, y};
  }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-763"><span class="koboSpan" id="kobo.828.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.829.1">The code</span><a id="_idIndexMarker1445"/><span class="koboSpan" id="kobo.830.1"> shown earlier is a follow-up of the modules example presented in the previous recipe. </span><span class="koboSpan" id="kobo.830.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">geometry</span></code><span class="koboSpan" id="kobo.832.1"> module has been split into two different partitions called </span><code class="inlineCode"><span class="koboSpan" id="kobo.833.1">core</span></code><span class="koboSpan" id="kobo.834.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.835.1">literals</span></code><span class="koboSpan" id="kobo.836.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.837.1">However, when you declare the partition, you must use the name in the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.838.1">modulename:partitionname</span></code><span class="koboSpan" id="kobo.839.1">, such as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.840.1">geometry:core</span></code><span class="koboSpan" id="kobo.841.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">geometry:literals</span></code><span class="koboSpan" id="kobo.843.1">. </span><span class="koboSpan" id="kobo.843.2">This is not necessary when you import a partition elsewhere in the module. </span><span class="koboSpan" id="kobo.843.3">This can be seen both in the primary partition unit </span><code class="inlineCode"><span class="koboSpan" id="kobo.844.1">geometry.ixx</span></code><span class="koboSpan" id="kobo.845.1"> and in the module interface partition </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">geometry-literals.ixx</span></code><span class="koboSpan" id="kobo.847.1">. </span><span class="koboSpan" id="kobo.847.2">Here are the snippets again, for clarity:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.848.1">// --- geometry-literals.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.849.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.850.1">module</span></span><span class="koboSpan" id="kobo.851.1"> geometry:literals;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.852.1">// import the core partition</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">import</span></span><span class="koboSpan" id="kobo.854.1"> :core;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.855.1">// --- geometry.ixx/.cppm ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.856.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.857.1">module</span></span><span class="koboSpan" id="kobo.858.1"> geometry;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.859.1">// import the core partition and then export it</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.860.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.861.1">import</span></span><span class="koboSpan" id="kobo.862.1"> :core;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.863.1">// import the literals partition and then export it</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.864.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.865.1">import</span></span><span class="koboSpan" id="kobo.866.1"> :literals;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.867.1">Although module partitions are distinct files, they are not available as separate modules or submodules to translation units using a module. </span><span class="koboSpan" id="kobo.867.2">They are exported together as a single, aggregated module. </span><span class="koboSpan" id="kobo.867.3">If you compare the source code in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">main.cpp</span></code><span class="koboSpan" id="kobo.869.1"> file with the one from the previous recipe, you will see no difference.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.870.1">As with module interface units, there are no rules for naming the files containing partitions. </span><span class="koboSpan" id="kobo.870.2">However, compilers may require different extensions or support some particular naming schemes. </span><span class="koboSpan" id="kobo.870.3">For instance, VC++ uses the scheme </span><code class="inlineCode"><span class="koboSpan" id="kobo.871.1">&lt;module-name&gt;-&lt;partition-name&gt;.ixx</span></code><span class="koboSpan" id="kobo.872.1">, which simplifies build commands.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.873.1">Partitions, just like modules, may contain code that is not exported from the module. </span><span class="koboSpan" id="kobo.873.2">A partition may contain no exports at all, in which case it is an internal partition only. </span><span class="koboSpan" id="kobo.873.3">Such a partition is called</span><a id="_idIndexMarker1446"/><span class="koboSpan" id="kobo.874.1"> a </span><em class="italic"><span class="koboSpan" id="kobo.875.1">module implementation partition</span></em><span class="koboSpan" id="kobo.876.1">. </span><span class="koboSpan" id="kobo.876.2">It is defined without using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.877.1">export</span></code><span class="koboSpan" id="kobo.878.1"> keyword in the module’s declaration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.879.1">An example of an</span><a id="_idIndexMarker1447"/><span class="koboSpan" id="kobo.880.1"> internal partition is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">geometry:details</span></code><span class="koboSpan" id="kobo.882.1"> partition shown earlier. </span><span class="koboSpan" id="kobo.882.2">It provides a helper function, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.883.1">split()</span></code><span class="koboSpan" id="kobo.884.1">, to parse two integers separated with a comma from a string. </span><span class="koboSpan" id="kobo.884.2">This partition is then imported into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.885.1">geometry:literals</span></code><span class="koboSpan" id="kobo.886.1"> partitions, where the </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">split()</span></code><span class="koboSpan" id="kobo.888.1"> function is used to implement the user-defined literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">_ip</span></code><span class="koboSpan" id="kobo.890.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-764"><span class="koboSpan" id="kobo.891.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.892.1">Partitions are divisions of a module. </span><span class="koboSpan" id="kobo.892.2">However, they are not submodules. </span><span class="koboSpan" id="kobo.892.3">They do not logically exist outside of the module. </span><span class="koboSpan" id="kobo.892.4">There is no concept of a submodule in the C++ language. </span><span class="koboSpan" id="kobo.892.5">The code shown in this recipe using partitions could be written slightly differently using modules:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.893.1">// --- geometry-core.ixx ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.894.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.895.1">module</span></span><span class="koboSpan" id="kobo.896.1"> geometry.core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.897.1">import</span></span><span class="koboSpan" id="kobo.898.1"> std;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.899.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.900.1">template</span></span><span class="koboSpan" id="kobo.901.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.902.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.903.1">T</span></span><span class="koboSpan" id="kobo.904.1">,
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.905.1">typename</span></span><span class="koboSpan" id="kobo.906.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.907.1">typename</span></span><span class="koboSpan" id="kobo.908.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.909.1">enable_if_t</span></span><span class="koboSpan" id="kobo.910.1">&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.911.1">struct</span></span><span class="koboSpan" id="kobo.912.1"> point
{
   T x;
   T y;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.913.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.914.1">using</span></span><span class="koboSpan" id="kobo.915.1"> int_point = point&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.916.1">int</span></span><span class="koboSpan" id="kobo.917.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.918.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.919.1">constexpr</span></span><span class="koboSpan" id="kobo.920.1"> int_point int_point_zero{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.921.1">0</span></span><span class="koboSpan" id="kobo.922.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.923.1">0</span></span><span class="koboSpan" id="kobo.924.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.925.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">template</span></span><span class="koboSpan" id="kobo.927.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.929.1">T</span></span><span class="koboSpan" id="kobo.930.1">&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.931.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.932.1">distance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.933.1">(point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.934.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.935.1">&amp; p1, point&lt;T&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.936.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.937.1">&amp; p2)</span></span><span class="koboSpan" id="kobo.938.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.939.1">return</span></span><span class="koboSpan" id="kobo.940.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.941.1">sqrt</span></span><span class="koboSpan" id="kobo.942.1">(
      (p2.x - p1.x) * (p2.x - p1.x) +
      (p2.y - p1.y) * (p2.y - p1.y));
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.943.1">// --- geometry-literals.ixx ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.944.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">module</span></span><span class="koboSpan" id="kobo.946.1"> geometry.literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.947.1">import</span></span><span class="koboSpan" id="kobo.948.1"> geometry.core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.949.1">namespace</span></span><span class="koboSpan" id="kobo.950.1"> geometry_literals
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.951.1">export</span></span><span class="koboSpan" id="kobo.952.1"> int_point </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.953.1">operator</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.954.1">""</span></span><span class="koboSpan" id="kobo.955.1">_ip(</span><span class="hljs-type"><span class="koboSpan" id="kobo.956.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.957.1">char</span></span><span class="koboSpan" id="kobo.958.1">* ptr, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.959.1">size_t</span></span><span class="koboSpan" id="kobo.960.1">)
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.961.1">int</span></span><span class="koboSpan" id="kobo.962.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.963.1">0</span></span><span class="koboSpan" id="kobo.964.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.965.1">0</span></span><span class="koboSpan" id="kobo.966.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.967.1">      if(ptr)</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.968.1">      {</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">while</span></span><span class="koboSpan" id="kobo.970.1"> (*ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.971.1">','</span></span><span class="koboSpan" id="kobo.972.1"> &amp;&amp; *ptr != </span><span class="hljs-string"><span class="koboSpan" id="kobo.973.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.974.1"> '</span></span><span class="koboSpan" id="kobo.975.1">)
            x = x * </span><span class="hljs-number"><span class="koboSpan" id="kobo.976.1">10</span></span><span class="koboSpan" id="kobo.977.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.978.1">'0'</span></span><span class="koboSpan" id="kobo.979.1">);
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">while</span></span><span class="koboSpan" id="kobo.981.1"> (*ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.982.1">','</span></span><span class="koboSpan" id="kobo.983.1"> || *ptr == </span><span class="hljs-string"><span class="koboSpan" id="kobo.984.1">' '</span></span><span class="koboSpan" id="kobo.985.1">) ptr++;
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.986.1">while</span></span><span class="koboSpan" id="kobo.987.1"> (*ptr != </span><span class="hljs-number"><span class="koboSpan" id="kobo.988.1">0</span></span><span class="koboSpan" id="kobo.989.1">)
            y = y * </span><span class="hljs-number"><span class="koboSpan" id="kobo.990.1">10</span></span><span class="koboSpan" id="kobo.991.1"> + (*ptr++ - </span><span class="hljs-string"><span class="koboSpan" id="kobo.992.1">'0'</span></span><span class="koboSpan" id="kobo.993.1">);
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">return</span></span><span class="koboSpan" id="kobo.995.1"> { x, y };
   }
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.996.1">// --- geometry.ixx ---</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.997.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.998.1">module</span></span><span class="koboSpan" id="kobo.999.1"> geometry;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1000.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">import</span></span><span class="koboSpan" id="kobo.1002.1"> geometry.core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1003.1">export</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1004.1">import</span></span><span class="koboSpan" id="kobo.1005.1"> geometry.literals;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1006.1">In this example, we have three modules: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1007.1">geometry.core</span></code><span class="koboSpan" id="kobo.1008.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">geometry.literals</span></code><span class="koboSpan" id="kobo.1010.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1011.1">geometry</span></code><span class="koboSpan" id="kobo.1012.1">. </span><span class="koboSpan" id="kobo.1012.2">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1013.1">geometry</span></code><span class="koboSpan" id="kobo.1014.1"> imports and then re-exports the entire content of the first two. </span><span class="koboSpan" id="kobo.1014.2">Because of this, the code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">main.cpp</span></code><span class="koboSpan" id="kobo.1016.1"> does not need to change. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1017.1">By solely importing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">geometry</span></code><span class="koboSpan" id="kobo.1019.1"> module, we get access to the content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">geometry.core</span></code><span class="koboSpan" id="kobo.1021.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">geometry.literals</span></code><span class="koboSpan" id="kobo.1023.1"> modules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1024.1">However, if we do not </span><a id="_idIndexMarker1448"/><span class="koboSpan" id="kobo.1025.1">define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">geometry</span></code><span class="koboSpan" id="kobo.1027.1"> module anymore, then we need to explicitly import the two modules, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1028.1">import</span></span><span class="koboSpan" id="kobo.1029.1"> std;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1030.1">import</span></span><span class="koboSpan" id="kobo.1031.1"> geometry.core;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1032.1">import</span></span><span class="koboSpan" id="kobo.1033.1"> geometry.literals;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1034.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1035.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1036.1">()</span></span><span class="koboSpan" id="kobo.1037.1">
{
   int_point p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1038.1">3</span></span><span class="koboSpan" id="kobo.1039.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1040.1">4</span></span><span class="koboSpan" id="kobo.1041.1"> };
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1042.1">distance</span></span><span class="koboSpan" id="kobo.1043.1">(int_point_zero, p) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1044.1">'\n'</span></span><span class="koboSpan" id="kobo.1045.1">;
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1046.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1047.1">namespace</span></span><span class="koboSpan" id="kobo.1048.1"> geometry_literals;
      std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1049.1">distance</span></span><span class="koboSpan" id="kobo.1050.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1051.1">"0,0"</span></span><span class="koboSpan" id="kobo.1052.1">_ip, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1053.1">"30,40"</span></span><span class="koboSpan" id="kobo.1054.1">_ip) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1055.1">'\n'</span></span><span class="koboSpan" id="kobo.1056.1">;
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1057.1">Choosing between using </span><a id="_idIndexMarker1449"/><span class="koboSpan" id="kobo.1058.1">partitions or multiple modules to componentize your source code should depend on the particularities of your project. </span><span class="koboSpan" id="kobo.1058.2">If you use multiple smaller modules, you provide better granularity for imports. </span><span class="koboSpan" id="kobo.1058.3">This can be important if you’re developing a large library because users should only import things they use (and not a very large module when they only need some functionalities).</span></p>
<h2 class="heading-2" id="_idParaDest-765"><span class="koboSpan" id="kobo.1059.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1060.1">Working with modules</span></em><span class="koboSpan" id="kobo.1061.1">, to explore the fundamentals of C++20 modules</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-766"><span class="koboSpan" id="kobo.1062.1">Specifying requirements on template arguments with concepts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1063.1">Template metaprogramming</span><a id="_idIndexMarker1450"/><span class="koboSpan" id="kobo.1064.1"> is an important part of the C++ language, empowering the development of general-purpose libraries, including the standard library. </span><span class="koboSpan" id="kobo.1064.2">However, template metaprogramming is not trivial. </span><span class="koboSpan" id="kobo.1064.3">On the contrary, complex tasks could be tedious and difficult to get right without a lot of experience. </span><span class="koboSpan" id="kobo.1064.4">In fact, the C++ Core Guidelines, an initiative created by Bjarne Stroustrup and Herb Sutter, have a rule called </span><em class="italic"><span class="koboSpan" id="kobo.1065.1">Use template metaprogramming only when you really need to,</span></em><span class="koboSpan" id="kobo.1066.1"> which reasons that:</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.1067.1">Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain.</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.1068.1">An important aspect concerning template metaprogramming has been the specification of constraints for type template parameters, in order to impose restrictions on the types that a template can be instantiated with. </span><span class="koboSpan" id="kobo.1068.2">The C++20 concepts library is designed to solve this problem. </span><span class="koboSpan" id="kobo.1068.3">A concept</span><a id="_idIndexMarker1451"/><span class="koboSpan" id="kobo.1069.1"> is a named set of constraints, and a constraint is a requirement for a template argument. </span><span class="koboSpan" id="kobo.1069.2">These are used to select the appropriate function overloads and template specializations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1070.1">In this recipe, we will see how we can use C++20 concepts to specify requirements on template arguments.</span></p>
<h2 class="heading-2" id="_idParaDest-767"><span class="koboSpan" id="kobo.1071.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1072.1">Before we </span><a id="_idIndexMarker1452"/><span class="koboSpan" id="kobo.1073.1">begin learning about </span><a id="_idIndexMarker1453"/><span class="koboSpan" id="kobo.1074.1">concepts, let’s consider the following class template, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">NumericalValue</span></code><span class="koboSpan" id="kobo.1076.1">, which is supposed to hold a value of an integral or floating-point type. </span><span class="koboSpan" id="kobo.1076.2">This C++11 implementation employs the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1078.1"> to specify requirements for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">T</span></code><span class="koboSpan" id="kobo.1080.1"> template argument:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">template</span></span><span class="koboSpan" id="kobo.1082.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1083.1">typename</span></span><span class="koboSpan" id="kobo.1084.1"> T&gt;,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1085.1">typename</span></span><span class="koboSpan" id="kobo.1086.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1087.1">typename</span></span><span class="koboSpan" id="kobo.1088.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1089.1">enable_if_t</span></span><span class="koboSpan" id="kobo.1090.1">&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1091.1">struct</span></span><span class="koboSpan" id="kobo.1092.1"> NumericalValue
{
  T value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1093.1">template</span></span><span class="koboSpan" id="kobo.1094.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1095.1">typename</span></span><span class="koboSpan" id="kobo.1096.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1097.1">NumericalValue&lt;T&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1098.1">wrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1099.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1100.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1101.1">return</span></span><span class="koboSpan" id="kobo.1102.1"> { value }; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1103.1">template</span></span><span class="koboSpan" id="kobo.1104.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1105.1">typename</span></span><span class="koboSpan" id="kobo.1106.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1107.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1108.1">unwrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1109.1">(NumericalValue&lt;T&gt; t)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1110.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1111.1">return</span></span><span class="koboSpan" id="kobo.1112.1"> t.value; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1113.1">auto</span></span><span class="koboSpan" id="kobo.1114.1"> nv = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1115.1">wrap</span></span><span class="koboSpan" id="kobo.1116.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1117.1">42</span></span><span class="koboSpan" id="kobo.1118.1">);
std::cout &lt;&lt; nv.value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1119.1">'\n'</span></span><span class="koboSpan" id="kobo.1120.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1121.1">// prints 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1122.1">auto</span></span><span class="koboSpan" id="kobo.1123.1"> v = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1124.1">unwrap</span></span><span class="koboSpan" id="kobo.1125.1">(nv);
std::cout &lt;&lt; v &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1126.1">'\n'</span></span><span class="koboSpan" id="kobo.1127.1">;          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1128.1">// prints 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1129.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1130.1">namespace</span></span><span class="koboSpan" id="kobo.1131.1"> std::string_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1132.1">auto</span></span><span class="koboSpan" id="kobo.1133.1"> ns = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1134.1">wrap</span></span><span class="koboSpan" id="kobo.1135.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1136.1">"42"</span></span><span class="koboSpan" id="kobo.1137.1">s);           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1138.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1139.1">This snippet will be the basis for the examples shown in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-768"><span class="koboSpan" id="kobo.1140.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">You can specify requirements for template arguments as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1142.1">Create a concept using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1143.1">concept</span></code><span class="koboSpan" id="kobo.1144.1"> keyword with the following form:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1145.1">template</span></span><span class="koboSpan" id="kobo.1146.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1147.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1148.1">T</span></span><span class="koboSpan" id="kobo.1149.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1150.1">concept</span></span><span class="koboSpan" id="kobo.1151.1"> Numerical = std::is_arithmetic_v&lt;T&gt;;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1152.1">Alternatively, you can use one of the standard-defined concepts, available in the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.1153.1">&lt;concepts&gt;</span></code><span class="koboSpan" id="kobo.1154.1"> (or one of the other standard library headers):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1155.1">template</span></span><span class="koboSpan" id="kobo.1156.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1157.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1158.1">T</span></span><span class="koboSpan" id="kobo.1159.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1160.1">concept</span></span><span class="koboSpan" id="kobo.1161.1"> Numerical = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1162.1">Use the concept name instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1163.1">class</span></code><span class="koboSpan" id="kobo.1164.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1165.1">typename</span></code><span class="koboSpan" id="kobo.1166.1"> keywords in function templates, class templates, or variable templates:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1167.1">template</span></span><span class="koboSpan" id="kobo.1168.1"> &lt;Numerical T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1169.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1170.1">NumericalValue</span></span><span class="koboSpan" id="kobo.1171.1">
{
  T value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1172.1">template</span></span><span class="koboSpan" id="kobo.1173.1"> &lt;Numerical T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1174.1">NumericalValue&lt;T&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1175.1">wrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1176.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1177.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1178.1">return</span></span><span class="koboSpan" id="kobo.1179.1"> { value }; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1180.1">template</span></span><span class="koboSpan" id="kobo.1181.1"> &lt;Numerical T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1182.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1183.1">unwrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1184.1">(NumericalValue&lt;T&gt; t)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1185.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1186.1">return</span></span><span class="koboSpan" id="kobo.1187.1"> t.value; }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1188.1">Instantiate</span><a id="_idIndexMarker1454"/><span class="koboSpan" id="kobo.1189.1"> class templates </span><a id="_idIndexMarker1455"/><span class="koboSpan" id="kobo.1190.1">and call function templates with no changes in syntax:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1191.1">auto</span></span><span class="koboSpan" id="kobo.1192.1"> nv = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1193.1">wrap</span></span><span class="koboSpan" id="kobo.1194.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1195.1">42</span></span><span class="koboSpan" id="kobo.1196.1">);
std::cout &lt;&lt; nv.value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1197.1">'\n'</span></span><span class="koboSpan" id="kobo.1198.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1199.1">// prints 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1200.1">auto</span></span><span class="koboSpan" id="kobo.1201.1"> v = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1202.1">unwrap</span></span><span class="koboSpan" id="kobo.1203.1">(nv);
std::cout &lt;&lt; v &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1204.1">'\n'</span></span><span class="koboSpan" id="kobo.1205.1">;          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1206.1">// prints 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1207.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1208.1">namespace</span></span><span class="koboSpan" id="kobo.1209.1"> std::string_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1210.1">auto</span></span><span class="koboSpan" id="kobo.1211.1"> ns = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1212.1">wrap</span></span><span class="koboSpan" id="kobo.1213.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1214.1">"42"</span></span><span class="koboSpan" id="kobo.1215.1">s);           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1216.1">// error</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-769"><span class="koboSpan" id="kobo.1217.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1218.1">A concept is a set of one or more constraints that is always defined in a namespace scope. </span><span class="koboSpan" id="kobo.1218.2">The definition of a concept is similar to a variable template. </span><span class="koboSpan" id="kobo.1218.3">The following snippet shows a concept being used for a variable template:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">template</span></span><span class="koboSpan" id="kobo.1220.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1222.1">T</span></span><span class="koboSpan" id="kobo.1223.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1224.1">concept</span></span><span class="koboSpan" id="kobo.1225.1"> Real = std::is_floating_point_v&lt;T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1226.1">template</span></span><span class="koboSpan" id="kobo.1227.1">&lt;Real T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1228.1">constexpr</span></span><span class="koboSpan" id="kobo.1229.1"> T pi = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1230.1">T</span></span><span class="koboSpan" id="kobo.1231.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1232.1">3.1415926535897932385L</span></span><span class="koboSpan" id="kobo.1233.1">);
std::cout &lt;&lt; pi&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1234.1">double</span></span><span class="koboSpan" id="kobo.1235.1">&gt; &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1236.1">'\n'</span></span><span class="koboSpan" id="kobo.1237.1">;
std::cout &lt;&lt; pi&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1238.1">int</span></span><span class="koboSpan" id="kobo.1239.1">&gt;    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1240.1">'\n'</span></span><span class="koboSpan" id="kobo.1241.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1242.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1243.1">Concepts</span><a id="_idIndexMarker1456"/><span class="koboSpan" id="kobo.1244.1"> cannot be constrained</span><a id="_idIndexMarker1457"/><span class="koboSpan" id="kobo.1245.1"> themselves, nor can they refer to themselves recursively. </span><span class="koboSpan" id="kobo.1245.2">In the examples shown so far, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1246.1">Numerical</span></code><span class="koboSpan" id="kobo.1247.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">Real</span></code><span class="koboSpan" id="kobo.1249.1"> concepts are composed of a single, atomic constraint. </span><span class="koboSpan" id="kobo.1249.2">However, concepts can be created from multiple constraints. </span><span class="koboSpan" id="kobo.1249.3">A constraint created from two constraints using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1250.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.1251.1"> logical operator is called a </span><em class="italic"><span class="koboSpan" id="kobo.1252.1">conjunction</span></em><span class="koboSpan" id="kobo.1253.1">, while a constraint created from two constraints using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1254.1">||</span></code><span class="koboSpan" id="kobo.1255.1"> logical operator is called a </span><em class="italic"><span class="koboSpan" id="kobo.1256.1">disjunction</span></em><span class="koboSpan" id="kobo.1257.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1258.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1259.1">Numerical</span></code><span class="koboSpan" id="kobo.1260.1"> concept defined in the </span><em class="italic"><span class="koboSpan" id="kobo.1261.1">How to do it...</span></em><span class="koboSpan" id="kobo.1262.1"> section was defined using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1263.1">std::is_arithmetic_v</span></code><span class="koboSpan" id="kobo.1264.1"> type trait. </span><span class="koboSpan" id="kobo.1264.2">However, we could have two concepts, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">Real</span></code><span class="koboSpan" id="kobo.1266.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1267.1">Integral</span></code><span class="koboSpan" id="kobo.1268.1">, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1269.1">template</span></span><span class="koboSpan" id="kobo.1270.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1271.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1272.1">T</span></span><span class="koboSpan" id="kobo.1273.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1274.1">concept</span></span><span class="koboSpan" id="kobo.1275.1"> Integral = std::is_integral_v&lt;T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1276.1">template</span></span><span class="koboSpan" id="kobo.1277.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1278.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1279.1">T</span></span><span class="koboSpan" id="kobo.1280.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1281.1">concept</span></span><span class="koboSpan" id="kobo.1282.1"> Real = std::is_floating_point_v&lt;T&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1283.1">From these two, we can compose the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1284.1">Numerical</span></code><span class="koboSpan" id="kobo.1285.1"> concept, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1286.1">||</span></code><span class="koboSpan" id="kobo.1287.1"> logical operator. </span><span class="koboSpan" id="kobo.1287.2">The result is a disjunction:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1288.1">template</span></span><span class="koboSpan" id="kobo.1289.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1290.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1291.1">T</span></span><span class="koboSpan" id="kobo.1292.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">concept</span></span><span class="koboSpan" id="kobo.1294.1"> Numerical = Integral&lt;T&gt; || Real&lt;T&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1295.1">Semantically, there is no difference between these two versions of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1296.1">Numerical</span></code><span class="koboSpan" id="kobo.1297.1"> concept, although they are defined in different ways.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1298.1">To understand conjunctions, let’s look at another example. </span><span class="koboSpan" id="kobo.1298.2">Consider two base classes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1299.1">IComparableToInt</span></code><span class="koboSpan" id="kobo.1300.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1301.1">IConvertibleToInt</span></code><span class="koboSpan" id="kobo.1302.1">, that are supposed to be derived by classes that should support comparison or conversion to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">int</span></code><span class="koboSpan" id="kobo.1304.1">. </span><span class="koboSpan" id="kobo.1304.2">These could be defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1305.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1306.1">IComparableToInt</span></span><span class="koboSpan" id="kobo.1307.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1308.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1309.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1310.1">CompareTo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1311.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1312.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1313.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1314.1"> o)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1315.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1316.1">0</span></span><span class="koboSpan" id="kobo.1317.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1318.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1319.1">IConvertibleToInt</span></span><span class="koboSpan" id="kobo.1320.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1321.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1322.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1323.1">ConvertTo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1324.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1325.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1326.1">0</span></span><span class="koboSpan" id="kobo.1327.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1328.1">Some</span><a id="_idIndexMarker1458"/><span class="koboSpan" id="kobo.1329.1"> classes can implement </span><a id="_idIndexMarker1459"/><span class="koboSpan" id="kobo.1330.1">both of them, others only one or the other. </span><span class="koboSpan" id="kobo.1330.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1331.1">SmartNumericalValue&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1332.1"> class here implements both, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1333.1">DullNumericalValue&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1334.1"> only implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">IConvertibleToInt</span></code><span class="koboSpan" id="kobo.1336.1"> class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1337.1">template</span></span><span class="koboSpan" id="kobo.1338.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1339.1">typename</span></span><span class="koboSpan" id="kobo.1340.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1341.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1342.1">SmartNumericalValue</span></span><span class="koboSpan" id="kobo.1343.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1344.1">public</span></span><span class="koboSpan" id="kobo.1345.1"> IComparableToint, IConvertibleToInt
{
  T value;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1346.1">SmartNumericalValue</span></span><span class="koboSpan" id="kobo.1347.1">(T v) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1348.1">value</span></span><span class="koboSpan" id="kobo.1349.1">(v) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1350.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1351.1">CompareTo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1352.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1353.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1354.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1355.1"> o)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1356.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1357.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1358.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1359.1">static_cast</span></span><span class="koboSpan" id="kobo.1360.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1361.1">int</span></span><span class="koboSpan" id="kobo.1362.1">&gt;(value) == o; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1363.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1364.1">ConvertTo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1365.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1366.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1367.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1368.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1369.1">static_cast</span></span><span class="koboSpan" id="kobo.1370.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1371.1">int</span></span><span class="koboSpan" id="kobo.1372.1">&gt;(value); }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1373.1">template</span></span><span class="koboSpan" id="kobo.1374.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1375.1">typename</span></span><span class="koboSpan" id="kobo.1376.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1378.1">DullNumericalValue</span></span><span class="koboSpan" id="kobo.1379.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1380.1">public</span></span><span class="koboSpan" id="kobo.1381.1"> IConvertibleToInt
{
  T value;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1382.1">DullNumericalValue</span></span><span class="koboSpan" id="kobo.1383.1">(T v) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1384.1">value</span></span><span class="koboSpan" id="kobo.1385.1">(v) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1386.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1387.1">ConvertTo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1388.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1389.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1390.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1391.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1392.1">static_cast</span></span><span class="koboSpan" id="kobo.1393.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1394.1">int</span></span><span class="koboSpan" id="kobo.1395.1">&gt;(value); }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1396.1">What we want to do is write a function template that only accepts arguments that are both comparable and can be converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1397.1">int</span></code><span class="koboSpan" id="kobo.1398.1">. </span><span class="koboSpan" id="kobo.1398.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">IComparableAndConvertible</span></code><span class="koboSpan" id="kobo.1400.1"> concept shown here is a conjunction of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">IntComparable</span></code><span class="koboSpan" id="kobo.1402.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">IntConvertible</span></code><span class="koboSpan" id="kobo.1404.1"> concepts. </span><span class="koboSpan" id="kobo.1404.2">They can be implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1405.1">template</span></span><span class="koboSpan" id="kobo.1406.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1407.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1408.1">T</span></span><span class="koboSpan" id="kobo.1409.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1410.1">concept</span></span><span class="koboSpan" id="kobo.1411.1"> IntComparable = std::is_base_of_v&lt;IComparableToInt, T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1412.1">template</span></span><span class="koboSpan" id="kobo.1413.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1414.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1415.1">T</span></span><span class="koboSpan" id="kobo.1416.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1417.1">concept</span></span><span class="koboSpan" id="kobo.1418.1"> IntConvertible = std::is_base_of_v&lt;IConvertibleToInt, T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1419.1">template</span></span><span class="koboSpan" id="kobo.1420.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1421.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1422.1">T</span></span><span class="koboSpan" id="kobo.1423.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1424.1">concept</span></span><span class="koboSpan" id="kobo.1425.1"> IntComparableAndConvertible = IntComparable&lt;T&gt; &amp;&amp; IntConvertible&lt;T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1426.1">template</span></span><span class="koboSpan" id="kobo.1427.1"> &lt;IntComparableAndConvertible T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1428.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1429.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1430.1">(T o)</span></span><span class="koboSpan" id="kobo.1431.1">
{
  std::cout &lt;&lt; o.value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1432.1">'\n'</span></span><span class="koboSpan" id="kobo.1433.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1434.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1435.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1436.1">()</span></span><span class="koboSpan" id="kobo.1437.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1438.1">auto</span></span><span class="koboSpan" id="kobo.1439.1"> snv = SmartNumericalValue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1440.1">double</span></span><span class="koboSpan" id="kobo.1441.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1442.1">42.0</span></span><span class="koboSpan" id="kobo.1443.1"> };
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1444.1">print</span></span><span class="koboSpan" id="kobo.1445.1">(snv);                      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1446.1">// prints 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1447.1">auto</span></span><span class="koboSpan" id="kobo.1448.1"> dnv = DullNumericalValue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1449.1">short</span></span><span class="koboSpan" id="kobo.1450.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1451.1">42</span></span><span class="koboSpan" id="kobo.1452.1"> };
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1453.1">print</span></span><span class="koboSpan" id="kobo.1454.1">(dnv);                      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1455.1">// error</span></span><span class="koboSpan" id="kobo.1456.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1457.1">Conjunctions </span><a id="_idIndexMarker1460"/><span class="koboSpan" id="kobo.1458.1">and disjunctions are </span><a id="_idIndexMarker1461"/><span class="koboSpan" id="kobo.1459.1">evaluated left to right and are short-circuited. </span><span class="koboSpan" id="kobo.1459.2">This means that for a conjunction, the right constraint is evaluated only if the left one is satisfied, and for a disjunction, the right constraint is evaluated only if the left one is not satisfied.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1460.1">The third category of</span><a id="_idIndexMarker1462"/><span class="koboSpan" id="kobo.1461.1"> constraints is </span><em class="italic"><span class="koboSpan" id="kobo.1462.1">atomic constraints</span></em><span class="koboSpan" id="kobo.1463.1">. </span><span class="koboSpan" id="kobo.1463.2">These are composed of an expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.1464.1">E</span></code><span class="koboSpan" id="kobo.1465.1"> and a mapping between the type parameters from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1466.1">E</span></code><span class="koboSpan" id="kobo.1467.1"> and the template arguments of the constrained entity, called </span><em class="italic"><span class="koboSpan" id="kobo.1468.1">parameter mapping</span></em><span class="koboSpan" id="kobo.1469.1">. </span><span class="koboSpan" id="kobo.1469.2">The </span><a id="_idIndexMarker1463"/><span class="koboSpan" id="kobo.1470.1">atomic constraints are formed during </span><em class="italic"><span class="koboSpan" id="kobo.1471.1">constraint normalization</span></em><span class="koboSpan" id="kobo.1472.1">, which is the process of transforming a constraint expression into a</span><a id="_idIndexMarker1464"/><span class="koboSpan" id="kobo.1473.1"> sequence of conjunctions and disjunctions of atomic constraints. </span><span class="koboSpan" id="kobo.1473.2">An atomic constraint is checked by substituting the parameter mapping and the template arguments into the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.1474.1">E</span></code><span class="koboSpan" id="kobo.1475.1">. </span><span class="koboSpan" id="kobo.1475.2">The result must be a valid prvalue constant expression of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">bool</span></code><span class="koboSpan" id="kobo.1477.1">; otherwise, the constraint is not satisfied.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1478.1">The standard library defines a series of concepts that can be used to define compile-time requirements on template arguments. </span><span class="koboSpan" id="kobo.1478.2">Although most of these concepts impose both syntactic and semantic requirements, the compiler can usually ensure only the former. </span><span class="koboSpan" id="kobo.1478.3">When the semantic requirements are not met, the program is considered ill-formed, and the compiler is not required to provide any diagnostics about the problem. </span><span class="koboSpan" id="kobo.1478.4">The standard concepts are available in several places:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1479.1">In the concepts library, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">&lt;concepts&gt;</span></code><span class="koboSpan" id="kobo.1481.1"> header and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1482.1">std</span></code><span class="koboSpan" id="kobo.1483.1"> namespace. </span><span class="koboSpan" id="kobo.1483.2">This includes core language concepts (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">same_as</span></code><span class="koboSpan" id="kobo.1485.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1486.1">integral</span></code><span class="koboSpan" id="kobo.1487.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1488.1">floating_point</span></code><span class="koboSpan" id="kobo.1489.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1490.1">copy_constructible</span></code><span class="koboSpan" id="kobo.1491.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1492.1">move_constructible</span></code><span class="koboSpan" id="kobo.1493.1">), comparison concepts (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1494.1">equality_comparable</span></code><span class="koboSpan" id="kobo.1495.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1496.1">totally_ordered</span></code><span class="koboSpan" id="kobo.1497.1">), object concepts (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1498.1">copyable</span></code><span class="koboSpan" id="kobo.1499.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1500.1">moveable</span></code><span class="koboSpan" id="kobo.1501.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1502.1">regular</span></code><span class="koboSpan" id="kobo.1503.1">), and callable concepts (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1504.1">invocable</span></code><span class="koboSpan" id="kobo.1505.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1506.1">predicate</span></code><span class="koboSpan" id="kobo.1507.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1508.1">In the algorithms library, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1509.1">&lt;iterator&gt;</span></code><span class="koboSpan" id="kobo.1510.1"> header and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1511.1">std</span></code><span class="koboSpan" id="kobo.1512.1"> namespace. </span><span class="koboSpan" id="kobo.1512.2">This includes algorithm requirements (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1513.1">sortable</span></code><span class="koboSpan" id="kobo.1514.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1515.1">permutable</span></code><span class="koboSpan" id="kobo.1516.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1517.1">mergeable</span></code><span class="koboSpan" id="kobo.1518.1">) and indirect callable concepts (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1519.1">indirect_unary_predicate</span></code><span class="koboSpan" id="kobo.1520.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1521.1">indirect_binary_predicate</span></code><span class="koboSpan" id="kobo.1522.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1523.1">In the ranges library, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1524.1">&lt;ranges&gt;</span></code><span class="koboSpan" id="kobo.1525.1"> header and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1526.1">std::ranges</span></code><span class="koboSpan" id="kobo.1527.1"> namespace. </span><span class="koboSpan" id="kobo.1527.2">This</span><a id="_idIndexMarker1465"/><span class="koboSpan" id="kobo.1528.1"> includes</span><a id="_idIndexMarker1466"/><span class="koboSpan" id="kobo.1529.1"> concepts specific for ranges, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">range</span></code><span class="koboSpan" id="kobo.1531.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1532.1">view</span></code><span class="koboSpan" id="kobo.1533.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">input_range</span></code><span class="koboSpan" id="kobo.1535.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1536.1">output_range</span></code><span class="koboSpan" id="kobo.1537.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1538.1">forward_range</span></code><span class="koboSpan" id="kobo.1539.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1540.1">random_access_range</span></code><span class="koboSpan" id="kobo.1541.1">.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-770"><span class="koboSpan" id="kobo.1542.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1543.1">The concepts defined in this recipe used the already available type traits. </span><span class="koboSpan" id="kobo.1543.2">However, there are many cases when requirements on template arguments cannot be described in this way. </span><span class="koboSpan" id="kobo.1543.3">For this reason, concepts can be defined with a </span><em class="italic"><span class="koboSpan" id="kobo.1544.1">requires expression</span></em><span class="koboSpan" id="kobo.1545.1">, which is a prvalue expression of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1546.1">bool</span></code><span class="koboSpan" id="kobo.1547.1">, describing a template argument requirement. </span><span class="koboSpan" id="kobo.1547.2">This will be the topic of the next recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-771"><span class="koboSpan" id="kobo.1548.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1549.1">Using requires expressions and clauses</span></em><span class="koboSpan" id="kobo.1550.1">, to learn about in-place constraints</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-772"><span class="koboSpan" id="kobo.1551.1">Using requires expressions and clauses</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1552.1">In the previous recipe, we </span><a id="_idIndexMarker1467"/><span class="koboSpan" id="kobo.1553.1">introduced the topic of concepts and constraints, learning about them with the help of several examples that were solely based on already existing type</span><a id="_idIndexMarker1468"/><span class="koboSpan" id="kobo.1554.1"> traits. </span><span class="koboSpan" id="kobo.1554.2">Moreover, we also used the terser syntax to specify concepts, with the concept name used instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1555.1">typename</span></code><span class="koboSpan" id="kobo.1556.1"> or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">class</span></code><span class="koboSpan" id="kobo.1558.1"> keyword in the template declaration. </span><span class="koboSpan" id="kobo.1558.2">However, it is possible to define more complex concepts with the help of </span><em class="italic"><span class="koboSpan" id="kobo.1559.1">requires expressions</span></em><span class="koboSpan" id="kobo.1560.1">. </span><span class="koboSpan" id="kobo.1560.2">These are prvalues of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1561.1">bool</span></code><span class="koboSpan" id="kobo.1562.1"> that describe the constraints on some template arguments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1563.1">In this recipe, we will learn how to write requires expressions and an alternative way to specify constraints on template arguments.</span></p>
<h2 class="heading-2" id="_idParaDest-773"><span class="koboSpan" id="kobo.1564.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1565.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1566.1">NumericalValue&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1567.1"> and the function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1568.1">wrap()</span></code><span class="koboSpan" id="kobo.1569.1"> defined in the previous recipe will be used in the code snippets presented in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-774"><span class="koboSpan" id="kobo.1570.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1571.1">To specify requirements for </span><a id="_idIndexMarker1469"/><span class="koboSpan" id="kobo.1572.1">template arguments, you can use requires</span><a id="_idIndexMarker1470"/><span class="koboSpan" id="kobo.1573.1"> expressions, introduced with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1574.1">requires</span></code><span class="koboSpan" id="kobo.1575.1"> keyword, such as the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1576.1">Use a simple expression that the compiler validates for correctness. </span><span class="koboSpan" id="kobo.1576.2">In the following snippet, the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.1577.1">+</span></code><span class="koboSpan" id="kobo.1578.1"> must be overloaded for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">T</span></code><span class="koboSpan" id="kobo.1580.1"> template argument:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1581.1">template</span></span><span class="koboSpan" id="kobo.1582.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1583.1">typename</span></span><span class="koboSpan" id="kobo.1584.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1585.1">concept</span></span><span class="koboSpan" id="kobo.1586.1"> Addable = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1587.1">requires</span></span><span class="koboSpan" id="kobo.1588.1"> (T a, T b) {a + b;};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1589.1">template</span></span><span class="koboSpan" id="kobo.1590.1"> &lt;Addable T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1591.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1592.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1593.1">(T a, T b)</span></span><span class="koboSpan" id="kobo.1594.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1595.1">return</span></span><span class="koboSpan" id="kobo.1596.1"> a + b;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1597.1">add</span></span><span class="koboSpan" id="kobo.1598.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1599.1">1</span></span><span class="koboSpan" id="kobo.1600.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1601.1">2</span></span><span class="koboSpan" id="kobo.1602.1">);        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1603.1">// OK, integers</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1604.1">add</span></span><span class="koboSpan" id="kobo.1605.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1606.1">"1"</span></span><span class="koboSpan" id="kobo.1607.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1608.1">"2"</span></span><span class="koboSpan" id="kobo.1609.1">s);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1610.1">// OK, std::string user-defined literals</span></span><span class="koboSpan" id="kobo.1611.1">
NumericalValue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1612.1">int</span></span><span class="koboSpan" id="kobo.1613.1">&gt; a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1614.1">1</span></span><span class="koboSpan" id="kobo.1615.1">};
NumericalValue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1616.1">int</span></span><span class="koboSpan" id="kobo.1617.1">&gt; b{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1618.1">2</span></span><span class="koboSpan" id="kobo.1619.1">};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1620.1">add</span></span><span class="koboSpan" id="kobo.1621.1">(a, b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1622.1">// error: no matching function for call to 'add'</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1623.1">// 'NumericalValue&lt;int&gt;' does not satisfy 'Addable'</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1624.1">Use a simple expression to require the existence of a particular function. </span><span class="koboSpan" id="kobo.1624.2">In the following snippet, a function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">wrap()</span></code><span class="koboSpan" id="kobo.1626.1">, which is overloaded with a parameter of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1627.1">T</span></code><span class="koboSpan" id="kobo.1628.1"> template argument, must exist:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1629.1">template</span></span><span class="koboSpan" id="kobo.1630.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1631.1">typename</span></span><span class="koboSpan" id="kobo.1632.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1633.1">concept</span></span><span class="koboSpan" id="kobo.1634.1"> Wrapable = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1635.1">requires</span></span><span class="koboSpan" id="kobo.1636.1">(T x) { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1637.1">wrap</span></span><span class="koboSpan" id="kobo.1638.1">(x); };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1639.1">template</span></span><span class="koboSpan" id="kobo.1640.1"> &lt;Wrapable T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1641.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1642.1">do_wrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1643.1">(T x)</span></span><span class="koboSpan" id="kobo.1644.1">
{
  [[maybe_unused]] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1645.1">auto</span></span><span class="koboSpan" id="kobo.1646.1"> v = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1647.1">wrap</span></span><span class="koboSpan" id="kobo.1648.1">(x);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1649.1">do_wrap</span></span><span class="koboSpan" id="kobo.1650.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1651.1">42</span></span><span class="koboSpan" id="kobo.1652.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1653.1">// OK, can wrap an int</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1654.1">do_wrap</span></span><span class="koboSpan" id="kobo.1655.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1656.1">42.0</span></span><span class="koboSpan" id="kobo.1657.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1658.1">// OK, can wrap a double</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1659.1">do_wrap</span></span><span class="koboSpan" id="kobo.1660.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1661.1">"42"</span></span><span class="koboSpan" id="kobo.1662.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1663.1">// error, cannot wrap a std::string</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1664.1">Use a</span><a id="_idIndexMarker1471"/><span class="koboSpan" id="kobo.1665.1"> type requirement, specified with the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.1666.1">typename</span></code><span class="koboSpan" id="kobo.1667.1">, followed by the name of a type, optionally qualified, to specify </span><a id="_idIndexMarker1472"/><span class="koboSpan" id="kobo.1668.1">requirements such as member names, class template specializations, or alias template substitutions. </span><span class="koboSpan" id="kobo.1668.2">In the following snippet, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1669.1">T</span></code><span class="koboSpan" id="kobo.1670.1"> template argument must have two inner types called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1671.1">value_type</span></code><span class="koboSpan" id="kobo.1672.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1673.1">iterator</span></code><span class="koboSpan" id="kobo.1674.1">. </span><span class="koboSpan" id="kobo.1674.2">Additionally, two functions, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1675.1">begin()</span></code><span class="koboSpan" id="kobo.1676.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1677.1">end()</span></code><span class="koboSpan" id="kobo.1678.1">, which take a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1679.1">T</span></code><span class="koboSpan" id="kobo.1680.1"> argument, must be available:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1681.1">template</span></span><span class="koboSpan" id="kobo.1682.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1683.1">typename</span></span><span class="koboSpan" id="kobo.1684.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1685.1">concept</span></span><span class="koboSpan" id="kobo.1686.1"> Container = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1687.1">requires</span></span><span class="koboSpan" id="kobo.1688.1">(T x)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1689.1">typename</span></span><span class="koboSpan" id="kobo.1690.1"> T::value_type;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1691.1">typename</span></span><span class="koboSpan" id="kobo.1692.1"> T::iterator;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1693.1">begin</span></span><span class="koboSpan" id="kobo.1694.1">(x);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1695.1">end</span></span><span class="koboSpan" id="kobo.1696.1">(x);
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1697.1">template</span></span><span class="koboSpan" id="kobo.1698.1"> &lt;Container T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1699.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1700.1">pass_container</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1701.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1702.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1703.1"> &amp; c)</span></span><span class="koboSpan" id="kobo.1704.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1705.1">for</span></span><span class="koboSpan" id="kobo.1706.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1707.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1708.1">const</span></span><span class="koboSpan" id="kobo.1709.1"> &amp; x : c)
    std::cout &lt;&lt; x &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1710.1">'\n'</span></span><span class="koboSpan" id="kobo.1711.1">;
}
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1712.1">int</span></span><span class="koboSpan" id="kobo.1713.1">&gt; v { </span><span class="hljs-number"><span class="koboSpan" id="kobo.1714.1">1</span></span><span class="koboSpan" id="kobo.1715.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1716.1">2</span></span><span class="koboSpan" id="kobo.1717.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1718.1">3</span></span><span class="koboSpan" id="kobo.1719.1">};
std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1720.1">int</span></span><span class="koboSpan" id="kobo.1721.1">, 3&gt; a {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1722.1">1</span></span><span class="koboSpan" id="kobo.1723.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1724.1">2</span></span><span class="koboSpan" id="kobo.1725.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1726.1">3</span></span><span class="koboSpan" id="kobo.1727.1">};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1728.1">int</span></span><span class="koboSpan" id="kobo.1729.1"> arr[] {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1730.1">1</span></span><span class="koboSpan" id="kobo.1731.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1732.1">2</span></span><span class="koboSpan" id="kobo.1733.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1734.1">3</span></span><span class="koboSpan" id="kobo.1735.1">};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1736.1">pass_container</span></span><span class="koboSpan" id="kobo.1737.1">(v);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1738.1">// OK</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1739.1">pass_container</span></span><span class="koboSpan" id="kobo.1740.1">(a);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1741.1">// OK</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1742.1">pass_container</span></span><span class="koboSpan" id="kobo.1743.1">(arr); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1744.1">// error: 'int [3]' does not satisfy</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1745.1">// 'Container'</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1746.1">Use a</span><a id="_idIndexMarker1473"/><span class="koboSpan" id="kobo.1747.1"> compound requirement to specify the requirements of an expression, as well as the result of the evaluation of the expression. </span><span class="koboSpan" id="kobo.1747.2">In</span><a id="_idIndexMarker1474"/><span class="koboSpan" id="kobo.1748.1"> the following example, there must be a function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">wrap()</span></code><span class="koboSpan" id="kobo.1750.1"> that can be called with an argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1751.1">T</span></code><span class="koboSpan" id="kobo.1752.1"> template argument type, and the result of calling the function must be of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1753.1">NumericalValue&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1754.1"> type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1755.1">template</span></span><span class="koboSpan" id="kobo.1756.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1757.1">typename</span></span><span class="koboSpan" id="kobo.1758.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1759.1">concept</span></span><span class="koboSpan" id="kobo.1760.1"> NumericalWrapable =
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1761.1">requires</span></span><span class="koboSpan" id="kobo.1762.1">(T x)
{
  {</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1763.1">wrap</span></span><span class="koboSpan" id="kobo.1764.1">(x)} -&gt; std::same_as&lt;NumericalValue&lt;T&gt;&gt;;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1765.1">template</span></span><span class="koboSpan" id="kobo.1766.1"> &lt;NumericalWrapable T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1767.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1768.1">do_wrap_numerical</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1769.1">(T x)</span></span><span class="koboSpan" id="kobo.1770.1">
{
  [[maybe_unused]] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1771.1">auto</span></span><span class="koboSpan" id="kobo.1772.1"> v = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1773.1">wrap</span></span><span class="koboSpan" id="kobo.1774.1">(x);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1775.1">template</span></span><span class="koboSpan" id="kobo.1776.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1777.1">typename</span></span><span class="koboSpan" id="kobo.1778.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1779.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1780.1">any_wrapper</span></span><span class="koboSpan" id="kobo.1781.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1782.1">public</span></span><span class="koboSpan" id="kobo.1783.1">:
  T value;
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1784.1">any_wrapper&lt;std::string&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1785.1">wrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1786.1">(std::string s)</span></span><span class="koboSpan" id="kobo.1787.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1788.1">return</span></span><span class="koboSpan" id="kobo.1789.1"> any_wrapper&lt;std::string&gt;{s};
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1790.1">// OK, wrap(int) returns NumericalValue&lt;int&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1791.1">do_wrap_numerical</span></span><span class="koboSpan" id="kobo.1792.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1793.1">42</span></span><span class="koboSpan" id="kobo.1794.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1795.1">// error, wrap(string) returns any_wrapper&lt;string&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1796.1">do_wrap_numerical</span></span><span class="koboSpan" id="kobo.1797.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1798.1">"42"</span></span><span class="koboSpan" id="kobo.1799.1">s);
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1800.1">Constraints on the</span><a id="_idIndexMarker1475"/><span class="koboSpan" id="kobo.1801.1"> template arguments can also be specified using a syntax, involving </span><a id="_idIndexMarker1476"/><span class="koboSpan" id="kobo.1802.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1803.1">requires</span></code><span class="koboSpan" id="kobo.1804.1"> keyword. </span><span class="koboSpan" id="kobo.1804.2">These are called </span><em class="italic"><span class="koboSpan" id="kobo.1805.1">requires clauses</span></em><span class="koboSpan" id="kobo.1806.1"> and can be used as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1807.1">Use a requires clause after the template parameter list:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1808.1">template</span></span><span class="koboSpan" id="kobo.1809.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1810.1">typename</span></span><span class="koboSpan" id="kobo.1811.1"> T&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1812.1">requires</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1813.1"> Addable&lt;T&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.1814.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1815.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1816.1">(T a, T b)</span></span><span class="koboSpan" id="kobo.1817.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1818.1">return</span></span><span class="koboSpan" id="kobo.1819.1"> a + b;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1820.1">Alternatively, use the requires clause after the last element of a function declarator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1821.1">template</span></span><span class="koboSpan" id="kobo.1822.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1823.1">typename</span></span><span class="koboSpan" id="kobo.1824.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1825.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1826.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1827.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1828.1">requires</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1829.1"> Addable&lt;T&gt;</span></span><span class="koboSpan" id="kobo.1830.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1831.1">return</span></span><span class="koboSpan" id="kobo.1832.1"> a + b;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1833.1">Combine a requires clause with a requires expression, instead of a named concept. </span><span class="koboSpan" id="kobo.1833.2">In this case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1834.1">requires</span></code><span class="koboSpan" id="kobo.1835.1"> keyword appears twice, as shown in the following snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1836.1">template</span></span><span class="koboSpan" id="kobo.1837.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1838.1">typename</span></span><span class="koboSpan" id="kobo.1839.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1840.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1841.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1842.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1843.1">requires</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1844.1">requires</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1845.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1846.1">{a + b;}
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1847.1">return</span></span><span class="koboSpan" id="kobo.1848.1"> a + b;
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-775"><span class="koboSpan" id="kobo.1849.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1850.1">The new </span><code class="inlineCode"><span class="koboSpan" id="kobo.1851.1">requires</span></code><span class="koboSpan" id="kobo.1852.1"> keyword has multiple purposes. </span><span class="koboSpan" id="kobo.1852.2">On one hand, it is used to introduce a requires clause that specifies constraints on template arguments. </span><span class="koboSpan" id="kobo.1852.3">On the other hand, it is used to define a requires expression that is a prvalue of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1853.1">bool</span></code><span class="koboSpan" id="kobo.1854.1"> used to define constraints on template arguments.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1855.1">If you are not familiar with C++ value categories (</span><em class="italic"><span class="koboSpan" id="kobo.1856.1">lvalue</span></em><span class="koboSpan" id="kobo.1857.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1858.1">rvalue</span></em><span class="koboSpan" id="kobo.1859.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1860.1">prvalue</span></em><span class="koboSpan" id="kobo.1861.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1862.1">xvalue</span></em><span class="koboSpan" id="kobo.1863.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1864.1">glvalue</span></em><span class="koboSpan" id="kobo.1865.1">), you are recommended to check </span><a href="https://en.cppreference.com/w/cpp/language/value_category"><span class="url"><span class="koboSpan" id="kobo.1866.1">https://en.cppreference.com/w/cpp/language/value_category</span></span></a><span class="koboSpan" id="kobo.1867.1">. </span><span class="koboSpan" id="kobo.1867.2">The term </span><em class="italic"><span class="koboSpan" id="kobo.1868.1">prvalue</span></em><span class="koboSpan" id="kobo.1869.1">, meaning </span><em class="italic"><span class="koboSpan" id="kobo.1870.1">pure rvalue</span></em><span class="koboSpan" id="kobo.1871.1">, specifies an rvalue that is not an xvalue (expiring value). </span><span class="koboSpan" id="kobo.1871.2">Examples of prvalues are literals, function calls whose return type is not a reference type, an enumerator, or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1872.1">this</span></code><span class="koboSpan" id="kobo.1873.1"> pointer. </span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1874.1">In a requires clause, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1875.1">requires</span></code><span class="koboSpan" id="kobo.1876.1"> keyword must be followed by a constant expression of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1877.1">bool</span></code><span class="koboSpan" id="kobo.1878.1">. </span><span class="koboSpan" id="kobo.1878.2">The expression must be either a primary expression (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1879.1">std::is_arithmetic_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1880.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1881.1">std::integral&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1882.1">), an expression in parentheses, or any sequence of such expressions joined with either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1883.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.1884.1"> or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1885.1">||</span></code><span class="koboSpan" id="kobo.1886.1"> operator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1887.1">A requires </span><a id="_idIndexMarker1477"/><span class="koboSpan" id="kobo.1888.1">expression has the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.1889.1">requires (parameters-list) { requirements }</span></code><span class="koboSpan" id="kobo.1890.1">. </span><span class="koboSpan" id="kobo.1890.2">The parameters list is optional and can be entirely omitted (including the parentheses). </span><span class="koboSpan" id="kobo.1890.3">The specified requirements may refer to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1891.1">The template parameters that are in scope</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1892.1">The local parameters introduced in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1893.1">parameters-list</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1894.1">Any other declarations that are visible from the enclosing context</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1895.1">The requirements sequence of the requires expression can contain requirements of the following types:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1896.1">Simple requirements</span></strong><span class="koboSpan" id="kobo.1897.1">: These are</span><a id="_idIndexMarker1478"/><span class="koboSpan" id="kobo.1898.1"> arbitrary expressions that do not start with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1899.1">requires</span></code><span class="koboSpan" id="kobo.1900.1"> keyword. </span><span class="koboSpan" id="kobo.1900.2">The compiler only checks its language correctness.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1901.1">Type requirements</span></strong><span class="koboSpan" id="kobo.1902.1">: These are</span><a id="_idIndexMarker1479"/><span class="koboSpan" id="kobo.1903.1"> expressions that start with the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.1904.1">typename</span></code><span class="koboSpan" id="kobo.1905.1"> followed by a type name, which must be valid. </span><span class="koboSpan" id="kobo.1905.2">This enables the compiler to validate that a certain nested name exists, or that a class template specialization or an alias template substitution exists.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1906.1">Compound requirements</span></strong><span class="koboSpan" id="kobo.1907.1">: They </span><a id="_idIndexMarker1480"/><span class="koboSpan" id="kobo.1908.1">have the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.1909.1">{expression} noexcept -&gt; type-constraint</span></code><span class="koboSpan" id="kobo.1910.1">. </span><span class="koboSpan" id="kobo.1910.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1911.1">noexcept</span></code><span class="koboSpan" id="kobo.1912.1"> keyword is optional, in which case the expression must not be potentially throwing. </span><span class="koboSpan" id="kobo.1912.2">The requirement for the return type, introduced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1913.1">-&gt;</span></code><span class="koboSpan" id="kobo.1914.1">, is also optional. </span><span class="koboSpan" id="kobo.1914.2">However, if it is present, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.1915.1">decltype(expression)</span></code><span class="koboSpan" id="kobo.1916.1"> must satisfy the constraints imposed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1917.1">type-constraint</span></code><span class="koboSpan" id="kobo.1918.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1919.1">Nested requirements</span></strong><span class="koboSpan" id="kobo.1920.1">: These are more complex expressions that specify constraints defined as a requires expression, which can, in turn, be another nested requirement. </span><span class="koboSpan" id="kobo.1920.2">A</span><a id="_idIndexMarker1481"/><span class="koboSpan" id="kobo.1921.1"> requirement that starts with the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.1922.1">requires</span></code><span class="koboSpan" id="kobo.1923.1"> is considered a nested requirement.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1924.1">Before they are evaluated, the body of every name concept and every </span><code class="inlineCode"><span class="koboSpan" id="kobo.1925.1">requires</span></code><span class="koboSpan" id="kobo.1926.1"> expression is substituted until a sequence of conjunctions and disjunctions of atomic constraints is obtained. </span><span class="koboSpan" id="kobo.1926.2">This process is </span><a id="_idIndexMarker1482"/><span class="koboSpan" id="kobo.1927.1">called </span><em class="italic"><span class="koboSpan" id="kobo.1928.1">normalization</span></em><span class="koboSpan" id="kobo.1929.1">. </span><span class="koboSpan" id="kobo.1929.2">The actual details of normalization and the analysis the compiler performs are beyond the scope of this book.</span></p>
<h2 class="heading-2" id="_idParaDest-776"><span class="koboSpan" id="kobo.1930.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1931.1">Specifying requirements on template arguments with concepts</span></em><span class="koboSpan" id="kobo.1932.1">, to explore the fundamentals of C++20 concepts</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-777"><span class="koboSpan" id="kobo.1933.1">Exploring abbreviated function templates</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1934.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.1935.1">Chapter 3</span></em><span class="koboSpan" id="kobo.1936.1">, we learned about function templates as well as lambda expressions, including generic and template lambdas. </span><span class="koboSpan" id="kobo.1936.2">A generic lambda is a lambda expression that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1937.1">auto</span></code><span class="koboSpan" id="kobo.1938.1"> specified for one of its parameters. </span><span class="koboSpan" id="kobo.1938.2">The result is a function object with a templated call operator. </span><span class="koboSpan" id="kobo.1938.3">The same is produced as a result of defining a lambda template that has the advantage, over generic lambdas, of allowing better control over the types of the parameters. </span><span class="koboSpan" id="kobo.1938.4">In C++20, this idea of using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1939.1">auto</span></code><span class="koboSpan" id="kobo.1940.1"> specifier for parameter types is generalized for all functions. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1941.1">This introduces a simplified syntax of defining function templates, and functions that are defined in this</span><a id="_idIndexMarker1483"/><span class="koboSpan" id="kobo.1942.1"> way are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1943.1">abbreviated function templates</span></strong><span class="koboSpan" id="kobo.1944.1">. </span><span class="koboSpan" id="kobo.1944.2">We will see in this recipe how to use them.</span></p>
<h2 class="heading-2" id="_idParaDest-778"><span class="koboSpan" id="kobo.1945.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1946.1">You can define the following categories of abbreviated function templates in C++20:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1947.1">Unconstrained abbreviated function templates</span><a id="_idIndexMarker1484"/><span class="koboSpan" id="kobo.1948.1"> that use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1949.1">auto</span></code><span class="koboSpan" id="kobo.1950.1"> specifier to define parameters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1951.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1952.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1953.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1954.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1955.1"> a, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1956.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1957.1"> b)</span></span><span class="koboSpan" id="kobo.1958.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1959.1">return</span></span><span class="koboSpan" id="kobo.1960.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1961.1">auto</span></span><span class="koboSpan" id="kobo.1962.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1963.1">sum</span></span><span class="koboSpan" id="kobo.1964.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1965.1">40</span></span><span class="koboSpan" id="kobo.1966.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1967.1">2</span></span><span class="koboSpan" id="kobo.1968.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1969.1">// 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1970.1">auto</span></span><span class="koboSpan" id="kobo.1971.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1972.1">sum</span></span><span class="koboSpan" id="kobo.1973.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1974.1">42.0</span></span><span class="koboSpan" id="kobo.1975.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1976.1">2</span></span><span class="koboSpan" id="kobo.1977.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1978.1">// 44.0</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1979.1">Constrained abbreviated function templates</span><a id="_idIndexMarker1485"/><span class="koboSpan" id="kobo.1980.1"> that use concepts, specified before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1981.1">auto</span></code><span class="koboSpan" id="kobo.1982.1"> specifier, to constrain the parameters of the function template:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1983.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1984.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1985.1">(std::integral </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1986.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1987.1"> a, std::integral </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1988.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1989.1"> b)</span></span><span class="koboSpan" id="kobo.1990.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1991.1">return</span></span><span class="koboSpan" id="kobo.1992.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1993.1">auto</span></span><span class="koboSpan" id="kobo.1994.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1995.1">sum</span></span><span class="koboSpan" id="kobo.1996.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1997.1">40</span></span><span class="koboSpan" id="kobo.1998.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1999.1">2</span></span><span class="koboSpan" id="kobo.2000.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2001.1">// 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2002.1">auto</span></span><span class="koboSpan" id="kobo.2003.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2004.1">sum</span></span><span class="koboSpan" id="kobo.2005.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2006.1">42.0</span></span><span class="koboSpan" id="kobo.2007.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2008.1">2</span></span><span class="koboSpan" id="kobo.2009.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2010.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2011.1">Constrained variadic abbreviated function templates</span><a id="_idIndexMarker1486"/><span class="koboSpan" id="kobo.2012.1"> that use the syntax seen above but with a parameter pack:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2013.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2014.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2015.1">(std::integral </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2016.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2017.1"> ... </span><span class="koboSpan" id="kobo.2017.2">args)</span></span><span class="koboSpan" id="kobo.2018.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2019.1">return</span></span><span class="koboSpan" id="kobo.2020.1"> (args + ...);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2021.1">auto</span></span><span class="koboSpan" id="kobo.2022.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2023.1">sum</span></span><span class="koboSpan" id="kobo.2024.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2025.1">10</span></span><span class="koboSpan" id="kobo.2026.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2027.1">30</span></span><span class="koboSpan" id="kobo.2028.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2029.1">2</span></span><span class="koboSpan" id="kobo.2030.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2031.1">// 42</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2032.1">Constrained abbreviated </span><a id="_idIndexMarker1487"/><span class="koboSpan" id="kobo.2033.1">lambda expressions</span><a id="_idIndexMarker1488"/><span class="koboSpan" id="kobo.2034.1"> that use the syntax seen above but with a lambda expression:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2035.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2036.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2037.1">()</span></span><span class="koboSpan" id="kobo.2038.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2039.1">auto</span></span><span class="koboSpan" id="kobo.2040.1"> lsum = [](std::integral </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2041.1">auto</span></span><span class="koboSpan" id="kobo.2042.1"> a, std::integral </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2043.1">auto</span></span><span class="koboSpan" id="kobo.2044.1"> b)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2045.1">return</span></span><span class="koboSpan" id="kobo.2046.1"> a + b;
   };
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2047.1">auto</span></span><span class="koboSpan" id="kobo.2048.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2049.1">lsum</span></span><span class="koboSpan" id="kobo.2050.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2051.1">40</span></span><span class="koboSpan" id="kobo.2052.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2053.1">2</span></span><span class="koboSpan" id="kobo.2054.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2055.1">// 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2056.1">auto</span></span><span class="koboSpan" id="kobo.2057.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2058.1">lsum</span></span><span class="koboSpan" id="kobo.2059.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2060.1">42.0</span></span><span class="koboSpan" id="kobo.2061.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2062.1">2</span></span><span class="koboSpan" id="kobo.2063.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2064.1">// error</span></span><span class="koboSpan" id="kobo.2065.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2066.1">Specializations of abbreviated function templates can be defined just as for function templates defined with the regular template syntax:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2067.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2068.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2069.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2070.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2071.1"> a, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2072.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2073.1"> b)</span></span><span class="koboSpan" id="kobo.2074.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2075.1">return</span></span><span class="koboSpan" id="kobo.2076.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2077.1">template</span></span><span class="koboSpan" id="kobo.2078.1"> &lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2079.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2080.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2081.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2082.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2083.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2084.1">* a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2085.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2086.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2087.1">* b)</span></span><span class="koboSpan" id="kobo.2088.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2089.1">return</span></span><span class="koboSpan" id="kobo.2090.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2091.1">string</span></span><span class="koboSpan" id="kobo.2092.1">(a) + std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2093.1">string</span></span><span class="koboSpan" id="kobo.2094.1">(b);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2095.1">auto</span></span><span class="koboSpan" id="kobo.2096.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2097.1">sum</span></span><span class="koboSpan" id="kobo.2098.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2099.1">40</span></span><span class="koboSpan" id="kobo.2100.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2101.1">2</span></span><span class="koboSpan" id="kobo.2102.1">);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2103.1">// 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2104.1">auto</span></span><span class="koboSpan" id="kobo.2105.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2106.1">sum</span></span><span class="koboSpan" id="kobo.2107.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2108.1">"40"</span></span><span class="koboSpan" id="kobo.2109.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2110.1">"2"</span></span><span class="koboSpan" id="kobo.2111.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2112.1">// "402"</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-779"><span class="koboSpan" id="kobo.2113.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2114.1">The template </span><a id="_idIndexMarker1489"/><span class="koboSpan" id="kobo.2115.1">syntax is considered by many rather cumbersome. </span><span class="koboSpan" id="kobo.2115.2">Abbreviated function templates are meant to simplify writing some categories of function templates. </span><span class="koboSpan" id="kobo.2115.3">They do so by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2116.1">auto</span></code><span class="koboSpan" id="kobo.2117.1"> specifier as a placeholder for parameter types, instead of the typical template syntax. </span><span class="koboSpan" id="kobo.2117.2">The following two definitions are equivalent:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2118.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2119.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2120.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2121.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2122.1"> a, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2123.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2124.1"> b)</span></span><span class="koboSpan" id="kobo.2125.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2126.1">return</span></span><span class="koboSpan" id="kobo.2127.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2128.1">template</span></span><span class="koboSpan" id="kobo.2129.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2130.1">typename</span></span><span class="koboSpan" id="kobo.2131.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2132.1">typename</span></span><span class="koboSpan" id="kobo.2133.1"> U&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2134.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2135.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2136.1">(T a, U b)</span></span><span class="koboSpan" id="kobo.2137.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2138.1">return</span></span><span class="koboSpan" id="kobo.2139.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2140.1">If the intention is to define a function template with both arguments of the same type, then this form of the abbreviated function template is not enough. </span><span class="koboSpan" id="kobo.2140.2">These abbreviated function templates are</span><a id="_idIndexMarker1490"/><span class="koboSpan" id="kobo.2141.1"> called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2142.1">unconstrained</span></strong><span class="koboSpan" id="kobo.2143.1"> because there are no constraints placed on the arguments of the function. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2144.1">Such constraints can be defined with the help of concepts, as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2145.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2146.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2147.1">(std::integral </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2148.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2149.1"> a, std::integral </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2150.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2151.1"> b)</span></span><span class="koboSpan" id="kobo.2152.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2153.1">return</span></span><span class="koboSpan" id="kobo.2154.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2155.1">The category of abbreviated function </span><a id="_idIndexMarker1491"/><span class="koboSpan" id="kobo.2156.1">templates is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2157.1">constrained</span></strong><span class="koboSpan" id="kobo.2158.1">. </span><span class="koboSpan" id="kobo.2158.2">The function above is equivalent to the following regular function template:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2159.1">template</span></span><span class="koboSpan" id="kobo.2160.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2161.1">typename</span></span><span class="koboSpan" id="kobo.2162.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2163.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2164.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2165.1">(T a, T b)</span></span><span class="koboSpan" id="kobo.2166.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2167.1">template</span></span><span class="koboSpan" id="kobo.2168.1">&lt;&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2169.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2170.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2171.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2172.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2173.1"> a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2174.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2175.1"> b)</span></span><span class="koboSpan" id="kobo.2176.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2177.1">return</span></span><span class="koboSpan" id="kobo.2178.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2179.1">Since an abbreviated function template is a function template, it can also be specialized like any function declared with the standard template syntax:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2180.1">template</span></span><span class="koboSpan" id="kobo.2181.1"> &lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2182.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2183.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2184.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2185.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2186.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2187.1">* a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2188.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2189.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2190.1">* b)</span></span><span class="koboSpan" id="kobo.2191.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2192.1">return</span></span><span class="koboSpan" id="kobo.2193.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2194.1">string</span></span><span class="koboSpan" id="kobo.2195.1">(a) + std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2196.1">string</span></span><span class="koboSpan" id="kobo.2197.1">(b);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2198.1">Constrained </span><a id="_idIndexMarker1492"/><span class="koboSpan" id="kobo.2199.1">abbreviated function templates can also be variadic; that is, they have a variable number of arguments. </span><span class="koboSpan" id="kobo.2199.2">There is nothing special about them, other than what we already learned in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2200.1">Chapter 5</span></em><span class="koboSpan" id="kobo.2201.1">. </span><span class="koboSpan" id="kobo.2201.2">Moreover, the syntax can also be used to define lambda templates. </span><span class="koboSpan" id="kobo.2201.3">Examples of these were given in the previous section.</span></p>
<h2 class="heading-2" id="_idParaDest-780"><span class="koboSpan" id="kobo.2202.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2203.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2204.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2205.1">Using generic lambdas</span></em><span class="koboSpan" id="kobo.2206.1">, to learn about the use of both generic lambdas and lambda templates</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2207.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2208.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2209.1">Writing function templates</span></em><span class="koboSpan" id="kobo.2210.1"> to explore the syntax for writing function templates</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2211.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2212.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2213.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.2214.1">, to see how you can write functions that take a variable number of arguments</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2215.1">Specifying requirements on template arguments with concepts</span></em><span class="koboSpan" id="kobo.2216.1">, to learn how to constrain the arguments with a function template, with the help of concepts</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-781"><span class="koboSpan" id="kobo.2217.1">Iterating over collections with the ranges library</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2218.1">The C++ standard library</span><a id="_idIndexMarker1493"/><span class="koboSpan" id="kobo.2219.1"> provides three important pillars—containers, iterators, and algorithms—that enable us to work with collections. </span><span class="koboSpan" id="kobo.2219.2">Because these algorithms are for general purposes and are designed to work with iterators, which define a range, they often require writing explicit and sometimes complex code to achieve simple tasks. </span><span class="koboSpan" id="kobo.2219.3">The C++20 ranges library has been designed to solve this problem by providing components for handling ranges of elements. </span><span class="koboSpan" id="kobo.2219.4">These components include range adapters (or views) and constrained algorithms that work with a range instead of iterators. </span><span class="koboSpan" id="kobo.2219.5">In this recipe, we will look at some of these views and algorithms and see how they can simplify coding.</span></p>
<h2 class="heading-2" id="_idParaDest-782"><span class="koboSpan" id="kobo.2220.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2221.1">In the following snippets, we will refer to a function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2222.1">is_prime()</span></code><span class="koboSpan" id="kobo.2223.1">, which takes an integer and returns a Boolean, indicating whether the number is prime or not. </span><span class="koboSpan" id="kobo.2223.2">A simple implementation is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2224.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2225.1">is_prime</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2226.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2227.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2228.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2229.1"> number)</span></span><span class="koboSpan" id="kobo.2230.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2231.1">if</span></span><span class="koboSpan" id="kobo.2232.1"> (number != </span><span class="hljs-number"><span class="koboSpan" id="kobo.2233.1">2</span></span><span class="koboSpan" id="kobo.2234.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2235.1">if</span></span><span class="koboSpan" id="kobo.2236.1"> (number &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2237.1">2</span></span><span class="koboSpan" id="kobo.2238.1"> || number % </span><span class="hljs-number"><span class="koboSpan" id="kobo.2239.1">2</span></span><span class="koboSpan" id="kobo.2240.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2241.1">0</span></span><span class="koboSpan" id="kobo.2242.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2243.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2244.1">false</span></span><span class="koboSpan" id="kobo.2245.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2246.1">auto</span></span><span class="koboSpan" id="kobo.2247.1"> root = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2248.1">sqrt</span></span><span class="koboSpan" id="kobo.2249.1">(number);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2250.1">for</span></span><span class="koboSpan" id="kobo.2251.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2252.1">int</span></span><span class="koboSpan" id="kobo.2253.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2254.1">3</span></span><span class="koboSpan" id="kobo.2255.1">; i &lt;= root; i += </span><span class="hljs-number"><span class="koboSpan" id="kobo.2256.1">2</span></span><span class="koboSpan" id="kobo.2257.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2258.1">if</span></span><span class="koboSpan" id="kobo.2259.1"> (number % i == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2260.1">0</span></span><span class="koboSpan" id="kobo.2261.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2262.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2263.1">false</span></span><span class="koboSpan" id="kobo.2264.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2265.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2266.1">true</span></span><span class="koboSpan" id="kobo.2267.1">;
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2268.1">For an efficient algorithm, which is beyond the scope of this recipe, I recommend the Miller–Rabin primality test.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2269.1">The ranges library is available in the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.2270.1">&lt;ranges&gt;</span></code><span class="koboSpan" id="kobo.2271.1"> header, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2272.1">std::ranges</span></code><span class="koboSpan" id="kobo.2273.1"> namespace. </span><span class="koboSpan" id="kobo.2273.2">For simplicity, the following namespace aliases will be used in this recipe:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2274.1">namespace</span></span><span class="koboSpan" id="kobo.2275.1"> rv = std::ranges::views;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2276.1">namespace</span></span><span class="koboSpan" id="kobo.2277.1"> rg = std::ranges;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2278.1">We will explore various uses of the ranges library in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-783"><span class="koboSpan" id="kobo.2279.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2280.1">The ranges library</span><a id="_idIndexMarker1494"/><span class="koboSpan" id="kobo.2281.1"> can be used to iterate through ranges with operations such as the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2282.1">Generate a sequence of consecutive integers with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2283.1">iota_view</span></code><span class="koboSpan" id="kobo.2284.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2285.1">views::iota</span></code><span class="koboSpan" id="kobo.2286.1"> view. </span><span class="koboSpan" id="kobo.2286.2">The following snippet prints all integers from 1 to 9:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2287.1">for</span></span><span class="koboSpan" id="kobo.2288.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2289.1">auto</span></span><span class="koboSpan" id="kobo.2290.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2291.1">iota</span></span><span class="koboSpan" id="kobo.2292.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2293.1">1</span></span><span class="koboSpan" id="kobo.2294.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2295.1">10</span></span><span class="koboSpan" id="kobo.2296.1">))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2297.1">' '</span></span><span class="koboSpan" id="kobo.2298.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2299.1">Filter the elements of a range with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2300.1">filter_view</span></code><span class="koboSpan" id="kobo.2301.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2302.1">views::filter</span></code><span class="koboSpan" id="kobo.2303.1">, by retaining only those that satisfy a predicate. </span><span class="koboSpan" id="kobo.2303.2">The first snippet here prints all the prime numbers from 1 to 99. </span><span class="koboSpan" id="kobo.2303.3">However, the second snippet retains and prints all the prime numbers from a vector of integers:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2304.1">// prints 2 3 5 7 11 13 ... </span><span class="koboSpan" id="kobo.2304.2">79 83 89 97</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2305.1">for</span></span><span class="koboSpan" id="kobo.2306.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2307.1">auto</span></span><span class="koboSpan" id="kobo.2308.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2309.1">iota</span></span><span class="koboSpan" id="kobo.2310.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2311.1">1</span></span><span class="koboSpan" id="kobo.2312.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2313.1">100</span></span><span class="koboSpan" id="kobo.2314.1">) | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2315.1">filter</span></span><span class="koboSpan" id="kobo.2316.1">(is_prime))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2317.1">' '</span></span><span class="koboSpan" id="kobo.2318.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2319.1">// prints 2 3 5 13</span></span><span class="koboSpan" id="kobo.2320.1">
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2321.1">int</span></span><span class="koboSpan" id="kobo.2322.1">&gt; nums{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2323.1">1</span></span><span class="koboSpan" id="kobo.2324.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2325.1">1</span></span><span class="koboSpan" id="kobo.2326.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2327.1">2</span></span><span class="koboSpan" id="kobo.2328.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2329.1">3</span></span><span class="koboSpan" id="kobo.2330.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2331.1">5</span></span><span class="koboSpan" id="kobo.2332.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2333.1">8</span></span><span class="koboSpan" id="kobo.2334.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2335.1">13</span></span><span class="koboSpan" id="kobo.2336.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2337.1">21</span></span><span class="koboSpan" id="kobo.2338.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2339.1">for</span></span><span class="koboSpan" id="kobo.2340.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2341.1">auto</span></span><span class="koboSpan" id="kobo.2342.1"> i : nums | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2343.1">filter</span></span><span class="koboSpan" id="kobo.2344.1">(is_prime))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2345.1">' '</span></span><span class="koboSpan" id="kobo.2346.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2347.1">Transform the elements of a range with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2348.1">transform_view</span></code><span class="koboSpan" id="kobo.2349.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2350.1">views::transform</span></code><span class="koboSpan" id="kobo.2351.1"> by applying a unary function to each element. </span><span class="koboSpan" id="kobo.2351.2">The following snippet prints the successor of all the prime numbers from 1 to 99:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2352.1">// prints 3 4 6 8 12 14 ... </span><span class="koboSpan" id="kobo.2352.2">80 84 90 98</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2353.1">for</span></span><span class="koboSpan" id="kobo.2354.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2355.1">auto</span></span><span class="koboSpan" id="kobo.2356.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2357.1">iota</span></span><span class="koboSpan" id="kobo.2358.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2359.1">1</span></span><span class="koboSpan" id="kobo.2360.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2361.1">100</span></span><span class="koboSpan" id="kobo.2362.1">) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2363.1">filter</span></span><span class="koboSpan" id="kobo.2364.1">(is_prime) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2365.1">transform</span></span><span class="koboSpan" id="kobo.2366.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2367.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2368.1">const</span></span><span class="koboSpan" id="kobo.2369.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2370.1">return</span></span><span class="koboSpan" id="kobo.2371.1"> n + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2372.1">1</span></span><span class="koboSpan" id="kobo.2373.1">; }))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2374.1">' '</span></span><span class="koboSpan" id="kobo.2375.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2376.1">Retain only the first </span><em class="italic"><span class="koboSpan" id="kobo.2377.1">N</span></em><span class="koboSpan" id="kobo.2378.1"> elements of a view with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2379.1">take_view</span></code><span class="koboSpan" id="kobo.2380.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2381.1">views::take</span></code><span class="koboSpan" id="kobo.2382.1">. </span><span class="koboSpan" id="kobo.2382.2">The following snippet prints only the first 10 prime numbers from 1 and 99:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2383.1">// prints 2 3 5 7 11 13 17 19 23 29</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2384.1">for</span></span><span class="koboSpan" id="kobo.2385.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2386.1">auto</span></span><span class="koboSpan" id="kobo.2387.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2388.1">iota</span></span><span class="koboSpan" id="kobo.2389.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2390.1">1</span></span><span class="koboSpan" id="kobo.2391.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2392.1">100</span></span><span class="koboSpan" id="kobo.2393.1">) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2394.1">filter</span></span><span class="koboSpan" id="kobo.2395.1">(is_prime) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2396.1">take</span></span><span class="koboSpan" id="kobo.2397.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2398.1">10</span></span><span class="koboSpan" id="kobo.2399.1">))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2400.1">' '</span></span><span class="koboSpan" id="kobo.2401.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2402.1">Iterate </span><a id="_idIndexMarker1495"/><span class="koboSpan" id="kobo.2403.1">a range in reverse order with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2404.1">reverse_view</span></code><span class="koboSpan" id="kobo.2405.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2406.1">views::reverse</span></code><span class="koboSpan" id="kobo.2407.1">. </span><span class="koboSpan" id="kobo.2407.2">The first snippet here prints the first 10 prime numbers from 99 to 1 (in descending order), while the second snippet prints the last 10 prime numbers from 1 to 99 (in ascending order):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2408.1">// prints 97 89 83 79 73 71 67 61 59 53</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2409.1">for</span></span><span class="koboSpan" id="kobo.2410.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2411.1">auto</span></span><span class="koboSpan" id="kobo.2412.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2413.1">iota</span></span><span class="koboSpan" id="kobo.2414.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2415.1">1</span></span><span class="koboSpan" id="kobo.2416.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2417.1">100</span></span><span class="koboSpan" id="kobo.2418.1">) |
              rv::reverse |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2419.1">filter</span></span><span class="koboSpan" id="kobo.2420.1">(is_prime) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2421.1">take</span></span><span class="koboSpan" id="kobo.2422.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2423.1">10</span></span><span class="koboSpan" id="kobo.2424.1">))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2425.1">' '</span></span><span class="koboSpan" id="kobo.2426.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2427.1">// prints 53 59 61 67 71 73 79 83 89 97</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2428.1">for</span></span><span class="koboSpan" id="kobo.2429.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2430.1">auto</span></span><span class="koboSpan" id="kobo.2431.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2432.1">iota</span></span><span class="koboSpan" id="kobo.2433.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2434.1">1</span></span><span class="koboSpan" id="kobo.2435.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2436.1">100</span></span><span class="koboSpan" id="kobo.2437.1">) |
              rv::reverse |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2438.1">filter</span></span><span class="koboSpan" id="kobo.2439.1">(is_prime) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2440.1">take</span></span><span class="koboSpan" id="kobo.2441.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2442.1">10</span></span><span class="koboSpan" id="kobo.2443.1">) |
              rv::reverse)
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2444.1">' '</span></span><span class="koboSpan" id="kobo.2445.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2446.1">Skip the first </span><em class="italic"><span class="koboSpan" id="kobo.2447.1">N</span></em><span class="koboSpan" id="kobo.2448.1"> elements of a range with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2449.1">drop_view</span></code><span class="koboSpan" id="kobo.2450.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2451.1">views::drop</span></code><span class="koboSpan" id="kobo.2452.1">. </span><span class="koboSpan" id="kobo.2452.2">The snippet here prints, in ascending order, the prime numbers between 1 and 99, but it skips the first and last 10 primes in the sequence:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2453.1">// prints 31 37 41 43 47</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2454.1">for</span></span><span class="koboSpan" id="kobo.2455.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2456.1">auto</span></span><span class="koboSpan" id="kobo.2457.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2458.1">iota</span></span><span class="koboSpan" id="kobo.2459.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2460.1">1</span></span><span class="koboSpan" id="kobo.2461.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2462.1">100</span></span><span class="koboSpan" id="kobo.2463.1">) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2464.1">filter</span></span><span class="koboSpan" id="kobo.2465.1">(is_prime) |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2466.1">drop</span></span><span class="koboSpan" id="kobo.2467.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2468.1">10</span></span><span class="koboSpan" id="kobo.2469.1">) |
              rv::reverse |
              rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2470.1">drop</span></span><span class="koboSpan" id="kobo.2471.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2472.1">10</span></span><span class="koboSpan" id="kobo.2473.1">) |
              rv::reverse)
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2474.1">' '</span></span><span class="koboSpan" id="kobo.2475.1">;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2476.1">The ranges library can also be used to call algorithms using a range instead of iterators. </span><span class="koboSpan" id="kobo.2476.2">Most algorithms have overloads for this purpose. </span><span class="koboSpan" id="kobo.2476.3">Examples are shown here:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2477.1">Determine the maximum element of a range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2478.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2479.1">int</span></span><span class="koboSpan" id="kobo.2480.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2481.1">5</span></span><span class="koboSpan" id="kobo.2482.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2483.1">2</span></span><span class="koboSpan" id="kobo.2484.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2485.1">7</span></span><span class="koboSpan" id="kobo.2486.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2487.1">1</span></span><span class="koboSpan" id="kobo.2488.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2489.1">4</span></span><span class="koboSpan" id="kobo.2490.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2491.1">2</span></span><span class="koboSpan" id="kobo.2492.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2493.1">9</span></span><span class="koboSpan" id="kobo.2494.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2495.1">5</span></span><span class="koboSpan" id="kobo.2496.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2497.1">auto</span></span><span class="koboSpan" id="kobo.2498.1"> m = rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2499.1">max</span></span><span class="koboSpan" id="kobo.2500.1">(v); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2501.1">// 5</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2502.1">Sort a range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2503.1">rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2504.1">sort</span></span><span class="koboSpan" id="kobo.2505.1">(v); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2506.1">// 1 2 2 4 5 5 7 9</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2507.1">Copy a range. </span><span class="koboSpan" id="kobo.2507.2">The following snippet copies the elements of the range to the standard output stream:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2508.1">rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2509.1">copy</span></span><span class="koboSpan" id="kobo.2510.1">(v, std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2511.1">ostream_iterator</span></span><span class="koboSpan" id="kobo.2512.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2513.1">int</span></span><span class="koboSpan" id="kobo.2514.1">&gt;(std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2515.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2516.1"> "</span></span><span class="koboSpan" id="kobo.2517.1">));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2518.1">Reverse the elements of a range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2519.1">rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2520.1">reverse</span></span><span class="koboSpan" id="kobo.2521.1">(v);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2522.1">Count the elements of a range (that verify a predicate):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2523.1">auto</span></span><span class="koboSpan" id="kobo.2524.1"> primes = rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2525.1">count_if</span></span><span class="koboSpan" id="kobo.2526.1">(v, is_prime);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-784"><span class="koboSpan" id="kobo.2527.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2528.1">The C++20 ranges library</span><a id="_idIndexMarker1496"/><span class="koboSpan" id="kobo.2529.1"> provides various components for dealing with ranges of elements. </span><span class="koboSpan" id="kobo.2529.2">These include:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2530.1">Range concepts, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2531.1">range</span></code><span class="koboSpan" id="kobo.2532.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2533.1">view</span></code><span class="koboSpan" id="kobo.2534.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2535.1">Range access functions, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2536.1">begin()</span></code><span class="koboSpan" id="kobo.2537.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2538.1">end()</span></code><span class="koboSpan" id="kobo.2539.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2540.1">size()</span></code><span class="koboSpan" id="kobo.2541.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2542.1">empty()</span></code><span class="koboSpan" id="kobo.2543.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2544.1">data()</span></code><span class="koboSpan" id="kobo.2545.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2546.1">Range factories that create sequences of elements, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2547.1">empty_view</span></code><span class="koboSpan" id="kobo.2548.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2549.1">single_view</span></code><span class="koboSpan" id="kobo.2550.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2551.1">iota_view</span></code><span class="koboSpan" id="kobo.2552.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2553.1">Range adaptors, or views, that create a lazy evaluated view from a range, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2554.1">filter_view</span></code><span class="koboSpan" id="kobo.2555.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2556.1">transform_view</span></code><span class="koboSpan" id="kobo.2557.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2558.1">take_view</span></code><span class="koboSpan" id="kobo.2559.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2560.1">drop_view</span></code><span class="koboSpan" id="kobo.2561.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2562.1">A range is </span><a id="_idIndexMarker1497"/><span class="koboSpan" id="kobo.2563.1">defined as a sequence of elements that can be iterated over with an iterator and an end sentinel. </span><span class="koboSpan" id="kobo.2563.2">Ranges are of different types, depending on the capabilities of the iterators that define the range. </span><span class="koboSpan" id="kobo.2563.3">The following concepts define types of ranges:</span></p>
<table class="table-container" id="table001-8">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2564.1">Concept</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2565.1">Iterator type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2566.1">Capabilities</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2567.1">input_range</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2568.1">input_iterator</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2569.1">Can be iterated at least once for reading.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2570.1">output_range</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2571.1">output_iterator</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2572.1">Can be iterated For writing.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2573.1">forward_range</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2574.1">forward_iterator</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2575.1">Can be iterated multiple times.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2576.1">bidirectional_range</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2577.1">bidirectional_iterator</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2578.1">Can be iterated also in reverse order.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2579.1">random_access_range</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2580.1">random_access_iterator</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2581.1">Elements can be accessed randomly in constant time.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2582.1">contiguous_range</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2583.1">contiguous_iterator</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2584.1">Elements are stored contiguously in memory.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2585.1">Table 12.1: The list of concepts that define the types of ranges</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2586.1">Because a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">forward_iterator</span></code><span class="koboSpan" id="kobo.2588.1"> satisfies the requirements of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2589.1">input_iterator</span></code><span class="koboSpan" id="kobo.2590.1">, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2591.1">bidirectional_iterator</span></code><span class="koboSpan" id="kobo.2592.1"> satisfies those of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2593.1">forward_iterator</span></code><span class="koboSpan" id="kobo.2594.1">, and so on (from top to bottom in the preceding table), so do the ranges. </span><span class="koboSpan" id="kobo.2594.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.2595.1">forward_range</span></code><span class="koboSpan" id="kobo.2596.1"> satisfies the requirements of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2597.1">input_range</span></code><span class="koboSpan" id="kobo.2598.1">, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2599.1">bidirectional_range</span></code><span class="koboSpan" id="kobo.2600.1"> satisfies those of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2601.1">forward_range</span></code><span class="koboSpan" id="kobo.2602.1">, and so on. </span><span class="koboSpan" id="kobo.2602.2">Apart from the range concepts listed in the preceding table, there are other range concepts. </span><span class="koboSpan" id="kobo.2602.3">One worth mentioning is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2603.1">sized_range</span></code><span class="koboSpan" id="kobo.2604.1">, which requires that a range must know its size in constant time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2605.1">The standard containers meet the requirements of different range concepts. </span><span class="koboSpan" id="kobo.2605.2">The most important of them are listed in the following table:</span></p>
<table class="table-container" id="table002-7">
<tbody>
<tr>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2606.1">Input range</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2607.1">Forward range</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2608.1">Bidirectional range</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2609.1">Random access range</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2610.1">Contiguous range</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2611.1">forward_list</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2612.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2613.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2614.1">list</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2615.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2616.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2617.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2618.1">dequeue</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2619.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2620.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2621.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2622.1">✓</span></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2623.1">array</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2624.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2625.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2626.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2627.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2628.1">✓</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2629.1">vector</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2630.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2631.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2632.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2633.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2634.1">✓</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2635.1">set</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2636.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2637.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2638.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2639.1">map</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2640.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2641.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2642.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2643.1">multiset</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2644.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2645.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2646.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2647.1">multimap</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2648.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2649.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2650.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2651.1">unordered_set</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2652.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2653.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2654.1">unordered_map</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2655.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2656.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2657.1">unordered_multiset</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2658.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2659.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2660.1">unordered_multimap</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2661.1">✓</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2662.1">✓</span></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2663.1">Table 12.2: A list of standard containers and the requirements they meet</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2664.1">A</span><a id="_idIndexMarker1498"/><span class="koboSpan" id="kobo.2665.1"> central concept of the ranges library is the range </span><em class="italic"><span class="koboSpan" id="kobo.2666.1">adaptor</span></em><span class="koboSpan" id="kobo.2667.1">, also called a </span><em class="italic"><span class="koboSpan" id="kobo.2668.1">view</span></em><span class="koboSpan" id="kobo.2669.1">. </span><span class="koboSpan" id="kobo.2669.2">A view is a non-owning wrapper of a range of elements that requires constant time to copy, move, or assign elements. </span><span class="koboSpan" id="kobo.2669.3">Views are composable adaptations of ranges. </span><span class="koboSpan" id="kobo.2669.4">However, these adaptations happen lazily, only when the view is iterated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2670.1">In the previous section, we saw examples of using various views: filter, transform, take, drop, and reverse. </span><span class="koboSpan" id="kobo.2670.2">There are a total of 16 views available in the library. </span><span class="koboSpan" id="kobo.2670.3">All the views are available in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2671.1">std::ranges</span></code><span class="koboSpan" id="kobo.2672.1"> and have names such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2673.1">filter_view</span></code><span class="koboSpan" id="kobo.2674.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2675.1">transform_view</span></code><span class="koboSpan" id="kobo.2676.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2677.1">take_view</span></code><span class="koboSpan" id="kobo.2678.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2679.1">drop_view</span></code><span class="koboSpan" id="kobo.2680.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2681.1">reverse_view</span></code><span class="koboSpan" id="kobo.2682.1">. </span><span class="koboSpan" id="kobo.2682.2">However, for simplicity of use, these views can be used with expressions of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.2683.1">views::filter</span></code><span class="koboSpan" id="kobo.2684.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2685.1">views::take</span></code><span class="koboSpan" id="kobo.2686.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2687.1">views::reverse</span></code><span class="koboSpan" id="kobo.2688.1">, and so on. </span><span class="koboSpan" id="kobo.2688.2">Notice that the types and values of these expressions are unspecified and are a compiler implementation detail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2689.1">To understand how the views work, let’s take a look at the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2690.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2691.1">int</span></span><span class="koboSpan" id="kobo.2692.1">&gt; nums{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2693.1">1</span></span><span class="koboSpan" id="kobo.2694.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2695.1">1</span></span><span class="koboSpan" id="kobo.2696.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2697.1">2</span></span><span class="koboSpan" id="kobo.2698.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2699.1">3</span></span><span class="koboSpan" id="kobo.2700.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2701.1">5</span></span><span class="koboSpan" id="kobo.2702.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2703.1">8</span></span><span class="koboSpan" id="kobo.2704.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2705.1">13</span></span><span class="koboSpan" id="kobo.2706.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2707.1">21</span></span><span class="koboSpan" id="kobo.2708.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2709.1">auto</span></span><span class="koboSpan" id="kobo.2710.1"> v = nums | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2711.1">filter</span></span><span class="koboSpan" id="kobo.2712.1">(is_prime) | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2713.1">take</span></span><span class="koboSpan" id="kobo.2714.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2715.1">3</span></span><span class="koboSpan" id="kobo.2716.1">) | rv::reverse;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2717.1">for</span></span><span class="koboSpan" id="kobo.2718.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2719.1">auto</span></span><span class="koboSpan" id="kobo.2720.1"> i : v) std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2721.1">' '</span></span><span class="koboSpan" id="kobo.2722.1">; // prints 5 3 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2723.1">The object </span><code class="inlineCode"><span class="koboSpan" id="kobo.2724.1">v</span></code><span class="koboSpan" id="kobo.2725.1"> in this snippet represents a view. </span><span class="koboSpan" id="kobo.2725.2">It does not evaluate the range it adapts until we start iterating over the elements. </span><span class="koboSpan" id="kobo.2725.3">This is done, in this example, with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2726.1">for</span></code><span class="koboSpan" id="kobo.2727.1"> statement. </span><span class="koboSpan" id="kobo.2727.2">The views are said to be lazy. </span><span class="koboSpan" id="kobo.2727.3">The pipe operator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2728.1">|</span></code><span class="koboSpan" id="kobo.2729.1">) is overloaded to simplify the composition of views.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2730.1">The composition of views is equivalent to the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2731.1">auto</span></span><span class="koboSpan" id="kobo.2732.1"> v = rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2733.1">reverse</span></span><span class="koboSpan" id="kobo.2734.1">(rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2735.1">take</span></span><span class="koboSpan" id="kobo.2736.1">(rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2737.1">filter</span></span><span class="koboSpan" id="kobo.2738.1">(nums, is_prime), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2739.1">3</span></span><span class="koboSpan" id="kobo.2740.1">));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2741.1">In general, the following rules apply:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2742.1">If an adaptor </span><code class="inlineCode"><span class="koboSpan" id="kobo.2743.1">A</span></code><span class="koboSpan" id="kobo.2744.1"> takes only one argument, a range </span><code class="inlineCode"><span class="koboSpan" id="kobo.2745.1">R</span></code><span class="koboSpan" id="kobo.2746.1">, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.2747.1">A(R)</span></code><span class="koboSpan" id="kobo.2748.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2749.1">R|A</span></code><span class="koboSpan" id="kobo.2750.1"> are equivalent.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2751.1">If an adaptor </span><code class="inlineCode"><span class="koboSpan" id="kobo.2752.1">A</span></code><span class="koboSpan" id="kobo.2753.1"> takes multiple arguments, a range </span><code class="inlineCode"><span class="koboSpan" id="kobo.2754.1">R</span></code><span class="koboSpan" id="kobo.2755.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2756.1">args...</span></code><span class="koboSpan" id="kobo.2757.1">, then the following three are equivalent: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2758.1">A(R, args...)</span></code><span class="koboSpan" id="kobo.2759.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2760.1">A(args...)(R)</span></code><span class="koboSpan" id="kobo.2761.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2762.1">R|A(args...)</span></code><span class="koboSpan" id="kobo.2763.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2764.1">Apart from ranges and range adaptors (or views), overloads of the general-purpose algorithms are also available in C++20, in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.2765.1">std::ranges</span></code><span class="koboSpan" id="kobo.2766.1"> namespace. </span><span class="koboSpan" id="kobo.2766.2">These overloads are</span><a id="_idIndexMarker1499"/><span class="koboSpan" id="kobo.2767.1"> called </span><em class="italic"><span class="koboSpan" id="kobo.2768.1">constrained algorithms</span></em><span class="koboSpan" id="kobo.2769.1">. </span><span class="koboSpan" id="kobo.2769.2">A range can be provided either as a single argument (as seen in the examples in this recipe) or as an iterator-sentinel pair. </span><span class="koboSpan" id="kobo.2769.3">Also, for these overloads, the </span><a id="_idIndexMarker1500"/><span class="koboSpan" id="kobo.2770.1">return type has been changed to provide additional information that’s computed during the execution of the algorithm.</span></p>
<h2 class="heading-2" id="_idParaDest-785"><span class="koboSpan" id="kobo.2771.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2772.1">The standard ranges library has been designed based</span><a id="_idIndexMarker1501"/><span class="koboSpan" id="kobo.2773.1"> on the </span><strong class="keyWord"><span class="koboSpan" id="kobo.2774.1">range-v3</span></strong><span class="koboSpan" id="kobo.2775.1"> library, created by Eric Niebler and available on GitHub at </span><a href="https://github.com/ericniebler/range-v3"><span class="url"><span class="koboSpan" id="kobo.2776.1">https://github.com/ericniebler/range-v3</span></span></a><span class="koboSpan" id="kobo.2777.1">. </span><span class="koboSpan" id="kobo.2777.2">This</span><a id="_idIndexMarker1502"/><span class="koboSpan" id="kobo.2778.1"> library provides a larger set of range adaptors (views), as well as actions that provide mutating operations (such as sorting, erasing, shuffling, and so on). </span><span class="koboSpan" id="kobo.2778.2">The transition from the range-v3 library to the C++20 ranges library can be very smooth. </span><span class="koboSpan" id="kobo.2778.3">In fact, all the samples provided in this recipe work with both libraries. </span><span class="koboSpan" id="kobo.2778.4">All you have to do is include the appropriate header files and use the range-v3-specific namespaces:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.2779.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2780.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2781.1">"range/v3/view.hpp"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2782.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2783.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2784.1">"range/v3/algorithm/sort.hpp"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2785.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2786.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2787.1">"range/v3/algorithm/copy.hpp"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2788.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2789.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2790.1">"range/v3/algorithm/reverse.hpp"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2791.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2792.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2793.1">"range/v3/algorithm/count_if.hpp"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2794.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2795.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2796.1">"range/v3/algorithm/max.hpp"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2797.1">namespace</span></span><span class="koboSpan" id="kobo.2798.1"> rv = ranges::views;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2799.1">namespace</span></span><span class="koboSpan" id="kobo.2800.1"> rg = ranges;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2801.1">With these replacements, all the snippets from the </span><em class="italic"><span class="koboSpan" id="kobo.2802.1">How to do it...</span></em><span class="koboSpan" id="kobo.2803.1"> section will continue to work using a C++17-compliant compiler.</span></p>
<h2 class="heading-2" id="_idParaDest-786"><span class="koboSpan" id="kobo.2804.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2805.1">Creating your own range view</span></em><span class="koboSpan" id="kobo.2806.1">, to see how to extend the ranges library’s capabilities with user-defined range adaptors</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2807.1">Specifying requirements on template arguments with concepts</span></em><span class="koboSpan" id="kobo.2808.1">, to explore the fundamentals of C++20 concepts</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-787"><span class="koboSpan" id="kobo.2809.1">Exploring the standard range adaptors</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2810.1">In the previous recipe, we </span><a id="_idIndexMarker1503"/><span class="koboSpan" id="kobo.2811.1">looked at how the ranges library helps us simplify various tasks when working with collections (ranges), such as enumerating, filtering, transforming, and reversing. </span><span class="koboSpan" id="kobo.2811.2">We did so with the help of range adaptors. </span><span class="koboSpan" id="kobo.2811.3">However, we have only looked at a small set of adaptors. </span><span class="koboSpan" id="kobo.2811.4">There are more available in the standard library, some included in C++20 and others in C++23. </span><span class="koboSpan" id="kobo.2811.5">In this recipe, we will explore all the adapters in the standard library.</span></p>
<h2 class="heading-2" id="_idParaDest-788"><span class="koboSpan" id="kobo.2812.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2813.1">In the snippets shown in this recipe, we will use the following namespace aliases:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2814.1">namespace</span></span><span class="koboSpan" id="kobo.2815.1"> rv = std::ranges::views;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2816.1">namespace</span></span><span class="koboSpan" id="kobo.2817.1"> rg = std::ranges;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2818.1">Also, to compile the snippets below, you need to include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2819.1">&lt;ranges&gt;</span></code><span class="koboSpan" id="kobo.2820.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2821.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.2822.1"> headers (for the ranges library).</span></p>
<h2 class="heading-2" id="_idParaDest-789"><span class="koboSpan" id="kobo.2823.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2824.1">In C++20, the following</span><a id="_idIndexMarker1504"/><span class="koboSpan" id="kobo.2825.1"> adaptors are available to use:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2826.1">ranges::filter_view</span></code><span class="koboSpan" id="kobo.2827.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2828.1">views::filter</span></code><span class="koboSpan" id="kobo.2829.1"> represents a view of the underlying sequence but without the elements that do not satisfy a specified predicate:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2830.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2831.1">int</span></span><span class="koboSpan" id="kobo.2832.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2833.1">1</span></span><span class="koboSpan" id="kobo.2834.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2835.1">1</span></span><span class="koboSpan" id="kobo.2836.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2837.1">2</span></span><span class="koboSpan" id="kobo.2838.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2839.1">3</span></span><span class="koboSpan" id="kobo.2840.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2841.1">5</span></span><span class="koboSpan" id="kobo.2842.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2843.1">8</span></span><span class="koboSpan" id="kobo.2844.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2845.1">13</span></span><span class="koboSpan" id="kobo.2846.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2847.1">auto</span></span><span class="koboSpan" id="kobo.2848.1"> primes = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2849.1">filter</span></span><span class="koboSpan" id="kobo.2850.1">(is_prime);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2851.1">copy</span></span><span class="koboSpan" id="kobo.2852.1">(primes, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2853.1">int</span></span><span class="koboSpan" id="kobo.2854.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2855.1">" "</span></span><span class="koboSpan" id="kobo.2856.1"> }); 
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2857.1">2 3 5 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2858.1">ranges::transform_view</span></code><span class="koboSpan" id="kobo.2859.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2860.1">views::transform</span></code><span class="koboSpan" id="kobo.2861.1"> represents a view of the underlying sequence after applying a specified function to each element of the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2862.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2863.1">int</span></span><span class="koboSpan" id="kobo.2864.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2865.1">1</span></span><span class="koboSpan" id="kobo.2866.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2867.1">1</span></span><span class="koboSpan" id="kobo.2868.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2869.1">2</span></span><span class="koboSpan" id="kobo.2870.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2871.1">3</span></span><span class="koboSpan" id="kobo.2872.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2873.1">5</span></span><span class="koboSpan" id="kobo.2874.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2875.1">8</span></span><span class="koboSpan" id="kobo.2876.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2877.1">13</span></span><span class="koboSpan" id="kobo.2878.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2879.1">auto</span></span><span class="koboSpan" id="kobo.2880.1"> letters = numbers | 
               rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2881.1">transform</span></span><span class="koboSpan" id="kobo.2882.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2883.1">int</span></span><span class="koboSpan" id="kobo.2884.1"> i) { 
                  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2885.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2886.1">static_cast</span></span><span class="koboSpan" id="kobo.2887.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2888.1">char</span></span><span class="koboSpan" id="kobo.2889.1">&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2890.1">'A'</span></span><span class="koboSpan" id="kobo.2891.1"> + i); });
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2892.1">copy</span></span><span class="koboSpan" id="kobo.2893.1">(letters, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2894.1">char</span></span><span class="koboSpan" id="kobo.2895.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2896.1">" "</span></span><span class="koboSpan" id="kobo.2897.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2898.1">B B C D F I N
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2899.1">ranges::take_view</span></code><span class="koboSpan" id="kobo.2900.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2901.1">views::take</span></code><span class="koboSpan" id="kobo.2902.1"> represents a view of the underlying sequence, starting at the beginning and containing the specified number of elements:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2903.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2904.1">int</span></span><span class="koboSpan" id="kobo.2905.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2906.1">1</span></span><span class="koboSpan" id="kobo.2907.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2908.1">1</span></span><span class="koboSpan" id="kobo.2909.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2910.1">2</span></span><span class="koboSpan" id="kobo.2911.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2912.1">3</span></span><span class="koboSpan" id="kobo.2913.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2914.1">5</span></span><span class="koboSpan" id="kobo.2915.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2916.1">8</span></span><span class="koboSpan" id="kobo.2917.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2918.1">13</span></span><span class="koboSpan" id="kobo.2919.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2920.1">auto</span></span><span class="koboSpan" id="kobo.2921.1"> some_numbers = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2922.1">take</span></span><span class="koboSpan" id="kobo.2923.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2924.1">3</span></span><span class="koboSpan" id="kobo.2925.1">);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2926.1">copy</span></span><span class="koboSpan" id="kobo.2927.1">(some_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2928.1">int</span></span><span class="koboSpan" id="kobo.2929.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2930.1">" "</span></span><span class="koboSpan" id="kobo.2931.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2932.1">1 1 2
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2933.1">ranges::take_while_view</span></code><span class="koboSpan" id="kobo.2934.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2935.1">views::take_while</span></code><span class="koboSpan" id="kobo.2936.1"> represents a view of the underlying sequence, starting at the beginning and containing all the consecutive elements that satisfy a given predicate:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2937.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2938.1">int</span></span><span class="koboSpan" id="kobo.2939.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2940.1">1</span></span><span class="koboSpan" id="kobo.2941.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2942.1">1</span></span><span class="koboSpan" id="kobo.2943.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2944.1">2</span></span><span class="koboSpan" id="kobo.2945.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2946.1">3</span></span><span class="koboSpan" id="kobo.2947.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2948.1">5</span></span><span class="koboSpan" id="kobo.2949.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2950.1">8</span></span><span class="koboSpan" id="kobo.2951.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2952.1">13</span></span><span class="koboSpan" id="kobo.2953.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2954.1">auto</span></span><span class="koboSpan" id="kobo.2955.1"> some_numbers = numbers | 
                    rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2956.1">take_while</span></span><span class="koboSpan" id="kobo.2957.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2958.1">int</span></span><span class="koboSpan" id="kobo.2959.1"> i) { 
                       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2960.1">return</span></span><span class="koboSpan" id="kobo.2961.1"> i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2962.1">3</span></span><span class="koboSpan" id="kobo.2963.1">; });});
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2964.1">copy</span></span><span class="koboSpan" id="kobo.2965.1">(some_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2966.1">int</span></span><span class="koboSpan" id="kobo.2967.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2968.1">" "</span></span><span class="koboSpan" id="kobo.2969.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2970.1">1 1 2
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2971.1">ranges::drop_view</span></code><span class="koboSpan" id="kobo.2972.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.2973.1">views::drop</span></code><span class="koboSpan" id="kobo.2974.1"> represents a view of the underlying sequence after skipping the specified number of elements:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2975.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2976.1">int</span></span><span class="koboSpan" id="kobo.2977.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2978.1">1</span></span><span class="koboSpan" id="kobo.2979.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2980.1">1</span></span><span class="koboSpan" id="kobo.2981.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2982.1">2</span></span><span class="koboSpan" id="kobo.2983.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2984.1">3</span></span><span class="koboSpan" id="kobo.2985.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2986.1">5</span></span><span class="koboSpan" id="kobo.2987.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2988.1">8</span></span><span class="koboSpan" id="kobo.2989.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2990.1">13</span></span><span class="koboSpan" id="kobo.2991.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2992.1">auto</span></span><span class="koboSpan" id="kobo.2993.1"> some_numbers = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2994.1">drop</span></span><span class="koboSpan" id="kobo.2995.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2996.1">3</span></span><span class="koboSpan" id="kobo.2997.1">);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2998.1">copy</span></span><span class="koboSpan" id="kobo.2999.1">(some_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3000.1">int</span></span><span class="koboSpan" id="kobo.3001.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3002.1">" "</span></span><span class="koboSpan" id="kobo.3003.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3004.1">3 5 8 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3005.1">ranges::drop_while_view</span></code><span class="koboSpan" id="kobo.3006.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3007.1">views::drop_while</span></code><span class="koboSpan" id="kobo.3008.1"> represents a view of the underlying sequence after skipping all the consecutive elements (from the beginning) that </span><a id="_idIndexMarker1505"/><span class="koboSpan" id="kobo.3009.1">satisfy a given predicate:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3010.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3011.1">int</span></span><span class="koboSpan" id="kobo.3012.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3013.1">1</span></span><span class="koboSpan" id="kobo.3014.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3015.1">1</span></span><span class="koboSpan" id="kobo.3016.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3017.1">2</span></span><span class="koboSpan" id="kobo.3018.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3019.1">3</span></span><span class="koboSpan" id="kobo.3020.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3021.1">5</span></span><span class="koboSpan" id="kobo.3022.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3023.1">8</span></span><span class="koboSpan" id="kobo.3024.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3025.1">13</span></span><span class="koboSpan" id="kobo.3026.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3027.1">auto</span></span><span class="koboSpan" id="kobo.3028.1"> some_numbers = numbers | 
                    rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3029.1">drop_while</span></span><span class="koboSpan" id="kobo.3030.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3031.1">int</span></span><span class="koboSpan" id="kobo.3032.1"> i) { 
                       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3033.1">return</span></span><span class="koboSpan" id="kobo.3034.1"> i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3035.1">3</span></span><span class="koboSpan" id="kobo.3036.1">; });
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3037.1">copy</span></span><span class="koboSpan" id="kobo.3038.1">(some_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3039.1">int</span></span><span class="koboSpan" id="kobo.3040.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3041.1">" "</span></span><span class="koboSpan" id="kobo.3042.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3043.1">3 5 8 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3044.1">ranges::join_view</span></code><span class="koboSpan" id="kobo.3045.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3046.1">views::join</span></code><span class="koboSpan" id="kobo.3047.1"> flattens a view of ranges; it represents a view consisting of all the elements of a sequence of sequences:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3048.1">std::vector&lt;std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3049.1">int</span></span><span class="koboSpan" id="kobo.3050.1">&gt;&gt; numbers{ {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3051.1">1</span></span><span class="koboSpan" id="kobo.3052.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3053.1">1</span></span><span class="koboSpan" id="kobo.3054.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3055.1">2</span></span><span class="koboSpan" id="kobo.3056.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3057.1">3</span></span><span class="koboSpan" id="kobo.3058.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3059.1">5</span></span><span class="koboSpan" id="kobo.3060.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3061.1">8</span></span><span class="koboSpan" id="kobo.3062.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3063.1">13</span></span><span class="koboSpan" id="kobo.3064.1">} };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3065.1">auto</span></span><span class="koboSpan" id="kobo.3066.1"> joined_numbers = numbers | rv::join;
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3067.1">copy</span></span><span class="koboSpan" id="kobo.3068.1">(joined_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3069.1">int</span></span><span class="koboSpan" id="kobo.3070.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3071.1">" "</span></span><span class="koboSpan" id="kobo.3072.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3073.1">1 1 2 3 5 8 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3074.1">ranges::split_view</span></code><span class="koboSpan" id="kobo.3075.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3076.1">views::split</span></code><span class="koboSpan" id="kobo.3077.1"> represents a view of subranges obtained by splitting a view with a specified delimiter. </span><span class="koboSpan" id="kobo.3077.2">The delimiter is not part of the resulting subranges:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3078.1">std::string text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3079.1">"Hello, world!"</span></span><span class="koboSpan" id="kobo.3080.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3081.1">auto</span></span><span class="koboSpan" id="kobo.3082.1"> words = text | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3083.1">split</span></span><span class="koboSpan" id="kobo.3084.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3085.1">' '</span></span><span class="koboSpan" id="kobo.3086.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3087.1">for</span></span><span class="koboSpan" id="kobo.3088.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3089.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3090.1">const</span></span><span class="koboSpan" id="kobo.3091.1"> word : words)
{
   std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3092.1">quoted</span></span><span class="koboSpan" id="kobo.3093.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3094.1">string_view</span></span><span class="koboSpan" id="kobo.3095.1">(word)) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3096.1">' '</span></span><span class="koboSpan" id="kobo.3097.1">;
}
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3098.1">"Hello," "world!"
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3099.1">ranges::lazy_split_view</span></code><span class="koboSpan" id="kobo.3100.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3101.1">views::lazy_split</span></code><span class="koboSpan" id="kobo.3102.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3103.1">split</span></code><span class="koboSpan" id="kobo.3104.1">, except that it works in a </span><em class="italic"><span class="koboSpan" id="kobo.3105.1">lazy mode</span></em><span class="koboSpan" id="kobo.3106.1">, meaning that it does not look ahead for the next delimiter until we iterate for the next element of the result. </span><span class="koboSpan" id="kobo.3106.2">It works with constant </span><a id="_idIndexMarker1506"/><span class="koboSpan" id="kobo.3107.1">ranges, which are not supported by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3108.1">split_view</span></code><span class="koboSpan" id="kobo.3109.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3110.1">std::string text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3111.1">"Hello, world!"</span></span><span class="koboSpan" id="kobo.3112.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3113.1">auto</span></span><span class="koboSpan" id="kobo.3114.1"> words = text | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3115.1">lazy_split</span></span><span class="koboSpan" id="kobo.3116.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3117.1">' '</span></span><span class="koboSpan" id="kobo.3118.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3119.1">for</span></span><span class="koboSpan" id="kobo.3120.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3121.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3122.1">const</span></span><span class="koboSpan" id="kobo.3123.1"> word : words)
{
   std::cout &lt;&lt; 
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3124.1">quoted</span></span><span class="koboSpan" id="kobo.3125.1">(std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3126.1">to</span></span><span class="koboSpan" id="kobo.3127.1">&lt;std::string&gt;(word)) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3128.1">' '</span></span><span class="koboSpan" id="kobo.3129.1">;
}
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3130.1">"Hello," "world!"
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3131.1">ranges::reverse_view</span></code><span class="koboSpan" id="kobo.3132.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3133.1">views::reverse</span></code><span class="koboSpan" id="kobo.3134.1"> represents a view of an underlying sequence with the elements presented in the reverse order:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3135.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3136.1">int</span></span><span class="koboSpan" id="kobo.3137.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3138.1">1</span></span><span class="koboSpan" id="kobo.3139.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3140.1">1</span></span><span class="koboSpan" id="kobo.3141.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3142.1">2</span></span><span class="koboSpan" id="kobo.3143.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3144.1">3</span></span><span class="koboSpan" id="kobo.3145.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3146.1">5</span></span><span class="koboSpan" id="kobo.3147.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3148.1">8</span></span><span class="koboSpan" id="kobo.3149.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3150.1">13</span></span><span class="koboSpan" id="kobo.3151.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3152.1">auto</span></span><span class="koboSpan" id="kobo.3153.1"> reversed_numbers = numbers | rv::reverse;
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3154.1">copy</span></span><span class="koboSpan" id="kobo.3155.1">(reversed_numbers, 
         std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3156.1">int</span></span><span class="koboSpan" id="kobo.3157.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3158.1">" "</span></span><span class="koboSpan" id="kobo.3159.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3160.1">13 8 5 3 2 1 1
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3161.1">ranges::elements_view</span></code><span class="koboSpan" id="kobo.3162.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3163.1">views::elements</span></code><span class="koboSpan" id="kobo.3164.1"> represents a view of the </span><em class="italic"><span class="koboSpan" id="kobo.3165.1">N</span></em><span class="koboSpan" id="kobo.3166.1">th element of an underlying sequence of tuple-like values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3167.1">std::vector&lt;std::tuple&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3168.1">int</span></span><span class="koboSpan" id="kobo.3169.1">, std::string_view&gt;&gt; numbers{
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3170.1">1</span></span><span class="koboSpan" id="kobo.3171.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3172.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3173.1">one"</span></span><span class="koboSpan" id="kobo.3174.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3175.1">1</span></span><span class="koboSpan" id="kobo.3176.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3177.1">"one"</span></span><span class="koboSpan" id="kobo.3178.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3179.1">2</span></span><span class="koboSpan" id="kobo.3180.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3181.1">"two"</span></span><span class="koboSpan" id="kobo.3182.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3183.1">3</span></span><span class="koboSpan" id="kobo.3184.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3185.1">"three"</span></span><span class="koboSpan" id="kobo.3186.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3187.1">5</span></span><span class="koboSpan" id="kobo.3188.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3189.1">"five"</span></span><span class="koboSpan" id="kobo.3190.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3191.1">8</span></span><span class="koboSpan" id="kobo.3192.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3193.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3194.1">eight"</span></span><span class="koboSpan" id="kobo.3195.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3196.1">13</span></span><span class="koboSpan" id="kobo.3197.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3198.1">"thirteen"</span></span><span class="koboSpan" id="kobo.3199.1">} };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3200.1">auto</span></span><span class="koboSpan" id="kobo.3201.1"> some_numbers = numbers | rv::elements&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.3202.1">0</span></span><span class="koboSpan" id="kobo.3203.1">&gt;;
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3204.1">copy</span></span><span class="koboSpan" id="kobo.3205.1">(some_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3206.1">int</span></span><span class="koboSpan" id="kobo.3207.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3208.1">" "</span></span><span class="koboSpan" id="kobo.3209.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3210.1">1 1 2 3 5 8 13
</span></code></pre>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3211.1">auto</span></span><span class="koboSpan" id="kobo.3212.1"> some_names = numbers | rv::elements&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.3213.1">1</span></span><span class="koboSpan" id="kobo.3214.1">&gt;;
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3215.1">copy</span></span><span class="koboSpan" id="kobo.3216.1">(some_names, 
         std::ostream_iterator&lt;std::string_view&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3217.1">" "</span></span><span class="koboSpan" id="kobo.3218.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3219.1">one one two three five eight thirteen
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3220.1">ranges::keys_view</span></code><span class="koboSpan" id="kobo.3221.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3222.1">views::keys</span></code><span class="koboSpan" id="kobo.3223.1"> represent </span><a id="_idIndexMarker1507"/><span class="koboSpan" id="kobo.3224.1">an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3225.1">ranges::elements_view&lt;R, 0&gt;</span></code><span class="koboSpan" id="kobo.3226.1"> and, respectively, an object of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3227.1">views::elements&lt;0&gt;</span></code><span class="koboSpan" id="kobo.3228.1">.</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3229.1">ranges::values_view</span></code><span class="koboSpan" id="kobo.3230.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3231.1">views::values</span></code><span class="koboSpan" id="kobo.3232.1"> represent an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3233.1">ranges::elements_view&lt;R, 1&gt;</span></code><span class="koboSpan" id="kobo.3234.1"> and, respectively, an object of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3235.1">views::elements&lt;1&gt;</span></code><span class="koboSpan" id="kobo.3236.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3237.1">std::vector&lt;std::pair&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3238.1">int</span></span><span class="koboSpan" id="kobo.3239.1">, std::string_view&gt;&gt; numbers{
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3240.1">1</span></span><span class="koboSpan" id="kobo.3241.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3242.1">"one"</span></span><span class="koboSpan" id="kobo.3243.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3244.1">1</span></span><span class="koboSpan" id="kobo.3245.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3246.1">"one"</span></span><span class="koboSpan" id="kobo.3247.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3248.1">2</span></span><span class="koboSpan" id="kobo.3249.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3250.1">"two"</span></span><span class="koboSpan" id="kobo.3251.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3252.1">3</span></span><span class="koboSpan" id="kobo.3253.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3254.1">"three"</span></span><span class="koboSpan" id="kobo.3255.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3256.1">5</span></span><span class="koboSpan" id="kobo.3257.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3258.1">"five"</span></span><span class="koboSpan" id="kobo.3259.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3260.1">8</span></span><span class="koboSpan" id="kobo.3261.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3262.1">"eight"</span></span><span class="koboSpan" id="kobo.3263.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3264.1">13</span></span><span class="koboSpan" id="kobo.3265.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3266.1">"thirteen"</span></span><span class="koboSpan" id="kobo.3267.1">} };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3268.1">auto</span></span><span class="koboSpan" id="kobo.3269.1"> some_numbers = numbers | rv::keys;
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3270.1">copy</span></span><span class="koboSpan" id="kobo.3271.1">(some_numbers, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3272.1">int</span></span><span class="koboSpan" id="kobo.3273.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3274.1">" "</span></span><span class="koboSpan" id="kobo.3275.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3276.1">1 1 2 3 5 8 13
</span></code></pre>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3277.1">auto</span></span><span class="koboSpan" id="kobo.3278.1"> some_names = numbers | rv::values;
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3279.1">copy</span></span><span class="koboSpan" id="kobo.3280.1">(some_names, 
         std::ostream_iterator&lt;std::string_view&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3281.1">" "</span></span><span class="koboSpan" id="kobo.3282.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3283.1">one one two three five eight thirteen
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3284.1">In C++23, the following</span><a id="_idIndexMarker1508"/><span class="koboSpan" id="kobo.3285.1"> adaptors were added to the standard library:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3286.1">ranges::enumerate_view</span></code><span class="koboSpan" id="kobo.3287.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3288.1">views::enumerate</span></code><span class="koboSpan" id="kobo.3289.1"> represents a view of tuples, with the first element being the zero-based index of the element of the underlying sequence, and the second element being a reference to the underlying element:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3290.1">std::vector&lt;std::string&gt; words{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3291.1">"one"</span></span><span class="koboSpan" id="kobo.3292.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3293.1">"two"</span></span><span class="koboSpan" id="kobo.3294.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3295.1">"three"</span></span><span class="koboSpan" id="kobo.3296.1">, 
                                </span><span class="hljs-string"><span class="koboSpan" id="kobo.3297.1">"four"</span></span><span class="koboSpan" id="kobo.3298.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3299.1">"five"</span></span><span class="koboSpan" id="kobo.3300.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3301.1">auto</span></span><span class="koboSpan" id="kobo.3302.1"> enumerated_words = words | rv::enumerate;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3303.1">for</span></span><span class="koboSpan" id="kobo.3304.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3305.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3306.1">const</span></span><span class="koboSpan" id="kobo.3307.1"> [index, word] : enumerated_words)
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3308.1">println</span></span><span class="koboSpan" id="kobo.3309.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3310.1">"{} : {}"</span></span><span class="koboSpan" id="kobo.3311.1">, index, word);
}
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3312.1">0 : one
1 : two
2 : three
3 : four
4 : five
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3313.1">ranges::zip_view</span></code><span class="koboSpan" id="kobo.3314.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3315.1">views::zip</span></code><span class="koboSpan" id="kobo.3316.1"> represents a view of tuples created from two or more underlying</span><a id="_idIndexMarker1509"/><span class="koboSpan" id="kobo.3317.1"> views, with the </span><em class="italic"><span class="koboSpan" id="kobo.3318.1">N</span></em><span class="koboSpan" id="kobo.3319.1">th tuple created from the </span><em class="italic"><span class="koboSpan" id="kobo.3320.1">N</span></em><span class="koboSpan" id="kobo.3321.1">th element of each underlying view:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3322.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3323.1">int</span></span><span class="koboSpan" id="kobo.3324.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3325.1">1</span></span><span class="koboSpan" id="kobo.3326.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3327.1">1</span></span><span class="koboSpan" id="kobo.3328.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3329.1">2</span></span><span class="koboSpan" id="kobo.3330.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3331.1">3</span></span><span class="koboSpan" id="kobo.3332.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3333.1">5</span></span><span class="koboSpan" id="kobo.3334.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3335.1">8</span></span><span class="koboSpan" id="kobo.3336.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3337.1">13</span></span><span class="koboSpan" id="kobo.3338.1"> };
std::vector&lt;std::string&gt; words{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3339.1">"one"</span></span><span class="koboSpan" id="kobo.3340.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3341.1">"two"</span></span><span class="koboSpan" id="kobo.3342.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3343.1">"three"</span></span><span class="koboSpan" id="kobo.3344.1">, 
                                </span><span class="hljs-string"><span class="koboSpan" id="kobo.3345.1">"four"</span></span><span class="koboSpan" id="kobo.3346.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3347.1">"five"</span></span><span class="koboSpan" id="kobo.3348.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3349.1">auto</span></span><span class="koboSpan" id="kobo.3350.1"> zipped = rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3351.1">zip</span></span><span class="koboSpan" id="kobo.3352.1">(numbers, words);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3353.1">for</span></span><span class="koboSpan" id="kobo.3354.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3355.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3356.1">const</span></span><span class="koboSpan" id="kobo.3357.1"> [number, word] : zipped)
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3358.1">println</span></span><span class="koboSpan" id="kobo.3359.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3360.1">"{} : {}"</span></span><span class="koboSpan" id="kobo.3361.1">, number, word);
}
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3362.1">1 : one
1 : two
2 : three
3 : four
5 : five
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3363.1">ranges::zip_transform_view</span></code><span class="koboSpan" id="kobo.3364.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3365.1">views::</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.3366.1">zip_transform</span></code><span class="koboSpan" id="kobo.3367.1"> represents a view of elements produced by applying a given function to two or more views. </span><span class="koboSpan" id="kobo.3367.2">The </span><em class="italic"><span class="koboSpan" id="kobo.3368.1">N</span></em><span class="koboSpan" id="kobo.3369.1">th element of the result view is produced from the </span><em class="italic"><span class="koboSpan" id="kobo.3370.1">N</span></em><span class="koboSpan" id="kobo.3371.1">th element of all the specified underlying views:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3372.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3373.1">int</span></span><span class="koboSpan" id="kobo.3374.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3375.1">1</span></span><span class="koboSpan" id="kobo.3376.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3377.1">1</span></span><span class="koboSpan" id="kobo.3378.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3379.1">2</span></span><span class="koboSpan" id="kobo.3380.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3381.1">3</span></span><span class="koboSpan" id="kobo.3382.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3383.1">5</span></span><span class="koboSpan" id="kobo.3384.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3385.1">8</span></span><span class="koboSpan" id="kobo.3386.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3387.1">13</span></span><span class="koboSpan" id="kobo.3388.1"> };
std::vector&lt;std::string&gt; words{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3389.1">"one"</span></span><span class="koboSpan" id="kobo.3390.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3391.1">"two"</span></span><span class="koboSpan" id="kobo.3392.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3393.1">"three"</span></span><span class="koboSpan" id="kobo.3394.1">, 
                                </span><span class="hljs-string"><span class="koboSpan" id="kobo.3395.1">"four"</span></span><span class="koboSpan" id="kobo.3396.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3397.1">"five"</span></span><span class="koboSpan" id="kobo.3398.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3399.1">auto</span></span><span class="koboSpan" id="kobo.3400.1"> zipped = rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3401.1">zip_transform</span></span><span class="koboSpan" id="kobo.3402.1">(
   [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3403.1">int</span></span><span class="koboSpan" id="kobo.3404.1"> number, std::string word) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3405.1">return</span></span><span class="koboSpan" id="kobo.3406.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3407.1">to_string</span></span><span class="koboSpan" id="kobo.3408.1">(number) + </span><span class="hljs-string"><span class="koboSpan" id="kobo.3409.1">" : "</span></span><span class="koboSpan" id="kobo.3410.1"> + word;
   },
   numbers, 
   words);
std::ranges::for_each(zipped, 
                      [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3411.1">auto</span></span><span class="koboSpan" id="kobo.3412.1"> e) {std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3413.1">println</span></span><span class="koboSpan" id="kobo.3414.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3415.1">"{}"</span></span><span class="koboSpan" id="kobo.3416.1">, e); });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3417.1">1 : one
1 : two
2 : three
3 : four
5 : five
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3418.1">ranges::adjacent_view</span></code><span class="koboSpan" id="kobo.3419.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3420.1">views::adjacent</span></code><span class="koboSpan" id="kobo.3421.1"> represents a view of tuples of </span><em class="italic"><span class="koboSpan" id="kobo.3422.1">N</span></em><span class="koboSpan" id="kobo.3423.1"> elements from an underlying view; each tuple is a window in the underlying view, the </span><em class="italic"><span class="koboSpan" id="kobo.3424.1">i</span></em><span class="koboSpan" id="kobo.3425.1">th tuple containing the elements with the indexes in the range </span><code class="inlineCode"><span class="koboSpan" id="kobo.3426.1">[i, i + N - 1]</span></code><span class="koboSpan" id="kobo.3427.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3428.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3429.1">int</span></span><span class="koboSpan" id="kobo.3430.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3431.1">1</span></span><span class="koboSpan" id="kobo.3432.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3433.1">1</span></span><span class="koboSpan" id="kobo.3434.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3435.1">2</span></span><span class="koboSpan" id="kobo.3436.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3437.1">3</span></span><span class="koboSpan" id="kobo.3438.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3439.1">5</span></span><span class="koboSpan" id="kobo.3440.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3441.1">8</span></span><span class="koboSpan" id="kobo.3442.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3443.1">13</span></span><span class="koboSpan" id="kobo.3444.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3445.1">auto</span></span><span class="koboSpan" id="kobo.3446.1"> adjacent_numbers = numbers | rv::adjacent&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.3447.1">3</span></span><span class="koboSpan" id="kobo.3448.1">&gt;;
std::ranges::for_each(
   adjacent_numbers, 
   [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3449.1">auto</span></span><span class="koboSpan" id="kobo.3450.1"> t) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3451.1">auto</span></span><span class="koboSpan" id="kobo.3452.1"> [a, b, c] = t;
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3453.1">println</span></span><span class="koboSpan" id="kobo.3454.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3455.1">"{},{},{}"</span></span><span class="koboSpan" id="kobo.3456.1">, a, b, c); 
   });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3457.1">1,1,2
1,2,3
2,3,5
3,5,8
5,8,13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3458.1">ranges::adjacent_transform_view</span></code><span class="koboSpan" id="kobo.3459.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3460.1">views::adjacent_transform</span></code><span class="koboSpan" id="kobo.3461.1"> represents a view of elements produced by applying a specified function to </span><em class="italic"><span class="koboSpan" id="kobo.3462.1">N</span></em><span class="koboSpan" id="kobo.3463.1">-adjacent elements of an underlying view; the </span><em class="italic"><span class="koboSpan" id="kobo.3464.1">i</span></em><span class="koboSpan" id="kobo.3465.1">th element of the resulting view is produced</span><a id="_idIndexMarker1510"/><span class="koboSpan" id="kobo.3466.1"> by applying the function to the elements of the underlying range with the indexes in the range </span><code class="inlineCode"><span class="koboSpan" id="kobo.3467.1">[i, i + N - 1]</span></code><span class="koboSpan" id="kobo.3468.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3469.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3470.1">int</span></span><span class="koboSpan" id="kobo.3471.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3472.1">1</span></span><span class="koboSpan" id="kobo.3473.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3474.1">1</span></span><span class="koboSpan" id="kobo.3475.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3476.1">2</span></span><span class="koboSpan" id="kobo.3477.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3478.1">3</span></span><span class="koboSpan" id="kobo.3479.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3480.1">5</span></span><span class="koboSpan" id="kobo.3481.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3482.1">8</span></span><span class="koboSpan" id="kobo.3483.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3484.1">13</span></span><span class="koboSpan" id="kobo.3485.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3486.1">auto</span></span><span class="koboSpan" id="kobo.3487.1"> adjacent_numbers = 
   numbers | 
   rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3488.1">adjacent_transform</span></span><span class="koboSpan" id="kobo.3489.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.3490.1">3</span></span><span class="koboSpan" id="kobo.3491.1">&gt;(
      [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3492.1">int</span></span><span class="koboSpan" id="kobo.3493.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3494.1">int</span></span><span class="koboSpan" id="kobo.3495.1"> b, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3496.1">int</span></span><span class="koboSpan" id="kobo.3497.1"> c) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3498.1">return</span></span><span class="koboSpan" id="kobo.3499.1"> a * b * c; });
std::ranges::for_each(adjacent_numbers, 
                      [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3500.1">auto</span></span><span class="koboSpan" id="kobo.3501.1"> e) {std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3502.1">print</span></span><span class="koboSpan" id="kobo.3503.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3504.1">"{} "</span></span><span class="koboSpan" id="kobo.3505.1">, e); });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3506.1">2 6 30 120 520
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3507.1">ranges::join_with_view</span></code><span class="koboSpan" id="kobo.3508.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3509.1">views::join_with</span></code><span class="koboSpan" id="kobo.3510.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3511.1">join_view</span></code><span class="koboSpan" id="kobo.3512.1"> because it flattens a view of ranges to a single view; however, it takes a delimiter that it inserts between the elements of the underlying ranges:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3513.1">std::vector&lt;std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3514.1">int</span></span><span class="koboSpan" id="kobo.3515.1">&gt;&gt; numbers{ {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3516.1">1</span></span><span class="koboSpan" id="kobo.3517.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3518.1">1</span></span><span class="koboSpan" id="kobo.3519.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3520.1">2</span></span><span class="koboSpan" id="kobo.3521.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3522.1">3</span></span><span class="koboSpan" id="kobo.3523.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3524.1">5</span></span><span class="koboSpan" id="kobo.3525.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3526.1">8</span></span><span class="koboSpan" id="kobo.3527.1">}, 
                                       {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3528.1">13</span></span><span class="koboSpan" id="kobo.3529.1">} };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3530.1">auto</span></span><span class="koboSpan" id="kobo.3531.1"> joined_numbers = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3532.1">join_with</span></span><span class="koboSpan" id="kobo.3533.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3534.1">0</span></span><span class="koboSpan" id="kobo.3535.1">);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3536.1">copy</span></span><span class="koboSpan" id="kobo.3537.1">(joined_numbers, 
         std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3538.1">int</span></span><span class="koboSpan" id="kobo.3539.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3540.1">" "</span></span><span class="koboSpan" id="kobo.3541.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3542.1">1 1 2 0 3 5 8 0 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3543.1">ranges::slide_view</span></code><span class="koboSpan" id="kobo.3544.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3545.1">views::slide</span></code><span class="koboSpan" id="kobo.3546.1"> is a range adaptor similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3547.1">ranges::adjacent_view</span></code><span class="koboSpan" id="kobo.3548.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3549.1">views::adjacent</span></code><span class="koboSpan" id="kobo.3550.1">, except that the size of the windows from the underlying sequence is specified at runtime:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3551.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3552.1">int</span></span><span class="koboSpan" id="kobo.3553.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3554.1">1</span></span><span class="koboSpan" id="kobo.3555.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3556.1">1</span></span><span class="koboSpan" id="kobo.3557.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3558.1">2</span></span><span class="koboSpan" id="kobo.3559.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3560.1">3</span></span><span class="koboSpan" id="kobo.3561.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3562.1">5</span></span><span class="koboSpan" id="kobo.3563.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3564.1">8</span></span><span class="koboSpan" id="kobo.3565.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3566.1">13</span></span><span class="koboSpan" id="kobo.3567.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3568.1">auto</span></span><span class="koboSpan" id="kobo.3569.1"> slide_numbers = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3570.1">slide</span></span><span class="koboSpan" id="kobo.3571.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3572.1">3</span></span><span class="koboSpan" id="kobo.3573.1">);
std::ranges::for_each(
   slide_numbers,
   [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3574.1">auto</span></span><span class="koboSpan" id="kobo.3575.1"> r) {
      rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3576.1">copy</span></span><span class="koboSpan" id="kobo.3577.1">(r, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3578.1">int</span></span><span class="koboSpan" id="kobo.3579.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3580.1">" "</span></span><span class="koboSpan" id="kobo.3581.1"> });
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3582.1">println</span></span><span class="koboSpan" id="kobo.3583.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3584.1">""</span></span><span class="koboSpan" id="kobo.3585.1">);
   });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3586.1">1 1 2
1 2 3
2 3 5
3 5 8
5 8 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3587.1">ranges::chunk_view</span></code><span class="koboSpan" id="kobo.3588.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3589.1">views::chunk</span></code><span class="koboSpan" id="kobo.3590.1"> represents a view of sub-views of </span><em class="italic"><span class="koboSpan" id="kobo.3591.1">N</span></em><span class="koboSpan" id="kobo.3592.1"> elements of the </span><a id="_idIndexMarker1511"/><span class="koboSpan" id="kobo.3593.1">underlying view. </span><span class="koboSpan" id="kobo.3593.2">The last chunk may have fewer than </span><em class="italic"><span class="koboSpan" id="kobo.3594.1">N</span></em><span class="koboSpan" id="kobo.3595.1"> elements (if the size of the underlying view is not a multiple of </span><em class="italic"><span class="koboSpan" id="kobo.3596.1">N</span></em><span class="koboSpan" id="kobo.3597.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3598.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3599.1">int</span></span><span class="koboSpan" id="kobo.3600.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3601.1">1</span></span><span class="koboSpan" id="kobo.3602.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3603.1">1</span></span><span class="koboSpan" id="kobo.3604.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3605.1">2</span></span><span class="koboSpan" id="kobo.3606.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3607.1">3</span></span><span class="koboSpan" id="kobo.3608.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3609.1">5</span></span><span class="koboSpan" id="kobo.3610.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3611.1">8</span></span><span class="koboSpan" id="kobo.3612.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3613.1">13</span></span><span class="koboSpan" id="kobo.3614.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3615.1">auto</span></span><span class="koboSpan" id="kobo.3616.1"> chunk_numbers = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3617.1">chunk</span></span><span class="koboSpan" id="kobo.3618.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3619.1">3</span></span><span class="koboSpan" id="kobo.3620.1">);
std::ranges::for_each(
   chunk_numbers,
   [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3621.1">auto</span></span><span class="koboSpan" id="kobo.3622.1"> r) {
      rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3623.1">copy</span></span><span class="koboSpan" id="kobo.3624.1">(r, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3625.1">int</span></span><span class="koboSpan" id="kobo.3626.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3627.1">" "</span></span><span class="koboSpan" id="kobo.3628.1"> });
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3629.1">println</span></span><span class="koboSpan" id="kobo.3630.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3631.1">""</span></span><span class="koboSpan" id="kobo.3632.1">);
   });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3633.1">1 1 2
3 5 8
13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3634.1">ranges::chunk_by_view</span></code><span class="koboSpan" id="kobo.3635.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3636.1">views::chunk_by</span></code><span class="koboSpan" id="kobo.3637.1"> represents a view of sub-views of an underlying view, produced by splitting the underlying view each time a supplied </span><a id="_idIndexMarker1512"/><span class="koboSpan" id="kobo.3638.1">binary predicate applied to two adjacent elements returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.3639.1">false</span></code><span class="koboSpan" id="kobo.3640.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3641.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3642.1">int</span></span><span class="koboSpan" id="kobo.3643.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3644.1">1</span></span><span class="koboSpan" id="kobo.3645.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3646.1">1</span></span><span class="koboSpan" id="kobo.3647.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3648.1">2</span></span><span class="koboSpan" id="kobo.3649.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3650.1">3</span></span><span class="koboSpan" id="kobo.3651.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3652.1">5</span></span><span class="koboSpan" id="kobo.3653.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3654.1">8</span></span><span class="koboSpan" id="kobo.3655.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3656.1">13</span></span><span class="koboSpan" id="kobo.3657.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3658.1">auto</span></span><span class="koboSpan" id="kobo.3659.1"> chunk_numbers = 
   numbers | 
   rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3660.1">chunk_by</span></span><span class="koboSpan" id="kobo.3661.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3662.1">int</span></span><span class="koboSpan" id="kobo.3663.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3664.1">int</span></span><span class="koboSpan" id="kobo.3665.1"> b) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3666.1">return</span></span><span class="koboSpan" id="kobo.3667.1"> a * b % </span><span class="hljs-number"><span class="koboSpan" id="kobo.3668.1">2</span></span><span class="koboSpan" id="kobo.3669.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3670.1">1</span></span><span class="koboSpan" id="kobo.3671.1">; });
std::ranges::for_each(
   chunk_numbers,
   [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3672.1">auto</span></span><span class="koboSpan" id="kobo.3673.1"> r) {
      rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3674.1">copy</span></span><span class="koboSpan" id="kobo.3675.1">(r, std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3676.1">int</span></span><span class="koboSpan" id="kobo.3677.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3678.1">" "</span></span><span class="koboSpan" id="kobo.3679.1"> });
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3680.1">println</span></span><span class="koboSpan" id="kobo.3681.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3682.1">""</span></span><span class="koboSpan" id="kobo.3683.1">);
   });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3684.1">1 1
2
3 5
8
13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3685.1">ranges::stride_view</span></code><span class="koboSpan" id="kobo.3686.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3687.1">views::stride</span></code><span class="koboSpan" id="kobo.3688.1"> is a view of some elements from an underlying view, starting with the first and advancing over </span><em class="italic"><span class="koboSpan" id="kobo.3689.1">N</span></em><span class="koboSpan" id="kobo.3690.1"> elements each time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3691.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3692.1">int</span></span><span class="koboSpan" id="kobo.3693.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3694.1">1</span></span><span class="koboSpan" id="kobo.3695.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3696.1">1</span></span><span class="koboSpan" id="kobo.3697.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3698.1">2</span></span><span class="koboSpan" id="kobo.3699.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3700.1">3</span></span><span class="koboSpan" id="kobo.3701.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3702.1">5</span></span><span class="koboSpan" id="kobo.3703.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3704.1">8</span></span><span class="koboSpan" id="kobo.3705.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3706.1">13</span></span><span class="koboSpan" id="kobo.3707.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3708.1">auto</span></span><span class="koboSpan" id="kobo.3709.1"> stride_numbers = numbers | rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3710.1">stride</span></span><span class="koboSpan" id="kobo.3711.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3712.1">3</span></span><span class="koboSpan" id="kobo.3713.1">);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3714.1">copy</span></span><span class="koboSpan" id="kobo.3715.1">(stride_numbers, 
         std::ostream_iterator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3716.1">int</span></span><span class="koboSpan" id="kobo.3717.1">&gt;{ std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3718.1">" "</span></span><span class="koboSpan" id="kobo.3719.1"> });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3720.1">1 3 13
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3721.1">ranges::cartesian_product_view</span></code><span class="koboSpan" id="kobo.3722.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.3723.1">views::cartesian_product</span></code><span class="koboSpan" id="kobo.3724.1"> represents a view of </span><a id="_idIndexMarker1513"/><span class="koboSpan" id="kobo.3725.1">tuples computed as the cartesian product of 1 or more underlying views:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3726.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3727.1">int</span></span><span class="koboSpan" id="kobo.3728.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3729.1">1</span></span><span class="koboSpan" id="kobo.3730.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3731.1">2</span></span><span class="koboSpan" id="kobo.3732.1"> };
std::vector&lt;std::string&gt; words{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3733.1">"one"</span></span><span class="koboSpan" id="kobo.3734.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3735.1">"two"</span></span><span class="koboSpan" id="kobo.3736.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3737.1">"three"</span></span><span class="koboSpan" id="kobo.3738.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3739.1">auto</span></span><span class="koboSpan" id="kobo.3740.1"> product = rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3741.1">cartesian_product</span></span><span class="koboSpan" id="kobo.3742.1">(numbers, words);
rg::for_each(
   product,
   [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3743.1">auto</span></span><span class="koboSpan" id="kobo.3744.1"> t) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3745.1">auto</span></span><span class="koboSpan" id="kobo.3746.1"> [number, word] = t;
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3747.1">println</span></span><span class="koboSpan" id="kobo.3748.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3749.1">"{} : {}"</span></span><span class="koboSpan" id="kobo.3750.1">, number, word);
   });
</span></code></pre>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3751.1">1 : one
1 : two
1 : three
2 : one
2 : two
2 : three
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-790"><span class="koboSpan" id="kobo.3752.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3753.1">We saw how range adaptors work in the previous recipe. </span><span class="koboSpan" id="kobo.3753.2">In this section, we will only look at some of the details and differences between some adaptors that you should be aware of.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3754.1">To start, let’s consider </span><code class="inlineCode"><span class="koboSpan" id="kobo.3755.1">adjacent_view</span></code><span class="koboSpan" id="kobo.3756.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3757.1">slide_view</span></code><span class="koboSpan" id="kobo.3758.1">. </span><span class="koboSpan" id="kobo.3758.2">They are similar in the sense that they take one view and produce another view of sub-views of this underlying view. </span><span class="koboSpan" id="kobo.3758.3">These sub-views are referred to as </span><em class="italic"><span class="koboSpan" id="kobo.3759.1">windows</span></em><span class="koboSpan" id="kobo.3760.1"> and have a specified size, </span><em class="italic"><span class="koboSpan" id="kobo.3761.1">N</span></em><span class="koboSpan" id="kobo.3762.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.3763.1">The first window starts from the first element, the second from the second element, etc. </span><span class="koboSpan" id="kobo.3763.2">However, they differ in two significant ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3764.1">The size </span><em class="italic"><span class="koboSpan" id="kobo.3765.1">N</span></em><span class="koboSpan" id="kobo.3766.1"> of the windows is specified at compile time for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3767.1">adjacent_view</span></code><span class="koboSpan" id="kobo.3768.1"> and at runtime for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3769.1">slide_view</span></code><span class="koboSpan" id="kobo.3770.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3771.1">The elements of the view represented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3772.1">adjacent_view</span></code><span class="koboSpan" id="kobo.3773.1"> are tuples, while the elements of the view represented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3774.1">slide_view</span></code><span class="koboSpan" id="kobo.3775.1"> are other views.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3776.1">The following diagram presents a</span><a id="_idIndexMarker1514"/><span class="koboSpan" id="kobo.3777.1"> comparison of these two adaptors:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.3778.1"><img alt="" src="../Images/B21549_12_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.3779.1">Figure 12.2: Comparison of adjacent_view&lt;3&gt;(R) and slide_view(R, 3)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3780.1">When the size of the windows is 2, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3781.1">views::pairwise</span></code><span class="koboSpan" id="kobo.3782.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3783.1">views::pairwise_transform</span></code><span class="koboSpan" id="kobo.3784.1">, which are objects of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3785.1">adjacent&lt;2&gt;</span></code><span class="koboSpan" id="kobo.3786.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3787.1">adjacent_transform&lt;2&gt;</span></code><span class="koboSpan" id="kobo.3788.1">, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3789.1">The next pair of adaptors to look at are </span><code class="inlineCode"><span class="koboSpan" id="kobo.3790.1">split_view</span></code><span class="koboSpan" id="kobo.3791.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3792.1">lazy_split_view</span></code><span class="koboSpan" id="kobo.3793.1">. </span><span class="koboSpan" id="kobo.3793.2">They both do the same thing: split a view into subranges based on a given delimiter, which can be either a single element or a view of elements. </span><span class="koboSpan" id="kobo.3793.3">Neither of the two adaptors include the delimiter in the resulting subranges. </span><span class="koboSpan" id="kobo.3793.4">These two, however, differ in a key aspect: the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3794.1">lazy_split_view</span></code><span class="koboSpan" id="kobo.3795.1"> adaptor is, as the name implies, </span><em class="italic"><span class="koboSpan" id="kobo.3796.1">lazy</span></em><span class="koboSpan" id="kobo.3797.1">, meaning that it does not look ahead to the next delimiter until we iterate for the next element of the result, which </span><code class="inlineCode"><span class="koboSpan" id="kobo.3798.1">split_view</span></code><span class="koboSpan" id="kobo.3799.1"> does. </span><span class="koboSpan" id="kobo.3799.2">Moreover, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3800.1">split_view</span></code><span class="koboSpan" id="kobo.3801.1"> supports ranges of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3802.1">forward_range</span></code><span class="koboSpan" id="kobo.3803.1"> type or higher but cannot split a constant range, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.3804.1">lazy_split_view</span></code><span class="koboSpan" id="kobo.3805.1"> supports ranges of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3806.1">input_range</span></code><span class="koboSpan" id="kobo.3807.1"> type or higher and can split a constant range.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3808.1">The question that arises is which one to use and when? </span><span class="koboSpan" id="kobo.3808.2">Typically, you should prefer </span><code class="inlineCode"><span class="koboSpan" id="kobo.3809.1">split_view</span></code><span class="koboSpan" id="kobo.3810.1"> because it is more efficient than </span><code class="inlineCode"><span class="koboSpan" id="kobo.3811.1">lazy_split_view</span></code><span class="koboSpan" id="kobo.3812.1"> (which has a less efficient iterator incrementation and comparison). </span><span class="koboSpan" id="kobo.3812.2">However, if you need to split a constant range, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.3813.1">split_view</span></code><span class="koboSpan" id="kobo.3814.1"> is not an option, and you should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3815.1">lazy_split_view</span></code><span class="koboSpan" id="kobo.3816.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3817.1">There are two adaptors, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3818.1">join_view</span></code><span class="koboSpan" id="kobo.3819.1"> (in C++20) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3820.1">join_with_view</span></code><span class="koboSpan" id="kobo.3821.1"> (in C++23), that perform a join operation, transforming a range of ranges into a single (flattened) range. </span><span class="koboSpan" id="kobo.3821.2">The difference between them is that the latter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3822.1">join_with_view</span></code><span class="koboSpan" id="kobo.3823.1">, takes a delimiter that is inserted in the result </span><a id="_idIndexMarker1515"/><span class="koboSpan" id="kobo.3824.1">between the elements of two consecutive underlying ranges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3825.1">For more details about the </span><a id="_idIndexMarker1516"/><span class="koboSpan" id="kobo.3826.1">standard range adaptors, you can consult the online documentation available at </span><a href="https://en.cppreference.com/w/cpp/ranges"><span class="url"><span class="koboSpan" id="kobo.3827.1">https://en.cppreference.com/w/cpp/ranges</span></span></a><span class="koboSpan" id="kobo.3828.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-791"><span class="koboSpan" id="kobo.3829.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3830.1">Iterating over collections with the ranges library</span></em><span class="koboSpan" id="kobo.3831.1">, to learn about the fundamentals of the C++ ranges library</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3832.1">Using constrained algorithms</span></em><span class="koboSpan" id="kobo.3833.1">, to learn about the standard generic algorithms that work with ranges</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-792"><span class="koboSpan" id="kobo.3834.1">Converting a range to a container</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3835.1">The result of </span><a id="_idIndexMarker1517"/><span class="koboSpan" id="kobo.3836.1">applying various range adapters to a range (such as a container) is a </span><a id="_idIndexMarker1518"/><span class="koboSpan" id="kobo.3837.1">complex type that is difficult to type or remember. </span><span class="koboSpan" id="kobo.3837.2">Typically, we’d use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3838.1">auto</span></code><span class="koboSpan" id="kobo.3839.1"> specifier to indicate the type of the result of chaining adaptors, as we saw in the previous recipes. </span><span class="koboSpan" id="kobo.3839.2">Ranges are lazy, which means they are evaluated, and they produce results only when we iterate over them. </span><span class="koboSpan" id="kobo.3839.3">However, we often need to store the result of applying one or more range adaptors in a container, such as a vector or a map. </span><span class="koboSpan" id="kobo.3839.4">Prior to C++23, this required explicit coding. </span><span class="koboSpan" id="kobo.3839.5">However, C++23 provides a range conversion function, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3840.1">std::ranges::to</span></code><span class="koboSpan" id="kobo.3841.1">, which makes this an easy task. </span><span class="koboSpan" id="kobo.3841.2">It also enables conversion between different containers. </span><span class="koboSpan" id="kobo.3841.3">In this recipe, we will learn how to use it.</span></p>
<h2 class="heading-2" id="_idParaDest-793"><span class="koboSpan" id="kobo.3842.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3843.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3844.1">is_prime()</span></code><span class="koboSpan" id="kobo.3845.1"> function used in the following snippets was shown in the recipe </span><em class="italic"><span class="koboSpan" id="kobo.3846.1">Exploring the standard range adaptors</span></em><span class="koboSpan" id="kobo.3847.1"> and will not be listed again here.</span></p>
<h2 class="heading-2" id="_idParaDest-794"><span class="koboSpan" id="kobo.3848.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3849.1">You can convert a range</span><a id="_idIndexMarker1519"/><span class="koboSpan" id="kobo.3850.1"> to a container using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3851.1">std::ranges::to</span></code><span class="koboSpan" id="kobo.3852.1"> range</span><a id="_idIndexMarker1520"/><span class="koboSpan" id="kobo.3853.1"> conversion function, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3854.1">Convert a range to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3855.1">std::vector</span></code><span class="koboSpan" id="kobo.3856.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3857.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3858.1">int</span></span><span class="koboSpan" id="kobo.3859.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3860.1">1</span></span><span class="koboSpan" id="kobo.3861.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3862.1">1</span></span><span class="koboSpan" id="kobo.3863.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3864.1">2</span></span><span class="koboSpan" id="kobo.3865.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3866.1">3</span></span><span class="koboSpan" id="kobo.3867.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3868.1">5</span></span><span class="koboSpan" id="kobo.3869.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3870.1">8</span></span><span class="koboSpan" id="kobo.3871.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3872.1">13</span></span><span class="koboSpan" id="kobo.3873.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3874.1">int</span></span><span class="koboSpan" id="kobo.3875.1">&gt; primes = numbers | 
                          std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3876.1">filter</span></span><span class="koboSpan" id="kobo.3877.1">(is_prime) | 
                          std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3878.1">to</span></span><span class="koboSpan" id="kobo.3879.1">&lt;std::vector&gt;();
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3880.1">copy</span></span><span class="koboSpan" id="kobo.3881.1">(primes, 
                  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3882.1">ostream_iterator</span></span><span class="koboSpan" id="kobo.3883.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3884.1">int</span></span><span class="koboSpan" id="kobo.3885.1">&gt;(std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3886.1">" "</span></span><span class="koboSpan" id="kobo.3887.1">));
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3888.1">println</span></span><span class="koboSpan" id="kobo.3889.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3890.1">""</span></span><span class="koboSpan" id="kobo.3891.1">);
std::string text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3892.1">"server=demo123;db=optimus"</span></span><span class="koboSpan" id="kobo.3893.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3894.1">auto</span></span><span class="koboSpan" id="kobo.3895.1"> parts = text | 
             std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3896.1">lazy_split</span></span><span class="koboSpan" id="kobo.3897.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3898.1">';'</span></span><span class="koboSpan" id="kobo.3899.1">) | 
             std::ranges::to&lt;std::vector&lt;std::string&gt;&gt;();
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3900.1">copy</span></span><span class="koboSpan" id="kobo.3901.1">(parts, 
                  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3902.1">ostream_iterator</span></span><span class="koboSpan" id="kobo.3903.1">&lt;std::string&gt;(std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3904.1">" "</span></span><span class="koboSpan" id="kobo.3905.1">));
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3906.1">println</span></span><span class="koboSpan" id="kobo.3907.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3908.1">""</span></span><span class="koboSpan" id="kobo.3909.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3910.1">Convert a range to a map type, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3911.1">std::unordered_multimap</span></code><span class="koboSpan" id="kobo.3912.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3913.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3914.1">int</span></span><span class="koboSpan" id="kobo.3915.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3916.1">1</span></span><span class="koboSpan" id="kobo.3917.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3918.1">1</span></span><span class="koboSpan" id="kobo.3919.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3920.1">2</span></span><span class="koboSpan" id="kobo.3921.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3922.1">3</span></span><span class="koboSpan" id="kobo.3923.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3924.1">5</span></span><span class="koboSpan" id="kobo.3925.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3926.1">8</span></span><span class="koboSpan" id="kobo.3927.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3928.1">13</span></span><span class="koboSpan" id="kobo.3929.1"> };
std::vector&lt;std::string&gt; words{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3930.1">"one"</span></span><span class="koboSpan" id="kobo.3931.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3932.1">"two"</span></span><span class="koboSpan" id="kobo.3933.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3934.1">"three"</span></span><span class="koboSpan" id="kobo.3935.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3936.1">"four"</span></span><span class="koboSpan" id="kobo.3937.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3938.1">auto</span></span><span class="koboSpan" id="kobo.3939.1"> zipped = std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3940.1">zip</span></span><span class="koboSpan" id="kobo.3941.1">(numbers, words) | 
              std::ranges::to&lt;
                 std::unordered_multimap&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3942.1">int</span></span><span class="koboSpan" id="kobo.3943.1">, std::string&gt;&gt;();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3944.1">for</span></span><span class="koboSpan" id="kobo.3945.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3946.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3947.1">const</span></span><span class="koboSpan" id="kobo.3948.1"> [number, word] : zipped)
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3949.1">println</span></span><span class="koboSpan" id="kobo.3950.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3951.1">"{} = {}"</span></span><span class="koboSpan" id="kobo.3952.1">, number, word);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3953.1">Convert a range to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3954.1">std::string</span></code><span class="koboSpan" id="kobo.3955.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3956.1">std::string text{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3957.1">"server=demo123;db=optimus"</span></span><span class="koboSpan" id="kobo.3958.1"> };
std::string text2 = text | 
                    std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3959.1">stride</span></span><span class="koboSpan" id="kobo.3960.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3961.1">3</span></span><span class="koboSpan" id="kobo.3962.1">) | 
                    std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3963.1">to</span></span><span class="koboSpan" id="kobo.3964.1">&lt;std::string&gt;();
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3965.1">println</span></span><span class="koboSpan" id="kobo.3966.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3967.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3968.1">{}"</span></span><span class="koboSpan" id="kobo.3969.1">, text2);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-795"><span class="koboSpan" id="kobo.3970.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3971.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3972.1">std::ranges::to</span></code><span class="koboSpan" id="kobo.3973.1"> range conversion function is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3974.1">&lt;ranges&gt;</span></code><span class="koboSpan" id="kobo.3975.1"> header, starting with C++23 (the feature-test macro </span><code class="inlineCode"><span class="koboSpan" id="kobo.3976.1">__cpp_lib_ranges_to_container</span></code><span class="koboSpan" id="kobo.3977.1"> can be used to test</span><a id="_idIndexMarker1521"/><span class="koboSpan" id="kobo.3978.1"> whether it is </span><a id="_idIndexMarker1522"/><span class="koboSpan" id="kobo.3979.1">supported or not).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3980.1">Although the previous examples showed how to convert from one range to another, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3981.1">std::ranges::to</span></code><span class="koboSpan" id="kobo.3982.1"> can also be used to convert between different types of containers, such as a vector to a list, or a map to a vector of pairs:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3983.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3984.1">int</span></span><span class="koboSpan" id="kobo.3985.1">&gt; numbers{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3986.1">1</span></span><span class="koboSpan" id="kobo.3987.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3988.1">1</span></span><span class="koboSpan" id="kobo.3989.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3990.1">2</span></span><span class="koboSpan" id="kobo.3991.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3992.1">3</span></span><span class="koboSpan" id="kobo.3993.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3994.1">5</span></span><span class="koboSpan" id="kobo.3995.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3996.1">8</span></span><span class="koboSpan" id="kobo.3997.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3998.1">13</span></span><span class="koboSpan" id="kobo.3999.1"> };
std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4000.1">int</span></span><span class="koboSpan" id="kobo.4001.1">&gt; list = numbers | std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4002.1">to</span></span><span class="koboSpan" id="kobo.4003.1">&lt;std::list&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4004.1">The compiler may be able to deduce the type of the elements of the container, such as in the previous snippet where we only specified </span><code class="inlineCode"><span class="koboSpan" id="kobo.4005.1">std::list</span></code><span class="koboSpan" id="kobo.4006.1"> and not </span><code class="inlineCode"><span class="koboSpan" id="kobo.4007.1">std::list&lt;int&gt;</span></code><span class="koboSpan" id="kobo.4008.1">. </span><span class="koboSpan" id="kobo.4008.2">However, there are scenarios where this is not possible, and you will get compiler errors unless you explicitly provide the full type. </span><span class="koboSpan" id="kobo.4008.3">Such an example is shown next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4009.1">std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4010.1">int</span></span><span class="koboSpan" id="kobo.4011.1">, std::string&gt; m{ {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4012.1">1</span></span><span class="koboSpan" id="kobo.4013.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4014.1">"one"</span></span><span class="koboSpan" id="kobo.4015.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4016.1">2</span></span><span class="koboSpan" id="kobo.4017.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4018.1">"two"</span></span><span class="koboSpan" id="kobo.4019.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4020.1">3</span></span><span class="koboSpan" id="kobo.4021.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4022.1">"three"</span></span><span class="koboSpan" id="kobo.4023.1">} };
std::vector&lt;std::pair&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4024.1">int</span></span><span class="koboSpan" id="kobo.4025.1">, std::string&gt;&gt; words = 
   m | rg::to&lt;std::vector&lt;std::pair&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4026.1">int</span></span><span class="koboSpan" id="kobo.4027.1">, std::string&gt;&gt;&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4028.1">When you use the pipe (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4029.1">|</span></code><span class="koboSpan" id="kobo.4030.1">) syntax, the parentheses are mandatory; otherwise, you will get compiler errors (which are difficult to read):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4031.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4032.1">int</span></span><span class="koboSpan" id="kobo.4033.1">&gt; v {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4034.1">1</span></span><span class="koboSpan" id="kobo.4035.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4036.1">1</span></span><span class="koboSpan" id="kobo.4037.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4038.1">2</span></span><span class="koboSpan" id="kobo.4039.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4040.1">3</span></span><span class="koboSpan" id="kobo.4041.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4042.1">5</span></span><span class="koboSpan" id="kobo.4043.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4044.1">8</span></span><span class="koboSpan" id="kobo.4045.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4046.1">auto</span></span><span class="koboSpan" id="kobo.4047.1"> r = v | std::ranges::to&lt;std::vector&gt;;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4048.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4049.1">The correct </span><a id="_idIndexMarker1523"/><span class="koboSpan" id="kobo.4050.1">syntax is </span><a id="_idIndexMarker1524"/><span class="koboSpan" id="kobo.4051.1">the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4052.1">auto</span></span><span class="koboSpan" id="kobo.4053.1"> r = v | std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4054.1">to</span></span><span class="koboSpan" id="kobo.4055.1">&lt;std::vector&gt;();  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4056.1">// OK</span></span>
</code></pre>
<h2 class="heading-2" id="_idParaDest-796"><span class="koboSpan" id="kobo.4057.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4058.1">Exploring the standard range adaptors</span></em><span class="koboSpan" id="kobo.4059.1">, to learn about the range adaptors available in C++20 and C++23</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4060.1">Using constrained algorithms</span></em><span class="koboSpan" id="kobo.4061.1">, to learn about the standard generic algorithms that work with ranges</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-797"><span class="koboSpan" id="kobo.4062.1">Creating your own range view</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4063.1">The C++20 ranges</span><a id="_idIndexMarker1525"/><span class="koboSpan" id="kobo.4064.1"> library simplifies the handling of ranges of elements. </span><span class="koboSpan" id="kobo.4064.2">The 16 range adaptors (views) defined in the library provide useful operations, as seen in the previous recipe. </span><span class="koboSpan" id="kobo.4064.3">However, you can create your own view that can be used together with the standard ones. </span><span class="koboSpan" id="kobo.4064.4">In this recipe, you will learn how to do that. </span><span class="koboSpan" id="kobo.4064.5">We will create a view called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4065.1">trim</span></code><span class="koboSpan" id="kobo.4066.1"> that, given a range and a unary predicate, returns a new range without the front and back elements that satisfy the predicate.</span></p>
<h2 class="heading-2" id="_idParaDest-798"><span class="koboSpan" id="kobo.4067.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4068.1">In this recipe, we will use the same namespace aliases used in the previous one, with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4069.1">rg</span></code><span class="koboSpan" id="kobo.4070.1"> as an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4071.1">std::ranges</span></code><span class="koboSpan" id="kobo.4072.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4073.1">rv</span></code><span class="koboSpan" id="kobo.4074.1"> as an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4075.1">std::ranges::views</span></code><span class="koboSpan" id="kobo.4076.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-799"><span class="koboSpan" id="kobo.4077.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4078.1">To create a view, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4079.1">Create a class template, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4080.1">trim_view</span></code><span class="koboSpan" id="kobo.4081.1">, derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4082.1">std::ranges::view_interface</span></code><span class="koboSpan" id="kobo.4083.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4084.1">template</span></span><span class="koboSpan" id="kobo.4085.1">&lt;rg::input_range R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4086.1">typename</span></span><span class="koboSpan" id="kobo.4087.1"> P&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4088.1">requires</span></span><span class="koboSpan" id="kobo.4089.1"> rg::view&lt;R&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4090.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4091.1">trim_view</span></span><span class="koboSpan" id="kobo.4092.1"> :
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4093.1">public</span></span><span class="koboSpan" id="kobo.4094.1"> rg::view_interface&lt;trim_view&lt;R, P&gt;&gt;
{
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4095.1">Define the internal state of the class, which, at a minimum, should include a begin and end iterator and the viewable range that is adapted by the view. </span><span class="koboSpan" id="kobo.4095.2">For this </span><a id="_idIndexMarker1526"/><span class="koboSpan" id="kobo.4096.1">adapter, we also need a predicate, as well as a Boolean variable to flag whether the iterators have been evaluated or not:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4097.1">private</span></span><span class="koboSpan" id="kobo.4098.1">:
  R base_ {};
  P pred_;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4099.1">mutable</span></span><span class="koboSpan" id="kobo.4100.1"> rg::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4101.1">iterator_t</span></span><span class="koboSpan" id="kobo.4102.1">&lt;R&gt; begin_ {std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4103.1">begin</span></span><span class="koboSpan" id="kobo.4104.1">(base_)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4105.1">mutable</span></span><span class="koboSpan" id="kobo.4106.1"> rg::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4107.1">iterator_t</span></span><span class="koboSpan" id="kobo.4108.1">&lt;R&gt; end_   {std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4109.1">end</span></span><span class="koboSpan" id="kobo.4110.1">(base_)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4111.1">mutable</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4112.1">bool</span></span><span class="koboSpan" id="kobo.4113.1"> evaluated_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4114.1">false</span></span><span class="koboSpan" id="kobo.4115.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4116.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4117.1">ensure_evaluated</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4118.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4119.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4120.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4121.1">if</span></span><span class="koboSpan" id="kobo.4122.1">(!evaluated_)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4123.1">while</span></span><span class="koboSpan" id="kobo.4124.1">(begin_ != std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4125.1">end</span></span><span class="koboSpan" id="kobo.4126.1">(base_) &amp;&amp; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4127.1">pred_</span></span><span class="koboSpan" id="kobo.4128.1">(*begin_))
      {begin_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4129.1">next</span></span><span class="koboSpan" id="kobo.4130.1">(begin_);}
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4131.1">while</span></span><span class="koboSpan" id="kobo.4132.1">(end_ != begin_ &amp;&amp; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4133.1">pred_</span></span><span class="koboSpan" id="kobo.4134.1">(*std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4135.1">prev</span></span><span class="koboSpan" id="kobo.4136.1">(end_)))
      {end_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4137.1">prev</span></span><span class="koboSpan" id="kobo.4138.1">(end_);}
      evaluated_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4139.1">true</span></span><span class="koboSpan" id="kobo.4140.1">;
    }
  }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4141.1">Define a default constructor (that can be defaulted) and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4142.1">constexpr</span></code><span class="koboSpan" id="kobo.4143.1"> constructor with the required parameters. </span><span class="koboSpan" id="kobo.4143.2">The first parameter is always the range. </span><span class="koboSpan" id="kobo.4143.3">For this view, the other parameter is a predicate:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4144.1">public</span></span><span class="koboSpan" id="kobo.4145.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4146.1">trim_view</span></span><span class="koboSpan" id="kobo.4147.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4148.1">default</span></span><span class="koboSpan" id="kobo.4149.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4150.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4151.1">trim_view</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4152.1">(R base, P pred)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4153.1">    : base_(std::move(base))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4154.1">    , pred_(std::move(pred))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4155.1">    , begin_(std::begin(base_))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4156.1">    , end_(std::end(base_))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4157.1">  {</span></span><span class="koboSpan" id="kobo.4158.1">}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4159.1">Provide accessors to the internal data, such as the base range and the predicate:
        </span><pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4160.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4161.1"> R </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4162.1">base</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4163.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4164.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4165.1"> &amp;       </span></span><span class="koboSpan" id="kobo.4166.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4167.1">return</span></span><span class="koboSpan" id="kobo.4168.1"> base_;}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4169.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4170.1"> R </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4171.1">base</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4172.1">()</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4173.1"> &amp;&amp;            </span></span><span class="koboSpan" id="kobo.4174.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4175.1">return</span></span><span class="koboSpan" id="kobo.4176.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4177.1">move</span></span><span class="koboSpan" id="kobo.4178.1">(base_);}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4179.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4180.1"> P </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4181.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4182.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4183.1">pred</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4184.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4185.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4186.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4187.1">return</span></span><span class="koboSpan" id="kobo.4188.1"> pred_; }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4189.1">Provide functions to retrieve the begin and end iterators. </span><span class="koboSpan" id="kobo.4189.2">To make sure the view is lazy, these iterators should only be evaluated by their first use:
        </span><pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4190.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4191.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4192.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4193.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4194.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4195.1">{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4196.1">ensure_evaluated</span></span><span class="koboSpan" id="kobo.4197.1">(); </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4198.1">return</span></span><span class="koboSpan" id="kobo.4199.1"> begin_; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4200.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4201.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4202.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4203.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4204.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4205.1">{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4206.1">ensure_evaluated</span></span><span class="koboSpan" id="kobo.4207.1">(); </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4208.1">return</span></span><span class="koboSpan" id="kobo.4209.1"> end_ ; }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4210.1">Provide other useful members, such as a function, to return the size of the range:
        </span><pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4211.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4212.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4213.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4214.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4215.1">requires</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4216.1"> rg::sized_range&lt;R&gt;</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4217.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4218.1">return</span></span><span class="koboSpan" id="kobo.4219.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4220.1">distance</span></span><span class="koboSpan" id="kobo.4221.1">(begin_, end_); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4222.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4223.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4224.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4225.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4226.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4227.1">requires</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4228.1"> rg::sized_range&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4229.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4230.1"> R&gt;</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4231.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4232.1">return</span></span><span class="koboSpan" id="kobo.4233.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4234.1">distance</span></span><span class="koboSpan" id="kobo.4235.1">(begin_, end_); }
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4236.1">Put all together, the </span><a id="_idIndexMarker1527"/><span class="koboSpan" id="kobo.4237.1">view appears as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4238.1">template</span></span><span class="koboSpan" id="kobo.4239.1">&lt;rg::input_range R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4240.1">typename</span></span><span class="koboSpan" id="kobo.4241.1"> P&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4242.1">requires</span></span><span class="koboSpan" id="kobo.4243.1"> rg::view&lt;R&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4244.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4245.1">trim_view</span></span><span class="koboSpan" id="kobo.4246.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4247.1">public</span></span><span class="koboSpan" id="kobo.4248.1"> rg::view_interface&lt;trim_view&lt;R, P&gt;&gt;
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4249.1">private</span></span><span class="koboSpan" id="kobo.4250.1">:
  R base_ {};
  P pred_;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4251.1">mutable</span></span><span class="koboSpan" id="kobo.4252.1"> rg::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4253.1">iterator_t</span></span><span class="koboSpan" id="kobo.4254.1">&lt;R&gt; begin_ {std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4255.1">begin</span></span><span class="koboSpan" id="kobo.4256.1">(base_)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4257.1">mutable</span></span><span class="koboSpan" id="kobo.4258.1"> rg::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4259.1">iterator_t</span></span><span class="koboSpan" id="kobo.4260.1">&lt;R&gt; end_   {std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4261.1">end</span></span><span class="koboSpan" id="kobo.4262.1">(base_)};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4263.1">mutable</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4264.1">bool</span></span><span class="koboSpan" id="kobo.4265.1"> evaluated_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4266.1">false</span></span><span class="koboSpan" id="kobo.4267.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4268.1">private</span></span><span class="koboSpan" id="kobo.4269.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4270.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4271.1">ensure_evaluated</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4272.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4273.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4274.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4275.1">if</span></span><span class="koboSpan" id="kobo.4276.1">(!evaluated_)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4277.1">while</span></span><span class="koboSpan" id="kobo.4278.1">(begin_ != std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4279.1">end</span></span><span class="koboSpan" id="kobo.4280.1">(base_) &amp;&amp; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4281.1">pred_</span></span><span class="koboSpan" id="kobo.4282.1">(*begin_))
      {begin_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4283.1">next</span></span><span class="koboSpan" id="kobo.4284.1">(begin_);}
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4285.1">while</span></span><span class="koboSpan" id="kobo.4286.1">(end_ != begin_ &amp;&amp; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4287.1">pred_</span></span><span class="koboSpan" id="kobo.4288.1">(*std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4289.1">prev</span></span><span class="koboSpan" id="kobo.4290.1">(end_)))
      {end_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4291.1">prev</span></span><span class="koboSpan" id="kobo.4292.1">(end_);}
      evaluated_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4293.1">true</span></span><span class="koboSpan" id="kobo.4294.1">;
    }
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4295.1">public</span></span><span class="koboSpan" id="kobo.4296.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4297.1">trim_view</span></span><span class="koboSpan" id="kobo.4298.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4299.1">default</span></span><span class="koboSpan" id="kobo.4300.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4301.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4302.1">trim_view</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4303.1">(R base, P pred)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4304.1">    : base_(std::move(base))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4305.1">    , pred_(std::move(pred))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4306.1">    , begin_(std::begin(base_))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4307.1">    , end_(std::end(base_))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4308.1">  {</span></span><span class="koboSpan" id="kobo.4309.1">}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4310.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4311.1"> R </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4312.1">base</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4313.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4314.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4315.1"> &amp;       </span></span><span class="koboSpan" id="kobo.4316.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4317.1">return</span></span><span class="koboSpan" id="kobo.4318.1"> base_;}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4319.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4320.1"> R </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4321.1">base</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4322.1">()</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4323.1"> &amp;&amp;            </span></span><span class="koboSpan" id="kobo.4324.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4325.1">return</span></span><span class="koboSpan" id="kobo.4326.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4327.1">move</span></span><span class="koboSpan" id="kobo.4328.1">(base_);}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4329.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4330.1"> P </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4331.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4332.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4333.1">pred</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4334.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4335.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4336.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4337.1">return</span></span><span class="koboSpan" id="kobo.4338.1"> pred_; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4339.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4340.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4341.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4342.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4343.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4344.1">{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4345.1">ensure_evaluated</span></span><span class="koboSpan" id="kobo.4346.1">(); </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4347.1">return</span></span><span class="koboSpan" id="kobo.4348.1"> begin_; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4349.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4350.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4351.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4352.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4353.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4354.1">{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4355.1">ensure_evaluated</span></span><span class="koboSpan" id="kobo.4356.1">(); </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4357.1">return</span></span><span class="koboSpan" id="kobo.4358.1"> end_ ; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4359.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4360.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4361.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4362.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4363.1">requires</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4364.1"> rg::sized_range&lt;R&gt;</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4365.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4366.1">return</span></span><span class="koboSpan" id="kobo.4367.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4368.1">distance</span></span><span class="koboSpan" id="kobo.4369.1">(begin_, end_); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4370.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4371.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4372.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4373.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4374.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4375.1">requires</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4376.1"> rg::sized_range&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4377.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4378.1"> R&gt;</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4379.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4380.1">return</span></span><span class="koboSpan" id="kobo.4381.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4382.1">distance</span></span><span class="koboSpan" id="kobo.4383.1">(begin_, end_); }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4384.1">To simplify the</span><a id="_idIndexMarker1528"/><span class="koboSpan" id="kobo.4385.1"> composability of this user-defined view with the standard ones, the following should also be done:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4386.1">Create a user-defined deduction guide for the class template argument deduction of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4387.1">trim_view</span></code><span class="koboSpan" id="kobo.4388.1"> class template:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4389.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4390.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4391.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4392.1"> R, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4393.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4394.1"> P&gt;</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.4395.1">trim_view</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4396.1">(R&amp;&amp; base, P pred)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4397.1">  -&gt; trim_view&lt;rg::views::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4398.1">all_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4399.1">&lt;R&gt;, P&gt;</span></span><span class="koboSpan" id="kobo.4400.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4401.1">Create function objects that can instantiate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4402.1">trim_view</span></code><span class="koboSpan" id="kobo.4403.1"> adaptor with the proper arguments. </span><span class="koboSpan" id="kobo.4403.2">These can be made available in a separate namespace because they represent implementation details:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4404.1">namespace</span></span><span class="koboSpan" id="kobo.4405.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4406.1">template</span></span><span class="koboSpan" id="kobo.4407.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4408.1">typename</span></span><span class="koboSpan" id="kobo.4409.1"> P&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4410.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4411.1">trim_view_range_adaptor_closure</span></span><span class="koboSpan" id="kobo.4412.1">
  {
    P pred_;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4413.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4414.1">trim_view_range_adaptor_closure</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4415.1">(P pred)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4416.1">      : pred_(pred)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4417.1">    {</span></span><span class="koboSpan" id="kobo.4418.1">}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4419.1">template</span></span><span class="koboSpan" id="kobo.4420.1"> &lt;rg::viewable_range R&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4421.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4422.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4423.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4424.1">()(R &amp;&amp; r)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4425.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4426.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4427.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4428.1">trim_view</span></span><span class="koboSpan" id="kobo.4429.1">(std::forward&lt;R&gt;(r), pred_);
    }
  };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4430.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4431.1">trim_view_range_adaptor</span></span><span class="koboSpan" id="kobo.4432.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4433.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4434.1">&lt;rg::viewable_range R, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4435.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4436.1"> P&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4437.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4438.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4439.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.4440.1">()</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.4441.1">(R &amp;&amp; r, P pred)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4442.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4443.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4444.1">trim_view</span></span><span class="koboSpan" id="kobo.4445.1">( std::forward&lt;R&gt;(r), pred ) ;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4446.1">template</span></span><span class="koboSpan" id="kobo.4447.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4448.1">typename</span></span><span class="koboSpan" id="kobo.4449.1"> P&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4450.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4451.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4452.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.4453.1">()</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.4454.1">(P pred)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4455.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4456.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4457.1">trim_view_range_adaptor_closure</span></span><span class="koboSpan" id="kobo.4458.1">(pred);
    }
  };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4459.1">Overload the</span><a id="_idIndexMarker1529"/><span class="koboSpan" id="kobo.4460.1"> pipe operator for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4461.1">trim_view_range_adaptor_closure</span></code><span class="koboSpan" id="kobo.4462.1"> class defined previously:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4463.1">namespace</span></span><span class="koboSpan" id="kobo.4464.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4465.1">template</span></span><span class="koboSpan" id="kobo.4466.1"> &lt;rg::viewable_range R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4467.1">typename</span></span><span class="koboSpan" id="kobo.4468.1"> P&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4469.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4470.1">auto</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4471.1">operator</span></span><span class="koboSpan" id="kobo.4472.1"> | (
    R&amp;&amp; r,
    trim_view_range_adaptor_closure&lt;P&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.4473.1">const</span></span><span class="koboSpan" id="kobo.4474.1"> &amp; a)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4475.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4476.1">a</span></span><span class="koboSpan" id="kobo.4477.1">(std::forward&lt;R&gt;(r)) ;
  }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4478.1">Create an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4479.1">trim_view_range_adaptor</span></code><span class="koboSpan" id="kobo.4480.1"> type that can be used to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.4481.1">trim_view</span></code><span class="koboSpan" id="kobo.4482.1"> instances. </span><span class="koboSpan" id="kobo.4482.2">This can be done in a namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4483.1">views</span></code><span class="koboSpan" id="kobo.4484.1"> to create a similarity with the namespaces of the ranges library:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4485.1">namespace</span></span><span class="koboSpan" id="kobo.4486.1"> views
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4487.1">inline</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4488.1">static</span></span><span class="koboSpan" id="kobo.4489.1"> details::trim_view_range_adaptor trim;
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-800"><span class="koboSpan" id="kobo.4490.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4491.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4492.1">trim_view</span></code><span class="koboSpan" id="kobo.4493.1"> class template we defined here is derived from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4494.1">std::ranges::view_interface</span></code><span class="koboSpan" id="kobo.4495.1"> class template. </span><span class="koboSpan" id="kobo.4495.2">This is a</span><a id="_idIndexMarker1530"/><span class="koboSpan" id="kobo.4496.1"> helper class in the ranges library to define views, using the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4497.1">curiously recurring template pattern</span></strong><span class="koboSpan" id="kobo.4498.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.4499.1">CRTP</span></strong><span class="koboSpan" id="kobo.4500.1">). </span><span class="koboSpan" id="kobo.4500.2">There are two template arguments for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4501.1">trim_view</span></code><span class="koboSpan" id="kobo.4502.1"> class: the range type, which must satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4503.1">std::ranges::input_range</span></code><span class="koboSpan" id="kobo.4504.1"> concept, and the predicate type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4505.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4506.1">trim_view</span></code><span class="koboSpan" id="kobo.4507.1"> class</span><a id="_idIndexMarker1531"/><span class="koboSpan" id="kobo.4508.1"> stores the base range and the predicate internally. </span><span class="koboSpan" id="kobo.4508.2">Additionally, it requires a beginning and end (sentinel) iterator. </span><span class="koboSpan" id="kobo.4508.3">These iterators must point to the first element and the ones past the last element of the range that do not satisfy the trimming predicate. </span><span class="koboSpan" id="kobo.4508.4">However, because the view is a lazy object, these iterators should not be resolved before they are needed to iterate over the range. </span><span class="koboSpan" id="kobo.4508.5">The following diagram shows the positions of these iterators in a range of integers, for when the view must trim the odd numbers from the beginning and end of the range </span><code class="inlineCode"><span class="koboSpan" id="kobo.4509.1">{1,1,2,3,5,6,4,7,7,9}</span></code><span class="koboSpan" id="kobo.4510.1">:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.4511.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21549_12_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.4512.1">Figure 12.3: A visual conceptual representation of the range and the position of the start and end iterators before the iteration starts (above) and when it starts (below)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4513.1">We can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4514.1">trim_view</span></code><span class="koboSpan" id="kobo.4515.1"> class to write the following snippets:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4516.1">auto</span></span><span class="koboSpan" id="kobo.4517.1"> is_odd = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.4518.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4519.1">const</span></span><span class="koboSpan" id="kobo.4520.1"> n){</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4521.1">return</span></span><span class="koboSpan" id="kobo.4522.1"> n%</span><span class="hljs-number"><span class="koboSpan" id="kobo.4523.1">2</span></span><span class="koboSpan" id="kobo.4524.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4525.1">1</span></span><span class="koboSpan" id="kobo.4526.1">;};
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4527.1">int</span></span><span class="koboSpan" id="kobo.4528.1">&gt; n { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4529.1">1</span></span><span class="koboSpan" id="kobo.4530.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4531.1">1</span></span><span class="koboSpan" id="kobo.4532.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4533.1">2</span></span><span class="koboSpan" id="kobo.4534.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4535.1">3</span></span><span class="koboSpan" id="kobo.4536.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4537.1">5</span></span><span class="koboSpan" id="kobo.4538.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4539.1">6</span></span><span class="koboSpan" id="kobo.4540.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4541.1">4</span></span><span class="koboSpan" id="kobo.4542.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4543.1">7</span></span><span class="koboSpan" id="kobo.4544.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4545.1">7</span></span><span class="koboSpan" id="kobo.4546.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4547.1">9</span></span><span class="koboSpan" id="kobo.4548.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4549.1">auto</span></span><span class="koboSpan" id="kobo.4550.1"> v = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4551.1">trim_view</span></span><span class="koboSpan" id="kobo.4552.1">(n, is_odd);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4553.1">copy</span></span><span class="koboSpan" id="kobo.4554.1">(v, std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4555.1">ostream_iterator</span></span><span class="koboSpan" id="kobo.4556.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4557.1">int</span></span><span class="koboSpan" id="kobo.4558.1">&gt;(std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4559.1">" "</span></span><span class="koboSpan" id="kobo.4560.1">));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4561.1">// prints 2 3 5 6 4</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4562.1">for</span></span><span class="koboSpan" id="kobo.4563.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4564.1">auto</span></span><span class="koboSpan" id="kobo.4565.1"> i : rv::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4566.1">reverse</span></span><span class="koboSpan" id="kobo.4567.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4568.1">trim_view</span></span><span class="koboSpan" id="kobo.4569.1">(n, is_odd)))
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4570.1">' '</span></span><span class="koboSpan" id="kobo.4571.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4572.1">// prints 4 6 5 3 2</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4573.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4574.1">trim_view</span></code><span class="koboSpan" id="kobo.4575.1"> class, as well as composition with other views, is simplified through the use of the function objects declared in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4576.1">details</span></code><span class="koboSpan" id="kobo.4577.1"> namespace, which represent implementation details. </span><span class="koboSpan" id="kobo.4577.2">However, these, together with the overloaded pipe operator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4578.1">|</span></code><span class="koboSpan" id="kobo.4579.1">), make it possible to rewrite the preceding code as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4580.1">auto</span></span><span class="koboSpan" id="kobo.4581.1"> v = n | views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4582.1">trim</span></span><span class="koboSpan" id="kobo.4583.1">(is_odd);
rg::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4584.1">copy</span></span><span class="koboSpan" id="kobo.4585.1">(v, std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4586.1">ostream_iterator</span></span><span class="koboSpan" id="kobo.4587.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4588.1">int</span></span><span class="koboSpan" id="kobo.4589.1">&gt;(std::cout, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4590.1">" "</span></span><span class="koboSpan" id="kobo.4591.1">));
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4592.1">for</span></span><span class="koboSpan" id="kobo.4593.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4594.1">auto</span></span><span class="koboSpan" id="kobo.4595.1"> i : n | views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4596.1">trim</span></span><span class="koboSpan" id="kobo.4597.1">(is_odd) | rv::reverse)
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4598.1">' '</span></span><span class="koboSpan" id="kobo.4599.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4600.1">It should be mentioned </span><a id="_idIndexMarker1532"/><span class="koboSpan" id="kobo.4601.1">that the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4602.1">range-v3</span></strong><span class="koboSpan" id="kobo.4603.1"> library</span><a id="_idIndexMarker1533"/><span class="koboSpan" id="kobo.4604.1"> does contain a range view called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4605.1">trim</span></code><span class="koboSpan" id="kobo.4606.1">, but it was not ported to the C++20 ranges library. </span><span class="koboSpan" id="kobo.4606.2">This may happen in a future version of the standard.</span></p>
<h2 class="heading-2" id="_idParaDest-801"><span class="koboSpan" id="kobo.4607.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4608.1">Iterating over collections with the ranges library</span></em><span class="koboSpan" id="kobo.4609.1">, to learn about the fundamentals of the C++ ranges library</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4610.1">Specifying requirements on template arguments with concepts</span></em><span class="koboSpan" id="kobo.4611.1">, to explore the fundamentals of C++20 concepts</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4612.1">Chapter 10</span></em><em class="italic"><span class="koboSpan" id="kobo.4613.1">, Static polymorphism with the curiously recurring template pattern </span></em><span class="koboSpan" id="kobo.4614.1">to see how the CRTP works</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-802"><span class="koboSpan" id="kobo.4615.1">Using constrained algorithms</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4616.1">The C++ standard library features over 100 generic-purpose algorithms (most of them in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4617.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.4618.1"> header, and some of them in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4619.1">&lt;numeric&gt;</span></code><span class="koboSpan" id="kobo.4620.1"> header). </span><span class="koboSpan" id="kobo.4620.2">Some of these algorithms we saw in </span><em class="chapterRef"><span class="koboSpan" id="kobo.4621.1">Chapter 5</span></em><span class="koboSpan" id="kobo.4622.1">, over the course of several recipes, when we learned how to search elements in a range, sort a range, initialize a range, and more. </span><span class="koboSpan" id="kobo.4622.2">The generic aspect of algorithms comes from the fact they work with iterators (a beginning and end iterator to a sequence of elements–a range) but this has the downside of requiring more explicit code that needs to be repeated over and over again. </span><span class="koboSpan" id="kobo.4622.3">To ease the use of these algorithms, the C++20 standard provides matching algorithms in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4623.1">std::ranges</span></code><span class="koboSpan" id="kobo.4624.1"> namespace that work with ranges (but also have overloads for iterators). </span><span class="koboSpan" id="kobo.4624.2">These algorithms from the ranges library are </span><a id="_idIndexMarker1534"/><span class="koboSpan" id="kobo.4625.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.4626.1">constrained algorithms</span></strong><span class="koboSpan" id="kobo.4627.1"> and are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4628.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.4629.1"> header. </span><span class="koboSpan" id="kobo.4629.2">Although it’s not possible to look at all of them here, in this recipe we will see how to use several of them for initializing, sorting, and finding elements in a range.</span></p>
<h2 class="heading-2" id="_idParaDest-803"><span class="koboSpan" id="kobo.4630.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4631.1">You can perform </span><a id="_idIndexMarker1535"/><span class="koboSpan" id="kobo.4632.1">various operations on ranges, including initializing, finding, and sorting, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4633.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4634.1">std::ranges::fill()</span></code><span class="koboSpan" id="kobo.4635.1"> to assign a value to all the elements of a range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4636.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4637.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4638.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4639.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4640.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4641.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4642.1">)</span></span><span class="koboSpan" id="kobo.4643.1">;
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4644.1">fill</span></span><span class="koboSpan" id="kobo.4645.1">(v, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4646.1">42</span></span><span class="koboSpan" id="kobo.4647.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4648.1">// v = {42, 42, 42, 42, 42}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4649.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4650.1">std::ranges::fill_n()</span></code><span class="koboSpan" id="kobo.4651.1"> to assign a value to a specified number of elements of a range. </span><span class="koboSpan" id="kobo.4651.2">The first element to be assigned is indicated by an output iterator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4652.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4653.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4654.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4655.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4656.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4657.1">10</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4658.1">)</span></span><span class="koboSpan" id="kobo.4659.1">;
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4660.1">fill_n</span></span><span class="koboSpan" id="kobo.4661.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4662.1">begin</span></span><span class="koboSpan" id="kobo.4663.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4664.1">5</span></span><span class="koboSpan" id="kobo.4665.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4666.1">42</span></span><span class="koboSpan" id="kobo.4667.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4668.1">// v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4669.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4670.1">std::ranges::generate_n()</span></code><span class="koboSpan" id="kobo.4671.1"> to assign the value returned by successive invocations of a given function to a number of elements of a range. </span><span class="koboSpan" id="kobo.4671.2">The first element is indicated by an iterator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4672.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4673.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4674.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4675.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4676.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4677.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4678.1">)</span></span><span class="koboSpan" id="kobo.4679.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4680.1">auto</span></span><span class="koboSpan" id="kobo.4681.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4682.1">1</span></span><span class="koboSpan" id="kobo.4683.1">;
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4684.1">generate_n</span></span><span class="koboSpan" id="kobo.4685.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4686.1">begin</span></span><span class="koboSpan" id="kobo.4687.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4688.1">size</span></span><span class="koboSpan" id="kobo.4689.1">(), 
                        [&amp;i] { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4690.1">return</span></span><span class="koboSpan" id="kobo.4691.1"> I * i++; });
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4692.1">// v = {1, 4, 9, 16, 25}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4693.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4694.1">std::ranges::iota()</span></code><span class="koboSpan" id="kobo.4695.1"> to assign sequentially increasing values to the elements of a range. </span><span class="koboSpan" id="kobo.4695.2">The values are incremented using the prefix </span><code class="inlineCode"><span class="koboSpan" id="kobo.4696.1">operator++</span></code><span class="koboSpan" id="kobo.4697.1"> from an initial specified value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4698.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4699.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4700.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4701.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4702.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4703.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4704.1">)</span></span><span class="koboSpan" id="kobo.4705.1">;
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4706.1">iota</span></span><span class="koboSpan" id="kobo.4707.1">(v, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4708.1">1</span></span><span class="koboSpan" id="kobo.4709.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4710.1">// v = {1, 2, 3, 4, 5}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4711.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4712.1">std::ranges::find()</span></code><span class="koboSpan" id="kobo.4713.1"> to find a value in a range; this algorithm returns an iterator to the first element equal to the supplied value, if such a value exists, or an iterator equal to the end of the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4714.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4715.1">int</span></span><span class="koboSpan" id="kobo.4716.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4717.1">1</span></span><span class="koboSpan" id="kobo.4718.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4719.1">1</span></span><span class="koboSpan" id="kobo.4720.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4721.1">2</span></span><span class="koboSpan" id="kobo.4722.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4723.1">3</span></span><span class="koboSpan" id="kobo.4724.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4725.1">5</span></span><span class="koboSpan" id="kobo.4726.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4727.1">8</span></span><span class="koboSpan" id="kobo.4728.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4729.1">13</span></span><span class="koboSpan" id="kobo.4730.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4731.1">auto</span></span><span class="koboSpan" id="kobo.4732.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4733.1">find</span></span><span class="koboSpan" id="kobo.4734.1">(v, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4735.1">3</span></span><span class="koboSpan" id="kobo.4736.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4737.1">if</span></span><span class="koboSpan" id="kobo.4738.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4739.1">cend</span></span><span class="koboSpan" id="kobo.4740.1">()) std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4741.1">'\n'</span></span><span class="koboSpan" id="kobo.4742.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4743.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4744.1">std::ranges::find_if()</span></code><span class="koboSpan" id="kobo.4745.1"> to find a value in a range that meets the criteria defined by a unary predicate. </span><span class="koboSpan" id="kobo.4745.2">The algorithm returns an iterator to the first element in the range for which the predicate returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.4746.1">true</span></code><span class="koboSpan" id="kobo.4747.1">, or an iterator to the end of the range if no such element exists:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4748.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4749.1">int</span></span><span class="koboSpan" id="kobo.4750.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4751.1">1</span></span><span class="koboSpan" id="kobo.4752.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4753.1">1</span></span><span class="koboSpan" id="kobo.4754.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4755.1">2</span></span><span class="koboSpan" id="kobo.4756.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4757.1">3</span></span><span class="koboSpan" id="kobo.4758.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4759.1">5</span></span><span class="koboSpan" id="kobo.4760.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4761.1">8</span></span><span class="koboSpan" id="kobo.4762.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4763.1">13</span></span><span class="koboSpan" id="kobo.4764.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4765.1">auto</span></span><span class="koboSpan" id="kobo.4766.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4767.1">find_if</span></span><span class="koboSpan" id="kobo.4768.1">(v, [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.4769.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4770.1">const</span></span><span class="koboSpan" id="kobo.4771.1"> n) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4772.1">return</span></span><span class="koboSpan" id="kobo.4773.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4774.1">10</span></span><span class="koboSpan" id="kobo.4775.1">; });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4776.1">if</span></span><span class="koboSpan" id="kobo.4777.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4778.1">cend</span></span><span class="koboSpan" id="kobo.4779.1">()) std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4780.1">'\n'</span></span><span class="koboSpan" id="kobo.4781.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4782.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4783.1">std::ranges::find_first_of()</span></code><span class="koboSpan" id="kobo.4784.1"> to search for the occurrence of any value </span><a id="_idIndexMarker1536"/><span class="koboSpan" id="kobo.4785.1">from a range in another range; the algorithm returns an iterator to the first element (in the searched range) that is found, or one equal to the end of the range, otherwise:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4786.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4787.1">int</span></span><span class="koboSpan" id="kobo.4788.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4789.1">1</span></span><span class="koboSpan" id="kobo.4790.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4791.1">1</span></span><span class="koboSpan" id="kobo.4792.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4793.1">2</span></span><span class="koboSpan" id="kobo.4794.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4795.1">3</span></span><span class="koboSpan" id="kobo.4796.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4797.1">5</span></span><span class="koboSpan" id="kobo.4798.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4799.1">8</span></span><span class="koboSpan" id="kobo.4800.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4801.1">13</span></span><span class="koboSpan" id="kobo.4802.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4803.1">int</span></span><span class="koboSpan" id="kobo.4804.1">&gt; p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4805.1">5</span></span><span class="koboSpan" id="kobo.4806.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4807.1">7</span></span><span class="koboSpan" id="kobo.4808.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4809.1">11</span></span><span class="koboSpan" id="kobo.4810.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4811.1">auto</span></span><span class="koboSpan" id="kobo.4812.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4813.1">find_first_of</span></span><span class="koboSpan" id="kobo.4814.1">(v, p);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4815.1">if</span></span><span class="koboSpan" id="kobo.4816.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4817.1">cend</span></span><span class="koboSpan" id="kobo.4818.1">())
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4819.1">"found "</span></span><span class="koboSpan" id="kobo.4820.1"> &lt;&lt; *it
   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4821.1">" at index "</span></span><span class="koboSpan" id="kobo.4822.1"> &lt;&lt; std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4823.1">distance</span></span><span class="koboSpan" id="kobo.4824.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4825.1">cbegin</span></span><span class="koboSpan" id="kobo.4826.1">(), it)
   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4827.1">'\n'</span></span><span class="koboSpan" id="kobo.4828.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4829.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4830.1">std::ranges::sort()</span></code><span class="koboSpan" id="kobo.4831.1"> to sort a range. </span><span class="koboSpan" id="kobo.4831.2">You can supply a comparison function to be applied to the elements. </span><span class="koboSpan" id="kobo.4831.3">This can include </span><code class="inlineCode"><span class="koboSpan" id="kobo.4832.1">std::ranges::greater</span></code><span class="koboSpan" id="kobo.4833.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4834.1">std::ranges::less</span></code><span class="koboSpan" id="kobo.4835.1">, and the other function objects from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4836.1">&lt;functional&gt;</span></code><span class="koboSpan" id="kobo.4837.1"> header corresponding to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4838.1">&lt;</span></code><span class="koboSpan" id="kobo.4839.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4840.1">&lt;=</span></code><span class="koboSpan" id="kobo.4841.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4842.1">&gt;</span></code><span class="koboSpan" id="kobo.4843.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4844.1">&gt;=</span></code><span class="koboSpan" id="kobo.4845.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4846.1">==</span></code><span class="koboSpan" id="kobo.4847.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4848.1">!=</span></code><span class="koboSpan" id="kobo.4849.1"> operators:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4850.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4851.1">int</span></span><span class="koboSpan" id="kobo.4852.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4853.1">3</span></span><span class="koboSpan" id="kobo.4854.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4855.1">13</span></span><span class="koboSpan" id="kobo.4856.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4857.1">5</span></span><span class="koboSpan" id="kobo.4858.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4859.1">8</span></span><span class="koboSpan" id="kobo.4860.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4861.1">1</span></span><span class="koboSpan" id="kobo.4862.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4863.1">2</span></span><span class="koboSpan" id="kobo.4864.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4865.1">1</span></span><span class="koboSpan" id="kobo.4866.1"> };
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4867.1">sort</span></span><span class="koboSpan" id="kobo.4868.1">(v);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4869.1">// v = {1, 1, 2, 3, 5, 8, 13}</span></span><span class="koboSpan" id="kobo.4870.1">
std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4871.1">sort</span></span><span class="koboSpan" id="kobo.4872.1">(v, std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4873.1">greater</span></span><span class="koboSpan" id="kobo.4874.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4875.1">// v = {13, 8, 5, 3, 2, 1 ,1}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4876.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4877.1">std::ranges::is_sorted()</span></code><span class="koboSpan" id="kobo.4878.1"> to check that a range is sorted:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4879.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4880.1">int</span></span><span class="koboSpan" id="kobo.4881.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4882.1">1</span></span><span class="koboSpan" id="kobo.4883.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4884.1">1</span></span><span class="koboSpan" id="kobo.4885.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4886.1">2</span></span><span class="koboSpan" id="kobo.4887.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4888.1">3</span></span><span class="koboSpan" id="kobo.4889.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4890.1">5</span></span><span class="koboSpan" id="kobo.4891.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4892.1">8</span></span><span class="koboSpan" id="kobo.4893.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4894.1">13</span></span><span class="koboSpan" id="kobo.4895.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4896.1">auto</span></span><span class="koboSpan" id="kobo.4897.1"> sorted = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4898.1">is_sorted</span></span><span class="koboSpan" id="kobo.4899.1">(v);
sorted = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4900.1">is_sorted</span></span><span class="koboSpan" id="kobo.4901.1">(v, std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4902.1">greater</span></span><span class="koboSpan" id="kobo.4903.1">());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4904.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4905.1">std::ranges::is_sorted_until()</span></code><span class="koboSpan" id="kobo.4906.1"> to find a sorted subrange from the beginning of a </span><a id="_idIndexMarker1537"/><span class="koboSpan" id="kobo.4907.1">range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4908.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4909.1">int</span></span><span class="koboSpan" id="kobo.4910.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4911.1">3</span></span><span class="koboSpan" id="kobo.4912.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4913.1">13</span></span><span class="koboSpan" id="kobo.4914.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4915.1">5</span></span><span class="koboSpan" id="kobo.4916.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4917.1">8</span></span><span class="koboSpan" id="kobo.4918.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4919.1">1</span></span><span class="koboSpan" id="kobo.4920.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4921.1">2</span></span><span class="koboSpan" id="kobo.4922.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4923.1">1</span></span><span class="koboSpan" id="kobo.4924.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4925.1">auto</span></span><span class="koboSpan" id="kobo.4926.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4927.1">is_sorted_until</span></span><span class="koboSpan" id="kobo.4928.1">(v);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4929.1">auto</span></span><span class="koboSpan" id="kobo.4930.1"> length = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4931.1">distance</span></span><span class="koboSpan" id="kobo.4932.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4933.1">cbegin</span></span><span class="koboSpan" id="kobo.4934.1">(), it);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4935.1">// length = 2</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-804"><span class="koboSpan" id="kobo.4936.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4937.1">All but one of the</span><a id="_idIndexMarker1538"/><span class="koboSpan" id="kobo.4938.1"> constrained algorithms are located in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4939.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.4940.1"> header. </span><span class="koboSpan" id="kobo.4940.2">The exception is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4941.1">std::ranges::iota()</span></code><span class="koboSpan" id="kobo.4942.1">, which is found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4943.1">&lt;numeric&gt;</span></code><span class="koboSpan" id="kobo.4944.1"> header. </span><span class="koboSpan" id="kobo.4944.2">The algorithms listed in the </span><em class="italic"><span class="koboSpan" id="kobo.4945.1">How to do it… </span></em><span class="koboSpan" id="kobo.4946.1">section are only a small selection of the available constrained algorithms. </span><span class="koboSpan" id="kobo.4946.2">They are called constrained because there are requirements defined in their arguments with the help of concepts and constraints. </span><span class="koboSpan" id="kobo.4946.3">Here is the definition of one of the overloads of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4947.1">std::ranges::find()</span></code><span class="koboSpan" id="kobo.4948.1"> that we used previously:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4949.1">template</span></span><span class="koboSpan" id="kobo.4950.1"> &lt;ranges::input_range R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4951.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4952.1">T</span></span><span class="koboSpan" id="kobo.4953.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4954.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4955.1">Proj</span></span><span class="koboSpan" id="kobo.4956.1"> = std::identity&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4957.1">requires</span></span><span class="koboSpan" id="kobo.4958.1"> std::indirect_binary_predicate&lt;
    ranges::equal_to,
    std::projected&lt;ranges::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4959.1">iterator_t</span></span><span class="koboSpan" id="kobo.4960.1">&lt;R&gt;, Proj&gt;,
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.4961.1">const</span></span><span class="koboSpan" id="kobo.4962.1"> T*&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4963.1">constexpr</span></span><span class="koboSpan" id="kobo.4964.1"> ranges::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4965.1">borrowed_iterator_t</span></span><span class="koboSpan" id="kobo.4966.1">&lt;R&gt;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4967.1">find</span></span><span class="koboSpan" id="kobo.4968.1">( R&amp;&amp; r, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4969.1">const</span></span><span class="koboSpan" id="kobo.4970.1"> T&amp; value, Proj proj = {} );
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4971.1">If you examine the snippets previously given and those in </span><em class="chapterRef"><span class="koboSpan" id="kobo.4972.1">Chapter 5</span></em><span class="koboSpan" id="kobo.4973.1">, in the recipes </span><em class="italic"><span class="koboSpan" id="kobo.4974.1">Finding elements in a range</span></em><span class="koboSpan" id="kobo.4975.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4976.1">Sorting a range</span></em><span class="koboSpan" id="kobo.4977.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.4978.1">Initializing a range</span></em><span class="koboSpan" id="kobo.4979.1">, you will notice they are almost identical. </span><span class="koboSpan" id="kobo.4979.2">The only difference is the namespace (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4980.1">std::ranges</span></code><span class="koboSpan" id="kobo.4981.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4982.1">std</span></code><span class="koboSpan" id="kobo.4983.1">) and the arguments; the traditional algorithms take iterators that define the bounds of a range, while the constrained algorithms work with ranges as defined in the ranges library. </span><span class="koboSpan" id="kobo.4983.2">Therefore, you can pass a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4984.1">std::vector</span></code><span class="koboSpan" id="kobo.4985.1">, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4986.1">std::list</span></code><span class="koboSpan" id="kobo.4987.1">, or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4988.1">std::array</span></code><span class="koboSpan" id="kobo.4989.1"> directly. </span><span class="koboSpan" id="kobo.4989.2">However, the constrained algorithms have overloads that take a pair of iterators. </span><span class="koboSpan" id="kobo.4989.3">The following snippet shows the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4990.1">std::ranges::find()</span></code><span class="koboSpan" id="kobo.4991.1"> algorithm, also presented in the previous section, invoked with a beginning and ending iterator:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4992.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4993.1">int</span></span><span class="koboSpan" id="kobo.4994.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4995.1">1</span></span><span class="koboSpan" id="kobo.4996.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4997.1">1</span></span><span class="koboSpan" id="kobo.4998.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4999.1">2</span></span><span class="koboSpan" id="kobo.5000.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5001.1">3</span></span><span class="koboSpan" id="kobo.5002.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5003.1">5</span></span><span class="koboSpan" id="kobo.5004.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5005.1">8</span></span><span class="koboSpan" id="kobo.5006.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5007.1">13</span></span><span class="koboSpan" id="kobo.5008.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5009.1">auto</span></span><span class="koboSpan" id="kobo.5010.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5011.1">find</span></span><span class="koboSpan" id="kobo.5012.1">(v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5013.1">begin</span></span><span class="koboSpan" id="kobo.5014.1">(), v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5015.1">end</span></span><span class="koboSpan" id="kobo.5016.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.5017.1">3</span></span><span class="koboSpan" id="kobo.5018.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5019.1">if</span></span><span class="koboSpan" id="kobo.5020.1"> (it != v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5021.1">cend</span></span><span class="koboSpan" id="kobo.5022.1">()) std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5023.1">'\n'</span></span><span class="koboSpan" id="kobo.5024.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5025.1">On the other </span><a id="_idIndexMarker1539"/><span class="koboSpan" id="kobo.5026.1">hand, there are some algorithms, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5027.1">std::ranges::fill_n()</span></code><span class="koboSpan" id="kobo.5028.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5029.1">std::ranges::generate_n()</span></code><span class="koboSpan" id="kobo.5030.1">, seen earlier, that have a single overload that takes only one iterator, from the beginning of the range.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5031.1">Another difference between the traditional algorithms and the constrained algorithms is that the latter do not have overloads to specify an execution policy, unlike the former, which do.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5032.1">The constrained algorithms have </span><a id="_idIndexMarker1540"/><span class="koboSpan" id="kobo.5033.1">several advantages over the traditional algorithms:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5034.1">There is less code to write because you don’t have to retrieve the beginning and ending iterator of a range.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5035.1">They are constrained, using concepts and constraints, which help provide better error messages in case of misuse.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5036.1">They can be used with ranges/views as defined by the ranges library.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5037.1">Some of them have overloads that allow you to specify a projection to apply to the elements, on which, in turn, a specified predicate is applied.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5038.1">Let’s first see how the constrained algorithms interact with ranges. </span><span class="koboSpan" id="kobo.5038.2">For this, we consider the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5039.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5040.1">int</span></span><span class="koboSpan" id="kobo.5041.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5042.1">3</span></span><span class="koboSpan" id="kobo.5043.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5044.1">13</span></span><span class="koboSpan" id="kobo.5045.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5046.1">5</span></span><span class="koboSpan" id="kobo.5047.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5048.1">8</span></span><span class="koboSpan" id="kobo.5049.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5050.1">1</span></span><span class="koboSpan" id="kobo.5051.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5052.1">2</span></span><span class="koboSpan" id="kobo.5053.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5054.1">1</span></span><span class="koboSpan" id="kobo.5055.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5056.1">auto</span></span><span class="koboSpan" id="kobo.5057.1"> range =
   v |
   std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5058.1">filter</span></span><span class="koboSpan" id="kobo.5059.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5060.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5061.1">const</span></span><span class="koboSpan" id="kobo.5062.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5063.1">return</span></span><span class="koboSpan" id="kobo.5064.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.5065.1">2</span></span><span class="koboSpan" id="kobo.5066.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5067.1">1</span></span><span class="koboSpan" id="kobo.5068.1">; }) |
   std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5069.1">transform</span></span><span class="koboSpan" id="kobo.5070.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5071.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5072.1">const</span></span><span class="koboSpan" id="kobo.5073.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5074.1">return</span></span><span class="koboSpan" id="kobo.5075.1"> n * n; }) |
   std::views::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5076.1">take</span></span><span class="koboSpan" id="kobo.5077.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5078.1">4</span></span><span class="koboSpan" id="kobo.5079.1">);
std::ranges::for_each(range, 
                      [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5080.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5081.1">const</span></span><span class="koboSpan" id="kobo.5082.1"> n) {std::cout &lt;&lt; n &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5083.1">' '</span></span><span class="koboSpan" id="kobo.5084.1">; });
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5085.1">'\n'</span></span><span class="koboSpan" id="kobo.5086.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5087.1">auto</span></span><span class="koboSpan" id="kobo.5088.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5089.1">find_if</span></span><span class="koboSpan" id="kobo.5090.1">(range, 
                               [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5091.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5092.1">const</span></span><span class="koboSpan" id="kobo.5093.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5094.1">return</span></span><span class="koboSpan" id="kobo.5095.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5096.1">10</span></span><span class="koboSpan" id="kobo.5097.1">; });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5098.1">if</span></span><span class="koboSpan" id="kobo.5099.1"> (it != range.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5100.1">end</span></span><span class="koboSpan" id="kobo.5101.1">())
   std::cout &lt;&lt; *it &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5102.1">'\n'</span></span><span class="koboSpan" id="kobo.5103.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5104.1">In this</span><a id="_idIndexMarker1541"/><span class="koboSpan" id="kobo.5105.1"> example, we have a vector of integers. </span><span class="koboSpan" id="kobo.5105.2">From this vector, we filter out the even numbers, transform the rest by their square, and, finally, retain four of the resulting numbers. </span><span class="koboSpan" id="kobo.5105.3">The result is a range. </span><span class="koboSpan" id="kobo.5105.4">Its type is too complex to remember or write; therefore, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5106.1">auto</span></code><span class="koboSpan" id="kobo.5107.1"> specifier and let the compiler infer it. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.5108.1">For those of you who wonder what the actual type is (in this previous example), it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5109.1">std::ranges::take_view&lt;std::ranges::transform_view&lt;std::ranges::filter_view&lt;std::ranges::ref_view&lt;std::vector&lt;int&gt;&gt;, lambda [](int n)-&gt;bool&gt;, lambda [](int n)-&gt;int&gt;&gt;</span></code><span class="koboSpan" id="kobo.5110.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.5111.1">We want to print the resulting values to the console and find the first value greater than 10 (if any exists). </span><span class="koboSpan" id="kobo.5111.2">For this purpose, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5112.1">std::ranges::for_each()</span></code><span class="koboSpan" id="kobo.5113.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5114.1">std::ranges::find_if()</span></code><span class="koboSpan" id="kobo.5115.1">, passing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5116.1">range</span></code><span class="koboSpan" id="kobo.5117.1"> object without having to deal directly with iterators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5118.1">The last advantage mentioned earlier in the list is the ability to specify a projection. </span><span class="koboSpan" id="kobo.5118.2">A projection is a callable object (for instance, a function object, or a reference to a member). </span><span class="koboSpan" id="kobo.5118.3">This projection is applied to the elements of the range. </span><span class="koboSpan" id="kobo.5118.4">On the result of the projection, another predicate is applied. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.5119.1">To understand how this works, let’s consider a list of products with an ID, name, and price. </span><span class="koboSpan" id="kobo.5119.2">From this list, we want to find the product with a certain price and print its name. </span><span class="koboSpan" id="kobo.5119.3">The list is defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5120.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5121.1">Product</span></span><span class="koboSpan" id="kobo.5122.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.5123.1">int</span></span><span class="koboSpan" id="kobo.5124.1">         id;
   std::string name;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.5125.1">double</span></span><span class="koboSpan" id="kobo.5126.1">      price;
};
std::vector&lt;Product&gt; products
{
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.5127.1">1</span></span><span class="koboSpan" id="kobo.5128.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5129.1">"pen"</span></span><span class="koboSpan" id="kobo.5130.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5131.1">15.50</span></span><span class="koboSpan" id="kobo.5132.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.5133.1">2</span></span><span class="koboSpan" id="kobo.5134.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5135.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5136.1">pencil"</span></span><span class="koboSpan" id="kobo.5137.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5138.1">9.99</span></span><span class="koboSpan" id="kobo.5139.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.5140.1">3</span></span><span class="koboSpan" id="kobo.5141.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5142.1">"rubber"</span></span><span class="koboSpan" id="kobo.5143.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5144.1">5.0</span></span><span class="koboSpan" id="kobo.5145.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.5146.1">4</span></span><span class="koboSpan" id="kobo.5147.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5148.1">"ruler"</span></span><span class="koboSpan" id="kobo.5149.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5150.1">5.50</span></span><span class="koboSpan" id="kobo.5151.1">},
   {</span><span class="hljs-number"><span class="koboSpan" id="kobo.5152.1">5</span></span><span class="koboSpan" id="kobo.5153.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5154.1">"notebook"</span></span><span class="koboSpan" id="kobo.5155.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5156.1">12.50</span></span><span class="koboSpan" id="kobo.5157.1">}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5158.1">With the </span><a id="_idIndexMarker1542"/><span class="koboSpan" id="kobo.5159.1">traditional algorithms, we need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5160.1">std::find_if()</span></code><span class="koboSpan" id="kobo.5161.1"> and pass a lambda function that performs the checking of each element:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5162.1">auto</span></span><span class="koboSpan" id="kobo.5163.1"> pos = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5164.1">find_if</span></span><span class="koboSpan" id="kobo.5165.1">(
   products.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5166.1">begin</span></span><span class="koboSpan" id="kobo.5167.1">(), products.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5168.1">end</span></span><span class="koboSpan" id="kobo.5169.1">(),
   [](Product </span><span class="hljs-type"><span class="koboSpan" id="kobo.5170.1">const</span></span><span class="koboSpan" id="kobo.5171.1">&amp; p) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5172.1">return</span></span><span class="koboSpan" id="kobo.5173.1"> p.price == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5174.1">12.5</span></span><span class="koboSpan" id="kobo.5175.1">; });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5176.1">if</span></span><span class="koboSpan" id="kobo.5177.1"> (pos != products.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5178.1">end</span></span><span class="koboSpan" id="kobo.5179.1">())
   std::cout &lt;&lt; pos-&gt;name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5180.1">'\n'</span></span><span class="koboSpan" id="kobo.5181.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5182.1">With constrained algorithms, we can use one of the overloads of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5183.1">std::ranges::find()</span></code><span class="koboSpan" id="kobo.5184.1"> that take a range, a value, and a projection, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5185.1">auto</span></span><span class="koboSpan" id="kobo.5186.1"> it = std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5187.1">find</span></span><span class="koboSpan" id="kobo.5188.1">(products, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5189.1">12.50</span></span><span class="koboSpan" id="kobo.5190.1">, &amp;Product::price);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5191.1">if</span></span><span class="koboSpan" id="kobo.5192.1"> (it != products.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5193.1">end</span></span><span class="koboSpan" id="kobo.5194.1">())
   std::cout &lt;&lt; it-&gt;name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5195.1">'\n'</span></span><span class="koboSpan" id="kobo.5196.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5197.1">Another similar example is sorting the range alphabetically (in ascending order) by the name of the products:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5198.1">std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5199.1">sort</span></span><span class="koboSpan" id="kobo.5200.1">(products, std::ranges::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5201.1">less</span></span><span class="koboSpan" id="kobo.5202.1">(), &amp;Product::name);
std::ranges::for_each(products, [](Product </span><span class="hljs-type"><span class="koboSpan" id="kobo.5203.1">const</span></span><span class="koboSpan" id="kobo.5204.1">&amp; p) {
      std::cout &lt;&lt; std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5205.1">"{} = {}\n"</span></span><span class="koboSpan" id="kobo.5206.1">, p.name, p.price); });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5207.1">Hopefully, these</span><a id="_idIndexMarker1543"/><span class="koboSpan" id="kobo.5208.1"> examples show there are compelling arguments to prefer, in general, the new C++20 constrained algorithms over the traditional ones. </span><span class="koboSpan" id="kobo.5208.2">However, keep in mind that you cannot use constrained algorithms when you want to specify an execution policy (for instance, to parallelize or vectorize the execution of an algorithm), as such overloads are not available.</span></p>
<h2 class="heading-2" id="_idParaDest-805"><span class="koboSpan" id="kobo.5209.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5210.1">Chapter 5</span></em><span class="koboSpan" id="kobo.5211.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5212.1">Finding elements in a range</span></em><span class="koboSpan" id="kobo.5213.1">, to learn about the standard algorithms to search through sequences of values</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5214.1">Chapter 5</span></em><span class="koboSpan" id="kobo.5215.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5216.1">Sorting a range</span></em><span class="koboSpan" id="kobo.5217.1">, to learn about the standard algorithms for sorting ranges</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5218.1">Chapter 5</span></em><span class="koboSpan" id="kobo.5219.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5220.1">Initializing a range</span></em><span class="koboSpan" id="kobo.5221.1">, to explore the standard algorithms for filling a range with values</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5222.1">Specify requirements on template arguments with concepts</span></em><span class="koboSpan" id="kobo.5223.1">, to explore the fundamentals of C++20 concepts</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-806"><span class="koboSpan" id="kobo.5224.1">Creating a coroutine task type for asynchronous computations</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5225.1">A major component of the C++20 </span><a id="_idIndexMarker1544"/><span class="koboSpan" id="kobo.5226.1">standard is represented by coroutines. </span><span class="koboSpan" id="kobo.5226.2">Simply put, coroutines are functions that can be suspended and resumed. </span><span class="koboSpan" id="kobo.5226.3">Coroutines are an alternative to writing asynchronous code. </span><span class="koboSpan" id="kobo.5226.4">They help simplify asynchronous I/O code, lazy computations, or event-driven applications. </span><span class="koboSpan" id="kobo.5226.5">When a coroutine is suspended, the execution returns to the caller, and the data necessary to resume the coroutine is stored separately from the stack. </span><span class="koboSpan" id="kobo.5226.6">For this reason, the C++20 coroutines are called </span><em class="italic"><span class="koboSpan" id="kobo.5227.1">stackless</span></em><span class="koboSpan" id="kobo.5228.1">. </span><span class="koboSpan" id="kobo.5228.2">Unfortunately, the C++20 standard does not define actual coroutine types and only a framework for building them. </span><span class="koboSpan" id="kobo.5228.3">This makes writing asynchronous code with coroutines difficult without relying on third-party components.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5229.1">In this recipe, you will learn how to write a coroutine task type that represents an asynchronous computation, which starts executing when the task is awaited.</span></p>
<h2 class="heading-2" id="_idParaDest-807"><span class="koboSpan" id="kobo.5230.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5231.1">The several </span><a id="_idIndexMarker1545"/><span class="koboSpan" id="kobo.5232.1">standard library types and functions that define the coroutine framework are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5233.1">&lt;coroutine&gt;</span></code><span class="koboSpan" id="kobo.5234.1"> header, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5235.1">std</span></code><span class="koboSpan" id="kobo.5236.1"> namespace. </span><span class="koboSpan" id="kobo.5236.2">However, you need to use a minimum compiler version to support coroutines: MSVC 19.28 (from Visual Studio 2019 16.8), Clang 17, or GCC 10.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5237.1">The goal of this recipe is to create a task type that enables us to write asynchronous functions, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5238.1">task&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5239.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5240.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5241.1">get_answer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5242.1">()</span></span><span class="koboSpan" id="kobo.5243.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5244.1">co_return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.5245.1">42</span></span><span class="koboSpan" id="kobo.5246.1">;
}
task&lt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5247.1">print_answer</span></span><span class="koboSpan" id="kobo.5248.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5249.1">auto</span></span><span class="koboSpan" id="kobo.5250.1"> t = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5251.1">co_await</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5252.1">get_answer</span></span><span class="koboSpan" id="kobo.5253.1">();
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5254.1">"the answer is "</span></span><span class="koboSpan" id="kobo.5255.1"> &lt;&lt; t &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5256.1">'\n'</span></span><span class="koboSpan" id="kobo.5257.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5258.1">template</span></span><span class="koboSpan" id="kobo.5259.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5260.1">typename</span></span><span class="koboSpan" id="kobo.5261.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5262.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5263.1">execute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5264.1">(T&amp;&amp; t)</span></span><span class="koboSpan" id="kobo.5265.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5266.1">while</span></span><span class="koboSpan" id="kobo.5267.1"> (!t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5268.1">is_ready</span></span><span class="koboSpan" id="kobo.5269.1">()) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5270.1">resume</span></span><span class="koboSpan" id="kobo.5271.1">();
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5272.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5273.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5274.1">()</span></span><span class="koboSpan" id="kobo.5275.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5276.1">auto</span></span><span class="koboSpan" id="kobo.5277.1"> t = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5278.1">get_answer</span></span><span class="koboSpan" id="kobo.5279.1">();
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5280.1">execute</span></span><span class="koboSpan" id="kobo.5281.1">(t);
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5282.1">"the answer is "</span></span><span class="koboSpan" id="kobo.5283.1"> &lt;&lt; t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5284.1">value</span></span><span class="koboSpan" id="kobo.5285.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5286.1">'\n'</span></span><span class="koboSpan" id="kobo.5287.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5288.1">execute</span></span><span class="koboSpan" id="kobo.5289.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5290.1">print_answer</span></span><span class="koboSpan" id="kobo.5291.1">());
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-808"><span class="koboSpan" id="kobo.5292.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5293.1">To create a task </span><a id="_idIndexMarker1546"/><span class="koboSpan" id="kobo.5294.1">type that supports coroutines that return nothing (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5295.1">task&lt;&gt;</span></code><span class="koboSpan" id="kobo.5296.1">), a value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5297.1">task&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5298.1">), or a reference (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5299.1">task&lt;T&amp;&gt;</span></code><span class="koboSpan" id="kobo.5300.1">), you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5301.1">Create a class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5302.1">promise_base</span></code><span class="koboSpan" id="kobo.5303.1"> with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5304.1">namespace</span></span><span class="koboSpan" id="kobo.5305.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5306.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5307.1">promise_base</span></span><span class="koboSpan" id="kobo.5308.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5309.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5310.1">initial_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5311.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5312.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5313.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5314.1">return</span></span><span class="koboSpan" id="kobo.5315.1"> std::suspend_always{}; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5316.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5317.1">final_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5318.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5319.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5320.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5321.1">return</span></span><span class="koboSpan" id="kobo.5322.1"> std::suspend_always{}; }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.5323.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5324.1">unhandled_exception</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5325.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5326.1">{ std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5327.1">terminate</span></span><span class="koboSpan" id="kobo.5328.1">(); }
   };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5329.1">Create a class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5330.1">promise</span></code><span class="koboSpan" id="kobo.5331.1">, derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.5332.1">promise_base</span></code><span class="koboSpan" id="kobo.5333.1">, that adds the methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.5334.1">get_return_object()</span></code><span class="koboSpan" id="kobo.5335.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5336.1">return_value()</span></code><span class="koboSpan" id="kobo.5337.1"> and holds the value returned from the coroutine:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5338.1">template &lt;typename T&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5339.1">struct task;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5340.1">namespace</span></span><span class="koboSpan" id="kobo.5341.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5342.1">template</span></span><span class="koboSpan" id="kobo.5343.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5344.1">typename</span></span><span class="koboSpan" id="kobo.5345.1"> T&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5346.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5347.1">promise</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5348.1">final</span></span><span class="koboSpan" id="kobo.5349.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5350.1">public</span></span><span class="koboSpan" id="kobo.5351.1"> promise_base
  {
    task&lt;T&gt; get_return_object() noexcept;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5352.1">template</span></span><span class="koboSpan" id="kobo.5353.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5354.1">typename</span></span><span class="koboSpan" id="kobo.5355.1"> V,
             </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5356.1">typename</span></span><span class="koboSpan" id="kobo.5357.1"> = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5358.1">enable_if_t</span></span><span class="koboSpan" id="kobo.5359.1">&lt;
                std::is_convertible_v&lt;V&amp;&amp;, T&gt;&gt;&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5360.1">void</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5361.1">return_value</span></span><span class="koboSpan" id="kobo.5362.1">(V&amp;&amp; value)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5363.1">noexcept</span></span><span class="koboSpan" id="kobo.5364.1">(std::is_nothrow_constructible_v&lt;T, V&amp;&amp;&gt;)
    {
      value_ = value;
    }
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.5365.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5366.1">get_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5367.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5368.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5369.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5370.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5371.1">return</span></span><span class="koboSpan" id="kobo.5372.1"> value_; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5373.1">private</span></span><span class="koboSpan" id="kobo.5374.1">:
    T value_;
  };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5375.1">Specialize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5376.1">promise</span></code><span class="koboSpan" id="kobo.5377.1"> class template for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5378.1">void</span></code><span class="koboSpan" id="kobo.5379.1"> type, and provide implementations for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5380.1">get_return_object()</span></code><span class="koboSpan" id="kobo.5381.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5382.1">return_void()</span></code><span class="koboSpan" id="kobo.5383.1"> methods:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5384.1">namespace</span></span><span class="koboSpan" id="kobo.5385.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5386.1">template</span></span><span class="koboSpan" id="kobo.5387.1"> &lt;&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5388.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5389.1">promise</span></span><span class="koboSpan" id="kobo.5390.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5391.1">void</span></span><span class="koboSpan" id="kobo.5392.1">&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5393.1">final</span></span><span class="koboSpan" id="kobo.5394.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5395.1">public</span></span><span class="koboSpan" id="kobo.5396.1"> promise_base
  {
    task&lt;void&gt; get_return_object() noexcept;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.5397.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5398.1">return_void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5399.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5400.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5401.1">{}
  };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5402.1">Specialize</span><a id="_idIndexMarker1547"/><span class="koboSpan" id="kobo.5403.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5404.1">promise</span></code><span class="koboSpan" id="kobo.5405.1"> class template for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5406.1">T&amp;</span></code><span class="koboSpan" id="kobo.5407.1">. </span><span class="koboSpan" id="kobo.5407.2">Provide implementations for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5408.1">get_return_object()</span></code><span class="koboSpan" id="kobo.5409.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5410.1">return_value()</span></code><span class="koboSpan" id="kobo.5411.1">, and store a pointer to the reference returned by the coroutine:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5412.1">namespace</span></span><span class="koboSpan" id="kobo.5413.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5414.1">template</span></span><span class="koboSpan" id="kobo.5415.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5416.1">typename</span></span><span class="koboSpan" id="kobo.5417.1"> T&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5418.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5419.1">promise</span></span><span class="koboSpan" id="kobo.5420.1">&lt;T&amp;&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5421.1">final</span></span><span class="koboSpan" id="kobo.5422.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5423.1">public</span></span><span class="koboSpan" id="kobo.5424.1"> promise_base
  {    
    task&lt;T&amp;&gt; get_return_object() noexcept;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.5425.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5426.1">return_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5427.1">(T&amp; value)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5428.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5429.1">{
      value_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5430.1">addressof</span></span><span class="koboSpan" id="kobo.5431.1">(value);
    }
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.5432.1">T&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5433.1">get_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5434.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5435.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5436.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5437.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5438.1">return</span></span><span class="koboSpan" id="kobo.5439.1"> *value_; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5440.1">private</span></span><span class="koboSpan" id="kobo.5441.1">:
    T* value_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5442.1">nullptr</span></span><span class="koboSpan" id="kobo.5443.1">;
  };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5444.1">Create a class</span><a id="_idIndexMarker1548"/><span class="koboSpan" id="kobo.5445.1"> template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5446.1">task</span></code><span class="koboSpan" id="kobo.5447.1">, with the stub content shown below. </span><span class="koboSpan" id="kobo.5447.2">This type must have an inner type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5448.1">promise_type</span></code><span class="koboSpan" id="kobo.5449.1"> and hold a handle to the executing coroutine. </span><span class="koboSpan" id="kobo.5449.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5450.1">task_awaiter</span></code><span class="koboSpan" id="kobo.5451.1"> and the class members are listed here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5452.1">template</span></span><span class="koboSpan" id="kobo.5453.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5454.1">typename</span></span><span class="koboSpan" id="kobo.5455.1"> T = </span><span class="hljs-type"><span class="koboSpan" id="kobo.5456.1">void</span></span><span class="koboSpan" id="kobo.5457.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5458.1">struct</span></span><span class="koboSpan" id="kobo.5459.1"> task
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5460.1">using</span></span><span class="koboSpan" id="kobo.5461.1"> promise_type = details::promise&lt;T&gt;;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5462.1">// task_awaiter</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.5463.1">// members</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5464.1">private</span></span><span class="koboSpan" id="kobo.5465.1">:
  std::coroutine_handle&lt;promise_type&gt; handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5466.1">nullptr</span></span><span class="koboSpan" id="kobo.5467.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5468.1">Create an awaitable class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5469.1">task_awaiter</span></code><span class="koboSpan" id="kobo.5470.1"> that implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5471.1">await_ready()</span></code><span class="koboSpan" id="kobo.5472.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5473.1">await_suspend()</span></code><span class="koboSpan" id="kobo.5474.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5475.1">await_resume()</span></code><span class="koboSpan" id="kobo.5476.1"> methods:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5477.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5478.1">task_awaiter</span></span><span class="koboSpan" id="kobo.5479.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5480.1">task_awaiter</span></span><span class="koboSpan" id="kobo.5481.1">(std::coroutine_handle&lt;promise_type&gt; coroutine)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5482.1">noexcept</span></span><span class="koboSpan" id="kobo.5483.1">
    : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5484.1">handle_</span></span><span class="koboSpan" id="kobo.5485.1">(coroutine)
  {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5486.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5487.1">await_ready</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5488.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5489.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5490.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5491.1">{
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5492.1">return</span></span><span class="koboSpan" id="kobo.5493.1"> !handle_ || handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5494.1">done</span></span><span class="koboSpan" id="kobo.5495.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5496.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5497.1">await_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5498.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.5499.1">    std::coroutine_handle&lt;&gt; continuation)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5500.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5501.1">{
    handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5502.1">resume</span></span><span class="koboSpan" id="kobo.5503.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5504.1">decltype</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5505.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5506.1">auto</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5507.1">) </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5508.1">await_resume</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5509.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5510.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5511.1">if</span></span><span class="koboSpan" id="kobo.5512.1"> (!handle_)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5513.1">throw</span></span><span class="koboSpan" id="kobo.5514.1"> std::runtime_error{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5515.1">"broken promise"</span></span><span class="koboSpan" id="kobo.5516.1"> };
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5517.1">return</span></span><span class="koboSpan" id="kobo.5518.1"> handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5519.1">promise</span></span><span class="koboSpan" id="kobo.5520.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5521.1">get_value</span></span><span class="koboSpan" id="kobo.5522.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5523.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5524.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5525.1">task</span></span><span class="koboSpan" id="kobo.5526.1">&lt;T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5527.1">private</span></span><span class="koboSpan" id="kobo.5528.1">:
  std::coroutine_handle&lt;promise_type&gt; handle_;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5529.1">Provide </span><a id="_idIndexMarker1549"/><span class="koboSpan" id="kobo.5530.1">class members, including a conversion constructor, a move constructor and move assignment operator, a destructor, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5531.1">co_await</span></code><span class="koboSpan" id="kobo.5532.1"> operator, a method to check whether the coroutine has completed, a method to resume a suspended coroutine, and a method to get the value returned from the coroutine:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5533.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5534.1">task</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5535.1">(std::coroutine_handle&lt;promise_type&gt; handle)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.5536.1">  : handle_(handle)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.5537.1">{</span></span><span class="koboSpan" id="kobo.5538.1">
}
~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5539.1">task</span></span><span class="koboSpan" id="kobo.5540.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5541.1">if</span></span><span class="koboSpan" id="kobo.5542.1"> (handle_) handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5543.1">destroy</span></span><span class="koboSpan" id="kobo.5544.1">();
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5545.1">task</span></span><span class="koboSpan" id="kobo.5546.1">(task&amp;&amp; t) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5547.1">noexcept</span></span><span class="koboSpan" id="kobo.5548.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5549.1">handle_</span></span><span class="koboSpan" id="kobo.5550.1">(t.handle_)
{
  t.handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5551.1">nullptr</span></span><span class="koboSpan" id="kobo.5552.1">;
}
task&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5553.1">operator</span></span><span class="koboSpan" id="kobo.5554.1">=(task&amp;&amp; other) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5555.1">noexcept</span></span><span class="koboSpan" id="kobo.5556.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5557.1">if</span></span><span class="koboSpan" id="kobo.5558.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5559.1">addressof</span></span><span class="koboSpan" id="kobo.5560.1">(other) != </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5561.1">this</span></span><span class="koboSpan" id="kobo.5562.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5563.1">if</span></span><span class="koboSpan" id="kobo.5564.1"> (handle_) handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5565.1">destroy</span></span><span class="koboSpan" id="kobo.5566.1">();
    handle_ = other.handle_;
    other.handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5567.1">nullptr</span></span><span class="koboSpan" id="kobo.5568.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5569.1">return</span></span><span class="koboSpan" id="kobo.5570.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5571.1">this</span></span><span class="koboSpan" id="kobo.5572.1">;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5573.1">task</span></span><span class="koboSpan" id="kobo.5574.1">(task </span><span class="hljs-type"><span class="koboSpan" id="kobo.5575.1">const</span></span><span class="koboSpan" id="kobo.5576.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5577.1">delete</span></span><span class="koboSpan" id="kobo.5578.1">;
task&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5579.1">operator</span></span><span class="koboSpan" id="kobo.5580.1">=(task </span><span class="hljs-type"><span class="koboSpan" id="kobo.5581.1">const</span></span><span class="koboSpan" id="kobo.5582.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5583.1">delete</span></span><span class="koboSpan" id="kobo.5584.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.5585.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5586.1">value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5587.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5588.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5589.1">noexcept</span></span><span class="koboSpan" id="kobo.5590.1">
{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5591.1">return</span></span><span class="koboSpan" id="kobo.5592.1"> handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5593.1">promise</span></span><span class="koboSpan" id="kobo.5594.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5595.1">get_value</span></span><span class="koboSpan" id="kobo.5596.1">(); }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5597.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5598.1">resume</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5599.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5600.1">noexcept</span></span><span class="koboSpan" id="kobo.5601.1">
{ handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5602.1">resume</span></span><span class="koboSpan" id="kobo.5603.1">(); }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5604.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5605.1">is_ready</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5606.1">() const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5607.1">noexcept</span></span><span class="koboSpan" id="kobo.5608.1">
{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5609.1">return</span></span><span class="koboSpan" id="kobo.5610.1"> !handle_ || handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5611.1">done</span></span><span class="koboSpan" id="kobo.5612.1">(); }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5613.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5614.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5615.1">co_await</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5616.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5617.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5618.1">&amp; </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5619.1">noexcept</span></span><span class="koboSpan" id="kobo.5620.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5621.1">return</span></span><span class="koboSpan" id="kobo.5622.1"> task_awaiter{ handle_ };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5623.1">Implement</span><a id="_idIndexMarker1550"/><span class="koboSpan" id="kobo.5624.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5625.1">get_return_object()</span></code><span class="koboSpan" id="kobo.5626.1"> member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5627.1">promise</span></code><span class="koboSpan" id="kobo.5628.1"> primary template as well as its specializations. </span><span class="koboSpan" id="kobo.5628.2">This must be done after the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5629.1">task</span></code><span class="koboSpan" id="kobo.5630.1"> class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5631.1">namespace</span></span><span class="koboSpan" id="kobo.5632.1"> details
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5633.1">template</span></span><span class="koboSpan" id="kobo.5634.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5635.1">typename</span></span><span class="koboSpan" id="kobo.5636.1"> T&gt;
   task&lt;T&gt; promise&lt;T&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5637.1">get_return_object</span></span><span class="koboSpan" id="kobo.5638.1">() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5639.1">noexcept</span></span><span class="koboSpan" id="kobo.5640.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5641.1">return</span></span><span class="koboSpan" id="kobo.5642.1"> task&lt;T&gt;{
        std::coroutine_handle&lt;promise&lt;T&gt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5643.1">from_promise</span></span><span class="koboSpan" id="kobo.5644.1">(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5645.1">this</span></span><span class="koboSpan" id="kobo.5646.1">)};
   }
   task&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5647.1">void</span></span><span class="koboSpan" id="kobo.5648.1">&gt; promise&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5649.1">void</span></span><span class="koboSpan" id="kobo.5650.1">&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5651.1">get_return_object</span></span><span class="koboSpan" id="kobo.5652.1">() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5653.1">noexcept</span></span><span class="koboSpan" id="kobo.5654.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5655.1">return</span></span><span class="koboSpan" id="kobo.5656.1"> task&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5657.1">void</span></span><span class="koboSpan" id="kobo.5658.1">&gt;{
        std::coroutine_handle&lt;promise&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5659.1">void</span></span><span class="koboSpan" id="kobo.5660.1">&gt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5661.1">from_promise</span></span><span class="koboSpan" id="kobo.5662.1">(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5663.1">this</span></span><span class="koboSpan" id="kobo.5664.1">)};
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5665.1">template</span></span><span class="koboSpan" id="kobo.5666.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5667.1">typename</span></span><span class="koboSpan" id="kobo.5668.1"> T&gt;
   task&lt;T&amp;&gt; promise&lt;T&amp;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5669.1">get_return_object</span></span><span class="koboSpan" id="kobo.5670.1">() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5671.1">noexcept</span></span><span class="koboSpan" id="kobo.5672.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5673.1">return</span></span><span class="koboSpan" id="kobo.5674.1"> task&lt;T&amp;&gt;{
        std::coroutine_handle&lt;promise&lt;T&amp;&gt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5675.1">from_promise</span></span><span class="koboSpan" id="kobo.5676.1">(
        *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5677.1">this</span></span><span class="koboSpan" id="kobo.5678.1">)};
   }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-809"><span class="koboSpan" id="kobo.5679.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5680.1">Functions are </span><a id="_idIndexMarker1551"/><span class="koboSpan" id="kobo.5681.1">blocks of code that execute one or more statements. </span><span class="koboSpan" id="kobo.5681.2">You can assign them to variables, pass them as arguments, take their address, and, of course, invoke them. </span><span class="koboSpan" id="kobo.5681.3">These features make them first-class citizens in the C++ language. </span><span class="koboSpan" id="kobo.5681.4">Functions are sometimes called </span><em class="italic"><span class="koboSpan" id="kobo.5682.1">subroutines</span></em><span class="koboSpan" id="kobo.5683.1">. </span><span class="koboSpan" id="kobo.5683.2">Coroutines, on the other hand, are functions that support two additional operations: suspending and resuming their execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5684.1">In C++20, a function</span><a id="_idIndexMarker1552"/><span class="koboSpan" id="kobo.5685.1"> is a coroutine if it uses any of the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5686.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5687.1">co_await</span></code><span class="koboSpan" id="kobo.5688.1"> operator, which suspends the execution until resumed</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5689.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5690.1">co_return</span></code><span class="koboSpan" id="kobo.5691.1"> keyword, to complete the execution and optionally return a value</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5692.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5693.1">co_yield</span></code><span class="koboSpan" id="kobo.5694.1"> keyword, to suspend the execution and return a value</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5695.1">Not every function, however, can be a coroutine. </span><span class="koboSpan" id="kobo.5695.2">The following cannot be coroutines:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5696.1">Constructors and destructors</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5697.1">Constexpr functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5698.1">Functions with a variable number of arguments</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5699.1">Functions that return </span><code class="inlineCode"><span class="koboSpan" id="kobo.5700.1">auto</span></code><span class="koboSpan" id="kobo.5701.1"> or a concept type</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5702.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5703.1">main()</span></code><span class="koboSpan" id="kobo.5704.1"> function</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5705.1">A coroutine</span><a id="_idIndexMarker1553"/><span class="koboSpan" id="kobo.5706.1"> consists of the following three parts:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5707.1">A </span><em class="italic"><span class="koboSpan" id="kobo.5708.1">promise object</span></em><span class="koboSpan" id="kobo.5709.1">, which is </span><a id="_idIndexMarker1554"/><span class="koboSpan" id="kobo.5710.1">manipulated inside the coroutine and is used to pass the return value or an exception from the coroutine.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5711.1">A </span><em class="italic"><span class="koboSpan" id="kobo.5712.1">coroutine handle</span></em><span class="koboSpan" id="kobo.5713.1">, which is </span><a id="_idIndexMarker1555"/><span class="koboSpan" id="kobo.5714.1">manipulated outside the coroutine and is used to either resume the execution or destroy the coroutine frame.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5715.1">The </span><em class="italic"><span class="koboSpan" id="kobo.5716.1">coroutine frame</span></em><span class="koboSpan" id="kobo.5717.1">, typically </span><a id="_idIndexMarker1556"/><span class="koboSpan" id="kobo.5718.1">allocated on the heap and containing the promise object, the coroutine parameters copied by value, local variables, temporaries whose lifetimes exceed the current suspension point, and a representation of the suspension point so that resuming and destroying can be performed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5719.1">The promise object</span><a id="_idIndexMarker1557"/><span class="koboSpan" id="kobo.5720.1"> can be any type that implements the following interface, as </span><a id="_idIndexMarker1558"/><span class="koboSpan" id="kobo.5721.1">expected by the compiler:</span></p>
<table class="table-container" id="table003-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5722.1">Default constructor</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5723.1">The promise must be default constructible</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5724.1">initial_suspend()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5725.1">Indicates whether suspension happens at the initial suspend point.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5726.1">final_suspend()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5727.1">Indicates whether suspension happens at the last suspend point.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5728.1">unhandled_exception()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5729.1">Called when an exception propagates out of a coroutine block.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5730.1">get_return_object()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5731.1">The return value of the function.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5732.1">return_value(v)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5733.1">Enables the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5734.1">co_return v</span></code><span class="koboSpan" id="kobo.5735.1"> statement. </span><span class="koboSpan" id="kobo.5735.2">Its return type must be </span><code class="inlineCode"><span class="koboSpan" id="kobo.5736.1">void</span></code><span class="koboSpan" id="kobo.5737.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5738.1">return_void()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5739.1">Enables the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5740.1">co_return</span></code><span class="koboSpan" id="kobo.5741.1"> statement. </span><span class="koboSpan" id="kobo.5741.2">Its return type must be </span><code class="inlineCode"><span class="koboSpan" id="kobo.5742.1">void</span></code><span class="koboSpan" id="kobo.5743.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5744.1">yield_value(v)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5745.1">Enables the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5746.1">co_yield v</span></code><span class="koboSpan" id="kobo.5747.1"> statement.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5748.1">Table 12.3: The members of the interface implemented by a promise</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5749.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5750.1">initial_suspend()</span></code><span class="koboSpan" id="kobo.5751.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5752.1">final_suspend()</span></code><span class="koboSpan" id="kobo.5753.1"> we have seen for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5754.1">promise</span></code><span class="koboSpan" id="kobo.5755.1"> type implemented here returns an instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5756.1">std::suspend_always</span></code><span class="koboSpan" id="kobo.5757.1">. </span><span class="koboSpan" id="kobo.5757.2">This is one of the two trivial awaitables that the standard defines, the other being </span><code class="inlineCode"><span class="koboSpan" id="kobo.5758.1">std::suspend_never</span></code><span class="koboSpan" id="kobo.5759.1">. </span><span class="koboSpan" id="kobo.5759.2">Their implementation is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5760.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5761.1">suspend_always</span></span><span class="koboSpan" id="kobo.5762.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5763.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5764.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5765.1">await_ready</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5766.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5767.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5768.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5769.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.5770.1">false</span></span><span class="koboSpan" id="kobo.5771.1">; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5772.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5773.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5774.1">await_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5775.1">(coroutine_handle&lt;&gt;)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5776.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5777.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5778.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5779.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5780.1">await_resume</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5781.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5782.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5783.1">{}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5784.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5785.1">suspend_never</span></span><span class="koboSpan" id="kobo.5786.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5787.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5788.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5789.1">await_ready</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5790.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5791.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5792.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5793.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.5794.1">true</span></span><span class="koboSpan" id="kobo.5795.1">; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5796.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5797.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5798.1">await_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5799.1">(coroutine_handle&lt;&gt;)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5800.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5801.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5802.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5803.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5804.1">await_resume</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5805.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5806.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5807.1">{}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5808.1">These types implement the </span><em class="italic"><span class="koboSpan" id="kobo.5809.1">awaitable</span></em><span class="koboSpan" id="kobo.5810.1"> concept, which enables the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5811.1">co_await</span></code><span class="koboSpan" id="kobo.5812.1"> operator. </span><span class="koboSpan" id="kobo.5812.2">There are three functions required by this concept. </span><span class="koboSpan" id="kobo.5812.3">These can be either free functions or class member functions. </span><span class="koboSpan" id="kobo.5812.4">They are listed in the following table:</span></p>
<table class="table-container" id="table004-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5813.1">await_ready()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5814.1">Indicates whether the result is ready. </span><span class="koboSpan" id="kobo.5814.2">If the return value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5815.1">false</span></code><span class="koboSpan" id="kobo.5816.1"> (or a value convertible to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5817.1">false</span></code><span class="koboSpan" id="kobo.5818.1">), then </span><code class="inlineCode"><span class="koboSpan" id="kobo.5819.1">await_suspend()</span></code><span class="koboSpan" id="kobo.5820.1"> is called.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5821.1">await_suspend()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5822.1">Schedules the coroutine to resume or to be destroyed.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5823.1">await_resume()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5824.1">Provides the result for the entire </span><code class="inlineCode"><span class="koboSpan" id="kobo.5825.1">co_await e</span></code><span class="koboSpan" id="kobo.5826.1"> expression.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5827.1">Table 12.4: Functions that the awaitable concepts require</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5828.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5829.1">task&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5830.1"> type we built in this</span><a id="_idIndexMarker1559"/><span class="koboSpan" id="kobo.5831.1"> recipe has several members:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5832.1">An explicit constructor that takes an argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5833.1">std::coroutine_handle&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5834.1"> type, representing a non-owning handle to the coroutine.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5835.1">A destructor that destroys the coroutine frame.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5836.1">A move constructor and move assignment operator.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5837.1">A deleted copy constructor and copy assignment operator, making the class moveable-only.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5838.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5839.1">co_await</span></code><span class="koboSpan" id="kobo.5840.1"> operator, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5841.1">task_awaiter</span></code><span class="koboSpan" id="kobo.5842.1"> value that implements the awaitable concept.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5843.1">is_ready()</span></code><span class="koboSpan" id="kobo.5844.1">, a method that returns a Boolean value indicating whether the coroutine value is ready.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5845.1">resume()</span></code><span class="koboSpan" id="kobo.5846.1">, a method that resumes the execution of the coroutine.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5847.1">value()</span></code><span class="koboSpan" id="kobo.5848.1">, a method that returns the value held by the promise object.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5849.1">An inner promise type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5850.1">promise_type</span></code><span class="koboSpan" id="kobo.5851.1"> (this name is mandatory).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5852.1">If an exception </span><a id="_idIndexMarker1560"/><span class="koboSpan" id="kobo.5853.1">occurs during the execution of the coroutine, and this exception leaves the coroutine without being handled, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5854.1">unhandled_exception()</span></code><span class="koboSpan" id="kobo.5855.1"> method of the promise is invoked. </span><span class="koboSpan" id="kobo.5855.2">In this simple implementation, this situation is not handled, and the program is abnormally terminated with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5856.1">std::terminate()</span></code><span class="koboSpan" id="kobo.5857.1">. </span><span class="koboSpan" id="kobo.5857.2">In the following recipe, we will see an awaitable implementation that handles exceptions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5858.1">Let’s take the following coroutine as an example to see how the compiler handles it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5859.1">task&lt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5860.1">print_answer</span></span><span class="koboSpan" id="kobo.5861.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5862.1">auto</span></span><span class="koboSpan" id="kobo.5863.1"> t = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5864.1">co_await</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5865.1">get_answer</span></span><span class="koboSpan" id="kobo.5866.1">();
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5867.1">"the answer is "</span></span><span class="koboSpan" id="kobo.5868.1"> &lt;&lt; t &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5869.1">'\n'</span></span><span class="koboSpan" id="kobo.5870.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5871.1">Because of all the mechanisms we built in this recipe, the compiler transforms this code into the following (this snippet is pseudocode):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5872.1">task&lt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5873.1">print_answer</span></span><span class="koboSpan" id="kobo.5874.1">()
{
  __frame* context;
  task&lt;&gt;::task_awaiter t = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5875.1">operator</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5876.1">co_await</span></span><span class="koboSpan" id="kobo.5877.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5878.1">get_answer</span></span><span class="koboSpan" id="kobo.5879.1">());
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5880.1">if</span></span><span class="koboSpan" id="kobo.5881.1">(!t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5882.1">await_ready</span></span><span class="koboSpan" id="kobo.5883.1">())
  {
    coroutine_handle&lt;&gt; resume_co =
      coroutine_handle&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5884.1">from_address</span></span><span class="koboSpan" id="kobo.5885.1">(context);
    y.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5886.1">await_suspend</span></span><span class="koboSpan" id="kobo.5887.1">(resume_co);
    __suspend_resume_point_1:
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5888.1">auto</span></span><span class="koboSpan" id="kobo.5889.1"> value = t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5890.1">await_resume</span></span><span class="koboSpan" id="kobo.5891.1">();
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5892.1">"the answer is "</span></span><span class="koboSpan" id="kobo.5893.1"> &lt;&lt; value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5894.1">'\n'</span></span><span class="koboSpan" id="kobo.5895.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5896.1">As mentioned earlier, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5897.1">main()</span></code><span class="koboSpan" id="kobo.5898.1"> function is one of the functions that cannot be a coroutine. </span><span class="koboSpan" id="kobo.5898.2">For this reason, it is not possible to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5899.1">co_await</span></code><span class="koboSpan" id="kobo.5900.1"> operator in </span><code class="inlineCode"><span class="koboSpan" id="kobo.5901.1">main()</span></code><span class="koboSpan" id="kobo.5902.1">. </span><span class="koboSpan" id="kobo.5902.2">This means that waiting for a coroutine to complete must be done differently in </span><code class="inlineCode"><span class="koboSpan" id="kobo.5903.1">main()</span></code><span class="koboSpan" id="kobo.5904.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5905.1">This is handled with the help of a function template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5906.1">execute()</span></code><span class="koboSpan" id="kobo.5907.1"> that runs the following loop:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5908.1">while</span></span><span class="koboSpan" id="kobo.5909.1"> (!t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5910.1">is_ready</span></span><span class="koboSpan" id="kobo.5911.1">()) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5912.1">resume</span></span><span class="koboSpan" id="kobo.5913.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5914.1">This loop ensures</span><a id="_idIndexMarker1561"/><span class="koboSpan" id="kobo.5915.1"> that the coroutine is resumed after each suspension point, until its final completion.</span></p>
<h2 class="heading-2" id="_idParaDest-810"><span class="koboSpan" id="kobo.5916.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5917.1">The C++20 standard does not provide any coroutine types, and writing your own is a cumbersome task. </span><span class="koboSpan" id="kobo.5917.2">Fortunately, third-party libraries can offer these abstractions. </span><span class="koboSpan" id="kobo.5917.3">Such a library is </span><strong class="keyWord"><span class="koboSpan" id="kobo.5918.1">libcoro</span></strong><span class="koboSpan" id="kobo.5919.1">, an </span><a id="_idIndexMarker1562"/><span class="koboSpan" id="kobo.5920.1">open-source experimental library that provides a set of general-purpose primitives to make use of the coroutines described in the C++20 standard. </span><span class="koboSpan" id="kobo.5920.2">The library is</span><a id="_idIndexMarker1563"/><span class="koboSpan" id="kobo.5921.1"> available at </span><a href="https://github.com/jbaldwin/libcoro"><span class="url"><span class="koboSpan" id="kobo.5922.1">https://github.com/jbaldwin/libcoro</span></span></a><span class="koboSpan" id="kobo.5923.1">. </span><span class="koboSpan" id="kobo.5923.2">Among the components it provides is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5924.1">task&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5925.1"> coroutine type, similar to what we built in this recipe. </span><span class="koboSpan" id="kobo.5925.2">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5926.1">coro::task&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5927.1"> type, we can rewrite our examples as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.5928.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5929.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5930.1">&lt;iostream&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.5931.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5932.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5933.1">&lt;coro/task.hpp&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.5934.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5935.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.5936.1">&lt;coro/sync_wait.hpp&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.5937.1">coro::task&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5938.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5939.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5940.1">get_answer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5941.1">()</span></span><span class="koboSpan" id="kobo.5942.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5943.1">co_return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.5944.1">42</span></span><span class="koboSpan" id="kobo.5945.1">;
}
coro::task&lt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5946.1">print_answer</span></span><span class="koboSpan" id="kobo.5947.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5948.1">auto</span></span><span class="koboSpan" id="kobo.5949.1"> t = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5950.1">co_await</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5951.1">get_answer</span></span><span class="koboSpan" id="kobo.5952.1">();
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5953.1">"the answer is "</span></span><span class="koboSpan" id="kobo.5954.1"> &lt;&lt; t &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5955.1">'\n'</span></span><span class="koboSpan" id="kobo.5956.1">;
}
coro::task&lt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5957.1">demo</span></span><span class="koboSpan" id="kobo.5958.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5959.1">auto</span></span><span class="koboSpan" id="kobo.5960.1"> t = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5961.1">co_await</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5962.1">get_answer</span></span><span class="koboSpan" id="kobo.5963.1">();
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5964.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5965.1">the answer is "</span></span><span class="koboSpan" id="kobo.5966.1"> &lt;&lt; t &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5967.1">'\n'</span></span><span class="koboSpan" id="kobo.5968.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5969.1">co_await</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5970.1">print_answer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5971.1">()</span></span><span class="koboSpan" id="kobo.5972.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5973.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5974.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5975.1">()</span></span><span class="koboSpan" id="kobo.5976.1">
{
   coro::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5977.1">sync_wait</span></span><span class="koboSpan" id="kobo.5978.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5979.1">demo</span></span><span class="koboSpan" id="kobo.5980.1">());
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5981.1">As you can see, the code is very similar to what we wrote in the first part of this recipe. </span><span class="koboSpan" id="kobo.5981.2">The changes are minimal. </span><span class="koboSpan" id="kobo.5981.3">By using</span><a id="_idIndexMarker1564"/><span class="koboSpan" id="kobo.5982.1"> this </span><strong class="keyWord"><span class="koboSpan" id="kobo.5983.1">libcoro</span></strong><span class="koboSpan" id="kobo.5984.1"> library or others that are similar, you do not need to be concerned with the details of implementing coroutine types and instead focus on their use.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.5985.1">Another library that was used in the second edition of the book was </span><strong class="keyWord"><span class="koboSpan" id="kobo.5986.1">cppcoro</span></strong><span class="koboSpan" id="kobo.5987.1">, which is available at </span><a href="https://github.com/lewissbaker/cppcoro"><span class="url"><span class="koboSpan" id="kobo.5988.1">https://github.com/lewissbaker/cppcoro</span></span></a><span class="koboSpan" id="kobo.5989.1">. </span><span class="koboSpan" id="kobo.5989.2">However, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.5990.1">cppcoro</span></strong><span class="koboSpan" id="kobo.5991.1"> library has not been maintained for several years. </span><span class="koboSpan" id="kobo.5991.2">Although it’s still available on</span><a id="_idIndexMarker1565"/><span class="koboSpan" id="kobo.5992.1"> GitHub, it relies on the experimental implementation of technical specifications for coroutines. </span><span class="koboSpan" id="kobo.5992.2">For instance, when using MSVC, this requires the use of the now obsolete </span><code class="inlineCode"><span class="koboSpan" id="kobo.5993.1">/await</span></code><span class="koboSpan" id="kobo.5994.1"> compiler flag. </span><span class="koboSpan" id="kobo.5994.2">You should only use this library as a source of inspiration to write coroutine primitives, such as the one we will see in the next recipe.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-811"><span class="koboSpan" id="kobo.5995.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5996.1">Creating a coroutine generator type for sequences of values</span></em><span class="koboSpan" id="kobo.5997.1">, to learn how to enable the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5998.1">co_yield</span></code><span class="koboSpan" id="kobo.5999.1"> to return multiple values from a coroutine</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-812"><span class="koboSpan" id="kobo.6000.1">Creating a coroutine generator type for sequences of values</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6001.1">In the previous recipe, we saw</span><a id="_idIndexMarker1566"/><span class="koboSpan" id="kobo.6002.1"> how to create a coroutine task that enables asynchronous computations. </span><span class="koboSpan" id="kobo.6002.2">We used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6003.1">co_await</span></code><span class="koboSpan" id="kobo.6004.1"> operator to suspend execution until resumed and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6005.1">co_return</span></code><span class="koboSpan" id="kobo.6006.1"> keyword to complete execution and return a value. </span><span class="koboSpan" id="kobo.6006.2">However, another keyword, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6007.1">co_yield</span></code><span class="koboSpan" id="kobo.6008.1">, also defines a function as a coroutine. </span><span class="koboSpan" id="kobo.6008.2">It suspends the execution of the coroutine and returns a value. </span><span class="koboSpan" id="kobo.6008.3">It enables a coroutine to return multiple values, one each time it is resumed. </span><span class="koboSpan" id="kobo.6008.4">To support this feature, another type of coroutine is required. </span><span class="koboSpan" id="kobo.6008.5">This type is called a </span><em class="italic"><span class="koboSpan" id="kobo.6009.1">generator</span></em><span class="koboSpan" id="kobo.6010.1">. </span><span class="koboSpan" id="kobo.6010.2">Conceptually, it’s like a stream that produces a sequence of values of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6011.1">T</span></code><span class="koboSpan" id="kobo.6012.1"> in a lazy manner (when iterated). </span><span class="koboSpan" id="kobo.6012.2">In this recipe, we will see how we can implement a simple generator.</span></p>
<h2 class="heading-2" id="_idParaDest-813"><span class="koboSpan" id="kobo.6013.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6014.1">The goal of this </span><a id="_idIndexMarker1567"/><span class="koboSpan" id="kobo.6015.1">recipe is to create a generator coroutine type that enables us to write code like the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.6016.1">generator&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6017.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6018.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6019.1">iota</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6020.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6021.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6022.1"> start = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.6023.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6024.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6025.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6026.1"> step = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.6027.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6028.1">)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6029.1">noexcept</span></span><span class="koboSpan" id="kobo.6030.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6031.1">auto</span></span><span class="koboSpan" id="kobo.6032.1"> value = start;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6033.1">for</span></span><span class="koboSpan" id="kobo.6034.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.6035.1">int</span></span><span class="koboSpan" id="kobo.6036.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6037.1">0</span></span><span class="koboSpan" id="kobo.6038.1">;; ++i)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6039.1">co_yield</span></span><span class="koboSpan" id="kobo.6040.1"> value;
    value += step;
  }
}
generator&lt;std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6041.1">int</span></span><span class="koboSpan" id="kobo.6042.1">&gt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6043.1">iota_n</span></span><span class="koboSpan" id="kobo.6044.1">(
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6045.1">int</span></span><span class="koboSpan" id="kobo.6046.1"> start = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6047.1">0</span></span><span class="koboSpan" id="kobo.6048.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.6049.1">int</span></span><span class="koboSpan" id="kobo.6050.1"> step = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6051.1">1</span></span><span class="koboSpan" id="kobo.6052.1">,
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6053.1">int</span></span><span class="koboSpan" id="kobo.6054.1"> n = std::numeric_limits&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6055.1">int</span></span><span class="koboSpan" id="kobo.6056.1">&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6057.1">max</span></span><span class="koboSpan" id="kobo.6058.1">()) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6059.1">noexcept</span></span><span class="koboSpan" id="kobo.6060.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6061.1">auto</span></span><span class="koboSpan" id="kobo.6062.1"> value = start;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6063.1">for</span></span><span class="koboSpan" id="kobo.6064.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.6065.1">int</span></span><span class="koboSpan" id="kobo.6066.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6067.1">0</span></span><span class="koboSpan" id="kobo.6068.1">; i &lt; n; ++i)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6069.1">co_yield</span></span><span class="koboSpan" id="kobo.6070.1"> value;
    value += step;
  }
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.6071.1">generator&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6072.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6073.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6074.1">fibonacci</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6075.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6076.1">noexcept</span></span><span class="koboSpan" id="kobo.6077.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6078.1">int</span></span><span class="koboSpan" id="kobo.6079.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6080.1">0</span></span><span class="koboSpan" id="kobo.6081.1">, b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6082.1">1</span></span><span class="koboSpan" id="kobo.6083.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6084.1">while</span></span><span class="koboSpan" id="kobo.6085.1"> (</span><span class="hljs-literal"><span class="koboSpan" id="kobo.6086.1">true</span></span><span class="koboSpan" id="kobo.6087.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6088.1">co_yield</span></span><span class="koboSpan" id="kobo.6089.1"> b;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6090.1">auto</span></span><span class="koboSpan" id="kobo.6091.1"> tmp = a;
    a = b;
    b += tmp;
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.6092.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6093.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6094.1">()</span></span><span class="koboSpan" id="kobo.6095.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6096.1">for</span></span><span class="koboSpan" id="kobo.6097.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6098.1">auto</span></span><span class="koboSpan" id="kobo.6099.1"> i : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6100.1">iota</span></span><span class="koboSpan" id="kobo.6101.1">())
  {
    std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6102.1">' '</span></span><span class="koboSpan" id="kobo.6103.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6104.1">if</span></span><span class="koboSpan" id="kobo.6105.1"> (i &gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.6106.1">10</span></span><span class="koboSpan" id="kobo.6107.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6108.1">break</span></span><span class="koboSpan" id="kobo.6109.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6110.1">for</span></span><span class="koboSpan" id="kobo.6111.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6112.1">auto</span></span><span class="koboSpan" id="kobo.6113.1"> i : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6114.1">iota_n</span></span><span class="koboSpan" id="kobo.6115.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.6116.1">0</span></span><span class="koboSpan" id="kobo.6117.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6118.1">1</span></span><span class="koboSpan" id="kobo.6119.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.6120.1">10</span></span><span class="koboSpan" id="kobo.6121.1">))
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6122.1">if</span></span><span class="koboSpan" id="kobo.6123.1"> (!i.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6124.1">has_value</span></span><span class="koboSpan" id="kobo.6125.1">()) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6126.1">break</span></span><span class="koboSpan" id="kobo.6127.1">;
    std::cout &lt;&lt; i.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6128.1">value</span></span><span class="koboSpan" id="kobo.6129.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6130.1">' '</span></span><span class="koboSpan" id="kobo.6131.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6132.1">int</span></span><span class="koboSpan" id="kobo.6133.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6134.1">1</span></span><span class="koboSpan" id="kobo.6135.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6136.1">for</span></span><span class="koboSpan" id="kobo.6137.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6138.1">auto</span></span><span class="koboSpan" id="kobo.6139.1"> i : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6140.1">fibonacci</span></span><span class="koboSpan" id="kobo.6141.1">())
  {
    std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6142.1">' '</span></span><span class="koboSpan" id="kobo.6143.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6144.1">if</span></span><span class="koboSpan" id="kobo.6145.1"> (++c &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.6146.1">10</span></span><span class="koboSpan" id="kobo.6147.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6148.1">break</span></span><span class="koboSpan" id="kobo.6149.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6150.1">It is recommended that you follow the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.6151.1">Creating a coroutine task type for asynchronous computations</span></em><span class="koboSpan" id="kobo.6152.1">, before you continue with this one.</span></p>
<h2 class="heading-2" id="_idParaDest-814"><span class="koboSpan" id="kobo.6153.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6154.1">To create a </span><a id="_idIndexMarker1568"/><span class="koboSpan" id="kobo.6155.1">generator coroutine type that supports synchronous lazy production of a sequence of values, you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6156.1">Create a class template, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6157.1">generator</span></code><span class="koboSpan" id="kobo.6158.1">, with the following content (the details of each part are presented in the following bullet points):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6159.1">template</span></span><span class="koboSpan" id="kobo.6160.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6161.1">typename</span></span><span class="koboSpan" id="kobo.6162.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6163.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6164.1">generator</span></span><span class="koboSpan" id="kobo.6165.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.6166.1">// struct promise_type</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.6167.1">// struct iterator</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.6168.1">// member functions</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.6169.1">// iterators</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.6170.1">private</span></span><span class="koboSpan" id="kobo.6171.1">:
   std::coroutine_handle&lt;promise_type&gt; handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6172.1">nullptr</span></span><span class="koboSpan" id="kobo.6173.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6174.1">Create an</span><a id="_idIndexMarker1569"/><span class="koboSpan" id="kobo.6175.1"> inner class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6176.1">promise_type</span></code><span class="koboSpan" id="kobo.6177.1"> (the name is mandatory) with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6178.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6179.1">promise_type</span></span><span class="koboSpan" id="kobo.6180.1">
{
  T </span><span class="hljs-type"><span class="koboSpan" id="kobo.6181.1">const</span></span><span class="koboSpan" id="kobo.6182.1">*             value_;
  std::exception_ptr   eptr_;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6183.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6184.1">get_return_object</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6185.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6186.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6187.1">return</span></span><span class="koboSpan" id="kobo.6188.1"> generator{ *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6189.1">this</span></span><span class="koboSpan" id="kobo.6190.1"> }; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6191.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6192.1">initial_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6193.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6194.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6195.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6196.1">return</span></span><span class="koboSpan" id="kobo.6197.1"> std::suspend_always{}; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6198.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6199.1">final_suspend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6200.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6201.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6202.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6203.1">return</span></span><span class="koboSpan" id="kobo.6204.1"> std::suspend_always{}; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6205.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6206.1">unhandled_exception</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6207.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6208.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6209.1">{
     eptr_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6210.1">current_exception</span></span><span class="koboSpan" id="kobo.6211.1">();
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6212.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6213.1">rethrow_if_exception</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6214.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6215.1">{
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6216.1">if</span></span><span class="koboSpan" id="kobo.6217.1"> (eptr_)
     {
        std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6218.1">rethrow_exception</span></span><span class="koboSpan" id="kobo.6219.1">(eptr_);
     }
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6220.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6221.1">yield_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6222.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6223.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6224.1">&amp; v)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6225.1">{
     value_ = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6226.1">addressof</span></span><span class="koboSpan" id="kobo.6227.1">(v);
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6228.1">return</span></span><span class="koboSpan" id="kobo.6229.1"> std::suspend_always{};
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6230.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6231.1">return_void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6232.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.6233.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6234.1">template</span></span><span class="koboSpan" id="kobo.6235.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6236.1">typename</span></span><span class="koboSpan" id="kobo.6237.1"> U&gt;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.6238.1">U&amp;&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6239.1">await_transform</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6240.1">(U&amp;&amp; v)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.6241.1">{
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6242.1">return</span></span><span class="koboSpan" id="kobo.6243.1"> std::forward&lt;U&gt;(v);
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6244.1">Create an </span><a id="_idIndexMarker1570"/><span class="koboSpan" id="kobo.6245.1">inner class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6246.1">iterator</span></code><span class="koboSpan" id="kobo.6247.1"> with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6248.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6249.1">iterator</span></span><span class="koboSpan" id="kobo.6250.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6251.1">using</span></span><span class="koboSpan" id="kobo.6252.1"> iterator_category = std::input_iterator_tag;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6253.1">using</span></span><span class="koboSpan" id="kobo.6254.1"> difference_type   = </span><span class="hljs-type"><span class="koboSpan" id="kobo.6255.1">ptrdiff_t</span></span><span class="koboSpan" id="kobo.6256.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6257.1">using</span></span><span class="koboSpan" id="kobo.6258.1"> value_type        = T;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6259.1">using</span></span><span class="koboSpan" id="kobo.6260.1"> reference         = T </span><span class="hljs-type"><span class="koboSpan" id="kobo.6261.1">const</span></span><span class="koboSpan" id="kobo.6262.1">&amp;;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6263.1">using</span></span><span class="koboSpan" id="kobo.6264.1"> pointer           = T </span><span class="hljs-type"><span class="koboSpan" id="kobo.6265.1">const</span></span><span class="koboSpan" id="kobo.6266.1">*;
  std::coroutine_handle&lt;promise_type&gt; handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6267.1">nullptr</span></span><span class="koboSpan" id="kobo.6268.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6269.1">iterator</span></span><span class="koboSpan" id="kobo.6270.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6271.1">default</span></span><span class="koboSpan" id="kobo.6272.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6273.1">iterator</span></span><span class="koboSpan" id="kobo.6274.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.6275.1">nullptr_t</span></span><span class="koboSpan" id="kobo.6276.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6277.1">handle_</span></span><span class="koboSpan" id="kobo.6278.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.6279.1">nullptr</span></span><span class="koboSpan" id="kobo.6280.1">) {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6281.1">iterator</span></span><span class="koboSpan" id="kobo.6282.1">(std::coroutine_handle&lt;promise_type&gt; arg)
    : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6283.1">handle_</span></span><span class="koboSpan" id="kobo.6284.1">(arg)
  {}
  iterator&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6285.1">operator</span></span><span class="koboSpan" id="kobo.6286.1">++()
  {
     handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6287.1">resume</span></span><span class="koboSpan" id="kobo.6288.1">();
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6289.1">if</span></span><span class="koboSpan" id="kobo.6290.1"> (handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6291.1">done</span></span><span class="koboSpan" id="kobo.6292.1">())
     {
        std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6293.1">exchange</span></span><span class="koboSpan" id="kobo.6294.1">(handle_, {}).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6295.1">promise</span></span><span class="koboSpan" id="kobo.6296.1">()
                                  .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6297.1">rethrow_if_exception</span></span><span class="koboSpan" id="kobo.6298.1">();
     }
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6299.1">return</span></span><span class="koboSpan" id="kobo.6300.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6301.1">this</span></span><span class="koboSpan" id="kobo.6302.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6303.1">void</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.6304.1">operator</span></span><span class="koboSpan" id="kobo.6305.1">++(</span><span class="hljs-type"><span class="koboSpan" id="kobo.6306.1">int</span></span><span class="koboSpan" id="kobo.6307.1">)
  {
     ++*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6308.1">this</span></span><span class="koboSpan" id="kobo.6309.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6310.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.6311.1">operator</span></span><span class="koboSpan" id="kobo.6312.1">==(iterator </span><span class="hljs-type"><span class="koboSpan" id="kobo.6313.1">const</span></span><span class="koboSpan" id="kobo.6314.1">&amp; _Right) </span><span class="hljs-type"><span class="koboSpan" id="kobo.6315.1">const</span></span><span class="koboSpan" id="kobo.6316.1">
  {
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6317.1">return</span></span><span class="koboSpan" id="kobo.6318.1"> handle_ == _Right.handle_;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6319.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.6320.1">operator</span></span><span class="koboSpan" id="kobo.6321.1">!=(iterator </span><span class="hljs-type"><span class="koboSpan" id="kobo.6322.1">const</span></span><span class="koboSpan" id="kobo.6323.1">&amp; _Right) </span><span class="hljs-type"><span class="koboSpan" id="kobo.6324.1">const</span></span><span class="koboSpan" id="kobo.6325.1">
  {
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6326.1">return</span></span><span class="koboSpan" id="kobo.6327.1"> !(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6328.1">this</span></span><span class="koboSpan" id="kobo.6329.1"> == _Right);
  }
  reference </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6330.1">operator</span></span><span class="koboSpan" id="kobo.6331.1">*() </span><span class="hljs-type"><span class="koboSpan" id="kobo.6332.1">const</span></span><span class="koboSpan" id="kobo.6333.1">
  {
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6334.1">return</span></span><span class="koboSpan" id="kobo.6335.1"> *handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6336.1">promise</span></span><span class="koboSpan" id="kobo.6337.1">().value_;
  }
  pointer </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6338.1">operator</span></span><span class="koboSpan" id="kobo.6339.1">-&gt;() </span><span class="hljs-type"><span class="koboSpan" id="kobo.6340.1">const</span></span><span class="koboSpan" id="kobo.6341.1">
  {
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6342.1">return</span></span><span class="koboSpan" id="kobo.6343.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6344.1">addressof</span></span><span class="koboSpan" id="kobo.6345.1">(handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6346.1">promise</span></span><span class="koboSpan" id="kobo.6347.1">().value_);
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6348.1">Provide a</span><a id="_idIndexMarker1571"/><span class="koboSpan" id="kobo.6349.1"> default constructor, an explicit constructor from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6350.1">promise_type</span></code><span class="koboSpan" id="kobo.6351.1"> object, a move constructor and a move assignment operator, and a destructor. </span><span class="koboSpan" id="kobo.6351.2">Delete the copy constructor and copy assignment operator so that the type is moveable only:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6352.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6353.1">generator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6354.1">(promise_type&amp; p)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.6355.1">  : handle_(</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.6356.1">      std::coroutine_handle&lt;promise_type&gt;::from_promise(p))</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.6357.1">{</span></span><span class="koboSpan" id="kobo.6358.1">}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6359.1">generator</span></span><span class="koboSpan" id="kobo.6360.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6361.1">default</span></span><span class="koboSpan" id="kobo.6362.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6363.1">generator</span></span><span class="koboSpan" id="kobo.6364.1">(generator </span><span class="hljs-type"><span class="koboSpan" id="kobo.6365.1">const</span></span><span class="koboSpan" id="kobo.6366.1">&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6367.1">delete</span></span><span class="koboSpan" id="kobo.6368.1">;
generator&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6369.1">operator</span></span><span class="koboSpan" id="kobo.6370.1">=(generator </span><span class="hljs-type"><span class="koboSpan" id="kobo.6371.1">const</span></span><span class="koboSpan" id="kobo.6372.1">&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6373.1">delete</span></span><span class="koboSpan" id="kobo.6374.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6375.1">generator</span></span><span class="koboSpan" id="kobo.6376.1">(generator&amp;&amp; other) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6377.1">handle_</span></span><span class="koboSpan" id="kobo.6378.1">(other.handle_)
{
  other.handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6379.1">nullptr</span></span><span class="koboSpan" id="kobo.6380.1">;
}
generator&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6381.1">operator</span></span><span class="koboSpan" id="kobo.6382.1">=(generator&amp;&amp; other)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6383.1">if</span></span><span class="koboSpan" id="kobo.6384.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6385.1">this</span></span><span class="koboSpan" id="kobo.6386.1"> != std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6387.1">addressof</span></span><span class="koboSpan" id="kobo.6388.1">(other))
  {
     handle_ = other.handle_;
     other.handle_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6389.1">nullptr</span></span><span class="koboSpan" id="kobo.6390.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6391.1">return</span></span><span class="koboSpan" id="kobo.6392.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6393.1">this</span></span><span class="koboSpan" id="kobo.6394.1">;
}
~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6395.1">generator</span></span><span class="koboSpan" id="kobo.6396.1">()
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6397.1">if</span></span><span class="koboSpan" id="kobo.6398.1"> (handle_)
  {
     handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6399.1">destroy</span></span><span class="koboSpan" id="kobo.6400.1">();
  }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6401.1">Provide</span><a id="_idIndexMarker1572"/><span class="koboSpan" id="kobo.6402.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6403.1">begin()</span></code><span class="koboSpan" id="kobo.6404.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6405.1">end()</span></code><span class="koboSpan" id="kobo.6406.1"> functions to enable iteration over the generator sequence:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.6407.1">iterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6408.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6409.1">()</span></span><span class="koboSpan" id="kobo.6410.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6411.1">if</span></span><span class="koboSpan" id="kobo.6412.1"> (handle_)
  {
     handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6413.1">resume</span></span><span class="koboSpan" id="kobo.6414.1">();
     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6415.1">if</span></span><span class="koboSpan" id="kobo.6416.1"> (handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6417.1">done</span></span><span class="koboSpan" id="kobo.6418.1">())
     {
        handle_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6419.1">promise</span></span><span class="koboSpan" id="kobo.6420.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6421.1">rethrow_if_exception</span></span><span class="koboSpan" id="kobo.6422.1">();
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6423.1">return</span></span><span class="koboSpan" id="kobo.6424.1"> { </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6425.1">nullptr</span></span><span class="koboSpan" id="kobo.6426.1"> };
     }
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6427.1">return</span></span><span class="koboSpan" id="kobo.6428.1"> { handle_ };
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.6429.1">iterator </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6430.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6431.1">()</span></span><span class="koboSpan" id="kobo.6432.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6433.1">return</span></span><span class="koboSpan" id="kobo.6434.1"> { </span><span class="hljs-literal"><span class="koboSpan" id="kobo.6435.1">nullptr</span></span><span class="koboSpan" id="kobo.6436.1"> };
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-815"><span class="koboSpan" id="kobo.6437.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6438.1">The promise type implemented in this recipe is similar to the one from the previous recipe, although there are some differences:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6439.1">It is implemented as an inner type, so the name is </span><code class="inlineCode"><span class="koboSpan" id="kobo.6440.1">promise_type</span></code><span class="koboSpan" id="kobo.6441.1">, since the coroutine framework requires the coroutine type to have an inner promise type with this name.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6442.1">It supports handling exceptions that leave the coroutine block uncaught. </span><span class="koboSpan" id="kobo.6442.2">In the previous recipe, this situation was not treated, and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6443.1">unhandled_exception()</span></code><span class="koboSpan" id="kobo.6444.1"> called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6445.1">std::terminate()</span></code><span class="koboSpan" id="kobo.6446.1"> to abnormally terminate the process. </span><span class="koboSpan" id="kobo.6446.2">This implementation, however, retries a pointer to the current exception and stores it in an </span><code class="inlineCode"><span class="koboSpan" id="kobo.6447.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.6448.1"> object. </span><span class="koboSpan" id="kobo.6448.2">This exception is rethrown when iterating through the generated sequence (either when calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6449.1">begin()</span></code><span class="koboSpan" id="kobo.6450.1"> or when incrementing the iterator).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6451.1">The functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.6452.1">return_value()</span></code><span class="koboSpan" id="kobo.6453.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6454.1">return_void()</span></code><span class="koboSpan" id="kobo.6455.1"> are not present, but replaced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6456.1">yield_value()</span></code><span class="koboSpan" id="kobo.6457.1">, which is called when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6458.1">co_yield expr</span></code><span class="koboSpan" id="kobo.6459.1"> expression is resolved.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6460.1">The generator</span><a id="_idIndexMarker1573"/><span class="koboSpan" id="kobo.6461.1"> class also bears some similarities to the task class from the previous recipe:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6462.1">It is default-constructible</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6463.1">It can be constructed from a promise object</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6464.1">It is not copy-constructible and copyable</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6465.1">It is move-constructible and moveable</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6466.1">Its destructor destroys the coroutine frame</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6467.1">This class does not overload the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6468.1">co_await</span></code><span class="koboSpan" id="kobo.6469.1"> operator, as it does not make sense to wait on the generator; instead, it provides the functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.6470.1">begin()</span></code><span class="koboSpan" id="kobo.6471.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6472.1">end()</span></code><span class="koboSpan" id="kobo.6473.1">, which return iterator objects that enable iterating over the sequence of values. </span><span class="koboSpan" id="kobo.6473.2">This generator is said to be lazy because it does not produce new values until the coroutine is resumed, either by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.6474.1">begin()</span></code><span class="koboSpan" id="kobo.6475.1"> or incrementing an iterator. </span><span class="koboSpan" id="kobo.6475.2">The coroutine is created suspended, and its first execution begins only when calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6476.1">begin()</span></code><span class="koboSpan" id="kobo.6477.1"> function. </span><span class="koboSpan" id="kobo.6477.2">The execution continues either until the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.6478.1">co_yield</span></code><span class="koboSpan" id="kobo.6479.1"> statement or until the coroutine completes its execution. </span><span class="koboSpan" id="kobo.6479.2">Similarly, incrementing the iterator will resume the execution of the coroutine, which continues either until the next </span><code class="inlineCode"><span class="koboSpan" id="kobo.6480.1">co_yield</span></code><span class="koboSpan" id="kobo.6481.1"> statement or until its completion.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6482.1">The following example shows a coroutine that produces several integer values. </span><span class="koboSpan" id="kobo.6482.2">It does so not by using a loop but by repeating </span><code class="inlineCode"><span class="koboSpan" id="kobo.6483.1">co_yield</span></code><span class="koboSpan" id="kobo.6484.1"> statements:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.6485.1">generator&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6486.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6487.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6488.1">get_values</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6489.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6490.1">noexcept</span></span><span class="koboSpan" id="kobo.6491.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6492.1">co_yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.6493.1">1</span></span><span class="koboSpan" id="kobo.6494.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6495.1">co_yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.6496.1">2</span></span><span class="koboSpan" id="kobo.6497.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6498.1">co_yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.6499.1">3</span></span><span class="koboSpan" id="kobo.6500.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.6501.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6502.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6503.1">()</span></span><span class="koboSpan" id="kobo.6504.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6505.1">for</span></span><span class="koboSpan" id="kobo.6506.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6507.1">auto</span></span><span class="koboSpan" id="kobo.6508.1"> i : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6509.1">get_values</span></span><span class="koboSpan" id="kobo.6510.1">())
  {
    std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6511.1">' '</span></span><span class="koboSpan" id="kobo.6512.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6513.1">An important</span><a id="_idIndexMarker1574"/><span class="koboSpan" id="kobo.6514.1"> thing to note is that the coroutine can only use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6515.1">co_yield</span></code><span class="koboSpan" id="kobo.6516.1"> keyword and produce values synchronously. </span><span class="koboSpan" id="kobo.6516.2">The use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6517.1">co_await</span></code><span class="koboSpan" id="kobo.6518.1"> operator within the coroutine is not supported with this particular implementation. </span><span class="koboSpan" id="kobo.6518.2">To be able to suspend execution by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6519.1">co_await</span></code><span class="koboSpan" id="kobo.6520.1"> operator, a different implementation is required.</span></p>
<h2 class="heading-2" id="_idParaDest-816"><span class="koboSpan" id="kobo.6521.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6522.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.6523.1">libcoro</span></strong><span class="koboSpan" id="kobo.6524.1"> library, mentioned </span><a id="_idIndexMarker1575"/><span class="koboSpan" id="kobo.6525.1">in the previous recipe, has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6526.1">generator&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6527.1"> type that can be used instead of the one we created here. </span><span class="koboSpan" id="kobo.6527.2">In fact, by replacing our </span><code class="inlineCode"><span class="koboSpan" id="kobo.6528.1">generator&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6529.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6530.1">coro::generator&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6531.1">, the snippets of code shown previously will continue to work as expected.</span></p>
<h2 class="heading-2" id="_idParaDest-817"><span class="koboSpan" id="kobo.6532.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6533.1">Creating a coroutine task type for asynchronous computations</span></em><span class="koboSpan" id="kobo.6534.1">, for an introduction to the C++20 coroutines</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-818"><span class="koboSpan" id="kobo.6535.1">Generating a sequence of values with the std::generator type</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6536.1">The C++20 standard includes two major updates to the standard library: the ranges library and coroutines. </span><span class="koboSpan" id="kobo.6536.2">However, with regard to the latter, the support is minimal. </span><span class="koboSpan" id="kobo.6536.3">The C++20 standard only defines a framework for building coroutines. </span><span class="koboSpan" id="kobo.6536.4">Because of this, libraries such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.6537.1">libcoro</span></strong><span class="koboSpan" id="kobo.6538.1">, which </span><a id="_idIndexMarker1576"/><span class="koboSpan" id="kobo.6539.1">we have previously seen, were created to provide actual coroutines, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6540.1">task</span></code><span class="koboSpan" id="kobo.6541.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6542.1">generator</span></code><span class="koboSpan" id="kobo.6543.1">, which we also saw in the previous two recipes. </span><span class="koboSpan" id="kobo.6543.2">The C++23 standard introduces the first standard coroutine, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6544.1">std::generator</span></code><span class="koboSpan" id="kobo.6545.1">. </span><span class="koboSpan" id="kobo.6545.2">This </span><a id="_idIndexMarker1577"/><span class="koboSpan" id="kobo.6546.1">brings together ranges and coroutines because </span><code class="inlineCode"><span class="koboSpan" id="kobo.6547.1">std::generator</span></code><span class="koboSpan" id="kobo.6548.1"> is a view that represents a synchronous coroutine generator. </span><span class="koboSpan" id="kobo.6548.2">This is a standard implementation for what we explicitly built in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.6549.1">Creating a coroutine generator type for sequences of values</span></em><span class="koboSpan" id="kobo.6550.1">. </span><span class="koboSpan" id="kobo.6550.2">Let’s see how it works.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.6551.1">At the time of writing, only GCC 14 supports this standard coroutine.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-819"><span class="koboSpan" id="kobo.6552.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6553.1">To generate a sequence of elements, in a lazy manner, write a coroutine that:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6554.1">Uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.6555.1">std::generator&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6556.1"> as the return type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6557.1">Uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6558.1">co_yield</span></code><span class="koboSpan" id="kobo.6559.1"> statement to return a value.</span></li>
</ul>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.6560.1">std::generator&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6561.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6562.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6563.1">iota</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6564.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6565.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6566.1"> start = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.6567.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6568.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6569.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6570.1"> step = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.6571.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6572.1">)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6573.1">noexcept</span></span><span class="koboSpan" id="kobo.6574.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6575.1">auto</span></span><span class="koboSpan" id="kobo.6576.1"> value = start;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6577.1">for</span></span><span class="koboSpan" id="kobo.6578.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.6579.1">int</span></span><span class="koboSpan" id="kobo.6580.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6581.1">0</span></span><span class="koboSpan" id="kobo.6582.1">;; ++i)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6583.1">co_yield</span></span><span class="koboSpan" id="kobo.6584.1"> value;
    value += step;
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.6585.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6586.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6587.1">()</span></span><span class="koboSpan" id="kobo.6588.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6589.1">for</span></span><span class="koboSpan" id="kobo.6590.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6591.1">auto</span></span><span class="koboSpan" id="kobo.6592.1"> i : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6593.1">iota</span></span><span class="koboSpan" id="kobo.6594.1">())
  {
    std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6595.1">' '</span></span><span class="koboSpan" id="kobo.6596.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6597.1">if</span></span><span class="koboSpan" id="kobo.6598.1"> (i &gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.6599.1">10</span></span><span class="koboSpan" id="kobo.6600.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6601.1">break</span></span><span class="koboSpan" id="kobo.6602.1">;
  }
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-820"><span class="koboSpan" id="kobo.6603.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6604.1">The new </span><code class="inlineCode"><span class="koboSpan" id="kobo.6605.1">std::generator</span></code><span class="koboSpan" id="kobo.6606.1"> class template is available in its own header, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6607.1">&lt;generator&gt;</span></code><span class="koboSpan" id="kobo.6608.1">. </span><span class="koboSpan" id="kobo.6608.2">It derives from </span><code class="inlineCode"><span class="koboSpan" id="kobo.6609.1">std::ranges::view_interface</span></code><span class="koboSpan" id="kobo.6610.1">; therefore, it is a view of elements that are yielded from the evaluation of a coroutine (an interruptible function). </span><span class="koboSpan" id="kobo.6610.2">The class is defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6611.1">template</span></span><span class="koboSpan" id="kobo.6612.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6613.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6614.1">Ref</span></span><span class="koboSpan" id="kobo.6615.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6616.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6617.1">V</span></span><span class="koboSpan" id="kobo.6618.1"> = </span><span class="hljs-type"><span class="koboSpan" id="kobo.6619.1">void</span></span><span class="koboSpan" id="kobo.6620.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6621.1">class</span></span><span class="koboSpan" id="kobo.6622.1"> Allocator = </span><span class="hljs-type"><span class="koboSpan" id="kobo.6623.1">void</span></span><span class="koboSpan" id="kobo.6624.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6625.1">class</span></span><span class="koboSpan" id="kobo.6626.1"> generator
 : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6627.1">public</span></span><span class="koboSpan" id="kobo.6628.1"> ranges::view_interface&lt;generator&lt;Ref, V, Allocator&gt;&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6629.1">Every time the</span><a id="_idIndexMarker1578"/><span class="koboSpan" id="kobo.6630.1"> coroutine is resumed and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6631.1">co_yield</span></code><span class="koboSpan" id="kobo.6632.1"> statement is evaluated, a new element of a sequence is produced. </span><span class="koboSpan" id="kobo.6632.2">The following is an example that contains a series of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6633.1">co_yield</span></code><span class="koboSpan" id="kobo.6634.1"> statements (not a loop). </span><span class="koboSpan" id="kobo.6634.2">In total, this coroutine produces three elements. </span><span class="koboSpan" id="kobo.6634.3">However, if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6635.1">get_values()</span></code><span class="koboSpan" id="kobo.6636.1"> coroutine is only evaluated once, it will only produce one element. </span><span class="koboSpan" id="kobo.6636.2">We call this a lazy evaluation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.6637.1">std::generator&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6638.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6639.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6640.1">get_values</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6641.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6642.1">noexcept</span></span><span class="koboSpan" id="kobo.6643.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6644.1">co_yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.6645.1">1</span></span><span class="koboSpan" id="kobo.6646.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6647.1">co_yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.6648.1">2</span></span><span class="koboSpan" id="kobo.6649.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6650.1">co_yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.6651.1">3</span></span><span class="koboSpan" id="kobo.6652.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6653.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6654.1">std::generator</span></code><span class="koboSpan" id="kobo.6655.1"> type is a synchronous generator; the coroutine can only use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6656.1">co_yield</span></code><span class="koboSpan" id="kobo.6657.1"> statement to return values. </span><span class="koboSpan" id="kobo.6657.2">It is not possible to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6658.1">co_await</span></code><span class="koboSpan" id="kobo.6659.1"> operator within the coroutine. </span><span class="koboSpan" id="kobo.6659.2">A different kind of generator would be required for that, and such a generator is not currently available.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6660.1">Another example of using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6661.1">std::generator</span></code><span class="koboSpan" id="kobo.6662.1"> type to produce a sequence of values is the following, which generates the series of Fibonacci numbers. </span><span class="koboSpan" id="kobo.6662.2">This is the same example that we saw in the previous recipe. </span><span class="koboSpan" id="kobo.6662.3">The only change is that we replaced </span><code class="inlineCode"><span class="koboSpan" id="kobo.6663.1">generator&lt;int&gt;</span></code><span class="koboSpan" id="kobo.6664.1"> (which we wrote) with </span><code class="inlineCode"><span class="koboSpan" id="kobo.6665.1">std::generator&lt;int&gt;</span></code><span class="koboSpan" id="kobo.6666.1">, which is available in the C++23</span><a id="_idIndexMarker1579"/><span class="koboSpan" id="kobo.6667.1"> standard:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.6668.1">std::generator&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6669.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.6670.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.6671.1">fibonacci</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6672.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6673.1">noexcept</span></span><span class="koboSpan" id="kobo.6674.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6675.1">int</span></span><span class="koboSpan" id="kobo.6676.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6677.1">0</span></span><span class="koboSpan" id="kobo.6678.1">, b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6679.1">1</span></span><span class="koboSpan" id="kobo.6680.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6681.1">while</span></span><span class="koboSpan" id="kobo.6682.1"> (</span><span class="hljs-literal"><span class="koboSpan" id="kobo.6683.1">true</span></span><span class="koboSpan" id="kobo.6684.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6685.1">co_yield</span></span><span class="koboSpan" id="kobo.6686.1"> b;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6687.1">auto</span></span><span class="koboSpan" id="kobo.6688.1"> tmp = a;
    a = b;
    b += tmp;
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.6689.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6690.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6691.1">()</span></span><span class="koboSpan" id="kobo.6692.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.6693.1">int</span></span><span class="koboSpan" id="kobo.6694.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.6695.1">1</span></span><span class="koboSpan" id="kobo.6696.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6697.1">for</span></span><span class="koboSpan" id="kobo.6698.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6699.1">auto</span></span><span class="koboSpan" id="kobo.6700.1"> i : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6701.1">fibonacci</span></span><span class="koboSpan" id="kobo.6702.1">())
  {
    std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6703.1">' '</span></span><span class="koboSpan" id="kobo.6704.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6705.1">if</span></span><span class="koboSpan" id="kobo.6706.1"> (++c &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.6707.1">10</span></span><span class="koboSpan" id="kobo.6708.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6709.1">break</span></span><span class="koboSpan" id="kobo.6710.1">;
  }
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-821"><span class="koboSpan" id="kobo.6711.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6712.1">Iterating over collections with the ranges library</span></em><span class="koboSpan" id="kobo.6713.1">, to learn about the fundamentals of the C++ ranges library</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6714.1">Creating a coroutine task type for asynchronous computations</span></em><span class="koboSpan" id="kobo.6715.1">, for an introduction to the C++20 coroutines</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6716.1">Creating a coroutine generator type for sequences of values</span></em><span class="koboSpan" id="kobo.6717.1">, to learn how to enable the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6718.1">co_yield</span></code><span class="koboSpan" id="kobo.6719.1"> to return multiple values from a coroutine</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.6720.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6721.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_12.xhtml"><span class="url"><span class="koboSpan" id="kobo.6722.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.6723.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>