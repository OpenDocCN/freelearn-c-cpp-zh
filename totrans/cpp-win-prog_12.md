# 第12章。辅助类

小型Windows包括一组辅助类，如下所示：

+   `Size`、`Point`、`Rect`、`Color`和`Font`：这些封装了Win32 API结构`SIZE`、`POINT`、`RECT`、`COLORREF`和`LOGFONT`。它们配备了与文件、剪贴板和注册表通信的方法。注册表是Windows系统中的一个数据库，我们可以用它来在应用程序执行之间存储值。

+   `Cursor`：表示Windows光标。

+   `DynamicList`：包含具有一组回调函数的动态大小列表。

+   `Tree`：包含递归树结构。

+   `InfoList`：包含可以转换到和从内存缓冲区转换的通用信息列表。

+   此外，还有一些字符串操作函数。

# `Size`类

`Size`类是一个包含宽度和高度的简单类：

**Size.h**

[PRE0]

`ZeroSize`对象是一个其宽度和高度设置为零的对象：

[PRE1]

默认构造函数将宽度和高度初始化为零。大小可以通过初始化和赋值给另一个大小来初始化。`Size`类使用赋值运算符将大小赋给另一个大小：

[PRE2]

`Size`对象可以被初始化并赋值为Win32 API `SIZE`结构体的值，并且`Size`对象可以被转换为`SIZE`：

[PRE3]

比较两个大小时，首先比较宽度。如果它们相等，然后比较高度：

[PRE4]

乘法运算符将因子乘以宽度和高度。请注意，尽管因子是双精度浮点数，但得到的宽度和高度始终被四舍五入为整数：

[PRE5]

也可以使用一对值来乘以大小，其中第一个值乘以宽度，第二个值乘以高度。此外，在这种情况下，得到的宽度和高度都是整数：

[PRE6]

第一组加法运算符将距离加到宽度和高度上：

[PRE7]

第二组加法运算符分别将宽度和高度相加和相减：

[PRE8]

大小可以被写入到文件流、剪贴板和注册表中，也可以从这些地方读取：

[PRE9]

宽度和高度通过常量方法进行检查，并通过非常量方法进行修改：

[PRE10]

`Size`类的实现相当直接：

**Size.cpp**

[PRE11]

如前所述，比较两个大小时，首先比较宽度。如果它们相等，然后比较高度：

[PRE12]

注意，如果`Min`和`Max`返回的值相等，则返回右侧的值。我们可以让它返回左侧的值。然而，由于在这种情况下`Size`对象持有的`x`和`y`值相同，并且方法返回的是对象而不是对象的引用，所以这并不重要。返回的是相同的值：

[PRE13]

如前所述，得到的宽度和高度始终被四舍五入为整数，即使因子是双精度浮点数：

[PRE14]

当将大小写入注册表时，我们将大小转换为 `SIZE` 结构，并将其发送到 `Registry` 中的 `WriteBuffer`：

[PRE15]

当从注册表中读取大小，我们将默认大小转换为 `SIZE` 结构，并将其发送到 `Registry` 中的 `ReadBuffer`。然后，结果被转换回 `Size` 对象：

[PRE16]

# 点类

`Point` 类是一个小的类，包含二维点的 *x* 和 *y* 位置：

**Point.h**

[PRE17]

默认构造函数将 *x* 和 *y* 值初始化为零。点可以通过另一个点初始化和赋值：

[PRE18]

与前面提到的 `Size` 类类似，`Point` 使用赋值运算符：

[PRE19]

与前一部分中的 `SIZE` 类似，存在一个 `POINT` Win32 API 结构。`Point` 对象可以通过 `POINT` 结构初始化和赋值，并且 `Point` 对象可以转换为 `POINT`：

[PRE20]

比较两个点时，首先比较 *x* 值。如果它们相等，然后比较 *y* 值：

[PRE21]

与前面提到的 `Size` 类类似，点的 *x* 和 *y* 值可以乘以一个因子。请注意，尽管因子是一个双精度值，但生成的 *x* 和 *y* 值始终四舍五入为整数：

[PRE22]

还可以将点与一对值相乘，其中第一个值乘以 *x* 值，第二个值乘以 *y* 值。在这种情况下，生成的 *x* 和 *y* 值也是整数：

[PRE23]

第一组加法运算符将整数距离加到点的 *x* 和 *y* 值上：

[PRE24]

第二组加法运算符将大小宽度和高度加到点的 *x* 和 *y* 值上：

[PRE25]

第三组加法运算符将点的 *x* 和 *y* 值加和减去：

[PRE26]

点可以写入、读取文件流、剪贴板和注册表：

[PRE27]

点的 *x* 和 *y* 值由常量方法检查并由非常量方法修改：

[PRE28]

`Point` 类的实现也很直接：

**Point.cpp**

[PRE29]

在赋值运算符中，一个好的习惯是验证我们不会分配相同的对象。然而，在这种情况下并不完全必要，因为我们只是分配了 *x* 和 *y* 的整数值：

[PRE30]

# Rect类

`Rect` 类包含矩形的四个边：左、上、右和下。

**Rect.h**

[PRE31]

默认构造函数将所有四个边设置为零。矩形可以通过另一个矩形初始化或赋值。也可以使用左上角和右下角以及包含矩形宽度和高度的尺寸初始化矩形：

[PRE32]

与前几节中的 `SIZE` 和 `POINT` 类似，矩形可以初始化和赋值给 Win32 API `RECT` 结构的值。`Rect` 对象也可以转换为 `RECT`：

[PRE33]

比较运算符首先比较左上角。如果它们相等，然后比较右下角：

[PRE34]

乘法运算符将所有边乘以因子。尽管因子是双精度浮点数，但边框值始终是整数，类似于前几节中的`Size`和`Point`情况：

[PRE35]

还可以将矩形与一对值相乘，其中第一个值与`left`和`right`相乘，第二个值与`top`和`bottom`相乘。此外，在这种情况下，结果值都是整数：

[PRE36]

以下运算符有点特殊：加法运算符将大小添加到右下角，同时保持左上角不变，而减法运算符从左上角减去大小，同时保持右下角不变：

[PRE37]

然而，以下运算符将大小添加到或从左上角和右下角：

[PRE38]

以下运算符接受一个点作为参数，并将该点添加到，并从左上角和右下角减去：

[PRE39]

矩形的宽度是左右边框之间的绝对差值，其高度是上下边框之间的绝对差值：

[PRE40]

`GetSize`方法返回矩形的宽度和高度。由于存在具有该名称的类，因此无法将其命名为`Size`。然而，仍然可以定义返回`Size`对象的运算符。`Size`和`Point`运算符返回矩形的尺寸和左上角：

[PRE41]

左上角和右下角都可以进行检查和修改。由于没有对应于角落的字段，因此不适当定义返回点引用的方法：

[PRE42]

`Clear`方法将所有四个角设置为0，`Normalize`方法如果左右边框和上下边框出现错误顺序，则交换左右边框和上下边框，`PointInside`方法如果点位于矩形内部，则返回`true`，假设它已经被归一化：

[PRE43]

矩形可以写入和读取文件流、剪贴板和注册表：

[PRE44]

四个角通过常量方法进行检查，并通过非常量方法进行修改：

[PRE45]

与`Size`和`Point`类似，`Rect`的实现相当直接。

**Rect.cpp**

[PRE46]

# 颜色类

`Color`类是Win32 API `COLORREF`结构的包装类，它按照红-绿-蓝（RGB）标准存储颜色。颜色的每个分量都由一个介于0到255之间的值表示，这给出了理论上的总数256³ = 16,777,216种不同的颜色，其中`Color`定义了142种标准颜色。

**Color.h**

[PRE47]

默认构造函数将红色、绿色和蓝色值初始化为零，这对应于黑色。颜色对象也可以通过另一个颜色初始化和赋值：

[PRE48]

等价运算符比较红色、绿色和蓝色值：

[PRE49]

`Inverse` 函数返回反转的颜色，而 `GrayScale` 返回相应的灰度颜色：

[PRE50]

颜色可以被写入、从文件流、剪贴板和注册表中读取：

[PRE51]

通过常量方法检查包装的 `COLORREF` 结构值，并通过非常量方法进行修改：

[PRE52]

预定义的颜色是常量对象：

[PRE53]

`Color` 的实现相当直接。Win32 的 `RGB` 宏根据三个颜色组件创建一个 `COLORREF` 值。

**Color.cpp**

[PRE54]

两个颜色相等，如果它们的包装 `COLORREF` 结构相等，并且它们通过 C 标准函数 `memcpy` 进行比较。

[PRE55]

`Inverse` 函数返回每个组件从 255 减去的反转颜色，而 `GrayScale` 返回每个组件持有红色、绿色和蓝色组件平均值的相关灰度颜色。`GetRValue`、`GetGValue` 和 `GetBValue` 是 Win32 API 宏，用于提取红色、绿色和蓝色组件：

[PRE56]

每个预定义的颜色都调用接受红色、绿色和蓝色组件的构造函数：

[PRE57]

# `Font` 类

`Font` 类是 Win32 API `LOGFONT` 结构的包装类。该结构包含大量属性；然而，我们只考虑字体名称和大小以及字体是否为斜体、粗体或下划线的字段；其他字段设置为零。系统字体是所有 `LOGFONT` 结构字段都设置为零的字体，这导致系统的标准字体。最后，`Font` 类还包括一个 `Color` 对象。

**Font.h**

[PRE58]

默认构造函数将名称设置为空字符串，并将所有其他值设置为零，从而得到系统字体，通常是 10 点 Arial。字体的大小以排版点给出（1 点 = 1/72 英寸 = 1/72 * 25.4 毫米 ≈ 0.35 毫米）。字体也可以通过另一个字体初始化或赋值：

[PRE59]

如果两个字体具有相同的名称和大小，以及相同的斜体、粗体和下划线状态（所有其他字段假定为零），则两个字体相等：

[PRE60]

字体可以被写入、从文件流、剪贴板和注册表中读取：

[PRE61]

`PointToMeters` 函数将排版点转换为逻辑单位（毫米的百分之一）：

[PRE62]

通过常量方法检查包装的 `LOGFONT` 结构，并通过非常量方法进行修改：

[PRE63]

`color` 字段也可以通过常量方法进行检查，并通过非常量方法进行修改：

[PRE64]

**Font.cpp**

[PRE65]

如果两个字体的包装 `LOGFONT` 结构和它们的 `Color` 字段相等，则两个字体相等：

[PRE66]

`write` 和 `read` 方法写入和读取包装的 `LOGFONT` 结构，并调用 `Color` 的写入和读取方法：

[PRE67]

一个排版点等于1/72英寸，一个英寸等于25.4毫米。要将字体排版单位转换为逻辑单位（毫米的百分之一），我们需要将宽度和高度除以72，乘以2,540（2,540逻辑单位等于25.4毫米）以及缩放因子：

[PRE68]

# Cursor类

Win32 API中有一组可用的光标，所有这些光标的名称都以`IDC_`开头。在小窗口中，它们被赋予了其他名称，希望这些名称更容易理解。与其他情况不同，我们不能为光标使用枚举，因为它们实际上是零终止的C++字符串（字符指针）。相反，每个光标都是一个指向零终止字符串的指针。`LPCTSTR`代表**长指针到常量TChar字符串**。

光标有自己类的原因，而光标在`Document`类中有方法，是因为光标确实需要一个窗口句柄来设置，而光标则不需要。

**Cursor.h**

[PRE69]

**Cursor.cpp**

[PRE70]

`Set`方法通过调用Win32 API函数`LoadCursor`和`SetCursor`来设置光标：

[PRE71]

# DynamicList类

`DynamicList`类可以被视为C++标准类`list`和`vector`的更高级版本。它动态地改变其大小：

**DynamicList.h**

[PRE72]

`IfFuncPtr`指针是一个函数原型，用于在测试（不更改）列表中的值时使用。它接受一个常量值和一个`void`指针，并返回一个`Boolean`值。`DoFuncPtr`用于更改列表中的值，并接受一个（非常量）值和一个`void`指针。这些`void`指针由调用方法传递；它们包含额外的信息：

[PRE73]

列表可以通过另一个列表初始化和赋值。默认构造函数创建一个空列表，析构函数则释放列表的内存：

[PRE74]

`Empty`函数如果列表为空则返回`true`，`Size`返回列表中的值的数量，`Clear`移除列表中的每个值，而`IndexOf`返回给定值的零基于索引，如果没有这样的值在列表中，则返回负一：

[PRE75]

`begin`和`end`方法返回列表的开始和结束指针。它们被包含进来是为了使列表可以通过`for`语句迭代：

[PRE76]

索引方法检查或修改列表中给定零基于索引的值：

[PRE77]

`Front`和`Back`方法通过调用之前提到的索引方法来检查和修改列表的第一个和最后一个值：

[PRE78]

`PushFront`和`PushBack`方法在列表的开始或结束处添加一个值或一个列表，而`Insert`在指定的索引处插入一个值或一个列表：

[PRE79]

`Erase` 函数删除给定索引处的值，而 `Remove` 删除从 `firstIndex` 到 `lastIndex`（包含）的列表，如果 `lastIndex` 为负一，则删除列表的末尾。如果 `firstIndex` 为零且 `lastIndex` 为负一，则删除整个列表。由于 `Remove` 中的 `lastIndex` 是默认参数，因此方法已被赋予不同的名称。给方法赋予相同的名称将违反重载规则：

[PRE80]

`Copy` 函数将 `firstIndex` 到 `lastIndex`（包含）的列表复制到 `copyList` 或 `lastIndex` 为负一时的列表的其余部分。如果 `firstIndex` 为零且 `lastIndex` 为负一，则整个列表被复制：

[PRE81]

`AnyOf` 函数如果至少有一个值满足 `ifFuncPtr`，则返回 `true`。也就是说，如果 `ifFuncPtr` 在以值作为参数调用时返回 `true`，则 `AllOf` 函数返回 `true` 如果所有值都满足 `ifFuncPtr`：

[PRE82]

`FirstOf` 和 `LastOf` 方法将 `value` 参数设置为满足 `ifFuncPtr` 的第一个和最后一个值；如果没有这样的值，则返回 `false`：

[PRE83]

`Apply` 方法对列表中的所有值调用 `doFuncPtr`，而 `ApplyIf` 方法对列表中满足 `ifFuncPtr` 的每个值调用 `doFuncPtr`：

[PRE84]

`CopyIf` 方法将列表中满足 `ifFuncPtr` 的每个值复制到 `copyList`。`RemoveIf` 移除满足 `ifFuncPtr` 的值：

[PRE85]

`ApplyRemoveIf` 方法对满足 `ifFuncPtr` 的每个值调用 `doFuncPtr`，然后移除它们。将函数应用于要删除的值可能看起来很奇怪。然而，当删除动态分配的值时，这在其中 `doFuncPtr` 在从列表中删除每个值之前释放每个值的内存时非常有用。简单地调用 `ApplyIf` 和 `RemoveIf` 是不起作用的。当值被 `ApplyIf` 删除后，它们不能成为 `RemoveIf` 中 `ifFuncPtr` 调用的参数：

[PRE86]

大小是列表中的值的数量，缓冲区持有这些值本身。缓冲区的大小是动态的，当向列表中添加或从列表中删除值时，它会改变。当列表为空时，缓冲区指针为空：

[PRE87]

默认构造函数和赋值运算符遍历给定的列表并复制每个值。为此，类型必须支持赋值运算符，除了数组之外的所有类型都支持：

[PRE88]

在赋值运算符中，我们首先删除缓冲区，因为它可能包含值。如果列表为空，缓冲区指针为空，删除运算符不执行任何操作：

[PRE89]

析构函数简单地删除缓冲区。再次强调，如果列表为空，缓冲区指针为空，删除运算符不执行任何操作：

[PRE90]

`Clear` 方法将大小设置为零并将缓冲区设置为空：

[PRE91]

`IndexOf` 方法遍历列表并返回找到的值的索引，如果没有这样的值，则返回负一：

[PRE92]

`begin` 方法返回列表中第一个值的地址：

[PRE93]

`end` 方法返回列表中最后一个值之后的一步地址，这是 C++ 中列表迭代器的惯例：

[PRE94]

如果索引超出列表范围，则发生断言：

[PRE95]

当在原始列表的末尾添加值时，我们需要分配一个包含一个额外值的新的列表，并将新值添加到末尾：

[PRE96]

当在原始列表的末尾添加新列表时，我们需要分配一个大小为原始列表和新列表之和的新列表，并将原始列表中的值复制到新列表中：

[PRE97]

当在列表的开头插入新值时，我们需要将原始列表中的所有值向前移动一步，为新值腾出空间：

[PRE98]

当在列表的开头插入新列表时，我们需要复制其所有值以及与新列表大小相对应的步数，为新值腾出空间：

[PRE99]

我们移动原始列表的值以腾出空间为新列表：

[PRE100]

当我们为新列表腾出空间后，我们将它复制到原始列表的开头：

[PRE101]

`Insert` 方法的工作方式与 `PushFront` 类似。我们需要分配一个新列表，并将原始列表中的值复制到新列表中腾出空间，然后将新值复制到原始列表中：

[PRE102]

当在列表中删除值时，我们分配一个较小的新的列表，并将剩余的值复制到该列表中：

[PRE103]

首先，我们复制删除索引之前的值：

[PRE104]

然后，我们复制删除索引之后的值：

[PRE105]

`Remove` 方法的工作方式与 `Delete` 相同；区别在于可以从列表中删除多个值；`removeSize` 保存要删除的值的数量：

[PRE106]

`Copy` 方法简单地为要复制的每个值调用 `PushBack`：

[PRE107]

`AnyOf` 方法遍历列表，如果至少有一个值满足函数，则返回 `true`：

[PRE108]

`AllOf` 方法遍历列表，如果至少有一个值不满足函数，则返回 `false`：

[PRE109]

`FirstOf` 方法以与 `FirstOf` 相同的方式查找列表中满足函数的第一个值，将其复制到值参数中，并返回 `true`。如果没有找到满足函数的任何值，则返回 `false`：

[PRE110]

`LastOf` 方法以与 `FirstOf` 相同的方式查找列表中满足函数的最后一个值；区别在于搜索是向后的：

[PRE111]

`Apply` 方法遍历列表，并对每个值调用 `doFuncPtr`，值可能会被修改（实际上，`Apply` 的目的就是修改值），因为 `doFuncPtr` 的参数不是常量：

[PRE112]

`ApplyIf` 方法遍历列表，并对满足 `ifFuncPtr` 的每个值调用 `doFuncPtr`：

[PRE113]

`CopyIf` 方法通过为每个满足 `ifFuncPtr` 的值调用 `PushBack` 将每个值复制到 `copyList` 中：

[PRE114]

`RemoveIf` 方法通过为每个值调用 `Delete` 来删除满足 `ifFuncPtr` 的每个值：

[PRE115]

`ApplyRemoveIf` 方法将 `doFuncPtr` 应用到满足 `ifFuncPtr` 的每个值。我们不能简单地调用 `Apply` 和 `RemoveIf`，因为 `doFuncPtr` 可能会释放 `Apply` 中的值，而 `RemoveIf` 中的 `ifFuncPtr` 在调用已删除的值时不会工作。相反，我们调用 `doFuncPtr` 并在调用后立即调用 `Erase`。这样，在调用 `doFuncPtr` 之后不会访问值：

[PRE116]

# 树类

C++ 标准库包含一组用于数组、列表、向量、集合和映射的容器类。然而，没有用于树结构的类。因此，`Tree` 类被添加到 Small Windows 中。树由一组节点组成，其中之一是根节点。每个节点持有一个（可能为空）的子节点列表：

**Tree.h**

[PRE117]

树可以被写入和从文件流或剪贴板读取：

[PRE118]

每个树节点持有一个值，该值由常量方法检查并由非常量方法修改：

[PRE119]

树节点还持有一个子节点列表，该列表由常量方法检查，并由非常量方法修改：

[PRE120]

子节点列表是一个树节点的初始化列表；默认情况下它是空的：

[PRE121]

默认构造函数和赋值运算符调用 `Init` 来执行树的实际初始化：

[PRE122]

析构函数递归地删除子节点：

[PRE123]

`WriteTreeToStream` 方法将节点值和子节点数量写入流，然后对每个子节点递归调用自身：

[PRE124]

`ReadTreeFromStream` 方法从流中读取节点值和子节点数量，创建子节点，并对每个子节点递归调用自身：

[PRE125]

`WriteTreeToClipboard` 和 `ReadTreeFromClipboard` 方法的工作方式与 `WriteTreeToStream` 和 `ReadTreeFromStream` 类似：

[PRE126]

# InfoList 类

`InfoList` 类是一个具有模板方法的辅助类，它将信息存储在字符列表中；信息可以被添加和提取；或者写入，或从缓冲区读取：

**InfoList** **.h**

[PRE127]

`Align` 函数逐字节增加列表，直到对齐类型的大小是列表大小的除数：

[PRE128]

`AddValue` 函数通过逐字节将模板类型的值添加到列表中来添加值，而 `GetValue` 通过逐字节从列表中提取值来获取列表开头的值：

[PRE129]

`AddString` 函数将文本的字符添加到列表中，并附带一个终止零字符，而 `GetString` 从列表中读取文本，直到遇到终止零字符：

[PRE130]

**InfoList.cpp**

[PRE131]

`FromBuffer` 函数将缓冲区的每个字节添加到列表中，而 `ToBuffer` 从列表中提取并复制每个字节到缓冲区：

[PRE132]

# 字符串

有少量字符串函数：

+   `CharPtrToGenericString`：这接受文本作为一个 `char` 字符指针，并以一个通用的 `String` 对象返回相同的文本。请记住，`String` 类持有 `TCHAR` 类型的值，其中许多是 `char` 或 `wchar_t`，这取决于系统设置。

+   `Split`：这接受一个字符串并返回一个包含文本空格分隔单词的字符串列表。

+   `IsNumeric`：如果文本包含一个数值，则此函数返回`true`。

+   `Trim`：这会移除文本开头和结尾的空格。

+   `ReplaceAll`：这会将一个字符串替换为另一个字符串。

+   `WriteStringToStream` 和 `ReadStringFromStream`：这些函数将字符串写入和从流中读取。

+   `StartsWith` 和 `EndsWith`：如果文本以子文本开头或结尾，则这些函数返回`true`。

**String.h**

[PRE133]

**String.cpp**

[PRE134]

`IsNumeric` 方法使用 `IStringStream` 方法读取字符串的值，并将读取的字符数与文本长度进行比较。如果读取了文本的所有字符，则文本将包含一个数值，并返回 `true`：

[PRE135]

# 摘要

在本章中，我们学习了Small Windows所使用的辅助类。在[第13章](ch13.html "第13章。注册表、剪贴板、标准对话框和打印预览")，*剪贴板、标准对话框和打印预览*中，我们将探讨注册表、剪贴板、标准对话框和打印预览。
