["```cpp\n#include <iostream>\n#include <thread>\n// Shared variable\nint counter = 0;\n// Function that increments the counter\nvoid incrementCounter() {\n  for (int i = 0; i < 100000; ++i) {\n    ++counter; // Race condition occurs here\n  }\n}\nint main() {\n  // Creating two threads that run incrementCounter()\n  std::thread thread1(incrementCounter);\n  std::thread thread2(incrementCounter);\n  // Wait for both threads to finish\n  thread1.join();\n  thread2.join();\n  // Print the final value of counter\n  std::cout << \"Final value of counter is: \" << counter\n            << std::endl;\n  return 0;\n}\n```", "```cpp\nFinal value of counter is: 130750\n```", "```cpp\n#include <atomic>\n#include <future>\n#include <iostream>\n#include <thread>\n#include <vector>\n// A simple function that we will run in a separate thread.\nvoid threadTask(int n) {\n  std::this_thread::sleep_for(std::chrono::seconds(n));\n  std::cout << \"Thread \" << std::this_thread::get_id()\n            << \" completed after \" << n << \" seconds.\\n\";\n}\n// A function that performs a task and returns a result.\nint performComputation(int value) {\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  return (value * value);\n}\nint main() {\n  // Start a thread that runs threadTask with n=2\n  std::thread t(threadTask, 2);\n  // task management with std::async and std::future\n  std::future<int> futureResult = std::async(\n      std::launch::async, performComputation, 5);\n  // Atomic operation with std::atomic\n  std::atomic<int> atomicCounter(0);\n  // Demonstrate atomicity in concurrent operations\n  std::vector<std::thread> threads;\n  for (int i = 0; i < 10; ++i) {\n    threads.emplace_back([&atomicCounter]() {\n      for (int j = 0; j < 100; ++j) {\n        atomicCounter += 1; // Atomic increment\n      }\n    });\n  }\n  // Joining the initial thread to ensure it has finished\n  // before main exits\n  if (t.joinable()) { t.join(); }\n  // Retrieving the result from the future\n  int computationResult = futureResult.get();\n  std::cout << \"The result of the computation is \"\n            << computationResult << \".\\n\";\n  // Joining all threads to ensure complete execution\n  for (auto &th : threads) {\n    if (th.joinable()) { th.join(); }\n  }\n  std::cout << \"The final value of the atomic counter is \"\n            << atomicCounter << \".\\n\";\n  return 0;\n}\n```", "```cpp\nThread 32280 completed after 2 seconds.\nThe result of the computation is 25.\nThe final value of the atomic counter is 1000.\n```", "```cpp\nstd::thread my_thread([]{\n    std::cout << \"Hello, Concurrent World!\" << \"\\n\";\n});\nmy_thread.join();\n```", "```cpp\nauto future_result = std::async([]{\n    return \"Response from async!\";\n});\nstd::cout << future_result.get() << \"\\n\";\n```", "```cpp\nthread_local int thread_counter = 0;\n```", "```cpp\n#include <future>\n#include <iostream>\n#include <thread>\n#include <vector>\n// Function to demonstrate the use of Thread Local Storage\nvoid incrementThreadCounter() {\n  // Unique to each thread\n  thread_local int thread_counter = 0;\n  thread_counter++;\n  std::cout << \"Thread \" << std::this_thread::get_id()\n            << \" counter: \" << thread_counter << \"\\n\";\n}\nint main() {\n  // Initiating a new thread using std::thread\n  std::thread my_thread([] {\n    std::cout << \"Hello, Concurrent World!\"\n              << \"\\n\";\n  });\n  // Ensure the main thread waits for my_thread to complete\n  if (my_thread.joinable()) { my_thread.join(); }\n  // Asynchronous operations w/std::async and std::future\n  auto future_result =\n      std::async([] { return \"Response from async!\"; });\n  // Retrieve the result with std::future::get when ready\n  std::cout << future_result.get() << \"\\n\";\n  // Demonstrating the use of Thread Local Storage (TLS)\n  std::vector<std::thread> threads;\n  for (int i = 0; i < 5; ++i) {\n    threads.emplace_back(incrementThreadCounter);\n  }\n  // Join all threads to the main thread\n  for (auto &thread : threads) {\n    if (thread.joinable()) { thread.join(); }\n  }\n  return 0;\n}\n```", "```cpp\nHello, Concurrent World!\nResponse from async!\nThread 11672 counter: Thread 1\n32816 counter: 1\nThread 7124 counter: 1\nThread 43792 counter: 1\nThread 23932 counter: 1\n```", "```cpp\nstd::map<std::string, std::string> config_data;\nstd::shared_timed_mutex config_mutex;\n```", "```cpp\nstd::shared_lock lock(config_mutex);\nauto val = config_data[\"some_key\"];\n```", "```cpp\nstd::unique_lock lock(config_mutex);\nconfig_data[\"some_key\"] = \"new_value\";\n```", "```cpp\n// A hypothetical concurrency-optimized container that uses\n// fine-grained locking\ntemplate <typename T> class ConcurrentVector {\nprivate:\n  std::vector<T> data;\n  mutable std::shared_mutex mutex;\npublic:\n  // Inserts an element into the container with minimal\n  // lock duration\n  void insert(const T &value) {\n    std::unique_lock<std::shared_mutex> lock(mutex);\n    data.push_back(value);\n  }\n  // Finds an element with read access, demonstrating\n  // shared locking\n  bool find(const T &value) const {\n    std::shared_lock<std::shared_mutex> lock(mutex);\n    return std::find(data.begin(), data.end(), value) !=\n           data.end();\n  }\n  // Size accessor that uses shared locking\n  size_t size() const {\n    std::shared_lock<std::shared_mutex> lock(mutex);\n    return data.size();\n  }\n};\n```", "```cpp\nvoid performConcurrentOperations(\n    ConcurrentVector<int> &concurrentContainer) {\n  // Multiple threads perform operations on the container\n  std::thread writer([&concurrentContainer]() {\n    for (int i = 0; i < 100; ++i) {\n      concurrentContainer.insert(i);\n    }\n  });\n  std::thread reader([&concurrentContainer]() {\n    for (int i = 0; i < 100; ++i) {\n      if (concurrentContainer.find(i)) {\n        std::cerr << \"Value \" << i\n                  << \" found in the container\\n\";\n      }\n    }\n  });\n  // Join threads to ensure complete execution\n  writer.join();\n  reader.join();\n  // Output the final size of the container\n  std::cout << \"Final size of the container:\"\n            << concurrentContainer.size() << \"\\n\";\n}\n```", "```cpp\nint main() {\n  ConcurrentVector<int> concurrentContainer;\n  performConcurrentOperations(concurrentContainer);\n  return 0;\n}\n```", "```cpp\n...\nValue 98 found in the container.\nValue 99 found in the container.\nFinal size of the container: 100\n```"]