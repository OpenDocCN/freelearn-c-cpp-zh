["```cpp\n#include <string>\nstd::string str1 = \"Thanks for reading me!\";\nstd::string str2 = \"Thanks for reading ME!\";\n```", "```cpp\n    #include <boost/algorithm/string/predicate.hpp>\n\n    boost::iequals(str1, str2)\n    ```", "```cpp\n    #include <boost/algorithm/string/compare.hpp>\n    #include <algorithm>\n\n    str1.size() == str2.size() && std::equal(\n      str1.begin(),\n      str1.end(),\n      str2.begin(),\n      boost::is_iequal()\n    )\n    ```", "```cpp\n    #include <boost/algorithm/string/case_conv.hpp>\n\n    std::string str1_low = boost::to_lower_copy(str1);\n    std::string str2_low = boost::to_lower_copy(str2);\n    assert(str1_low == str2_low);\n    ```", "```cpp\n    #include <boost/algorithm/string/case_conv.hpp>\n\n    std::string str1_up = boost::to_upper_copy(str1);\n    std::string str2_up = boost::to_upper_copy(str2);\n    assert(str1_up == str2_up);\n    ```", "```cpp\n    #include <boost/algorithm/string/case_conv.hpp>\n\n    boost::to_lower(str1);\n    boost::to_lower(str2);\n    assert(str1 == str2);\n    ```", "```cpp\n  // On some platforms std::locale::classic() works\n  // faster than std::locale()\n  boost::iequals(str1, str2, std::locale::classic());\n```", "```cpp\n    #include <boost/regex.hpp>\n    #include <iostream>\n    ```", "```cpp\n    int main() {\n      std::cout \n        << \"Available regex syntaxes:\\n\"\n        << \"\\t[0] Perl\\n\"\n        << \"\\t[1] Perl case insensitive\\n\"\n        << \"\\t[2] POSIX extended\\n\"\n        << \"\\t[3] POSIX extended case insensitive\\n\"\n        << \"\\t[4] POSIX basic\\n\"\n        << \"\\t[5] POSIX basic case insensitive\\n\"\n        << \"Choose regex syntax: \";\n    ```", "```cpp\n      boost::regex::flag_type flag;\n      switch (std::cin.get()) {\n        case '0': flag = boost::regex::perl;\n          break;\n        case '1': flag = boost::regex::perl|boost::regex::icase;\n          break;\n\n        case '2': flag = boost::regex::extended;\n          break;\n        case '3': flag = boost::regex::extended|boost::regex::icase;\n          break;\n        case '4': flag = boost::regex::basic;\n          break;\n\n        case '5': flag = boost::regex::basic|boost::regex::icase;\n          break;\n        default:\n          std::cout << \"Inccorect number of regex syntax.\"\n                    <<\"Exiting... \\n\";\n          return -1;\n      } \n      // Disabling exceptions\n      flag |= boost::regex::no_except;\n    ```", "```cpp\n      // Restoring std::cin\n      std::cin.ignore();\n      std::cin.clear();\n\n      std::string regex, str;\n      do {\n        std::cout << \"Input regex: \";\n        if (!std::getline(std::cin, regex) || regex.empty()) {\n          return 0;\n        }\n\n        // Without `boost::regex::no_except`flag this \n        // constructor may throw\n        const boost::regex e(regex, flag);\n        if (e.status()) {\n          std::cout << \"Incorrect regex pattern!\\n\";\n          continue;\n        }\n    ```", "```cpp\n        std::cout << \"String to match: \";\n        while (std::getline(std::cin, str) && !str.empty()) {\n    ```", "```cpp\n          bool matched = boost::regex_match(str, e);\n          std::cout << (matched ? \"MATCH\\n\" : \"DOES NOT MATCH\\n\");\n          std::cout << \"String to match: \";\n        } // end of `while (std::getline(std::cin, str))`\n    ```", "```cpp\n        // Restoring std::cin\n        std::cin.ignore();\n        std::cin.clear();\n      } while (1);\n    } // int main()\n    ```", "```cpp\n    Available regex syntaxes:\n            [0] Perl\n            [1] Perl case insensitive\n            [2] POSIX extended\n            [3] POSIX extended case insensitive\n            [4] POSIX basic\n            [5] POSIX basic case insensitive\n    Choose regex syntax: 0\n    Input regex: (\\d{3}[#-]){2}\n    String to match: 123-123#\n    MATCH\n    String to match: 312-321-\n    MATCH\n    String to match: 21-123-\n    DOES NOT MATCH\n    String to match: ^Z\n    Input regex: \\l{3,5}\n    String to match: qwe\n    MATCH\n    String to match: qwert\n    MATCH\n    String to match: qwerty\n    DOES NOT MATCH\n    String to match: QWE\n    DOES NOT MATCH\n    String to match: ^Z\n\n    Input regex: ^Z\n    Press any key to continue . . .\n    ```", "```cpp\nif (e.status()) {\n  std::cout << \"Incorrect regex pattern!\\n\";\n  continue;\n}\n```", "```cpp\nInput regex: (incorrect regex(\nIncorrect regex pattern!\nInput regex:\n\n```", "```cpp\nAvailable regex syntaxes:\n        [0] Perl\n        [1] Perl case insensitive\n        [2] POSIX extended\n        [3] POSIX extended case insensitive\n        [4] POSIX basic\n        [5] POSIX basic case insensitive\nChoose regex syntax: 0\n\nInput regex: (\\d)(\\d)\nString to match: 00\nMATCH: 0, 0,\nReplace pattern: \\1#\\2\nRESULT: 0#0\nString to match: 42\nMATCH: 4, 2,\nReplace pattern: ###\\1-\\1-\\2-\\1-\\1###\nRESULT: ###4-4-2-4-4###\n…\n```", "```cpp\n      std::string regex, str, replace_string;\n    ```", "```cpp\n      std::cout << \"String to match: \";\n      while (std::getline(std::cin, str) && !str.empty()) {\n        boost::smatch results;\n        bool matched = regex_search(str, results, e);\n        if (matched) {\n          std::cout << \"MATCH: \";\n          std::copy(\n            results.begin() + 1, \n            results.end(), \n            std::ostream_iterator<std::string>( std::cout, \", \")\n          );\n    ```", "```cpp\n          std::cout << \"\\nReplace pattern: \";\n          if (std::getline(std::cin, replace_string) && !replace_string.empty()) {\n            std::cout << \"RESULT: \" << boost::regex_replace(str, e, replace_string); \n          } else {\n            // Restoring std::cin\n            std::cin.ignore();\n            std::cin.clear();\n          }\n        } else { // `if (matched) `\n          std::cout << \"DOES NOT MATCH\";\n        }\n    ```", "```cpp\n    std::copy(\n      results.begin() + 1, \n      results.end(), \n      std::ostream_iterator<std::string>( std::cout, \", \")\n    );\n```", "```cpp\nstd::cout << \"RESULT: \" << boost::regex_replace(str, e, replace_string);\n```", "```cpp\nstd::cout << \"RESULT: \" << results.format(replace_string);\n```", "```cpp\nInput regex: (\\d)(\\d)\nString to match: 12\nMATCH: 1, 2,\nReplace pattern: $1-$2---$&---$$\nRESULT: 1-2---12---$\n```", "```cpp\nclass i_hold_some_internals {\n  int i;\n  std::string s;\n  char c;\n  // ...\n};\n```", "```cpp\n    #include <boost/format.hpp>\n    ```", "```cpp\n      // fmt parameter must contain the following:\n      //  $1$ for outputting integer 'i'\n      //  $2$ for outputting string 's'\n      //  $3$ for outputting character 'c'\n      std::string \n        to_string(const std::string& format_specifier) const {\n    ```", "```cpp\n        boost::format f(format_specifier);\n        unsigned char flags = boost::io::all_error_bits;\n        flags ^= boost::io::too_many_args_bit;\n        f.exceptions(flags);\n        return (f % i % s % c).str();\n      }\n    ```", "```cpp\n      i_hold_some_internals class_instance;\n\n      std::cout << class_instance.to_string(\n        \"Hello, dear %2%! \"\n        \"Did you read the book for %1% %% %3%\\n\"\n      );\n\n      std::cout << class_instance.to_string(\n        \"%1% == %1% && %1%%% != %1%\\n\\n\"\n      );\n    ```", "```cpp\n    Hello, dear Reader! Did you read the book for 100 % !\n    100 == 100 && 100% != 100\n    ```", "```cpp\n  boost::format f(format_specifier);\n  unsigned char flags = boost::io::all_error_bits;\n  flags ^= boost::io::too_many_args_bit;\n```", "```cpp\n  // Outputs 'Reader'\n  std::cout << class_instance.to_string(\"%2%\\n\\n\");\n```", "```cpp\n  try {\n    class_instance.to_string(\"%1% %2% %3% %4% %5%\\n\");\n    assert(false);\n  } catch (const std::exception& e) {\n    // boost::io::too_few_args exception must be caught\n    std::cout << e.what() << '\\n';\n  }\n```", "```cpp\nboost::too_few_args: format-string referred to more arguments than were passed\n```", "```cpp\n#include <string>\nconst std::string str = \"Hello, hello, dear Reader.\";\n```", "```cpp\nnamespace ba = boost::algorithm;\nstd::cout << \"\\n erase_all_copy   :\" << ba::erase_all_copy(str, \",\");\nstd::cout << \"\\n erase_first_copy :\" << ba::erase_first_copy(str, \",\");\nstd::cout << \"\\n erase_last_copy  :\" << ba::erase_last_copy(str, \",\");\nstd::cout << \"\\n ierase_all_copy  :\" << ba::ierase_all_copy(str, \"hello\");\nstd::cout << \"\\n ierase_nth_copy  :\" << ba::ierase_nth_copy(str, \",\", 1);\n```", "```cpp\nerase_all_copy     :Hello hello dear Reader.\nerase_first_copy   :Hello hello, dear Reader.\nerase_last_copy    :Hello, hello dear Reader.\nierase_all_copy    :, , dear Reader.\nierase_nth_copy    :Hello, hello dear Reader.\n```", "```cpp\nnamespace ba = boost::algorithm;\n\nstd::cout << \"\\n replace_all_copy  :\" << ba::replace_all_copy(str, \",\", \"!\");\nstd::cout << \"\\n replace_first_copy  :\" << ba::replace_first_copy(str, \",\", \"!\");\nstd::cout << \"\\n replace_head_copy  :\" << ba::replace_head_copy(str, 6, \"Whaaaaaaa!\");\n```", "```cpp\nreplace_all_copy    :Hello! hello! dear Reader.\nreplace_first_copy  :Hello! hello, dear Reader.\nreplace_head_copy   :Whaaaaaaa! hello, dear Reader.\n```", "```cpp\n    #include <boost/algorithm/string/split.hpp>\n    #include <boost/algorithm/string/classification.hpp>\n    #include <algorithm>\n    ```", "```cpp\n    int main() {\n      const char str[] \n        = \"This is a long long character array.\"\n          \"Please split this character array to sentences!\"\n          \"Do you know, that sentences are separated using period, \"\n          \"exclamation mark and question mark? :-)\"\n      ; \n    ```", "```cpp\n    typedef boost::split_iterator<const char*> split_iter_t;\n    ```", "```cpp\n      split_iter_t sentences = boost::make_split_iterator(str, \n        boost::algorithm::token_finder(boost::is_any_of(\"?!.\"))\n      );  \n    ```", "```cpp\n      for (unsigned int i = 1; !sentences.eof(); ++sentences, ++i) {\n        boost::iterator_range<const char*> range = *sentences;\n        std::cout << \"Sentence #\" << i << \" : \\t\" << range << '\\n';\n    ```", "```cpp\n        std::cout << \"Sentence has \" << range.size() << \" characters.\\n\";\n    ```", "```cpp\n        std::cout \n          << \"Sentence has \" \n          << std::count(range.begin(), range.end(), ' ') \n          << \" whitespaces.\\n\\n\";\n      } // end of for(...) loop\n    } // end of main()\n    ```", "```cpp\n    Sentence #1 :   This is a long long character array\n    Sentence has 35 characters.\n    Sentence has 6 whitespaces.\n\n    Sentence #2 :   Please split this character array to sentences\n    Sentence has 46 characters.\n    Sentence has 6 whitespaces.\n\n    Sentence #3 :   Do you know, that sentences are separated using dot,\n    exclamation mark and question mark\n    Sentence has 87 characters.\n    Sentence has 13 whitespaces.\n\n    Sentence #4 :    :-)\n    Sentence has 4 characters.\n    Sentence has 1 whitespaces.\n    ```", "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string between_str(const std::string& input, char starts,\n   char ends)\n{\n  std::string::const_iterator pos_beg \n    = std::find(input.begin(), input.end(), starts);\n\n  if (pos_beg == input.end()) {\n    return std::string(); // Empty\n  }\n\n  ++ pos_beg;\n  std::string::const_iterator pos_end \n    = std::find(input.begin(), input.end(), ends);\n\n  return std::string(pos_beg, pos_end);\n}\n```", "```cpp\nbetween_str(\"Getting expression (between brackets)\", '(', ')');\n```", "```cpp\n    #include <boost/utility/string_ref.hpp>\n    ```", "```cpp\n    boost::string_ref between(\n      const boost::string_ref& input, \n      char starts, \n      char ends) \n    ```", "```cpp\n    {\n      boost::string_ref::const_iterator pos_beg \n        = std::find(input.cbegin(), input.cend(), starts);\n      if (pos_beg == input.cend()) {\n        return boost::string_ref(); // Empty\n      }\n      ++ pos_beg;\n      boost::string_ref::const_iterator pos_end \n        = std::find(input.cbegin(), input.cend(), ends);\n      // ...\n    ```", "```cpp\n      if (pos_end == input.cend()) {\n        return boost::string_ref(pos_beg, input.end() - pos_beg);\n      }\n      return boost::string_ref(pos_beg, pos_end - pos_beg);\n    }\n    ```", "```cpp\n    between(std::string(\"(expression)\"), '(', ')')\n    ```", "```cpp\n  boost::string_ref r0(\"^_^\");\n\n  std::string O_O(\"O__O\");\n  boost::string_ref r1 = O_O;\n\n  std::vector<char> chars_vec(10, '#');\n  boost::string_ref r2(&chars_vec.front(), chars_vec.size());\n```", "```cpp\n#include <boost/algorithm/string/case_conv.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/lexical_cast.hpp>\n#include <iterator>\n\nvoid string_ref_algorithms_examples() {\n  boost::string_ref r(\"O_O\");\n  // Finding symbol\n  std::find(r.cbegin(), r.cend(), '_');\n\n  // Will print 'o_o'\n  boost::to_lower_copy(std::ostream_iterator<char>(std::cout), r);\n  std::cout << '\\n';\n\n  // Will print 'O_O'\n  std::cout << r << '\\n';\n\n  // Will print '^_^'\n  boost::replace_all_copy(\n    std::ostream_iterator<char>(std::cout), r, \"O\", \"^\"\n  );\n}\n```", "```cpp\ntypedef basic_string_ref<char, std::char_traits<char> >\n   string_ref;\n```", "```cpp\ntypedef basic_string_ref<wchar_t,  std::char_traits<wchar_t> > \n   wstring_ref;\n\ntypedef basic_string_ref<char16_t, std::char_traits<char16_t> > \n   u16string_ref;\n\ntypedef basic_string_ref<char32_t, std::char_traits<char32_t> > \n   u32string_ref;\n```"]