<html><head></head><body>
        

                            
                    <h1 class="header-title">Shader Editing and Optimization Tips</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Shaders (and the Materials they are built from in UE4) are responsible for all we see in the game. Some are very simple and require no user input whatsoever (such as most UI work), but eventually, any team making a modern day 3D game will likely need some custom solutions, if not a huge number, beyond what comes packaged with the basic game and templates. Knowing how to create and modify them, how to use (and re-use) them efficiently at runtime, and some of the powerful capabilities they provide, is major importance. Thankfully, UE4 makes some of this much easier than other platforms with their Material Editor, saving time and resources for teams, but of course this comes at the risk of improper use, which can be devastating for performance. Throughout this chapter are tips to prevent that, while getting the most out of the system and tools. And keep in mind, our goal here is not to become a specialized expert in every topic but to gain a holistic mastery of the major systems of UE4 and the confidence to guide a team or project to its best effectiveness. Material and shader mastery can (and does!) fill its own books entirely, but after this chapter, you should have the confidence to give grounded answers on the capabilities and limitations of what can be done with materials in UE4.  Our main topics will be:</p>
<ul>
<li>Basics of creating and editing materials</li>
<li>Editing material networks and editor-time performance tips</li>
<li>Runtime tips for optimizing shaders</li>
<li>Adapting shaders across various platforms</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter will use the project from the following GitHub link. While the lessons can be applied to any project, specific examples will be given using assets directly from the game project, so of course syncing it is recommended:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-8">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-8</a></p>
<p>Engine version used: 4.19.2.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Knowing and building materials</h1>
                
            
            
                
<p>It is assumed most readers are familiar with the concept of shaders: specific rendering code sent at runtime to tell the hardware how we want it to draw a given item to the screen. There are numerous places a novice can begin learning about them, but the assumption here is the reader has at least basic knowledge of how shaders work: compilation, upload to a GPU or software renderer, and execution there. As this is not a graphics primer, we'll skip ahead now to UE4's ubiquitous method of generating and porting shaders across platforms: Materials.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of materials, material instance creation, and use</h1>
                
            
            
                
<p>There's no perfect place to start when it comes to materials. However, the obvious one not everyone even knows is there are engine materials. If you open the editor and go to the content browser, you'll see in the bottom-right a View Options drop-down menu. Selecting Show Engine Content will make a new folder show up in the sources browser on the left, and selecting this folder, then adding a filter of Material and Material Instance, as here, from the Filters drop-down menu will show you a huge list of existing built-in materials:</p>
<p class="mce-root"/>
<p><img src="img/db7f30e4-c71d-4ad2-aef5-638b30411292.png"/></p>
<p>Selecting the Daylight Ambient Cubemap as a quick example will open the material editor and look like this:</p>
<p><img src="img/b668d045-e4d7-4d5d-9743-00ec10039595.png"/></p>
<p class="mce-root"/>
<p>For those new to editing materials, you can see it looks a lot like the blueprint editor and other node-based editing in UE4, which helps give a sense of familiarity across the different editor windows offered. Briefly describing what is shown here, the top-left has a preview (always just mapped to a sphere in the middle) of the material's output. The bottom-left is the details of whatever node is selected. The center, of course, is the main editing pane. At the bottom is a summary of the shader's complexity (more on this later!), and to the right is a list of nodes you can drop in (the same as if you right-click in the main pane). Browsing through the engine materials, you'll see many are simply used by the editor itself. You'll also notice (given the filter) several material instances. What's the difference? And what's different about a dynamic material instance? Let's do a quick list here and continue to some more specific examples:</p>
<ul>
<li>A material is the most basic type, typically a parent class to material instances, when used, and consists of the basic flow of what the material (and compiled shader) are going to do</li>
<li>By adding parameter nodes (more on this soon too), material instances can be inherited from a parent master material and given individual properties, so the whole material doesn't have to be remade to change, say, an input texture</li>
<li>Dynamic material instances are material instances created at runtime that can take real-time parameters and change them in places like blueprints of an actor</li>
</ul>
<p>We'll go through some examples of each, creating our own as we go, and viewing others already built in the content of our project to date. But it's important to consider the usage of a material before you begin work on it. Is this a material that will be used in a very specific way with no need to derive children? Then it can probably just remain and be directly referenced as a material. Is the intention to have several variants of one core set of shader logic? Then you'll likely want a base material with a set of material instance children of course. Do you want something that takes parameters (think like a function being passed arguments in C++) at runtime with different outcomes based on that? You'll want to make a material, a material instance (at least one) thereof, and then at runtime, create a dynamic material instance (the easiest way is usually in the blueprint constructor of the object), and pass that its parameters either at startup or throughout that object's life. So let's take these one at a time in the next section, see what's involved in each of those cases, and get in the habit of building your materials right the first time to fit their use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working on material networks and performance tips at editor time</h1>
                
            
            
                
<p>While we can easily begin a material from scratch (and it's highly recommended to just take some time playing with what can be done if you're unfamiliar), let's begin with an existing material and go through what it does, then begin changing it to something more useful in our test map.</p>
<p>To give a quick example of how we can change a material instance and apply it to the world, let's start with Content/InfinityBladeIceLands/Environments/Misc/Exo_Deco01/Materials, and we'll use the M_Exo_Crate_Open material as our starting point. Feel free to select it and open it in the material editor now.</p>
<p>To get a demonstration rolling, we'll quickly do a few things to this base material. Drag from the Emissive Color pin and filter for time or the like to get the TimeWithSpeedVariable node placed here. Drag from its speed to the left and add a Constant. We'll make sure that constant defaults to 0.0, thus not changing the base behavior everywhere else this crate material is used (in the frozen cove level). Lastly, right-click on that constant node, select Convert to Parameter, and name it EmissiveSpeed, as shown here:</p>
<p><img src="img/8997beff-61bb-418f-babd-d1101db2b637.png"/></p>
<p>For those paying close attention, you'll notice the Mobile texture samplers at the bottom is currently 2/8. As soon as you save the material, its current graph gets applied (both to the material asset, as well as any instances in the level), and you'll see it jump from 2 to 6/8! Granted, tripling our texture sampling at runtime isn't great, but on mobile platforms that magic 8 number can be a very significant limit (more on that later in the chapter). But remember: <em>save to apply changes fully!</em></p>
<p>Once that's all done, back in the content browser, right-click on the crate material, and at the top is the option to Create Material Instance. We'll use that to activate this emissive color in the instance:</p>
<p><img src="img/37926a04-457c-44ff-83d6-8fb747a96fd3.png"/></p>
<p>Just like in base materials, it's important to always have whatever stats you need clicked to on at the top of these editors as you can immediately see an overview of the complexity of the material: base and vertex instructions and texture samplers. Small changes can make <em>huge</em> differences to these numbers, and getting artists and anyone working with materials familiar with what reasonable numbers are for your platform is critical to do early and always enforce!</p>
<p>Notice that while editing a material instance, the logic of the shader is gone. You can't modify it in an instance, but you can modify parameters (that's sort of the whole point of them!). In the top-right, check the box to allow editing of the EmissiveSpeed, and we'll set it to 1.0. Now, keep in mind this texture and its corresponding normal map were made for a specific model, not these cubes, but we're again demonstrating concepts here, not making ready-to-ship art. We can now drag this (the instance's icon from the content browser) on to one of the cubes in the level and play it. In the screenshot here, I lowered the direction light's intensity to 0.6 or so, and brought the color of the sky light to a dark gray, but you don't have to do these things. It just makes the lighting-independent nature of this pulsing emissive more obvious:</p>
<p><img src="img/2b984e88-c338-48b9-b9f9-6b043f149648.png"/></p>
<p class="mce-root"/>
<p>So while it's not perfect (we'll improve it in just a moment!) you can see now a trick that a lot of games use to highlight items that the player should pick up in a game. They often have a pulsing shine to them that makes them stand out from the static backgrounds near them so the player won't miss those valuable pick-ups. To test its pulsing, you can click Simulate from the Play button pull-down in the editor, though again for those of you playing along closely in the GitHub project, you'll notice this exposes a check of mine on the player controller being the right type. So, any time a serious bug like that is found, you check in a fix ASAP. But let's view that box now (either by playing the level normally, or syncing commit ce0da7c, or making the following fix locally):</p>
<pre>void AMasteringCharacter::InitializeInventoryHUD()
{
        APlayerController* player = Cast&lt;APlayerController&gt;(GetController());
 
        if (player != nullptr) // function is called with a non-player controller in simulation in editor
        {
                AMasteringHUD* HUD = Cast&lt;AMasteringHUD&gt;(player-&gt;GetHUD());
 
                if (HUD != nullptr)
                {
                        HUD-&gt;InitializeInventory(Inventory);
                }
        }
}</pre>
<p>And you can now see the results of a few quick changes to the material. Let's improve it a bit quickly, and then move on. First we'll make the pulsing follow a sine output rather than linear, and we'll put a cap on its magnitude, defaulted to 0.5:</p>
<p><img src="img/0920a37c-1e3d-47fe-8427-c62a6248e7e5.png"/></p>
<p>Now if you go to the material instance. As the MaxEmissive is also a parameter now, you can see it and set it to something else (say 0.25 to make it all a bit more subtle) and look at our result.</p>
<p>To make a dynamic material instance, we need to edit the blueprint of the Physics Box object in the test level, select any of them, and then in its details pane, pick Edit Blueprint and open the editor. Here we can add logic such as this, but note: this will change the logic for <em>all</em> of the boxes in the level now, and will even overwrite (as we put it in slot 0) the unmodified material instance on the box we were working on before. Add this and check out the result:</p>
<p><img src="img/fab396e1-4547-4cad-8ef6-98e4a692354c.png"/></p>
<p>Now we have a really fast pulsing material on all our boxes. If you wanted it on just a select few, it's possible to do this by referencing it in the level blueprint or by making individual box types instead of just the one they all are instances of, but now, hopefully, the value of creating a dynamic instance with parameters that can be set at runtime by blueprint events is evident. You could even change the material back to the default cube material upon being hit. The flexibility here is very powerful! Just keep in mind there are some specific precomputed possibilities that are lost if you replace a material dynamically at runtime, but for most games and projects, real-time lighting and effects are the prominent feature on anything you would give a dynamic material instance to.</p>
<p>Don't forget also that static meshes (and other meshes) can have many materials: just look around at some of the pieces in the map Frozen Cove! All will be applied when rendering the actor. The first material is typically the one used for setting the Physical Material and the most basic/fundamental rendering of the object, but if you pick a static mesh object (including the 1M_Cube of this test level), you can see its materials are just an array with no hard limit (only practical ones for performance and manageability).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Materials at runtime and various platforms</h1>
                
            
            
                
<p>Now that editing materials is familiar and we briefly noted how one seemingly small change drastically increased one of the stats of a material, it's time to get a bit more in-depth here and understand the tools available for runtime analysis. There are myriad tools for analyzing the graphical performance of your scene, several built into UE4, and others that are free that you can explore. NVIDIA makes a great set of tools, a lifesaver for Android developers, which can be found in the additional reading section. For now, we'll focus on what we can do inside Unreal and the editor first and foremost as our main tool and early testing spot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Runtime tools and techniques to quickly iterate shaders</h1>
                
            
            
                
<p>One of the most immediately useful tools in your arsenal for shader performance is the Shader Complexity viewmode. In any viewport window in the editor, this can be found by clicking the lighting drop-down menu (next to the perspective drop-down menu in the top-left corner of the viewport. In the screenshots, these are typically Lit and Perspective respectively). In there, under Optimization Viewmodes is Shader Complexity (<em>Alt+8</em> being the shortcut on PC, <em>Alt+4</em> to get back to lit). However, in our test level there's not much to look at, so let's quickly go to the frozen cove map, which has a lot more of interest. At runtime, on any platform with the console enabled (<em>~</em> key on PC, 4-finger tap on most mobile devices), you can access this also via the show ShaderComplexity command, and as that's most interesting here, let's take a look at what we get at the start of frozen cove:</p>
<p><img src="img/a4f54bd0-8e5b-4adf-bf7a-8a12753ce418.png"/></p>
<p>Yikes! As is obvious from the color scale at the bottom, there's something serious going on there in the middle, and of course, it's obvious it's the blowing snow/clouds that drift through the center of the map. What you'll often find on most platforms is your most hated foe from a performance standpoint is overdraw. Most developers are at least familiar with the term, but this is where the GPU is forced to draw then re-draw the same pixel on the screen a number of times. Translucence tends to be the biggest cause of overdraw, as is exactly the case here. We have a ton of giant particles, all with alpha translucence, on top of each other from a rendering standpoint (our camera's perspective). Thus to blend them all, those pixels where they overlap are redrawn a huge number of times, making those bright white spots of shader work. On a decent PC this is all fine and good as the framerate in even a non-optimized build is still 50+ fps for this level, but on other platforms (especially mobile devices), this will quickly become a nightmare scenario, discussed further in the next section.</p>
<p>In the meantime, since we don't have a dedicated chapter in this book on optimization, hopefully an overview of helpful tools and some links to further reading will suffice. First, get to know your stat ... command-line cheats. These can give you huge amounts of real-time data in-game, and being familiar with a number of them is always recommended. That said, the ones I recommend most highly are stat CPU, stat GPU (where you can easily see the cost of translucence), stat Game, and stat FPS, the latter of which should probably be turned on by default in almost every non-release build.  Also of note, stat Memory is a huge help too, but for memory consumption, not directly performance. Figuring out where your game is bound of course is the key to knowing where to optimize to improve your framerate. Again, this is probably fairly common knowledge among most developers; but this simply means: is your main thread, render thread, or GPU cost the highest each frame. You're only as fast as the slowest member of that group, and the Profiler in the Session Frontend window was discussed very early on. It is a good tool for getting very detailed information about the first two (main/game thread and render thread) to see whether you are using up too much CPU. The <kbd>stat GPU</kbd> command is the fastest way to check whether that is your bottleneck, but for detailed information such as in the profiler, you can use stat startfile and stat stopfile to generate detailed information and also open it in the frontend window. On other platforms or for a different perspective, again, see NVIDIA's tools (mentioned earlier) or explore the many options each platform typically supplies to its developers. For a little bit more detail on UE4's options, a couple of links have been added to the <em>Further reading </em>section. Of note at this point, you can, even while simulating or running a level, begin editing materials (and remember to save them to propagate changes!) and see the results directly and immediately.  So let's now explore a couple of options here with these blending particles as examples of this.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Know Your Platform and How to Adapt Shaders!</h1>
                
            
            
                
<p>Knowing what platform you are developing for is obviously key to any performance optimization, especially in the graphics and shader department. For example, let's say we're aiming to include mid-performance Android phones and tablets as a platform. The fastest way to test what things may look like there is to go to the main editor menu's settings drop-down menu, then Preview Rendering Level, Mobile / HTML5, and pick Android Preview. At this point, you'll probably see this:</p>
<p><img src="img/f2a4f86d-568a-4858-b80e-dcf4fe16d5fa.png"/></p>
<p>We're now having to rebuild something like 8,000+ shaders for this new platform, but as may have been noted, this happened the first time opening this level on PC as well. It simply has to be done once, then smaller changes will cause smaller shader recompilations, but initially, this can be several minutes of serious CPU utilization as it builds all of those shaders. Just know that it won't keep happening in this level once they're cached for this preview mode.</p>
<p>Once that's done, let's play again and show shader complexity again now that we're in OpenGL ES2 emulation in our viewport while playing:</p>
<p><img src="img/30eb2379-b665-4835-9236-696e963da694.png"/></p>
<p>Yikes! Now that overdraw is getting serious. So what can we do?</p>
<p>Well, the most obvious approach, as these are just a cosmetic feature (and other than a bit of visibility, are not there to affect gameplay), we simply tell the particle emitters not to run at certain quality levels. This section is not on particle FX (but there is one coming later!) so we'll just briefly test this theory to prove our ES2 killing overdraw is coming from them specifically. Searching the level for emitters, eventually P_Snow_BlowingLarge_particulates stands out and is in fact the culprit. Opening it up, we can click on the emitter with the large swirling cloud particles and set its Detail Mode to Medium, as shown here:</p>
<p><img src="img/025f6265-cc15-4eb0-8314-62212057e2c0.png"/></p>
<p>But, of course, nothing changes in our preview until we change the available performance levels there, too. Here, we'll want to modify the scalability settings we're using to preview this in-editor:</p>
<p><img src="img/91146e15-3a01-4e64-b97c-26d142fa9388.png"/></p>
<p>So, as shown here, we're going to set our current Effects level to Low, and voila, no more particles causing our biggest burning overdraw performance hit:</p>
<p><img src="img/76bd8db6-aa25-4b0d-82f9-e8550f5fc539.png"/></p>
<p>Don't worry about the lighting rebuild warning here in-game, as you can't build precomputed lighting in the editor under ES2 emulation (which you conveniently can see is on in the bottom-right corner), and it's also saying the vertex fog this level uses won't work at all in this mode. Good information, but <em>always</em> be sure to test whenever possible on the actual devices themselves. The emulation is a great way to quickly iterate a few ideas, but until you actually test these changes on a proper device with its library and OS updated to whatever level is appropriate, and it's using its own drivers, you can't be sure your results will match anything like the best emulation you could hope for here.</p>
<p>While there are still plenty of things to worry about if we were to use this level on anything but higher-range Android devices (using ES3+ or other rendering), the biggest offender was just removed. But you may be asking, "<em>isn't this chapter about modifying materials to suit your</em> needs?" Yes, it certainly is. Let's find the material used in these particles. Tracing it from the emitters properties, it's a smoke-like material instance whose parent is a translucent material. A typical adjustment from high-end rendering to ES2 OpenGL or lower-end rendering is to turn those translucent materials into masked, and rather than sending a graded alpha in to the translucency channel, you just send a 1-bit mask, like here, in the grass material near the start point in the map:</p>
<p><img src="img/d38d9cc0-9622-462f-a637-7303ad5731fa.png"/></p>
<p class="mce-root"/>
<p>Note the alpha channel of the input texture going to the mask input of the shader (also interesting is the wind node which is used to shift the grass around at runtime, feel free to experiment with it, too).  Now, we have some pros and cons to this of course.  Pro: there's no overdraw where you see through the texture, because the mask tells the renderer to never draw the pixel in the first place!  Con: you get hard edges where the mask falls, not smooth, subtle fading edges.  We've all seen this in games before, but take a look here at the grass in our preview window:</p>
<p><img src="img/09205f73-ea87-4bc1-bd42-0cf922a26337.png"/></p>
<p class="mce-root"/>
<p>This works OK for things such as plants, or literally holes in surfaces, but would look amateurish at best for something like a puff of a snowy cloud like the effect here. So what can be done with materials to address this? Let's get acquainted with by far the most helpful little node for this purpose, the quality switch. Here is the translucent material as it shipped with the level:</p>
<p><img src="img/dd36b8fe-2212-4599-b1e4-86fa146ffe44.png"/></p>
<p>And here's how we can insert the quality node to set low-quality FX to not do this alpha blending business on those devices:</p>
<p><img src="img/a6b99887-f958-4266-bd6c-02c8c39408db.png"/></p>
<p>If we now set the particle system back to &gt;= Low detail mode (so it always tries to emit), but keep our editor's scalability setting for effects to Low, the particles will also stop drawing and will not be a drag on our GPU performance anymore. This can be shown real time by playing the level before saving the change (or simply wiring the alpha of DIFF directly back into the A channel of the multiply node). With it wired up with the quality switch, save the material, and poof: the snowy cloud wisps are gone.</p>
<p>So, one last point here. That's all fine and good in the editor, but how do these things get set per platform, or even per device? Config (.ini) files. Keep in mind that in the Config folder of the project, you can have a subfolder for each relevant platform (so Config/Android, Config/Windows, Config/iOS, and so on), and for each Default... .ini in the base folder, you can create a platform-specific one in its folder (so, for example, DefaultEngine.ini is overridden on Android devices by <kbd>Config/Android/AndroidEngine.ini</kbd>). Config files are always applied from most specific to least specific, so if a property is in <kbd>AndroidEngine.ini</kbd>, the game's <kbd>Config/DefaultEngine.ini</kbd>, <em>and</em> the engine's <kbd>Config/BaseEngine.ini</kbd>, the <kbd>AndroidEngine.ini</kbd> propery will be the last one applied, and the one used at runtime. That said, if you're working with a significant number of devices, you'll likely want to add these properties at the game's <kbd>Config/DefaultDeviceProfiles.ini</kbd> level. Here's a quick rundown of what can be done there:</p>
<pre>[DeviceProfiles]<br/>+DeviceProfileNameAndTypes=Android_Adreno4xx_High,Android</pre>
<p>Here we define a special named device and its type (Android).</p>
<pre>[/Script/AndroidDeviceProfileSelector.AndroidDeviceProfileMatchingRules]<br/>+MatchProfile=(Profile="Android_Adreno4xx_High",Match=((SourceType=SRC_GpuFamily,CompareType=CMP_Regex,MatchString="Adreno \\(TM\\) 4[3-9][0-9]")))</pre>
<p>This chunk tells the engine how to figure out whether the device it's started on is running that device type (by searching for the GPU type):</p>
<pre>[Android DeviceProfile]<br/> +CVars=r.BloomQuality=1<br/> +CVars=r.Shadow.MaxResolution=1024<br/> +CVars=r.MaterialQualityLevel=2</pre>
<p>Here we have a couple of default values for an Android device (all of them unless overridden more specifically after):</p>
<pre>[Android_High DeviceProfile]<br/> +CVars=r.MaterialQualityLevel=1<br/> +CVars=r.MobileContentScaleFactor=2.0<br/> +CVars=r.ShadowQuality=5<br/> +CVars=r.DetailMode=2</pre>
<p>This is a profile for high-performance Android properties to use:</p>
<pre>[Android_Adreno4xx_High DeviceProfile]<br/> DeviceType=Android<br/> BaseProfileName=Android_High</pre>
<p class="mce-root"/>
<p>And lastly, we simply set the specific Adreno4xx_High type to the Android_High type, but we could at that point set any properties we wanted to different levels as well. For our material, in the profiles we wanted the snowy clouds not to show up, so we'd simply set the following:</p>
<pre>+r.DetailMode=0</pre>
<p>In a more general fashion, you can set (Platform)Scalability.ini's sg.EffectsQuality to 0, as is shown in great detail in the scalability reference link from Epic in the <em>Further reading</em> section.</p>
<p>One warning: at the end of the GitHub project for this chapter, .uasset file types were added to Git's LFS system because of some very large assets. Jumping back to earlier projects will turn any later changed .uasset pointers back into .uasset data objects and confuse LFS, which may require you to fix your local branch by doing a hard reset to before this LFS change (commit c24d2db), then doing a hard reset to the changelist or branch forward that you wanted to work in if it refuses to let you discard .uasset changes because it says it can't parse the pointer (thinking it should be an LFS pointer, not a binary .uasset). All maintained branches going forward (Chapter-9, master, and the new In-Progress) will be set to have their .uassets tracked properly. It's only an issue when jumping back, but hopefully these tips can get past it for any who do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>For those already familiar with UE4's material system, hopefully this was a good review and came with some new information or pointers along the way. For those who were previously inexperienced, you should now have a solid foundation to build upon for driving a team and project forward and making the right decisions with the most commonly used powerful tools that Unreal makes available. There is always more to learn, but having a level of competence across areas such as this is mandatory for being able to take a project to a higher level and demonstrate to a team the skills and knowledge needed to manage such a complex and powerful world that UE4's materials offer every project. Finally, as promised, for those familiar with writing HLSL or GLSL directly, and wondering what this looks like for UE4, take a look in the Engine's Shaders/Private folder at things such as VolumetricFog.usf. For those who want to get started down this path or who are new to Unreal's way of compiling shaders themselves, another great link is in the <em>Further reading</em> section for just that pursuit.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the difference between a material and a material instance?</li>
<li>A material instance is only meaningful if adding a very specific node type to a material. What is that type?</li>
<li>Simulation from the play drop-down menu can be helpful. What things did it reveal in this chapter?</li>
<li>What is the purpose of a dynamic material instance, and where/when can they be made?</li>
<li>What is the key tool for finding GPU-killing shaders in an area of a map?</li>
<li>Which command-line options are most helpful for profiling any and all performance problems?</li>
<li>What node is your best friend when trying to tune materials across various platforms?</li>
<li>How can per-platform settings across almost all significant performance factors be set?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>NVIDIA PerfKit (Android and PC):</p>
<p><a href="https://developer.nvidia.com/nvidia-perfkit">https://developer.nvidia.com/nvidia-perfkit</a></p>
<p>UE4 CPU profiling:</p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Performance/CPU">https://docs.unrealengine.com/en-us/Engine/Performance/CPU</a></p>
<p>UE4 GPU profiling:</p>
<p><a href="https://docs.unrealengine.com/en-US/Engine/Performance/GPU">https://docs.unrealengine.com/en-US/Engine/Performance/GPU</a></p>
<p>Unreal scalability reference:</p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Performance/Scalability/ScalabilityReference">https://docs.unrealengine.com/en-us/Engine/Performance/Scalability/ScalabilityReference</a></p>
<p>Unreal Shader development (.usf, including HLSL/GLSL cross-compiling explained):</p>
<p><a href="https://docs.unrealengine.com/en-us/Programming/Rendering/ShaderDevelopment">https://docs.unrealengine.com/en-us/Programming/Rendering/ShaderDevelopment</a></p>


            

            
        
    </body></html>