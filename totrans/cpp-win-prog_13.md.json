["```cpp\nnamespace SmallWindows { \n  class Registry { \n    public: \n      static void WriteInteger(String key, const int value); \n      static void WriteDouble(String key, const double value); \n      static void WriteBoolean(String key, const bool value); \n      static void WriteString(String key, const String text); \n\n      static void WriteBuffer(String key, const void* buffer, \n                              int size); \n\n      static int ReadInteger(String key, const int defaultValue); \n      static double ReadDouble(String key, \n                               const double defaultValue); \n      static bool ReadBoolean(String key, \n                              const bool defaultValue); \n      static String ReadString(String key, \n                               const String defaultText); \n      static void ReadBuffer(String key, void* buffer, int size, \n                             const void* defaultBuffer); \n\n      static void Erase(String key); \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n\n```", "```cpp\n  const String RegistryFileName = TEXT(\".\\\\SmallWindows.ini\"); \n\n```", "```cpp\n  void Registry::WriteInteger(String key, const int intValue) { \n    WriteBuffer(key, &intValue, sizeof intValue); \n  } \n\n  void Registry::WriteDouble(String key, \n                             const double doubleValue) { \n    WriteBuffer(key, &doubleValue, sizeof doubleValue); \n  } \n\n  void Registry::WriteBoolean(String key, const bool boolValue) { \n    WriteBuffer(key, &boolValue, sizeof boolValue); \n  } \n\n```", "```cpp\n  void Registry::WriteString(String key, const String text) { \n    ::WritePrivateProfileString \n        (Application::ApplicationName().c_str(), \n         key.c_str(), text.c_str(), RegistryFileName.c_str()); \n  } \n\n```", "```cpp\n  void Registry::WriteBuffer(String key, const void* buffer, \n                             int size) { \n    ::WritePrivateProfileStruct \n        (Application::ApplicationName().c_str(), \n         key.c_str(), (void*) buffer, size, \n         RegistryFileName.c_str()); \n  } \n\n```", "```cpp\n  int Registry::ReadInteger(String key, const int defaultValue) { \n    int intValue; \n    ReadBuffer(key, &intValue, sizeof intValue, &defaultValue); \n    return intValue; \n  } \n\n  double Registry::ReadDouble(String key, \n                              const double defaultValue) { \n    double doubleValue; \n    ReadBuffer(key, &doubleValue, sizeof doubleValue, \n               &defaultValue); \n    return doubleValue; \n  } \n\n  bool Registry::ReadBoolean(String key, const bool defaultValue){ \n    bool boolValue; \n    ReadBuffer(key, &boolValue, sizeof boolValue, &defaultValue); \n    return boolValue; \n  } \n\n```", "```cpp\n  String Registry::ReadString(String key, \n                              const String defaultText) { \n    TCHAR text[MAX_PATH]; \n    int count = \n      ::GetPrivateProfileString \n          (Application::ApplicationName().c_str(), key.c_str(), \n           nullptr, text, MAX_PATH, RegistryFileName.c_str()); \n    return (count > 0) ? String(text) : defaultText; \n  } \n\n```", "```cpp\n  void Registry::ReadBuffer(String key, void* buffer, int size, \n                            const void* defaultBuffer) { \n    int result = \n      ::GetPrivateProfileStruct \n          (Application::ApplicationName().c_str(), key.c_str(), \n           buffer, size, RegistryFileName.c_str()); \n\n    if (result == 0) { \n      ::memcpy(buffer, defaultBuffer, size); \n    } \n  } \n\n```", "```cpp\n  void Registry::Erase(String key) { \n    ::WritePrivateProfileString \n        (Application::ApplicationName().c_str(), \n         key.c_str(),nullptr,RegistryFileName.c_str()); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n\n```", "```cpp\n  enum {AsciiFormat = CF_TEXT, UnicodeFormat = CF_UNICODETEXT}; \n\n```", "```cpp\n  class Clipboard { \n    public: \n      static bool Open(const Window* windowPtr); \n      static bool Close(); \n      static bool Clear(); \n      static bool Available(unsigned int format); \n\n```", "```cpp\n      template<int Format, class CharType> \n      static bool WriteText(vector<String>& lineList); \n      template<int Format, class CharType> \n      static bool ReadText(vector<String>& lineList); \n\n      static bool WriteGeneric(unsigned int format, \n                               InfoList& infoList); \n      static bool ReadGeneric(unsigned int format, \n                              InfoList& infoList); \n  }; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n\n```", "```cpp\n  bool Clipboard::Open(const Window* windowPtr) { \n    return (::OpenClipboard(windowPtr->WindowHandle()) != 0); \n  } \n\n  bool Clipboard::Close() { \n    return (::CloseClipboard() != 0); \n  } \n\n  bool Clipboard::Clear() { \n    return (::EmptyClipboard() != 0); \n  } \n\n```", "```cpp\n  bool Clipboard::Available(unsigned int format) { \n    return (::IsClipboardFormatAvailable(format) != 0); \n  } \n\n```", "```cpp\n  template<int Format,class CharType> \n  bool Clipboard::WriteText(vector<String>& lineList) { \n\n```", "```cpp\n    int bufferSize = 0; \n\n    for (String line : lineList) { \n      bufferSize += line.size(); \n    }  \n\n    int listSize = lineList.size(); \n    bufferSize += listSize; \n\n```", "```cpp\n    HGLOBAL globalHandle = \n      ::GlobalAlloc(GMEM_MOVEABLE, bufferSize * sizeof(CharType)); \n\n```", "```cpp\n    if (globalHandle != nullptr) { \n      CharType* buffer = (CharType*) ::GlobalLock(globalHandle); \n\n      if (buffer != nullptr) { \n        int bufferIndex = 0; \n\n```", "```cpp\n        for (int listIndex = 0; listIndex < listSize;++listIndex) { \n          for (TCHAR tChar : lineList[listIndex]) { \n            buffer[bufferIndex++] = (CharType) tChar; \n          } \n\n          if (listIndex < (listSize - 1)) { \n            buffer[bufferIndex++] = (CharType) '\\r'; \n          } \n        } \n\n```", "```cpp\n        buffer[bufferIndex] = (CharType) '\\0'; \n\n```", "```cpp\n        ::GlobalUnlock(globalHandle); \n        ::SetClipboardData(Format, globalHandle); \n\n```", "```cpp\n        return true; \n      } \n    } \n\n```", "```cpp\n    return false; \n  } \n\n```", "```cpp\n  template<int Format,class CharType> \n  bool Clipboard::ReadText(vector<String>& lineList) { \n    HGLOBAL globalHandle = ::GetClipboardData(Format); \n\n    if (globalHandle != nullptr) { \n      CharType* buffer = (CharType*) ::GlobalLock(globalHandle); \n\n      if (buffer != nullptr) { \n        String currentLine; \n\n```", "```cpp\n        int charCount = \n          ::GlobalSize(globalHandle) / (sizeof(CharType)); \n\n        for (int count = 0; count < charCount; ++count) { \n          CharType cChar = (*buffer++); \n\n```", "```cpp\n          switch (cChar) { \n            case ((CharType) '\\r') : \n              lineList.push_back(currentLine); \n              currentLine.clear(); \n              break; \n\n```", "```cpp\n            case ((CharType) '\\0') : \n              lineList.push_back(currentLine); \n              break; \n\n```", "```cpp\n            default: \n              currentLine += (TCHAR) cChar; \n              break; \n          } \n        } \n\n```", "```cpp\n        ::GlobalUnlock(globalHandle); \n        return true; \n      } \n    } \n\n```", "```cpp\n    return false; \n  } \n}; \n\n```", "```cpp\n  bool Clipboard::WriteGeneric(unsigned int format, \n                               InfoList& infoList) { \n    int bufferSize = infoList.Size(); \n    HGLOBAL globalHandle = GlobalAlloc(GMEM_MOVEABLE, bufferSize); \n\n    if (globalHandle != nullptr) { \n      void* buffer = ::GlobalLock(globalHandle); \n\n```", "```cpp\n      if (buffer != nullptr) { \n        infoList.ToBuffer(buffer); \n        ::GlobalUnlock(globalHandle); \n        ::SetClipboardData(format, globalHandle); \n        return true; \n      } \n    } \n\n```", "```cpp\n    return false; \n  } \n\n```", "```cpp\n  bool Clipboard::ReadGeneric(unsigned int format, \n                              InfoList& infoList) { \n    HGLOBAL globalHandle = ::GetClipboardData(format); \n\n    if (globalHandle != nullptr) { \n      void *buffer = ::GlobalLock(globalHandle); \n      int bufferSize = ::GlobalSize(globalHandle); \n      infoList.FromBuffer(buffer, bufferSize); \n      ::GlobalUnlock(globalHandle); \n      return true; \n    } \n\n```", "```cpp\n    return false; \n  } \n}; \n\n```", "```cpp\nWord Files (*.wrd)\\0*.drw\\0Text Files(*.txt)\\0*.txt\\0\\0 \n\n```", "```cpp\nnamespace SmallWindows { \n  class Window; \n  class Graphics; \n\n  class StandardDialog { \n    public: \n      enum SaveFlags {NoSaveFlag = 0, \n                      PromptBeforeOverwrite = OFN_OVERWRITEPROMPT, \n                      PathMustExist = OFN_PATHMUSTEXIST, \n                      NormalSaveFlags = OFN_OVERWRITEPROMPT | \n                                        OFN_PATHMUSTEXIST}; \n\n      static bool SaveDialog(Window* windowPtr, String& path, \n                             const TCHAR* filter, \n                             const vector<String> fileSuffixList, \n                             StandardDialog::SaveFlags saveFlags = \n                               NormalSaveFlags);  \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  bool StandardDialog::SaveDialog(Window* windowPtr, String& path, \n                              const TCHAR* filter, \n                              const vector<String> fileSuffixList,  \n                              SaveFlags saveFlags \n                                /* = NormalSaveFlags */) { \n\n```", "```cpp\n    OPENFILENAME saveFileName; \n    memset(&saveFileName, 0, sizeof saveFileName); \n\n    TCHAR pathBuffer[MAX_PATH]; \n    wcscpy_s(pathBuffer, MAX_PATH, path.c_str()); \n\n    saveFileName.lStructSize = sizeof saveFileName; \n    saveFileName.hwndOwner = windowPtr->WindowHandle(); \n    saveFileName.hInstance = Application::InstanceHandle(); \n    saveFileName.lpstrFilter = filter; \n    saveFileName.lpstrFile = pathBuffer; \n    saveFileName.nMaxFile = MAX_PATH; \n    saveFileName.Flags = saveFlags; \n\n    if (!fileSuffixList.empty()) { \n      saveFileName.lpstrDefExt = fileSuffixList.front().c_str(); \n    } \n    else { \n      saveFileName.lpstrDefExt = nullptr; \n    } \n\n```", "```cpp\n    while (true) { \n      if (::GetSaveFileName(&saveFileName) != 0) { \n        path = pathBuffer; \n\n        for (String fileWithSuffix : fileSuffixList) { \n          if (EndsWith(path, TEXT(\".\") + fileWithSuffix)) { \n            return true; \n          } \n        } \n\n        windowPtr->MessageBox(TEXT(\"Undefined file suffix.\")); \n      } \n      else { \n        return false; \n      } \n    } \n  } \n\n```", "```cpp\n      enum OpenFlags {NoOpenFlag = 0, \n                      PromptBeforeCreate = OFN_CREATEPROMPT, \n                      FileMustExist = OFN_FILEMUSTEXIST, \n                      HideReadOnly = OFN_HIDEREADONLY, \n                      NormalOpenFlags = OFN_CREATEPROMPT | \n                                        OFN_FILEMUSTEXIST | \n                                        OFN_HIDEREADONLY}; \n\n      static bool OpenDialog(Window* windowPtr, String& path, \n                             const TCHAR* filter, \n                             const vector<String> fileSuffixList, \n                             StandardDialog::OpenFlags openFlags = \n                               NormalOpenFlags);  \n\n```", "```cpp\n  bool StandardDialog::OpenDialog(Window* windowPtr, String& path, \n                              const TCHAR* filter, \n                              const vector<String> fileSuffixList,  \n                              StandardDialog::OpenFlags openFlags \n                                /*=NormalOpenFlags */){ \n    OPENFILENAME openFileName; \n    memset(&openFileName, 0, sizeof openFileName); \n\n    TCHAR pathBuffer[MAX_PATH]; \n    wcscpy_s(pathBuffer, MAX_PATH, path.c_str()); \n\n    openFileName.lStructSize = sizeof openFileName; \n    openFileName.hwndOwner = windowPtr->WindowHandle(); \n    openFileName.hInstance = Application::InstanceHandle(); \n    openFileName.lpstrFilter = filter; \n    openFileName.lpstrFile = pathBuffer; \n    openFileName.nMaxFile = MAX_PATH; \n    openFileName.Flags = openFlags; \n\n    if (!fileSuffixList.empty()) { \n      openFileName.lpstrDefExt = fileSuffixList.front().c_str(); \n    } \n    else { \n      openFileName.lpstrDefExt = nullptr; \n    } \n\n    while (true) { \n      if (::GetOpenFileName(&openFileName) != 0) { \n        path = pathBuffer; \n\n        for (String fileWithSuffix : fileSuffixList) { \n          if (EndsWith(path, TEXT(\".\") + fileWithSuffix)) { \n            return true; \n          } \n        } \n\n        windowPtr->MessageBox(TEXT(\"Undefined file suffix.\")); \n      } \n      else { \n        return false; \n      } \n    } \n  } \n\n```", "```cpp\n      static COLORREF customColorArray[]; \n      static bool ColorDialog(Window* windowPtr, Color& color); \n\n```", "```cpp\n  COLORREF StandardDialog::customColorArray[16]; \n\n  bool StandardDialog::ColorDialog(Window* windowPtr, \n                                   Color& color) { \n    CHOOSECOLOR chooseColor; \n    chooseColor.lStructSize = sizeof chooseColor; \n    chooseColor.hwndOwner = windowPtr->WindowHandle(); \n    chooseColor.hInstance = nullptr; \n    chooseColor.rgbResult = color.ColorRef(); \n    chooseColor.lpCustColors = customColorArray; \n    chooseColor.Flags = CC_RGBINIT | CC_FULLOPEN; \n    chooseColor.lCustData = 0; \n    chooseColor.lpfnHook = nullptr; \n    chooseColor.lpTemplateName = nullptr; \n\n```", "```cpp\n    if (::ChooseColor(&chooseColor) != 0) { \n      color.ColorRef() = chooseColor.rgbResult; \n      return true; \n    } \n\n```", "```cpp\n    return false; \n  } \n\n```", "```cpp\n      static bool FontDialog(Window* windowPtr, Font& font); \n\n```", "```cpp\n  bool StandardDialog::FontDialog(Window* windowPtr, Font& font) { \n    LOGFONT logFont = font.LogFont(); \n\n```", "```cpp\n    CHOOSEFONT chooseFont; \n    memset(&chooseFont, 0, sizeof chooseFont); \n\n    chooseFont.lStructSize = sizeof(CHOOSEFONT); \n    chooseFont.hInstance = Application::InstanceHandle(); \n    chooseFont.hwndOwner = windowPtr->WindowHandle(); \n    chooseFont.Flags = CF_INITTOLOGFONTSTRUCT | \n                       CF_SCREENFONTS | CF_EFFECTS; \n    chooseFont.lpLogFont = &logFont; \n    chooseFont.rgbColors = font.FontColor().ColorRef(); \n\n```", "```cpp\n    if (::ChooseFont(&chooseFont) != 0) { \n      font.LogFont() = logFont; \n      font.FontColor() = Color(chooseFont.rgbColors); \n      return true; \n    } \n\n```", "```cpp\n    return false; \n  } \n\n```", "```cpp\n      static Graphics* PrintDialog(Window* parentPtr, \n                                   int totalPages, \n                                   int& firstPage, int& lastPage, \n                                   int& copies, bool& sorted); \n  }; \n}; \n\n```", "```cpp\n  Graphics* StandardDialog::PrintDialog(Window* parentPtr, \n                            int totalPages, \n                            int& firstPage, int& lastPage, \n                            int& copies, bool& sorted) { \n    PRINTDLG printDialog; \n    memset(&printDialog, 0, sizeof printDialog); \n\n    printDialog.lStructSize = sizeof printDialog; \n    printDialog.hwndOwner = parentPtr->WindowHandle(); \n    printDialog.hDevMode = nullptr; \n    printDialog.hDevNames = nullptr; \n    printDialog.hDC = nullptr; \n    printDialog.Flags = PD_ALLPAGES | PD_COLLATE | \n                        PD_RETURNDC | PD_NOSELECTION; \n    printDialog.nFromPage = 1; \n    printDialog.nToPage = totalPages; \n    printDialog.nMinPage = 1; \n    printDialog.nMaxPage = totalPages; \n    printDialog.nCopies = 1; \n    printDialog.hInstance = nullptr; \n    printDialog.lCustData = 0L; \n    printDialog.lpfnPrintHook = nullptr; \n    printDialog.lpfnSetupHook = nullptr; \n    printDialog.lpPrintTemplateName = nullptr; \n    printDialog.lpSetupTemplateName = nullptr; \n    printDialog.hPrintTemplate = nullptr; \n    printDialog.hSetupTemplate = nullptr; \n\n```", "```cpp\n    if (::PrintDlg(&printDialog) != 0) { \n      bool pageIntervalSelected = \n        ((printDialog.Flags & PD_SELECTION) != 0); \n\n      if (pageIntervalSelected) { \n        firstPage = printDialog.nFromPage; \n        lastPage = printDialog.nToPage; \n      } \n      else { \n        firstPage = printDialog.nMinPage; \n        lastPage = printDialog.nMaxPage; \n      } \n\n```", "```cpp\n      copies = printDialog.nCopies; \n      sorted = (printDialog.Flags & PD_COLLATE) != 0; \n\n```", "```cpp\n      return (new Graphics(parentPtr, printDialog.hDC)); \n    } \n\n```", "```cpp\n    return nullptr; \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class PrintPreviewDocument : Document { \n    public: \n      PrintPreviewDocument(StandardDocument* parentDocument, \n                  int page = 1, Size pageSize = USLetterPortrait); \n      bool OnKeyDown(WORD key, bool shiftPressed, \n                     bool controlPressed); \n\n```", "```cpp\n      void OnSize(Size clientSize) {/* Empty. */} \n      void OnVerticalScroll(WORD flags, WORD thumbPos = 0); \n      void OnPaint(Graphics& graphics) const; \n\n```", "```cpp\n    private: \n      void SetHeader(); \n      int page, totalPages; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  PrintPreviewDocument::PrintPreviewDocument \n    (StandardDocument* parentDocument, int totalPages /* = 1 */, \n     Size pageSize/* = USLetterPortrait */) \n   :Document(PreviewCoordinate, pageSize, parentDocument), \n    page(1), \n    totalPages(totalPages) { \n\n```", "```cpp\n    SetHorizontalScrollPosition(0); \n    SetHorizontalScrollPageWidth(pageSize.Width()); \n    SetHorizontalScrollTotalWidth(pageSize.Width()); \n\n```", "```cpp\n    SetVerticalScrollPosition(0); \n    SetVerticalScrollPageHeight(pageSize.Height()); \n    SetVerticalScrollTotalHeight(totalPages * pageSize.Height()); \n\n    SetHeader(); \n    ShowWindow(true); \n  } \n\n```", "```cpp\n  void PrintPreviewDocument::SetHeader() { \n    SetName(TEXT(\"Print Preview: Page \") + to_String(page) + \n            TEXT(\" out of \") + to_String(totalPages)); \n  } \n\n```", "```cpp\n  bool PrintPreviewDocument::OnKeyDown \n         (WORD key, bool shiftPressed, bool controlPressed) { \n    switch (key) { \n      case KeyEscape: { \n          Window* parentWindow = ParentWindowPtr(); \n          ::CloseWindow(WindowHandle()); \n          parentWindow->SetFocus(); \n        } \n        break; \n\n      case KeyHome: \n        OnVerticalScroll(SB_TOP); \n        break; \n\n      case KeyEnd: \n        OnVerticalScroll(SB_BOTTOM); \n        break; \n\n      case KeyUp: \n      case KeyPageUp: \n        OnVerticalScroll(SB_LINEUP); \n        break; \n\n      case KeyDown: \n      case KeyPageDown: \n        OnVerticalScroll(SB_LINEDOWN); \n        break; \n    } \n\n```", "```cpp\n    return true; \n  } \n\n```", "```cpp\n  void PrintPreviewDocument::OnVerticalScroll(WORD flags, \n                                       WORD thumbPos /* = 0 */) { \n    int oldPage = page; \n\n    switch (flags) { \n      case SB_LINEUP: \n      case SB_PAGEUP: \n        page = max(1, page - 1); \n        break; \n\n      case SB_LINEDOWN: \n      case SB_PAGEDOWN: \n        page = min(page + 1, totalPages); \n        break; \n\n      case SB_THUMBTRACK: \n      case SB_THUMBPOSITION: \n        page = (thumbPos / pageSize.Height()) + 1; \n        break; \n\n      case SB_TOP: \n        page = 1; \n        break; \n\n      case SB_BOTTOM: \n        page = totalPages; \n        break; \n    } \n\n```", "```cpp\n    if (oldPage != page) { \n      SetHeader(); \n      SetVerticalScrollPosition((page - 1) * pageSize.Height()); \n      Invalidate(); \n      UpdateWindow(); \n    } \n  } \n\n```", "```cpp\n  void PrintPreviewDocument::OnPaint(Graphics& graphics) const { \n    StandardDocument* parentDocument = \n      (StandardDocument*) ParentWindowPtr(); \n    parentDocument->OnPrint(graphics, page, 1, totalPages); \n  } \n}; \n\n```"]