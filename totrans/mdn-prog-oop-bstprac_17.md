# *第十五章*

# 哲学

## 引言

当这本书的手稿逐渐成形时，我意识到其中很多内容是基于一种有限且天真的软件创建的*哲学*。我正在概述这种哲学如何应用于每一章，然后解释各种相关任务是什么以及它们如何融入这种哲学。以下是它的具体内容，明确地、独立于书中的其他考虑：

*我们作为软件制作者的角色是“解决问题”，而制作软件只是顺便的事情。仅仅为了制作软件而制作软件，充其量是时间和金钱的无害浪费，最坏的情况是会对那些接触到它的人造成伤害。我们始终首要考虑的是我们正在解决其问题的人，以及这些问题本身。*

如果这是 20 世纪 70 年代，你可能会称之为*新时代*的胡言乱语。如今，你可能会把它看作是那些关于成为更好的管理者的自助书籍中的废话；也许我现在应该把软件放下，去做管理咨询了。但只有通过同意一个学科的哲学，我们才能决定哪些工作代表了有价值的贡献。考虑一下科学哲学在千年间的变化（这里的讨论基于我的第一位经理约翰·沃德在牛津大学物理系的一次演讲）。

在古希腊文明中，任何你可以构建逻辑论证的结论都可以被接受为科学事实。因此，女性的牙齿比男性少，木头可以燃烧，因为它是由重土和轻火组成的，而火想要逃向天堂。这些事情被接受为真实，因为人们思考了它们，并决定它们是真实的。

在接下来的几个世纪里，科学的面貌发生了变化。理查德·P·费曼可能是在引用法国哲学家-牧师布尔迪安时表达了他的信念，即“所有知识的检验是实验”；这个观点在费曼的时代，已经花费了几个世纪的时间逐渐融入社会的科学哲学中。在皇家学会成立的时候，如果一个可敬的人在一个正确的圈子中提出了某事的证据，那么它就是真的：这就是我们如何知道海怪的存在，因为绅士们航行到美洲并报告说他们看到了它们。如果某个有声誉的人看到了什么，那么它一定在那里。

在 20 世纪，卡尔·波普尔为科学哲学提出了一个可证伪的哲学：与其寻找证明一个理论是正确的证据，不如弱化它并寻找证明它是错误的证据。这就是科学家今天采取的方法。所有这些并不是为了展示我们当前启蒙状态的进步而呈现的伟大历史。科学哲学的接受可能会随时改变。提出这个轶事的原因是为了表明，被认为是好的科学、坏的科学或值得的科学，都是*定位*在占主导地位的哲学观点之中（除了其他考虑因素，包括伦理）。通过类比，如果有人想要论证存在*好的*编程实践、坏实践或值得的实践，他们必须这样做，无论是明确还是隐含地，都要参考特定的哲学和价值体系。

在这一章的结尾，我想通过考察整体软件构建哲学的角色和输入，将整本书的内容综合起来。

## 软件作为一种追求

制作软件（为了金钱——我们将业余爱好放在一边）是一种职业吗？它是一种手艺？它是一种科学？一个工程学科？一种艺术形式？一门社会科学？

质疑专业程序员的观念很容易。职业的特点是进入门槛的教育壁垒：你不能成为一个自学成才的律师或建筑师，例如。教育确保（潜在的）从业者了解机构的知识体系和道德规范——这些在编程的“职业”中是缺失的。某些组织，如*特许信息系统学会*——[`www.bcs.org/`](http://www.bcs.org/)和**计算机协会**——[`www.acm.org`](http://www.acm.org)正在试图将其定位为这样的职业，但它们代表了少数从业者。

我们有专业风格的会议；这些会议服务于一小部分从业者，通常在问题解决研讨会和技术演示中穿插（或代替）销售说辞和自我推销。没有专业性的结论：如果你忽视编写软件的伦理，你不能被禁止编写软件。编程的伦理在*第十四章，伦理*中讨论过，并发现其很大程度上是缺失的。

将软件组织为职业的另一个困难：正如我在第十章“学习”中描述的，编程教学过于随意，无法代表核心知识体系的转移。在 1968 年推荐大学计算机课程的教学大纲时，ACM 在学术计算机科学和野外的计算实践之间划了一条厚重的界限。即使在最新版本的教学大纲中——[`ai.stanford.edu/users/sahami/CS2013/`](http://ai.stanford.edu/users/sahami/CS2013/)，专业标准和伦理影响也只是计算机科学课程提供的培训中的一小部分。（在撰写本文时，教学大纲 13 仍处于草案状态。）无疑，完成计算机科学学位的人对计算机的工作原理有很好的了解，但可以争论的是，这虽然是成为新手程序员所必需的，但并不充分。

软件从业者将我们的工作视为职业的程度，一直以来都是多样化的。这也很大程度上是按需定制的。编写软件的实践并不是一种职业，而且不会在短期内实现职业化。目前几乎所有自称为程序员的人，除非他们接受过一些适当的培训，否则都会被排除在职业之外，除非有某种方式可以“祖父式”地加入，这会削弱成为认可职业成员的价值。突然出现的“许可”程序员可用性的下降，要么会削弱企业，要么会看到他们合法或非法地使用现有的、未经许可的从业者。例如，想象一下，如果 BCS 设法在英国为该职业获得保护提名，英国的公司会等到他们的程序员成为特许专业人士后再进行 IT 项目，还是会解雇现在不合格的员工并将工作外包到国外？

那么，编程是否可以成为一种艺术形式，或者是一种结合了手工艺能力和某些技术知识的技艺或贸易？在《计算机男孩们接管》一书中，Nathan Ensmenger 为这一立场提出了有力的论据。他观察到，尽管有大量的技术知识和计算机科学可以用于编程，但许多程序员对这个知识体系只有部分了解。他们通过自学模式来增强他们的技术知识——经验告诉他们以前有效，将来也会有效的东西。任何程序员或程序员团队都会建立起一个局部的手工艺知识领域，结果是编程技艺因环境而异。

恩斯梅格纳也注意到程序员负责在“组织的科技架构和社会架构之间进行调解。”他得出结论，这种将手工艺技术与科学知识和社会整合相结合的做法，使程序员不是一个专业人士，而是一个技术人员。他还观察到，专业程序员的修辞学具有流动的界限：程序员会根据听众的不同，将他们的工作描述为科学、工程、*或*艺术。在整个讨论中请记住这一点——既要评估所描述的各种立场，也要分析我自己的结论，看看是否有 Humpty-Dumpty 主义的表现：

*“当我使用一个词时，”Humpty Dumpty 带着一种轻蔑的语气说，“它的意思就是我选择的意思——不多也不少。”*

**软件工艺运动**—[`manifesto.softwarecraftsmanship.org/`](http://manifesto.softwarecraftsmanship.org/) 使用的是深深植根于中世纪贸易学校的语言。信徒们谈论学徒制和行会成员（以及继续一个早期的参考，关于鞋子和船只和封蜡；关于卷心菜和君主们），尽管与中世纪欧洲的行会（以及他们所实践的排他性，与专业机构相当）的平行关系往往不被提及。重点是社区互动，从他人的经验中学习，并通过结合这些经验来综合一种新的工艺方法。

虽然它吸引了几百年的传统，但软件工艺显然是对“软件工程”职业的直接回应和撤退，或者也许是对它的一个稻草人观点的撤退。皮特·麦克布伦的《软件工艺》序言问道：

*软件工程是否适合于少于 100 开发者年的项目？软件工程中固有的专业化是否是一个好主意？软件开发甚至可以用工程术语来表达吗？*

就麦克布伦而言，答案当然是“不”；这里更倾向于学徒制、实践和自我组织的团队。麦克布伦告诉我们，软件工程可能适合于建造航天飞机软件，但对于生产压缩包装商业软件或内部业务应用程序来说则失败了。这类应用程序需要个性化的触摸，而一个好的程序员不仅应该理解软件构建的技术细节，还应该理解制作定制作品所需的艺术技巧。

然而，它没有解决软件工艺运动实际上是否促进了软件制作作为一种*工艺*，或者它是否像软件工程中讨论的工程版本一样，同样是一个稻草人。中世纪工艺的形象与专业贸易一样，既具有排他性和分裂性。大师工匠是该地区控制工艺实践（及其秘密技术的传播）的行会成员。除了行会成员外，只有学徒被允许实践（而且只有在其师傅允许的有限方式下）。任何完成学徒期的人都会被赶出去成为“行商”，在他们旅途中寻找一个尚未被行会控制的城镇，在那里他们可以开店，或者直到他们可以提交“杰作”并成为行会成员。

软件工艺运动中的成员将这种排他性视为吸引人的证据是显而易见的。《**软件工艺宣言**》—[`manifesto.softwarecraftsmanship.org`](http://manifesto.softwarecraftsmanship.org) 以明确和隐晦的方式阐述了这一点：

*我们开始重视 [...] 一群专业人士的社区。*

…以及隐晦的方式：

*我们开始重视 [...] 精心制作的软件。*

第二个例子相当微妙，但“精心制作的软件”究竟是什么？这是一个如此模糊的短语，唯一获得定义的方式就是加入专业人士的行会；也就是说，通过向大师们屈服。

罗伯特·C·马丁喜欢通过定义“专业人士”为那些表现出可取品质的人，而将“非专业人士”定义为那些不具备这些品质的人来区分软件语言的不同：

+   *当程序员表现出专业行为时，遗留代码并非不可避免*—[`twitter.com/unclebobmartin/status/298762801164451840`](https://twitter.com/unclebobmartin/status/298762801164451840)

+   这里是一个*最小*的列表，列出了每个软件专业人士都应该熟悉的（来自**《清洁程序员》**—[`www.amazon.com/The-Clean-Coder-Professional-Programmers/dp/0137081073`](http://www.amazon.com/The-Clean-Coder-Professional-Programmers/dp/0137081073)，第一章，*原文强调*）

+   专业人士知道他们很自大，但并不假装谦卑。专业人士了解自己的工作，并为其工作感到自豪。专业人士对自己的能力充满信心，并基于这种信心采取大胆而谨慎的风险。专业人士并不胆怯。（*《清洁程序员》，第一章*）

这里使用的语言自动在程序员之间造成了一种划分：那些符合马丁的理想的人是“专业人士”，而其他人则是，嗯，其他什么。不专业的？业余的？不是程序员？这也*同样*在专业程序员和他们合作的人之间造成了划分。经理和客户最好不要敢质疑我们的工作方式——我们在*专业*地工作。（布拉德·科克斯在他的书《超级分销：电子前沿上的对象作为财产》——[`virtualschool.edu/mon/Superdistribution/`](http://virtualschool.edu/mon/Superdistribution/)中提出了程序员和非程序员之间划分的观点，所以他写作于 1996 年时，这种划分已经存在。他半开玩笑地说：“客户，尤其是经理，的角色是站在一边，手拿支票簿，赞赏这位程序员技能的卓越和对他的手艺的奉献。”）

手工艺运动质疑软件是否*真的*是一门专业工程学科，在回答“不是”时，它推广了许多与软件工程运动或任何受监管职业相同的理想和划分。

我想提出一个不同的问题：编程*真的*是一门社会科学吗？程序员应该了解多少关于软件构建的社会、人际方面的知识？本书的大部分内容都集中在编程的协作性质上：文档、管理、团队合作和需求工程都是程序员为他人或与他人一起做的事情的例子。因此，我认为很少有情况是程序员可以*不*需要这些技能的。本章剩余部分将通过对社会科学各个分支的视角来探讨制作软件的实践。

## 软件的经济哲学

### 直接经济因素

软件产品通常作为固定期限的项目被创建或扩展。项目的预估成本与预估产生的收入进行比较，如果平衡有利，则项目获得批准。高级项目资助者会考虑*保护性收入*（如果添加此功能，有多少客户不会跳转到竞争产品）和*机会成本*（如果我们拒绝这项工作，我们可能在做些什么），将这些因素纳入项目决策中。

我提到了巴里·W·博伊姆和他的书，**《软件工程经济学**》——[`books.google.co.uk/books/about/Software_engineering_economics.html?id=mpZQAAAAMAAJ&redir_esc=y`](http://books.google.co.uk/books/about/Software_engineering_economics.html?id=mpZQAAAAMAAJ&redir_esc=y)，在**第九章，需求工程**中。他介绍了人类经济因素的概念；例如，为软件将给其用户带来的满足感（或否则）分配美元价值。我将在下一节，关于**外部性**的下一节中回到这一点，但在此刻，请记住，预期的人类经济因素被认为是**项目**成本的一部分。

所以，奇怪的是，**维护**成本在博伊姆的 COCOMO 模型中被视为项目经济的一部分。记住莱赫曼关于 E 型软件的定律，部署环境会进化，软件系统必须与之保持同步。在博伊姆的模型中，这种进化在项目成本的一个条目中得到体现。

这种维护成本估算似乎表明我们在为软件预算的方式存在问题。一些进化变化（功能添加）必须被视为明确的项目，其成本必须明确计算并与其预期的收入相平衡。其他进化变化（维护修复）只是被视为编写软件的必要风险，其成本被纳入编写新功能的计算中。

新功能总是比错误修复更大、更昂贵吗？不。错误修复总是花费我们金钱，并且从未吸引或保护收入吗？不。新功能有时会悄悄地融入维护中吗？是的。错误修复有时会推迟到新项目发布吗？是的。那么为什么它们没有被一起预算呢？

可能是出于道德原因：也许程序员认为维护问题是他们应该承认并免费纠正的错误。但记住，莱赫曼定律之一指出，软件带来的满足感会随着**社会环境**的涉及而衰减。并非所有在编写时被认为是错误的错误在编写时都是错误的！你不能为在环境变化之前你做**正确**的工作道歉。

对我来说，这表明需要一个更敏捷的经济模型；一个无论它是错误修复、功能添加还是内部质量清理，都同等对待任何变化的模型。忘记我们**已经**在这个产品上花费和制造了什么（因为这样会导致沉没成本谬误），**提议**的改变将花费多少？这将给我们带来什么？它有多大的风险？我们还能做什么？我们有什么替代方案？

### 外部性

上述问题仅考虑了制作软件的**直接**经济影响。还有其他因素；这些因素以某种形式产生成本或效益，但不会对工作的价格或收入产生实际影响。在经济学中，这些被称为**外部性**。

外部性可以是正面的，也可以是负面的，但它们也可以是个人层面的，而不是与公司及其工作相关。作为职业的软件开发具有各种外部性，包括利益和成本，这些外部性并没有反映在我们的工资中。让我们考虑那些既影响个人又影响企业的外部性。

开源软件对许多企业来说是一种正面的外部性。软件行业的许多公司采用已经免费发布的组件或系统，并将它们纳入自己的产品中，或者提供“增值”服务，如支持。这些公司从开源软件中获得价值，而无需为创建该软件付费。作为一个开源软件作为外部性的例子，编写 OpenSSH 的成本并没有计入 macOS X 的价格，尽管 OpenSSH 是该系统的一个组件。

对于个人程序员的情况则不太明确。暂时不考虑那些个人和商业目标紧密相连的微型独立软件开发者，一个求职的职业程序员可能会被要求展示他们创建或贡献的开源项目组合。我推断，*创建*开源软件具有积极的影响：它提高了我们的声誉，增加了我们被雇佣的可能性。另一方面，*创建*开源软件的行为可能是负面的：如果你不是作为工作的一部分来做这件事，那么你实际上是在增加工作量而没有直接报酬。

缺陷是负面的外部性。软件公司通常在向消费者销售时根据市场力量定价，如果他们向客户企业销售，则基于初始项目的日费率。在两种情况下，后续的维护成本都没有计入销售价格；与无需维护的相同产品相比，这将导致利润减少。客户本身并没有将缺陷计入使用软件的（经济或心理）成本。正如 David Rice 在《Geekonomics: the real price of insecure software》一书中所论证的——[`books.google.co.uk/books/about/Geekonomics.html?id=k6cRhfp2aWgC`](http://books.google.co.uk/books/about/Geekonomics.html?id=k6cRhfp2aWgC)，在评估软件产品时，客户通常只有功能清单可以参考，无法了解其质量。但质量是有成本的；你支付测试人员，你分类处理缺陷报告，你监控支持渠道以发现问题，并致力于修复工作。

一些组织会举办黑客马拉松或黑客日，在这些活动中，人们通常会组成团队，为某些挑战提供基于软件的解决方案，获胜者将获得奖品。这些黑客日可能会对职业生涯产生积极影响，因为一些雇主可能会将参与黑客日视为社区参与的证据，并且它们提供了“磨砺锯子”和尝试新技能或工具的机会。另一方面，花费更多时间工作（尤其是在某些黑客日中需要的通宵达旦）会对你的健康产生不利影响，这是一个负面影响。

最后，考虑一下制作软件产品所投入的所有工作是否都反映在标签价格上。如果你在制作用户指南上花费的金额加倍，价格会上涨吗？可能不会。同样适用于本地化：你将拥有更大的潜在客户池，但大部分情况下，你无法提高价格。这表明，对你的客户来说，本地化是一种外部性：本地化软件的好处，但不是改变他们支付金额的好处。

公司可以通过内部收费或将成本或节省转嫁给客户来将他们对外部性的价值纳入其决策中：一个简单的例子是，如果允许他们共同品牌化最终产品，一些代理公司会对项目收取更少的费用。代理品牌与产品的关联以及可能推动未来工作的可能性是一种正外部性。将节省转嫁给客户——即在存在正外部性时降低成本——显然比转嫁负外部性的费用更易于接受，但后者是可以做到的。想想有机食品的价格溢价——[`www.mint.com/blog/trends/organic-food-07082010/`](https://www.mint.com/blog/trends/organic-food-07082010/)，这比生产成本差异（在某些情况下，由于补贴可能低于非有机食品）要高。通过说服购买者有机食品确实有实际的好处，供应商可以要求更高的价格。

### 传统供需经济学

许多经济学教科书都会从讨论供需作为影响市场价格的关键因素开始：当需求高或供给低时，价格上升；当需求低或供给高时，价格下降。将这种经济结构应用于软件定价的问题在于供给是无限的：没有“单位成本”，所以一旦软件制作完成，就可以不断复制，直到所有想要副本的人都有为止。那么，软件如何才能在价格不立即跌至零的情况下进行销售呢？

面对证据，有些人不相信这是可能的。这就是**数字版权管理**的宗旨：试图将物理商品的稀缺性重新引入软件（和其他数字商品）的经济学中。但人们确实成功地销售了软件、音乐、文档（例如这一篇）等，而没有使用 DRM。我们不仅要注意到无限供应“问题”并试图限制供应，还需要尝试理解那个确实存在、可持续，但与长期模型不匹配的市场。

我将从假设开始：所交易的不是软件本身，而是首先*能力*，其次是*时间*。鉴于有做某事的愿望，但无法做到，任何通过使该事物成为可能来解决该问题的东西都是有价值的。这就是经济学家赫伯特·西蒙描述的**有限理性**，或**满意解法**—[`www.economist.com/node/13350892`](http://www.economist.com/node/13350892)。因此，第一个发现的解决方案，无论是否理想，都是有价值的。这已经解释了为什么无限供应“问题”不是真实的：在发现可以购买到满足他们需求的产品时，消费者可能会满足于作为满意解法进行购买——许多人不会花额外的时间去研究盗版应用。对于一些人来说，使用盗版应用*确实*会带来成本，即焦虑。任何与一个人的道德相悖的决定，无论多么理性，都会产生心理成本。信息安全行业将这一点视为通过政策控制安全的限制因素之一。

找到问题确实可以解决后，顾客随后可以花一点时间思考如何改进这个解决方案。这就是节省时间的地方。现在他们知道*自己能够做什么*，就有可能提高这种能力，以便有更多的时间去做其他事情：这也很有价值，正如本杰明·富兰克林所明确指出的。（这个论点以修改后的形式适用于游戏。只需颠倒这两个因素。*鉴于*我有时间可用，你能提供让我享受其过程的*能力*吗？）

在这个模型中，软件本身没有价值，这与传统经济学的无限供应问题相符合。但顾客的时间和能力是有限的，软件可以用作工具来解锁这些。从这个意义上说，为软件付费类似于为教育付费：你想要的不是*教学*，而是*已经受过教育*。因此，我们可以这样说，软件的价值不在于*创造解决问题的方案*，而在于*问题已经被解决*。由于满足的本质，如果成本和能力“足够好”，顾客会为解决方案付费。

回顾本章的第二段，我们看到这种经济模式只是同样的哲学，用经济术语表达。我们作为软件制作者的角色是*解决问题*——我们通过*解决问题*为我们的客户提供有价值的服务。

## 软件管理哲学

想象一个世界，在这个世界里，程序员的地位与中层管理者相似。但首先，请摒弃管理者天生无用且邪恶的观念，让我来解释一下管理者的定义。

管理者通常不会因为工作而获得报酬；他们通常根据团队的工作表现和团队完成的工作量来获得报酬。大量工作做得不好并不好，但工作做得不够好也不理想。

这通常意味着他们会避免做工作。给他们一些工作要做，他们通常的做法是找到团队中最有能力完成这项工作的人，并让他们去做。他们会让那个人负责完成工作，并且（如果他们做得好）给予他们完成工作的权限。

但他们并不是因为告诉别人如何做工作，或者因为委托责任或授权的任务而获得报酬。事实上，如果工作没有完成，或者没有做好，那么公司其他部门会认为*管理者*应该负责。他们是因为工作已经完成而获得报酬。

*现在*，想象一个程序员与中层管理者一样被重视的世界：一个程序员是管理者，计算机向程序员汇报的世界。程序员不是因为*编写软件*——向计算机解释需要完成的工作而获得报酬。程序员是因为计算机*完成了分配的工作*而获得报酬，无论是数量足够还是质量足够。如果计算机没有完成工作，那么*程序员*将承担责任。

再次强调，这只是在章节开头所采取立场的重申。虽然前一个部分的重申告诉我们购买软件的人重视什么，但这一点告诉我们，在软件制作人身上应该考虑什么是有价值的。我们看到，“编写的代码行数”、“完成的用户故事点数”、“增加的功能数量”和“修复的 bug 数量”本身并不是有价值的东西，但也许我们可以看到每个指标作为我们工作有用*代理*的程度。

## 软件社会哲学

在第九章“需求工程”中，你了解到软件并非独立存在，而是嵌入在其使用的社交系统中。本书的其余部分主要讨论了另一个社交系统：软件的开发系统。许多软件是由多个人共同制作的。即使在罕见的情况下，一个人完成了所有的*生产*（编码、设计、UI 文本、营销、销售等），也可能会有些客户反馈，即使那只是以支持邮件的形式。

那么，这些两种社会系统在这个领域是如何被考虑的？典型的程序员形象是某人（通常是 20 多岁的白人男性），独自工作，盯着显示器。如果外界被承认，那也是通过其排除：程序员戴上耳机以避免干扰，编写代码。（在撰写本文时，以及就我的观点而言，*谷歌图片搜索“程序员”*的结果——[`www.google.co.uk/search?q=programmer&aq=f&um=1&ie=UTF-8&hl=en&tbm=isch&source=og&sa=N&tab=wi&ei=4J2TUbOrOZSV0QWI7YHABQ&biw=2560&bih=1368&sei=452TUcKIFoi40QXmjIDYCQ`](https://www.google.co.uk/search?q=programmer&aq=f&um=1&ie=UTF-8&hl=en&tbm=isch&source=og&sa=N&tab=wi&ei=4J2TUbOrOZSV0QWI7YHABQ&biw=2560&bih=1368&sei=452TUcKIFoi40QXmjIDYCQ)支持了这种“典型”形象的描述。）

我们在这里自动看到了各种问题。制作软件的人是程序员，而不是其他任何相关专家。他是男性，而不是女性或跨性别者。他是白人，而不是其他任何种族。他是年轻人，而不是老年人。他是独自一人，而不是与他人一起工作。所有这些不平等都存在于软件制作者的*描绘*中。所有这些都未能捕捉到围绕软件系统的社会系统的多样性和复杂性。许多这些不平等存在于软件制作者的描绘中，因为它们存在于软件制作的*现实*中。

社会科学家会对他们研究的任何社会系统提出两个高级问题：社会是如何构建和修复的？它支持哪些分化和不平等？通过审视“传统”的程序员观点，我们已经看到了软件行业目前支持的一些不平等。

我们可能还能找到更多。Shanley Kane *研究了硅谷初创公司使用的语言*——[`blog.prettylittlestatemachine.com/blog/2013/02/20/what-your-culture-really-says`](http://blog.prettylittlestatemachine.com/blog/2013/02/20/what-your-culture-really-says)，寻找潜在的偏见，例如：

#### 我们没有休假政策

你的文化可能实际上在说……我们欺骗自己认为我们有一个更好的工作/生活平衡，而实际上人们即使有休假政策，休假时间也比没有休假政策时还要少。社会压力和对工作的沉迷已经取代了政策，成为休假时间的调节器。

如果这是真的，那么这表明那些能够工作更长的时间并且休假更少的人在这个系统中处于相对有利的地位。这反过来又赋予了某些阶级特权：例如，那些年轻且没有孩子的阶级。

那么，这就是软件是*制造*的社会系统。那么，软件是*使用*的社会系统又如何呢？那里也存在不平等和分化。商业软件系统（甚至运行在商业平台上的免费软件系统）只有那些买得起的人才能访问。

在英国，国家统计局**估计有超过 700 万人从未使用过互联网**。他们确定了互联网接入能力与人口统计状况之间的相关性，因此在线服务（例如）不太可能对 75 岁以上的人或残疾人可用（在我们考虑特定服务是否具有开发者通常理解的“可访问性”功能之前，这种可访问性的缺乏就已经存在了。）

还可以找到其他不平等。许多应用程序只支持英语，而且即使它们*可以*本地化，它们也不处理非格里高利日历、从右到左的书写系统、带变音符号的字符以及其他“非英语”（或非美国）地区特性。

知道这些不平等存在（其他也存在）并报告它们是一回事，但可能并不新颖。我们该如何利用这种意识呢？

你觉得哪些不平等是不公正的，这很可能取决于你的政治观点，尽管前一章中描述的伦理文件为我们提供了一个实用的指南。从**ACM 伦理准则**—— [`www.acm.org/about/code-of-ethics`](http://www.acm.org/about/code-of-ethics)：

*不同群体之间可能存在的不平等可能源于信息和技术的不当使用。在一个公平的社会中，所有个人，无论种族、性别、宗教、年龄、残疾、国籍或其他类似因素，都应享有平等的机会参与或从计算机资源的使用中受益。然而，这些理想并不能证明未经授权使用计算机资源的合理性，也不能为违反本准则的任何其他伦理规范提供充分的依据。*

这相当明确。ACM 期望其成员遵守的，是在其他伦理准则范围内的**完全不歧视**——正如以往一样，潜在的伦理冲突仍然存在。从特权方窃取计算机资源供弱势方使用（我将其称为“罗宾汉调度”）就是这种冲突的一个例子。

在歧视中需要注意的一个重要因素是**他者化**。社会心理学家区分了**标记身份和非标记身份**——[`cak400.wordpress.com/2012/10/01/marked-and-unmarked-identities-and-social-hierarchy/`](http://cak400.wordpress.com/2012/10/01/marked-and-unmarked-identities-and-social-hierarchy/)。一个“非标记”的身份是人们认为正常的东西，而其他身份通过不同于这个基准来区分（“标记”）。谈论移民的人是在**标记**一些人作为移民，并由此隐含地将本土人定义为正常。谈论女性的人是在**标记**一些人作为女性，并隐含地将男性定义为正常。

关于“他者化”的重要方面是这种区别的不对称性质：它是在“正常”人和“不像我们的人”之间。重要的是要认识到我们*确实*这样做，这是我们的思维方式，要*识别*我们何时这样做，并自觉地*纠正*它。正如 *Mike Lee* 所说—[`twitter.com/bmf/status/333960606837272577`](https://twitter.com/bmf/status/333960606837272577)：

*我们把那些我们自己在自己身上拒绝的品质放入其他人的身上。但这使我们忽视了现实。*

所以，下次当你认为“普通人不会想要*那个*功能”或“任何有常识的人都不会那样使用它”时，问问自己你是否真的认为“不像我的人不会想要那个”，然后考虑你是否在为像你这样的人的少数人编写软件，还是为所有人编写。

## 软件的教育哲学

这是哲学章节中最技术性和最基础的组成部分，也是我最没有资格谈论的部分。我在大学教了几年编程，但作为大学教学最明显的特征之一是，在你开始之前没有人会培训你，我不确定这算不算。

很容易找到这样的断言：*学术计算机科学与实践无关*—[`shape-of-code.coding-guidelines.com/2013/05/15/wot-apply-academic-work-in-industry/`](http://shape-of-code.coding-guidelines.com/2013/05/15/wot-apply-academic-work-in-industry/) 和 *计算机科学不足以作为软件职业的准备*。这是一个问题吗？如果是，原因是什么？有哪些替代方案？

商业软件和学术软件实践之间的差异在计算机历史的早期就已经开始。在《*软件作为一项追求*》中描述的 ACM 课程的第一版是**课程 68**—[`dl.acm.org/citation.cfm?id=362976`](http://dl.acm.org/citation.cfm?id=362976)。在这门课程的介绍中，作者明确指出，学术计算机科学课程不适合培训专业 IT 人员：

*例如，这些建议并不是针对计算机操作员、编码员和其他服务人员的培训。对于这些职位以及许多编程职位，可能最好由应用技术项目、职业学院或大专院校提供培训。也很有可能，在商业数据处理、科学研究、工程分析等领域的大多数应用程序员将继续是受过相关学科领域教育的专家，尽管这样的学生无疑可以通过参加一些计算机科学课程而受益。*

因此，课程是在这样的认识下创建的：它**不会**直接适用于那些希望成为专业程序员的人。虽然存在职业课程，但遇到没有接受过该领域正规介绍的有能力自学程序员是非常常见的——包括我自己。世界上关于如何制作软件的信息**很多**，自学的人必须以某种方式发现这些信息：最终，很多知识将通过试错来学习。《软件工程知识体系》（[`www.computer.org/education/bodies-of-knowledge/software-engineering`](https://www.computer.org/education/bodies-of-knowledge/software-engineering)）可以被视为从已发表的软件工程文献中学习内容的指南。当以书籍的形式呈现时，这个指南比本文更长。就像这本书一样，指南本身并不处于“这是如何制作软件”的水平，而是处于“在制作软件时应牢记的这些事情”的水平。因此，我们有一个 200 页的指南，涵盖了 13 个“知识领域”，这些领域包括你应该知道的事情列表，并附带一些对可用文献的引用。知识领域、每个领域选择的主题以及参考文献的时效性和有效性都是（正如你可能从这个领域预料到的）有争议的，因此**SWEBOK**（**软件工程知识体系**）代表了保守选择的一组已经广泛应用的观念。

自学程序员如何才能跟上这个庞大且不断发展的知识体系？支持“软件作为一门职业”的人会说他们不能；他们认为这是专业机构的责任去教授和维护知识体系，并确保只有跟上进度的人才能被认为是程序员。支持“软件作为一门手艺”的人也会说他们不能：他们认为他们需要来自学徒期的专家指导，然后是作为熟练工人的自我探索期。

但是，反思第十章“学习”，我必须问：SWEBOK 除了是一个学习课程，无论是教授的还是自学的，还有什么吗？它以相当抽象的水平（以及非常枯燥的风格）呈现，因此可能更适合教师决定教什么，而不是初学者试图找出要**学习**什么。

那些内容——不一定是 SWEBOK 本身，但类似于它——可以很容易地改编成自学指南。我发现最合适的模式是能力矩阵：我在过去几年中，将我对计算机科学的知识与**程序员能力矩阵**（[`www.starling-software.com/employment/programmer-competency-matrix.html`](http://www.starling-software.com/employment/programmer-competency-matrix.html)）进行了评估，并在撰写本文的过程中创建了**程序员礼仪矩阵**（[`blog.securemacprogramming.com/2013/04/rebooting-the-programmer-competency-matrix/`](http://blog.securemacprogramming.com/2013/04/rebooting-the-programmer-competency-matrix/)），以总结材料。

矩阵成功的地方在于，它为学习者提供了一个方便的方式来评估自己的进度（无论是通过反思，还是与评估者或教育者的讨论），并了解在矩阵的任何特定行中需要什么来前进。列布局提供了关于“接下来”是什么以及可以留到“以后”的指导。

*这种排序是我职业生涯早期遇到的一个难题。我在一家大型公司工作，该公司有通过技术角色的晋升途径：软件工程师、高级软件工程师、资深软件工程师和软件架构师。我被雇佣在第一个级别，但很快就被提升为高级软件工程师。因为我专注于下一个级别，所以我试图在巩固和扩展我对高级角色的理解之前，学习资深工程师的职责。因此，我没有成为一个特别好的资深工程师：这是继续前进的先决条件。*

矩阵在**SWEBOK**做得好的部分**失败**了：为每个级别提供参考资料，让学习者知道*在哪里*找到进步所需的信息。这部分课程内容更加具体：自学课程可能会指向书籍、文章、会议演讲或网站，以了解学习资源；而指导学习课程可能会建议特定的培训或大学课程，或者由教育者评估的问题集。关键是，没有理由一个自学程序员不能，通过能力矩阵提供的领域意识和自身能力，像职业程序员一样进步——可能进度比教授或硕士程序员慢，但仍然在进步。

将这次讨论（以及*第十章，学习*）与本章开头的位置声明联系起来，软件制作者的教学实际上应该被视为在软件系统背景下进行*问题识别和解决方案*的教学。从这个角度看，学术和商业领域的教学目标是一致的；只是选择要解决的问题（因此关注知识体系中的特定领域，相当于能力矩阵中的特定行）不同。

对于新手程序员，无论是自学成才、学徒出身还是受过教育（请注意，这句话中不存在错误的二分法；自学和学徒出身的程序员并非“未受过教育”，他们只是没有从教育者那里学习如何制作软件*而已*），从爱好者到专业软件制作的课程——无论软件是在何种背景下制作的，无论我们选择何种“专业”的具体定义——都始于对软件作为解决问题的手段而非目的本身的*认识*。下一步是认识到他们新手能力与当前技术水平之间的差距。他们选择如何填补这个差距并不那么重要，重要的是认识到这个差距的存在。

## 成为“擅长”制作软件意味着什么？

关于制作软件的人的生产力，有很多说法。许多人声称*有些程序员的生产力是其他程序员的 10 倍*——[`www.johndcook.com/blog/2011/01/10/some-programmers-really-are-10x-more-productive/`](http://www.johndcook.com/blog/2011/01/10/some-programmers-really-are-10x-more-productive/)。这*意味着*什么？

想要得出一个数量，即使是像“10 倍”这样的相对数，我们可能有一些可以应用于在不同背景下制作软件的人的定量指标。这个数量是什么？是编写的具有重大意义的代码行数吗？如果是这样，我们应该解雇那些*一天只写-2000 行代码的程序员*——[`folklore.org/StoryView.py?story=Negative_2000_Lines_Of_Code.txt`](http://folklore.org/StoryView.py?story=Negative_2000_Lines_Of_Code.txt)？

那么，修复一个错误所需的时间，最初是用来发现 10 倍数的指标（针对少数程序员）？也许程序员并没有更有效率，但我们*恰好捕捉到了他们效率高的一天*？那么，那个花了更多时间确保错误最初就不存在的人呢？这个人是不是更勤奋，还是在浪费时间进行过度设计？

如果你接受这里提出的软件制作观点，那么一个人能编写的软件数量，无论你如何衡量，都与制作人是否优秀无关。相关的问题是，软件制作人从（或引入）他们的客户正在工作的系统中移除了多少问题。

*这种生产力度量标准最有效的展示之一来自一位朋友，他被一位潜在客户要求设计一个移动应用程序来解决客户业务中存在的特定问题。在与客户会面并讨论他们的问题后，这个人观察到电子表格比移动应用程序是一个更好的解决方案。因此，他们拒绝了浪费客户金钱创建次优解决方案的机会。那个人可以写出电子表格，软件制造商可以将他们的注意力转向更合适的技能应用。*

不幸的是，关于软件在系统中的净效应是解决问题还是引入问题的问题尚未得到解答，也许在系统变得庞大时是无法回答的。例如，直到 20 世纪 80 年代，西方组织中的许多办公室都雇佣了主要由女性组成的打字员，尽管工资较低且环境嘈杂。在引入台式电脑后，那些打字员被那些使用文字处理应用程序准备自己文档的传统上地位较高的工作人员所取代。那些应用程序以及它们运行的电脑得到了主要由男性 IT 支持工作团队的支撑。

对于经历了这些变化的企业来说，IT 支持部门与打字员相比，其成本效益是更高还是更低？使用文字处理器的打字是否比为打字员手写稿件更有效地利用了高管的时间？台式电脑和办公打印机是否比几十台打字机造成的问题更少，还是更多？

在社会层面，失业的打字员是否从打字员的专制中解放出来，或者他们被排除在劳动力之外？电脑对性别平等是好事还是坏事？软件是否创造了比它消除的更多机会？

这些问题是复杂的，我将不回答它们就结束。只需说，虽然我们新的生产力度量标准在哲学上比代码行数等事物更好，但应用起来要困难得多。

## 结论

我写这本书是为了反思我所知道的关于制作软件的知识，以及理解我关于制作软件所不知道的知识。我出版它是为了让你们能够利用我在从事这一职业的十年中所发现的东西，并激发你们对自己经历的反思（希望你们能像我所做的那样与我们分享）。

我首先从我们在煤场工作时的事情开始：我们用来将想法转化为软件的工具和实践。然后我观察了我们如何与其他人合作：我们如何记录我们所做的工作；我们如何找出需要编写的软件；我们如何利用机会从他人那里学习，解释他人的论点，并在团队或商业环境中与他们合作。最后，我试图构建一个高级模型，将所有这些工作定位其中，通过考虑制作软件的伦理和哲学，以及如何通过教授这一代新手的技能来推进我们的知识。

通过这个过程，我发现，虽然计算机科学可能能够告诉我们关于我们在计算机上使用的编译器和语言的一些信息，但软件产品不能脱离它们被制作和使用的*社会*系统。心理学、社会学、民族志和经济学：所有社会科学都有智慧可以传授，可以帮助我们作为软件制作者使用我们的技能来解决人们的问题。

不幸的是，这项工作以一个困境结束：虽然不同的软件制作者群体已经确定了避免歧视的道德必要性，但我们不能明确地说我们的行业没有在其影响的社会中造成*新的*分裂和不平等。关于是否使用 Web 或本地技术，或者是否使用函数式或面向对象的编程风格是“更好”的问题，要么会被回答，要么变得无关紧要，或者两者都会。我们工作是否消除或加强了人与人之间的分裂的问题永远不会消失，这将是历史评判我们所作所为的标准。
