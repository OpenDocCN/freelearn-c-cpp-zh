<html><head></head><body>
<div><div><div><h1 id="_idParaDest-173" class="chapter-number"><a id="_idTextAnchor303"/>11</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor304"/>Analog-to-Digital Converter (ADC)</h1>
			<p>In this chapter, we will learn about the <strong class="bold">analog-to-digital converter</strong> (<strong class="bold">ADC</strong>), an important peripheral in embedded systems that enables the microcontroller to interface with the analog world. We will start by providing an overview of the analog-to-digital conversion process, the importance of the ADC, and its key specifications.</p>
			<p>Following this, we will extract and analyze the relevant registers from the STM32F411 reference manual that are necessary for ADC operations. Finally, we will develop a bare-metal ADC driver to demonstrate the practical application of the theoretical concepts we’ve discussed.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Overview of <a id="_idTextAnchor305"/>analog-to-digital conversion</li>
				<li><a id="_idTextAnchor306"/>The STM32F4 ADC peripheral</li>
				<li><a id="_idTextAnchor307"/>The key ADC registers and flags</li>
				<li><a id="_idTextAnchor308"/>Developing the ADC driver</li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of the STM32 ADC peripheral and the skills necessary to develop efficient drivers for it, enabling you to effectively integrate analog-to-digital conversion capabilities into your embedded systems projects.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor309"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor310"/>Overview of analog-to-digital conversion</h1>
			<p>ADC is a critical <a id="_idIndexMarker759"/>process in embedded systems that allows our microcontrollers to interpret and process real-world analog signals. In this section, we will walk through this process, explaining each step involved in converting an analog signal into digital values.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor311"/>What is analog-to-digital conversion?</h2>
			<p>Analog-to-digital conversion is the process of converting a continuous analog signal into a discrete digital representation. Analog signals, which can have any value within a certain range, are transformed into digital signals, which have specific, quantized levels. This conversion is essential because microcontrollers and digital systems can only process digital data.</p>
			<p>The conversion process typically involves several key steps: sampling, quantization, and encoding. Let’s break down these steps, starting with sampling.</p>
			<h3>Sampling</h3>
			<p><strong class="bold">Sampling</strong> involves measuring the <a id="_idIndexMarker760"/>amplitude of an analog signal at regular intervals, called <strong class="bold">sampling intervals</strong>. The result is a series of discrete values<a id="_idIndexMarker761"/> that approximate the original analog signal. <em class="italic">Figure 11</em><em class="italic">.1</em> depicts this process:</p>
			<div><div><img src="img/B21914_11_1.jpg" alt="Figure 11.1: The sampling process" width="1224" height="304"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: The sampling process</p>
			<p>The rate at which the analog signal is <a id="_idIndexMarker762"/>sampled is known as the <strong class="bold">sampling rate</strong> or <strong class="bold">sampling frequency</strong>. This is<a id="_idIndexMarker763"/> typically measured in samples per second (Hz). According<a id="_idIndexMarker764"/> to the <strong class="bold">Nyquist Theorem</strong>, the sampling rate<a id="_idIndexMarker765"/> must be at least twice the highest frequency present in the analog signal to accurately reconstruct the original signal.</p>
			<p>The next step in the process is<a id="_idIndexMarker766"/> quantization.</p>
			<h3>Quantization</h3>
			<p><strong class="bold">Quantization</strong> is the process of <a id="_idIndexMarker767"/>mapping the sampled analog values to<a id="_idIndexMarker768"/> the nearest discrete levels available in the digital domain. Each discrete level corresponds to a unique digital code.</p>
			<p>The number of discrete levels available for quantization is determined by the resolution of the analog-to-digital converter. For example, an <em class="italic">8-bit ADC has 256 levels (28)</em>, while a <em class="italic">12-bit ADC has 4096 </em><em class="italic">levels (212)</em>.</p>
			<p>The quantization process inherently introduces an error, known as <strong class="bold">quantization error</strong> or <strong class="bold">quantization noise</strong>, because the exact analog<a id="_idIndexMarker769"/> value is approximated to the nearest digital level. We <a id="_idIndexMarker770"/>can minimize this error by increasing the resolution of the ADC. For example, if an analog signal ranges <em class="italic">from 0 to 3.3V</em> and an <em class="italic">8-bit ADC</em> is used, the quantization step size is approximately <em class="italic">12.9 mV (3.3V / 256)</em>. An analog input of <em class="italic">1.5V</em> might be quantized to the closest digital level, which could be slightly higher or lower than <em class="italic">1.5V</em>.</p>
			<p>The final step in the process is encoding.</p>
			<h3>Encoding</h3>
			<p><strong class="bold">Encoding</strong> is the final step and is <a id="_idIndexMarker771"/>where the quantized levels are converted into a<a id="_idIndexMarker772"/> binary code that can be processed by the digital system. Each quantized level is represented by a unique binary value.</p>
			<p>The number of bits used in the ADC determines the binary code length. For example, a <em class="italic">10-bit</em> ADC will produce a <em class="italic">10-bit</em> binary number for each sampled value. Continuing with our previous example, if the quantized level for <em class="italic">1.5V</em> is determined to be level <em class="italic">116</em>, the binary representation would be <em class="italic">01110100</em> for an <em class="italic">8-bit</em> ADC.</p>
			<p><em class="italic">Figure 11</em><em class="italic">.2</em> shows the encoding process of a <em class="italic">6-bit ADC</em>. The columns in the table show the 6-bit binary representation of the quantization levels. For a 6-bit ADC, the digital output ranges from <code>000000</code> for the lowest quantization level to <code>111111</code> for the highest. Each binary value corresponds to a specific quantization level:</p>
			<div><div><img src="img/B21914_11_2.jpg" alt="Figure 11.2: The encoding process" width="1380" height="353"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: The encoding process</p>
			<p>In s<a id="_idTextAnchor312"/>ummary, the analog-to-digital conversion process begins with an analog input signal, which can vary continuously over time. This signal could be a voltage from a temperature sensor, an <a id="_idIndexMarker773"/>audio signal, or any other analog signal. The analog-to-digital converter typically includes a sample-and-hold circuit that captures and holds the analog signal at each <a id="_idIndexMarker774"/>sampling interval. This ensures that the signal remains constant during the conversion process. The core of the ADC performs quantization and encoding. It compares the held analog value to a set of reference voltages to determine the closest matching digital level. The resulting digital code is output from the ADC and can be read by our microcontroller or digital system for further processing.</p>
			<p>In the next section, we will explain some of the key terms that were used in this section, including resolution and <strong class="bold">reference </strong><strong class="bold">voltage</strong> (<strong class="bold">VREF</strong>).</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor313"/>Key specifications of the ADC – resolution, step size, and VREF</h2>
			<p>To effectively use ADCs, it’s important to<a id="_idIndexMarker775"/> understand their key specifications, which define their performance for various applications. Let’s start with resolution.</p>
			<h3>Resolution</h3>
			<p>The resolution of an ADC determines the<a id="_idIndexMarker776"/> number of distinct output levels it can produce, corresponding to the number of intervals the input voltage range is divided into. It is typically expressed in bits. Higher resolution allows us to have a more precise representation of the analog input signal, reducing quantization error and improving the accuracy of measurements.</p>
			<p>For an <em class="italic">N-bit</em> ADC, the number of discrete output levels is <em class="italic">2N</em>. For example, an <em class="italic">8-bit</em> ADC has <em class="italic">256(28)</em> levels, while a <em class="italic">12-bit</em> ADC has <em class="italic">4,096</em> levels.</p>
			<p><em class="italic">Table 11.1</em> shows common<a id="_idIndexMarker777"/> ADC resolutions and their corresponding number of discrete levels. The following table highlights how the number of discrete levels increases exponentially with the resolution, providing finer granularity in the digital representation of the analog input signal:</p>
			<table id="table001-6" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">ADC </strong><strong class="bold">Resolution (bits)</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Number of Discrete </strong><strong class="bold">Levels (2^N)</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>8</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>256</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>10</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1,024</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>12</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>4,096</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>14</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>16,384</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>16</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>65,536</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>18</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>262,144</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>20</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1,048,576</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>24</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>16,777,216</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1: Common ADC resolutions</p>
			<p>The next key specification is the <strong class="bold">VREF</strong>.</p>
			<h3>VREF</h3>
			<p>The VREF is the maximum voltage that<a id="_idIndexMarker778"/> our ADC can convert. The analog input voltage is compared to this VREF to produce a digital value. The stability and accuracy of the VREF directly impact the accuracy of the ADC as any fluctuations in the VREF can cause corresponding errors in the digital output.</p>
			<p>We can choose to derive the VREF from the microcontroller or provide an external one for more precise applications. Internal references are convenient but might have higher variability, while external <a id="_idIndexMarker779"/>references can offer better stability and accuracy. The choice of VREF depends on our application’s accuracy requirements and the nature of the analog signal being measured.</p>
			<p>For example, if the VREF is 5V, the ADC can accurately convert any analog input signal within the range of 0V to 5V.</p>
			<p>The last specification we’ll examine is the step size.</p>
			<h3>Step size</h3>
			<p>The step size is the smallest <a id="_idIndexMarker780"/>change in analog input that can be distinguished by the ADC. It is determined by the VRED and the resolution and it determines the granularity of the ADC’s output. A smaller step size indicates finer resolution, allowing the ADC to detect smaller changes in the input signa<a id="_idTextAnchor314"/>l.</p>
			<p>The step size is calculated by <em class="italic">dividing the VREF by 2 raised to the power of the ADC’s resolution</em> (number of bits<a id="_idTextAnchor315"/>):</p>
			<p><img src="img/4.png" alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;/mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;N&lt;/mi&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.502em;height:1.487em;width:6.186em" width="258" height="62"/></p>
			<p>Here, <em class="italic">VREF</em> is the reference voltage and <em class="italic">N</em> is the resolution bits.</p>
			<p>For example, for a 10-bit ADC with VREF = 3.3V:</p>
			<p><img src="img/5.png" alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;3.3&lt;/mn&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;3.3&lt;/mn&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;1024&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3.22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.495em;height:1.482em;width:13.696em" width="574" height="62"/></p>
			<p>This means that each increment in the quantized digital output corresponds to a <em class="italic">3.22mV</em> change in the analog input. <em class="italic">Table 11.2</em> lists common ADC resolutions, the corresponding number of steps, and the step size using a VREF of 3.3V:</p>
			<table id="table002-3" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">ADC </strong><strong class="bold">Resolution (Bits)</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Number of </strong><strong class="bold">Steps (2^N)</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Step </strong><strong class="bold">Size (mV)</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>8</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>256</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>12.9</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>10</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1,024</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>3.22</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>12</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>4,096</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0.805</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>14</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>16,384</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0.201</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>16</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>65,536</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0.0504</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>18</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>262,144</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0.0126</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>20</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1,048,576</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0.0032</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>24</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>16,777,216</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0.000197</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2: ADC resolutions and step sizes at 3.3V VREF</p>
			<p>This table provides a clear view of how the step size decreases with increasing resolution, allowing for finer granularity in the digital representation of the analog input.</p>
			<p>This concludes our<a id="_idIndexMarker781"/> overview of the analog-to-digital conversion process. In the next section, we will examine the ADC peripheral of our STM32 microcontroller.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor316"/>The STM32F4 ADC peripheral</h1>
			<p>Our STM32F411 microcontroller features a 12-bit ADC capable of measuring signals from up to <em class="italic">19 multiplexed channels</em>. The ADC can operate in various modes, such as single, continuous, scan, or <a id="_idIndexMarker782"/>discontinuous, with the results stored in <em class="italic">a 16-bit data register</em>. Additionally, the ADC has an analog watchdog feature that allows the system to detect when the input voltage exceeds predefined thresholds.</p>
			<p>Before we explain the various ADC modes, let’s understand what we mean by ADC channels.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor317"/>The ADC channels</h2>
			<p>An <strong class="bold">ADC channel</strong> is a dedicated <a id="_idIndexMarker783"/>pathway through which an<a id="_idIndexMarker784"/> analog signal is fed into the ADC so that it can be converted into a digital value. Each ADC channel corresponds to a specific GPIO pin configured to operate in analog mode.</p>
			<p>Sensors, which produce analog signals representing physical phenomena (such as temperature, light, or pressure), are interfaced with our microcontroller through these GPIO pins. By configuring a GPIO pin as an analog input, the microcontroller can receive the sensor’s analog <a id="_idIndexMarker785"/>output signal on the corresponding ADC channel. The ADC then converts this continuous analog signal into a discrete digital representation that the microcontroller can process, analyze, and use for further decision-making tasks in our embedded systems applications.</p>
			<p>You might be wondering, does having 19 channels mean we have 19 separate ADC modules? This is where multiplexing comes into play.</p>
			<h3>Multiplexing ADC channels</h3>
			<p><strong class="bold">Multiplexing</strong> allows the ADC to switch<a id="_idIndexMarker786"/> between different input signals, sampling each one sequentially. This is achieved<a id="_idIndexMarker787"/> using an analog multiplexer (MUX) within the ADC peripheral. As we learned earlier, each of the ADC channels is connected to a specific GPIO pin configured for analog input. The analog MUX selects which analog input signal (from the GPIO pins or internal sources) is connected to the ADC’s sampling circuitry at any given time. This selection is controlled by the ADC’s configuration registers.</p>
			<p><em class="italic">Figure 11</em><em class="italic">.3</em> shows the ADC channels’ connection to the analog multiplexor within the ADC peripheral block:</p>
			<div><div><img src="img/B21914_11_3.jpg" alt="Figure 11.3: ADC channel multiplexing" width="711" height="449"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: ADC channel multiplexing</p>
			<p>Now, let’s examine<a id="_idIndexMarker788"/> the available ADC modes.</p>
			<h3>The ADC modes</h3>
			<p>The ADC in our STM32F411 <a id="_idIndexMarker789"/>microcontroller can operate in several modes, each tailored to specific application requirements. The primary modes of operation <a id="_idTextAnchor318"/>include single conversio<a id="_idTextAnchor319"/>n mode, continuous conversion mode, scan mode, discontinuous mode, and injected conversion mode.</p>
			<p>Let’s break them down:</p>
			<ul>
				<li><code>0</code> in the <code>ADC_CR2</code> register.<p class="list-inset"><em class="italic">Example use case</em>: Reading the value from a temperature sensor at specific intervals.</p></li>
				<li><code>1</code> in the <code>ADC_CR2</code> register.<p class="list-inset"><em class="italic">Example Use Case</em>: Continuously monitoring a potentiometer to track its position in real time.</p></li>
				<li><code>ADC_CR1</code> register and then configuring the sequence of channels in the <code>ADC_SQRx</code> registers. If the <code>ADC_CR2</code>, the sequence restarts after the last channel is converted.<p class="list-inset"><em class="italic">Example use case</em>: Sampling multiple sensor inputs in a data acquisition system.</p></li>
				<li><code>ADC_CR1</code> register and then defining the number of channels to convert in each group by setting the <code>ADC_CR1</code> register.<p class="list-inset"><em class="italic">Example use case</em>: Reducing the sampling rate for a subset of channels in a multi-channel system.</p></li>
				<li><code>ADC_JSQR</code> register, and then starting the conversion by setting the <code>ADC_CR2</code> register or via an external trigger.<p class="list-inset"><em class="italic">Example use case</em>: Prioritizing critical cell voltage measurements in a <strong class="bold">battery management system</strong> (<strong class="bold">BMS</strong>) during<a id="_idIndexMarker795"/> rapid charging or discharging.</p></li>
			</ul>
			<p>Before exploring the common ADC registers, let’s understand the two types of channels available in the STM32F411 microcontroller.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor321"/>Understanding regular channels versus injected channels in STM32F411 ADC</h2>
			<p>In the STM32F411 <a id="_idIndexMarker796"/>microcontroller, the ADC offers a versatile approach to handling multiple analog inputs through two main types of channels: regular channels and injected channels. Regular channels are configured for routine, sequential conversions, ideal for periodic data<a id="_idIndexMarker797"/> acquisition from sensors where timing is not extremely critical. These channels follow a predefined sequence set by the <code>ADC_SQRx</code> registers and can be triggered by software or external events.</p>
			<p>In contrast, injected channels, such as those configured in injected conversion mode, are designed for <em class="italic">high-priority</em>, <em class="italic">time-sensitive tasks</em>, interrupting the regular sequence to perform immediate conversions when specific conditions are met. This makes injected channels perfect for capturing critical measurements with precise timing, such as motor current sensing in control applications. Additionally, the ADC includes an <em class="italic">Analog Watchdog feature</em>, which can monitor both regular and injected channels for values that exceed predefined thresholds, generating interrupts to handle out-of-range conditions. This dual-channel capability, combined with the Analog Watchdog, provides a robust framework for diverse applications, from routine environmental monitoring to critical real-time data processing and safety monitoring.</p>
			<p>In the next section, we will examine the key registers of the ADC peripheral and some of the flags associated with the ADC operations.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor322"/>The key ADC registers and flags</h1>
			<p>In this section, we will explore<a id="_idIndexMarker798"/> the characteristics and functions of some of the crucial registers within the ADC peripheral.</p>
			<p>Let’s start with ADC Control Register 1 (<code>ADC_CR1</code>).</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor323"/>ADC Control Register 1 (ADC_CR1)</h2>
			<p>This is one of the main control registers that’s used to configure the ADC’s operational settings. It provides various configuration <a id="_idIndexMarker799"/>options, such as resolution, scan mode, discontinuous mode, and <a id="_idTextAnchor324"/>interrupt enable.</p>
			<p>The following are the key bits in this register:</p>
			<ul>
				<li><strong class="bold">RES[1:0]</strong> (<strong class="bold">resolution bits</strong>): These bits<a id="_idIndexMarker800"/> set the resolution of the ADC (12-bit, 10-bit, 8-bit, or 6-bit)</li>
				<li><strong class="bold">SCAN</strong> (<strong class="bold">scan mode</strong>): Setting this bit <a id="_idIndexMarker801"/>enables scan mode, allowing the ADC to convert multiple channels in sequence</li>
				<li><strong class="bold">DISCEN</strong> (<strong class="bold">discontinuous mode</strong>): When set, this bit <a id="_idIndexMarker802"/>enables discontinuous mode on regular channels</li>
				<li><strong class="bold">AWDEN</strong> (<strong class="bold">Analog Watchdog enable</strong>): This bit <a id="_idIndexMarker803"/>enables the Analog Watchdog on all regular channels</li>
				<li><strong class="bold">EOCIE</strong> (<strong class="bold">end of conversion interrupt enable</strong>): When set, this bit allows an interrupt to be<a id="_idIndexMarker804"/> generated when the EOC flag is set</li>
			</ul>
			<p>You can find detailed information about this register on page 229 of the STM32F411 reference manual (RM0383).</p>
			<p>Next, we have ADC Control Register 2 (<code>ADC_CR2</code>).</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor325"/>ADC Control Register 2 (ADC_CR2)</h2>
			<p>This is another crucial control register <a id="_idIndexMarker805"/>that handles different aspects of ADC operation, including the start of conversion, data alignment, and external triggers.</p>
			<p>Here are the key bits in this<a id="_idIndexMarker806"/> register:</p>
			<ul>
				<li><strong class="bold">ADON</strong> (<strong class="bold">ADC on</strong>): This bit turns<a id="_idIndexMarker807"/> the ADC on or off</li>
				<li><strong class="bold">CONT</strong> (<strong class="bold">continuous conversion</strong>): Setting this bit <a id="_idIndexMarker808"/>enables continuous conversion mode</li>
				<li><strong class="bold">SWSTART</strong> (<strong class="bold">start conversion of regular channels</strong>): Setting this bit starts the conversion of regular<a id="_idIndexMarker809"/> channels</li>
				<li><strong class="bold">ALIGN</strong> (<strong class="bold">data alignment</strong>): This bit sets the alignment of the converted data (right or left)</li>
				<li><strong class="bold">EXTEN[1:0]</strong>: This is an external trigger that enables polarity selection for regular channels</li>
			</ul>
			<p>Further information about this register can be found on page 231 of the reference manual.</p>
			<p>Let’s move on to the ADC Regular Sequence Register (<code>ADC_SQRx</code>).</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor326"/>ADC Regular Sequence Register (ADC_SQRx)</h2>
			<p>The <code>ADC_SQRx</code> registers define the<a id="_idIndexMarker810"/> sequence in which the ADC converts the channels. There are multiple SQR registers to handle the<a id="_idIndexMarker811"/> sequence for up to 16 regular channels.</p>
			<p>Here are the key bits in this register:</p>
			<ul>
				<li><strong class="bold">L[3:0]</strong>: Regular channel sequence length. These bits set the total number of conversions in the regular sequence.</li>
				<li><strong class="bold">SQ1-SQ16</strong>: Regular channel sequence. These bits specify the order of the channels to be converted.</li>
			</ul>
			<p>You can read more about this register on page 235 of the reference. The next crucial register is the ADC Data Register (<code>ADC_DR</code>)</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor327"/>ADC Data Register (ADC_DR)</h2>
			<p>The <code>ADC_DR</code> register holds the <a id="_idIndexMarker812"/>result of the conversion. This is where the digital representation of the analog input is stored after the conversion is complete. The register is read-only and the data is stored in the lower 16 bits of the register.</p>
			<p>The final register we will examine is the ADC Status Register (<code>ADC_SR</code>).</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor328"/>ADC Status Register (ADC_SR)</h2>
			<p>This register holds various status<a id="_idIndexMarker813"/> flags that indicate the state of the ADC. These flags are essential for monitoring the ADC’s operation and handling interrupts. We’ll examine these flags in the next section.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor329"/>The key ADC flags</h2>
			<p>ADC flags are status indicators that inform<a id="_idIndexMarker814"/> the system about the state of the ADC operations. These flags are essential for monitoring the ADC’s progress, handling interrupts, and managing errors.</p>
			<p>The key ADC flags <a id="_idTextAnchor330"/>in the STM32F411 are as follows:</p>
			<ul>
				<li><code>ADC_SR</code> register at bit <a id="_idIndexMarker815"/>position 1 (EOC) and is set by hardware when a regular conversion finishes.<p class="list-inset">If the <code>ADC_CR1</code> register is set, the EOC flag can trigger an interrupt. In this case, an interrupt service routine can be triggered to process the converted data.</p></li>
				<li><code>ADC_SR</code> register at bit position 2 (<code>ADC_CR1</code> register.</li>
				<li><code>ADC_<a id="_idTextAnchor332"/>SR</code> register at bit position 0 (<code>ADC_CR1</code> register.</li>
				<li><code>ADC_SR</code> register at bit position 5 (<code>ADC_CR1</code> register.</li>
				<li><strong class="bold">Start conversion (STRT) flag</strong>: The <strong class="bold">STRT</strong> flag indicates that an ADC conversion has started. We can <a id="_idIndexMarker820"/>use this flag to verify that the ADC has initiated a conversion process.</li>
			</ul>
			<p>Understanding and effectively using ADC flags is crucial for managing ADC operations in our STM32 microcontroller. Flags such as EOC, JEOC, AWD, OVR, and STRT provide essential information about the status of conversions, data integrity, and threshold monitoring. By leveraging these flags, we can enhance the reliability and functionality of our ADC implementations, ensuring accurate and timely data acquisition and processing in our embedded systems projects.</p>
			<p>In the next section, we will apply the information we’ve learned to develop an ADC driver for reading analog sensor values.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor333"/>Developing the ADC driver</h1>
			<p>In this section, we will apply <a id="_idIndexMarker821"/>everything we have learned about the ADC peripheral to develop a driver for reading sensor values from a sensor connected to one of the ADC channels.</p>
			<h3>Identifying the GPIO pins for the ADC</h3>
			<p>Let’s begin by identifying the GPIO pins connected to the ADC channels. To do this, refer to the table on <em class="italic">page 39</em> of the <em class="italic">STM32F411RE datasheet</em>. This table lists all the GPIO pins of the microcontroller, along <a id="_idIndexMarker822"/>with their descriptions and additional functionalities. As shown in <em class="italic">Figure 11</em><em class="italic">.4</em>, part of this table reveals that <code>ADC1_IN1</code>. This indicates that <strong class="bold">PA1</strong> is connected to ADC1, <strong class="bold">channel 1</strong>:</p>
			<div><div><img src="img/B21914_11_4.jpg" alt="Figure 11.4: Pin definitions" width="938" height="449"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: Pin definitions</p>
			<p>Let’s configure <strong class="bold">PA1</strong> so that it functions as an ADC pin.</p>
			<p>First, create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project to <code>ADC</code>. Next, create a new file named <code>adc.c</code> in the <code>Src</code> folder and another file named <code>adc.h</code> in the <code>Inc</code> folder.</p>
			<p>Populate your <code>adc.c</code> file with the following code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adc.h"
<strong class="bold">#define</strong> GPIOAEN        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC1EN        (1U&lt;&lt;8)
<strong class="bold">#define</strong> ADC_CH1        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC_SEQ_LEN_1  0x00
<strong class="bold">#define</strong> CR2_ADCON    (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR2_CONT          (1U&lt;&lt;1)
<strong class="bold">#define</strong> CR2_SWSTART     (1U&lt;&lt;30)
<strong class="bold">#define</strong> SR_EOC         (1U&lt;&lt;1)
<strong class="bold">void pa1_adc_init(void)</strong>
{
    /****Configure the ADC GPIO Pin**/
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA1 mode to <strong class="bold">analog</strong> mode*/
    GPIOA-&gt;MODER |=(1U&lt;&lt;2);
    GPIOA-&gt;MODER |=(1U&lt;&lt;3);
    /****Configure the ADC Module**/
    /*Enable clock access to the ADC module*/
    RCC-&gt;APB2ENR |=ADC1EN;
    /*Set conversion sequence start*/
    ADC1-&gt;SQR3 = ADC_CH1;
    /*Set conversion sequence length*/
    ADC1-&gt;SQR1 = ADC_SEQ_LEN_1;
    /*Enable ADC module*/
    ADC1-&gt;CR2 |=CR2_ADCON;
}
<strong class="bold">void start_conversion(void)</strong>
{
    /*Enable continuous conversion*/
    ADC1-&gt;CR2 |=CR2_CONT;
    /*Start ADC conversion*/
    ADC1-&gt;CR2 |=CR2_SWSTART;
}
uint32_t <strong class="bold">adc_read(void)</strong>
{
    /*Wait for conversion to be complete*/
    <strong class="bold">while</strong>(!(ADC1-&gt;SR &amp; SR_EOC)){}
    /*Read converted value*/
    <strong class="bold">return</strong> (ADC1-&gt;DR);
}</pre>			<p>Let’s break down the<a id="_idIndexMarker823"/> source code, starting with the macro definitions:</p>
			<pre class="source-code">
<strong class="bold">#define</strong> GPIOAEN        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC1EN        (1U&lt;&lt;8)
<strong class="bold">#define</strong> ADC_CH1        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC_SEQ_LEN_1  0x00
<strong class="bold">#define</strong> CR2_ADCON     (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR2_CONT     (1U&lt;&lt;1)
<strong class="bold">#define</strong> CR2_SWSTART      (1U&lt;&lt;30)
<strong class="bold">#define</strong> SR_EOC          (1U&lt;&lt;1)</pre>			<p>Let’s break down the macros:</p>
			<ul>
				<li><code>GPIOAEN</code>: This macro enables the clock for GPIOA by setting bit 0 in the <code>AHB1ENR</code> register</li>
				<li><code>ADC1EN</code>: This enables the clock for ADC1 by setting bit 8 in the <code>APB2ENR</code> register</li>
				<li><code>ADC_CH1</code>: This selects channel 1 for the ADC conversion in the <code>SQR3</code> register</li>
				<li><code>ADC_SEQ_LEN_1</code>: This sets the conversion sequence length to 1 in the <code>SQR1</code> register</li>
				<li><code>CR2_ADCON</code>: This enables the ADC module by setting bit 0 in the <code>CR2</code> register</li>
				<li><code>CR2_CONT</code>: This enables continuous conversion mode by setting bit 1 in the <code>CR2</code> register</li>
				<li><code>CR2_SWSTART</code>: This starts the ADC conversion by setting bit 30 in the <code>CR2</code> register</li>
				<li><code>SR_EOC</code>: This macro waits for<a id="_idIndexMarker824"/> the end of conversion by reading bit 1 in the <strong class="bold">status </strong><strong class="bold">register</strong> (<strong class="bold">SR</strong>)</li>
			</ul>
			<p>Next, we must analyze the <a id="_idIndexMarker825"/>configuration sequence of the GPIO pin that’s used for ADC functionality:</p>
			<pre class="source-code">
/* Enable clock access to GPIOA */
 RCC-&gt;AHB1ENR |= GPIOAEN;</pre>			<p>This line enables the clock for <code>GPIOA</code> by setting the appropriate bit in the <code>AHB1ENR</code> register using the <strong class="bold">GPIOAEN</strong> macro:</p>
			<pre class="source-code">
/* Set PA1 mode to analog mode */
    GPIOA-&gt;MODER |= (1U&lt;&lt;2);
    GPIOA-&gt;MODER |= (1U&lt;&lt;3);</pre>			<p>These lines configure <code>GPIOA_MODER</code> register.</p>
			<p>Let’s move on to the part of the code that configures the ADC parameters:</p>
			<pre class="source-code">
/* Enable clock access to the ADC module */
RCC-&gt;APB2ENR |= ADC1EN;</pre>			<p>This line enables the clock for ADC1 by setting the appropriate bit in the <code>APB2ENR</code> register using the <strong class="bold">ADC1EN</strong> macro.</p>
			<pre class="source-code">
/* Set conversion sequence start */
 ADC1-&gt;SQR3 = ADC_CH1;</pre>			<p>This line sets channel 1 as the start of the conversion sequence in the <code>ADC_SQR3</code> register using the <strong class="bold">ADC_CH1</strong> macro:</p>
			<pre class="source-code">
/* Set conversion sequence length */
ADC1-&gt;SQR1 = ADC_SEQ_LEN_1;</pre>			<p>This line sets the sequence length to 1 in the <code>ADC_SQR1</code> register using the <strong class="bold">ADC_SEQ_LEN_1</strong> macro, meaning only one channel will be converted:</p>
			<pre class="source-code">
/* Enable ADC module */
ADC1-&gt;CR2 |= CR2_ADCON;</pre>			<p>This line enables the ADC module by setting the <code>ADC_CR2</code> register.</p>
			<p>Next, we can start the conversion:</p>
			<pre class="source-code">
/* Enable continuous conversion */
ADC1-&gt;CR2 |= CR2_CONT;</pre>			<p>This line enables continuous conversion mode by setting the <code>ADC_CR2</code> register using the <strong class="bold">CR2_CONT</strong> macro:</p>
			<pre class="source-code">
/* Start ADC conversion */
 ADC1-&gt;CR2 |= CR2_SWSTART;</pre>			<p>This line starts the ADC conversion by setting the <code>ADC_CR2</code> register using the <strong class="bold">CR2_SWSTART</strong> macro.</p>
			<p>Next, we must wait for the<a id="_idIndexMarker826"/> results to be ready:</p>
			<pre class="source-code">
/* Wait for conversion to be complete */
while (!(ADC1-&gt;SR &amp; SR_EOC)) {}</pre>			<p>This line waits until the conversion is complete by checking the <code>ADC_SR</code> register:</p>
			<pre class="source-code">
/* Read converted value */
return (ADC1-&gt;DR);</pre>			<p>This line reads the converted digital value from the <code>ADC_DR</code> register.</p>
			<p>In summary, our code performs the following actions:</p>
			<ol>
				<li><strong class="bold">Initializes the ADC </strong><strong class="bold">GPIO pin</strong>:<ul><li>Enables the clock for GPIOA</li><li>Sets PA1 to analog mode</li></ul></li>
				<li><strong class="bold">Configures the </strong><strong class="bold">ADC module</strong>:<ul><li>Enables the clock for ADC1</li><li>Sets channel 1 as the start of the conversion sequence</li><li>Sets the conversion sequence’s length to 1</li><li>Enables the ADC module</li></ul></li>
				<li><strong class="bold">Starts the ADC </strong><strong class="bold">conversion process</strong>:<ul><li>Enables continuous conversion mode</li><li>Starts the ADC conversion process</li></ul></li>
				<li><strong class="bold">Reads the </strong><strong class="bold">ADC value</strong>:<ul><li>Waits for<a id="_idIndexMarker827"/> the conversion to complete</li><li>Reads the converted value from the ADC data register</li></ul></li>
			</ol>
			<p>Our next task is to populate the <code>adc.h</code> file. Here’s the code:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADC_H__
<strong class="bold">#define</strong> ADC_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void pa1_adc_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void start_conversion</strong>(<strong class="bold">void</strong>);
uint32_t <strong class="bold">adc_read</strong>(<strong class="bold">void</strong>);
<code>adc.c</code>, making them callable from other files.</p>
			<p>Let’s move on<a id="_idIndexMarker828"/> to the <code>main.c</code> file. Update your <code>main.c</code> file, like so:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "adc.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">int</strong> sensor_value;
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize ADC*/
    pa1_adc_init();
    /*Start conversion*/
    start_conversion();
    <strong class="bold">while</strong>(1)
    {
        sensor_value = adc_read();
        <strong class="bold">printf</strong>("Sensor Value: %d\r\n",sensor_value);
    }
}</pre>			<p>Let’s break it down:</p>
			<ul>
				<li><strong class="bold">Including </strong><strong class="bold">header files</strong>:<pre class="source-code">
#include &lt;stdio.h&gt;
#include "adc.h"
#include "uart.h"</pre><p class="list-inset">Let’s take a closer look:</p><ul><li><code>#include &lt;stdio.h&gt;</code>: This includes the standard input/output library, which provides the <code>printf()</code> function for printing the sensor values</li><li><code>#include "adc.h"</code>: This includes the header file for the ADC functions, ensuring that the <code>pa1_adc_init</code>, <code>start_conversion</code>, and <code>adc_read</code> functions <a id="_idIndexMarker829"/>from our <code>adc.c</code> file are available</li><li><code>#include "uart.h"</code>: This includes the header file for the UART functions we developed in the previous chapter, ensuring that the <code>uart_init</code> function is available</li></ul></li>				<li><strong class="bold">Global </strong><strong class="bold">variable declaration</strong>:<pre class="source-code">
int sensor_value;</pre><p class="list-inset">This declares a global variable to store the ADC value that’s read from the sensor.</p></li>				<li><strong class="bold">Main function</strong>:<pre class="source-code">
/* Initialize debug UART */
uart_init();</pre><p class="list-inset">This line initializes the UART peripheral, allowing us to print the sensor value:</p><pre class="source-code">/* Initialize ADC */
pa1_adc_init();</pre><p class="list-inset">This line initializes the ADC:</p><pre class="source-code">/* Start conversion */
 start_conversion();</pre><p class="list-inset">This line starts the <a id="_idIndexMarker830"/>ADC conversion process.</p></li>				<li><strong class="bold">Infinite loop</strong>:<pre class="source-code">
 sensor_value = adc_read();
printf("Sensor Value: %d\r\n", sensor_value);</pre><p class="list-inset">This line prints the sensor value to the terminal or console using the UART. The <code>\r\n</code> part at the end of the string ensures that the printed value starts on a new line each time.</pre></li>			</ul>
			<p>We are now ready to test the project.</p>
			<h3>Testing the project</h3>
			<p>To test your project, you must connect<a id="_idIndexMarker831"/> your sensor or a potentiometer to the development board. Follow these steps:</p>
			<ol>
				<li><strong class="bold">Connect </strong><strong class="bold">a sensor</strong>:<ul><li><strong class="bold">Signal pin</strong>: Connect the signal pin of your sensor to <strong class="bold">PA1</strong>.</li><li><strong class="bold">GND pin</strong>: Connect the GND pin of the sensor to one of the GND pins on the development board.</li><li><strong class="bold">VCC pin</strong>: Connect the VCC pin to either the 3.3V or 5V pin on the development board. Ensure you verify the required voltage from your sensor’s documentation as different sensors may need either 3.3V or 5V.</li></ul></li>
				<li><strong class="bold">Use </strong><strong class="bold">a potentiometer</strong>:<ul><li>If a sensor is not available, you can use a potentiometer instead. A potentiometer is an <a id="_idIndexMarker832"/>adjustable resistor that’s used to vary the voltage. It has three terminals: two fixed and one variable (wiper).</li><li><strong class="bold">Middle terminal</strong>: Connect the middle terminal (wiper) of the potentiometer to PA1.</li><li><strong class="bold">Left terminal</strong>: Connect the left terminal to 3.3V.</li><li><strong class="bold">Right terminal</strong>: Connect the right terminal to GND.</li></ul><p class="list-inset">See <em class="italic">Figure 11</em><em class="italic">.4</em> for the connection diagram:</p></li>
			</ol>
			<div><div><img src="img/B21914_11_5.jpg" alt="Figure 11.5: Potentiometer connection" width="1110" height="828"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: Potentiometer connection</p>
			<p class="list-inset">As you turn the knob of the potentiometer, the resistance between the middle terminal and the fixed terminals (3.3V and GND) will change, which, in turn, changes the voltage output at the middle terminal. This varying voltage will be measured by the ADC.</p>
			<ol>
				<li value="3"><strong class="bold">Run </strong><strong class="bold">the project</strong>:<ul><li>Build and run the <a id="_idIndexMarker833"/>project on the development board.</li><li>Open <strong class="bold">RealTerm</strong> or another serial terminal program and select the appropriate port and baud rate.</li><li>You should see the sensor values being printed in real time on the terminal. As you turn the potentiometer knob, the displayed value should change, reflecting the varying output voltage.</li></ul></li>
			</ol>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor334"/>Summary</h1>
			<p>In this chapter, we explored the ADC, a vital peripheral in embedded systems that enables microcontrollers to interface with the analog world. We started with an overview of the analog-to-digital conversion process, highlighting its importance and discussing key specifications such as resolution, step size, and VREF.</p>
			<p>Then, we delved into the STM32F411 microcontroller’s ADC peripheral, examining its capabilities and the relevant registers required for ADC operations. This included an overview of key ADC registers, such as <code>ADC_CR1</code>, <code>ADC_CR2</code>, <code>ADC_SQRx</code>, <code>ADC_SR</code>, and <code>ADC_DR</code>, as well as important ADC flags, such as EOC, JEOC, AWD, OVR, and STRT.</p>
			<p>This chapter also explained the different ADC modes, including single conversion mode, continuous conversion mode, scan mode, discontinuous mode, and injected conversion mode. Each mode was explained with practical use cases to illustrate their applications.</p>
			<p>Next, we examined how multiplexing allows the ADC to switch between multiple input signals, enabling the microcontroller to handle multiple analog inputs efficiently.</p>
			<p>Finally, we applied the theoretical concepts by developing a bare-metal ADC driver. This involved configuring a GPIO pin for ADC input, configuring the ADC module, starting conversions, and reading the ADC values.</p>
			<p>In the next chapter, we will<a id="_idIndexMarker834"/> focus on the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>), another commonly used communication protocol known for its speed and efficiency in embedded systems.</p>
		</div>
	</div>
</div>
</body></html>