<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer104">
			<h1 id="_idParaDest-173" class="chapter-number"><a id="_idTextAnchor303"/>11</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor304"/>Analog-to-Digital Converter (ADC)</h1>
			<p>In this chapter, we will learn about the <strong class="bold">analog-to-digital converter</strong> (<strong class="bold">ADC</strong>), an important peripheral in embedded systems that enables the microcontroller to interface with the analog world. We will start by providing an overview of the analog-to-digital conversion process, the importance of the ADC, and its <span class="No-Break">key specifications.</span></p>
			<p>Following this, we will extract and analyze the relevant registers from the STM32F411 reference manual that are necessary for ADC operations. Finally, we will develop a bare-metal ADC driver to demonstrate the practical application of the theoretical concepts <span class="No-Break">we’ve discussed.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Overview of <a id="_idTextAnchor305"/><span class="No-Break">analog-to-digital conversion</span></li>
				<li><a id="_idTextAnchor306"/>The STM32F4 <span class="No-Break">ADC peripheral</span></li>
				<li><a id="_idTextAnchor307"/>The key ADC registers <span class="No-Break">and flags</span></li>
				<li><a id="_idTextAnchor308"/>Developing the <span class="No-Break">ADC driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of the STM32 ADC peripheral and the skills necessary to develop efficient drivers for it, enabling you to effectively integrate analog-to-digital conversion capabilities into your embedded <span class="No-Break">systems projects.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor309"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor310"/>Overview of analog-to-digital conversion</h1>
			<p>ADC is a critical <a id="_idIndexMarker759"/>process in embedded systems that allows our microcontrollers to interpret and process real-world analog signals. In this section, we will walk through this process, explaining each step involved in converting an analog signal into <span class="No-Break">digital values.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor311"/>What is analog-to-digital conversion?</h2>
			<p>Analog-to-digital conversion is the process of converting a continuous analog signal into a discrete digital representation. Analog signals, which can have any value within a certain range, are transformed into digital signals, which have specific, quantized levels. This conversion is essential because microcontrollers and digital systems can only process <span class="No-Break">digital data.</span></p>
			<p>The conversion process typically involves several key steps: sampling, quantization, and encoding. Let’s break down these steps, starting <span class="No-Break">with sampling.</span></p>
			<h3>Sampling</h3>
			<p><strong class="bold">Sampling</strong> involves measuring the <a id="_idIndexMarker760"/>amplitude of an analog signal at regular intervals, called <strong class="bold">sampling intervals</strong>. The result is a series of discrete values<a id="_idIndexMarker761"/> that approximate the original analog signal. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em> depicts <span class="No-Break">this process:</span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B21914_11_1.jpg" alt="Figure 11.1: The sampling process" width="1224" height="304"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: The sampling process</p>
			<p>The rate at which the analog signal is <a id="_idIndexMarker762"/>sampled is known as the <strong class="bold">sampling rate</strong> or <strong class="bold">sampling frequency</strong>. This is<a id="_idIndexMarker763"/> typically measured in samples per second (Hz). According<a id="_idIndexMarker764"/> to the <strong class="bold">Nyquist Theorem</strong>, the sampling rate<a id="_idIndexMarker765"/> must be at least twice the highest frequency present in the analog signal to accurately reconstruct the <span class="No-Break">original signal.</span></p>
			<p>The next step in the process <span class="No-Break">is</span><span class="No-Break"><a id="_idIndexMarker766"/></span><span class="No-Break"> quantization.</span></p>
			<h3>Quantization</h3>
			<p><strong class="bold">Quantization</strong> is the process of <a id="_idIndexMarker767"/>mapping the sampled analog values to<a id="_idIndexMarker768"/> the nearest discrete levels available in the digital domain. Each discrete level corresponds to a unique <span class="No-Break">digital code.</span></p>
			<p>The number of discrete levels available for quantization is determined by the resolution of the analog-to-digital converter. For example, an <em class="italic">8-bit ADC has 256 levels (28)</em>, while a <em class="italic">12-bit ADC has 4096 </em><span class="No-Break"><em class="italic">levels (212)</em></span><span class="No-Break">.</span></p>
			<p>The quantization process inherently introduces an error, known as <strong class="bold">quantization error</strong> or <strong class="bold">quantization noise</strong>, because the exact analog<a id="_idIndexMarker769"/> value is approximated to the nearest digital level. We <a id="_idIndexMarker770"/>can minimize this error by increasing the resolution of the ADC. For example, if an analog signal ranges <em class="italic">from 0 to 3.3V</em> and an <em class="italic">8-bit ADC</em> is used, the quantization step size is approximately <em class="italic">12.9 mV (3.3V / 256)</em>. An analog input of <em class="italic">1.5V</em> might be quantized to the closest digital level, which could be slightly higher or lower <span class="No-Break">than </span><span class="No-Break"><em class="italic">1.5V</em></span><span class="No-Break">.</span></p>
			<p>The final step in the process <span class="No-Break">is encoding.</span></p>
			<h3>Encoding</h3>
			<p><strong class="bold">Encoding</strong> is the final step and is <a id="_idIndexMarker771"/>where the quantized levels are converted into a<a id="_idIndexMarker772"/> binary code that can be processed by the digital system. Each quantized level is represented by a unique <span class="No-Break">binary value.</span></p>
			<p>The number of bits used in the ADC determines the binary code length. For example, a <em class="italic">10-bit</em> ADC will produce a <em class="italic">10-bit</em> binary number for each sampled value. Continuing with our previous example, if the quantized level for <em class="italic">1.5V</em> is determined to be level <em class="italic">116</em>, the binary representation would be <em class="italic">01110100</em> for an <span class="No-Break"><em class="italic">8-bit</em></span><span class="No-Break"> ADC.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.2</em> shows the encoding process of a <em class="italic">6-bit ADC</em>. The columns in the table show the 6-bit binary representation of the quantization levels. For a 6-bit ADC, the digital output ranges from <strong class="source-inline">000000</strong> for the lowest quantization level to <strong class="source-inline">111111</strong> for the highest. Each binary value corresponds to a specific <span class="No-Break">quantization level:</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B21914_11_2.jpg" alt="Figure 11.2: The encoding process" width="1380" height="353"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: The encoding process</p>
			<p>In s<a id="_idTextAnchor312"/>ummary, the analog-to-digital conversion process begins with an analog input signal, which can vary continuously over time. This signal could be a voltage from a temperature sensor, an <a id="_idIndexMarker773"/>audio signal, or any other analog signal. The analog-to-digital converter typically includes a sample-and-hold circuit that captures and holds the analog signal at each <a id="_idIndexMarker774"/>sampling interval. This ensures that the signal remains constant during the conversion process. The core of the ADC performs quantization and encoding. It compares the held analog value to a set of reference voltages to determine the closest matching digital level. The resulting digital code is output from the ADC and can be read by our microcontroller or digital system for <span class="No-Break">further processing.</span></p>
			<p>In the next section, we will explain some of the key terms that were used in this section, including resolution and <strong class="bold">reference </strong><span class="No-Break"><strong class="bold">voltage</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">VREF</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor313"/>Key specifications of the ADC – resolution, step size, and VREF</h2>
			<p>To effectively use ADCs, it’s important to<a id="_idIndexMarker775"/> understand their key specifications, which define their performance for various applications. Let’s start <span class="No-Break">with resolution.</span></p>
			<h3>Resolution</h3>
			<p>The resolution of an ADC determines the<a id="_idIndexMarker776"/> number of distinct output levels it can produce, corresponding to the number of intervals the input voltage range is divided into. It is typically expressed in bits. Higher resolution allows us to have a more precise representation of the analog input signal, reducing quantization error and improving the accuracy <span class="No-Break">of measurements.</span></p>
			<p>For an <em class="italic">N-bit</em> ADC, the number of discrete output levels is <em class="italic">2N</em>. For example, an <em class="italic">8-bit</em> ADC has <em class="italic">256(28)</em> levels, while a <em class="italic">12-bit</em> ADC has <span class="No-Break"><em class="italic">4,096</em></span><span class="No-Break"> levels.</span></p>
			<p><em class="italic">Table 11.1</em> shows common<a id="_idIndexMarker777"/> ADC resolutions and their corresponding number of discrete levels. The following table highlights how the number of discrete levels increases exponentially with the resolution, providing finer granularity in the digital representation of the analog <span class="No-Break">input signal:</span></p>
			<table id="table001-6" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">ADC </strong><span class="No-Break"><strong class="bold">Resolution (bits)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Number of Discrete </strong><span class="No-Break"><strong class="bold">Levels (2^N)</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>8</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">256</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">10</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1,024</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">12</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">4,096</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">14</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16,384</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">65,536</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">18</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">262,144</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">20</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1,048,576</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">24</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16,777,216</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1: Common ADC resolutions</p>
			<p>The next key specification is <span class="No-Break">the </span><span class="No-Break"><strong class="bold">VREF</strong></span><span class="No-Break">.</span></p>
			<h3>VREF</h3>
			<p>The VREF is the maximum voltage that<a id="_idIndexMarker778"/> our ADC can convert. The analog input voltage is compared to this VREF to produce a digital value. The stability and accuracy of the VREF directly impact the accuracy of the ADC as any fluctuations in the VREF can cause corresponding errors in the <span class="No-Break">digital output.</span></p>
			<p>We can choose to derive the VREF from the microcontroller or provide an external one for more precise applications. Internal references are convenient but might have higher variability, while external <a id="_idIndexMarker779"/>references can offer better stability and accuracy. The choice of VREF depends on our application’s accuracy requirements and the nature of the analog signal <span class="No-Break">being measured.</span></p>
			<p>For example, if the VREF is 5V, the ADC can accurately convert any analog input signal within the range of 0V <span class="No-Break">to 5V.</span></p>
			<p>The last specification we’ll examine is the <span class="No-Break">step size.</span></p>
			<h3>Step size</h3>
			<p>The step size is the smallest <a id="_idIndexMarker780"/>change in analog input that can be distinguished by the ADC. It is determined by the VRED and the resolution and it determines the granularity of the ADC’s output. A smaller step size indicates finer resolution, allowing the ADC to detect smaller changes in the <span class="No-Break">input signa<a id="_idTextAnchor314"/>l.</span></p>
			<p>The step size is calculated by <em class="italic">dividing the VREF by 2 raised to the power of the ADC’s resolution</em> (number <span class="No-Break">of bits<a id="_idTextAnchor315"/>):</span></p>
			<p><img src="image/4.png" alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;/mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;N&lt;/mi&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.502em;height:1.487em;width:6.186em" width="258" height="62"/></p>
			<p>Here, <em class="italic">VREF</em> is the reference voltage and <em class="italic">N</em> is the <span class="No-Break">resolution bits.</span></p>
			<p>For example, for a 10-bit ADC with VREF = <span class="No-Break">3.3V:</span></p>
			<p><img src="image/5.png" alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;3.3&lt;/mn&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;3.3&lt;/mn&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;1024&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3.22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.495em;height:1.482em;width:13.696em" width="574" height="62"/></p>
			<p>This means that each increment in the quantized digital output corresponds to a <em class="italic">3.22mV</em> change in the analog input. <em class="italic">Table 11.2</em> lists common ADC resolutions, the corresponding number of steps, and the step size using a VREF <span class="No-Break">of 3.3V:</span></p>
			<table id="table002-3" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">ADC </strong><span class="No-Break"><strong class="bold">Resolution (Bits)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Number of </strong><span class="No-Break"><strong class="bold">Steps (2^N)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Step </strong><span class="No-Break"><strong class="bold">Size (mV)</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>8</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">256</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">12.9</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">10</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1,024</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">3.22</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">12</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">4,096</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0.805</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">14</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16,384</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0.201</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">65,536</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0.0504</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">18</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">262,144</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0.0126</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">20</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1,048,576</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0.0032</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">24</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16,777,216</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0.000197</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2: ADC resolutions and step sizes at 3.3V VREF</p>
			<p>This table provides a clear view of how the step size decreases with increasing resolution, allowing for finer granularity in the digital representation of the <span class="No-Break">analog input.</span></p>
			<p>This concludes our<a id="_idIndexMarker781"/> overview of the analog-to-digital conversion process. In the next section, we will examine the ADC peripheral of our <span class="No-Break">STM32 microcontroller.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor316"/>The STM32F4 ADC peripheral</h1>
			<p>Our STM32F411 microcontroller features a 12-bit ADC capable of measuring signals from up to <em class="italic">19 multiplexed channels</em>. The ADC can operate in various modes, such as single, continuous, scan, or <a id="_idIndexMarker782"/>discontinuous, with the results stored in <em class="italic">a 16-bit data register</em>. Additionally, the ADC has an analog watchdog feature that allows the system to detect when the input voltage exceeds <span class="No-Break">predefined thresholds.</span></p>
			<p>Before we explain the various ADC modes, let’s understand what we mean by <span class="No-Break">ADC channels.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor317"/>The ADC channels</h2>
			<p>An <strong class="bold">ADC channel</strong> is a dedicated <a id="_idIndexMarker783"/>pathway through which an<a id="_idIndexMarker784"/> analog signal is fed into the ADC so that it can be converted into a digital value. Each ADC channel corresponds to a specific GPIO pin configured to operate in <span class="No-Break">analog mode.</span></p>
			<p>Sensors, which produce analog signals representing physical phenomena (such as temperature, light, or pressure), are interfaced with our microcontroller through these GPIO pins. By configuring a GPIO pin as an analog input, the microcontroller can receive the sensor’s analog <a id="_idIndexMarker785"/>output signal on the corresponding ADC channel. The ADC then converts this continuous analog signal into a discrete digital representation that the microcontroller can process, analyze, and use for further decision-making tasks in our embedded <span class="No-Break">systems applications.</span></p>
			<p>You might be wondering, does having 19 channels mean we have 19 separate ADC modules? This is where multiplexing comes <span class="No-Break">into play.</span></p>
			<h3>Multiplexing ADC channels</h3>
			<p><strong class="bold">Multiplexing</strong> allows the ADC to switch<a id="_idIndexMarker786"/> between different input signals, sampling each one sequentially. This is achieved<a id="_idIndexMarker787"/> using an analog multiplexer (MUX) within the ADC peripheral. As we learned earlier, each of the ADC channels is connected to a specific GPIO pin configured for analog input. The analog MUX selects which analog input signal (from the GPIO pins or internal sources) is connected to the ADC’s sampling circuitry at any given time. This selection is controlled by the ADC’s <span class="No-Break">configuration registers.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.3</em> shows the ADC channels’ connection to the analog multiplexor within the ADC <span class="No-Break">peripheral block:</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B21914_11_3.jpg" alt="Figure 11.3: ADC channel multiplexing" width="711" height="449"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: ADC channel multiplexing</p>
			<p>Now, let’s examine<a id="_idIndexMarker788"/> the available <span class="No-Break">ADC modes.</span></p>
			<h3>The ADC modes</h3>
			<p>The ADC in our STM32F411 <a id="_idIndexMarker789"/>microcontroller can operate in several modes, each tailored to specific application requirements. The primary modes of operation <a id="_idTextAnchor318"/>include single conversio<a id="_idTextAnchor319"/>n mode, continuous conversion mode, scan mode, discontinuous mode, and injected <span class="No-Break">conversion mode.</span></p>
			<p>Let’s break <span class="No-Break">them down:</span></p>
			<ul>
				<li><strong class="bold">Single conversion mode</strong>: In this mode, the ADC performs a single conversion of the selected channel and then stops. This mode is useful for applications where periodic <a id="_idIndexMarker790"/>or event-driven sampling of an analog signal is required. To select this mode, we hav<a id="_idTextAnchor320"/>e to set the <strong class="bold">CONT</strong> bit to <strong class="source-inline">0</strong> in the <span class="No-Break"><strong class="source-inline">ADC_CR2</strong></span><span class="No-Break"> register.</span><p class="list-inset"><em class="italic">Example use case</em>: Reading the value from a temperature sensor at <span class="No-Break">specific intervals.</span></p></li>
				<li><strong class="bold">Continuous conversion mode</strong>: This mode allows the ADC to repeatedly convert the input <a id="_idIndexMarker791"/>signal. After each conversion, the next conversion starts automatically. This mode is enabled by setting the <strong class="bold">CONT</strong> bit to <strong class="source-inline">1</strong> in the <span class="No-Break"><strong class="source-inline">ADC_CR2</strong></span><span class="No-Break"> register.</span><p class="list-inset"><em class="italic">Example Use Case</em>: Continuously monitoring a potentiometer to track its position in <span class="No-Break">real time.</span></p></li>
				<li><strong class="bold">Scan mode</strong>: This mode is<a id="_idIndexMarker792"/> used to convert a sequence of analog channels. We use this mode when we need to sample multiple signals in a defined order. This mode is enabled by setting the <strong class="bold">SCAN</strong> bit in the <strong class="source-inline">ADC_CR1</strong> register and then configuring the sequence of channels in the <strong class="source-inline">ADC_SQRx</strong> registers. If the <strong class="bold">CONT</strong> bit is set in <strong class="source-inline">ADC_CR2</strong>, the sequence restarts after the last channel <span class="No-Break">is converted.</span><p class="list-inset"><em class="italic">Example use case</em>: Sampling multiple sensor inputs in a data <span class="No-Break">acquisition system.</span></p></li>
				<li><strong class="bold">Discontinuous mode</strong>: This mode allows us to convert a subset of channels within a sequence. It reduces <a id="_idIndexMarker793"/>the number of channels converted in each sequence, which can be useful for power saving or reducing processing load. This mode can be enabled by setting the <strong class="bold">DISCEN</strong> bit in the <strong class="source-inline">ADC_CR1</strong> register and then defining the number of channels to convert in each group by setting the <strong class="bold">DISCNUM</strong> bits in the <span class="No-Break"><strong class="source-inline">ADC_CR1</strong></span><span class="No-Break"> register.</span><p class="list-inset"><em class="italic">Example use case</em>: Reducing the sampling rate for a subset of channels in a <span class="No-Break">multi-channel system.</span></p></li>
				<li><strong class="bold">Injected conversion mode</strong>: This mode is designed for higher-priority conversions that can interrupt regular conversions and is useful for applications that require precise timing for <a id="_idIndexMarker794"/>specific signal measurements. We can use this mode by configuring the injected channels and their sequence in the <strong class="source-inline">ADC_JSQR</strong> register, and then starting the conversion by setting the <strong class="bold">JSWSTART</strong> bit in the <strong class="source-inline">ADC_CR2</strong> register or via an <span class="No-Break">external trigger.</span><p class="list-inset"><em class="italic">Example use case</em>: Prioritizing critical cell voltage measurements in a <strong class="bold">battery management system</strong> (<strong class="bold">BMS</strong>) during<a id="_idIndexMarker795"/> rapid charging <span class="No-Break">or discharging.</span></p></li>
			</ul>
			<p>Before exploring the common ADC registers, let’s understand the two types of channels available in the <span class="No-Break">STM32F411 microcontroller.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor321"/>Understanding regular channels versus injected channels in STM32F411 ADC</h2>
			<p>In the STM32F411 <a id="_idIndexMarker796"/>microcontroller, the ADC offers a versatile approach to handling multiple analog inputs through two main types of channels: regular channels and injected channels. Regular channels are configured for routine, sequential conversions, ideal for periodic data<a id="_idIndexMarker797"/> acquisition from sensors where timing is not extremely critical. These channels follow a predefined sequence set by the <strong class="source-inline">ADC_SQRx</strong> registers and can be triggered by software or <span class="No-Break">external events.</span></p>
			<p>In contrast, injected channels, such as those configured in injected conversion mode, are designed for <em class="italic">high-priority</em>, <em class="italic">time-sensitive tasks</em>, interrupting the regular sequence to perform immediate conversions when specific conditions are met. This makes injected channels perfect for capturing critical measurements with precise timing, such as motor current sensing in control applications. Additionally, the ADC includes an <em class="italic">Analog Watchdog feature</em>, which can monitor both regular and injected channels for values that exceed predefined thresholds, generating interrupts to handle out-of-range conditions. This dual-channel capability, combined with the Analog Watchdog, provides a robust framework for diverse applications, from routine environmental monitoring to critical real-time data processing and <span class="No-Break">safety monitoring.</span></p>
			<p>In the next section, we will examine the key registers of the ADC peripheral and some of the flags associated with the <span class="No-Break">ADC operations.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor322"/>The key ADC registers and flags</h1>
			<p>In this section, we will explore<a id="_idIndexMarker798"/> the characteristics and functions of some of the crucial registers within the <span class="No-Break">ADC peripheral.</span></p>
			<p>Let’s start with ADC Control Register <span class="No-Break">1 (</span><span class="No-Break"><strong class="source-inline">ADC_CR1</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor323"/>ADC Control Register 1 (ADC_CR1)</h2>
			<p>This is one of the main control registers that’s used to configure the ADC’s operational settings. It provides various configuration <a id="_idIndexMarker799"/>options, such as resolution, scan mode, discontinuous mode, and <a id="_idTextAnchor324"/><span class="No-Break">interrupt enable.</span></p>
			<p>The following are the key bits in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">RES[1:0]</strong> (<strong class="bold">resolution bits</strong>): These bits<a id="_idIndexMarker800"/> set the resolution of the ADC (12-bit, 10-bit, 8-bit, <span class="No-Break">or 6-bit)</span></li>
				<li><strong class="bold">SCAN</strong> (<strong class="bold">scan mode</strong>): Setting this bit <a id="_idIndexMarker801"/>enables scan mode, allowing the ADC to convert multiple channels <span class="No-Break">in sequence</span></li>
				<li><strong class="bold">DISCEN</strong> (<strong class="bold">discontinuous mode</strong>): When set, this bit <a id="_idIndexMarker802"/>enables discontinuous mode on <span class="No-Break">regular channels</span></li>
				<li><strong class="bold">AWDEN</strong> (<strong class="bold">Analog Watchdog enable</strong>): This bit <a id="_idIndexMarker803"/>enables the Analog Watchdog on all <span class="No-Break">regular channels</span></li>
				<li><strong class="bold">EOCIE</strong> (<strong class="bold">end of conversion interrupt enable</strong>): When set, this bit allows an interrupt to be<a id="_idIndexMarker804"/> generated when the EOC flag <span class="No-Break">is set</span></li>
			</ul>
			<p>You can find detailed information about this register on page 229 of the STM32F411 reference <span class="No-Break">manual (RM0383).</span></p>
			<p>Next, we have ADC Control Register <span class="No-Break">2 (</span><span class="No-Break"><strong class="source-inline">ADC_CR2</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor325"/>ADC Control Register 2 (ADC_CR2)</h2>
			<p>This is another crucial control register <a id="_idIndexMarker805"/>that handles different aspects of ADC operation, including the start of conversion, data alignment, and <span class="No-Break">external triggers.</span></p>
			<p>Here are the key bits in <span class="No-Break">this</span><span class="No-Break"><a id="_idIndexMarker806"/></span><span class="No-Break"> register:</span></p>
			<ul>
				<li><strong class="bold">ADON</strong> (<strong class="bold">ADC on</strong>): This bit turns<a id="_idIndexMarker807"/> the ADC on <span class="No-Break">or off</span></li>
				<li><strong class="bold">CONT</strong> (<strong class="bold">continuous conversion</strong>): Setting this bit <a id="_idIndexMarker808"/>enables continuous <span class="No-Break">conversion mode</span></li>
				<li><strong class="bold">SWSTART</strong> (<strong class="bold">start conversion of regular channels</strong>): Setting this bit starts the conversion of <span class="No-Break">regular</span><span class="No-Break"><a id="_idIndexMarker809"/></span><span class="No-Break"> channels</span></li>
				<li><strong class="bold">ALIGN</strong> (<strong class="bold">data alignment</strong>): This bit sets the alignment of the converted data (right <span class="No-Break">or left)</span></li>
				<li><strong class="bold">EXTEN[1:0]</strong>: This is an external trigger that enables polarity selection for <span class="No-Break">regular channels</span></li>
			</ul>
			<p>Further information about this register can be found on page 231 of the <span class="No-Break">reference manual.</span></p>
			<p>Let’s move on to the ADC Regular Sequence <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">ADC_SQRx</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor326"/>ADC Regular Sequence Register (ADC_SQRx)</h2>
			<p>The <strong class="source-inline">ADC_SQRx</strong> registers define the<a id="_idIndexMarker810"/> sequence in which the ADC converts the channels. There are multiple SQR registers to handle the<a id="_idIndexMarker811"/> sequence for up to 16 <span class="No-Break">regular channels.</span></p>
			<p>Here are the key bits in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">L[3:0]</strong>: Regular channel sequence length. These bits set the total number of conversions in the <span class="No-Break">regular sequence.</span></li>
				<li><strong class="bold">SQ1-SQ16</strong>: Regular channel sequence. These bits specify the order of the channels to <span class="No-Break">be converted.</span></li>
			</ul>
			<p>You can read more about this register on page 235 of the reference. The next crucial register is the ADC Data <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">ADC_DR</strong></span><span class="No-Break">)</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor327"/>ADC Data Register (ADC_DR)</h2>
			<p>The <strong class="source-inline">ADC_DR</strong> register holds the <a id="_idIndexMarker812"/>result of the conversion. This is where the digital representation of the analog input is stored after the conversion is complete. The register is read-only and the data is stored in the lower 16 bits of <span class="No-Break">the register.</span></p>
			<p>The final register we will examine is the ADC Status <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">ADC_SR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor328"/>ADC Status Register (ADC_SR)</h2>
			<p>This register holds various status<a id="_idIndexMarker813"/> flags that indicate the state of the ADC. These flags are essential for monitoring the ADC’s operation and handling interrupts. We’ll examine these flags in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor329"/>The key ADC flags</h2>
			<p>ADC flags are status indicators that inform<a id="_idIndexMarker814"/> the system about the state of the ADC operations. These flags are essential for monitoring the ADC’s progress, handling interrupts, and <span class="No-Break">managing errors.</span></p>
			<p>The key ADC flags <a id="_idTextAnchor330"/>in the STM32F411 are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">End of conversion (EOC) flag</strong>: The <strong class="bold">EOC</strong> flag indicates that the ADC has completed a conversion, and the result is available in the data register. It is located in the <strong class="source-inline">ADC_SR</strong> register at bit <a id="_idIndexMarker815"/>position 1 (EOC) and is set by hardware when a regular <span class="No-Break">conversion finishes.</span><p class="list-inset">If the <strong class="bold">EOCIE</strong> bit in the <strong class="source-inline">ADC_CR1</strong> register is set, the EOC flag can trigger an interrupt. In this case, an interrupt service routine can be triggered to process the <span class="No-Break">converted data.</span></p></li>
				<li><strong class="bold">End of injected conversion (JEOC) flag</strong>: This flag<a id="_idIndexMarker816"/> indicates that an injected conversion sequence has been completed and the result is available in the injected data register. It is located in the <strong class="source-inline">ADC_SR</strong> register at bit position 2 (<strong class="bold">JEOC</strong>) and is set by hardware at the end of the conversion of all injected channels in th<a id="_idTextAnchor331"/>e group. Similar to <strong class="bold">EOC</strong>, this flag can generate an interrupt if its corresponding interrupt enable bit (<strong class="bold">JEOCIE</strong>) is set in the <span class="No-Break"><strong class="source-inline">ADC_CR1</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="bold">Analog Watchdog (AWD) flag</strong>: This flag<a id="_idIndexMarker817"/> indicates that the converted value has exceeded the<a id="_idIndexMarker818"/> predefined high or low thresholds set for the analog watchdog. It is located in the <strong class="source-inline">ADC_<a id="_idTextAnchor332"/>SR</strong> register at bit position 0 (<strong class="bold">AWD</strong>). It can also generate an interrupt if its corresponding interrupt enable bit (<strong class="bold">AWDIE</strong>) is set in the <span class="No-Break"><strong class="source-inline">ADC_CR1</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="bold">Overrun (OVR) flag</strong>: This flag indicates that a new conversion result has overwritten the previous data before it was <a id="_idIndexMarker819"/>read. It is located in the <strong class="source-inline">ADC_SR</strong> register at bit position 5 (<strong class="bold">OVR</strong>). It can also generate an interrupt if its corresponding interrupt enable bit (<strong class="bold">OVRIE</strong>) is set in the <span class="No-Break"><strong class="source-inline">ADC_CR1</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="bold">Start conversion (STRT) flag</strong>: The <strong class="bold">STRT</strong> flag indicates that an ADC conversion has started. We can <a id="_idIndexMarker820"/>use this flag to verify that the ADC has initiated a <span class="No-Break">conversion process.</span></li>
			</ul>
			<p>Understanding and effectively using ADC flags is crucial for managing ADC operations in our STM32 microcontroller. Flags such as EOC, JEOC, AWD, OVR, and STRT provide essential information about the status of conversions, data integrity, and threshold monitoring. By leveraging these flags, we can enhance the reliability and functionality of our ADC implementations, ensuring accurate and timely data acquisition and processing in our embedded <span class="No-Break">systems projects.</span></p>
			<p>In the next section, we will apply the information we’ve learned to develop an ADC driver for reading analog <span class="No-Break">sensor values.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor333"/>Developing the ADC driver</h1>
			<p>In this section, we will apply <a id="_idIndexMarker821"/>everything we have learned about the ADC peripheral to develop a driver for reading sensor values from a sensor connected to one of the <span class="No-Break">ADC channels.</span></p>
			<h3>Identifying the GPIO pins for the ADC</h3>
			<p>Let’s begin by identifying the GPIO pins connected to the ADC channels. To do this, refer to the table on <em class="italic">page 39</em> of the <em class="italic">STM32F411RE datasheet</em>. This table lists all the GPIO pins of the microcontroller, along <a id="_idIndexMarker822"/>with their descriptions and additional functionalities. As shown in <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.4</em>, part of this table reveals that <strong class="bold">PA1</strong> has an additional function labeled as <strong class="source-inline">ADC1_IN1</strong>. This indicates that <strong class="bold">PA1</strong> is connected to ADC1, <span class="No-Break"><strong class="bold">channel 1</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B21914_11_4.jpg" alt="Figure 11.4: Pin definitions" width="938" height="449"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: Pin definitions</p>
			<p>Let’s configure <strong class="bold">PA1</strong> so that it functions as an <span class="No-Break">ADC pin.</span></p>
			<p>First, create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project to <strong class="source-inline">ADC</strong>. Next, create a new file named <strong class="source-inline">adc.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">adc.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<p>Populate your <strong class="source-inline">adc.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adc.h"
<strong class="bold">#define</strong> GPIOAEN        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC1EN        (1U&lt;&lt;8)
<strong class="bold">#define</strong> ADC_CH1        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC_SEQ_LEN_1  0x00
<strong class="bold">#define</strong> CR2_ADCON    (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR2_CONT          (1U&lt;&lt;1)
<strong class="bold">#define</strong> CR2_SWSTART     (1U&lt;&lt;30)
<strong class="bold">#define</strong> SR_EOC         (1U&lt;&lt;1)
<strong class="bold">void pa1_adc_init(void)</strong>
{
    /****Configure the ADC GPIO Pin**/
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA1 mode to <strong class="bold">analog</strong> mode*/
    GPIOA-&gt;MODER |=(1U&lt;&lt;2);
    GPIOA-&gt;MODER |=(1U&lt;&lt;3);
    /****Configure the ADC Module**/
    /*Enable clock access to the ADC module*/
    RCC-&gt;APB2ENR |=ADC1EN;
    /*Set conversion sequence start*/
    ADC1-&gt;SQR3 = ADC_CH1;
    /*Set conversion sequence length*/
    ADC1-&gt;SQR1 = ADC_SEQ_LEN_1;
    /*Enable ADC module*/
    ADC1-&gt;CR2 |=CR2_ADCON;
}
<strong class="bold">void start_conversion(void)</strong>
{
    /*Enable continuous conversion*/
    ADC1-&gt;CR2 |=CR2_CONT;
    /*Start ADC conversion*/
    ADC1-&gt;CR2 |=CR2_SWSTART;
}
uint32_t <strong class="bold">adc_read(void)</strong>
{
    /*Wait for conversion to be complete*/
    <strong class="bold">while</strong>(!(ADC1-&gt;SR &amp; SR_EOC)){}
    /*Read converted value*/
    <strong class="bold">return</strong> (ADC1-&gt;DR);
}</pre>			<p>Let’s break down the<a id="_idIndexMarker823"/> source code, starting with the <span class="No-Break">macro definitions:</span></p>
			<pre class="source-code">
<strong class="bold">#define</strong> GPIOAEN        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC1EN        (1U&lt;&lt;8)
<strong class="bold">#define</strong> ADC_CH1        (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC_SEQ_LEN_1  0x00
<strong class="bold">#define</strong> CR2_ADCON     (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR2_CONT     (1U&lt;&lt;1)
<strong class="bold">#define</strong> CR2_SWSTART      (1U&lt;&lt;30)
<strong class="bold">#define</strong> SR_EOC          (1U&lt;&lt;1)</pre>			<p>Let’s break down <span class="No-Break">the macros:</span></p>
			<ul>
				<li><strong class="source-inline">GPIOAEN</strong>: This macro enables the clock for GPIOA by setting bit 0 in the <span class="No-Break"><strong class="source-inline">AHB1ENR</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">ADC1EN</strong>: This enables the clock for ADC1 by setting bit 8 in the <span class="No-Break"><strong class="source-inline">APB2ENR</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">ADC_CH1</strong>: This selects channel 1 for the ADC conversion in the <span class="No-Break"><strong class="source-inline">SQR3</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">ADC_SEQ_LEN_1</strong>: This sets the conversion sequence length to 1 in the <span class="No-Break"><strong class="source-inline">SQR1</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">CR2_ADCON</strong>: This enables the ADC module by setting bit 0 in the <span class="No-Break"><strong class="source-inline">CR2</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">CR2_CONT</strong>: This enables continuous conversion mode by setting bit 1 in the <span class="No-Break"><strong class="source-inline">CR2</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">CR2_SWSTART</strong>: This starts the ADC conversion by setting bit 30 in the <span class="No-Break"><strong class="source-inline">CR2</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">SR_EOC</strong>: This macro waits for<a id="_idIndexMarker824"/> the end of conversion by reading bit 1 in the <strong class="bold">status </strong><span class="No-Break"><strong class="bold">register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SR</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Next, we must analyze the <a id="_idIndexMarker825"/>configuration sequence of the GPIO pin that’s used for <span class="No-Break">ADC functionality:</span></p>
			<pre class="source-code">
/* Enable clock access to GPIOA */
 RCC-&gt;AHB1ENR |= GPIOAEN;</pre>			<p>This line enables the clock for <strong class="source-inline">GPIOA</strong> by setting the appropriate bit in the <strong class="source-inline">AHB1ENR</strong> register using the <span class="No-Break"><strong class="bold">GPIOAEN</strong></span><span class="No-Break"> macro:</span></p>
			<pre class="source-code">
/* Set PA1 mode to analog mode */
    GPIOA-&gt;MODER |= (1U&lt;&lt;2);
    GPIOA-&gt;MODER |= (1U&lt;&lt;3);</pre>			<p>These lines configure <strong class="bold">PA1</strong> as an analog input by setting bits 2 and 3 in the <span class="No-Break"><strong class="source-inline">GPIOA_MODER</strong></span><span class="No-Break"> register.</span></p>
			<p>Let’s move on to the part of the code that configures the <span class="No-Break">ADC parameters:</span></p>
			<pre class="source-code">
/* Enable clock access to the ADC module */
RCC-&gt;APB2ENR |= ADC1EN;</pre>			<p>This line enables the clock for ADC1 by setting the appropriate bit in the <strong class="source-inline">APB2ENR</strong> register using the <span class="No-Break"><strong class="bold">ADC1EN</strong></span><span class="No-Break"> macro.</span></p>
			<pre class="source-code">
/* Set conversion sequence start */
 ADC1-&gt;SQR3 = ADC_CH1;</pre>			<p>This line sets channel 1 as the start of the conversion sequence in the <strong class="source-inline">ADC_SQR3</strong> register using the <span class="No-Break"><strong class="bold">ADC_CH1</strong></span><span class="No-Break"> macro:</span></p>
			<pre class="source-code">
/* Set conversion sequence length */
ADC1-&gt;SQR1 = ADC_SEQ_LEN_1;</pre>			<p>This line sets the sequence length to 1 in the <strong class="source-inline">ADC_SQR1</strong> register using the <strong class="bold">ADC_SEQ_LEN_1</strong> macro, meaning only one channel will <span class="No-Break">be converted:</span></p>
			<pre class="source-code">
/* Enable ADC module */
ADC1-&gt;CR2 |= CR2_ADCON;</pre>			<p>This line enables the ADC module by setting the <strong class="bold">ADCON</strong> bit in the <span class="No-Break"><strong class="source-inline">ADC_CR2</strong></span><span class="No-Break"> register.</span></p>
			<p>Next, we can start <span class="No-Break">the conversion:</span></p>
			<pre class="source-code">
/* Enable continuous conversion */
ADC1-&gt;CR2 |= CR2_CONT;</pre>			<p>This line enables continuous conversion mode by setting the <strong class="bold">CONT</strong> bit in the <strong class="source-inline">ADC_CR2</strong> register using the <span class="No-Break"><strong class="bold">CR2_CONT</strong></span><span class="No-Break"> macro:</span></p>
			<pre class="source-code">
/* Start ADC conversion */
 ADC1-&gt;CR2 |= CR2_SWSTART;</pre>			<p>This line starts the ADC conversion by setting the <strong class="bold">SWSTART</strong> bit in the <strong class="source-inline">ADC_CR2</strong> register using the <span class="No-Break"><strong class="bold">CR2_SWSTART</strong></span><span class="No-Break"> macro.</span></p>
			<p>Next, we must wait for the<a id="_idIndexMarker826"/> results to <span class="No-Break">be ready:</span></p>
			<pre class="source-code">
/* Wait for conversion to be complete */
while (!(ADC1-&gt;SR &amp; SR_EOC)) {}</pre>			<p>This line waits until the conversion is complete by checking the <strong class="bold">EOC</strong> flag in the <span class="No-Break"><strong class="source-inline">ADC_SR</strong></span><span class="No-Break"> register:</span></p>
			<pre class="source-code">
/* Read converted value */
return (ADC1-&gt;DR);</pre>			<p>This line reads the converted digital value from the <span class="No-Break"><strong class="source-inline">ADC_DR</strong></span><span class="No-Break"> register.</span></p>
			<p>In summary, our code performs the <span class="No-Break">following actions:</span></p>
			<ol>
				<li><strong class="bold">Initializes the ADC </strong><span class="No-Break"><strong class="bold">GPIO pin</strong></span><span class="No-Break">:</span><ul><li>Enables the clock <span class="No-Break">for GPIOA</span></li><li>Sets PA1 to <span class="No-Break">analog mode</span></li></ul></li>
				<li><strong class="bold">Configures the </strong><span class="No-Break"><strong class="bold">ADC module</strong></span><span class="No-Break">:</span><ul><li>Enables the clock <span class="No-Break">for ADC1</span></li><li>Sets channel 1 as the start of the <span class="No-Break">conversion sequence</span></li><li>Sets the conversion sequence’s length <span class="No-Break">to 1</span></li><li>Enables the <span class="No-Break">ADC module</span></li></ul></li>
				<li><strong class="bold">Starts the ADC </strong><span class="No-Break"><strong class="bold">conversion process</strong></span><span class="No-Break">:</span><ul><li>Enables continuous <span class="No-Break">conversion mode</span></li><li>Starts the ADC <span class="No-Break">conversion process</span></li></ul></li>
				<li><strong class="bold">Reads the </strong><span class="No-Break"><strong class="bold">ADC value</strong></span><span class="No-Break">:</span><ul><li>Waits for<a id="_idIndexMarker827"/> the conversion <span class="No-Break">to complete</span></li><li>Reads the converted value from the ADC <span class="No-Break">data register</span></li></ul></li>
			</ol>
			<p>Our next task is to populate the <strong class="source-inline">adc.h</strong> file. Here’s <span class="No-Break">the code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADC_H__
<strong class="bold">#define</strong> ADC_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void pa1_adc_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void start_conversion</strong>(<strong class="bold">void</strong>);
uint32_t <strong class="bold">adc_read</strong>(<strong class="bold">void</strong>);
<strong class="bold">#endif</strong></pre>			<p>Here, we are simply exposing the functions implemented in <strong class="source-inline">adc.c</strong>, making them callable from <span class="No-Break">other files.</span></p>
			<p>Let’s move on<a id="_idIndexMarker828"/> to the <strong class="source-inline">main.c</strong> file. Update your <strong class="source-inline">main.c</strong> file, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "adc.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">int</strong> sensor_value;
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize ADC*/
    pa1_adc_init();
    /*Start conversion*/
    start_conversion();
    <strong class="bold">while</strong>(1)
    {
        sensor_value = adc_read();
        <strong class="bold">printf</strong>("Sensor Value: %d\r\n",sensor_value);
    }
}</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="bold">Including </strong><span class="No-Break"><strong class="bold">header files</strong></span><span class="No-Break">:</span><pre class="source-code">
#include &lt;stdio.h&gt;
#include "adc.h"
#include "uart.h"</pre><p class="list-inset">Let’s take a <span class="No-Break">closer look:</span></p><ul><li><strong class="source-inline">#include &lt;stdio.h&gt;</strong>: This includes the standard input/output library, which provides the <strong class="source-inline">printf()</strong> function for printing the <span class="No-Break">sensor values</span></li><li><strong class="source-inline">#include "adc.h"</strong>: This includes the header file for the ADC functions, ensuring that the <strong class="source-inline">pa1_adc_init</strong>, <strong class="source-inline">start_conversion</strong>, and <strong class="source-inline">adc_read</strong> functions <a id="_idIndexMarker829"/>from our <strong class="source-inline">adc.c</strong> file <span class="No-Break">are available</span></li><li><strong class="source-inline">#include "uart.h"</strong>: This includes the header file for the UART functions we developed in the previous chapter, ensuring that the <strong class="source-inline">uart_init</strong> function <span class="No-Break">is available</span></li></ul></li>				<li><strong class="bold">Global </strong><span class="No-Break"><strong class="bold">variable declaration</strong></span><span class="No-Break">:</span><pre class="source-code">
int sensor_value;</pre><p class="list-inset">This declares a global variable to store the ADC value that’s read from <span class="No-Break">the sensor.</span></p></li>				<li><span class="No-Break"><strong class="bold">Main function</strong></span><span class="No-Break">:</span><pre class="source-code">
/* Initialize debug UART */
uart_init();</pre><p class="list-inset">This line initializes the UART peripheral, allowing us to print the <span class="No-Break">sensor value:</span></p><pre class="source-code">/* Initialize ADC */
pa1_adc_init();</pre><p class="list-inset">This line initializes <span class="No-Break">the ADC:</span></p><pre class="source-code">/* Start conversion */
 start_conversion();</pre><p class="list-inset">This line starts the <a id="_idIndexMarker830"/>ADC <span class="No-Break">conversion process.</span></p></li>				<li><span class="No-Break"><strong class="bold">Infinite loop</strong></span><span class="No-Break">:</span><pre class="source-code">
 sensor_value = adc_read();</pre><p class="list-inset">This line reads the latest converted value from the ADC and stores it in the <span class="No-Break"><strong class="source-inline">sensor_value</strong></span><span class="No-Break"> variable:</span></p><pre class="source-code">printf("Sensor Value: %d\r\n", sensor_value);</pre><p class="list-inset">This line prints the sensor value to the terminal or console using the UART. The <strong class="source-inline">\r\n</strong> part at the end of the string ensures that the printed value starts on a new line <span class="No-Break">each time.</span></p></li>			</ul>
			<p>We are now ready to test <span class="No-Break">the project.</span></p>
			<h3>Testing the project</h3>
			<p>To test your project, you must connect<a id="_idIndexMarker831"/> your sensor or a potentiometer to the development board. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li><strong class="bold">Connect </strong><span class="No-Break"><strong class="bold">a sensor</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Signal pin</strong>: Connect the signal pin of your sensor <span class="No-Break">to </span><span class="No-Break"><strong class="bold">PA1</strong></span><span class="No-Break">.</span></li><li><strong class="bold">GND pin</strong>: Connect the GND pin of the sensor to one of the GND pins on the <span class="No-Break">development board.</span></li><li><strong class="bold">VCC pin</strong>: Connect the VCC pin to either the 3.3V or 5V pin on the development board. Ensure you verify the required voltage from your sensor’s documentation as different sensors may need either 3.3V <span class="No-Break">or 5V.</span></li></ul></li>
				<li><strong class="bold">Use </strong><span class="No-Break"><strong class="bold">a potentiometer</strong></span><span class="No-Break">:</span><ul><li>If a sensor is not available, you can use a potentiometer instead. A potentiometer is an <a id="_idIndexMarker832"/>adjustable resistor that’s used to vary the voltage. It has three terminals: two fixed and one <span class="No-Break">variable (wiper).</span></li><li><strong class="bold">Middle terminal</strong>: Connect the middle terminal (wiper) of the potentiometer <span class="No-Break">to PA1.</span></li><li><strong class="bold">Left terminal</strong>: Connect the left terminal <span class="No-Break">to 3.3V.</span></li><li><strong class="bold">Right terminal</strong>: Connect the right terminal <span class="No-Break">to GND.</span></li></ul><p class="list-inset">See <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.4</em> for the <span class="No-Break">connection diagram:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B21914_11_5.jpg" alt="Figure 11.5: Potentiometer connection" width="1110" height="828"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: Potentiometer connection</p>
			<p class="list-inset">As you turn the knob of the potentiometer, the resistance between the middle terminal and the fixed terminals (3.3V and GND) will change, which, in turn, changes the voltage output at the middle terminal. This varying voltage will be measured by <span class="No-Break">the ADC.</span></p>
			<ol>
				<li value="3"><strong class="bold">Run </strong><span class="No-Break"><strong class="bold">the project</strong></span><span class="No-Break">:</span><ul><li>Build and run the <a id="_idIndexMarker833"/>project on the <span class="No-Break">development board.</span></li><li>Open <strong class="bold">RealTerm</strong> or another serial terminal program and select the appropriate port and <span class="No-Break">baud rate.</span></li><li>You should see the sensor values being printed in real time on the terminal. As you turn the potentiometer knob, the displayed value should change, reflecting the varying <span class="No-Break">output voltage.</span></li></ul></li>
			</ol>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor334"/>Summary</h1>
			<p>In this chapter, we explored the ADC, a vital peripheral in embedded systems that enables microcontrollers to interface with the analog world. We started with an overview of the analog-to-digital conversion process, highlighting its importance and discussing key specifications such as resolution, step size, <span class="No-Break">and VREF.</span></p>
			<p>Then, we delved into the STM32F411 microcontroller’s ADC peripheral, examining its capabilities and the relevant registers required for ADC operations. This included an overview of key ADC registers, such as <strong class="source-inline">ADC_CR1</strong>, <strong class="source-inline">ADC_CR2</strong>, <strong class="source-inline">ADC_SQRx</strong>, <strong class="source-inline">ADC_SR</strong>, and <strong class="source-inline">ADC_DR</strong>, as well as important ADC flags, such as EOC, JEOC, AWD, OVR, <span class="No-Break">and STRT.</span></p>
			<p>This chapter also explained the different ADC modes, including single conversion mode, continuous conversion mode, scan mode, discontinuous mode, and injected conversion mode. Each mode was explained with practical use cases to illustrate <span class="No-Break">their applications.</span></p>
			<p>Next, we examined how multiplexing allows the ADC to switch between multiple input signals, enabling the microcontroller to handle multiple analog <span class="No-Break">inputs efficiently.</span></p>
			<p>Finally, we applied the theoretical concepts by developing a bare-metal ADC driver. This involved configuring a GPIO pin for ADC input, configuring the ADC module, starting conversions, and reading the <span class="No-Break">ADC values.</span></p>
			<p>In the next chapter, we will<a id="_idIndexMarker834"/> focus on the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>), another commonly used communication protocol known for its speed and efficiency in <span class="No-Break">embedded systems.</span></p>
		</div>
	</div>
</div>
</body></html>