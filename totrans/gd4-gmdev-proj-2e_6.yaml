- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Infinite Flyer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限飞行者
- en: In this chapter, you’ll build a 3D infinite runner (or more accurately, infinite
    *flyer*) in the vein of *Temple Run* or *Subway Surfers*. The player’s goal is
    to fly as far as possible, passing through floating rings to collect points, while
    avoiding obstacles. By building this game, you’ll get a feel for how to make 3D
    objects interact and how to generate a 3D world automatically, rather than building
    it piece-by-piece as you did in earlier games such as *Minigolf* or *Jungle Jump*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个3D无限跑酷游戏（或者更准确地说，无限*飞行者*），类似于*神庙逃亡*或*地铁跑酷*。玩家的目标是尽可能飞远，穿过漂浮的圆环来收集分数，同时避开障碍物。通过构建这个游戏，你会了解如何使3D对象交互，以及如何自动生成3D世界，而不是像在早期的*迷你高尔夫*或*丛林跳跃*等游戏中那样逐块构建。
- en: 'Here are some of the new things you’ll learn in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到一些新内容：
- en: Using transforms to rotate and move in 3D space
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换在3D空间中旋转和移动
- en: Load and unload “chunks” of your game world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和卸载游戏世界的“块”
- en: How to randomly generate the game environment and game objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何随机生成游戏环境和游戏对象
- en: Saving and loading files for persistent data storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载文件以进行持久数据存储
- en: Using `CharacterBody3D` and detecting collisions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CharacterBody3D`和检测碰撞
- en: 'When completed, the game will look like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，游戏将看起来像这样：
- en: '![Figure 6.1: Finished game screenshot](img/B19289_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：完成的游戏截图](img/B19289_06_01.jpg)'
- en: 'Figure 6.1: Finished game screenshot'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：完成的游戏截图
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Download the game assets from the following link and unzip them into your new
    project folder:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载游戏资源，并将其解压到你的新项目文件夹中：
- en: '[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到本章的完整代码：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer)
- en: Project setup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Create a new project in Godot to get started. As you’ve done before, download
    the project assets and unzip them in the new project folder. Once you’ve created
    the project, you’ll start by configuring the inputs and Godot settings needed
    for the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中创建一个新的项目开始。像之前一样，下载项目资源并将其解压到新的项目文件夹中。一旦创建项目，你将开始配置游戏所需的输入和Godot设置。
- en: Inputs
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入
- en: 'You’ll control the plane with up, down, left, and right inputs. You can add
    them in `pitch_up`, `pitch_down`, `roll_left`, and `roll_right`. You can add the
    arrow keys and/or the *W*, *A*, *S*, and *D* keys to these, but if you have a
    game controller, you can also use a joystick for more precise control. To add
    joystick inputs, you can select **Joypad Axes** after pressing the **+** button.
    The values are labeled, such as **Left Stick Up**, so you can easily keep track
    of them:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用上、下、左、右输入来控制飞机。你可以在`pitch_up`、`pitch_down`、`roll_left`和`roll_right`中添加它们。你可以添加箭头键和/或*W*、*A*、*S*和*D*键，但如果你有游戏控制器，你也可以使用摇杆进行更精确的控制。要添加摇杆输入，你可以在按下**+**按钮后选择**Joypad
    Axes**。这些值都有标签，例如**Left Stick Up**，这样你可以轻松跟踪它们：
- en: '![Figure 6.2: Input configuration](img/B19289_06_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：输入配置](img/B19289_06_02.jpg)'
- en: 'Figure 6.2: Input configuration'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：输入配置
- en: The nice part about this setup is that your code won’t have to be any different
    for the different types of input. By using `Input.get_axis()` and passing in the
    four input events, you’ll get a result whether the player pressed a key or moved
    the stick. Pressing the keys is equivalent to pushing the stick all the way in
    one direction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置的优点是，你的代码对于不同类型的输入不需要做任何改变。通过使用`Input.get_axis()`并传入四个输入事件，无论玩家是按下了键还是移动了摇杆，你都会得到一个结果。按下键等同于将摇杆推到一端。
- en: Now that the project is set up, you can start making your game objects, starting
    with the player-controlled airplane.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经设置好了，你可以开始创建你的游戏对象，从玩家控制的飞机开始。
- en: Airplane scene
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞机场景
- en: In this section, you’ll create the airplane that the player will control. It
    will fly forward while the player can move it up, down, left, and right.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建玩家将控制的飞机。当玩家可以上下左右移动时，飞机将向前飞行。
- en: Start your new plane scene with a `CharacterBody3D` node named `Plane` and save
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为`Plane`的`CharacterBody3D`节点开始您的新飞机场景，并保存它。
- en: You can find the 3D model for the airplane in the `assets` folder, named `cartoon_plane.glb`.
    The name indicates the model is stored as a *binary* `.gltf` file (exported from
    Blender). Godot imports `.gltf` files as scenes containing meshes, animations,
    materials, and other objects that may have been exported in the file. Click the
    `Node3D`, but it’s facing the wrong direction. Select it and set the `180` in
    the Inspector feature, so that it points along the *z* axis, which is Godot’s
    “forward” direction. Note that typing the value directly is easier than trying
    to rotate the node exactly using the mouse.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`assets`文件夹中找到飞机的3D模型，命名为`cartoon_plane.glb`。这个名字表明该模型以*二进制* `.gltf`文件格式存储（由Blender导出）。Godot将`.gltf`文件导入为包含网格、动画、材质和其他可能已导出在文件中的对象的场景。点击`Node3D`，但它的方向是错误的。选择它，并在检查器功能中设置`180`，使其指向*z*轴，这是Godot的“前进”方向。请注意，直接输入值比尝试使用鼠标精确旋转节点要容易。
- en: Model orientation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型方向
- en: As mentioned in the previous chapter, the various 3D design programs use different
    axis orientations. It’s very common to import your model and have its forward
    direction not match Godot’s. If you’re making the model yourself, you can correct
    this when you export it, but when you’re using a model made by someone else, it’s
    common to need to reorient it in Godot.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，不同的3D设计程序使用不同的轴方向。导入模型时，其前进方向不匹配Godot的情况非常常见。如果您自己制作模型，您可以在导出时纠正这一点，但使用他人制作的模型时，通常需要在Godot中重新定位它。
- en: 'If you right-click on the `cartoon_plane` node and choose `AnimationPlayer`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`cartoon_plane`节点上右键单击并选择`AnimationPlayer`：
- en: '![Figure 6.3: Airplane meshes](img/B19289_06_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：飞机网格](img/B19289_06_03.jpg)'
- en: 'Figure 6.3: Airplane meshes'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：飞机网格
- en: '`AnimationPlayer` contains an animation for making the propeller spin, so select
    it and set the `prop_spin` animation for the **Autoplay on** **Load** function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationPlayer`包含一个使螺旋桨旋转的动画，因此选择它，并将`prop_spin`动画设置为**加载时自动播放**功能：'
- en: '![Figure 6.4: Autoplay animation](img/B19289_06_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：自动播放动画](img/B19289_06_04.jpg)'
- en: 'Figure 6.4: Autoplay animation'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：自动播放动画
- en: Collision shapes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞形状
- en: Add a `CollisionShape3D` node to `Plane` and choose `90` to align it with the
    plane’s fuselage. You can do this with the gizmo (don’t forget to turn on snapping
    using the “Use Smart Snap” icon to get it perfectly aligned) or by typing the
    value directly into Inspector.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CollisionShape3D`节点添加到`Plane`，并选择`90`以使其与飞机的机身对齐。您可以使用gizmo（别忘了使用“使用智能吸附”图标打开吸附以使其完美对齐）或直接在检查器中输入值。
- en: '![](img/B19289_06_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19289_06_05.jpg)'
- en: 'The wings also need to be covered, so add a second `CollisionShape3D` node.
    This time, use `BoxShape3D`. Size it to cover the wings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 翼也需要被覆盖，因此添加第二个`CollisionShape3D`节点。这次，使用`BoxShape3D`。将其调整到覆盖翼的尺寸：
- en: '![Figure 6.5: Airplane collision shapes](img/B19289_06_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：飞机碰撞形状](img/B19289_06_06.jpg)'
- en: 'Figure 6.5: Airplane collision shapes'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：飞机碰撞形状
- en: Scripting the plane
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写飞机脚本
- en: 'You can begin with the airplane’s controls. There are two axes of movement:
    “pitch up” and “pitch down” will raise or lower the nose of the plane (rotating
    around its *x* axis), causing it to move up or down. The `roll_left` and `roll_right`
    functions will rotate the plane around its *z* axis, which causes it to go left
    or right.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从飞机的控制开始。有两个移动轴：“抬头”和“低头”将抬起或降低飞机的机头（绕其*x*轴旋转），使其向上或向下移动。`roll_left`和`roll_right`函数将飞机绕其*z*轴旋转，使其向左或向右移动。
- en: For either input, you’ll want smooth rotation, and when the player lets go of
    the button or returns the stick to the center, the plane should smoothly rotate
    back to its original position. You can do this by **interpolating** the rotation
    rather than setting it directly when rotating.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何输入，您都希望旋转平滑，当玩家松开按钮或将操纵杆返回中心时，飞机应平滑地旋转回其原始位置。您可以通过**插值**旋转而不是直接设置旋转来实现这一点。
- en: About interpolation
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于插值
- en: '**Linear interpolation**, typically abbreviated to **lerp**, is a term that
    you’ll encounter often in game development. It means to calculate an intermediate
    value between two given values, using a straight-line function. In practice, it
    can be used to smoothly change a value from one value to another over time.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性插值**，通常缩写为 **lerp**，是你在游戏开发中经常会遇到的一个术语。这意味着使用直线函数计算两个给定值之间的中间值。在实践中，它可以用来在一段时间内平滑地从一个值变化到另一个值。'
- en: 'To begin, attach a script to the `Plane` node and define some variables:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将脚本附加到 `Plane` 节点并定义一些变量：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The exported variables let you set the speed of the plane’s rotation in either
    direction, as well as the speed of its automatic return to level flight.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的变量让你可以设置飞机旋转的速度，无论是哪个方向，以及它自动返回水平飞行的速度。
- en: 'In your `get_input()` function, you’ll check the values of the inputs from
    **Input Map** to determine which way to rotate:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `get_input()` 函数中，你将检查来自 **输入映射** 的输入值，以确定旋转的方向：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Input.get_axis()` function returns a value between `-1` and `1` based on
    the two inputs. When using keys, which can only be pressed or not pressed, that
    will mean you’ll only get `-1` when one key is pressed, `1` for the other, and
    `0` when neither or both are pressed. However, when using an analog input such
    as a joystick axis, you can get the full range of values. This allows more precise
    control, as tilting the joystick only slightly to the right will give a small
    `roll_input` value of `0.25`, for example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input.get_axis()` 函数根据两个输入返回一个介于 `-1` 和 `1` 之间的值。当使用只能按下或未按下的按键时，这意味着当按下其中一个键时，你会得到
    `-1`，另一个键为 `1`，当两个键都未按下或都按下时，为 `0`。然而，当使用类似摇杆轴这样的模拟输入时，你可以得到完整的值范围。这允许更精确的控制，例如，将摇杆稍微向右倾斜只会给出小的
    `roll_input` 值，例如 `0.25`。'
- en: 'In `_physics_process()`, you can then rotate the plane on its *x* axis based
    on the pitch input:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_physics_process()` 中，你可以根据俯仰输入在 *x* 轴上旋转飞机：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s also important to use `clamp()` to limit the rotation so the plane doesn’t
    flip completely upside down.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `clamp()` 也很重要，以限制旋转，这样飞机就不会完全翻转过来。
- en: 'You can test this out by making a new test scene and adding the plane and `Camera3D`,
    like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个新的测试场景并添加飞机和 `Camera3D` 来测试这一点，如下所示：
- en: '![Figure 6.6: Test scene](img/B19289_06_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：测试场景](img/B19289_06_07.jpg)'
- en: 'Figure 6.6: Test scene'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：测试场景
- en: Position the camera behind the plane and run the scene to test that pressing
    the pitch up and pitch down inputs correctly tilts the plane up and down.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将摄像机放置在飞机后面，运行场景以测试按下俯仰向上和俯仰向下输入是否能够正确地使飞机上下倾斜。
- en: 'For the roll, you could rotate the body in the *z* axis as well, but then the
    two rotations would add together, and you’d find it very difficult to get the
    plane back to level flight. Since for this game, you want the plane to continue
    going forward, it will be easier to rotate the child mesh instead. Add this line
    next in `_physics_process()`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于滚转，你可以在 *z* 轴上旋转机身，但这样两次旋转会相加，你会发现很难将飞机恢复到水平飞行。由于在这个游戏中，你希望飞机继续向前飞行，旋转子网格会更简单。在
    `_physics_process()` 中添加此行：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Test it again in your test scene and make sure that the controls all work as
    expected.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在测试场景中测试它，并确保所有控制都按预期工作。
- en: 'To finish up the movement, add two more variables at the top of the script.
    Your plane’s flying speed will be `forward_speed`. You’ll adjust this later to
    change the difficulty of the game. You can use `max_altitude` to keep the plane
    from climbing offscreen:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成移动，在脚本顶部添加两个更多变量。你的飞机飞行速度将是 `forward_speed`。你将在以后调整它以改变游戏的难度。你可以使用 `max_altitude`
    来防止飞机飞出屏幕：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In `get_input()`, after checking the inputs, add this to cause the plane to
    level out if it reaches the maximum altitude:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get_input()` 中，检查输入后，添加以下内容以使飞机在达到最大高度时水平：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, add this to `_physics_process()` to handle the movement. The forward
    velocity will be the `forward_speed` amount:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此行添加到 `_physics_process()` 中以处理移动。前进速度将是 `forward_speed` 的量：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the side-to-side movement (in the *x* direction), you can multiply by the
    amount of rotation to make it faster or slower depending on how much the plane
    has rolled. Then, scale the speed based on the forward speed (dividing by two
    to make it a little bit slower – experiment here to change the feel):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于侧向移动（在 *x* 方向上），你可以乘以旋转量以使其更快或更慢，这取决于飞机滚转了多少。然后，根据前进速度（除以二以使其稍微慢一点——在这里进行实验以改变感觉）来调整速度：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your plane should now be flying forward and the controls should be working as
    expected. Don’t move on to the next step until you’ve checked that the plane behaves
    correctly. In the next section, you will build the environment for the plane to
    fly around in.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的飞机现在应该正在向前飞行，并且控制应该按预期工作。在检查飞机行为正确之前，不要进行到下一步。在下一节中，你将为飞机飞行创建环境。
- en: Building the world
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建世界
- en: Because this is an *infinite*-style game, the player will continue to fly through
    the world as long as possible. That means you will need to continuously create
    more of the world for them to see – random buildings, items to collect, and so
    on. It would be impractical to create this all ahead of time both because you
    don’t know how far the player will go, and because you don’t want the game to
    be the same every time you play. It would also be inefficient to load a huge game
    world if the player isn’t going to see most of it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个**无限**风格的游戏，玩家将尽可能长时间地飞越世界。这意味着你需要不断地为他们创建更多的世界，以便他们可以看到——随机建筑物、要收集的项目等等。如果玩家不会看到大部分游戏世界，那么提前创建所有这些将是不切实际的。此外，如果玩家不会看到大部分游戏世界，那么加载一个巨大的游戏世界也将是不高效的。
- en: For that reason, it makes more sense to use a **chunking** strategy. You’ll
    randomly generate the world in smaller pieces, or chunks. You can then create
    these as they’re needed – as the player moves forward. You can also remove them
    once they’ve been passed when the game doesn’t need to keep track of them anymore.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用**分块**策略更为合理。你将随机生成世界的较小部分，或者称为块。你可以在需要时创建这些块——当玩家向前移动时。一旦它们被通过，当游戏不再需要跟踪它们时，你也可以移除它们。
- en: World objects
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界对象
- en: 'Each time you generate a new chunk of the world, it’s going to contain a number
    of different world objects. You can begin with two: buildings, which will be obstacles,
    and rings that the player tries to collect by flying through them.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每次生成世界的新块时，它将包含多个不同的世界对象。你可以从两个开始：建筑物，它们将是障碍物，以及玩家通过飞行尝试收集的环。
- en: Buildings
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建筑物
- en: For the first building, start a new scene with a `StaticBody3D` node and name
    it `Building1`. Add a `MeshInstance3D` node and drag `res://assets/building_meshes/Build_01.obj`
    into the `.glTF` file, the building’s mesh is stored in the *OBJ* format. There
    is also a separate `.mtl` file that contains the mesh’s material – Godot hides
    it in the **FileSystem** panel, but it will be used for the texture in the mesh
    instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一座建筑物，使用一个`StaticBody3D`节点开始一个新的场景，并将其命名为`Building1`。添加一个`MeshInstance3D`节点，并将`res://assets/building_meshes/Build_01.obj`拖入`.glTF`文件中，建筑物的网格存储在*OBJ*格式中。还有一个单独的`.mtl`文件，其中包含网格的材料——Godot将其隐藏在**文件系统**面板中，但它将被用于网格实例中的纹理。
- en: You’ll notice that the building is centered on the origin. Since your buildings
    are going to be of different sizes, this will make it difficult to place them
    all on the ground – they’ll all have different offsets. If your buildings are
    all consistently offset ahead of time, then they can be more easily placed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到建筑物以原点为中心。由于你的建筑物大小不一，这将使它们难以全部放置在地面上——它们将具有不同的偏移量。如果您的建筑物在事先都保持一致偏移，那么它们可以更容易地放置。
- en: To position the building mesh, change the `MeshInstance3D` node to `(0, 6, -8)`,
    which moves it up and places its edge on the origin. Add a collision shape by
    selecting the mesh and choosing **Mesh** -> **Create Trimesh** **Collision Sibling**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位建筑网格，将`MeshInstance3D`节点更改为`(0, 6, -8)`，这将将其向上移动并将其边缘放置在原点上。通过选择网格并选择**网格**
    -> **创建三角形网格** **碰撞兄弟**来添加碰撞形状。
- en: 'Save the scene in a new folder called `res://buildings/` and repeat the process
    with the other buildings, starting each scene with a `StaticBody3D` node, adding
    the mesh, offsetting it, and then creating the collision shape. Since each building
    is a different size, here are the offsets that will position them perfectly:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`res://buildings/`的新文件夹中保存场景，并使用其他建筑物重复此过程，每个场景都从`StaticBody3D`节点开始，添加网格，偏移它，然后创建碰撞形状。由于每座建筑的大小不同，以下是将它们完美定位的偏移量：
- en: '| **Building** | **Offset** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **建筑** | **偏移** |'
- en: '| `1` | `(0,` `6, -8)` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `(0,` `6, -8)` |'
- en: '| `2` | `(0,` `8, -4)` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `(0,` `8, -4)` |'
- en: '| `3` | `(0,` `10, -6)` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `(0,` `10, -6)` |'
- en: '| `4` | `(0,` `10, -6)` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `(0,` `10, -6)` |'
- en: '| `5` | `(0,` `11, -4)` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `(0,` `11, -4)` |'
- en: The chunk can now load and instance these buildings randomly to create a varied
    city skyline.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在块可以随机加载和实例化这些建筑物，以创建多样化的城市天际线。
- en: Rings
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环
- en: Rings will appear ahead of the player, and the plane needs to fly through them
    to score. If the plane is very close to the center of the ring, the player will
    get a score bonus. As the game progresses, the rings can become more difficult
    to catch – changing size, moving back and forth, and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Before starting, and without looking ahead, think about which type of node would
    be best for the ring object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Did you select `Area3D`? Since you want to detect when the plane flies through
    the ring, but not collide with it, an area’s `body_entered` detection will be
    the ideal solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Start the new `Ring` scene with `Area3D` and add a `MeshInstance3D` child. For
    `TorusMesh`, and in the mesh properties, set `3.5` and `4`, so that you have a
    narrow ring.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Add a `CollisionShape3D` node and choose `.5` and `3`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Later, you’ll want to animate the ring moving up and down. An easy way to do
    this will be to move the collision shape relative to the root node’s position.
    Since you’ll want the mesh to move as well, drag the mesh to make it a child of
    `CollisionShape3D`. Rotate the collision shape 90 degrees around *x* to make it
    stand up.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A plain white ring is not very exciting, so you can add texture. In the `MeshInstance3D`,
    add `res://assets/textures/texture_09.png`. You’ll notice that the texture, which
    is a grid of alternating light and dark squares, looks very stretched around the
    torus. You can adjust how a texture is wrapped around the mesh by changing the
    `(12, 1, 1)` for a beginning value and adjust it to your liking. Under **Shading**,
    set **Shading Mode** to **Unshaded** – this will ensure that the ring ignores
    lighting and shadows, keeping it bright and visible at all times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `Label3D` node to the `Ring` node. You’ll use this to show the player
    how many points they scored for the ring and whether or not they got the center
    bonus. Set the `100` so you can see something to test. Under `Baloo2-Medium.ttf`
    from the assets folder and set the font size to `720`. To make the text always
    face the camera, set **Flags/Billboard** to **Enabled**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to the ring and connect the `body_entered` signal. The `Label3D`
    function should be hidden at first, and the ring will be hidden when the plane
    touches it. There’s a problem, though: what if a ring spawns and overlaps a building?
    The `body_entered` signal will still be triggered, but you don’t want the building
    to collect the ring!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'You can solve this by setting collision layers. On the `Plane` scene, change
    its `2` (removing `1`), then come back to the `Ring` node and set its `2`. Now,
    you can be sure that if the ring sees a body enter, it can only be the plane:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that, you need to find the distance from the plane to the center of the
    ring to see if the player scored the bonus and set the `text` property to the
    correct value. If the plane hits the ring directly in the center (closer than
    2.0 units), you can also color the text yellow to indicate the perfect hit:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Continuing the `_on_body_entered()` function, add some animation to the label
    to make it move and fade out:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写`_on_body_entered()`函数，给标签添加一些动画，使其移动并淡出：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, give the ring a nice rotation effect:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给环添加一个漂亮的旋转效果：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Chunks
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: Now that you’ve got the building blocks of your chunk, you can make the chunk
    scene itself. This is the scene that the game will instance whenever there needs
    to be more of the world ahead of the player. When you instantiate a new chunk,
    it will randomly place buildings along the left and right sides, as well as spawning
    rings at random points along its length.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了块的基本构建块，你可以制作块场景本身。这是游戏在需要玩家前方有更多世界时实例化的场景。当你实例化一个新的块时，它将在左右两侧随机放置建筑物，并在其长度上随机生成环。
- en: 'Start the `Chunk` scene with a `Node3D` node and a `MeshInstance3D` child named
    `Ground`. Make the `PlaneMesh` and set its `(50, 200)`. This is the size of a
    single chunk:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Node3D`节点和名为`Ground`的`MeshInstance3D`子节点启动`Chunk`场景。将`PlaneMesh`设置为`(50,
    200)`。这是单个块的大小：
- en: '![Figure 6.7: Plane size settings](img/B19289_06_08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7：飞机大小设置](img/B19289_06_08.jpg)'
- en: 'Figure 6.7: Plane size settings'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：飞机大小设置
- en: 'Position it to start at the origin by setting its `-100`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其设置为`-100`来定位它以从原点开始：
- en: '![Figure 6.8: Positioning the plane](img/B19289_06_09.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：定位飞机](img/B19289_06_09.jpg)'
- en: 'Figure 6.8: Positioning the plane'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：定位飞机
- en: 'Add material and use `texture_01.png` as the `(2, 10, 2)`. By default, Godot
    links the three scale values to keep them the same, so you’ll need to uncheck
    the link button to allow them to be different:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加材质并使用`texture_01.png`作为`(2, 10, 2)`。默认情况下，Godot会将三个比例值链接起来以保持它们相同，因此你需要取消选中链接按钮以允许它们不同：
- en: '![Figure 6.9: Adjusting the UV scale](img/B19289_06_10.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：调整UV比例](img/B19289_06_10.jpg)'
- en: 'Figure 6.9: Adjusting the UV scale'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：调整UV比例
- en: Select the `Ground` node and choose `StaticBody3D` node and a `CollisionShape3D`
    node that matches the size of the ground.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Ground`节点，并选择与地面大小匹配的`StaticBody3D`节点和`CollisionShape3D`节点。
- en: As the plane moves toward the end of the chunk, you’ll spawn a new chunk ahead,
    and you can also remove old chunks once they’ve passed by. To assist with the
    latter, add a `VisibleOnScreenNotifier3D` node and set its `0, 0, -250)`, which
    places it past the end of the ground plane.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞机移动到块末尾时，你会在前方生成一个新的块，并且一旦旧块通过，你也可以移除它们。为了辅助后者，添加一个`VisibleOnScreenNotifier3D`节点并将其设置为`(0,
    0, -250)`，这样它就会位于地面平面的末端之外。
- en: 'You can now add a script to the `Chunk` node and connect the notifier’s `screen_exited`
    signal so that the chunk will be removed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以向`Chunk`节点添加一个脚本，并将通知器的`screen_exited`信号连接起来，以便移除块：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the top of the script, load the scenes that need to be instanced:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部，加载需要实例化的场景：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Loading many scenes
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 加载许多场景
- en: In a bigger game, where you have a much larger number of buildings and possibly
    other scenes, you wouldn’t want to write them all out individually in the script
    as you’ve done here. Another solution would be to write code here that loads every
    scene file saved in a particular folder.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更大的游戏中，如果你有更多的建筑物和其他场景，你不想像这里一样在脚本中逐个写出它们。另一个解决方案是在这里编写代码，以加载特定文件夹中保存的每个场景文件。
- en: The `level` variable can be set by the main scene when the chunk is loaded to
    allow increasing difficulty by spawning rings with different behaviors (more about
    that later).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`level`变量可以在块加载时由主场景设置，以便通过生成具有不同行为的环来增加难度（关于这一点稍后介绍）。'
- en: 'In `_ready()`, the chunk needs to do three things:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_ready()`中，块需要做三件事：
- en: Spawn buildings along the sides of the ground plane
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地面平面的两侧生成建筑物
- en: Occasionally spawn buildings in the middle to act as obstacles
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不时在中间生成建筑物作为障碍物
- en: Spawn rings
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成环
- en: 'Each of these steps will involve some code, so you can keep it all organized
    by creating three separate functions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤中的每一个都会涉及一些代码，因此你可以通过创建三个单独的函数来保持所有内容的组织：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first step is to spawn the side buildings. Since they need to be on both
    sides of the chunk, you repeat the loop twice – once for the positive *x* direction
    and once for the negative direction. Each time, you’ll move along the length of
    the chunk spawning random buildings:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是生成侧建筑物。由于它们需要位于块的两侧，你需要重复循环两次——一次用于正*x*方向，一次用于负方向。每次，你都会沿着块的长边生成随机的建筑物：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `randf()` function is a common random function that returns a floating point
    number between `0` and `1`, making it easy to use to calculate percentages. Check
    here if the random number is greater than `0.75` to have a 25% chance of there
    being no building at a particular spot.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`randf()` 函数是一个常见的随机函数，它返回一个介于 `0` 和 `1` 之间的浮点数，这使得它很容易用于计算百分比。检查随机数是否大于 `0.75`，以有
    25% 的几率在特定位置没有建筑物。'
- en: By getting the size of the building mesh using `get_aabb()`, you can ensure
    that the buildings don’t overlap each other. The position of the next building
    will be exactly at the edge of the previous one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `get_aabb()` 获取建筑物网格的大小，你可以确保建筑物不会相互重叠。下一个建筑物的位置将正好位于前一个建筑物的边缘。
- en: 'Next, spawning middle buildings won’t happen at the start, but later in the
    game, they’ll start appearing with a 20% probability:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，中间建筑物的生成不会在游戏开始时发生，但在游戏后期，它们将以 20% 的概率开始出现：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The third step is spawning the rings. Right now, it just positions some rings
    at random fixed positions. Later, you’ll add some more variation here as the game
    progresses:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是生成环形。目前，它只是在随机固定的位置放置了一些环形。随着游戏的进行，你将在这里添加更多变化：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You’re finished setting up the chunk. When it loads, it takes care of populating
    itself with a random assortment of buildings and rings, and it also removes itself
    when it later goes offscreen. In the next section, you’ll bring it all together
    in a scene that instantiates chunks as the plane moves forward.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了块设置的配置。当它加载时，它会随机填充建筑物和环形，并在稍后它离开屏幕时将其删除。在下一节中，你将在场景中实例化块，当飞机向前移动时。
- en: Main scene
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主场景
- en: In this section, you’ll make the main scene, which, in this game, will handle
    loading the world chunks, displaying the game information, and starting and ending
    the game.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建主场景，在这个游戏中，它将负责加载世界块、显示游戏信息和开始及结束游戏。
- en: Start a new scene with a `Node3D` named `Main`. Add an instance of the `Plane`
    and an instance of the `Chunk` to start with.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 `Main` 的 `Node3D` 开始一个新的场景。添加一个 `Plane` 实例和一个 `Chunk` 实例以开始。
- en: 'You’ll also need some lighting, so in the toolbar, choose the “Edit Sun and
    Environment settings” dropdown and add the sun and environment to the scene:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一些照明，因此请在工具栏中选择“编辑太阳和环境设置”下拉菜单，并将太阳和环境添加到场景中：
- en: '![Figure 6.10: Add environment and sun](img/B19289_06_11.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10：添加环境和太阳](img/B19289_06_11.jpg)'
- en: 'Figure 6.10: Add environment and sun'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：添加环境和太阳
- en: 'Rather than use the generated sky texture, you can use `styled_sky.hdr` found
    in the assets folder. Select `WorldEnvironment` and then expand its `ProdeduralSkyMaterial`.
    Click the down arrow and choose `styled_sky.hdr`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择不使用生成的天空纹理，而是使用在资产文件夹中找到的 `styled_sky.hdr`。选择 `WorldEnvironment` 并展开其 `ProceduralSkyMaterial`。点击向下箭头并选择
    `styled_sky.hdr`：
- en: '![Figure 6.11: WorldEnvironment sky settings](img/B19289_06_12.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11：WorldEnvironment 天空设置](img/B19289_06_12.jpg)'
- en: 'Figure 6.11: WorldEnvironment sky settings'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：WorldEnvironment 天空设置
- en: 'Before you can test, you’ll also need a camera. Add a `Camera3D` and then add
    a script to it. Since it’s a standalone node without any children, you don’t need
    to make it a separate saved scene:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以测试之前，你还需要一个相机。添加一个 `Camera3D` 并将其添加到脚本中。由于它是一个没有子节点的独立节点，你不需要将其作为单独保存的场景：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This camera script is generic and could be used in other projects where you
    want a camera to follow a moving 3D object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相机脚本是一般的，可以在其他项目中使用，其中你希望相机跟随一个移动的 3D 对象。
- en: Select the `Camera3D` node and in Inspector, click `Plane` node. Set `(7, 7,
    15)`, which will keep the camera behind, above, and to the right of the plane.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `Camera3D` 节点，并在检查器中点击 `Plane` 节点。设置 `(7, 7, 15)`，这将使相机位于平面的后方、上方和右侧。
- en: '![Figure 6.12: Camera follow settings](img/B19289_06_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12：相机跟随设置](img/B19289_06_13.jpg)'
- en: 'Figure 6.12: Camera follow settings'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12：相机跟随设置
- en: Play the `Main` scene and you should be able to fly along the chunk, collecting
    rings. If you run into the buildings, nothing will happen, and when you reach
    the end of the chunk, you won’t see another one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 播放 `Main` 场景，你应该能够沿着块飞行，收集环形。如果你撞到建筑物，什么也不会发生，当你到达块的尽头时，你将看不到另一个块。
- en: Spawning new chunks
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成新的块
- en: The length of each chunk is `200`, so when the plane has traveled half that
    distance, a new chunk should spawn ahead at the end position of the previous chunk.
    The `max_position` setting will keep track of the middle of the next chunk ahead,
    which is the position that the plane needs to reach to spawn a new chunk.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also keep track of how many chunks have been spawned, so you can use
    that to determine when the game should get harder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to `Main` and add the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that everything is moving forward in the *-z* direction, so the position
    at the center of the first chunk will have a *z* value of `-100`. The plane’s
    *z* coordinate will continue to decrease as it moves forward.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_process()`, you’ll check the plane’s position, and if it goes past `max_position`,
    it’s time to instantiate a new chunk and update `max_position` to the center of
    the next chunk:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here is where the chunk spawning happens. The new chunk gets placed at the end
    of the previous one. Remember that `max_position` is the center of the chunk,
    so you also need to add `chunk_size /` `2`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Then, to get the level number, dividing by `4` results in `5`, `5/4` is just
    `1`. The level will reach `2` at chunk number `8`, `3` at chunk number `12`, and
    so on. This will give you a gradual increase in difficulty.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Play the scene. You should now see the new chunks appearing ahead of the plane
    as it moves forward.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Increasing difficulty
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’re spawning chunks, they’re being given a level value that gradually
    increases. You can use that to start making the rings more challenging to collect.
    For example, currently, they’re placed exactly in the center, so the player doesn’t
    need to steer left or right at all. You could start randomizing the *x* coordinate
    of the rings. You could also start making the rings move back and forth or up
    and down.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these variables to the top of `ring.gd`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The two Boolean variables will let you turn on movement in the *x* or *y* direction,
    and `move_amount` and `move_speed` will let you control how much movement you
    want.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'When those values are set, you can check `_ready()`, start the movement, then
    use a tween:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that by default, a tween starts playing automatically. Since you may or
    may not be actually animating a property, depending on what level the player is
    on, you can use `stop()` to stop the tween initially and then use `play()` to
    start it once you’ve set up which property you want to affect. By using `set_loops()`,
    you’re telling the tween to repeat the two moves endlessly, moving back and forth.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the ring is ready to move, your chunk can set these values when it spawns
    the ring. Go to `chunk.gd` and update the section that spawns rings to use `level`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, once the level reaches `1`, the rings will start moving up and
    down. At level `2`, they’ll start to have a random *x* position, and at level
    `3`, they’ll start moving horizontally.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You should consider this an example of what’s possible. Feel free to create
    your own pattern of increasing difficulty.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将此视为可能性的一个示例。请随意创建自己的难度递增模式。
- en: Collisions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞
- en: The next step is to make the plane explode if it runs into anything, such as
    the ground or the buildings. If it does, you’ll play an explosion animation, and
    that’s the end of the game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让飞机在遇到任何东西，如地面或建筑物时爆炸。如果它真的爆炸了，你将播放一个爆炸动画，游戏也就结束了。
- en: Explosion
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 爆炸
- en: Go to your `Plane` scene and add an `AnimatedSprite3D` child. Name it `Explosion`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的 `Plane` 场景并添加一个 `AnimatedSprite3D` 子节点。将其命名为 `Explosion`。
- en: 'The `AnimatedSprite3D` node works very much like the 2D version you used earlier
    in the book. Add a new `SpriteFrames` resource in the `res://assets/smoke/` into
    the `10` FPS, and turn off **Loop**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimatedSprite3D` 节点的工作方式与你在书中早期使用的 2D 版本非常相似。在 `res://assets/smoke/` 中添加一个新的
    `SpriteFrames` 资源到 `10` FPS，并关闭 **Loop**：'
- en: '![Figure 6.13: Explosion sprite frames](img/B19289_06_14.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13：爆炸精灵帧](img/B19289_06_14.jpg)'
- en: 'Figure 6.13: Explosion sprite frames'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：爆炸精灵帧
- en: You may notice that you can’t see the sprite in the viewport. When displaying
    a 2D image, which is drawn in pixels, in 3D, the engine needs to know how big
    a pixel is in 3D space. To size the explosion to match the size of the plane,
    set `0.5` in Inspector. Under **Flags**, set **Billboard** to enabled. This ensures
    that the sprite always faces the camera. You should now see a large cloud (the
    first frame of the animation) superimposed on your plane.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到你无法在视图中看到精灵。当在 3D 中显示以像素绘制的 2D 图像时，引擎需要知道 3D 空间中像素的大小。为了使爆炸与飞机的大小相匹配，在检查器中将
    `0.5` 设置为大小。在 **Flags** 下，将 **Billboard** 设置为启用。这确保了精灵始终面向相机。你现在应该看到一个大云（动画的第一帧）叠加在你的飞机上。
- en: '![Figure 6.14: Explosion sprite](img/B19289_06_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14：爆炸精灵](img/B19289_06_15.jpg)'
- en: 'Figure 6.14: Explosion sprite'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14：爆炸精灵
- en: You don’t want to see the explosion, so click the eye icon to hide `Explosion`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望看到爆炸，所以点击眼睛图标来隐藏 `Explosion`。
- en: Scripting the collisions
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写碰撞脚本
- en: 'Add a new signal at the top of `plane.gd`, which will notify the game that
    the player has crashed:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `plane.gd` 的顶部添加一个新的信号，该信号将通知游戏玩家已经坠毁：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In `_physics_process()`, you’re using `move_and_slide()` to move the plane.
    Whenever a `CharacterBody3D` node is moved with this method, it can check for
    `move_and_slide()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_physics_process()` 中，你使用 `move_and_slide()` 来移动飞机。每当使用此方法移动 `CharacterBody3D`
    节点时，它可以检查 `move_and_slide()`：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can then define the `die()` function to handle what should happen when
    the plane crashes. First, it will stop moving forward. Then, you can hide the
    plane and show the explosion, playing the animation. Once the animation has ended,
    you can reset the game. Since you haven’t made the title screen yet, you can just
    restart for now:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义 `die()` 函数来处理飞机坠毁时应该发生的事情。首先，它将停止向前移动。然后，你可以隐藏飞机并显示爆炸，播放动画。一旦动画结束，你可以重置游戏。由于你还没有制作标题屏幕，现在你可以简单地重新开始：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll remove that last line later once the rest of the game has been set up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏设置完成后，你将删除最后一行。
- en: Play the `Main` scene now and try running into something to verify that the
    explosion plays and the scene restarts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在播放 `Main` 场景并尝试撞到某个东西以验证爆炸是否播放并且场景是否重新启动。
- en: Fuel and score
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 燃料和得分
- en: The next step is to keep track of the score earned when collecting the rings.
    You’ll also add a fuel component to the plane. This value will steadily decrease,
    and the game will end if the fuel runs out. The player gets fuel back based on
    collecting the rings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是跟踪收集环时获得的分数。你还将为飞机添加一个燃料组件。这个值将稳步下降，如果燃料耗尽，游戏将结束。玩家通过收集环来获得燃料。
- en: 'Add two new signals at the top of `plane.gd`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `plane.gd` 的顶部添加两个新的信号：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These will notify the UI to display the score and fuel values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将通知 UI 显示得分和燃料值。
- en: 'Then, add these new variables:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加这些新变量：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The setter functions for these variables will update them and emit the signals:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的设置函数将更新它们并发出信号：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To reduce the fuel over time, add this line to `_physics_process()`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了随着时间的推移减少燃料，将此行添加到 `_physics_process()`：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Try playing the main scene and you’ll see that you run out of fuel and explode
    after about 10 seconds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试播放主场景，你会看到大约10秒后燃料耗尽并爆炸。
- en: 'Now, you can make the rings update the score and give some fuel back based
    on how close the player was to the center of the ring. You’re already setting
    the ring’s label, and you can do the rest in the same section of `ring.gd`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以让环形更新分数，并根据玩家距离环形中心的远近给予一些燃料。你已经在设置环的标签，你可以在`ring.gd`的同一部分做剩下的工作：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you test again, you should be able to fly longer as long as you keep collecting
    rings. It’s hard to tell how much fuel you have left, though, so you should add
    a UI overlay that displays the fuel and the score.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次测试，你应该能够飞得更久，只要你继续收集环形。然而，很难判断你剩下多少燃料，所以你应该添加一个UI叠加层来显示燃料和分数。
- en: UI
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI
- en: 'Create a new scene with a `CanvasLayer` layer called “UI”. Add two children:
    `TextureProgressBar` (`FuelBar`) and `Label` (`Score`).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，包含一个名为“UI”的`CanvasLayer`层。添加两个子元素：`TextureProgressBar`（`FuelBar`）和`Label`（`Score`）。
- en: Set the text in the `Score` box `0` and add the font as you’ve done before,
    setting its `48`. Use the toolbar menu to set the layout to **Top Right**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Score`框中设置文本为`0`，并添加字体，就像你之前做的那样，将其设置为`48`。使用工具栏菜单将布局设置为**右上角**。
- en: For `FuelBar`, you have two textures in the `assets` folder. You can use `bar_red.png`
    for the `bar_glass.png` for the `10` and `0.01`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`FuelBar`，在`assets`文件夹中有两个纹理。你可以使用`bar_red.png`用于`bar_glass.png`，对于`10`和`0.01`。
- en: 'You can position the bar in the bottom left, but if you want to resize it,
    you’ll need to change a few more settings. Check the box labeled `6`. You’ll see
    that now, no matter how you resize the bar, the borders remain unstretched:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将条形放置在左下角，但如果你想调整大小，你需要更改更多设置。勾选标有`6`的框。你会看到，无论你如何调整条形的大小，边框都不会拉伸：
- en: '![Figure 6.15: Nine patch stretch settings](img/B19289_06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：九宫格拉伸设置](img/B19289_06_16.jpg)'
- en: 'Figure 6.15: Nine patch stretch settings'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：九宫格拉伸设置
- en: 'Make the bar a comfortable size and then add a script to `UI`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将条形设置为舒适的大小，然后向`UI`添加一个脚本：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add an instance of the UI scene to `Main`. Connect the plane’s `score_changed`
    signal and the `fuel_changed` signal to the functions you just made on the UI:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将UI场景的一个实例添加到`Main`中。将飞机的`score_changed`信号和`fuel_changed`信号连接到你刚刚在UI上制作的函数：
- en: '![Figure 6.16: Connecting the plane’s signal to the UI](img/B19289_06_17.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16：将飞机的信号连接到UI](img/B19289_06_17.jpg)'
- en: 'Figure 6.16: Connecting the plane’s signal to the UI'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：将飞机的信号连接到UI
- en: Play the scene once again and verify that the bar shows the fuel changing and
    that the score updates correctly when rings are collected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 再次播放场景，并验证条形是否显示燃料变化，并且在收集环形时分数是否正确更新。
- en: You are almost done! You have a mostly working game at this point. Take a moment
    to play it a few times to make sure you’re not missing any of the interactions.
    Are the chunks increasing in difficulty as you fly farther? You should see moving
    rings and then rings that spawn to the left and right of the center. Make sure
    to review the previous sections if there’s anything you are unclear about. When
    you’re ready, move on to making the title screen.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了！到目前为止，你有一个基本可以工作的游戏。花点时间玩几次，确保你没有错过任何交互。随着你飞得更远，块是否在增加难度？你应该看到移动的环形，然后是中心左右生成的环形。如果有任何你不清楚的地方，请确保复习前面的部分。当你准备好了，继续制作标题屏幕。
- en: Title screen
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题屏幕
- en: The purpose of the title screen is to introduce the game and give a way to start
    it by pressing a button. This section will not go into much detail on the styling
    – you should experiment with the settings and try to make it look pleasing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕的目的是介绍游戏，并提供一个按钮来开始游戏。本节不会详细介绍样式 – 你应该尝试不同的设置，并尝试让它看起来令人愉悦。
- en: Start your `TitleScreen` scene with a `Control` node and add a `Label` and a
    `TextureButton` plus a `TextureRect` for the background.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Control`节点开始`TitleScreen`场景，并添加一个`Label`、一个`TextureButton`以及一个用于背景的`TextureRect`。
- en: You can use `styled_sky.hdr` for the `TextureRect`’s **Texture** property. It’s
    a lot bigger than the screen size, so feel free to scale and/or position it as
    you like.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`styled_sky.hdr`作为`TextureRect`的**纹理**属性。它比屏幕尺寸大得多，所以你可以随意缩放和/或定位它。
- en: For `TextureButton`, there are three images in the `res://assets/buttons/` folder
    for the **Normal**, **Pressed**, and **Hover** textures. The images are quite
    large to allow for sizing, so you can check **Ignore Texture Size** and set **Stretch
    Mode** to **Keep Aspect** to allow you to resize it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TextureButton`，在`res://assets/buttons/`文件夹中有三个图像用于**正常**、**按下**和**悬停**纹理。图像相当大，允许调整大小，所以你可以勾选**忽略纹理大小**，并将**拉伸模式**设置为**保持纵横比**以允许你调整大小。
- en: The `Label` node is there to display the game’s title. Set up the font with
    large font size, such as `128`. Arrange `Label` and `TextureButton` on the screen.
    Set both of their layouts to **Center** and then move them up and down to position
    them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`节点用于显示游戏标题。设置字体为大号，例如`128`。将`Label`和`TextureButton`放置在屏幕上。将它们的布局都设置为**居中**，然后上下移动以定位它们。'
- en: 'The only code needed is to determine what to do when the button is pressed,
    so add a script to the scene and connect the button’s `pressed` signal. When the
    button is pressed, it should load the main scene:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的唯一代码是确定按钮按下时应该执行的操作，因此向场景添加一个脚本并将按钮的`pressed`信号连接起来。当按钮被按下时，它应该加载主场景：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To return to the title screen at the end of the game, remove `get_tree().reload_current_scene()`
    from the plane’s `die()` function, and then go to the `Main` scene and connect
    the plane instance’s `dead` signal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏结束时返回到标题屏幕，从飞机的`die()`函数中移除`get_tree().reload_current_scene()`，然后转到`Main`场景并连接飞机实例的`dead`信号：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now when you crash, you should immediately return to the title screen, where
    you can press **Play** again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你崩溃时，你应该立即返回到标题屏幕，在那里你可以再次按下**Play**。
- en: Audio
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频
- en: 'There are two sound effect files located in the `assets` folder: `impact.wav`
    for the plane’s explosion and `three_tone.wav` for the ring collection sound.
    You can add `AudioStreamPlayer` nodes to the `Plane` and `Ring` scenes to play
    them at the appropriate time.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`assets`文件夹中有两个声音效果文件：`impact.wav`用于飞机爆炸和`three_tone.wav`用于收集环圈的声音。你可以在`Plane`和`Ring`场景中添加`AudioStreamPlayer`节点，在适当的时间播放它们。
- en: For the background music, which should be played in a loop during the game,
    add `AudioStreamPlayer` to the `Main` scene, using `Riverside Ride Short Loop.wav`
    for **Stream**. Since it needs to play automatically at the start, you can check
    the **Autoplay** box.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景音乐，应在游戏过程中循环播放，将`AudioStreamPlayer`添加到`Main`场景中，使用`Riverside Ride Short
    Loop.wav`作为**流**。由于它需要在开始时自动播放，你可以勾选**自动播放**框。
- en: The audio for this game is intentionally kept simple and upbeat. While there’s
    a sound effect for each major game event (flying through a ring, crashing), you
    could also try adding additional sounds for the airplane engine, bonuses, or a
    warning when fuel is low. Experiment to see what works for you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏的音频故意保持简单和欢快。虽然每个主要游戏事件（如飞过环圈、碰撞）都有声音效果，但你也可以尝试添加额外的声音，如飞机引擎、奖励或燃油低时的警告。尝试看看什么对你有效。
- en: Saving a high score
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存高分
- en: Saving the player’s high score is another common feature in many games (and
    one that you can add to the other games in this book as well). Since the score
    needs to be saved between sessions of the game, you’ll need to save it in an external
    file that the game can read the next time you open it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 保存玩家的最高分是许多游戏中的另一个常见功能（并且你可以将其添加到本书中的其他游戏中）。由于分数需要在游戏会话之间保存，因此你需要将其保存到一个外部文件，以便游戏在下次打开时可以读取它。
- en: 'Here’s the process:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是过程：
- en: When the game launches, check for a save file.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏启动时，检查是否有保存文件。
- en: If the save file exists, load the score from it, otherwise use `0`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在保存文件，则从其中加载分数，否则使用`0`。
- en: When a game ends, check if the score is higher than the current high score.
    If it is, save it to the file.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏结束时，检查分数是否高于当前高分。如果是，将其保存到文件中。
- en: Show the high score on the title screen.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题屏幕上显示高分。
- en: 'Since you’ll need to access the high score variable from different parts of
    your game, it makes sense to use an autoload. In the `global.gd`. To begin, you’ll
    need two variables:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要从游戏的不同部分访问最高分变量，因此使用自动加载是有意义的。在`global.gd`中，首先你需要两个变量：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: About file locations
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于文件位置
- en: 'You’ll notice that the path for the save file doesn’t begin with `res://` like
    all of the other files you’ve been working with. The `res://` designation represents
    your game’s project folder – the place where all the scripts, scenes, and assets
    are located. When you export your game, though, that folder becomes read-only.
    To store persistent data, you use a location on the device that’s set aside for
    the game to write to: `user://`. Where this folder is actually located depends
    on the operating system you’re using. For example, in Windows, it would be `%APPDATA%\Godot\app_userdata\[project_name]`.
    You can find the paths for other supported operating systems here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到保存文件的路径不像您一直在使用的其他所有文件一样以`res://`开头。`res://`指定代表您的游戏项目文件夹——所有脚本、场景和资源都位于该位置。但是，当您导出游戏时，该文件夹变为只读。为了存储持久数据，您使用设备上为游戏写入而预留的位置：`user://`。此文件夹的实际位置取决于您使用的操作系统。例如，在Windows中，它将是`%APPDATA%\Godot\app_userdata\[project_name]`。您可以在以下位置找到其他支持的操作系统的路径：
- en: https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html
- en: Accessing files
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问文件
- en: 'Accessing files in Godot is done via the `FileAccess` object. This object handles
    opening, reading, and writing files. Add these functions to `global.gd`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中，通过`FileAccess`对象访问文件。此对象处理打开、读取和写入文件。将这些函数添加到`global.gd`：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the script calls `load_score()` in `_ready()`, so it’s done
    immediately when the game is launched. The `load_score()` function uses `FileAccess`
    to check if the save file exists, and if it does, it opens it and retrieves the
    data that was stored in it using `get_var()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，脚本在`_ready()`中调用`load_score()`，因此它在游戏启动时立即执行。`load_score()`函数使用`FileAccess`检查保存文件是否存在，如果存在，则打开它并使用`get_var()`检索其中存储的数据。
- en: The `save_score()` function does the opposite. Note that you don’t have to check
    if the file exists – if you try to write to a file that doesn’t exist, it will
    be created.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_score()`函数执行相反的操作。请注意，您不需要检查文件是否存在——如果您尝试写入一个不存在的文件，它将被创建。'
- en: 'Save this script and add it as an autoload in **Project Settings**:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此脚本并将其添加到**项目设置**中的自动加载：
- en: '![Figure 6.17: Adding a global script](img/B19289_06_18.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：添加全局脚本](img/B19289_06_18.jpg)'
- en: 'Figure 6.17: Adding a global script'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：添加全局脚本
- en: 'Go to your `Title` scene and add another `Label` node to display the high score.
    Set its font and arrange it on the screen – the bottom middle might be a good
    choice. Add this to the script, so that the score will be displayed whenever the
    title screen loads:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 前往您的`标题`场景，并添加另一个`标签`节点以显示高分。设置其字体并在屏幕上排列它——底部中间可能是一个不错的选择。将此添加到脚本中，以便在标题屏幕加载时显示分数：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, at the end of the game, you’ll need to check if there’s a new high
    score. The `score` variable is kept on the plane, so open `plane.gd` and find
    the `die()` function, which is called when the game ends. Add a score check and
    call `save_score()` if needed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在游戏结束时，您需要检查是否有新的高分。`score`变量保存在飞机上，因此打开`plane.gd`并找到在游戏结束时被调用的`die()`函数。添加分数检查并在需要时调用`save_score()`：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the game to test that the high score is being displayed, saved, and loaded
    again when you run the game the next time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏以测试高分是否在您下次运行游戏时显示、保存并重新加载。
- en: This technique can be used for any type of data that you want to save between
    runs of your game. It’s a useful technique, so be sure to try it out with your
    own projects in the future. Reusing code is a great way to accelerate development,
    so once you’ve got a save system that you’re happy with, stick with it!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以用于您想要在游戏运行之间保存的任何类型的数据。这是一个有用的技术，所以请确保将来在自己的项目中尝试它。重用代码是加速开发的好方法，所以一旦您对保存系统满意，就坚持使用它！
- en: Suggestions for additional features
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外功能的建议
- en: 'For an additional challenge, try to expand the game by adding more features.
    Here are some suggestions to get you started:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加额外的挑战，尝试通过添加更多功能来扩展游戏。以下是一些启动建议：
- en: Track the distance the player flies in each game, and save the maximum value
    as a high score.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪玩家在每局游戏中飞行的距离，并将最大值保存为高分。
- en: Increase the speed incrementally as time goes on or include boost items that
    increase the plane’s speed.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移逐步增加速度或包括增加飞机速度的加速物品。
- en: Flying obstacles that need to be dodged, such as other planes or birds.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要躲避的飞行障碍物，例如其他飞机或鸟类。
- en: (Advanced) Instead of only straight lines, add curved chunks as well. The player
    will have to steer and the camera will have to move to stay behind them.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （高级）除了直线外，还可以添加曲线块。玩家将需要操控方向，摄像机也需要移动以保持在玩家后面。
- en: This would also be a great game for you to experiment with building a game for
    a mobile platform. See the next chapter for information about exporting games.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个非常适合你尝试为移动平台构建游戏的绝佳机会。下一章将提供有关导出游戏的信息。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you extended your 3D skills by learning about more of Godot’s
    3D nodes, such as the `CharacterBody3D`. You should have a good understanding
    of the 3D transform and how it works to move and rotate an object in space. Randomly
    generating chunks, while relatively simple in this game, is something that you
    can extend to much larger games and more complex environments.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过学习更多Godot的3D节点，如`CharacterBody3D`，扩展了你的3D技能。你应该对3D变换及其在空间中移动和旋转对象的方式有了很好的理解。在这个游戏中随机生成块虽然相对简单，但你可以将其扩展到更大型的游戏和更复杂的环境中。
- en: Congratulations, you’ve made it to the end of the last project! But with these
    five games, your journey to becoming a game developer has just begun.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经完成了最后一个项目！但有了这五个游戏，你成为游戏开发者的旅程才刚刚开始。
- en: In the next chapter, you can read about some other topics that didn’t quite
    fit into the example games, as well as find some pointers for where to go next
    in building your game development skills.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你可以了解一些不适合示例游戏的其他主题，以及一些关于如何进一步提升你的游戏开发技能的指导。
