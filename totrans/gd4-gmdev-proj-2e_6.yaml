- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infinite Flyer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll build a 3D infinite runner (or more accurately, infinite
    *flyer*) in the vein of *Temple Run* or *Subway Surfers*. The player’s goal is
    to fly as far as possible, passing through floating rings to collect points, while
    avoiding obstacles. By building this game, you’ll get a feel for how to make 3D
    objects interact and how to generate a 3D world automatically, rather than building
    it piece-by-piece as you did in earlier games such as *Minigolf* or *Jungle Jump*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the new things you’ll learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using transforms to rotate and move in 3D space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load and unload “chunks” of your game world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to randomly generate the game environment and game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading files for persistent data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `CharacterBody3D` and detecting collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When completed, the game will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Finished game screenshot](img/B19289_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Finished game screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the game assets from the following link and unzip them into your new
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter06%20-%20Infinite%20Flyer)'
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Godot to get started. As you’ve done before, download
    the project assets and unzip them in the new project folder. Once you’ve created
    the project, you’ll start by configuring the inputs and Godot settings needed
    for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll control the plane with up, down, left, and right inputs. You can add
    them in `pitch_up`, `pitch_down`, `roll_left`, and `roll_right`. You can add the
    arrow keys and/or the *W*, *A*, *S*, and *D* keys to these, but if you have a
    game controller, you can also use a joystick for more precise control. To add
    joystick inputs, you can select **Joypad Axes** after pressing the **+** button.
    The values are labeled, such as **Left Stick Up**, so you can easily keep track
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Input configuration](img/B19289_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Input configuration'
  prefs: []
  type: TYPE_NORMAL
- en: The nice part about this setup is that your code won’t have to be any different
    for the different types of input. By using `Input.get_axis()` and passing in the
    four input events, you’ll get a result whether the player pressed a key or moved
    the stick. Pressing the keys is equivalent to pushing the stick all the way in
    one direction.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the project is set up, you can start making your game objects, starting
    with the player-controlled airplane.
  prefs: []
  type: TYPE_NORMAL
- en: Airplane scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll create the airplane that the player will control. It
    will fly forward while the player can move it up, down, left, and right.
  prefs: []
  type: TYPE_NORMAL
- en: Start your new plane scene with a `CharacterBody3D` node named `Plane` and save
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the 3D model for the airplane in the `assets` folder, named `cartoon_plane.glb`.
    The name indicates the model is stored as a *binary* `.gltf` file (exported from
    Blender). Godot imports `.gltf` files as scenes containing meshes, animations,
    materials, and other objects that may have been exported in the file. Click the
    `Node3D`, but it’s facing the wrong direction. Select it and set the `180` in
    the Inspector feature, so that it points along the *z* axis, which is Godot’s
    “forward” direction. Note that typing the value directly is easier than trying
    to rotate the node exactly using the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Model orientation
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, the various 3D design programs use different
    axis orientations. It’s very common to import your model and have its forward
    direction not match Godot’s. If you’re making the model yourself, you can correct
    this when you export it, but when you’re using a model made by someone else, it’s
    common to need to reorient it in Godot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you right-click on the `cartoon_plane` node and choose `AnimationPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Airplane meshes](img/B19289_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Airplane meshes'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnimationPlayer` contains an animation for making the propeller spin, so select
    it and set the `prop_spin` animation for the **Autoplay on** **Load** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Autoplay animation](img/B19289_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Autoplay animation'
  prefs: []
  type: TYPE_NORMAL
- en: Collision shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a `CollisionShape3D` node to `Plane` and choose `90` to align it with the
    plane’s fuselage. You can do this with the gizmo (don’t forget to turn on snapping
    using the “Use Smart Snap” icon to get it perfectly aligned) or by typing the
    value directly into Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19289_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The wings also need to be covered, so add a second `CollisionShape3D` node.
    This time, use `BoxShape3D`. Size it to cover the wings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Airplane collision shapes](img/B19289_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Airplane collision shapes'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can begin with the airplane’s controls. There are two axes of movement:
    “pitch up” and “pitch down” will raise or lower the nose of the plane (rotating
    around its *x* axis), causing it to move up or down. The `roll_left` and `roll_right`
    functions will rotate the plane around its *z* axis, which causes it to go left
    or right.'
  prefs: []
  type: TYPE_NORMAL
- en: For either input, you’ll want smooth rotation, and when the player lets go of
    the button or returns the stick to the center, the plane should smoothly rotate
    back to its original position. You can do this by **interpolating** the rotation
    rather than setting it directly when rotating.
  prefs: []
  type: TYPE_NORMAL
- en: About interpolation
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear interpolation**, typically abbreviated to **lerp**, is a term that
    you’ll encounter often in game development. It means to calculate an intermediate
    value between two given values, using a straight-line function. In practice, it
    can be used to smoothly change a value from one value to another over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, attach a script to the `Plane` node and define some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The exported variables let you set the speed of the plane’s rotation in either
    direction, as well as the speed of its automatic return to level flight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `get_input()` function, you’ll check the values of the inputs from
    **Input Map** to determine which way to rotate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Input.get_axis()` function returns a value between `-1` and `1` based on
    the two inputs. When using keys, which can only be pressed or not pressed, that
    will mean you’ll only get `-1` when one key is pressed, `1` for the other, and
    `0` when neither or both are pressed. However, when using an analog input such
    as a joystick axis, you can get the full range of values. This allows more precise
    control, as tilting the joystick only slightly to the right will give a small
    `roll_input` value of `0.25`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_physics_process()`, you can then rotate the plane on its *x* axis based
    on the pitch input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It’s also important to use `clamp()` to limit the rotation so the plane doesn’t
    flip completely upside down.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test this out by making a new test scene and adding the plane and `Camera3D`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Test scene](img/B19289_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Test scene'
  prefs: []
  type: TYPE_NORMAL
- en: Position the camera behind the plane and run the scene to test that pressing
    the pitch up and pitch down inputs correctly tilts the plane up and down.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the roll, you could rotate the body in the *z* axis as well, but then the
    two rotations would add together, and you’d find it very difficult to get the
    plane back to level flight. Since for this game, you want the plane to continue
    going forward, it will be easier to rotate the child mesh instead. Add this line
    next in `_physics_process()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Test it again in your test scene and make sure that the controls all work as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish up the movement, add two more variables at the top of the script.
    Your plane’s flying speed will be `forward_speed`. You’ll adjust this later to
    change the difficulty of the game. You can use `max_altitude` to keep the plane
    from climbing offscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In `get_input()`, after checking the inputs, add this to cause the plane to
    level out if it reaches the maximum altitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this to `_physics_process()` to handle the movement. The forward
    velocity will be the `forward_speed` amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the side-to-side movement (in the *x* direction), you can multiply by the
    amount of rotation to make it faster or slower depending on how much the plane
    has rolled. Then, scale the speed based on the forward speed (dividing by two
    to make it a little bit slower – experiment here to change the feel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your plane should now be flying forward and the controls should be working as
    expected. Don’t move on to the next step until you’ve checked that the plane behaves
    correctly. In the next section, you will build the environment for the plane to
    fly around in.
  prefs: []
  type: TYPE_NORMAL
- en: Building the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because this is an *infinite*-style game, the player will continue to fly through
    the world as long as possible. That means you will need to continuously create
    more of the world for them to see – random buildings, items to collect, and so
    on. It would be impractical to create this all ahead of time both because you
    don’t know how far the player will go, and because you don’t want the game to
    be the same every time you play. It would also be inefficient to load a huge game
    world if the player isn’t going to see most of it.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, it makes more sense to use a **chunking** strategy. You’ll
    randomly generate the world in smaller pieces, or chunks. You can then create
    these as they’re needed – as the player moves forward. You can also remove them
    once they’ve been passed when the game doesn’t need to keep track of them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: World objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each time you generate a new chunk of the world, it’s going to contain a number
    of different world objects. You can begin with two: buildings, which will be obstacles,
    and rings that the player tries to collect by flying through them.'
  prefs: []
  type: TYPE_NORMAL
- en: Buildings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the first building, start a new scene with a `StaticBody3D` node and name
    it `Building1`. Add a `MeshInstance3D` node and drag `res://assets/building_meshes/Build_01.obj`
    into the `.glTF` file, the building’s mesh is stored in the *OBJ* format. There
    is also a separate `.mtl` file that contains the mesh’s material – Godot hides
    it in the **FileSystem** panel, but it will be used for the texture in the mesh
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that the building is centered on the origin. Since your buildings
    are going to be of different sizes, this will make it difficult to place them
    all on the ground – they’ll all have different offsets. If your buildings are
    all consistently offset ahead of time, then they can be more easily placed.
  prefs: []
  type: TYPE_NORMAL
- en: To position the building mesh, change the `MeshInstance3D` node to `(0, 6, -8)`,
    which moves it up and places its edge on the origin. Add a collision shape by
    selecting the mesh and choosing **Mesh** -> **Create Trimesh** **Collision Sibling**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the scene in a new folder called `res://buildings/` and repeat the process
    with the other buildings, starting each scene with a `StaticBody3D` node, adding
    the mesh, offsetting it, and then creating the collision shape. Since each building
    is a different size, here are the offsets that will position them perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Building** | **Offset** |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `(0,` `6, -8)` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `(0,` `8, -4)` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `(0,` `10, -6)` |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `(0,` `10, -6)` |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `(0,` `11, -4)` |'
  prefs: []
  type: TYPE_TB
- en: The chunk can now load and instance these buildings randomly to create a varied
    city skyline.
  prefs: []
  type: TYPE_NORMAL
- en: Rings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rings will appear ahead of the player, and the plane needs to fly through them
    to score. If the plane is very close to the center of the ring, the player will
    get a score bonus. As the game progresses, the rings can become more difficult
    to catch – changing size, moving back and forth, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting, and without looking ahead, think about which type of node would
    be best for the ring object.
  prefs: []
  type: TYPE_NORMAL
- en: Did you select `Area3D`? Since you want to detect when the plane flies through
    the ring, but not collide with it, an area’s `body_entered` detection will be
    the ideal solution.
  prefs: []
  type: TYPE_NORMAL
- en: Start the new `Ring` scene with `Area3D` and add a `MeshInstance3D` child. For
    `TorusMesh`, and in the mesh properties, set `3.5` and `4`, so that you have a
    narrow ring.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `CollisionShape3D` node and choose `.5` and `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Later, you’ll want to animate the ring moving up and down. An easy way to do
    this will be to move the collision shape relative to the root node’s position.
    Since you’ll want the mesh to move as well, drag the mesh to make it a child of
    `CollisionShape3D`. Rotate the collision shape 90 degrees around *x* to make it
    stand up.
  prefs: []
  type: TYPE_NORMAL
- en: A plain white ring is not very exciting, so you can add texture. In the `MeshInstance3D`,
    add `res://assets/textures/texture_09.png`. You’ll notice that the texture, which
    is a grid of alternating light and dark squares, looks very stretched around the
    torus. You can adjust how a texture is wrapped around the mesh by changing the
    `(12, 1, 1)` for a beginning value and adjust it to your liking. Under **Shading**,
    set **Shading Mode** to **Unshaded** – this will ensure that the ring ignores
    lighting and shadows, keeping it bright and visible at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `Label3D` node to the `Ring` node. You’ll use this to show the player
    how many points they scored for the ring and whether or not they got the center
    bonus. Set the `100` so you can see something to test. Under `Baloo2-Medium.ttf`
    from the assets folder and set the font size to `720`. To make the text always
    face the camera, set **Flags/Billboard** to **Enabled**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to the ring and connect the `body_entered` signal. The `Label3D`
    function should be hidden at first, and the ring will be hidden when the plane
    touches it. There’s a problem, though: what if a ring spawns and overlaps a building?
    The `body_entered` signal will still be triggered, but you don’t want the building
    to collect the ring!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can solve this by setting collision layers. On the `Plane` scene, change
    its `2` (removing `1`), then come back to the `Ring` node and set its `2`. Now,
    you can be sure that if the ring sees a body enter, it can only be the plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you need to find the distance from the plane to the center of the
    ring to see if the player scored the bonus and set the `text` property to the
    correct value. If the plane hits the ring directly in the center (closer than
    2.0 units), you can also color the text yellow to indicate the perfect hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing the `_on_body_entered()` function, add some animation to the label
    to make it move and fade out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, give the ring a nice rotation effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Chunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve got the building blocks of your chunk, you can make the chunk
    scene itself. This is the scene that the game will instance whenever there needs
    to be more of the world ahead of the player. When you instantiate a new chunk,
    it will randomly place buildings along the left and right sides, as well as spawning
    rings at random points along its length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the `Chunk` scene with a `Node3D` node and a `MeshInstance3D` child named
    `Ground`. Make the `PlaneMesh` and set its `(50, 200)`. This is the size of a
    single chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Plane size settings](img/B19289_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Plane size settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Position it to start at the origin by setting its `-100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Positioning the plane](img/B19289_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Positioning the plane'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add material and use `texture_01.png` as the `(2, 10, 2)`. By default, Godot
    links the three scale values to keep them the same, so you’ll need to uncheck
    the link button to allow them to be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Adjusting the UV scale](img/B19289_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Adjusting the UV scale'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Ground` node and choose `StaticBody3D` node and a `CollisionShape3D`
    node that matches the size of the ground.
  prefs: []
  type: TYPE_NORMAL
- en: As the plane moves toward the end of the chunk, you’ll spawn a new chunk ahead,
    and you can also remove old chunks once they’ve passed by. To assist with the
    latter, add a `VisibleOnScreenNotifier3D` node and set its `0, 0, -250)`, which
    places it past the end of the ground plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now add a script to the `Chunk` node and connect the notifier’s `screen_exited`
    signal so that the chunk will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the script, load the scenes that need to be instanced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Loading many scenes
  prefs: []
  type: TYPE_NORMAL
- en: In a bigger game, where you have a much larger number of buildings and possibly
    other scenes, you wouldn’t want to write them all out individually in the script
    as you’ve done here. Another solution would be to write code here that loads every
    scene file saved in a particular folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `level` variable can be set by the main scene when the chunk is loaded to
    allow increasing difficulty by spawning rings with different behaviors (more about
    that later).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_ready()`, the chunk needs to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn buildings along the sides of the ground plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally spawn buildings in the middle to act as obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn rings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these steps will involve some code, so you can keep it all organized
    by creating three separate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to spawn the side buildings. Since they need to be on both
    sides of the chunk, you repeat the loop twice – once for the positive *x* direction
    and once for the negative direction. Each time, you’ll move along the length of
    the chunk spawning random buildings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `randf()` function is a common random function that returns a floating point
    number between `0` and `1`, making it easy to use to calculate percentages. Check
    here if the random number is greater than `0.75` to have a 25% chance of there
    being no building at a particular spot.
  prefs: []
  type: TYPE_NORMAL
- en: By getting the size of the building mesh using `get_aabb()`, you can ensure
    that the buildings don’t overlap each other. The position of the next building
    will be exactly at the edge of the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, spawning middle buildings won’t happen at the start, but later in the
    game, they’ll start appearing with a 20% probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The third step is spawning the rings. Right now, it just positions some rings
    at random fixed positions. Later, you’ll add some more variation here as the game
    progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You’re finished setting up the chunk. When it loads, it takes care of populating
    itself with a random assortment of buildings and rings, and it also removes itself
    when it later goes offscreen. In the next section, you’ll bring it all together
    in a scene that instantiates chunks as the plane moves forward.
  prefs: []
  type: TYPE_NORMAL
- en: Main scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll make the main scene, which, in this game, will handle
    loading the world chunks, displaying the game information, and starting and ending
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new scene with a `Node3D` named `Main`. Add an instance of the `Plane`
    and an instance of the `Chunk` to start with.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also need some lighting, so in the toolbar, choose the “Edit Sun and
    Environment settings” dropdown and add the sun and environment to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Add environment and sun](img/B19289_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Add environment and sun'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than use the generated sky texture, you can use `styled_sky.hdr` found
    in the assets folder. Select `WorldEnvironment` and then expand its `ProdeduralSkyMaterial`.
    Click the down arrow and choose `styled_sky.hdr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: WorldEnvironment sky settings](img/B19289_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: WorldEnvironment sky settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can test, you’ll also need a camera. Add a `Camera3D` and then add
    a script to it. Since it’s a standalone node without any children, you don’t need
    to make it a separate saved scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This camera script is generic and could be used in other projects where you
    want a camera to follow a moving 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Camera3D` node and in Inspector, click `Plane` node. Set `(7, 7,
    15)`, which will keep the camera behind, above, and to the right of the plane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Camera follow settings](img/B19289_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Camera follow settings'
  prefs: []
  type: TYPE_NORMAL
- en: Play the `Main` scene and you should be able to fly along the chunk, collecting
    rings. If you run into the buildings, nothing will happen, and when you reach
    the end of the chunk, you won’t see another one.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning new chunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The length of each chunk is `200`, so when the plane has traveled half that
    distance, a new chunk should spawn ahead at the end position of the previous chunk.
    The `max_position` setting will keep track of the middle of the next chunk ahead,
    which is the position that the plane needs to reach to spawn a new chunk.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also keep track of how many chunks have been spawned, so you can use
    that to determine when the game should get harder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to `Main` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember that everything is moving forward in the *-z* direction, so the position
    at the center of the first chunk will have a *z* value of `-100`. The plane’s
    *z* coordinate will continue to decrease as it moves forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_process()`, you’ll check the plane’s position, and if it goes past `max_position`,
    it’s time to instantiate a new chunk and update `max_position` to the center of
    the next chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here is where the chunk spawning happens. The new chunk gets placed at the end
    of the previous one. Remember that `max_position` is the center of the chunk,
    so you also need to add `chunk_size /` `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to get the level number, dividing by `4` results in `5`, `5/4` is just
    `1`. The level will reach `2` at chunk number `8`, `3` at chunk number `12`, and
    so on. This will give you a gradual increase in difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Play the scene. You should now see the new chunks appearing ahead of the plane
    as it moves forward.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing difficulty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’re spawning chunks, they’re being given a level value that gradually
    increases. You can use that to start making the rings more challenging to collect.
    For example, currently, they’re placed exactly in the center, so the player doesn’t
    need to steer left or right at all. You could start randomizing the *x* coordinate
    of the rings. You could also start making the rings move back and forth or up
    and down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these variables to the top of `ring.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The two Boolean variables will let you turn on movement in the *x* or *y* direction,
    and `move_amount` and `move_speed` will let you control how much movement you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'When those values are set, you can check `_ready()`, start the movement, then
    use a tween:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that by default, a tween starts playing automatically. Since you may or
    may not be actually animating a property, depending on what level the player is
    on, you can use `stop()` to stop the tween initially and then use `play()` to
    start it once you’ve set up which property you want to affect. By using `set_loops()`,
    you’re telling the tween to repeat the two moves endlessly, moving back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the ring is ready to move, your chunk can set these values when it spawns
    the ring. Go to `chunk.gd` and update the section that spawns rings to use `level`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once the level reaches `1`, the rings will start moving up and
    down. At level `2`, they’ll start to have a random *x* position, and at level
    `3`, they’ll start moving horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: You should consider this an example of what’s possible. Feel free to create
    your own pattern of increasing difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to make the plane explode if it runs into anything, such as
    the ground or the buildings. If it does, you’ll play an explosion animation, and
    that’s the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Explosion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go to your `Plane` scene and add an `AnimatedSprite3D` child. Name it `Explosion`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnimatedSprite3D` node works very much like the 2D version you used earlier
    in the book. Add a new `SpriteFrames` resource in the `res://assets/smoke/` into
    the `10` FPS, and turn off **Loop**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: Explosion sprite frames](img/B19289_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Explosion sprite frames'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that you can’t see the sprite in the viewport. When displaying
    a 2D image, which is drawn in pixels, in 3D, the engine needs to know how big
    a pixel is in 3D space. To size the explosion to match the size of the plane,
    set `0.5` in Inspector. Under **Flags**, set **Billboard** to enabled. This ensures
    that the sprite always faces the camera. You should now see a large cloud (the
    first frame of the animation) superimposed on your plane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: Explosion sprite](img/B19289_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Explosion sprite'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want to see the explosion, so click the eye icon to hide `Explosion`.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the collisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new signal at the top of `plane.gd`, which will notify the game that
    the player has crashed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In `_physics_process()`, you’re using `move_and_slide()` to move the plane.
    Whenever a `CharacterBody3D` node is moved with this method, it can check for
    `move_and_slide()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define the `die()` function to handle what should happen when
    the plane crashes. First, it will stop moving forward. Then, you can hide the
    plane and show the explosion, playing the animation. Once the animation has ended,
    you can reset the game. Since you haven’t made the title screen yet, you can just
    restart for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You’ll remove that last line later once the rest of the game has been set up.
  prefs: []
  type: TYPE_NORMAL
- en: Play the `Main` scene now and try running into something to verify that the
    explosion plays and the scene restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Fuel and score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to keep track of the score earned when collecting the rings.
    You’ll also add a fuel component to the plane. This value will steadily decrease,
    and the game will end if the fuel runs out. The player gets fuel back based on
    collecting the rings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two new signals at the top of `plane.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These will notify the UI to display the score and fuel values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add these new variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter functions for these variables will update them and emit the signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To reduce the fuel over time, add this line to `_physics_process()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Try playing the main scene and you’ll see that you run out of fuel and explode
    after about 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can make the rings update the score and give some fuel back based
    on how close the player was to the center of the ring. You’re already setting
    the ring’s label, and you can do the rest in the same section of `ring.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you test again, you should be able to fly longer as long as you keep collecting
    rings. It’s hard to tell how much fuel you have left, though, so you should add
    a UI overlay that displays the fuel and the score.
  prefs: []
  type: TYPE_NORMAL
- en: UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new scene with a `CanvasLayer` layer called “UI”. Add two children:
    `TextureProgressBar` (`FuelBar`) and `Label` (`Score`).'
  prefs: []
  type: TYPE_NORMAL
- en: Set the text in the `Score` box `0` and add the font as you’ve done before,
    setting its `48`. Use the toolbar menu to set the layout to **Top Right**.
  prefs: []
  type: TYPE_NORMAL
- en: For `FuelBar`, you have two textures in the `assets` folder. You can use `bar_red.png`
    for the `bar_glass.png` for the `10` and `0.01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can position the bar in the bottom left, but if you want to resize it,
    you’ll need to change a few more settings. Check the box labeled `6`. You’ll see
    that now, no matter how you resize the bar, the borders remain unstretched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Nine patch stretch settings](img/B19289_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Nine patch stretch settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the bar a comfortable size and then add a script to `UI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an instance of the UI scene to `Main`. Connect the plane’s `score_changed`
    signal and the `fuel_changed` signal to the functions you just made on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Connecting the plane’s signal to the UI](img/B19289_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Connecting the plane’s signal to the UI'
  prefs: []
  type: TYPE_NORMAL
- en: Play the scene once again and verify that the bar shows the fuel changing and
    that the score updates correctly when rings are collected.
  prefs: []
  type: TYPE_NORMAL
- en: You are almost done! You have a mostly working game at this point. Take a moment
    to play it a few times to make sure you’re not missing any of the interactions.
    Are the chunks increasing in difficulty as you fly farther? You should see moving
    rings and then rings that spawn to the left and right of the center. Make sure
    to review the previous sections if there’s anything you are unclear about. When
    you’re ready, move on to making the title screen.
  prefs: []
  type: TYPE_NORMAL
- en: Title screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the title screen is to introduce the game and give a way to start
    it by pressing a button. This section will not go into much detail on the styling
    – you should experiment with the settings and try to make it look pleasing.
  prefs: []
  type: TYPE_NORMAL
- en: Start your `TitleScreen` scene with a `Control` node and add a `Label` and a
    `TextureButton` plus a `TextureRect` for the background.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `styled_sky.hdr` for the `TextureRect`’s **Texture** property. It’s
    a lot bigger than the screen size, so feel free to scale and/or position it as
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: For `TextureButton`, there are three images in the `res://assets/buttons/` folder
    for the **Normal**, **Pressed**, and **Hover** textures. The images are quite
    large to allow for sizing, so you can check **Ignore Texture Size** and set **Stretch
    Mode** to **Keep Aspect** to allow you to resize it.
  prefs: []
  type: TYPE_NORMAL
- en: The `Label` node is there to display the game’s title. Set up the font with
    large font size, such as `128`. Arrange `Label` and `TextureButton` on the screen.
    Set both of their layouts to **Center** and then move them up and down to position
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only code needed is to determine what to do when the button is pressed,
    so add a script to the scene and connect the button’s `pressed` signal. When the
    button is pressed, it should load the main scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To return to the title screen at the end of the game, remove `get_tree().reload_current_scene()`
    from the plane’s `die()` function, and then go to the `Main` scene and connect
    the plane instance’s `dead` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now when you crash, you should immediately return to the title screen, where
    you can press **Play** again.
  prefs: []
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two sound effect files located in the `assets` folder: `impact.wav`
    for the plane’s explosion and `three_tone.wav` for the ring collection sound.
    You can add `AudioStreamPlayer` nodes to the `Plane` and `Ring` scenes to play
    them at the appropriate time.'
  prefs: []
  type: TYPE_NORMAL
- en: For the background music, which should be played in a loop during the game,
    add `AudioStreamPlayer` to the `Main` scene, using `Riverside Ride Short Loop.wav`
    for **Stream**. Since it needs to play automatically at the start, you can check
    the **Autoplay** box.
  prefs: []
  type: TYPE_NORMAL
- en: The audio for this game is intentionally kept simple and upbeat. While there’s
    a sound effect for each major game event (flying through a ring, crashing), you
    could also try adding additional sounds for the airplane engine, bonuses, or a
    warning when fuel is low. Experiment to see what works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a high score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving the player’s high score is another common feature in many games (and
    one that you can add to the other games in this book as well). Since the score
    needs to be saved between sessions of the game, you’ll need to save it in an external
    file that the game can read the next time you open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the process:'
  prefs: []
  type: TYPE_NORMAL
- en: When the game launches, check for a save file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the save file exists, load the score from it, otherwise use `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a game ends, check if the score is higher than the current high score.
    If it is, save it to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the high score on the title screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since you’ll need to access the high score variable from different parts of
    your game, it makes sense to use an autoload. In the `global.gd`. To begin, you’ll
    need two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: About file locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll notice that the path for the save file doesn’t begin with `res://` like
    all of the other files you’ve been working with. The `res://` designation represents
    your game’s project folder – the place where all the scripts, scenes, and assets
    are located. When you export your game, though, that folder becomes read-only.
    To store persistent data, you use a location on the device that’s set aside for
    the game to write to: `user://`. Where this folder is actually located depends
    on the operating system you’re using. For example, in Windows, it would be `%APPDATA%\Godot\app_userdata\[project_name]`.
    You can find the paths for other supported operating systems here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html
  prefs: []
  type: TYPE_NORMAL
- en: Accessing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accessing files in Godot is done via the `FileAccess` object. This object handles
    opening, reading, and writing files. Add these functions to `global.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script calls `load_score()` in `_ready()`, so it’s done
    immediately when the game is launched. The `load_score()` function uses `FileAccess`
    to check if the save file exists, and if it does, it opens it and retrieves the
    data that was stored in it using `get_var()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `save_score()` function does the opposite. Note that you don’t have to check
    if the file exists – if you try to write to a file that doesn’t exist, it will
    be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this script and add it as an autoload in **Project Settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Adding a global script](img/B19289_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Adding a global script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your `Title` scene and add another `Label` node to display the high score.
    Set its font and arrange it on the screen – the bottom middle might be a good
    choice. Add this to the script, so that the score will be displayed whenever the
    title screen loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, at the end of the game, you’ll need to check if there’s a new high
    score. The `score` variable is kept on the plane, so open `plane.gd` and find
    the `die()` function, which is called when the game ends. Add a score check and
    call `save_score()` if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Run the game to test that the high score is being displayed, saved, and loaded
    again when you run the game the next time.
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be used for any type of data that you want to save between
    runs of your game. It’s a useful technique, so be sure to try it out with your
    own projects in the future. Reusing code is a great way to accelerate development,
    so once you’ve got a save system that you’re happy with, stick with it!
  prefs: []
  type: TYPE_NORMAL
- en: Suggestions for additional features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an additional challenge, try to expand the game by adding more features.
    Here are some suggestions to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: Track the distance the player flies in each game, and save the maximum value
    as a high score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the speed incrementally as time goes on or include boost items that
    increase the plane’s speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flying obstacles that need to be dodged, such as other planes or birds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Advanced) Instead of only straight lines, add curved chunks as well. The player
    will have to steer and the camera will have to move to stay behind them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This would also be a great game for you to experiment with building a game for
    a mobile platform. See the next chapter for information about exporting games.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you extended your 3D skills by learning about more of Godot’s
    3D nodes, such as the `CharacterBody3D`. You should have a good understanding
    of the 3D transform and how it works to move and rotate an object in space. Randomly
    generating chunks, while relatively simple in this game, is something that you
    can extend to much larger games and more complex environments.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you’ve made it to the end of the last project! But with these
    five games, your journey to becoming a game developer has just begun.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you can read about some other topics that didn’t quite
    fit into the example games, as well as find some pointers for where to go next
    in building your game development skills.
  prefs: []
  type: TYPE_NORMAL
