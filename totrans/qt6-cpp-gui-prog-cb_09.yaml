- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Touch Screen Application with Qt 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is not only a cross-platform software development kit for PC platforms; it
    also supports mobile platforms, such as iOS and Android. The developers of Qt
    introduced **Qt Quick** back in 2010, which provides an easy way to build custom
    user interfaces that are highly dynamic, where users can easily create fluid transitions
    and effects with only minimal coding.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick uses a declarative scripting language called **QML**, which is similar
    to the **JavaScript** language used in web development. Advanced users can also
    create custom functions in C++ and port them over to Qt Quick to enhance their
    functionality. At the moment, Qt Quick supports multiple platforms, such as Windows,
    Linux, macOS, iOS, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Qt for mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a basic user interface with QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information using model/view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating QML and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include Qt 6.6.1, Qt Creator 12.0.2,
    Android **Software Development Kit** (**SDK**), Android **Native Development Kit**
    (**NDK**), **Java Development Kit** (**JDK**), and Apache Ant. All the code used
    in this chapter can be downloaded from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter09](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Qt for mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to set up our Qt project in Qt Quick and
    enable it to be built and exported to mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started and learn how to create our first mobile application using
    Qt 6:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s create a new project by going to **File** | **New Project…**.
    Then, a window will pop up for you to choose a project template. Select **Qt Quick
    Application** and click the **Choose...** button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Create a Qt Quick application project](img/B20976_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Create a Qt Quick application project
  prefs: []
  type: TYPE_NORMAL
- en: After that, insert the project name and select the project location. Click the
    **Next** button, and it will ask you to select the minimum Qt version required
    for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please make sure that you select a version that exists on your computer. Otherwise,
    you won’t be able to run it properly.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done that, proceed by clicking the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, Qt Creator will ask you which kit you want to use for your project. These
    **kits** are basically different compilers that you can use to compile your project
    for different platforms. Since we’re making an application for a mobile platform,
    we will enable the Android kit (or the iOS kit if you’re running a Mac) to build
    and export your app to your mobile device, as shown in the following screenshot.
    You can also enable one of the desktop kits so you can test your program on the
    desktop beforehand. Do note that you need to configure the Android kit if you’re
    using it for the first time so that Qt can find the directory of the Android SDK.
    Click **Next** once you’re done with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Create an Android Kit for this project](img/B20976_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Create an Android Kit for this project
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project has been created, Qt Creator will automatically open up a
    file from your project called `Main.qml`. You will see a different type of script,
    as shown in the following code, that is very different from your usual C/C++ projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the project now by clicking on the green arrow button located
    at the bottom-left corner of your Qt Creator, as shown in *Figure 9**.3*. If you
    set the default kit to one of the desktop kits, an empty window will pop up once
    the project has been compiled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Press the triangle button to build and run](img/B20976_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Press the triangle button to build and run
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the next screenshot, We can switch between different kits by going
    to the Projects interface and selecting the kit you want your project to be built
    with. You can also manage all the kits available on your computer or add a new
    kit to your project from the **Projects** interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Change to any kits in the Projects interface](img/B20976_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Change to any kits in the Projects interface
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is your first time building and running your project, you need to create
    a template for the Android kit under the **Build** settings. Once you have clicked
    the **Create Templates** button under the **Build Android APK** tab, as shown
    in *Figure 9**.5*, Qt will generate all the files required to run your app on
    an Android device. If you don’t plan to use Gradle in your project, disable the
    **Copy the Gradle files to Android directory** option. Otherwise, you may encounter
    problems when trying to compile and deploy your app to your mobile device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Click the Create Templates button to create an Android template
    file](img/B20976_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Click the Create Templates button to create an Android template
    file
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click the `AndroidManifest.xml`, Gradle-related files, and other resources
    that are required by the Android platform. Let’s open up the `AndroidManifest.xml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Set your app’s settings in AndroidManifest.xml](img/B20976_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Set your app’s settings in AndroidManifest.xml
  prefs: []
  type: TYPE_NORMAL
- en: Once you have opened `AndroidManifest.xml`, you can set your app’s package name,
    version code, app icon, and permissions before exporting the app. To build and
    test your Android app, click on the **Run** button on Qt Creator. You should now
    see the following window pop up, asking which device it should export to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the device that is currently connected to your computer and press the
    **OK** button. Wait for a while for it to build the project, and you should be
    able to get a blank app running on your mobile device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Qt Quick application project is quite different from a widget application
    project. You will be writing QML script most of the time instead of writing C/C++
    code. **Android Software Development Kit** (**SDK**), **Android Native Development
    Kit** (**NDK**), **Java Development Kit** (**JDK**), and **Apache Ant** are required
    to build and export your app to the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can also use Gradle instead of Apache Ant for your Android
    kit. All you need to do is enable the **Use Gradle** instead of Ant option and
    provide Qt with Gradle’s installation path. Note that Android Studio is currently
    (at the time of authoring this book) not supported by Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Set up your Android settings in the Android tab in the Preferences
    window](img/B20976_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Set up your Android settings in the Android tab in the Preferences
    window
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running the app on an Android device, make sure that you have **USB
    debugging mode** enabled. To enable USB debugging mode, you need to first enable
    the developer options on your Android device by going to **Settings | About Phone**
    and tapping **Build Number** seven times. After that, go to **Settings | Developer
    Options**, and you will see the **USB debugging** option in the menu. Enable that
    option, and you can now export your app to your device for testing.
  prefs: []
  type: TYPE_NORMAL
- en: To build for the iOS platform, you need to run Qt Creator on a Mac and make
    sure the latest **Xcode** is installed on your Mac as well. To test your app on
    an iOS device, you need to register a developer account with Apple, register your
    device at the developer portal, and install the provisioning to your **Xcode**,
    which is a lot trickier than Android. You will be given access to the developer
    portal once you have obtained a developer account from Apple.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a basic user interface with QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example will teach us how to use Qt Design Studio to design our program’s
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a new **Qt Quick application** project, just like we did
    in the previous recipe. This time, however, make sure you check on the **Creates
    a project that you can open in Qt Design Studio** option as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Make sure your project can be opened by Qt Design Studio](img/B20976_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Make sure your project can be opened by Qt Design Studio
  prefs: []
  type: TYPE_NORMAL
- en: You will see a QML file in your project resources called `main.qml`. This is
    where we implement the logic for our application, but we will also need another
    QML file where we define our user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we proceed to design our program’s user interface, let’s download and
    install **Qt Design Studio** from Qt’s official website: [https://www.qt.io/product/ui-design-tools](https://www.qt.io/product/ui-design-tools).
    This is a new editor created by Qt for UI/UX designers to design user interfaces
    for their Qt Quick projects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have installed `.qmlproject` file in your project directory by pressing
    the **Open** **Project…** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Click the Open Project … button](img/B20976_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Click the Open Project … button
  prefs: []
  type: TYPE_NORMAL
- en: After that, a default QML UI file called `Sreen01.ui.qml` will be opened by
    **Qt Design Studio**. You will see an entirely different user interface editor
    compared to the one we used in previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since Qt 6, the Qt team released the **Qt Design Studio**, which is a new editor
    used specifically to design user interfaces for Qt Quick projects. The components
    of this editor are described as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Components**: The **Components** window displays all the predefined QML types
    that you can add to your user interface canvas. You can also create custom Qt
    Quick components from the Create Component button and display them here.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigator**: The **Navigator** window displays the items in the current QML
    file in a tree structure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connections**: You can use the tools provided in the **Connections** window
    to connect objects to signals, specify dynamic properties for objects, and create
    bindings between the properties of two objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**States**: The **States** window displays the different states of an item.
    You can add a new state for an item by clicking on the **+** button on the right
    of the **State** window.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2D/3D Canvas**: The canvas is where you design your program’s user interface.
    You can drag and drop a **Qt Quick** component from the **Components** window
    onto the canvas and instantly see what it will look like in the program. You can
    create a 2D or 3D canvas for different types of applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: This is where you change the properties of a selected item.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also select pre-defined workspaces for your **Qt Design Studio** editor
    by selecting from the drop-down box in the top-right corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Select a pre-defined workspace](img/B20976_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Select a pre-defined workspace
  prefs: []
  type: TYPE_NORMAL
- en: We’re about to make a simple login screen. First, delete the editing components
    from the 2D canvas. Then, from the **Components** window, drag two text widgets
    onto the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `Username:` and `Password:`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Set the Text property](img/B20976_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Set the Text property
  prefs: []
  type: TYPE_NORMAL
- en: Drag two rectangles from the `1` and the `5`. Then, set the echo mode of one
    of the text fields to **Password**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we’re going to manually create a button widget by combining a mouse area
    widget with a rectangle and a text widget. Drag a mouse area widget onto the canvas,
    then drag a rectangle and a text widget onto the canvas and parent them both to
    the mouse area. Set the color of the rectangle to `#bdbdbd`, then set its `1`
    and its `5`. Then, set the `Login` and make sure the size of the mouse area is
    the same as the rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, drag another rectangle onto the canvas to act as the container for
    the login form so that it will look neat. Set its `#5e5858` and its `2`. Then,
    set its `5` to make its corners look a little rounded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the rectangle that we added in the previous step is positioned at
    the top of the hierarchy in the **Navigator** window so that it appears behind
    all the other widgets. You can arrange the widget positions within the hierarchy
    by pressing the arrow buttons located at the top of the **Navigator** window as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Click the Move up button](img/B20976_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Click the Move up button
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will export three widgets: mouse area and the two text input widgets
    as the alias properties of the root item so that later on, we can access these
    widgets from the `App.qml` file. The widgets can be exported by clicking on the
    small icon behind the widget name and making sure the icon changes to the **On**
    status.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By now, your user interface should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – A simple login screen](img/B20976_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – A simple login screen
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s open up `App.qml`. Qt Creator will not open this file in `Screen01.ui.qml`,
    and `App.qml` is only used for defining the logic and functions that will be applied
    to the UI. You can, however, open it with Qt Design Studio to preview the user
    interface by clicking on the **Design** button located in the sidebar on the left
    of the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the script, add the third line to import the dialog module to
    `App.qml`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, replace the following code with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We continue to define `messageDialog` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run this program on your PC, and you should get a simple program
    that shows a message box when you click on the **Login** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – A message box showing after clicking on the Login button](img/B20976_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – A message box showing after clicking on the Login button
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Qt 5.4, a new file extension called `.ui.qml` has been introduced. The
    QML engine handles it like the normal `.qml` files but forbids any logic implementation
    from being written in it. It serves as the user interface definition template
    that can be reused in different `.qml` files. The separation of UI definition
    and logic implementation improves the maintainability of QML code and creates
    a better workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Since Qt 6, `.ui.qml` files have no longer been handled by Qt Creator. Instead,
    Qt provides you with another program called Qt Design Studio to edit your Qt Quick
    UI. They intend to give programmers and designers their separate tools that fit
    their workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the widgets under **Basic** are the most basic widgets that we can use
    to mix and match and create a new type of widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Drag and drop widgets from here](img/B20976_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Drag and drop widgets from here
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we learned how to put three widgets together—a text,
    a mouse area, and a rectangle—to form a button widget. You can also create your
    custom component by clicking the **Create Component** button at the top right
    corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – You can also create your custom component](img/B20976_09_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – You can also create your custom component
  prefs: []
  type: TYPE_NORMAL
- en: We imported the `QtQuick.Dialogs` module in `App.qml` and created a message
    box that displays the username and password filled in by the user when the `Screen01.ui.qml`,
    we will not be able to access their properties in `App.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can export the program to iOS and Android, but the user interface
    may not look accurate on some of the devices that have a higher resolution or
    a higher **density-per-pixel** (**DPI**) unit. We will cover this issue later
    on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to develop a touch-driven application that
    runs on mobile devices using Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following this step-by-step guide:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Qt Quick** **application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Qt Design Studio, click on the `tux.png` and add it to the project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Import tux.png into your project](img/B20976_09_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Import tux.png into your project
  prefs: []
  type: TYPE_NORMAL
- en: Next, open up `Screen01.ui.qml`. Drag an image widget from the `tux.png` and
    set its `200` and its `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that both the mouse area widget and the image widget are exported
    as the alias properties of the root item by clicking on the small icon beside
    their respective widget name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, switch over to the script editor by clicking on the **Edit** button
    on the sidebar located on the left side of the editor. We need to change the mouse
    area widget to a multi-point touch area widget, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also set the **Image** widget to be automatically placed at the center of
    the window by default, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final user interface should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Place the penguin in your application window](img/B20976_09_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Place the penguin in your application window
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’re done with that, let’s open up `App.qml`. First, clear everything
    within the `anchors.fill: parent`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, declare several variables within the **MainForm** object that will
    be used to rescale the image widget. If you want to know more about the property
    keyword used in the following code, check out the **There’s more…** section at
    the end of this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following code, we will define what will happen when our finger touches
    the multi-point area widget. In this case, we will save the positions of the first
    and second touch points if more than one finger touches the multi-point touch
    area. We also save the width and height of the image widget so that, later on,
    we can use these variables to calculate the scale of the image when the fingers
    start to move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following diagram shows the example of touch points being registered when
    two fingers are touching the screen within the `touchArea` boundary. The `touchArea.touchPoints[0]`
    is the first registered touch point, and `touchArea.touchPoints[1]` is the second.
    We then calculate the X and Y distance between the two touch points and save them
    as `prevDistX` and `prevDistY`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Calculate the distances between two touch points](img/B20976_09_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Calculate the distances between two touch points
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we will define what will happen when our fingers move while remaining
    in contact with the screen and still within the boundary of the touch area using
    the following code. At this point, we will calculate the scale of the image by
    using the variables we saved in the previous step. At the same time, if we detect
    that only a single touch is found, then we will move the image instead of altering
    its scale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following diagram shows the example of moving touch points; `touchArea.touchPoints[0]`
    moved from point A to point B, and `touchArea.touchPoints[1]` moved from point
    C to point D. We can then determine how many units have the touch points moved
    by looking at the differences between the previous X, and Y variables with the
    current ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Compare two sets of touch points to determine movement](img/B20976_09_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Compare two sets of touch points to determine movement
  prefs: []
  type: TYPE_NORMAL
- en: You can now build and export the program to your mobile device. You will not
    be able to test this program on a platform that does not support multi-touch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the program is running on the mobile device (or a desktop/laptop that
    supports multi-touch), try two things—put only one finger on the screen and move
    it around, and put two fingers on the screen and move them in opposite directions.
    What you should see is that the penguin will be moved to another place if you
    use only one finger, and it will be scaled up or down if you use two fingers,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Scaling up and down using your fingers](img/B20976_09_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Scaling up and down using your fingers
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a finger touches the screen of the device, the multi-point touch area widget
    triggers the `onPressed` event and registers the position of each of the touch
    points in an internal array. We can get these data by telling Qt which touch point
    we want to get access to. The first touch will bear the index number of 0, the
    second touch will be 1, and so on. We will then save these data into variables
    so that we can retrieve them later to calculate the scaling of the penguin image.
    Other than `onPressed`, you can also use `onReleased` if you want the event to
    be triggered when the user releases his/her finger from the touch area.
  prefs: []
  type: TYPE_NORMAL
- en: When one or more fingers remain in contact with the screen while moving, a multi-point
    touch area will trigger the `onUpdated` event. We will then check how many touches
    there are; if only one touch is found, we will just move the penguin image based
    on how much our finger has moved. If there is more than one touch, we will compare
    the distance between the two touches and compare this with the previous variables
    we have saved to determine how much we should rescale the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram shows tapping your finger on the screen will trigger the `onPressed`
    event, while swiping your finger on the screen will trigger the `onUpdated` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Difference between onPressed and onUpdated](img/B20976_09_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Difference between onPressed and onUpdated
  prefs: []
  type: TYPE_NORMAL
- en: We must also check whether the first touch is on the left side or if the second
    touch is on the right side. In this way, we can prevent the image from being scaled
    in the inverse direction of the finger movement and producing an inaccurate result.
    As for the movement of the penguin, we will just get the difference between the
    current touch position and the previous one and add that to the coordinate of
    the penguin; after this, it’s done. A single touch event is usually a lot more
    straightforward than a multi-touch event.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Qt Quick, all its components have built-in properties, such as `int`, `float`,
    and so on) keyword; here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also bind the custom `property` to a value by using a colon (`:`) before
    the value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the property types supported by Qt Quick, check out this
    link: [http://doc.qt.io/qt-6/qtqml-typesystem-basictypes.html](http://doc.qt.io/qt-6/qtqml-typesystem-basictypes.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Animation in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt allows us to easily animate a user interface component without writing a
    bunch of code. In this example, we will learn how to make our program’s user interface
    more interesting by applying animations to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s learn how to add animation to our Qt Quick application by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we will start everything from scratch. Therefore, create a new `Screen01.ui.qml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `Screen01.ui.qml` and go to the `QtQuick.Controls` to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you will see a new category appear in the **QML Types** tab called
    **QtQuick Controls**, which contains many new widgets that can be placed on the
    canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, drag three button widgets to the canvas and set their `45`. Then, go
    to the `0`. This will make the buttons resize horizontally according to the width
    of the main window. After that, set the y value of the first button to `0`, the
    second to `45`, and the third to `90`. The user interface should now look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Add three buttons to the layout](img/B20976_09_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Add three buttons to the layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open up the `fan.png` to the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Add fan.png to your project](img/B20976_09_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Add fan.png to your project
  prefs: []
  type: TYPE_NORMAL
- en: Then, add two mouse area widgets to the canvas. After that, drag a **Rectangle**
    widget and an **Image** widget onto the canvas. Parent the rectangle and image
    to the mouse areas we have just added before this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `#0000ff` and apply `fan.png` to the image widget. Your user interface
    should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Place a rectangle and the fan image in the layout](img/B20976_09_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Place a rectangle and the fan image in the layout
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, export all the widgets in your `Screen01.ui.qml` as alias properties
    of the root item by clicking on the icons located to the right of the widget name,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Adding aliases to the widgets](img/B20976_09_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Adding aliases to the widgets
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will apply animation and logic to the user interface, but we won’t
    be doing it in `Screen01.ui.qml`. Instead, we will do it all in `App.qml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `App.qml`, remove the default code for the mouse area and add in a **width**
    and **height** for the window so that we get more space to preview, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add the following code that defines the behavior of the buttons
    in the **Screen01** widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we continue to define `button3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, follow this with the behavior of the fan image and the mouse area widget
    it is attached to as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we then define `mouseArea1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last but not least, add the behavior of the rectangle and the mouse area widget
    it’s attached to as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we continue to add the `RED` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then finish the code by defining `mouseArea2` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you compile and run the program now, you should see three buttons at the
    top of the window and a moving rectangle at the bottom left, followed by a spinning
    fan at the bottom right, as demonstrated in the following screenshot. If you click
    any of the buttons, they will move slightly downward with a nice, smooth animation.
    If you click on the rectangle, it will change color from **blue** to **red**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Meanwhile, the fan image will pause its animation if you click on it while
    it’s animating, and it will resume the animation if you click on it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.27 – You can now control the animation and color of the widgets](img/B20976_09_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – You can now control the animation and color of the widgets
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the animation elements supported by the C++ version of Qt, such as transition,
    sequential animation, and parallel animation, are also available in Qt Quick.
    If you are familiar with the Qt animation framework in C++, you should be able
    to grasp this pretty easily.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added a spring animation element to all three buttons that
    specifically tracked their respective y-axes. If Qt detects that the y value has
    changed, the widget will not instantly pop to the new position; instead, it will
    be interpolated, move across the canvas, and perform a little shaking animation
    when reaching its destination that simulates the spring effect. We just have to
    write one line of code and leave the rest to Qt.
  prefs: []
  type: TYPE_NORMAL
- en: As for the fan image, we added a rotation animation element to it and set the
    duration to `1000 milliseconds`, which means it will complete a full rotation
    in one second. We also set it to loop its animation infinitely. When we clicked
    on the mouse area widget it’s attached to, we just called `pause()` or `resume()`
    to enable or disable the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the rectangle widget, we added two states to it, one called **BLUE**
    and one called **RED**, each of which carries a **color** property that will be
    applied to the rectangle upon state change. At the same time, we added **sequential
    animation group** to the mouse area widget that the rectangle is attached to and
    then added two **property animation** elements to the group. You can also mix
    different types of group animation; Qt can handle this very well.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying information using model/view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt includes a **model/view framework** that maintains separation between the
    way data are organized and managed and the way that they are presented to the
    user. In this section, we will learn how to make use of the model/view; in particular,
    by using the list view to display information and, at the same time, apply our
    own customization to make it look slick.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `home.png`, `map.png`, `profile.png`, `search.png`, `settings.png`,
    and `arrow.png` to the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Adding more images to the project](img/B20976_09_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – Adding more images to the project
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, create and open `Screen01.ui.qml`, as we did in all previous examples.
    Drag a **List View** widget from under the **Qt Quick – Views** category in the
    **Components** window and place it onto the canvas. Then, set its **Anchors**
    setting to fill the parent size by clicking on the button located in the middle
    of the **Layout** window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Set the layout anchor as a fill parent](img/B20976_09_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – Set the layout anchor as a fill parent
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, switch over to the script editor, as we will define what the list view
    will look like as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue to write the code by adding the following list view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue to add rows to the list view, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add a mouse area and an image, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, continue to add two text objects, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add an image object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following code, we will then define the list model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue to write the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add the final list element, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `App.qml` and replace the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program, and now your program should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.30 – Navigation menu with different fonts and icons](img/B20976_09_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.30 – Navigation menu with different fonts and icons
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Quick allows us to customize the look of each row of the list view with ease.
    The delegate defines what each row will look like, and the model is where you
    store the data that will be displayed on the list view.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added a background with a gradient on each row, and then
    we also added an icon on each side of the item, a title, a description, and a
    mouse area widget that makes each row of the list view clickable. The delegate
    is not static, as we allow the model to change the title, description, and icon
    to make each row look unique.
  prefs: []
  type: TYPE_NORMAL
- en: In `App.qml`, we defined the behavior of the mouse area widget that will halve
    its own opacity value when pressed and return to fully opaque when released. Since
    all other elements, such as title and icon, are all the children of the mouse
    area widget, all will also automatically follow their parent widget’s behavior
    and become semi-transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we have finally solved the display problem on mobile devices
    with high resolution and DPI. It’s a very simple trick; first, we defined a variable
    called `sizeMultiplier`. The value of `sizeMultiplier` is the result of dividing
    the width of the window by a predefined value, say 480, which is the current window
    width we used for the PC. Then, multiply `sizeMultiplier` by all the widget variables
    that are related to size and position, including font size. Do note that, in this
    case, you should use the `pixelSize` property for text instead of `pointSize`,
    so that you will get the correct display when multiplying by `sizeMultiplier`.
    The following screenshot shows you what the app looks like on the mobile device
    with and without `sizeMultiplier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.31 – Correcting size using size multiplier](img/B20976_09_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.31 – Correcting size using size multiplier
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you may get a messed-up user interface in the editor once you multiply
    everything by the `sizeMultiplier` variable. This is because the width variable
    may return as `0` in the editor. Hence, by multiplying 0 by 480, you may get the
    result `0`, which makes the entire user interface look funny. However, it will
    look fine when running the actual program. If you want to preview the user interface
    on the editor, temporarily set `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating QML and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt supports bridging between C++ classes with the QML engine. This combination
    allows developers to take advantage of both the simplicity of QML and the flexibility
    of C++. You can even integrate features that are not supported by Qt from external
    components, then pass the resulting data to Qt Quick to be displayed in the UI.
    In this example, we will learn how to export our user interface components from
    QML to the C++ framework and manipulate their properties before displaying them
    on screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we will start everything from scratch. Therefore, create a new `Screen01.ui.qml`
    with Qt Design Studio. Then, open up `Screen01.ui.qml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can keep the mouse area and text widget but place the text widget at the
    bottom of the window. Change the `Text` property of the text widget to `18`. After
    that, go to the `120`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.32 – Place it at the center of the layout](img/B20976_09_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.32 – Place it at the center of the layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, drag a rectangle widget from the `#ff0d0d`. Set its `200` and enable
    both the vertical and horizontal center anchor. After that, set the `-14`. Your
    UI should now look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Place the square and text as they are positioned in this image](img/B20976_09_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.33 – Place the square and text as they are positioned in this image
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done with that, right-click on your project directory in `myclass.h`
    and `myclass.cpp`—will now be created and added to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.34 – Create a new custom class](img/B20976_09_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.34 – Create a new custom class
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open up `myclass.h` and add a variable and function under the class constructor,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `myclass.cpp` and define the `setMyObject()` function,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now close `myclass.cpp` and open up `App.qml`. At the top of the file,
    import the `MyClassLib` components that we just created in C++:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Window {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'visible: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'width: 480'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: 320'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MyClass {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: myclass'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Screen01 {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'anchors.fill: parent'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mouseArea.onClicked: {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Qt.quit();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Component.onCompleted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: myclass.setMyObject(messageText);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, open up `main.cpp` and register the custom class to the QML engine.
    We will also change the properties of the text widget and the rectangle here using
    C++ code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, proceed to create the objects, just like the highlighted section in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, build and run the program, and you should see that the colors of the rectangle
    and the text are completely different from what you defined earlier in Qt Quick,
    as shown in the following screenshot. This is because their properties have been
    changed by the C++ code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.35 – Text and color can now be changed by C++](img/B20976_09_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.35 – Text and color can now be changed by C++
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QML is designed to be easily extendable through C++ code. The classes in the
    Qt QML module enable QML objects to be loaded and manipulated from C++.
  prefs: []
  type: TYPE_NORMAL
- en: Only classes that are inherited from the `QObject` base class can be integrated
    with QML, as it is part of the Qt ecosystem. Once the class has been registered
    with the QML engine, we get the root item from the QML engine and use it to find
    the objects we want to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, use the `setProperty()` function to change any of the properties
    belonging to the widget. Other than `setProperty()`, you may also use the `Q_PROPERTY()`
    macro in a class that inherits `QObject` to declare a property. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `Q_INVOKABLE` macro needs to be placed in front of the function
    that you intend to call in QML. Without it, Qt will not expose the function to
    Qt Quick, and you will not be able to call it.
  prefs: []
  type: TYPE_NORMAL
