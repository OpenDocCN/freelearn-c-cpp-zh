["```cpp\n    $ mkdir llvm_root_directory/lib/Target/TOY\n\n    ```", "```cpp\n    $ cd llvm_root_directory/lib/Target/TOY\n    $ vi TOYRegisterInfo.td\n\n    ```", "```cpp\n    class TOYReg<bits<16> Enc, string n> : Register<n> {\n      let HWEncoding = Enc;\n      let Namespace = \"TOY\";\n    }\n\n    foreach i = 0-3 in {\n        def R#i : R<i, \"r\"#i >;\n    }\n\n    def SP  : TOYReg<13, \"sp\">;\n    def LR  : TOYReg<14, \"lr\">;\n\n    def GRRegs : RegisterClass<\"TOY\", [i32], 32,\n      (add R0, R1, R2, R3, SP)>;\n    ```", "```cpp\n    $ vi TOYCallingConv.td\n\n    ```", "```cpp\n    def RetCC_TOY : CallingConv<[\n     CCIfType<[i32], CCAssignToReg<[R0]>>,\n     CCIfType<[i32], CCAssignToStack<4, 4>>\n    ]>;\n\n    ```", "```cpp\n    def CC_TOY : CallingConv<[\n     CCIfType<[i8, i16], CCPromoteToType<i32>>,\n     CCIfType<[i32], CCAssignToReg<[R0, R1]>>,\n     CCIfType<[i32], CCAssignToStack<4, 4>>\n    ]>;\n\n    ```", "```cpp\n    def CC_Save : CalleeSavedRegs<(add R2, R3)>;\n\n    ```", "```cpp\n    $ vi TOYInstrInfo.td\n\n    ```", "```cpp\n    def ADDrr : InstTOY<(outs GRRegs:$dst),\n                        (ins GRRegs:$src1, GRRegs:$src2),\n                         \"add $dst, $src1,z$src2\",\n    [(set i32:$dst, (add i32:$src1, i32:$src2))]>;\n    ```", "```cpp\nadd r0, r0, r1\n```", "```cpp\n    void TOYFrameLowering::emitPrologue(MachineFunction &MF) const {\n      const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();\n      MachineBasicBlock &MBB = MF.front();\n      MachineBasicBlock::iterator MBBI = MBB.begin();\n      DebugLoc dl = MBBI != MBB.end() ? MBBI->getDebugLoc() : DebugLoc();\n      uint64_t StackSize = computeStackSize(MF);\n      if (!StackSize) {\n        return;\n      }\n      unsigned StackReg = TOY::SP;\n      unsigned OffsetReg = materializeOffset(MF, MBB, MBBI, (unsigned)StackSize);\n      if (OffsetReg) {\n        BuildMI(MBB, MBBI, dl, TII.get(TOY::SUBrr), StackReg)\n            .addReg(StackReg)\n            .addReg(OffsetReg)\n            .setMIFlag(MachineInstr::FrameSetup);\n      } else {\n        BuildMI(MBB, MBBI, dl, TII.get(TOY::SUBri), StackReg)\n            .addReg(StackReg)\n            .addImm(StackSize)\n            .setMIFlag(MachineInstr::FrameSetup);\n      }\n    }\n    ```", "```cpp\n    void TOYFrameLowering::emitEpilogue(MachineFunction &MF,\n                                        MachineBasicBlock &MBB) const {\n\n      const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();\n    MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();\n      DebugLoc dl = MBBI->getDebugLoc();\n      uint64_t StackSize = computeStackSize(MF);\n      if (!StackSize) {\n        return;\n      }\n      unsigned StackReg = TOY::SP;\n      unsigned OffsetReg = materializeOffset(MF, MBB, MBBI, (unsigned)StackSize);\n      if (OffsetReg) {\n        BuildMI(MBB, MBBI, dl, TII.get(TOY::ADDrr), StackReg)\n            .addReg(StackReg)\n            .addReg(OffsetReg)\n            .setMIFlag(MachineInstr::FrameSetup);\n      } else {\n        BuildMI(MBB, MBBI, dl, TII.get(TOY::ADDri), StackReg)\n            .addReg(StackReg)\n            .addImm(StackSize)\n            .setMIFlag(MachineInstr::FrameSetup);\n      }\n    }\n    ```", "```cpp\n    static unsigned materializeOffset(MachineFunction &MF, MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI, unsigned Offset) {\n      const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();\n      DebugLoc dl = MBBI != MBB.end() ? MBBI->getDebugLoc() : DebugLoc();\n      const uint64_t MaxSubImm = 0xfff;\n      if (Offset <= MaxSubImm) {\n        return 0;\n      } else {\n        unsigned OffsetReg = TOY::R2;\n        unsigned OffsetLo = (unsigned)(Offset & 0xffff);\n        unsigned OffsetHi = (unsigned)((Offset & 0xffff0000) >> 16);\n        BuildMI(MBB, MBBI, dl, TII.get(TOY::MOVLOi16), OffsetReg)\n            .addImm(OffsetLo)\n            .setMIFlag(MachineInstr::FrameSetup);\n        if (OffsetHi) {\n          BuildMI(MBB, MBBI, dl, TII.get(TOY::MOVHIi16), OffsetReg)\n              .addReg(OffsetReg)\n              .addImm(OffsetHi)\n              .setMIFlag(MachineInstr::FrameSetup);\n        }\n        return OffsetReg;\n      }\n    }\n    ```", "```cpp\n    uint64_t TOYFrameLowering::computeStackSize(MachineFunction &MF) const {\n      MachineFrameInfo *MFI = MF.getFrameInfo();\n      uint64_t StackSize = MFI->getStackSize();\n      unsigned StackAlign = getStackAlignment();\n      if (StackAlign > 0) {\n        StackSize = RoundUpToAlignment(StackSize, StackAlign);\n      }\n      return StackSize;\n    }\n    ```", "```cpp\n%p = alloca i32, align 4\nstore i32 2, i32* %p\n%b = load i32* %p, align 4\n%c = add nsw i32 %a, %b\n```", "```cpp\nsub sp, sp, #4 ; prologue\nmovw r1, #2\nstr r1, [sp]\nadd r0, r0, #2\nadd sp, sp, #4 ; epilogue\n```", "```cpp\n    $ cd lib/Target/TOY\n    $ mkdir InstPrinter\n\n    ```", "```cpp\n    class InstTOY<dag outs, dag ins, string asmstr, list<dag> pattern>\n        : Instruction {\n      field bits<32> Inst;\n      let Namespace = \"TOY\";\n      dag OutOperandList = outs;\n      dag InOperandList = ins;\n      let AsmString   = asmstr;\n      let Pattern = pattern;\n      let Size = 4;\n    }\n    ```", "```cpp\n    void TOYInstPrinter::printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O) {\n      const MCOperand &Op = MI->getOperand(OpNo);\n      if (Op.isReg()) {\n        printRegName(O, Op.getReg());\n        return;\n      }\n\n      if (Op.isImm()) {\n        O << \"#\" << Op.getImm();\n        return;\n      }\n      assert(Op.isExpr() && \"unknown operand kind in printOperand\");\n      printExpr(Op.getExpr(), O);\n    }\n    ```", "```cpp\n    void TOYInstPrinter::printRegName(raw_ostream &OS, unsigned RegNo) const {\n      OS << StringRef(getRegisterName(RegNo)).lower();\n    }\n    ```", "```cpp\n    void TOYInstPrinter::printInst(const MCInst *MI, raw_ostream &O,StringRef Annot) {\n      printInstruction(MI, O);\n      printAnnotation(O, Annot);\n    }\n    ```", "```cpp\n    #ifndef TOYTARGETASMINFO_H\n    #define TOYTARGETASMINFO_H\n\n    #include \"llvm/MC/MCAsmInfoELF.h\"\n\n    namespace llvm {\n    class StringRef;\n    class Target;\n\n    class TOYMCAsmInfo : public MCAsmInfoELF {\n      virtual void anchor();\n\n    public:\n      explicit TOYMCAsmInfo(StringRef TT);\n    };\n\n    } // namespace llvm\n    #endif\n    ```", "```cpp\n    #include \"TOYMCAsmInfo.h\"\n    #include \"llvm/ADT/StringRef.h\"\n    using namespace llvm;\n\n    void TOYMCAsmInfo::anchor() {}\n\n    TOYMCAsmInfo::TOYMCAsmInfo(StringRef TT) {\n      SupportsDebugInformation = true;\n      Data16bitsDirective = \"\\t.short\\t\";\n      Data32bitsDirective = \"\\t.long\\t\";\n      Data64bitsDirective = 0;\n      ZeroDirective = \"\\t.space\\t\";\n      CommentString = \"#\";\n\n      AscizDirective = \".asciiz\";\n\n      HiddenVisibilityAttr = MCSA_Invalid;\n      HiddenDeclarationVisibilityAttr = MCSA_Invalid;\n      ProtectedVisibilityAttr = MCSA_Invalid;\n    }\n    ```", "```cpp\n    [component_0]\n    type = Library\n    name = TOYAsmPrinter\n    parent = TOY\n    required_libraries = MC Support\n    add_to_library_groups = TOY\n    ```", "```cpp\n    add_llvm_library(LLVMTOYAsmPrinter\n      TOYInstPrinter.cpp\n      )\n    ```", "```cpp\ntarget datalayout = \"e-m:e-p:32:32-i1:8:32-i8:8:32- i16:16:32-i64:32-f64:32-a:0:32-n32\"\ntarget triple = \"toy\"\ndefine i32 @foo(i32 %a, i32 %b) {\n   %c = add nsw i32 %a, %b\n   ret i32 %c\n}\n\n$ llc foo.ll\n.text\n.file \"foo.ll\"\n.globl foo\n.type foo,@function\nfoo:     # @foo\n# BB#0:   # %entry\nadd r0, r0, r1\nb lr\n.Ltmp0:\n.size foo, .Ltmp0-foo\n```", "```cpp\n    $ vi CMakeLists .txt\n    add_llvm_target(...\n    ...\n    TOYISelDAGToDAG.cpp\n    ...\n    )\n    ```", "```cpp\n    $ vi TOYTargetMachine.h\n    const TOYInstrInfo *getInstrInfo() const override {\n    return getSubtargetImpl()->getInstrInfo();\n    }\n    ```", "```cpp\n    class TOYPassConfig : public TargetPassConfig {\n    public:\n    ...\n    virtual bool addInstSelector();\n    };\n    ...\n    bool TOYPassConfig::addInstSelector() {\n    addPass(createTOYISelDag(getTOYTargetMachine()));\n    return false;\n    }\n    ```", "```cpp\n    $ vi TOYISelDAGToDAG.cpp\n\n    ```", "```cpp\n    #include \"TOY.h\"\n    #include \"TOYTargetMachine.h\"\n    #include \"llvm/CodeGen/SelectionDAGISel.h\"\n    #include \"llvm/Support/Compiler.h\"\n    #include \"llvm/Support/Debug.h\"\n    #include \"TOYInstrInfo.h\"\n\n    ```", "```cpp\n    class TOYDAGToDAGISel : public SelectionDAGISel {\n      const TOYSubtarget &Subtarget;\n\n    public:\n      explicit TOYDAGToDAGISel(TOYTargetMachine &TM, CodeGenOpt::Level OptLevel)\n    : SelectionDAGISel(TM, OptLevel),   Subtarget(*TM.getSubtargetImpl()) {}\n    };\n    ```", "```cpp\n    SDNode *Select(SDNode *N);\n\n    ```", "```cpp\n    SDNode *TOYDAGToDAGISel::Select(SDNode *N) {\n     return SelectCode(N);\n    }\n\n    ```", "```cpp\n        bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);\n    ```", "```cpp\n    bool TOYDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset) {\n      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {\n            Base = CurDAG->getTargetFrameIndex(FIN->getIndex(),\n                                           getTargetLowering()- >getPointerTy());\n            Offset = CurDAG->getTargetConstant(0, MVT::i32);\n            return true;\n        }\n      if (Addr.getOpcode() == ISD::TargetExternalSymbol ||\n            Addr.getOpcode() == ISD::TargetGlobalAddress ||\n            Addr.getOpcode() == ISD::TargetGlobalTLSAddress) {\n            return false; // direct calls.\n      }\n\n        Base = Addr;\n        Offset = CurDAG->getTargetConstant(0, MVT::i32);\n        return true;\n    }\n    ```", "```cpp\n    FunctionPass *llvm::createTOYISelDag(TOYTargetMachine &TM, CodeGenOpt::Level OptLevel) {\n    return new TOYDAGToDAGISel(TM, OptLevel);\n    }\n    ```", "```cpp\n    bits 0 to 3 -> src2, second register operand\n    bits 4 to 11 -> all zeros\n    bits 12 to 15 -> dst, for destination register\n    bits 16 to 19 -> src1, first register operand\n    bit 20 -> zero\n    bit 21 to 24 -> for opcode\n    bit 25 to 27 -> all zeros\n    bit 28 to 31 -> 1110\n    ```", "```cpp\n    class InstTOY<dag outs, dag ins, string asmstr, list<dag> pattern>\n          : Instruction {\n      field bits<32> Inst;\n\n      let Namespace = \"TOY\";\n        …\n       …\n        let AsmString   = asmstr;\n       …\n     …\n     }\n    ```", "```cpp\n    def ADDrr : InstTOY<(outs GRRegs:$dst),(ins GRRegs:$src1, GRRegs:$src2) ... > {\n    bits<4> src1;\n    bits<4> src2;\n    bits<4> dst;\n    let Inst{31-25} = 0b1100000;\n    let Inst{24-21} = 0b1100; // Opcode\n    let Inst{20} = 0b0;\n    let Inst{19-16} = src1; // Operand 1\n    let Inst{15-12} = dst; // Destination\n    let Inst{11-4} = 0b00000000;\n    let Inst{3-0} = src2;\n    }\n    ```", "```cpp\n    unsigned TOYMCCodeEmitter::getMachineOpValue(const MCInst &MI,\n                                                 const MCOperand &MO,\n                                                 SmallVectorImpl<MCFixup> &Fixups,\n                                                 const MCSubtargetInfo &STI) const {\n        if (MO.isReg()) {\n          return CTX.getRegisterInfo()- >getEncodingValue(MO.getReg());\n      }\n    ```", "```cpp\n    void TOYMCCodeEmitter::EncodeInstruction(const MCInst &MI, raw_ostream &OS, SmallVectorImpl<MCFixup> &Fixups, const MCSubtargetInfo &STI) const {\n          const MCInstrDesc &Desc = MCII.get(MI.getOpcode());\n          if (Desc.getSize() != 4) {\n            llvm_unreachable(\"Unexpected instruction size!\");\n      }\n\n          const uint32_t Binary = getBinaryCodeForInstr(MI, Fixups, STI);\n\n      EmitConstant(Binary, Desc.getSize(), OS);\n     ++MCNumEmitted;\n    }\n    ```", "```cpp\n    $ vi TOYSubtarget.h\n\n    ```", "```cpp\n    #include \"TOY.h\"\n    #include \"TOYFrameLowering.h\"\n    #include \"TOYISelLowering.h\"\n    #include \"TOYInstrInfo.h\"\n    #include \"TOYSelectionDAGInfo.h\"\n    #include \"TOYSubtarget.h\"\n    #include \"llvm/Target/TargetMachine.h\"\n    #include \"llvm/Target/TargetSubtargetInfo.h\"\n    #include \"TOYGenSubtargetInfo.inc\"\n\n    ```", "```cpp\n    class TOYSubtarget : public TOYGenSubtargetInfo {\n      virtual void anchor();\n\n    private:\n      const DataLayout DL;       // Calculates type size & alignment.\n      TOYInstrInfo InstrInfo;\n      TOYTargetLowering TLInfo;\n      TOYSelectionDAGInfo TSInfo;\n      TOYFrameLowering FrameLowering;\n      InstrItineraryData InstrItins;\n    ```", "```cpp\n    TOYSubtarget(const std::string &TT, const std::string &CPU, const std::string &FS, TOYTargetMachine &TM);\n    ```", "```cpp\n    const InstrItineraryData *getInstrItineraryData() const override {\n      return &InstrItins;\n    }\n\n    const TOYInstrInfo *getInstrInfo() const override { return &InstrInfo; }\n\n    const TOYRegisterInfo *getRegisterInfo() const override {\n      return &InstrInfo.getRegisterInfo();\n    }\n\n    const TOYTargetLowering *getTargetLowering() const override {\n      return &TLInfo;\n    }\n\n    const TOYFrameLowering *getFrameLowering() const override {\n      return &FrameLowering;\n    }\n\n    const TOYSelectionDAGInfo *getSelectionDAGInfo() const override {\n      return &TSInfo;\n    }\n\n    const DataLayout *getDataLayout() const override { return &DL; }\n\n    void ParseSubtargetFeatures(StringRef CPU, StringRef FS);\n\n    TO LC,\n\n    Please maintain the representation of the above code EXACTLY as seen above.\n    ```", "```cpp\n    TOYSubtarget::TOYSubtarget(const std::string &TT, const std::string &CPU, const std::string &FS, TOYTargetMachine &TM)\n          DL(\"e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32- f64:32-a:0:32-n32\"),\n          InstrInfo(), TLInfo(TM), TSInfo(DL), FrameLowering() {}\n    ```", "```cpp\n    def MOVLOi16 : MOV<0b1000, \"movw\", (ins i32imm:$imm),\n                      [(set i32:$dst, i32imm_lo:$imm)]>;\n    def MOVHIi16 : MOV<0b1010, \"movt\", (ins GRRegs:$src1, i32imm:$imm),\n                      [/* No Pattern */]>;\n    ```", "```cpp\n    def MOVi32 : InstTOY<(outs GRRegs:$dst), (ins i32imm:$src), \"\", [(set i32:$dst, (movei32 imm:$src))]> {\n      let isPseudo = 1;\n    }\n    ```", "```cpp\n    bool TOYInstrInfo::expandPostRAPseudo(MachineBasicBlock::iterato r MI) const {\n      if (MI->getOpcode() == TOY::MOVi32){\n        DebugLoc DL = MI->getDebugLoc();\n        MachineBasicBlock &MBB = *MI->getParent();\n\n        const unsigned DstReg = MI->getOperand(0).getReg();\n        const bool DstIsDead = MI->getOperand(0).isDead();\n\n        const MachineOperand &MO = MI->getOperand(1);\n\n        auto LO16 = BuildMI(MBB, MI, DL, get(TOY::MOVLOi16), DstReg);\n        auto HI16 = BuildMI(MBB, MI, DL, get(TOY::MOVHIi16))\n                        .addReg(DstReg, RegState::Define | getDeadRegState(DstIsDead))\n                        .addReg(DstReg);\n\n      MBB.erase(MI);\n        return true;\n      }\n    }\n    ```", "```cpp\n    define i32 @foo(i32 %a) #0 {\n    %b = add nsw i32 %a, 65537 ; 0x00010001\n    ret i32 %b\n    }\n    ```", "```cpp\n    movw r1, #1\n    movt r1, #1\n    add r0, r0, r1\n    b lr\n    ```", "```cpp\n    set(LLVM_ALL_TARGETS\n      AArch64\n      ARM\n      …\n      …\n      TOY\n      )\n    ```", "```cpp\n    class Triple {\n    public:\n      enum ArchType {\n        UnknownArch,\n\n        arm,        // ARM (little endian): arm, armv.*, xscale\n        armeb,      // ARM (big endian): armeb\n        aarch64,    // AArch64 (little endian): aarch64\n        …\n       …\n\n    toy     // TOY: toy\n    };\n    ```", "```cpp\n    class MCSymbolRefExpr : public MCExpr {\n    public:\n    enum VariantKind {\n    ...\n    VK_TOY_LO,\n    VK_TOY_HI,\n    };\n    ```", "```cpp\n    enum {\n      EM_NONE          = 0, // No machine\n      EM_M32           = 1, // AT&T WE 32100\n      …\n      …\n      EM_TOY           = 220 // whatever is the next number\n    };\n    ```", "```cpp\n    StringRef MCSymbolRefExpr::getVariantKindName(VariantKind Kind) {\n    switch (Kind) {\n\n      …\n      …\n      case VK_TOY_LO: return \"TOY_LO\";\n      case VK_TOY_HI: return \"TOY_HI\";\n      }\n    …\n    }\n    ```", "```cpp\n    const char *Triple::getArchTypeName(ArchType Kind) {\n      switch (Kind) {\n     …\n     …\n     case toy:         return \"toy\";\n\n    }\n\n    const char *Triple::getArchTypePrefix(ArchType Kind) {\n      switch (Kind) {\n     …\n     …\n    case toy:         return \"toy\";\n      }\n    }\n\n    Triple::ArchType Triple::getArchTypeForLLVMName(StringRef Name) {\n    …\n    …\n        .Case(\"toy\", toy)\n    …\n    }\n\n    static Triple::ArchType parseArch(StringRef ArchName) {\n    …\n    …\n        .Case(\"toy\", Triple::toy)\n    …\n    }\n\n    static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {\n    …\n    …\n    case llvm::Triple::toy:\n        return 32;\n\n    …\n    …\n    }\n\n    Triple Triple::get32BitArchVariant() const {\n    …\n    …\n    case Triple::toy:\n        // Already 32-bit.\n        break;\n    …\n    }\n\n    Triple Triple::get64BitArchVariant() const {\n    …\n    …\n    case Triple::toy:\n        T.setArch(UnknownArch);\n        break;\n\n    …\n    …\n    }\n    ```", "```cpp\n    [common]\n    subdirectories = ARM AArch64 CppBackend Hexagon MSP430 … … TOY\n    ```", "```cpp\n    #ifndef TARGET_TOY_H\n    #define TARGET_TOY_H\n\n    #include \"MCTargetDesc/TOYMCTargetDesc.h\"\n    #include \"llvm/Target/TargetMachine.h\"\n\n    namespace llvm {\n    class TargetMachine;\n    class TOYTargetMachine;\n\n    FunctionPass *createTOYISelDag(TOYTargetMachine &TM,\n                                   CodeGenOpt::Level OptLevel);\n    } // end namespace llvm;\n\n    #endif\n    ```", "```cpp\n    #include \"TOY.h\"\n    #include \"llvm/IR/Module.h\"\n    #include \"llvm/Support/TargetRegistry.h\"\n    using namespace llvm;\n\n    Target llvm::TheTOYTarget;\n\n    extern \"C\" void LLVMInitializeTOYTargetInfo() {\n      RegisterTarget<Triple::toy> X(TheTOYTarget, \"toy\", \"TOY\");\n    }\n    ```", "```cpp\n    add_llvm_library(LLVMTOYInfo\n      TOYTargetInfo.cpp\n      )\n    ```", "```cpp\n    [component_0]\n    type = Library\n    name = TOYInfo\n    parent = TOY\n    required_libraries = Support\n    add_to_library_groups = TOY\n    ```", "```cpp\n    #include \"TOYTargetMachine.h\"\n    #include \"TOY.h\"\n    #include \"TOYFrameLowering.h\"\n    #include \"TOYInstrInfo.h\"\n    #include TOYISelLowering.h\"\n    #include \"TOYSelectionDAGInfo.h\"\n    #include \"llvm/CodeGen/Passes.h\"\n    #include \"llvm/IR/Module.h\"\n    #include \"llvm/PassManager.h\"\n    #include \"llvm/Support/TargetRegistry.h\"\n    using namespace llvm;\n\n    TOYTargetMachine::TOYTargetMachine(const Target &T, StringRef TT, StringRef CPU, StringRef FS, const TargetOptions &Options,\n    Reloc::Model RM, CodeModel::Model CM,\n                                       CodeGenOpt::Level OL)\n        : LLVMTargetMachine(T, TT, CPU, FS, Options, RM, CM, OL),\n          Subtarget(TT, CPU, FS, *this) {\n      initAsmInfo();\n    }\n\n    namespace {\n    class TOYPassConfig : public TargetPassConfig {\n    public:\n      TOYPassConfig(TOYTargetMachine *TM, PassManagerBase &PM)\n          : TargetPassConfig(TM, PM) {}\n\n      TOYTargetMachine &getTOYTargetMachine() const {\n        return getTM<TOYTargetMachine>();\n      }\n\n      virtual bool addPreISel();\n      virtual bool addInstSelector();\n      virtual bool addPreEmitPass();\n    };\n    } // namespace\n\n    TargetPassConfig *TOYTargetMachine::createPassConfig(PassManagerBase &PM) {\n      return new TOYPassConfig(this, PM);\n    }\n\n    bool TOYPassConfig::addPreISel() { return false; }\n\n    bool TOYPassConfig::addInstSelector() {\n      addPass(createTOYISelDag(getTOYTargetMachine(), getOptLevel()));\n      return false;\n    }\n\n    bool TOYPassConfig::addPreEmitPass() { return false; }\n\n    // Force static initialization.\n    extern \"C\" void LLVMInitializeTOYTarget() {\n      RegisterTargetMachine<TOYTargetMachine> X(TheTOYTarget);\n    }\n\n    void TOYTargetMachine::addAnalysisPasses(PassManagerBase &PM) {}\n    ```", "```cpp\n    #ifndef TOYMCTARGETDESC_H\n    #define TOYMCTARGETDESC_H\n\n    #include \"llvm/Support/DataTypes.h\"\n\n    namespace llvm {\n    class Target;\n    class MCInstrInfo;\n    class MCRegisterInfo;\n    class MCSubtargetInfo;\n    class MCContext;\n    class MCCodeEmitter;\n    class MCAsmInfo;\n    class MCCodeGenInfo;\n    class MCInstPrinter;\n    class MCObjectWriter;\n    class MCAsmBackend;\n\n    class StringRef;\n    class raw_ostream;\n\n    extern Target TheTOYTarget;\n\n    MCCodeEmitter *createTOYMCCodeEmitter(const MCInstrInfo &MCII, const MCRegisterInfo &MRI, const MCSubtargetInfo &STI, MCContext &Ctx);\n\n    MCAsmBackend *createTOYAsmBackend(const Target &T, const MCRegisterInfo &MRI, StringRef TT, StringRef   CPU);\n\n    MCObjectWriter *createTOYELFObjectWriter(raw_ostream &OS, uint8_t OSABI);\n\n    } // End llvm namespace\n\n    #define GET_REGINFO_ENUM\n    #include \"TOYGenRegisterInfo.inc\"\n\n    #define GET_INSTRINFO_ENUM\n    #include \"TOYGenInstrInfo.inc\"\n\n    #define GET_SUBTARGETINFO_ENUM\n    #include \"TOYGenSubtargetInfo.inc\"\n\n    #endif\n    ```", "```cpp\n    #include \"TOYMCTargetDesc.h\"\n    #include \"InstPrinter/TOYInstPrinter.h\"\n    #include \"TOYMCAsmInfo.h\"\n    #include \"llvm/MC/MCCodeGenInfo.h\"\n    #include \"llvm/MC/MCInstrInfo.h\"\n    #include \"llvm/MC/MCRegisterInfo.h\"\n    #include \"llvm/MC/MCSubtargetInfo.h\"\n    #include \"llvm/MC/MCStreamer.h\"\n    #include \"llvm/Support/ErrorHandling.h\"\n    #include \"llvm/Support/FormattedStream.h\"\n    #include \"llvm/Support/TargetRegistry.h\"\n\n    #define GET_INSTRINFO_MC_DESC\n    #include \"TOYGenInstrInfo.inc\"\n\n    #define GET_SUBTARGETINFO_MC_DESC\n    #include \"TOYGenSubtargetInfo.inc\"\n\n    #define GET_REGINFO_MC_DESC\n    #include \"TOYGenRegisterInfo.inc\"\n\n    using namespace llvm;\n\n    static MCInstrInfo *createTOYMCInstrInfo() {\n      MCInstrInfo *X = new MCInstrInfo();\n      InitTOYMCInstrInfo(X);\n      return X;\n    }\n\n    static MCRegisterInfo *createTOYMCRegisterInfo(StringRef TT) {\n      MCRegisterInfo *X = new MCRegisterInfo();\n      InitTOYMCRegisterInfo(X, TOY::LR);\n      return X;\n    }\n\n    static MCSubtargetInfo *createTOYMCSubtargetInfo(StringRef TT, StringRef CPU,\n                                                     StringRef FS) {\n      MCSubtargetInfo *X = new MCSubtargetInfo();\n      InitTOYMCSubtargetInfo(X, TT, CPU, FS);\n      return X;\n    }\n\n    static MCAsmInfo *createTOYMCAsmInfo(const MCRegisterInfo &MRI, StringRef TT) {\n      MCAsmInfo *MAI = new TOYMCAsmInfo(TT);\n      return MAI;\n    }\n\n    static MCCodeGenInfo *createTOYMCCodeGenInfo(StringRef TT, Reloc::Model RM,\n                                                 CodeModel::Model CM,\n                                                 CodeGenOpt::Level OL) {\n      MCCodeGenInfo *X = new MCCodeGenInfo();\n      if (RM == Reloc::Default) {\n        RM = Reloc::Static;\n      }\n      if (CM == CodeModel::Default) {\n        CM = CodeModel::Small;\n      }\n      if (CM != CodeModel::Small && CM != CodeModel::Large) {\n        report_fatal_error(\"Target only supports CodeModel Small or Large\");\n      }\n\n      X->InitMCCodeGenInfo(RM, CM, OL);\n      return X;\n    }\n\n    static MCInstPrinter *\n    createTOYMCInstPrinter(const Target &T, unsigned SyntaxVariant,\n                           const MCAsmInfo &MAI, const MCInstrInfo &MII,\n                           const MCRegisterInfo &MRI, const MCSubtargetInfo &STI) {\n      return new TOYInstPrinter(MAI, MII, MRI);\n    }\n\n    static MCStreamer *\n    createMCAsmStreamer(MCContext &Ctx, formatted_raw_ostream &OS, bool isVerboseAsm, bool useDwarfDirectory,MCInstPrinter *InstPrint, MCCodeEmitter *CE,MCAsmBackend *TAB, bool ShowInst) {\n      return createAsmStreamer(Ctx, OS, isVerboseAsm,   useDwarfDirectory, InstPrint,  CE,   TAB, ShowInst);\n    }\n\n    static MCStreamer *createMCStreamer(const Target &T, StringRef TT,\n                                        MCContext &Ctx, MCAsmBackend &MAB,\n                                        raw_ostream &OS,\n                                        MCCodeEmitter *Emitter,\n                                        const MCSubtargetInfo &STI,\n                                        bool RelaxAll,\n                                        bool NoExecStack) {\n      return createELFStreamer(Ctx, MAB, OS, Emitter, false, NoExecStack);\n    }\n\n    // Force static initialization.\n    extern \"C\" void LLVMInitializeTOYTargetMC() {\n      // Register the MC asm info.\n      RegisterMCAsmInfoFn X(TheTOYTarget, createTOYMCAsmInfo);\n\n      // Register the MC codegen info.\n      TargetRegistry::RegisterMCCodeGenInfo(TheTOYTarget, createTOYMCCodeGenInfo);\n\n      // Register the MC instruction info.\n      TargetRegistry::RegisterMCInstrInfo(TheTOYTarget, createTOYMCInstrInfo);\n\n      // Register the MC register info.\n      TargetRegistry::RegisterMCRegInfo(TheTOYTarget, createTOYMCRegisterInfo);\n\n      // Register the MC subtarget info.\n      TargetRegistry::RegisterMCSubtargetInfo(TheTOYTarget,\n                                              createTOYMCSubtargetInfo);\n\n      // Register the MCInstPrinter\n      TargetRegistry::RegisterMCInstPrinter(TheTOYTarget, createTOYMCInstPrinter);\n\n      // Register the ASM Backend.   TargetRegistry::RegisterMCAsmBackend(TheTOYTarget, createTOYAsmBackend);\n\n      // Register the assembly streamer.\n      TargetRegistry::RegisterAsmStreamer(TheTOYTarget, createMCAsmStreamer);\n\n      // Register the object streamer.\n      TargetRegistry::RegisterMCObjectStreamer(TheTOYTarget, createMCStreamer);\n\n      // Register the MCCodeEmitter\n      TargetRegistry::RegisterMCCodeEmitter(TheTOYTarget, createTOYMCCodeEmitter);\n    }\n    ```", "```cpp\n    [component_0]\n    type = Library\n    name = TOYDesc\n    parent = TOY\n    required_libraries = MC Support TOYAsmPrinter TOYInfo\n    add_to_library_groups = TOY\n    ```", "```cpp\n    add_llvm_library(LLVMTOYDesc\n      TOYMCTargetDesc.cpp)\n    ```", "```cpp\n$ cmake llvm_src_dir –DCMAKE_BUILD_TYPE=Release – DLLVM_TARGETS_TO_BUILD=\"TOY\"\n$ make\n\n```", "```cpp\n$ llc –version\n…\n…\nRegistered Targets :\ntoy – TOY\n\n```"]