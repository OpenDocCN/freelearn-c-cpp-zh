- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Fundamental Algorithms and Searching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本算法和搜索
- en: This chapter covers some of the most crucial and commonly used C++ **Standard
    Template Library** (**STL**) algorithms. The chapter equips readers with the knowledge
    and skills to manipulate and analyze data effectively by focusing on sorting,
    conditional checks, finding, and searching techniques. Understanding these fundamental
    algorithms is paramount for developers keen on ensuring efficient and robust applications.
    The chapter also emphasizes best practices, ensuring code is correct and optimized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了最关键和最常用的 C++ **标准模板库** (**STL**) 算法。本章通过关注排序、条件检查、查找和搜索技术，使读者能够有效地操作和分析数据。理解这些基本算法对于希望确保高效和健壮应用的开发者至关重要。本章还强调了最佳实践，确保代码正确且优化。
- en: 'This chapter covers the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Sorting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Checking conditions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查条件
- en: Counting and finding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数和查找
- en: Searching and comparison
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和比较
- en: Best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Sorting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: '**Sorting** is a fundamental concept every programmer encounters, yet it is
    not just about ordering elements. It’s about optimization, understanding the nature
    of your data, and selecting the right approach to arrange that data meaningfully.
    The vast toolkit of the C++ STL has a rich array of sorting algorithms tailored
    to various scenarios and datasets. But how do you choose? How do you effectively
    wield these tools for optimal results? Let’s embark on this enlightening journey
    together.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**排序** 是每个程序员都会遇到的基本概念，但它不仅仅是关于元素排序。它关乎优化，理解数据的本质，并选择合适的方法来有意义地排列这些数据。C++ STL
    的强大工具箱提供了一系列针对各种场景和数据集的排序算法。但如何选择？如何有效地运用这些工具以获得最佳结果？让我们共同踏上这段启发性的旅程。'
- en: To begin with, why do we sort? Sorting makes data aesthetically appealing and
    paves the way for efficient searching, data analysis, and optimized data structures.
    Whether it is sorting names in an address book or products by price in an online
    store, the act of sorting is deeply woven into the fabric of computing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么我们要排序？排序使数据看起来更美观，并为高效搜索、数据分析以及优化数据结构铺平了道路。无论是按姓名在地址簿中排序，还是在在线商店中按价格排序产品，排序这一行为深深地融入了计算的纹理中。
- en: 'The STL provides a primary sorting function: `std::sort`. This function is
    versatile and can sort almost any sequence of elements, from arrays to vectors.
    Under the hood, `std::sort` is typically implemented using an introsort, a hybrid
    sorting algorithm that combines quicksort, heapsort, and insertion sort, ensuring
    speed and adaptability. Here’s a simple example of `std::sort`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了一个主要的排序函数：`std::sort`。这个函数非常灵活，可以排序几乎任何元素序列，从数组到向量。在底层，`std::sort` 通常使用
    introsort 实现的，这是一种结合了快速排序、堆排序和插入排序的混合排序算法，确保了速度和适应性。以下是一个简单的 `std::sort` 示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But sorting isn’t always about ascending order or numbers. With `std::sort`,
    custom comparators allow you to define the order. Imagine you have a list of products
    and want to sort them by their names in descending order. You can do it in the
    following manner:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但排序并不总是关于升序或数字。使用 `std::sort`，自定义比较器允许你定义顺序。想象一下，你有一个产品列表，并想按名称降序排序。你可以这样做：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s not just about regular sorting. When you have almost sorted data, `std::partial_sort`
    comes to the rescue. This function sorts a range so that a particular subrange
    is sorted. Say you want to find the top three students by their score; `std::partial_sort`
    can make this task efficient.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅关于常规排序。当你有几乎排序好的数据时，`std::partial_sort` 就能提供帮助。这个函数对某个子范围进行排序。比如说，你想根据分数找到前三名的学生；`std::partial_sort`
    可以使这项任务更高效。
- en: However, knowing the algorithm is only half the battle; understanding when to
    use which function is critical. If you aim to sort a list of a million numbers,
    `std::sort` is your best friend. But if you’re dealing with a smaller dataset
    where you must maintain the original order of equal elements, `std::stable_sort`
    is a more suitable option.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解算法只是战斗的一半；理解何时使用哪个函数是至关重要的。如果你旨在对一个包含一百万个数字的列表进行排序，`std::sort` 将是你的最佳拍档。但如果你处理的是较小的数据集，其中你必须保持相等元素的原始顺序，那么
    `std::stable_sort` 是一个更合适的选择。
- en: There are also niche sorting functions tailored for specific scenarios. For
    instance, when dealing with large datasets where you’re interested in a subset
    of sorted data, `std::nth_element` is a fantastic tool. It rearranges elements
    such that the element at the nth position is the one that would be in that position
    in a sorted sequence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些针对特定场景量身定制的排序函数。例如，当处理大型数据集且你只对排序数据的子集感兴趣时，`std::nth_element` 是一个极好的工具。它重新排列元素，使得第
    n 个位置的元素在排序序列中也将位于该位置。
- en: Selecting the suitable algorithm also involves understanding the nature of your
    data. If you have a smaller dataset or a nearly sorted list, insertion sort might
    be your best bet. On the other hand, for larger datasets, more advanced algorithms
    such as mergesort or quicksort are more fitting. Knowing the underlying mechanics
    of these algorithms and their performance metrics helps make informed decisions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的算法还涉及到理解你的数据特性。如果你有一个较小的数据集或几乎排序好的列表，插入排序可能是你的最佳选择。另一方面，对于较大的数据集，更高级的算法如归并排序或快速排序可能更合适。了解这些算法的底层机制和性能指标有助于做出明智的决定。
- en: Sorting in the STL is not just about arranging data but choosing the optimal
    way. It’s a dance of understanding your data, the nature of your application,
    and the tools at your disposal. Next, we will learn how to check various conditions
    on our sorted data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: STL 中的排序不仅仅是安排数据，而是选择最佳方式。这是理解你的数据、应用性质以及你拥有的工具之间的舞蹈。接下来，我们将学习如何检查排序数据上的各种条件。
- en: Checking conditions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查条件
- en: The elegance of the C++ STL doesn’t just lie in its vast assortment of containers
    and algorithms. It also resides in its fine-tuned ability to let developers efficiently
    check and validate data using condition-based operations. With the might of predicate
    functions, these operations empower programmers to answer questions such as *Does
    this dataset hold a particular property?* and *Are all elements in this* *range
    positive?*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL 的优雅之处不仅在于其丰富的容器和算法集合，还在于其精细调校的能力，让开发者能够通过基于条件的操作高效地检查和验证数据。借助谓词函数的力量，这些操作使程序员能够回答诸如“这个数据集是否具有特定的属性？”和“这个范围内的所有元素都是正数吗？”等问题。
- en: One of the most intuitive and fundamental operations is `std::all_of`. With
    this algorithm, you can check if all elements in a range satisfy a given predicate.
    If you had a list of students’ grades, you could use `std::all_of` to see if all
    grades were positive (and they should be!).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观和基本操作之一是 `std::all_of`。使用这个算法，你可以检查一个范围内的所有元素是否满足给定的谓词。如果你有一个学生成绩列表，你可以使用
    `std::all_of` 来查看所有成绩是否都是正数（而且应该是！）。
- en: By contrast, its counterpart `std::none_of` checks if none of the elements in
    a range satisfy a given predicate. Let’s say you’re working with a list of student
    grades and want to ensure that no one has scored below passing marks. In this
    case, `std::none_of` becomes an invaluable asset.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，它的对应函数 `std::none_of` 检查一个范围内的所有元素是否都不满足给定的谓词。假设你正在处理一个学生成绩列表，并想确保没有人得分低于及格线。在这种情况下，`std::none_of`
    变得非常有价值。
- en: Rounding up the trio is `std::any_of`, which checks if at least one element
    in a sequence meets a specific condition. This becomes particularly handy in scenarios
    where you’re looking for the existence of a condition, such as finding if any
    grades are As (>= 90).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 三元组中的最后一个函数是 `std::any_of`，它检查序列中至少有一个元素满足特定条件。这在寻找条件存在性的场景中尤其有用，例如查找是否有任何成绩是
    A（>= 90）。
- en: 'Let’s look at a code example illustrating the usage of `std::all_of`, `std::none_of`,
    and `std::any_of`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例，说明 `std::all_of`、`std::none_of` 和 `std::any_of` 的用法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the example output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we’ve used a set of student grades as our dataset. We use the
    described algorithms to check if all grades are positive, if no student scored
    below passing marks (considered 80 in this case), and if there’s at least one
    student who achieved an *exceptional* grade (90 or above).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一组学生成绩作为我们的数据集。我们使用描述的算法来检查所有成绩是否为正数，没有学生得分低于及格分（在本例中认为是 80 分），以及至少有一名学生取得了*优异*的成绩（90
    分或以上）。
- en: Moving beyond these fundamental checks, there are more specialized algorithms
    such as `std::is_sorted`, which, as the name suggests, verifies if a range is
    sorted. For instance, with a dataset of product prices, this function quickly
    checks if the sequence is in ascending order, ensuring integrity before performing
    other operations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 超越这些基本检查，还有更多专门的算法，例如 `std::is_sorted`，正如其名所示，它验证一个范围是否已排序。例如，对于产品价格的数据集，这个函数可以快速检查序列是否按升序排列，确保在执行其他操作之前数据的完整性。
- en: Another intriguing algorithm is `std::is_partitioned`. Imagine you have a mixed
    data collection, and you’ve used some criteria to partition it, such as dividing
    numbers into even and odd. This algorithm checks if such a partitioning exists
    in a sequence based on a predicate.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的算法是 `std::is_partitioned`。想象一下，你有一个混合数据集，你已经使用某些标准对其进行了分区，例如将数字分为偶数和奇数。这个算法根据谓词检查序列中是否存在这种分区。
- en: While these functions offer direct ways to validate data, sometimes the need
    is more nuanced. Consider the situation where you want to compare two sequences
    to check if they’re permutations of each other. The STL offers `std::is_permutation`
    for this very purpose. Whether it is strings, numbers, or custom objects, this
    function can ascertain if one sequence is a reordering of another.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些函数提供了直接验证数据的方法，但有时需求更为复杂。考虑这种情况，你可能想要比较两个序列以检查它们是否是彼此的排列。STL 提供了 `std::is_permutation`
    来实现这一目的。无论是字符串、数字还是自定义对象，这个函数都可以确定一个序列是否是另一个序列的重新排序。
- en: 'Let’s use a dataset of product prices to demonstrate the use of `std::is_permutation`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个产品价格的数据集来演示 `std::is_permutation` 的用法：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the example output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we’ve used the described algorithms on a dataset of product
    prices. The prices are first checked to see if they’re sorted. Then, they’re partitioned
    based on a price criterion. Finally, we verify if two sequences of prices are
    permutations of each other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用描述的算法对一个产品价格的数据集进行了操作。首先检查价格是否已排序。然后，根据价格标准进行分区。最后，我们验证两个价格序列是否是彼此的排列。
- en: Utilizing these condition-checking functions isn’t just about invoking them
    on datasets. True power comes from crafting meaningful predicates. By harnessing
    the capabilities of lambdas or functor objects, you can design intricate conditions
    that precisely capture your requirements. Whether checking the validity of user
    inputs, validating data before processing, or ensuring the sanctity of results
    post-processing, predicate-based functions are your trusty tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些条件检查函数不仅仅是将它们应用于数据集。真正的力量来自于构建有意义的谓词。通过利用 lambda 或函数对象的能力，你可以设计复杂的条件，精确地捕捉你的需求。无论是检查用户输入的有效性，验证处理前的数据，还是确保处理后的结果的神圣不可侵犯，基于谓词的函数是你的可靠工具。
- en: But like any powerful toolkit, these functions must be used judiciously. Over-relying
    on checks can lead to performance overhead, especially on large datasets. Striking
    a balance between validation and performance is crucial. Often, understanding
    the nature of your data and the broader context of the application can guide you
    in efficiently using these algorithms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像任何强大的工具包一样，这些函数必须谨慎使用。过度依赖检查可能导致性能开销，尤其是在大型数据集上。在验证和性能之间取得平衡至关重要。通常，了解数据的性质和应用的更广泛背景可以指导你有效地使用这些算法。
- en: In wrapping up this exploration of condition-checking algorithms, it is evident
    that they form an essential part of the STL’s algorithmic suite. They provide
    a robust foundation upon which more advanced operations can be built. As we journey
    ahead, you’ll see how these foundational checks intertwine with other algorithms,
    such as counting and finding, painting a holistic picture of data processing in
    the captivating world of C++.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结对条件检查算法的探索时，很明显，它们是 STL 算法套件的重要组成部分。它们提供了一个强大的基础，可以在其上构建更高级的操作。随着我们继续前进，你会看到这些基础检查如何与其他算法，如计数和查找交织在一起，描绘出
    C++ 魅力世界中数据处理的全景。
- en: Counting and finding
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数和查找
- en: In the data we deal with daily, managing or validating the data and actively
    searching, locating, and quantifying specific elements or patterns within it often
    becomes essential. The STL equips developers with a treasure trove of precise
    algorithms for counting and finding.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们日常处理的数据中，管理或验证数据，以及积极搜索、定位和量化其中的特定元素或模式，往往变得至关重要。STL为开发者提供了一宝库精确的算法，用于计数和查找。
- en: 'Let’s start with the simple yet powerful `std::count` and its twin `std::count_if`.
    While `std::count` can swiftly tell you how many times a specific value appears
    in a range, `std::count_if` takes it up a notch, letting you count occurrences
    based on a predicate. Imagine you have a collection of student marks and wish
    to find out how many scored above 90\. With `std::count_if`, it’s a cakewalk,
    as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单而强大的`std::count`及其孪生兄弟`std::count_if`开始。虽然`std::count`可以迅速告诉你特定值在范围内出现的次数，但`std::count_if`更进一步，允许你根据谓词来计数。想象一下，你有一个学生分数的集合，并希望找出有多少人得分超过90。使用`std::count_if`，这就像走平地一样简单，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the example output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have utilized `std::count` to check the number of students who scored
    precisely 90 and then employed `std::count_if` to count the students scoring above
    90.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`std::count`来检查得分恰好为90的学生数量，然后使用了`std::count_if`来计数得分超过90的学生。
- en: Beyond just counting, sometimes the goal is to locate a specific element. This
    is where `std::find` and `std::find_if` come into play. In comparison, `std::find`
    looks for an exact match, and `std::find_if` searches based on a predicate. For
    those times when you’re eager to know the position of the first element that meets
    a condition, these functions are your go-to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计数之外，有时目标是要定位一个特定的元素。这就是`std::find`和`std::find_if`发挥作用的地方。相比之下，`std::find`寻找精确匹配，而`std::find_if`基于谓词进行搜索。在你渴望知道满足条件的第一个元素的位置时，这些函数是你的首选。
- en: Yet, life isn’t always about the first match. Occasionally, it is the last match
    that matters. In such scenarios, `std::find_end` proves invaluable. Especially
    useful in situations such as locating the last occurrence of a subsequence within
    a larger sequence, this function ensures you don’t miss out on the nuances in
    your data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，生活并不总是关于第一个匹配项。有时，最后一个匹配项才是重要的。在这种情况下，`std::find_end`证明是无价的。特别是在定位较大序列中子序列的最后一个出现的情况下，这个函数确保你不会错过数据中的细微差别。
- en: 'Let’s look at a code example using `std::list` containing a structure of student
    names and grades. We’ll then use `std::find_if` and `std::find_end` to locate
    students based on their grades, as demonstrated here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用`std::list`的代码示例，其中包含学生姓名和成绩的结构。然后，我们将使用`std::find_if`和`std::find_end`根据成绩定位学生，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the example output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we use `std::find_if` to find the first student who scored
    92\. Then, we use `std::find_end` to find the last student who scored 92\. The
    `std::find_end` function is a bit tricky in this case because it is meant for
    finding subsequences, but by providing it with a single-element list (which acts
    as our *subsequence*), we can still use it to find the last occurrence of a particular
    grade.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`std::find_if`来找到第一个得分92的学生。然后，我们使用`std::find_end`来找到最后一个得分92的学生。在这个情况下，`std::find_end`函数有点棘手，因为它旨在查找子序列，但通过提供一个单元素列表（作为我们的*子序列*），我们仍然可以使用它来找到特定成绩的最后一个出现。
- en: For those who work with sorted data, STL doesn’t disappoint. With `std::lower_bound`
    and `std::upper_bound`, you can efficiently find the beginning and end of a range
    of values equal to a given value in a sorted sequence. Furthermore, `std::binary_search`
    lets you quickly ascertain if an element exists in the sorted range. Remember,
    these functions capitalize on the sorted nature of the data, making them considerably
    faster than their generic counterparts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些处理排序数据的人来说，STL并不会让人失望。通过`std::lower_bound`和`std::upper_bound`，你可以在排序序列中高效地找到等于给定值的值的范围的开始和结束。此外，`std::binary_search`让你能够快速确定一个元素是否存在于排序范围内。记住，这些函数利用了数据的排序特性，使它们的速度比它们的通用版本快得多。
- en: 'Let’s define a `Student` structure and use a `std::set` of `Student` objects.
    We’ll modify the comparison operators to sort based on grades as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`Student`结构，并使用`Student`对象的`std::set`。我们将修改比较运算符，以便根据成绩进行排序，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the example output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, `Student` structures are sorted in `std::set` based on their
    grades. The names are then used in the output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Student`结构根据成绩在`std::set`中排序。然后，在输出中使用姓名。
- en: Speaking of speed, the adjacency algorithms – `std::adjacent_find` being a prime
    example – allow for the rapid location of consecutive duplicates in a sequence.
    Imagine a sensor sending data, and you wish to identify if there are back-to-back
    duplicate readings quickly. This function is your go-to solution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 说到速度，邻接算法——`std::adjacent_find` 是一个典型的例子——允许快速定位序列中的连续重复项。想象一下一个传感器正在发送数据，而你希望快速识别是否存在连续重复的读数。这个函数就是你的首选解决方案。
- en: 'Let’s look at an example of a `std::list` of structures where each entry has
    a sensor reading (a temperature) and the time it was taken:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 `std::list` 结构体的例子，其中每个条目都有一个传感器读数（温度）和读取时间：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, each `SensorData` structure contains a temperature and its
    recorded timestamp. We’re using `std::adjacent_find` with a custom comparator
    to check for back-to-back duplicate temperature readings. When we find such a
    reading, we display the time the reading was taken and the temperature value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个 `SensorData` 结构体包含一个温度及其记录的时间戳。我们使用 `std::adjacent_find` 和自定义比较器来检查连续重复的温度读数。当我们找到这样的读数时，我们会显示读取时间以及温度值。
- en: 'Here’s the example output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with all tools, understanding when and how to use these algorithms is pivotal.
    While it might be tempting to employ binary searches frequently due to their speed,
    they’re only applicable to sorted data. Otherwise, using them might lead to incorrect
    results. Similarly, while counting occurrences might seem straightforward, using
    the correct counting function, depending on whether you have a specific value
    or a condition, can significantly affect your program’s clarity and efficiency.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有工具一样，理解何时以及如何使用这些算法是至关重要的。虽然由于它们的速度，频繁地使用二分搜索可能很有吸引力，但它们仅适用于排序数据。否则，使用它们可能会导致错误的结果。同样，虽然计数出现次数可能看起来很简单，但根据你是否有特定值或条件，使用正确的计数函数可以显著影响你程序的清晰度和效率。
- en: Given all of the options for data handling in C++, counting and finding are
    foundational and complex. They pave the way for more advanced operations, and
    a mastery over them ensures you’re well on your way to becoming adept at handling
    even the most complex data scenarios. Given our sorted data, we can expand our
    toolset further by examining efficient searching and comparison with the STL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中处理数据时，计数和查找是基础且复杂的操作，为更高级的操作铺平了道路。对这些操作掌握得越好，你就越有可能熟练地处理最复杂的数据场景。鉴于我们的数据已排序，我们可以通过检查
    STL 中的高效搜索和比较来进一步扩展我们的工具集。
- en: Searching and comparison
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索和比较
- en: Searching through data is a common yet crucial operation that most software
    requires. Whether you’re trying to retrieve specific user details from a database
    or find a book’s position in a sorted list, a robust search technique is paramount.
    With its plethora of algorithms, the STL offers several methods to search through
    sequences efficiently. Moreover, the library provides intuitive ways to compare
    sequences and retrieve extreme values, making data analysis more streamlined.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索数据是一个常见但至关重要的操作，大多数软件都需要。无论是尝试从数据库中检索特定用户详情，还是找到一本书在排序列表中的位置，强大的搜索技术都是至关重要的。STL
    提供了多种方法来有效地搜索序列。此外，该库提供了直观的方式来比较序列和检索极值，使数据分析更加流畅。
- en: When working with sorted data, `std::binary_search` is a power player. It’s
    a testament to the importance of keeping data sorted wherever feasible. By repeatedly
    dividing the dataset in half, it locates the desired element, making it an exceptionally
    speedy tool. However, this is merely a boolean operation; it informs if the element
    exists, but not where it exists. For that, we lean on `std::lower_bound` and `std::upper_bound`.
    These functions retrieve iterators pointing to the first occurrence and just past
    the last occurrence of an element. Combining these two can give a range representing
    all instances of a value in a sorted sequence.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理排序数据时，`std::binary_search` 是一个强大的工具。这是保持数据排序在可行范围内的重要性的证明。通过反复将数据集分成两半，它定位所需的元素，使其成为一个异常快速的工具。然而，这仅仅是一个布尔操作；它通知元素是否存在，但并不告知其位置。为此，我们依赖
    `std::lower_bound` 和 `std::upper_bound`。这些函数检索指向元素首次出现和最后一次出现之后的迭代器。结合这两个函数可以给出表示排序序列中所有实例的值的范围。
- en: Yet, not all data is sorted, and not all searches are for exact matches. The
    STL doesn’t leave you in the lurch. Functions such as `std::find` and `std::find_if`
    shine in these situations, providing flexibility to search based on actual values
    or predicates.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有数据都是排序的，并非所有搜索都是精确匹配。STL不会让你陷入困境。`std::find`和`std::find_if`等函数在这些情况下表现出色，提供了基于实际值或谓词进行搜索的灵活性。
- en: After searching, a natural progression is comparing elements. Often, we need
    to determine if one sequence is lexicographically less than, greater than, or
    equal to another. This is where `std::lexicographical_compare` steps in, allowing
    you to compare two sequences like dictionary ordering. It’s a must-have when working
    with strings or custom data types, ensuring you can quickly sort and rank data
    as required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索之后，一个自然的步骤是比较元素。通常，我们需要确定一个序列在字典序上是否小于、大于或等于另一个序列。这就是`std::lexicographical_compare`发挥作用的地方，它允许你像字典排序一样比较两个序列。当处理字符串或自定义数据类型时，这是必不可少的，确保你可以快速地按需排序和排名数据。
- en: 'Here’s an example to demonstrate the use of `std::lexicographical_compare`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来展示`std::lexicographical_compare`的使用：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the example output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This demonstrates how `std::lexicographical_compare` can be used to determine
    the relative ordering of two sequences.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何使用`std::lexicographical_compare`来确定两个序列的相对顺序。
- en: 'But what if you’re only interested in the extremes? Perhaps you want to find
    the highest score in an exam or the lowest price in a list of products. Here,
    `std::max_element` and `std::min_element` are your stalwarts. They return iterators
    pointing to the maximum and minimum elements, respectively. If you’re looking
    for both, `std::minmax_element` does the trick, giving you a pair of iterators
    in one go:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只对极端值感兴趣呢？也许你想要找到考试中的最高分或产品列表中的最低价格。在这里，`std::max_element`和`std::min_element`是你的得力助手。它们分别返回指向最大和最小元素的迭代器。如果你两者都要找，`std::minmax_element`一次就能给出一个迭代器对：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the example output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This demonstrates using `std::max_element`, `std::min_element`, and `std::minmax_element`
    to find the extreme values in sequences.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何使用`std::max_element`、`std::min_element`和`std::minmax_element`在序列中找到极值。
- en: To wrap up, the power of searching and comparison in STL isn’t just in the breadth
    of its functions but in its adaptability. With iterators and predicates, these
    algorithms are remarkably versatile, ensuring you can adapt them to various scenarios.
    As developers, these tools become extensions of our thinking, guiding us toward
    efficient and elegant solutions. As we progress further, remember these operations
    form the foundation for more advanced techniques and best practices, fortifying
    our capabilities in data handling and algorithmic problem-solving in C++.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，STL中搜索和比较的力量不仅在于其函数的广度，还在于其适应性。有了迭代器和谓词，这些算法非常灵活，确保你可以根据各种场景调整它们。作为开发者，这些工具成为我们思考的延伸，引导我们走向高效且优雅的解决方案。随着我们进一步发展，请记住这些操作是更高级技术和最佳实践的基础，加强我们在C++中处理数据和算法解决问题的能力。
- en: Best practices
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'The elegance of the C++ STL lies in its vast array of utilities and its potential
    for optimization. However, merely knowing the algorithms isn’t the endgame. How
    you use them, combine them, and make subtle decisions can spell the difference
    between an efficient program and a sluggish one. So, let’s delve into the best
    practices, ensuring that your forays into STL are correct and performed at peak
    efficiency:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL的优雅之处在于其丰富的实用工具和优化潜力。然而，仅仅了解算法并不是最终目标。你如何使用它们，如何组合它们，以及如何做出细微的决策，这决定了程序是高效还是缓慢。因此，让我们深入研究最佳实践，确保你在STL中的探索是正确且效率最高的：
- en: '`std::binary_search` on a mostly sorted array may be counterproductive when
    `std::find` can serve the purpose with less overhead.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个基本排序的数组上使用`std::binary_search`可能是不切实际的，当`std::find`可以以更低的开销完成这项任务时。
- en: '`std::set` and `std::map`, have inherent advantages in searching and inserting
    elements. However, they can also lead to pitfalls. Continuously adding elements
    to such containers may not be efficient, and sometimes, batch insertions followed
    by a sort operation can be more optimal.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`和`std::map`在搜索和插入元素方面具有固有的优势。然而，它们也可能导致陷阱。持续向此类容器添加元素可能并不高效，有时，批量插入后跟排序操作可能更优。'
- en: '`std::vector`, using the `reserve` method, it is crucial to have a fair estimate
    of the size and reserve the memory upfront. This way, as you call `push_back`
    to add elements, the vector does not have to reallocate memory frequently, offering
    a significant performance boost.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::vector` 时，通过 `reserve` 方法，预先对大小进行合理的估计并保留内存至关重要。这样，当你调用 `push_back`
    添加元素时，向量不需要频繁地重新分配内存，从而提供显著的性能提升。
- en: '`std::count_if` and `std::find_if` allow custom conditions to be set, making
    them flexible and adaptable to a broader range of scenarios than their non-predicate
    counterparts. Moreover, lambdas in C++11 and beyond have made using these algorithms
    even more concise and expressive.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::count_if` 和 `std::find_if` 允许设置自定义条件，这使得它们比非谓词对应版本更加灵活和适应更广泛的场景。此外，C++11
    及以后的 lambda 表达式使得使用这些算法变得更加简洁和表达力丰富。'
- en: '**Be wary of algorithmic complexity**: While the STL provides tools, it does
    not change the fundamental nature of algorithms. A linear search will always be
    linear, and a binary search will be logarithmic. Recognize the complexity of your
    algorithm and question whether that’s the best for your application’s requirements.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警惕算法复杂度**：虽然 STL 提供了工具，但它并没有改变算法的基本性质。线性搜索始终是线性的，二分搜索将是对数的。认识到你算法的复杂度，并质疑这对你应用程序的需求是否最佳。'
- en: '`std::array`, which are stack-allocated, can be faster to access than their
    heap-allocated counterparts due to cache locality. However, this comes with the
    trade-off of fixed sizes. Hence, understanding the memory requirements beforehand
    can help strike the right balance.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array` 是栈分配的，由于缓存局部性，其访问速度可能比堆分配的对应版本更快。然而，这伴随着固定大小的权衡。因此，事先了解内存需求可以帮助找到正确的平衡点。'
- en: '`std::vector`, can invalidate iterators, leading to undefined behavior.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 可能会失效迭代器，导致未定义行为。'
- en: '**Benchmark and profile**: Assumptions and best practices are starting points,
    but real performance metrics come from profiling your application. Tools such
    as gprof, Valgrind, and Celero can be invaluable in highlighting bottlenecks and
    guiding you toward the right optimizations. These best practices outline how to
    optimize C++ STL usage, emphasizing the importance of understanding the nature
    of data, leveraging sorted data structures, avoiding unnecessary memory reallocations,
    preferring algorithms with predicate versions, being aware of algorithmic complexity,
    choosing stack over heap allocation when appropriate, using iterators judiciously,
    and the significance of benchmarking and profiling to identify performance bottlenecks.
    They underscore that while STL offers powerful utilities, efficient programming
    depends on how these tools are employed and combined.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试和性能分析**：假设和最佳实践是起点，但真实性能指标来自对应用程序的性能分析。gprof、Valgrind 和 Celero 等工具在突出瓶颈并指导你进行正确的优化方面可能非常有价值。这些最佳实践概述了如何优化
    C++ STL 的使用，强调了理解数据性质、利用排序数据结构、避免不必要的内存重新分配、优先选择具有谓词版本的算法、意识到算法复杂度、在适当的情况下选择栈分配而不是堆分配、谨慎使用迭代器以及基准测试和性能分析在识别性能瓶颈中的重要性。它们强调，虽然
    STL 提供了强大的工具，但高效的编程取决于如何使用和组合这些工具。'
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have thoroughly examined the core algorithms that operate
    on STL containers and their role in efficient C++ programming. We began by exploring
    the essentials of sorting algorithms and understanding how they organize data
    for better accessibility and performance. We then delved into various methods
    for checking container conditions and techniques for counting and finding elements,
    which are vital for data analysis and manipulation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们彻底研究了在 STL 容器上操作的核心算法及其在高效 C++ 编程中的作用。我们首先探讨了排序算法的基本原理，了解它们如何组织数据以实现更好的可访问性和性能。然后，我们深入探讨了检查容器条件的方法以及计数和查找元素的技术，这些对于数据分析和处理至关重要。
- en: This chapter has armed you with strategies for effectively searching and comparing
    elements. We also focused on best practices that ensure these operations are performed
    with optimal efficiency and minimal error.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了有效搜索和比较元素的战略。我们还关注了确保这些操作以最优效率和最小错误率执行的最佳实践。
- en: This knowledge has provided a foundation for implementing complex algorithms
    and performing data manipulations and everyday tasks in intermediate to advanced
    C++ development.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些知识为您在中级到高级 C++ 开发中实现复杂算法、执行数据操作和日常任务提供了基础。
- en: In the next chapter, we will extend our understanding of algorithms further.
    We will learn about copying and moving semantics within STL containers, **Return
    Value Optimization** (**RVO**), and techniques for filling, generating, removing,
    and replacing elements. Additionally, we will explore the nuances of swapping
    and reversing elements and conclude with deduplication and sampling strategies.
    These topics will contribute to a holistic understanding of data manipulation
    and transformation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步扩展我们对算法的理解。我们将学习在STL容器内进行复制和移动语义，**返回值优化**（**RVO**），以及填充、生成、删除和替换元素的技术。此外，我们还将探讨交换和反转元素细微差别，并以去重和抽样策略作为总结。这些主题将有助于全面理解数据操作和转换。
