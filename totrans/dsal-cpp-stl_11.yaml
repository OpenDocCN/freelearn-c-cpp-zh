- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamental Algorithms and Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers some of the most crucial and commonly used C++ **Standard
    Template Library** (**STL**) algorithms. The chapter equips readers with the knowledge
    and skills to manipulate and analyze data effectively by focusing on sorting,
    conditional checks, finding, and searching techniques. Understanding these fundamental
    algorithms is paramount for developers keen on ensuring efficient and robust applications.
    The chapter also emphasizes best practices, ensuring code is correct and optimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting and finding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sorting** is a fundamental concept every programmer encounters, yet it is
    not just about ordering elements. It’s about optimization, understanding the nature
    of your data, and selecting the right approach to arrange that data meaningfully.
    The vast toolkit of the C++ STL has a rich array of sorting algorithms tailored
    to various scenarios and datasets. But how do you choose? How do you effectively
    wield these tools for optimal results? Let’s embark on this enlightening journey
    together.'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, why do we sort? Sorting makes data aesthetically appealing and
    paves the way for efficient searching, data analysis, and optimized data structures.
    Whether it is sorting names in an address book or products by price in an online
    store, the act of sorting is deeply woven into the fabric of computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL provides a primary sorting function: `std::sort`. This function is
    versatile and can sort almost any sequence of elements, from arrays to vectors.
    Under the hood, `std::sort` is typically implemented using an introsort, a hybrid
    sorting algorithm that combines quicksort, heapsort, and insertion sort, ensuring
    speed and adaptability. Here’s a simple example of `std::sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But sorting isn’t always about ascending order or numbers. With `std::sort`,
    custom comparators allow you to define the order. Imagine you have a list of products
    and want to sort them by their names in descending order. You can do it in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It’s not just about regular sorting. When you have almost sorted data, `std::partial_sort`
    comes to the rescue. This function sorts a range so that a particular subrange
    is sorted. Say you want to find the top three students by their score; `std::partial_sort`
    can make this task efficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, knowing the algorithm is only half the battle; understanding when to
    use which function is critical. If you aim to sort a list of a million numbers,
    `std::sort` is your best friend. But if you’re dealing with a smaller dataset
    where you must maintain the original order of equal elements, `std::stable_sort`
    is a more suitable option.
  prefs: []
  type: TYPE_NORMAL
- en: There are also niche sorting functions tailored for specific scenarios. For
    instance, when dealing with large datasets where you’re interested in a subset
    of sorted data, `std::nth_element` is a fantastic tool. It rearranges elements
    such that the element at the nth position is the one that would be in that position
    in a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the suitable algorithm also involves understanding the nature of your
    data. If you have a smaller dataset or a nearly sorted list, insertion sort might
    be your best bet. On the other hand, for larger datasets, more advanced algorithms
    such as mergesort or quicksort are more fitting. Knowing the underlying mechanics
    of these algorithms and their performance metrics helps make informed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting in the STL is not just about arranging data but choosing the optimal
    way. It’s a dance of understanding your data, the nature of your application,
    and the tools at your disposal. Next, we will learn how to check various conditions
    on our sorted data.
  prefs: []
  type: TYPE_NORMAL
- en: Checking conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The elegance of the C++ STL doesn’t just lie in its vast assortment of containers
    and algorithms. It also resides in its fine-tuned ability to let developers efficiently
    check and validate data using condition-based operations. With the might of predicate
    functions, these operations empower programmers to answer questions such as *Does
    this dataset hold a particular property?* and *Are all elements in this* *range
    positive?*
  prefs: []
  type: TYPE_NORMAL
- en: One of the most intuitive and fundamental operations is `std::all_of`. With
    this algorithm, you can check if all elements in a range satisfy a given predicate.
    If you had a list of students’ grades, you could use `std::all_of` to see if all
    grades were positive (and they should be!).
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, its counterpart `std::none_of` checks if none of the elements in
    a range satisfy a given predicate. Let’s say you’re working with a list of student
    grades and want to ensure that no one has scored below passing marks. In this
    case, `std::none_of` becomes an invaluable asset.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding up the trio is `std::any_of`, which checks if at least one element
    in a sequence meets a specific condition. This becomes particularly handy in scenarios
    where you’re looking for the existence of a condition, such as finding if any
    grades are As (>= 90).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a code example illustrating the usage of `std::all_of`, `std::none_of`,
    and `std::any_of`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve used a set of student grades as our dataset. We use the
    described algorithms to check if all grades are positive, if no student scored
    below passing marks (considered 80 in this case), and if there’s at least one
    student who achieved an *exceptional* grade (90 or above).
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond these fundamental checks, there are more specialized algorithms
    such as `std::is_sorted`, which, as the name suggests, verifies if a range is
    sorted. For instance, with a dataset of product prices, this function quickly
    checks if the sequence is in ascending order, ensuring integrity before performing
    other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another intriguing algorithm is `std::is_partitioned`. Imagine you have a mixed
    data collection, and you’ve used some criteria to partition it, such as dividing
    numbers into even and odd. This algorithm checks if such a partitioning exists
    in a sequence based on a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: While these functions offer direct ways to validate data, sometimes the need
    is more nuanced. Consider the situation where you want to compare two sequences
    to check if they’re permutations of each other. The STL offers `std::is_permutation`
    for this very purpose. Whether it is strings, numbers, or custom objects, this
    function can ascertain if one sequence is a reordering of another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a dataset of product prices to demonstrate the use of `std::is_permutation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve used the described algorithms on a dataset of product
    prices. The prices are first checked to see if they’re sorted. Then, they’re partitioned
    based on a price criterion. Finally, we verify if two sequences of prices are
    permutations of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing these condition-checking functions isn’t just about invoking them
    on datasets. True power comes from crafting meaningful predicates. By harnessing
    the capabilities of lambdas or functor objects, you can design intricate conditions
    that precisely capture your requirements. Whether checking the validity of user
    inputs, validating data before processing, or ensuring the sanctity of results
    post-processing, predicate-based functions are your trusty tools.
  prefs: []
  type: TYPE_NORMAL
- en: But like any powerful toolkit, these functions must be used judiciously. Over-relying
    on checks can lead to performance overhead, especially on large datasets. Striking
    a balance between validation and performance is crucial. Often, understanding
    the nature of your data and the broader context of the application can guide you
    in efficiently using these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In wrapping up this exploration of condition-checking algorithms, it is evident
    that they form an essential part of the STL’s algorithmic suite. They provide
    a robust foundation upon which more advanced operations can be built. As we journey
    ahead, you’ll see how these foundational checks intertwine with other algorithms,
    such as counting and finding, painting a holistic picture of data processing in
    the captivating world of C++.
  prefs: []
  type: TYPE_NORMAL
- en: Counting and finding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the data we deal with daily, managing or validating the data and actively
    searching, locating, and quantifying specific elements or patterns within it often
    becomes essential. The STL equips developers with a treasure trove of precise
    algorithms for counting and finding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the simple yet powerful `std::count` and its twin `std::count_if`.
    While `std::count` can swiftly tell you how many times a specific value appears
    in a range, `std::count_if` takes it up a notch, letting you count occurrences
    based on a predicate. Imagine you have a collection of student marks and wish
    to find out how many scored above 90\. With `std::count_if`, it’s a cakewalk,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have utilized `std::count` to check the number of students who scored
    precisely 90 and then employed `std::count_if` to count the students scoring above
    90.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond just counting, sometimes the goal is to locate a specific element. This
    is where `std::find` and `std::find_if` come into play. In comparison, `std::find`
    looks for an exact match, and `std::find_if` searches based on a predicate. For
    those times when you’re eager to know the position of the first element that meets
    a condition, these functions are your go-to.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, life isn’t always about the first match. Occasionally, it is the last match
    that matters. In such scenarios, `std::find_end` proves invaluable. Especially
    useful in situations such as locating the last occurrence of a subsequence within
    a larger sequence, this function ensures you don’t miss out on the nuances in
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a code example using `std::list` containing a structure of student
    names and grades. We’ll then use `std::find_if` and `std::find_end` to locate
    students based on their grades, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `std::find_if` to find the first student who scored
    92\. Then, we use `std::find_end` to find the last student who scored 92\. The
    `std::find_end` function is a bit tricky in this case because it is meant for
    finding subsequences, but by providing it with a single-element list (which acts
    as our *subsequence*), we can still use it to find the last occurrence of a particular
    grade.
  prefs: []
  type: TYPE_NORMAL
- en: For those who work with sorted data, STL doesn’t disappoint. With `std::lower_bound`
    and `std::upper_bound`, you can efficiently find the beginning and end of a range
    of values equal to a given value in a sorted sequence. Furthermore, `std::binary_search`
    lets you quickly ascertain if an element exists in the sorted range. Remember,
    these functions capitalize on the sorted nature of the data, making them considerably
    faster than their generic counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a `Student` structure and use a `std::set` of `Student` objects.
    We’ll modify the comparison operators to sort based on grades as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Student` structures are sorted in `std::set` based on their
    grades. The names are then used in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of speed, the adjacency algorithms – `std::adjacent_find` being a prime
    example – allow for the rapid location of consecutive duplicates in a sequence.
    Imagine a sensor sending data, and you wish to identify if there are back-to-back
    duplicate readings quickly. This function is your go-to solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a `std::list` of structures where each entry has
    a sensor reading (a temperature) and the time it was taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each `SensorData` structure contains a temperature and its
    recorded timestamp. We’re using `std::adjacent_find` with a custom comparator
    to check for back-to-back duplicate temperature readings. When we find such a
    reading, we display the time the reading was taken and the temperature value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with all tools, understanding when and how to use these algorithms is pivotal.
    While it might be tempting to employ binary searches frequently due to their speed,
    they’re only applicable to sorted data. Otherwise, using them might lead to incorrect
    results. Similarly, while counting occurrences might seem straightforward, using
    the correct counting function, depending on whether you have a specific value
    or a condition, can significantly affect your program’s clarity and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Given all of the options for data handling in C++, counting and finding are
    foundational and complex. They pave the way for more advanced operations, and
    a mastery over them ensures you’re well on your way to becoming adept at handling
    even the most complex data scenarios. Given our sorted data, we can expand our
    toolset further by examining efficient searching and comparison with the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching through data is a common yet crucial operation that most software
    requires. Whether you’re trying to retrieve specific user details from a database
    or find a book’s position in a sorted list, a robust search technique is paramount.
    With its plethora of algorithms, the STL offers several methods to search through
    sequences efficiently. Moreover, the library provides intuitive ways to compare
    sequences and retrieve extreme values, making data analysis more streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: When working with sorted data, `std::binary_search` is a power player. It’s
    a testament to the importance of keeping data sorted wherever feasible. By repeatedly
    dividing the dataset in half, it locates the desired element, making it an exceptionally
    speedy tool. However, this is merely a boolean operation; it informs if the element
    exists, but not where it exists. For that, we lean on `std::lower_bound` and `std::upper_bound`.
    These functions retrieve iterators pointing to the first occurrence and just past
    the last occurrence of an element. Combining these two can give a range representing
    all instances of a value in a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, not all data is sorted, and not all searches are for exact matches. The
    STL doesn’t leave you in the lurch. Functions such as `std::find` and `std::find_if`
    shine in these situations, providing flexibility to search based on actual values
    or predicates.
  prefs: []
  type: TYPE_NORMAL
- en: After searching, a natural progression is comparing elements. Often, we need
    to determine if one sequence is lexicographically less than, greater than, or
    equal to another. This is where `std::lexicographical_compare` steps in, allowing
    you to compare two sequences like dictionary ordering. It’s a must-have when working
    with strings or custom data types, ensuring you can quickly sort and rank data
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example to demonstrate the use of `std::lexicographical_compare`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates how `std::lexicographical_compare` can be used to determine
    the relative ordering of two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you’re only interested in the extremes? Perhaps you want to find
    the highest score in an exam or the lowest price in a list of products. Here,
    `std::max_element` and `std::min_element` are your stalwarts. They return iterators
    pointing to the maximum and minimum elements, respectively. If you’re looking
    for both, `std::minmax_element` does the trick, giving you a pair of iterators
    in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates using `std::max_element`, `std::min_element`, and `std::minmax_element`
    to find the extreme values in sequences.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up, the power of searching and comparison in STL isn’t just in the breadth
    of its functions but in its adaptability. With iterators and predicates, these
    algorithms are remarkably versatile, ensuring you can adapt them to various scenarios.
    As developers, these tools become extensions of our thinking, guiding us toward
    efficient and elegant solutions. As we progress further, remember these operations
    form the foundation for more advanced techniques and best practices, fortifying
    our capabilities in data handling and algorithmic problem-solving in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The elegance of the C++ STL lies in its vast array of utilities and its potential
    for optimization. However, merely knowing the algorithms isn’t the endgame. How
    you use them, combine them, and make subtle decisions can spell the difference
    between an efficient program and a sluggish one. So, let’s delve into the best
    practices, ensuring that your forays into STL are correct and performed at peak
    efficiency:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::binary_search` on a mostly sorted array may be counterproductive when
    `std::find` can serve the purpose with less overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` and `std::map`, have inherent advantages in searching and inserting
    elements. However, they can also lead to pitfalls. Continuously adding elements
    to such containers may not be efficient, and sometimes, batch insertions followed
    by a sort operation can be more optimal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, using the `reserve` method, it is crucial to have a fair estimate
    of the size and reserve the memory upfront. This way, as you call `push_back`
    to add elements, the vector does not have to reallocate memory frequently, offering
    a significant performance boost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::count_if` and `std::find_if` allow custom conditions to be set, making
    them flexible and adaptable to a broader range of scenarios than their non-predicate
    counterparts. Moreover, lambdas in C++11 and beyond have made using these algorithms
    even more concise and expressive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be wary of algorithmic complexity**: While the STL provides tools, it does
    not change the fundamental nature of algorithms. A linear search will always be
    linear, and a binary search will be logarithmic. Recognize the complexity of your
    algorithm and question whether that’s the best for your application’s requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::array`, which are stack-allocated, can be faster to access than their
    heap-allocated counterparts due to cache locality. However, this comes with the
    trade-off of fixed sizes. Hence, understanding the memory requirements beforehand
    can help strike the right balance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, can invalidate iterators, leading to undefined behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmark and profile**: Assumptions and best practices are starting points,
    but real performance metrics come from profiling your application. Tools such
    as gprof, Valgrind, and Celero can be invaluable in highlighting bottlenecks and
    guiding you toward the right optimizations. These best practices outline how to
    optimize C++ STL usage, emphasizing the importance of understanding the nature
    of data, leveraging sorted data structures, avoiding unnecessary memory reallocations,
    preferring algorithms with predicate versions, being aware of algorithmic complexity,
    choosing stack over heap allocation when appropriate, using iterators judiciously,
    and the significance of benchmarking and profiling to identify performance bottlenecks.
    They underscore that while STL offers powerful utilities, efficient programming
    depends on how these tools are employed and combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have thoroughly examined the core algorithms that operate
    on STL containers and their role in efficient C++ programming. We began by exploring
    the essentials of sorting algorithms and understanding how they organize data
    for better accessibility and performance. We then delved into various methods
    for checking container conditions and techniques for counting and finding elements,
    which are vital for data analysis and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has armed you with strategies for effectively searching and comparing
    elements. We also focused on best practices that ensure these operations are performed
    with optimal efficiency and minimal error.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge has provided a foundation for implementing complex algorithms
    and performing data manipulations and everyday tasks in intermediate to advanced
    C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend our understanding of algorithms further.
    We will learn about copying and moving semantics within STL containers, **Return
    Value Optimization** (**RVO**), and techniques for filling, generating, removing,
    and replacing elements. Additionally, we will explore the nuances of swapping
    and reversing elements and conclude with deduplication and sampling strategies.
    These topics will contribute to a holistic understanding of data manipulation
    and transformation.
  prefs: []
  type: TYPE_NORMAL
