["```cpp\n const aiScene* scene = aiImportFile(\n    “data/rubber_duck/scene.gltf”, aiProcess_Triangulate);\n  const aiMesh* mesh = scene->mMeshes[0];\n  std::vector<vec3> positions;\n  std::vector<uint32_t> indices;\n  for (unsigned int i = 0; i != mesh->mNumVertices; i++) {\n    const aiVector3D v = mesh->mVertices[i];\n    positions.push_back(vec3(v.x, v.y, v.z));\n  }\n  for (unsigned int i = 0; i != mesh->mNumFaces; i++) {\n    for (int j = 0; j != 3; j++)\n      indices.push_back(mesh->mFaces[i].mIndices[j]);\n  }\n  aiReleaseImport(scene);\n```", "```cpp\n std::vector<uint32_t> remap(indices.size());\n  const size_t vertexCount =\n    meshopt_generateVertexRemap(remap.data(), indices.data(),\n      indices.size(), positions.data(), indices.size(), sizeof(vec3));\n```", "```cpp\n std::vector<uint32_t> remappedIndices(indices.size());\n  std::vector<vec3> remappedVertices(vertexCount);\n  meshopt_remapIndexBuffer(remappedIndices.data(), indices.data(),\n    indices.size(), remap.data());\n  meshopt_remapVertexBuffer(remappedVertices.data(), positions.data(),\n    positions.size(), sizeof(vec3), remap.data());\n```", "```cpp\n meshopt_optimizeVertexCache(remappedIndices.data(),\n    remappedIndices.data(), indices.size(), vertexCount);\n```", "```cpp\n meshopt_optimizeOverdraw(\n    remappedIndices.data(), remappedIndices.data(),\n    indices.size(), glm::value_ptr(remappedVertices[0]), vertexCount,\n    sizeof(vec3), 1.05f);\n```", "```cpp\n meshopt_optimizeVertexFetch(\n    remappedVertices.data(), remappedIndices.data(), indices.size(),\n    remappedVertices.data(), vertexCount, sizeof(vec3));\n```", "```cpp\n const float threshold           = 0.2f;\n  const size_t target_index_count =\n    size_t(remappedIndices.size() * threshold);\n  const float target_error        = 0.01f;\n  std::vector<uint32_t> indicesLod;\n  indicesLod.resize(remappedIndices.size());\n  indicesLod.resize(meshopt_simplify(\n    &indicesLod[0], remappedIndices.data(), remappedIndices.size(),\n    &remappedVertices[0].x, vertexCount, sizeof(vec3),\n    target_index_count, target_error));\n  indices   = remappedIndices;\n  positions = remappedVertices;\n```", "```cpp\n lvk::Holder<lvk::BufferHandle> vertexBuffer = ctx->createBuffer({\n    .usage     = lvk::BufferUsageBits_Vertex,\n    .storage   = lvk::StorageType_Device,\n    .size      = sizeof(vec3) * positions.size(),\n    .data      = positions.data(),\n    .debugName = “Buffer: vertex” }, nullptr);\n```", "```cpp\n lvk::Holder<lvk::BufferHandle> indexBuffer = ctx->createBuffer({\n    .usage     = lvk::BufferUsageBits_Index,\n    .storage   = lvk::StorageType_Device,\n    .size      = sizeof(uint32_t) * indices.size(),\n    .data      = indices.data(),\n    .debugName = “Buffer: index” }, nullptr);\n  lvk::Holder<lvk::BufferHandle> indexBufferLod = ctx->createBuffer({\n    .usage     = lvk::BufferUsageBits_Index,\n    .storage   = lvk::StorageType_Device,\n    .size      = sizeof(uint32_t) * indicesLod.size(),\n    .data      = indicesLod.data(),\n    .debugName = “Buffer: index LOD” }, nullptr);\n```", "```cpp\n buf.cmdBindVertexBuffer(0, vertexBuffer, 0);\n  buf.cmdBindRenderPipeline(pipeline);\n  buf.cmdBindDepthState(dState);\n  buf.cmdPushConstants(p * v1 * m);\n  buf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);\n  buf.cmdDrawIndexed(indices.size());\n```", "```cpp\n buf.cmdPushConstants(p * v2 * m);\n  buf.cmdBindIndexBuffer(indexBufferLod, lvk::IndexFormat_UI32);\n  buf.cmdDrawIndexed(indicesLod.size());\n```", "```cpp\nconst aiScene* scene = aiImportFile(\n  “data/rubber_duck/scene.gltf”, aiProcess_Triangulate);\nconst aiMesh* mesh = scene->mMeshes[0];\n```", "```cpp\nstruct Vertex {\n  vec3 pos;\n  vec2 uv;\n};\nstd::vector<Vertex> positions;\nfor (unsigned int i = 0; i != mesh->mNumVertices; i++) {\n  const aiVector3D v = mesh->mVertices[i];\n  const aiVector3D t = mesh->mTextureCoords[0][i];\n  positions.push_back({\n   .pos = vec3(v.x, v.y, v.z), .uv = vec2(t.x, t.y) });\n}\n```", "```cpp\nstd::vector<uint32_t> indices;\nfor (unsigned int i = 0; i != mesh->mNumFaces; i++) {\n  for (int j = 0; j != 3; j++)\n    indices.push_back(mesh->mFaces[i].mIndices[j]);\n}\naiReleaseImport(scene);\n```", "```cpp\nlvk::Holder<lvk::BufferHandle> vertexBuffer = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Storage,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(Vertex) * positions.size(),\n  .data      = positions.data(),\n  .debugName = “Buffer: vertex” }, nullptr);\nlvk::Holder<lvk::BufferHandle> indexBuffer = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Index,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(uint32_t) * indices.size(),\n  .data      = indices.data(),\n  .debugName = “Buffer: index” }, nullptr);\n```", "```cpp\nlvk::Holder<lvk::ShaderModuleHandle> vert =\n  loadShaderModule(ctx, “Chapter05/02_VertexPulling/src/main.vert”);\nlvk::Holder<lvk::ShaderModuleHandle> geom =\n  loadShaderModule(ctx, “Chapter05/02_VertexPulling/src/main.geom”);\nlvk::Holder<lvk::ShaderModuleHandle> frag =\n  loadShaderModule(ctx, “Chapter05/02_VertexPulling/src/main.frag”);\nlvk::Holder<lvk::RenderPipelineHandle> pipelineSolid =\n  ctx->createRenderPipeline({\n        .smVert      = vert,\n        .smGeom      = geom,\n        .smFrag      = frag,\n        .color       = { { .format = ctx->getSwapchainFormat() } },\n        .depthFormat = app.getDepthFormat(),\n        .cullMode    = lvk::CullMode_Back,\n    });\n```", "```cpp\nlvk::Holder<lvk::TextureHandle> texture =\n  loadTexture(ctx, “data/rubber_duck/textures/Duck_baseColor.png”);\nconst lvk::DepthState dState =\n  { .compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true };\n```", "```cpp\nconst struct PushConstants {\n  mat4 mvp;\n  uint64_t vertices;\n  uint32_t texture;\n} pc {\n  .mvp      = p * v * m,\n  .vertices = ctx->gpuAddress(vertexBuffer),\n  .texture  = texture.index(),\n};\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nbuf.cmdBeginRendering(renderPass, framebuffer);\nbuf.cmdPushConstants(pc);\n```", "```cpp\nbuf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);\nbuf.cmdBindRenderPipeline(pipelineSolid);\nbuf.cmdBindDepthState(dState);\nbuf.cmdDrawIndexed(indices.size());\nbuf.cmdEndRendering();\n```", "```cpp\nstruct Vertex {\n  float x, y, z;\n  float u, v;\n};\nlayout(std430, buffer_reference) readonly buffer Vertices {\n  Vertex in_Vertices[];\n};\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n  Vertices vtx;\n  uint texture;\n};\n```", "```cpp\nvec3 getPosition(int i) {\n  return vec3(vtx.in_Vertices[i].x,\n              vtx.in_Vertices[i].y,\n              vtx.in_Vertices[i].z);\n}\nvec2 getTexCoord(int i) {\n  return vec2(vtx.in_Vertices[i].u,\n              vtx.in_Vertices[i].v);\n}\n```", "```cpp\nlayout (location=0) out vec2 uv;\nvoid main() {\n  gl_Position = MVP * vec4(getPosition(gl_VertexIndex), 1.0);\n  uv = getTexCoord(gl_VertexIndex);\n}\n```", "```cpp\nconst uint32_t texWidth  = 256;\nconst uint32_t texHeight = 256;\nstd::vector<uint32_t> pixels(texWidth * texHeight);\nfor (uint32_t y = 0; y != texHeight; y++)\n  for (uint32_t x = 0; x != texWidth; x++)\n    pixels[y * texWidth + x] =\n      0xFF000000 + ((x^y) << 16) + ((x^y) << 8) + (x^y);\nlvk::Holder<lvk::TextureHandle> texture = ctx->createTexture({\n   .type       = lvk::TextureType_2D,\n   .format     = lvk::Format_BGRA_UN8,\n   .dimensions = {texWidth, texHeight},\n   .usage      = lvk::TextureUsageBits_Sampled,\n   .data       = pixels.data(),\n   .debugName  = “XOR pattern”,\n});\n```", "```cpp\nconst uint32_t kNumCubes = 1024 * 1024;\nstd::vector<vec4> centers(kNumCubes);\nfor (vec4& p : centers)\n  p = vec4(glm::linearRand(-vec3(500.0f), +vec3(500.0f)),\n           glm::linearRand(0.0f, 3.14159f));\nlvk::Holder<lvk::BufferHandle> bufferPosAngle = ctx->createBuffer({\n  .usage   = lvk::BufferUsageBits_Storage,\n  .storage = lvk::StorageType_Device,\n  .size    = sizeof(vec4) * kNumCubes,\n  .data    = centers.data(),\n});\n```", "```cpp\nbuf.cmdBeginRendering(renderPass, framebuffer);\nconst mat4 view = translate(mat4(1.0f),\n  vec3(0.0f, 0.0f,\n       -1000.0f + 500.0f * (1.0f - cos(-glfwGetTime() * 0.5f))));\n```", "```cpp\nconst struct {\n  mat4 viewproj;\n  uint32_t textureId;\n  uint64_t bufferPosAngle;\n  float time;\n} pc {\n  .viewproj       = proj * view,\n  .textureId      = texture.index(),\n  .bufferPosAngle = ctx->gpuAddress(bufferPosAngle),\n  .time           = (float)glfwGetTime(),\n};\n```", "```cpp\nbuf.cmdPushConstants(pc);\nbuf.cmdBindRenderPipeline(pipelineSolid);\nbuf.cmdBindDepthState(dState);\nbuf.cmdDraw(36, kNumCubes);\nbuf.cmdEndRendering();\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  mat4 viewproj;\n  uint textureId;\n  uvec2 bufId;\n  float time;\n};\nlayout (location=0) out vec3 color;\nlayout (location=1) out vec2 uv;\nlayout(std430, buffer_reference) readonly buffer Positions {\n  vec4 pos[]; // pos, initialAngle\n};\n```", "```cpp\nconst int indices[36] = int[36](\n  0,  2,  1,  2,  3,  1,  5,  4,  1,  1,  4,  0,\n  0,  4,  6,  0,  6,  2,  6,  5,  7,  6,  4,  5,\n  2,  6,  3,  6,  7,  3,  7,  1,  3,  7,  5,  1);\n```", "```cpp\nconst vec3 colors[7] = vec3[7](\n  vec3(1.0, 0.0, 0.0),\n  vec3(0.0, 1.0, 0.0),\n  vec3(0.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 0.0),\n  vec3(0.0, 1.0, 1.0),\n  vec3(1.0, 0.0, 1.0),\n  vec3(1.0, 1.0, 1.0));\n```", "```cpp\nmat4 translate(mat4 m, vec3 v) {\n  mat4 Result = m;\n  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];\n  return Result;\n}\n```", "```cpp\nmat4 rotate(mat4 m, float angle, vec3 v) {\n  float a = angle;\n  float c = cos(a);\n  float s = sin(a);\n  vec3 axis = normalize(v);\n  vec3 temp = (float(1.0) - c) * axis;\n  mat4 r;\n  r[0][0] = c + temp[0] * axis[0];\n  r[0][1] = temp[0] * axis[1] + s * axis[2];\n  r[0][2] = temp[0] * axis[2] - s * axis[1];\n  r[1][0] = temp[1] * axis[0] - s * axis[2];\n  r[1][1] = c + temp[1] * axis[1];\n  r[1][2] = temp[1] * axis[2] + s * axis[0];\n  r[2][0] = temp[2] * axis[0] + s * axis[1];\n  r[2][1] = temp[2] * axis[1] - s * axis[0];\n  r[2][2] = c + temp[2] * axis[2];\n  mat4 res;\n  res[0] = m[0] * r[0][0] + m[1] * r[0][1] + m[2] * r[0][2];\n  res[1] = m[0] * r[1][0] + m[1] * r[1][1] + m[2] * r[1][2];\n  res[2] = m[0] * r[2][0] + m[1] * r[2][1] + m[2] * r[2][2];\n  res[3] = m[3];\n  return res;\n}\n```", "```cpp\nvoid main() {\n  vec4 center = Positions(bufId).pos[gl_InstanceIndex];\n  mat4 model = rotate(translate(mat4(1.0f), center.xyz),\n                 time + center.w, vec3(1.0f, 1.0f, 1.0f));\n```", "```cpp\n uint idx = indices[gl_VertexIndex];\n  vec3 xyz = vec3(idx & 1, (idx & 4) >> 2, (idx & 2) >> 1);\n```", "```cpp\n const float edge = 1.0;\n  gl_Position =\n    viewproj * model * vec4(edge * (xyz - vec3(0.5)), 1.0);\n```", "```cpp\n int face = gl_VertexIndex / 6;\n  if (face == 0 || face == 3) uv = vec2(xyz.x, xyz.z);\n  if (face == 1 || face == 4) uv = vec2(xyz.x, xyz.y);\n  if (face == 2 || face == 5) uv = vec2(xyz.y, xyz.z);\n  color = colors[gl_InstanceIndex % 7];\n}\n```", "```cpp\nlayout (location=0) in vec3 color;\nlayout (location=1) in vec2 uv;\nlayout (location=0) out vec4 out_FragColor;\nlayout(push_constant) uniform PerFrameData {\n  mat4 proj;\n  uint textureId;\n};\nvoid main() {\n  out_FragColor = textureBindless2D(\n    textureId, 0, uv) * vec4(color, 1.0);\n}\n```", "```cpp\nconst uint32_t kNumMeshes = 32 * 1024;\nstd::vector<vec4> centers(kNumMeshes);\nfor (vec4& p : centers)\n   p = vec4(glm::linearRand(-vec3(500.0f), +vec3(500.0f)),\n            glm::linearRand(0.0f, 3.14159f));\n```", "```cpp\nlvk::Holder<lvk::BufferHandle> bufferPosAngle   = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Storage,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(vec4) * kNumMeshes,\n  .data      = centers.data(),\n  .debugName = “Buffer: angles & positions”,\n});\n```", "```cpp\nlvk::Holder<lvk::BufferHandle> bufferMatrices[] = {\n  ctx->createBuffer({ .usage     = lvk::BufferUsageBits_Storage,\n                      .storage   = lvk::StorageType_Device,\n                      .size      = sizeof(mat4) * kNumMeshes,\n                      .debugName = “Buffer: matrices 1” }),\n  ctx->createBuffer({ .usage     = lvk::BufferUsageBits_Storage,\n                      .storage   = lvk::StorageType_Device,\n                      .size      = sizeof(mat4) * kNumMeshes,\n                      .debugName = “Buffer: matrices 2” }),\n};.\n```", "```cpp\nconst aiScene* scene =\n  aiImportFile(“data/rubber_duck/scene.gltf”, aiProcess_Triangulate);\nstruct Vertex {\n  vec3 pos;\n  vec2 uv;\n  vec3 n;\n};\nconst aiMesh* mesh = scene->mMeshes[0];\nstd::vector<Vertex> vertices;\nstd::vector<uint32_t> indices;\nfor (unsigned int i = 0; i != mesh->mNumVertices; i++) {\n  const aiVector3D v = mesh->mVertices[i];\n  const aiVector3D t = mesh->mTextureCoords[0][i];\n  const aiVector3D n = mesh->mNormals[i];\n  vertices.push_back({ .pos = vec3(v.x, v.y, v.z),\n                       .uv  = vec2(t.x, t.y),\n                       .n   = vec3(n.x, n.y, n.z) });\n}\nfor (unsigned int i = 0; i != mesh->mNumFaces; i++)\n  for (int j = 0; j != 3; j++)\n    indices.push_back(mesh->mFaces[i].mIndices[j]);\naiReleaseImport(scene);\n```", "```cpp\nlvk::Holder<lvk::BufferHandle> vertexBuffer = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Storage,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(Vertex) * vertices.size(),\n  .data      = vertices.data(),\n  .debugName = “Buffer: vertex” }, nullptr);\nlvk::Holder<lvk::BufferHandle> indexBuffer = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Index,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(uint32_t) * indices.size(),\n  .data      = indices.data(),\n  .debugName = “Buffer: index” }, nullptr);\n```", "```cpp\nlvk::Holder<lvk::TextureHandle> texture =\n  loadTexture(ctx, “data/rubber_duck/textures/Duck_baseColor.png”);\nlvk::Holder<lvk::ShaderModuleHandle> comp =\n  loadShaderModule(ctx, “Chapter05/04_InstancedMeshes/src/main.comp”);\nlvk::Holder<lvk::ComputePipelineHandle> pipelineComputeMatrices =\n  ctx->createComputePipeline({ smComp = comp });\nlvk::Holder<lvk::ShaderModuleHandle> vert =\n  loadShaderModule(ctx, “Chapter05/04_InstancedMeshes/src/main.vert”);\nlvk::Holder<lvk::ShaderModuleHandle> frag =\n  loadShaderModule(ctx, “Chapter05/04_InstancedMeshes/src/main.frag”);\nlvk::Holder<lvk::RenderPipelineHandle> pipelineSolid =\n  ctx->createRenderPipeline({\n    .smVert      = vert,\n    .smFrag      = frag,\n    .color       = { { .format = ctx->getSwapchainFormat() } },\n    .depthFormat = app.getDepthFormat(),\n    .cullMode    = lvk::CullMode_Back });\n```", "```cpp\nuint32_t frameId = 0;\napp.run([&](uint32_t width, uint32_t height,\n            float aspectRatio, float deltaSeconds) {\n  const mat4 proj =\n    glm::perspective(45.0f, aspectRatio, 0.2f, 1500.0f);\n  const lvk::RenderPass renderPass = {\n    .color = { { .loadOp = lvk::LoadOp_Clear,\n                .clearColor = { 1.0f, 1.0f, 1.0f, 1.0f } } },\n    .depth = { .loadOp = lvk::LoadOp_Clear, .clearDepth = 1.0f }\n  };\n  const lvk::Framebuffer framebuffer = {\n    .color = { { .texture = ctx->getCurrentSwapchainTexture() } },\n    .depthStencil = { .texture = app.getDepthTexture() },\n  };\n  lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n```", "```cpp\n const mat4 view = translate(mat4(1.0f), vec3(0.0f, 0.0f,\n    -1000.0f + 500.0f * (1.0f - cos(-glfwGetTime() * 0.5f))));\n  const struct {\n    mat4 viewproj;\n    uint32_t textureId;\n    uint64_t bufferPosAngle;\n    uint64_t bufferMatrices;\n    uint64_t bufferVertices;\n    float time;\n  } pc {\n    .viewproj       = proj * view,\n    .textureId      = texture.index(),\n    .bufferPosAngle = ctx->gpuAddress(bufferPosAngle),\n    .bufferMatrices = ctx->gpuAddress(bufferMatrices[frameId]),\n    .bufferVertices = ctx->gpuAddress(vertexBuffer),\n    .time           = (float)glfwGetTime(),\n  };\n  buf.cmdPushConstants(pc);\n```", "```cpp\n buf.cmdBindComputePipeline(pipelineComputeMatrices);\n  buf.cmdDispatchThreadGroups({ .width = kNumMeshes / 32 } });\n```", "```cpp\n buf.cmdBeginRendering(renderPass, framebuffer,\n    { .buffers = { lvk::BufferHandle(bufferMatrices[frameId]) } });\n```", "```cpp\nVK_PIPELINE_STAGE_COMPUTE_SHADER_BIT\n```", "```cpp\nVK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT\n```", "```cpp\nvoid lvk::CommandBuffer::bufferBarrier(BufferHandle handle,\n  VkPipelineStageFlags srcStage, VkPipelineStageFlags dstStage)\n{\n  lvk::VulkanBuffer* buf = ctx_->buffersPool_.get(handle);\n  const VkBufferMemoryBarrier barrier = {\n    .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n    .srcAccessMask = VK_ACCESS_SHADER_READ_BIT |\n                     VK_ACCESS_SHADER_WRITE_BIT,\n    .dstAccessMask = VK_ACCESS_SHADER_READ_BIT |\n                     VK_ACCESS_SHADER_WRITE_BIT,\n    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,\n    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,\n    .buffer = buf->vkBuffer_,\n    .offset = 0,\n    .size = VK_WHOLE_SIZE,\n  };\n  vkCmdPipelineBarrier(wrapper_->cmdBuf_, srcStage, dstStage,\n    VkDependencyFlags{}, 0, nullptr, 1, &barrier, 0, nullptr);\n}\n```", "```cpp\n buf.cmdBindRenderPipeline(pipelineSolid);\n  buf.cmdBindDepthState({\n    .compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true });\n  buf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);\n  buf.cmdDrawIndexed(indices.size(), kNumMeshes);\n  buf.cmdEndRendering();\n  ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n  frameId = (frameId + 1) & 1;\n});\n```", "```cpp\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;\n// included from <Chapter05/04_InstancedMeshes/src/common.sp>\nlayout(push_constant) uniform PerFrameData {\n  mat4 viewproj;\n  uint textureId;\n  uvec2 bufPosAngleId;\n  uvec2 bufMatricesId;\n  uvec2 bufVerticesId;\n  float time;\n};\nlayout(std430, buffer_reference) readonly buffer Positions {\n  vec4 pos[]; // pos, initialAngle\n};\n// end of #include\n```", "```cpp\nlayout(std430, buffer_reference) writeonly buffer Matrices {\n  mat4 mtx[];\n};\n```", "```cpp\nmat4 translate(mat4 m, vec3 v);\nmat4 rotate(mat4 m, float angle, vec3 v);\n```", "```cpp\nvoid main() {\n  uint idx = gl_GlobalInvocationID.x;\n  vec4 center = Positions(bufPosAngleId).pos[idx];\n  mat4 model = rotate(translate(mat4(1.0f),\n    center.xyz), time + center.w, vec3(1.0f, 1.0f, 1.0f));\n  Matrices(bufMatricesId).mtx[idx] = model;\n}\n```", "```cpp\n#include <Chapter05/04_InstancedMeshes/src/common.sp>\nlayout (location=0) out vec2 uv;\nlayout (location=1) out vec3 normal;\nlayout (location=2) out vec3 color;\nlayout(std430, buffer_reference) readonly buffer Matrices {\n  mat4 mtx[];\n};\n```", "```cpp\nstruct Vertex {\n  float x, y, z;\n  float u, v;\n  float nx, ny, nz;\n};\nlayout(std430, buffer_reference) readonly buffer Vertices {\n  Vertex in_Vertices[];\n};\n```", "```cpp\nconst vec3 colors[3] = vec3[3](vec3(1.0, 0.0, 0.0),\n                               vec3(0.0, 1.0, 0.0),\n                               vec3(1.0, 1.0, 1.0));\nvoid main() {\n  Vertex vtx = Vertices(bufVerticesId).in_Vertices[gl_VertexIndex];\n  mat4 model = Matrices(bufMatricesId).mtx[gl_InstanceIndex];\n```", "```cpp\n const float scale = 10.0;\n  gl_Position = viewproj * model *\n    vec4(scale * vtx.x, scale * vtx.y, scale * vtx.z, 1.0);\n  mat3 normalMatrix = transpose( inverse(mat3(model)) );\n  uv = vec2(vtx.u, vtx.v);\n  normal = normalMatrix * vec3(vtx.nx, vtx.ny, vtx.nz);\n  color = colors[gl_InstanceIndex % 3];\n}\n```", "```cpp\nlayout (location=0) in vec2 uv;\nlayout (location=1) in vec3 normal;\nlayout (location=2) in vec3 color;\nlayout (location=0) out vec4 out_FragColor;\nlayout(push_constant) uniform PerFrameData {\n  mat4 viewproj;\n  uint textureId;\n};\nvoid main() {\n  vec3 n = normalize(normal);\n  vec3 l = normalize(vec3(1.0, 0.0, 1.0));\n  float NdotL = clamp(dot(n, l), 0.3, 1.0);\n  out_FragColor =\n    textureBindless2D(textureId, 0, uv) * NdotL * vec4(color, 1.0);\n};\n```", "```cpp\nfloat gridSize = 100.0;\n```", "```cpp\nfloat gridCellSize = 0.025;\n```", "```cpp\nvec4 gridColorThin = vec4(0.5, 0.5, 0.5, 1.0);\nvec4 gridColorThick = vec4(0.0, 0.0, 0.0, 1.0);\n```", "```cpp\nconst float gridMinPixelsBetweenCells = 2.0;\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n  vec4 cameraPos;\n  vec4 origin;\n};\nlayout (location=0) out vec2 uv;\nlayout (location=1) out vec2 out_camPos;\nconst vec3 pos[4] = vec3[4](\n  vec3(-1.0, 0.0, -1.0),\n  vec3( 1.0, 0.0, -1.0),\n  vec3( 1.0, 0.0,  1.0),\n  vec3(-1.0, 0.0,  1.0)\n);\nconst int indices[6] = int[6]( 0, 1, 2, 2, 3, 0 );\n```", "```cpp\nvoid main() {\n  int idx = indices[gl_VertexIndex];\n  vec3 position = pos[idx] * gridSize;\n  position.x += cameraPos.x;\n  position.z += cameraPos.z;\n  position += origin.xyz;\n  out_camPos = cameraPos.xz;\n  gl_Position = MVP * vec4(position, 1.0);\n  uv = position.xz;\n}\n```", "```cpp\nfloat log10(float x) {\n  return log(x) / log(10.0);\n}\nfloat satf(float x) {\n  return clamp(x, 0.0, 1.0);\n}\nvec2 satv(vec2 x) {\n  return clamp(x, vec2(0.0), vec2(1.0));\n}\nfloat max2(vec2 v) {\n  return max(v.x, v.y);\n}\n```", "```cpp\nvec2 dudv = vec2( length(vec2(dFdx(uv.x), dFdy(uv.x))),\n                  length(vec2(dFdx(uv.y), dFdy(uv.y))) );\n```", "```cpp\nfloat lodLevel = max(0.0, log10((length(dudv) *\n  gridMinPixelsBetweenCells) / gridCellSize) + 1.0);\nfloat lodFade = fract(lodLevel);\n```", "```cpp\nfloat lod0 = gridCellSize * pow(10.0, floor(lodLevel));\nfloat lod1 = lod0 * 10.0;\nfloat lod2 = lod1 * 10.0;\n```", "```cpp\ndudv *= 4.0;\nuv += dudv * 0.5;\n```", "```cpp\nfloat lod0a = max2( vec2(1.0) - abs(\n  satv(mod(uv, lod0) / dudv) * 2.0 - vec2(1.0)) );\nfloat lod1a = max2( vec2(1.0) - abs(\n  satv(mod(uv, lod1) / dudv) * 2.0 - vec2(1.0)) );\nfloat lod2a = max2( vec2(1.0) - abs(\n  satv(mod(uv, lod2) / dudv) * 2.0 - vec2(1.0)) );\n```", "```cpp\nvec4 c = lod2a > 0.0 ?\n  gridColorThick :\n  lod1a > 0.0 ?\n    mix(gridColorThick, gridColorThin, lodFade) : gridColorThin;\n```", "```cpp\nuv -= camPos;\nfloat opacityFalloff = (1.0 - satf(length(uv) / gridSize));\n```", "```cpp\nc.a *= \n  lod2a > 0.0 ? lod2a : lod1a > 0.0 ? lod1a : (lod0a * (1.0-lodFade));\nc.a *= opacityFalloff;\nout_FragColor = c;\n```", "```cpp\nlvk::Holder<lvk::RenderPipelineHandle> pipeline =\n  ctx->createRenderPipeline({\n    .smVert      = vert,\n    .smFrag      = frag,\n    .color       = { {\n      .format            = ctx->getSwapchainFormat(),\n      .blendEnabled      = true,\n      .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,\n      .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha,\n    } },\n    .depthFormat = app.getDepthFormat() });\n```", "```cpp\nbuf.cmdBindRenderPipeline(pipeline);\nbuf.cmdBindDepthState({});\nstruct {\n  mat4 mvp;\n  vec4 camPos;\n  vec4 origin;\n} pc = {\n  .mvp    = glm::perspective(\n    45.0f, aspectRatio, 0.1f, 1000.0f) * app.camera_.getViewMatrix(),\n  .camPos = vec4(app.camera_.getPosition(), 1.0f),\n  .origin = vec4(0.0f),\n};\nbuf.cmdPushConstants(pc);\nbuf.cmdDraw(6);\n```", "```cpp\n// included from <Chapter05/06_Tessellation/src/common.sp>\nstruct Vertex {\n  float x, y, z;\n  float u, v;\n};\nlayout(std430, buffer_reference) readonly buffer Vertices {\n  Vertex in_Vertices[];\n};\nlayout(std430, buffer_reference) readonly buffer PerFrameData {\n  mat4 model;\n  mat4 view;\n  mat4 proj;\n  vec4 cameraPos;\n  uint texture;\n  float tesselationScale;\n  Vertices vtx;\n};\nlayout(push_constant) uniform PushConstants {\n  PerFrameData pc;\n};\n```", "```cpp\nvec3 getPosition(int i) {\n  return vec3(pc.vtx.in_Vertices[i].x,\n              pc.vtx.in_Vertices[i].y,\n              pc.vtx.in_Vertices[i].z);\n}\nvec2 getTexCoord(int i) {\n  return vec2(pc.vtx.in_Vertices[i].u,\n              pc.vtx.in_Vertices[i].v);\n}\n```", "```cpp\nlayout (location=0) out vec2 uv_in;\nlayout (location=1) out vec3 worldPos_in;\nvoid main() {\n  vec4 pos = vec4(getPosition(gl_VertexIndex), 1.0);\n  gl_Position = pc.proj * pc.view * pc.model * pos;\n  uv_in = getTexCoord(gl_VertexIndex);\n  worldPos_in = (pc.model * pos).xyz;\n}\n```", "```cpp\n#include <Chapter05/06_Tessellation/src/common.sp>\nlayout (vertices = 3) out;\nlayout (location = 0) in vec2 uv_in[];\nlayout (location = 1) in vec3 worldPos_in[];\n```", "```cpp\nin gl_PerVertex {\n  vec4 gl_Position;\n} gl_in[];\nout gl_PerVertex {\n  vec4 gl_Position;\n} gl_out[];\nstruct vertex {\n  vec2 uv;\n};\nstruct vertex {\n  vec2 uv;\n};\nlayout(location = 0) out vertex Out[];\n```", "```cpp\nfloat getTessLevel(float distance0, float distance1) {\n  const float distanceScale1 = 1.2;\n  const float distanceScale2 = 1.7;\n  const float avgDistance =\n    (distance0 + distance1) / (2.0 * pc.tesselationScale);\n  if (avgDistance <= distanceScale1) return 5.0;\n  if (avgDistance <= distanceScale2) return 3.0;\n  return 1.0;\n}\n```", "```cpp\nvoid main() {  \n  gl_out[gl_InvocationID].gl_Position =\n    gl_in[gl_InvocationID].gl_Position;\n  Out[gl_InvocationID].uv = uv_in[gl_InvocationID];\n  vec3 c = pc.cameraPos.xyz;\n  float eyeToVertexDistance0 = distance(c, worldPos_in[0]);\n  float eyeToVertexDistance1 = distance(c, worldPos_in[1]);\n  float eyeToVertexDistance2 = distance(c, worldPos_in[2]);\n```", "```cpp\n gl_TessLevelOuter[0] =\n    getTessLevel(eyeToVertexDistance1, eyeToVertexDistance2);\n  gl_TessLevelOuter[1] =\n    getTessLevel(eyeToVertexDistance2, eyeToVertexDistance0);\n  gl_TessLevelOuter[2] =\n    getTessLevel(eyeToVertexDistance0, eyeToVertexDistance1);\n  gl_TessLevelInner[0] = gl_TessLevelOuter[2];\n};\n```", "```cpp\nlayout(triangles, equal_spacing, ccw) in;\nstruct vertex {\n  vec2 uv;\n};\nin gl_PerVertex {\n  vec4 gl_Position;\n} gl_in[];\nlayout(location = 0) in vertex In[];\nout gl_PerVertex {\n  vec4 gl_Position;\n};\nlayout (location=0) out vec2 uv;\n```", "```cpp\nvec2 interpolate2(in vec2 v0, in vec2 v1, in vec2 v2) {\n  return v0 * gl_TessCoord.x +\n         v1 * gl_TessCoord.y +\n         v2 * gl_TessCoord.z;\n}\nvec4 interpolate4(in vec4 v0, in vec4 v1, in vec4 v2) {\n  return v0 * gl_TessCoord.x +\n         v1 * gl_TessCoord.y +\n         v2 * gl_TessCoord.z;\n}\n```", "```cpp\nvoid main() {\n  gl_Position = interpolate4(gl_in[0].gl_Position,\n                             gl_in[1].gl_Position,\n                             gl_in[2].gl_Position);\n  uv = interpolate2(In[0].uv, In[1].uv, In[2].uv);\n};\n```", "```cpp\n#version 460 core\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices = 3) out;\nlayout(location=0) in vec2 uv[];\nlayout(location=0) out vec2 uvs;\nlayout(loc\nation=1) out vec3 barycoords;\n```", "```cpp\nvoid main() {\n  const vec3 bc[3] = vec3[]( vec3(1.0, 0.0, 0.0),\n                             vec3(0.0, 1.0, 0.0),\n                             vec3(0.0, 0.0, 1.0) );\n  for ( int i = 0; i < 3; i++ ) {\n    gl_Position = gl_in[i].gl_Position;\n    uvs = uv[i];\n    barycoords = bc[i];\n    EmitVertex();\n  }\n  EndPrimitive();\n}\n```", "```cpp\n#include <Chapter05/06_Tessellation/src/common.sp>\nlayout(location=0) in vec2 uvs;\nlayout(location=1) in vec3 barycoords;\nlayout(location=0) out vec4 out_FragColor;\n```", "```cpp\nfloat edgeFactor(float thickness) {\n  vec3 a3 = smoothstep( vec3(0.0),\n              fwidth(barycoords) * thickness, barycoords);\n  return min( min( a3.x, a3.y ), a3.z );\n}\n```", "```cpp\nvoid main() {\n  vec4 color = textureBindless2D(pc.texture, 0, uvs);\n  out_FragColor = mix( vec4(0.1), color, edgeFactor(0.75) );\n}\n```", "```cpp\nlvk::Holder<lvk::ShaderModuleHandle> vert =\n  loadShaderModule(ctx, “Chapter05/06_Tessellation/src/main.vert”);\nlvk::Holder<lvk::ShaderModuleHandle> tesc =\n  loadShaderModule(ctx, “Chapter05/06_Tessellation/src/main.tesc”);\nlvk::Holder<lvk::ShaderModuleHandle> geom =\n  loadShaderModule(ctx, “Chapter05/06_Tessellation/src/main.geom”);\nlvk::Holder<lvk::ShaderModuleHandle> tese =\n  loadShaderModule(ctx, “Chapter05/06_Tessellation/src/main.tese”);\nlvk::Holder<lvk::ShaderModuleHandle> frag =\n  loadShaderModule(ctx, “Chapter05/06_Tessellation/src/main.frag”);\n```", "```cpp\nlvk::Holder<lvk::RenderPipelineHandle> pipelineSolid =\n  ctx->createRenderPipeline({\n    .topology    = lvk::Topology_Patch,\n    .smVert      = vert,\n    .smTesc      = tesc,\n    .smTese      = tese,\n    .smGeom      = geom,\n    .smFrag      = frag,\n    .color       = { { .format = ctx->getSwapchainFormat() } },\n    .depthFormat = app.getDepthFormat(),\n    .patchControlPoints = 3,\n  });;\n```", "```cpp\nconst mat4 m = glm::rotate(mat4(1.0f),\n  glm::radians(-90.0f), vec3(1, 0, 0));\nconst mat4 v = glm::rotate(glm::translate(mat4(1.0f),\n  vec3(0.0f, -0.5f, -1.5f)),\n  (float)glfwGetTime(), vec3(0.0f, 1.0f, 0.0f));\nconst mat4 p = glm::perspective(45.0f, aspectRatio, 0.1f, 1000.0f);\n```", "```cpp\nconst PerFrameData pc = {\n  .model             = v * m,\n  .view              = app.camera_.getViewMatrix(),\n  .proj              = p,\n  .cameraPos         = vec4(app.camera_.getPosition(), 1.0f),\n  .texture           = texture.index(),\n  .tessellationScale = tessellationScale,\n  .vertices          = ctx->gpuAddress(vertexBuffer),\n};\nctx->upload(bufferPerFrame, &pc, sizeof(pc));\n```", "```cpp\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nbuf.cmdBeginRendering(renderPass, framebuffer);\nbuf.cmdPushConstants(ctx->gpuAddress(bufferPerFrame));\nbuf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);\nbuf.cmdBindRenderPipeline(pipelineSolid);\nbuf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                        .isDepthWriteEnabled = true });\nbuf.cmdDrawIndexed(indices.size());\n```", "```cpp\napp.drawGrid(buf, p, vec3(0, -0.5f, 0));\napp.imgui_->beginFrame(framebuffer);\nImGui::Begin(“Camera Controls”, nullptr,\n  ImGuiWindowFlags_AlwaysAutoResize);\nImGui::SliderFloat(\n  “Tessellation scale”, &tessellationScale, 0.7f, 1.2f, “%.1f”);\nImGui::End();\napp.imgui_->endFrame(buf);\nbuf.cmdEndRendering();\n```", "```cpp\nconstexpr const uint32_t kMaxLODs = 8;\nstruct Mesh final {\n  uint32_t lodCount = 1;\n  uint32_t indexOffset = 0;\n  uint32_t vertexOffset = 0;\n```", "```cpp\n uint32_t vertexCount = 0;\n  uint32_t materialID = 0;\n```", "```cpp\n uint32_t lodOffset[kMaxLODs+1] = { 0 };\n```", "```cpp\n inline uint32_t getLODIndicesCount(uint32_t lod) const {\n    return lod < lodCount ? lodOffset[lod + 1] - lodOffset[lod] : 0;\n  }\n};\n```", "```cpp\nstruct MeshData {\n  lvk::VertexInput streams = {};\n```", "```cpp\n std::vector<uint32_t> indexData;\n  std::vector<uint8_t> vertexData;\n```", "```cpp\n std::vector<Mesh> meshes;\n```", "```cpp\n std::vector<BoundingBox> boxes;\n};\n```", "```cpp\nstruct MeshFileHeader {\n  uint32_t magicValue;\n```", "```cpp\n uint32_t meshCount;\n```", "```cpp\n uint32_t indexDataSize;\n  uint32_t vertexDataSize;\n};\n```", "```cpp\nMeshFileHeader loadMeshData(const char* meshFile, MeshData& out) {\n  FILE* f = fopen(meshFile, “rb”);\n  SCOPE_EXIT { fclose(f); };\n  MeshFileHeader header;\n  fread(&header, 1, sizeof(header), f)\n  fread(&out.streams, 1, sizeof(out.streams), f);\n```", "```cpp\n out.meshes.resize(header.meshCount);\n  fread(out.meshes.data(), sizeof(Mesh), header.meshCount, f);\n  out.boxes.resize(header.meshCount);\n  fread(out.boxes.data(), sizeof(BoundingBox), header.meshCount, f);\n```", "```cpp\n out.indexData.resize(header.indexDataSize / sizeof(uint32_t));\n  out.vertexData.resize(header.vertexDataSize);\n  fread(out.indexData.data(), 1, header.indexDataSize, f);\n  fread(out.vertexData.data(), 1, header.vertexDataSize, f);\n  return header;\n};\n```", "```cpp\nMesh convertAIMesh(const aiMesh* m, MeshData& meshData,\n  uint32_t& indexOffset, uint32_t& vertexOffset)\n{\n  const bool hasTexCoords = m->HasTextureCoords(0);\n```", "```cpp\n std::vector<float> srcVertices;\n  std::vector<uint32_t> srcIndices;\n  std::vector<uint8_t>& vertices = meshData.vertexData;\n  std::vector<std::vector<uint32_t>> outLods;\n```", "```cpp\n for (size_t i = 0; i != m->mNumVertices; i++) {\n    const aiVector3D v = m->mVertices[i];\n    const aiVector3D n = m->mNormals[i];\n    const aiVector2D t = !hasTexCoords ? aiVector2D() : aiVector2D(\n      m->mTextureCoords[0][i].x,\n      m->mTextureCoords[0][i].y);\n    if (g_calculateLODs) {\n      srcVertices.push_back(v.x);\n      srcVertices.push_back(v.y);\n      srcVertices.push_back(v.z);\n    }\n```", "```cpp\n put(vertices, v);\n    put(vertices, glm::packHalf2x16(vec2(t.x, t.y)));\n    put(vertices, glm::packSnorm3x10_1x2(vec4(n.x, n.y, n.z, 0)));\n  }\n```", "```cpp\n meshData.streams = {\n    .attributes = {{ .location = 0,\n                     .format = lvk::VertexFormat::Float3,\n                     .offset = 0 },\n                   { .location = 1,\n                     .format = lvk::VertexFormat::HalfFloat2,\n                     .offset = sizeof(vec3) },\n                   { .location = 2,\n                     .format = lvk::VertexFormat::Int_2_10_10_10_REV,\n                     .offset = sizeof(vec3) + sizeof(uint32_t) } },\n    .inputBindings = { { .stride =\n      sizeof(vec3) + sizeof(uint32_t) + sizeof(uint32_t) } },\n  };\n```", "```cpp\n for (unsigned int i = 0; i != m->mNumFaces; i++) {\n    if (m->mFaces[i].mNumIndices != 3) continue;\n    for (unsigned j = 0; j != m->mFaces[i].mNumIndices; j++)\n      srcIndices.push_back(m->mFaces[i].mIndices[j]);\n  }\n```", "```cpp\n if (!g_calculateLODs)\n     outLods.push_back(srcIndices);\n  else\n     processLods(srcIndices, srcVertices, outLods);\n```", "```cpp\n Mesh result = {\n    .indexOffset  = indexOffset,\n    .vertexOffset = vertexOffset,\n    .vertexCount  = m->mNumVertices,\n  };\n```", "```cpp\n uint32_t numIndices = 0;\n  for (size_t l = 0; l < outLods.size(); l++) {\n    for (size_t i = 0; i < outLods[l].size(); i++)\n      meshData.indexData.push_back(outLods[l][i]);\n    result.lodOffset[l] = numIndices;\n    numIndices += (int)outLods[l].size();\n  }\n  result.lodOffset[outLods.size()] = numIndices;\n  result.lodCount                  = (uint32_t)outLods.size();\n```", "```cpp\n indexOffset += numIndices;\n  vertexOffset += m->mNumVertices;\n  return result;\n}\n```", "```cpp\nvoid loadMeshFile(const char* fileName, MeshData& meshData)\n{\n  const unsigned int flags = aiProcess_JoinIdenticalVertices |\n                             aiProcess_Triangulate |\n                             aiProcess_GenSmoothNormals |\n                             aiProcess_LimitBoneWeights | \n                             aiProcess_SplitLargeMeshes |\n                             aiProcess_ImproveCacheLocality |\n                             aiProcess_RemoveRedundantMaterials |\n                             aiProcess_FindDegenerates |\n                             aiProcess_FindInvalidData |\n                             aiProcess_GenUVCoords;\n  const aiScene* scene = aiImportFile(fileName, flags);\n```", "```cpp\n meshData.meshes.reserve(scene->mNumMeshes);\n  meshData.boxes.reserve(scene->mNumMeshes);\n  uint32_t indexOffset = 0;\n  uint32_t vertexOffset = 0;\n  for (unsigned int i = 0; i != scene->mNumMeshes; i++)\n    meshData.meshes.push_back(\n      convertAIMesh(scene->mMeshes[i], meshData,\n        indexOffset, vertexOffset));\n```", "```cpp\n recalculateBoundingBoxes(meshData);\n}\n```", "```cpp\nvoid saveMeshData(const char* fileName, const MeshData& m) {\n  FILE* f = fopen(fileName, “wb”);\n```", "```cpp\n const MeshFileHeader header = {\n    .magicValue    = 0x12345678,\n    .meshCount     = (uint32_t)m.meshes.size(),\n    .indexDataSize =\n      (uint32_t)(m.indexData.size() * sizeof(uint32_t)),\n    .vertexDataSize = (uint32_t)(m.vertexData.size()),\n  };\n```", "```cpp\n fwrite(&header, 1, sizeof(header), f);\n  fwrite(&m.streams, 1, sizeof(m.streams), f);\n  fwrite(m.meshes.data(), sizeof(Mesh), header.meshCount, f);\n  fwrite(m.boxes.data(), sizeof(BoundingBox), header.meshCount, f);\n```", "```cpp\n fwrite(m.indexData.data(), 1, header.indexDataSize, f);\n  fwrite(m.vertexData.data(), 1, header.vertexDataSize, f);\n  fclose(f);\n}\n```", "```cpp\nbool isMeshDataValid(const char* meshFile) {\n  FILE* f = fopen(meshFile, “rb”);\n  if (!f)  false;\n  SCOPE_EXIT { fclose(f); };\n  MeshFileHeader header;\n  if (fread(&header, 1, sizeof(header), f) != sizeof(header))\n    return false;\n  if (fseek(f, sizeof(Mesh) * header.meshCount, SEEK_CUR))\n    return false;\n  if (fseek(f, sizeof(BoundingBox) * header.meshCount, SEEK_CUR))\n    return false;\n  if (fseek(f, header.indexDataSize, SEEK_CUR))\n    return false;\n  if (fseek(f, header.vertexDataSize, SEEK_CUR))\n    return false;\n  return true;\n}\n```", "```cpp\nconst char* meshMeshes = “.cache/ch05_bistro.meshes”;\nint main() {\n  if (!isMeshDataValid(meshMeshes)) {\n    printf(“No cached mesh data found. Precaching...\\n\\n”);\n    MeshData meshData;\n    loadMeshFile(“deps/src/bistro/Exterior/exterior.obj”, meshData);\n    saveMeshData(meshMeshes, meshData);\n  }\n```", "```cpp\n MeshData meshData;\n  const MeshFileHeader header = loadMeshData(meshMeshes, meshData);\n```", "```cpp\nclass VKMesh final {\n  lvk::Holder<lvk::BufferHandle> bufferIndices_;\n  lvk::Holder<lvk::BufferHandle> bufferVertices_;\n  lvk::Holder<lvk::BufferHandle> bufferIndirect_;\n  lvk::Holder<lvk::ShaderModuleHandle> vert_;\n  lvk::Holder<lvk::ShaderModuleHandle> geom_;\n  lvk::Holder<lvk::ShaderModuleHandle> frag_;\n  lvk::Holder<lvk::RenderPipelineHandle> pipeline_;\n```", "```cpp\npublic:\n  uint32_t numIndices_ = 0;\n  VKMesh(const std::unique_ptr<lvk::IContext>& ctx,\n         const MeshFileHeader& header,\n         const MeshData& meshData,\n         lvk::Format depthFormat)\n  : numIndices_(header.indexDataSize / sizeof(uint32_t)) {\n    const uint32_t* indices = meshData.indexData.data();\n    const uint8_t* vertexData = meshData.vertexData.data();\n```", "```cpp\n bufferVertices_ = ctx->createBuffer({\n      .usage     = lvk::BufferUsageBits_Vertex,\n      .storage   = lvk::StorageType_Device,\n      .size      = header.vertexDataSize,\n      .data      = vertexData,\n      .debugName = “Buffer: vertex” }, nullptr);\n    bufferIndices_ = ctx->createBuffer({\n      .usage     = lvk::BufferUsageBits_Index,\n      .storage   = lvk::StorageType_Device,\n      .size      = header.indexDataSize,\n      .data      = indices,\n      .debugName = “Buffer: index” }, nullptr);\n```", "```cpp\n std::vector<uint8_t> drawCommands;\n    const uint32_t numCommands = header.meshCount;\n    drawCommands.resize(\n      sizeof(DrawIndexedIndirectCommand) * numCommands +\n        sizeof(uint32_t));\n```", "```cpp\n memcpy(drawCommands.data(), &numCommands, sizeof(numCommands));\n    DrawIndexedIndirectCommand* cmd = std::launder(\n      reinterpret_cast<DrawIndexedIndirectCommand*>(\n        drawCommands.data() + sizeof(uint32_t)));\n```", "```cpp\n for (uint32_t i = 0; i != numCommands; i++)\n      *cmd++ = {\n        .count         = meshData.meshes[i].getLODIndicesCount(0),\n        .instanceCount = 1,\n        .firstIndex    = meshData.meshes[i].indexOffset,\n        .baseVertex    = meshData.meshes[i].vertexOffset,\n        .baseInstance  = 0,\n      };\n```", "```cpp\n bufferIndirect_ = ctx->createBuffer({\n      .usage     = lvk::BufferUsageBits_Indirect,\n      .storage   = lvk::StorageType_Device,\n      .size      = sizeof(DrawIndexedIndirectCommand) *\n        numCommands + sizeof(uint32_t),\n      .data      = drawCommands.data(),\n      .debugName = “Buffer: indirect” }, nullptr);\n```", "```cpp\n vert_ = loadShaderModule(\n      ctx, “Chapter05/07_MeshRenderer/src/main.vert”);\n    geom_ = loadShaderModule(\n      ctx, “Chapter05/07_MeshRenderer/src/main.geom”);\n    frag_ = loadShaderModule(\n      ctx, “Chapter05/07_MeshRenderer/src/main.frag”);\n    pipeline_ = ctx->createRenderPipeline({\n      .vertexInput = meshData.streams,\n      .smVert      = vert_,\n      .smGeom      = geom_,\n      .smFrag      = frag_,\n      .color       = { { .format = ctx->getSwapchainFormat() } },\n      .depthFormat = depthFormat,\n      .cullMode    = lvk::CullMode_Back,\n    });\n  }\n```", "```cpp\n void draw(lvk::ICommandBuffer& buf, const MeshFileHeader& header) {\n    buf.cmdBindIndexBuffer(bufferIndices_, lvk::IndexFormat_UI32);\n    buf.cmdBindVertexBuffer(0, bufferVertices_);\n    buf.cmdBindRenderPipeline(pipeline_);\n    buf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                            .isDepthWriteEnabled = true });\n    buf.cmdDrawIndexedIndirect(\n      bufferIndirect_, sizeof(uint32_t), header.meshCount);\n  }\n};\n```", "```cpp\nMeshData meshData;\nconst MeshFileHeader header = loadMeshData(meshMeshes, meshData);\nconst VKMesh mesh(ctx, header, meshData, app.getDepthFormat());\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n};\nlayout (location=0) in vec3 in_pos;\nlayout (location=1) in vec2 in_tc;\nlayout (location=2) in vec3 in_normal;\nlayout (location=0) out vec2 uv;\nlayout (location=1) out vec3 normal;\nvoid main() {\n  gl_Position = MVP * vec4(in_pos, 1.0);\n  uv = in_tc;\n  normal = in_normal;\n};\n```", "```cpp\n#version 460 core\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices = 3) out;\nlayout(location=0) in vec2 uv[];\nlayout(location=1) in vec3 normal[];\nlayout(location=0) out vec2 uvs;\nlayout(location=1) out vec3 barycoords;\nlayout(location=2) out vec3 normals;\nvoid main() {\n  const vec3 bc[3] = vec3[](vec3(1.0, 0.0, 0.0),\n                            vec3(0.0, 1.0, 0.0),\n                            vec3(0.0, 0.0, 1.0) );\n  for ( int i = 0; i < 3; i++ ) {\n    gl_Position = gl_in[i].gl_Position;\n    uvs = uv[i];\n    barycoords = bc[i];\n    normals = normal[i];\n    EmitVertex();\n  }\n  EndPrimitive();\n}\n```", "```cpp\nlayout (location=0) in vec2 uvs;\nlayout (location=1) in vec3 barycoords;\nlayout (location=2) in vec3 normal;\nlayout (location=0) out vec4 out_FragColor;\nfloat edgeFactor(float thickness) {\n  vec3 a3 = smoothstep(\n    vec3( 0.0 ), fwidth(barycoords) * thickness, barycoords);\n  return min( min( a3.x, a3.y ), a3.z );\n}\nvoid main() {\n  float NdotL = clamp(dot(normalize(normal),\n                          normalize(vec3(-1,1,-1))), 0.5, 1.0);\n  vec4 color = vec4(1.0, 1.0, 1.0, 1.0) * NdotL;\n  out_FragColor = mix( vec4(0.1), color, edgeFactor(1.0) );\n};\n```", "```cpp\nbuf.cmdBeginRendering(renderPass, framebuffer);\nbuf.cmdPushConstants(mvp);\nmesh.draw(buf, header);\napp.drawGrid(buf, p, vec3(0, -0.0f, 0));\napp.imgui_->beginFrame(framebuffer);\napp.drawFPS();\napp.imgui_->endFrame(buf);\nbuf.cmdEndRendering();\n```", "```cpp\nlayout (local_size_x = 16, local_size_y = 16) in;\n```", "```cpp\nlayout (set = 0, binding = 2, rgba8)\n  uniform writeonly image2D kTextures2DOut[];\n```", "```cpp\nlayout(push_constant) uniform uPushConstant {\n  uint tex;\n  float time;\n} pc;\nvoid main() {\n  ivec2 dim = imageSize(kTextures2DOut[pc.tex]);\n```", "```cpp\n vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;\n```", "```cpp\n imageStore(kTextures2DOut[pc.tex],\n    ivec2(gl_GlobalInvocationID.xy), vec4(uv, 0.0, 1.0));\n}\n```", "```cpp\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n```", "```cpp\nvec4 mainImage(in vec2 fragCoord)\n```", "```cpp\nvoid main() {\n  ivec2 dim = imageSize(kTextures2DOut[pc.tex]);\n  vec4 c = vec4(0.0);\n  for (int dx = -2; dx != 3; dx++)\n    for (int dy = -2; dy != 3; dy++) {\n      vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim +\n                vec2(dx, dy) / (3.0 * dim);\n      c += mainImage(uv * dim);\n    }\n  imageStore(kTextures2DOut[pc.tex],\n    ivec2(gl_GlobalInvocationID.xy), c / 25.0);\n}\n```", "```cpp\nlayout(push_constant) uniform uPushConstant {\n  uint tex;\n  float time;\n} pc;\nvec2 iResolution = vec2( 1280.0, 720.0 );\nfloat iTime = pc.time;\n```", "```cpp\nlvk::Holder<lvk::TextureHandle> texture = ctx->createTexture({\n  .type       = lvk::TextureType_2D,\n  .format     = lvk::Format_RGBA_UN8,\n  .dimensions = {1024, 720},\n  .usage      = lvk::TextureUsageBits_Sampled |\n                lvk::TextureUsageBits_Storage,\n  .debugName  = “Texture: compute”,\n});\n```", "```cpp\nlvk::Holder<lvk::ShaderModuleHandle> comp = loadShaderModule(\n  ctx, “Chapter05/08_ComputeTexture/src/main.comp”);\nlvk::Holder<lvk::ComputePipelineHandle> pipelineComputeMatrices =\n  ctx->createComputePipeline({ smComp = comp });\nlvk::Holder<lvk::ShaderModuleHandle> vert = loadShaderModule(\n  ctx, “data/shaders/Quad.vert”);\nlvk::Holder<lvk::ShaderModuleHandle> frag = loadShaderModule(\n  ctx, “data/shaders/Quad.frag”);\nlvk::Holder<lvk::RenderPipelineHandle> pipelineFullScreenQuad =\n  ctx->createRenderPipeline({\n    .smVert = vert,\n    .smFrag = frag,\n    .color  = { { .format = ctx->getSwapchainFormat() } },\n});\n```", "```cpp\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nconst struct {\n  uint32_t textureId;\n  float time;\n} pc {\n  .textureId = texture.index(),\n  .time      = (float)glfwGetTime(),\n};\nbuf.cmdPushConstants(pc);\nbuf.cmdBindComputePipeline(pipelineComputeMatrices);\nbuf.cmdDispatchThreadGroups(\n  { .width = 1024 / 16, .height = 720 / 16 });\n```", "```cpp\nbuf.cmdBeginRendering(renderPass, framebuffer,\n  { .textures = { { lvk::TextureHandle(texture) } } });\nbuf.cmdBindRenderPipeline(pipelineFullScreenQuad);\nbuf.cmdDraw(3);\nbuf.cmdEndRendering();\nctx->submit(buf, ctx->getCurrentSwapchainTexture());\n```", "```cpp\nstd::deque<std::pair<uint32_t, uint32_t>> morphQueue =\n  { { 5, 8 }, { 5, 8 } };\nfloat morphCoef = 0.0f;\nfloat animationSpeed = 1.0f;\nbool g_UseColoredMesh = false;\n```", "```cpp\nconstexpr uint32_t kNumU = 1024;\nconstexpr uint32_t kNumV = 1024;\n```", "```cpp\nvoid generateIndices(uint32_t* indices) {\n  for (uint32_t j = 0; j < kNumV - 1; j++) {\n    for (uint32_t i = 0; i < kNumU - 1; i++) {\n      uint32_t ofs = (j * (kNumU - 1) + i) * 6;\n      uint32_t i1 = (j + 0) * kNumU + (i + 0);\n      uint32_t i2 = (j + 0) * kNumU + (i + 1);\n      uint32_t i3 = (j + 1) * kNumU + (i + 1);\n      uint32_t i4 = (j + 1) * kNumU + (i + 0);\n      indices[ofs + 0] = i1;\n      indices[ofs + 1] = i2;\n      indices[ofs + 2] = i4;\n      indices[ofs + 3] = i2;\n      indices[ofs + 4] = i3;\n      indices[ofs + 5] = i4;\n    }\n  }\n}\n```", "```cpp\nvoid renderGUI(lvk::TextureHandle texture) {\n  static const std::vector<std::pair<uint32_t, uint32_t>> PQ = {\n    {1, 1}, {2, 3}, {2, 5}, {2, 7}, {3, 4},\n    {2, 9}, {3, 5}, {5, 8}, {8, 9} };\n  ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_Appearing);\n  ImGui::Begin(“Torus Knot params”, nullptr,\n    ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoCollapse);\n```", "```cpp\n ImGui::Checkbox(“Use colored mesh”, &g_UseColoredMesh);\n  ImGui::SliderFloat(\n    “Morph animation speed”, &g_AnimationSpeed, 0.0f, 2.0f);\n```", "```cpp\n for (size_t i = 0; i != PQ.size(); i++) {\n    const std::string title = std::to_string(PQ[i].first) + “, “ +\n      std::to_string(PQ[i].second);\n    if (ImGui::Button(title.c_str(), ImVec2(128, 0))) {\n      if (PQ[i] != g_MorphQueue.back())\n        g_MorphQueue.push_back(PQ[i]);\n    }\n  }\n```", "```cpp\n ImGui::Text(“Morph queue:”);\n  for (size_t i = 0; i != g_MorphQueue.size(); i++) {\n    const bool isLastElement = (i + 1) == g_MorphQueue.size();\n    ImGui::Text(“  P = %u, Q = %u %s”, g_MorphQueue[i].first,\n      g_MorphQueue[i].second, isLastElement ? “<---” : ““);\n  }\n  ImGui::End();\n```", "```cpp\n if (!g_UseColoredMesh) {\n    const ImVec2 size = ImGui::GetIO().DisplaySize;\n    const float  dim  = std::max(size.x, size.y);\n    const ImVec2 sizeImg(0.25f * dim, 0.25f * dim);\n    ImGui::SetNextWindowPos(ImVec2(size.x - sizeImg.x - 25, 0),\n      ImGuiCond_Appearing);\n    ImGui::Begin(“Texture”, nullptr,\n      ImGuiWindowFlags_AlwaysAutoResize);\n    ImGui::Image(texture.indexAsVoid(), sizeImg);\n    ImGui::End();\n  }\n};\n```", "```cpp\nstd::vector<uint32_t> indicesGen((kNumU - 1) * (kNumV - 1) * 6);\ngenerateIndices(indicesGen.data());\nconst uint32_t vertexBufferSize = 12 * sizeof(float) * kNumU * kNumV;\nconst uint32_t indexBufferSize  =\n  sizeof(uint32_t) * (kNumU - 1) * (kNumV - 1) * 6;\nlvk::Holder<lvk::BufferHandle> bufferIndex  = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Index,\n  .storage   = lvk::StorageType_Device,\n  .size      = indicesGen.size() * sizeof(uint32_t),\n  .data      = indicesGen.data(),\n  .debugName = “Buffer: index” });\n```", "```cpp\nlvk::Holder<lvk::TextureHandle> texture = ctx->createTexture({\n  .type       = lvk::TextureType_2D,\n  .format     = lvk::Format_RGBA_UN8,\n  .dimensions = {1024, 1024},\n  .usage      = lvk::TextureUsageBits_Sampled |\n                lvk::TextureUsageBits_Storage,\n  .debugName  = “Texture: compute” });\n```", "```cpp\nlvk::Holder<lvk::BufferHandle> bufferVertex = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Vertex |\n               lvk::BufferUsageBits_Storage,\n  .storage   = lvk::StorageType_Device,\n  .size      = vertexBufferSize,\n  .debugName = “Buffer: vertex” });\n```", "```cpp\nlvk::Holder<lvk::ShaderModuleHandle> compMesh = loadShaderModule(ctx,\n  “Chapter05/09_ComputeMesh/src/main_mesh.comp”);\nlvk::Holder<lvk::ShaderModuleHandle> compTexture =\n  loadShaderModule(ctx,\n  “Chapter05/09_ComputeMesh/src/main_texture.comp”);\nlvk::Holder<lvk::ComputePipelineHandle> pipelineComputeMesh =\n  ctx->createComputePipeline({ .smComp = compMesh });\nlvk::Holder<lvk::ComputePipelineHandle> pipelineComputeTexture =\n  ctx->createComputePipeline({ .smComp = compTexture });\n```", "```cpp\nlvk::Holder<lvk::ShaderModuleHandle> vert =\n  loadShaderModule(ctx, “Chapter05/09_ComputeMesh/src/main.vert”);\nlvk::Holder<lvk::ShaderModuleHandle> geom =\n  loadShaderModule(ctx, “Chapter05/09_ComputeMesh/src/main.geom”);\nlvk::Holder<lvk::ShaderModuleHandle> frag =\n  loadShaderModule(ctx, “Chapter05/09_ComputeMesh/src/main.frag”);\n```", "```cpp\nconst lvk::VertexInput vdesc = {\n  .attributes  = { { .location = 0,\n                     .format = VertexFormat::Float4,\n                     .offset = 0 },\n                   { .location = 1,\n                     .format = VertexFormat::Float4,\n                     .offset = sizeof(vec4) },\n                   { .location = 2,\n                     .format = VertexFormat::Float4,\n                     .offset = sizeof(vec4)+sizeof(vec4) } },\n  .inputBindings = { { .stride = 3 * sizeof(vec4) },\n};\n```", "```cpp\nconst uint32_t specColored = 1;\nconst uint32_t specNotColored = 0;\nlvk::Holder<lvk::RenderPipelineHandle> pipelineMeshColored =\n  ctx->createRenderPipeline({\n    .vertexInput = vdesc,\n    .smVert      = vert,\n    .smGeom      = geom,\n    .smFrag      = frag,\n    .specInfo    = { .entries = { { .constantId = 0,\n                                    .size = sizeof(uint32_t) } },\n                     .data = &specColored,\n                     .dataSize = sizeof(specColored) },\n    .color       = { { .format = ctx->getSwapchainFormat() } },\n    .depthFormat = app.getDepthFormat() });\nlvk::Holder<lvk::RenderPipelineHandle> pipelineMeshTextured =\n  ctx->createRenderPipeline({\n    .vertexInput = vdesc,\n    .smVert      = vert,\n    .smGeom      = geom,\n    .smFrag      = frag,\n    .specInfo    = { .entries = { { .constantId = 0,\n                                    .size = sizeof(uint32_t) } },\n                     .data = &specNotColored,\n                     .dataSize = sizeof(specNotColored) },\n    .color       = { { .format = ctx->getSwapchainFormat() } },\n    .depthFormat = app.getDepthFormat() });\n```", "```cpp\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nconst mat4 m = glm::translate(mat4(1.0f), vec3(0.0f, 0.0f, -18.f));\nconst mat4 p = glm::perspective(45.0f, aspectRatio, 0.1f, 1000.0f);\nauto iter = g_MorphQueue.begin();\n```", "```cpp\nstruct PerFrame {\n  mat4 mvp;\n  uint64_t buffer;\n  uint32_t textureId;\n  float time;\n  uint32_t numU, numV;\n  float minU, maxU;\n  float minV, maxV;\n  uint32_t p1, p2;\n  uint32_t q1, q2;\n  float morph;\n} pc = {\n  .mvp       = p * m,\n  .buffer    = ctx->gpuAddress(bufferVertex),\n  .textureId = texture.index(),\n  .time      = (float)glfwGetTime(),\n  .numU      = kNumU,\n  .numV      = kNumU,\n  .minU      = -1.0f,\n  .maxU      = +1.0f,\n  .minV      = -1.0f,\n  .maxV      = +1.0f,\n  .p1        = iter->first,\n  .p2        = (iter + 1)->first,\n  .q1        = iter->second,\n  .q2        = (iter + 1)->second,\n  .morph     = easing(g_MorphCoef),\n};\nbuf.cmdPushConstants(pc);\n```", "```cpp\nbuf.cmdBindComputePipeline(pipelineComputeMesh);\nbuf.cmdDispatchThreadGroups(\n  { .width = (kNumU * kNumV) / 2 },\n  { .buffers = { { lvk::BufferHandle(bufferVertex) } } });\n```", "```cpp\nif (!g_UseColoredMesh) {\n  buf.cmdBindComputePipeline(pipelineComputeTexture);\n  buf.cmdDispatchThreadGroups(\n    { .width = 1024 / 16, .height = 1024 / 16 },\n    { .textures = { { lvk::TextureHandle(texture) } } });\n}\n```", "```cpp\nbuf.cmdBeginRendering(\n  renderPass, framebuffer,\n  { .textures = { { lvk::TextureHandle(texture) } },\n    .buffers  = { { lvk::BufferHandle(bufferVertex) } } });\nbuf.cmdBindRenderPipeline(\n  g_UseColoredMesh ? pipelineMeshColored : pipelineMeshTextured);\nbuf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true });\nbuf.cmdBindVertexBuffer(0, bufferVertex);\nbuf.cmdBindIndexBuffer(bufferIndex, lvk::IndexFormat_UI32);\nbuf.cmdDrawIndexed(indicesGen.size());\napp.imgui_->beginFrame(framebuffer);\n```", "```cpp\nrenderGUI(texture);\napp.drawFPS();\napp.imgui_->endFrame(buf);\nbuf.cmdEndRendering();\n```", "```cpp\nlayout (local_size_x = 2, local_size_y = 1, local_size_z = 1) in;\n// included from <Chapter05/09_ComputeMesh/src/common.sp>\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n  uvec2 bufferId;\n  uint textureId;\n  float time;\n  uint numU, numV;\n  float minU, maxU, minV, maxV;\n  uint P1, P2, Q1, Q2;\n  float morph;\n} pc;\n```", "```cpp\nstruct VertexData {\n  vec4 pos;\n  vec4 tc;\n  vec4 norm;\n};\nlayout (buffer_reference) buffer VertexBuffer {\n  VertexData vertices[];\n} vbo;\n```", "```cpp\nx = r * cos(u)\ny = r * sin(u)\nz = -sin(v)\n```", "```cpp\nVertexData torusKnot(vec2 uv, float p, float q) {\n  const float baseRadius    = 5.0;\n  const float segmentRadius = 3.0;\n  const float tubeRadius    = 0.5;\n  float ct = cos( uv.x );\n  float st = sin( uv.x );\n  float qp = q / p;\n  float qps = qp * segmentRadius;\n  float arg = uv.x * qp;\n  float sqp = sin( arg );\n  float cqp = cos( arg );\n  float BSQP = baseRadius + segmentRadius * cqp;\n  float dxdt = -qps * sqp * ct - st * BSQP;\n  float dydt = -qps * sqp * st + ct * BSQP;\n  float dzdt =  qps * cqp;\n  vec3 r    = vec3(BSQP * ct, BSQP * st, segmentRadius * sqp);\n  vec3 drdt = vec3(dxdt, dydt, dzdt);\n  vec3 v1 = normalize(cross(r, drdt));\n  vec3 v2 = normalize(cross(v1, drdt));\n  float cv = cos( uv.y );\n  float sv = sin( uv.y );\n  VertexData res;\n  res.pos  = vec4(r + tubeRadius * ( v1 * sv + v2 * cv ), 1);\n  res.norm = vec4(cross(v1 * cv - v2 * sv, drdt ), 0);\n  return res;\n}\n```", "```cpp\nmat3 rotY(float angle) {\n  float c = cos(angle), s = sin(angle);\n  return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle), s = sin(angle);\n  return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n```", "```cpp\nvoid main() {\n  uint index = gl_GlobalInvocationID.x;\n  vec2 numUV = vec2(pc.numU, pc.numV);\n  vec2 ij = vec2(float(index / pc.numV), float(index % pc.numV));\n```", "```cpp\n const vec2 maxUV1 = 2.0 * 3.141592653 * vec2(pc.P1, 1.0);\n  vec2 uv1 = ij * maxUV1 / (numUV - vec2(1));\n  const vec2 maxUV2 = 2.0 * 3.141592653 * vec2(pc.P2, 1.0);\n  vec2 uv2 = ij * maxUV2 / (numUV - vec2(1));\n```", "```cpp\n mat3 modelMatrix = rotY(0.5 * pc.time) * rotZ(0.5 * pc.time);\n```", "```cpp\n VertexData v1 = torusKnot(uv1, pc.P1, pc.Q1);\n  VertexData v2 = torusKnot(uv2, pc.P2, pc.Q2);\n```", "```cpp\n vec3 pos = mix(v1.pos.xyz, v2.pos.xyz, pc.morph);\n  vec3 norm = mix(v1.norm.xyz, v2.norm.xyz, pc.morph);\n```", "```cpp\n VertexData vtx;\n  vtx.pos  = vec4(modelMatrix * pos, 1);\n  vtx.tc   = vec4(ij / numUV, 0, 0);\n  vtx.norm = vec4(modelMatrix * norm, 0);\n  VertexBuffer(pc.bufferId).vertices[index] = vtx;\n}\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n};\nlayout (location=0) in vec4 in_pos;\nlayout (location=1) in vec2 in_uv;\nlayout (location=2) in vec3 in_normal;\nlayout (location=0) out vec2 uv;\nlayout (location=1) out vec3 normal;\nvoid main() {\n  gl_Position = MVP * in_pos;\n  uv = in_uv;\n  normal = in_normal;\n}\n```", "```cpp\n#include <Chapter05/09_ComputeMesh/src/common.sp>\nlayout (location=0) in vec2 uv;\nlayout (location=1) in vec3 normal;\nlayout (location=2) in vec3 barycoords;\nlayout (location=0) out vec4 out_FragColor;\nlayout (constant_id = 0) const bool isColored = false;\n```", "```cpp\nfloat edgeFactor(float thickness) {\n  vec3 a3 = smoothstep( vec3( 0.0 ),\n    fwidth(barycoords) * thickness, barycoords);\n  return min( min( a3.x, a3.y ), a3.z );\n}\n```", "```cpp\nvec3 hue2rgb(float hue) {\n  float h = fract(hue);\n  float r = abs(h * 6 - 3) - 1;\n  float g = 2 - abs(h * 6 - 2);\n  float b = 2 - abs(h * 6 - 4);\n  return clamp(vec3(r,g,b), vec3(0), vec3(1));\n}\nvoid main() {\n  float NdotL = dot(normalize(normal), normalize(vec3(0, 0, +1)));\n  float intensity = 1.0 * clamp(NdotL, 0.75, 1);\n  vec3 color = isColored ?\n    intensity * hue2rgb(uv.x) :\n    textureBindless2D(pc.textureId, 0, vec2(8,1) * uv).xyz;\n  out_FragColor = vec4(color, 1.0);\n```", "```cpp\n if (isColored && pc.numU <= 64 && pc.numV <= 64)\n    out_FragColor =\n      vec4( mix( vec3(0.0), color, edgeFactor(1.0) ), 1.0 );\n}\n```"]