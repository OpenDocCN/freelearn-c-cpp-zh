<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer025">&#13;
			<h1 id="_idParaDest-128" class="chapter-number"><a id="_idTextAnchor132"/>8</h1>&#13;
			<h1 id="_idParaDest-129"><a id="_idTextAnchor133"/>The TableGen Language</h1>&#13;
			<p>Large parts of backends in LLVM are written in the TableGen language, a special language used to<a id="_idIndexMarker457"/> generate fragments of C++ source code to avoid implementing code similar for each backend and to shorten the amount of source code. Having knowledge of TableGen is <span class="No-Break">therefore important.</span></p>&#13;
			<p>In this chapter, you will learn <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>In <em class="italic">Understanding the TableGen language</em>, you will learn about the main idea <span class="No-Break">behind TableGen</span></li>&#13;
				<li>In <em class="italic">Experimenting with the TableGen language</em>, you will define your own TableGen classes and records, and learn the syntax of the <span class="No-Break">TableGen language</span></li>&#13;
				<li>In <em class="italic">Generating C++ code from a TableGen file</em>, you will develop your own <span class="No-Break">TableGen backend</span></li>&#13;
				<li>Drawbacks <span class="No-Break">of TableGen</span></li>&#13;
			</ul>&#13;
			<p>By the end of the chapter, you will be able to use existing TableGen classes to define your own records. You will also acquire knowledge of how to create TableGen classes and records from scratch, and how to develop a TableGen backend to emit <span class="No-Break">source code.</span></p>&#13;
			<h1 id="_idParaDest-130"><a id="_idTextAnchor134"/>Technical requirements</h1>&#13;
			<p>You can find the source code used in this chapter on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-131"><a id="_idTextAnchor135"/>Understanding the TableGen language</h1>&#13;
			<p>LLVM comes <a id="_idIndexMarker458"/>with its own <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) called <strong class="bold">TableGen</strong>. It is<a id="_idIndexMarker459"/> used to generate C++ code for a wide range of use cases, thus reducing the amount of code a developer has to produce. The TableGen language is not a full-fledged programming language. It is only used to define records, which is a fancy word for a collection of names and values. To understand why such a restricted language is useful, let’s examine <span class="No-Break">two examples.</span></p>&#13;
			<p>Typical data you need to define one machine instruction of a <span class="No-Break">CPU is:</span></p>&#13;
			<ul>&#13;
				<li>The mnemonic of <span class="No-Break">the instruction</span></li>&#13;
				<li>The <span class="No-Break">bit pattern</span></li>&#13;
				<li>The number and types <span class="No-Break">of operands</span></li>&#13;
				<li>Possible restrictions or <span class="No-Break">side effects</span></li>&#13;
			</ul>&#13;
			<p>It is easy to see that<a id="_idIndexMarker460"/> this data can be represented as a record. For example, a field named <strong class="source-inline">asmstring</strong> could hold the value of the mnemonic; say, <strong class="source-inline">"add"</strong>. Also, a field named <strong class="source-inline">opcode</strong> could hold the binary representation of the instruction. Together, the record would describe an additional instruction. Each LLVM backend describes the instruction set in <span class="No-Break">this way.</span></p>&#13;
			<p>Records are such a general concept that you can describe a wide variety of data with them. Another example is the definition of command-line options. A <span class="No-Break">command-line option:</span></p>&#13;
			<ul>&#13;
				<li>Has <span class="No-Break">a name</span></li>&#13;
				<li>May have an <span class="No-Break">optional argument</span></li>&#13;
				<li>Has a <span class="No-Break">help text</span></li>&#13;
				<li>May belong to a group <span class="No-Break">of options</span></li>&#13;
			</ul>&#13;
			<p>Again, this data can be easily seen as a record. Clang uses this approach for the command-line options of the <span class="No-Break">Clang driver.</span></p>&#13;
			<p class="callout-heading">The TableGen language</p>&#13;
			<p class="callout">In LLVM, the TableGen language is used for a variety of tasks. Large parts of a backend are written in the TableGen language; for example, the definition of a register file, all instructions with mnemonic and binary encoding, calling conventions, patterns for instruction selection, and scheduling models for instruction scheduling. Other uses of LLVM are the definition of intrinsic functions, the definition of attributes, and the definition of <span class="No-Break">command-line options.</span></p>&#13;
			<p class="callout">You’ll find the <em class="italic">Programmer’s Reference</em> at <a href="https://llvm.org/docs/TableGen/ProgRef.html">https://llvm.org/docs/TableGen/ProgRef.html</a> and the <em class="italic">Backend Developer’s Guide</em> <span class="No-Break">at </span><a href="https://llvm.org/docs/TableGen/BackGuide.html"><span class="No-Break">https://llvm.org/docs/TableGen/BackGuide.html</span></a><span class="No-Break">.</span></p>&#13;
			<p>To achieve this<a id="_idIndexMarker461"/> flexibility, the parsing and the semantics of the TableGen language are implemented in a library. To generate C++ code from the records, you need to create a tool that takes the parsed records and generates C++ code from it. In LLVM, that tool is called <strong class="source-inline">llvm-tblgen</strong>, and in Clang, it is called <strong class="source-inline">clang-tblgen</strong>. Those tools contain the code generators required by the project. But they can also be used to learn more about the TableGen language, which is what we’ll do in the <span class="No-Break">next section.</span></p>&#13;
			<h1 id="_idParaDest-132"><a id="_idTextAnchor136"/>Experimenting with the TableGen language</h1>&#13;
			<p>Very <a id="_idIndexMarker462"/>often, beginners feel overwhelmed by the TableGen language. But as soon as you start experimenting with the language, it becomes <span class="No-Break">much easier.</span></p>&#13;
			<h2 id="_idParaDest-133"><a id="_idTextAnchor137"/>Defining records and classes</h2>&#13;
			<p>Let’s <a id="_idIndexMarker463"/>define a simple record for <span class="No-Break">an instruction:</span></p>&#13;
			<pre class="source-code">&#13;
def ADD {&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 0xA0;&#13;
}</pre>			<p>The <strong class="source-inline">def</strong> keyword <a id="_idIndexMarker464"/>signals that you define a record. It is followed by the name of the record. The record body is surrounded by curly braces, and the body consists of field definitions, similar to a structure <span class="No-Break">in C++.</span></p>&#13;
			<p>You can use the <strong class="source-inline">llvm-tblgen</strong> tool to see the generated records. Save the preceding source code in an <strong class="source-inline">inst.td</strong> file and run <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-tblgen --print-records inst.td&#13;
------------- Classes -----------------&#13;
------------- Defs -----------------&#13;
def ADD {&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 160;&#13;
}</pre>			<p>This is not yet exciting; it only shows the defined record was <span class="No-Break">parsed correctly.</span></p>&#13;
			<p>Defining <a id="_idIndexMarker465"/>instructions using single records is not very comfortable. A modern CPU has hundreds of instructions, and with this amount of records, it is <a id="_idIndexMarker466"/>very easy to introduce typing errors in the field names. And if you decide to rename a field or add a new field, then the number of records to change becomes a challenge. Therefore, a blueprint is needed. In C++, classes have a similar purpose, and in TableGen, it is also <a id="_idIndexMarker467"/>called a <strong class="bold">class</strong>. Here is the definition of an <strong class="source-inline">Inst</strong> class and two records based on <span class="No-Break">that class:</span></p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
}&#13;
def ADD : Inst&lt;"add", 0xA0&gt;;&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;</pre>			<p>The syntax for classes is similar to that of records. The <strong class="source-inline">class</strong> keyword signals that a class is defined, followed by the name of the class. A class can have a parameter list. Here, the <strong class="source-inline">Inst</strong> class has two parameters, <strong class="source-inline">mnemonic</strong> and <strong class="source-inline">opcode</strong>, which are used to initialize the records’ fields. The values for those fields are given when the class is instantiated. The <strong class="source-inline">ADD</strong> and <strong class="source-inline">SUB</strong> records show two instantiations of the class. Again, let’s use <strong class="source-inline">llvm-tblgen</strong> to look at <span class="No-Break">the records:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-tblgen --print-records inst.td&#13;
------------- Classes -----------------&#13;
class Inst&lt;string Inst:mnemonic = ?, int Inst:opcode = ?&gt; {&#13;
  string Mnemonic = Inst:mnemonic;&#13;
  int Opcode = Inst:opcode;&#13;
}&#13;
------------- Defs -----------------&#13;
def ADD {       // Inst&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 160;&#13;
}&#13;
def SUB {       // Inst&#13;
  string Mnemonic = "sub";&#13;
  int Opcode = 176;&#13;
}</pre>			<p>Now, you <a id="_idIndexMarker468"/>have one class definition and two records. The name<a id="_idIndexMarker469"/> of the class used to define the records is shown as a comment. Please note that the arguments of the class have the default value <strong class="source-inline">?</strong>, which indicates <strong class="source-inline">int</strong> <span class="No-Break">is uninitialized.</span></p>&#13;
			<p class="callout-heading">Tip for debugging</p>&#13;
			<p class="callout">To get a more detailed dump of the records, you can use the <strong class="source-inline">–-print-detailed-records</strong> option. The output includes the line numbers of record and class definitions, and where record fields are initialized. They can be very helpful if you try to track down why a record field was assigned a <span class="No-Break">certain value.</span></p>&#13;
			<p>In general, the <strong class="source-inline">ADD</strong> and <strong class="source-inline">SUB</strong> instructions have a lot in common, but there is also a difference: addition is a commutative operation but subtraction is not. Let’s capture that fact in the record, too. A small challenge is that TableGen only supports a limited set of data types. You already used <strong class="source-inline">string</strong> and <strong class="source-inline">int</strong> in the examples. The other available data types are <strong class="source-inline">bit</strong>, <strong class="source-inline">bits&lt;n&gt;</strong>, <strong class="source-inline">list&lt;type&gt;</strong>, and <strong class="source-inline">dag</strong>. The <strong class="source-inline">bit</strong> type represents a single bit; that is, <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong>. If you need a fixed number of bits, then you use the <strong class="source-inline">bits&lt;n&gt;</strong> type. For example, <strong class="source-inline">bits&lt;5&gt;</strong> is an integer type 5 bits wide. To define a list based on another type, you use the <strong class="source-inline">list&lt;type&gt;</strong> type. For example, <strong class="source-inline">list&lt;int&gt;</strong> is a list of integers, and <strong class="source-inline">list&lt;Inst&gt;</strong> is a list of records of the <strong class="source-inline">Inst</strong> class from the example. The <strong class="source-inline">dag</strong> type <a id="_idIndexMarker470"/>represents <strong class="bold">directed acyclic graph</strong> (<strong class="bold">DAG</strong>) nodes. This type is useful for defining patterns and operations and is used extensively in <span class="No-Break">LLVM backends.</span></p>&#13;
			<p>To represent a<a id="_idIndexMarker471"/> flag, a single bit is sufficient, so you can use<a id="_idIndexMarker472"/> one to mark an instruction as commutable. The majority of instructions are not commutable, so you can take advantage of <span class="No-Break">default values:</span></p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode, bit commutable = 0&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
  bit Commutable = commutable;&#13;
}&#13;
def ADD : Inst&lt;"add", 0xA0, 1&gt;;&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;</pre>			<p>You should run <strong class="source-inline">llvm-tblgen</strong> to verify that the records are defined <span class="No-Break">as expected.</span></p>&#13;
			<p>There is no requirement for a class to have parameters. It is also possible to assign values later. For example, you can define that all instructions are <span class="No-Break">not commutable:</span></p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
  bit Commutable = 0;&#13;
}&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;</pre>			<p>Using a <strong class="source-inline">let</strong> statement, you can overwrite <span class="No-Break">that value:</span></p>&#13;
			<pre class="source-code">&#13;
let Commutable = 1 in&#13;
  def ADD : Inst&lt;"add", 0xA0&gt;;</pre>			<p>Alternatively, you can open a record body to overwrite <span class="No-Break">the value:</span></p>&#13;
			<pre class="source-code">&#13;
def ADD : Inst&lt;"add", 0xA0&gt; {&#13;
  let Commutable = 1;&#13;
}</pre>			<p>Again, please use <strong class="source-inline">llvm-tblgen</strong> to verify that the <strong class="source-inline">Commutable</strong> flag is set to <strong class="source-inline">1</strong> in <span class="No-Break">both cases.</span></p>&#13;
			<p>Classes <a id="_idIndexMarker473"/>and records can be inherited from multiple classes, and<a id="_idIndexMarker474"/> it is always possible to add new fields or overwrite the value of existing fields. You can use inheritance to introduce a new <span class="No-Break"><strong class="source-inline">CommutableInst</strong></span><span class="No-Break"> class:</span></p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
  bit Commutable = 0;&#13;
}&#13;
class CommutableInst&lt;string mnemonic, int opcode&gt;&#13;
  : Inst&lt;mnemonic, opcode&gt; {&#13;
  let Commutable = 1;&#13;
}&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;&#13;
def ADD : CommutableInst&lt;"add", 0xA0&gt;;</pre>			<p>The resulting records are always the same, but the language allows you to define records in different <a id="_idIndexMarker475"/>ways. Please note that, in the latter example, the <strong class="source-inline">Commutable</strong> flag may be superfluous: the <a id="_idIndexMarker476"/>code generator can query a record for the classes it is based on, and if that list contains the <strong class="source-inline">CommutableInst</strong> class, then it can set the <span class="No-Break">flag internally.</span></p>&#13;
			<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Creating multiple records at once with multiclasses</h2>&#13;
			<p>Another <a id="_idIndexMarker477"/>often-used statement is <strong class="source-inline">multiclass</strong>. A multiclass allows you to define multiple records at once. Let’s expand the example to show why this can <span class="No-Break">be useful.</span></p>&#13;
			<p>The definition of an <strong class="source-inline">add</strong> instruction is very simplistic. In reality, a CPU often has several <strong class="source-inline">add</strong> instructions. A common variant is that one instruction has two register operands while another instruction has one register operand and an immediate operand, which is a small number. Assume that for the instruction having an immediate operand, the designer of the instruction set decided to mark them with <strong class="source-inline">i</strong> as a suffix. So, we end up with the <strong class="source-inline">add</strong> and <strong class="source-inline">addi</strong> instructions. Further, assume that the opcodes differ by <strong class="source-inline">1</strong>. Many arithmetic and logical instructions follow this scheme; therefore, you want the definition to be as compact <span class="No-Break">as possible.</span></p>&#13;
			<p>The first challenge is that you need to manipulate values. There is a limited number of operators that you can use to modify a value. For example, to produce the sum of <strong class="source-inline">1</strong> and the value of the field opcode, <span class="No-Break">you write:</span></p>&#13;
			<pre class="source-code">&#13;
!add(opcode, 1)</pre>			<p>Such an expression is best used as an argument for a class. Testing a field value and then changing it based on the found value is generally not possible because it requires dynamic statements that are not available. Always remember that all calculations are done while the records <span class="No-Break">are constructed!</span></p>&#13;
			<p>In a similar way, strings can <span class="No-Break">be concatenated:</span></p>&#13;
			<pre class="source-code">&#13;
!strconcat(mnemonic,"i")</pre>			<p>Because all operators begin with an <a id="_idIndexMarker478"/>exclamation mark (<strong class="source-inline">!</strong>), they are also called <strong class="bold">bang operators</strong>. You find a full list of bang operators in the <em class="italic">Programmer’s </em><span class="No-Break"><em class="italic">Reference</em></span><span class="No-Break">: </span><a href="https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators"><span class="No-Break">https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators</span></a><span class="No-Break">.</span></p>&#13;
			<p>Now, you can define a multiclass. The <strong class="source-inline">Inst</strong> class serves again as <span class="No-Break">the base:</span></p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
}</pre>			<p>The<a id="_idIndexMarker479"/> definition of a multiclass is a bit more involved, so let’s do it <span class="No-Break">in steps:</span></p>&#13;
			<ol>&#13;
				<li>The definition of a multiclass uses a similar syntax to classes. The new multiclass is named <strong class="source-inline">InstWithImm</strong> and has two parameters, <strong class="source-inline">mnemonic</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">opcode</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
multiclass InstWithImm&lt;string mnemonic, int opcode&gt; {</pre></li>				<li>First, you define an instruction with two register operands. As in a normal record definition, you use the <strong class="source-inline">def</strong> keyword to define the record, and you use the <strong class="source-inline">Inst</strong> class to create the record content. You also need to define an empty name. We will explain later why this <span class="No-Break">is necessary:</span><pre class="source-code">&#13;
  def "": Inst&lt;mnemonic, opcode&gt;;</pre></li>				<li>Next, you define an instruction with the immediate operand. You derive the values for the mnemonic and the opcode from the parameters of the multiclass, using bang operators. The record is <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">I</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
  def I: Inst&lt;!strconcat(mnemonic,"i"), !add(opcode, 1)&gt;;</pre></li>				<li>That is all; the class body can be closed, <span class="No-Break">like so:</span><pre class="source-code">&#13;
}</pre></li>			</ol>&#13;
			<p>To instantiate the records, you must use the <span class="No-Break"><strong class="source-inline">defm</strong></span><span class="No-Break"> keyword:</span></p>&#13;
			<pre class="source-code">&#13;
defm ADD : InstWithImm&lt;"add", 0xA0&gt;;</pre>			<p>These statements result in <span class="No-Break">the following:</span></p>&#13;
			<ol>&#13;
				<li>The <strong class="source-inline">Inst&lt;"add", 0xA0&gt;</strong> record is instantiated. The name of the record is the concatenation of the name following the <strong class="source-inline">defm</strong> keyword and of the name following <strong class="source-inline">def</strong> inside the multiclass statement, which results in the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">ADD</strong></span><span class="No-Break">.</span></li>&#13;
				<li>The <strong class="source-inline">Inst&lt;"addi", 0xA1&gt;</strong> record is instantiated and, following the same scheme, is given the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">ADDI</strong></span><span class="No-Break">.</span></li>&#13;
			</ol>&#13;
			<p>Let’s verify<a id="_idIndexMarker480"/> this claim <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">llvm-tblgen</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-tblgen –print-records inst.td&#13;
------------- Classes -----------------&#13;
class Inst&lt;string Inst:mnemonic = ?, int Inst:opcode = ?&gt; {&#13;
  string Mnemonic = Inst:mnemonic;&#13;
  int Opcode = Inst:opcode;&#13;
}&#13;
------------- Defs -----------------&#13;
def ADD {       // Inst&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 160;&#13;
}&#13;
def ADDI {      // Inst&#13;
  string Mnemonic = "addi";&#13;
  int Opcode = 161;&#13;
}</pre>			<p>Using a multiclass, it is very easy to generate multiple records at once. This feature is used <span class="No-Break">very often!</span></p>&#13;
			<p>A record does not need to have a name. Anonymous records are perfectly fine. Omitting the name is all you need to do to define an anonymous record. The name of a record generated<a id="_idIndexMarker481"/> by a multiclass is made up of two names, and both names must be given to create a named record. If you omit the name after <strong class="source-inline">defm</strong>, then only anonymous records are created. Similarly, if the <strong class="source-inline">def</strong> inside the multiclass is not followed by a name, an anonymous record is created. This is the reason why the first definition in the multiclass example used the empty name <strong class="source-inline">""</strong>: without it, the record would <span class="No-Break">be anonymous.</span></p>&#13;
			<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Simulating function calls</h2>&#13;
			<p>In some cases, using <a id="_idIndexMarker482"/>a multiclass like in the previous example can lead to repetitions. Assume that the CPU also supports memory operands, in a way similar to immediate operands. You can support this by adding a new record definition to <span class="No-Break">the multiclass:</span></p>&#13;
			<pre class="source-code">&#13;
multiclass InstWithOps&lt;string mnemonic, int opcode&gt; {&#13;
  def "": Inst&lt;mnemonic, opcode&gt;;&#13;
  def "I": Inst&lt;!strconcat(mnemonic,"i"), !add(opcode, 1)&gt;;&#13;
  def "M": Inst&lt;!strconcat(mnemonic,"m"), !add(opcode, 2)&gt;;&#13;
}</pre>			<p>This is perfectly fine. But now, imagine you do not have 3 but 16 records to define, and you need to do this multiple times. A typical scenario where such a situation can arise is when the CPU supports many vector types, and the vector instructions vary slightly based on the <span class="No-Break">used type.</span></p>&#13;
			<p>Please note that all three lines with the <strong class="source-inline">def</strong> statement have the same structure. The variation is only in the suffix of the name and of the mnemonic, and the delta value is added to the opcode. In C, you could put the data into an array and implement a function that returns the data based on an index value. Then, you could create a loop over the data instead of manually <span class="No-Break">repeating statements.</span></p>&#13;
			<p>Amazingly, you can do something similar in the TableGen language! Here is how to transform <span class="No-Break">the example:</span></p>&#13;
			<ol>&#13;
				<li>To store the data, you define a class with all required fields. The class is called <strong class="source-inline">InstDesc</strong>, because it describes some properties of <span class="No-Break">an instruction:</span><pre class="source-code">&#13;
class InstDesc&lt;string name, string suffix, int delta&gt; {&#13;
  string Name = name;&#13;
  string Suffix = suffix;&#13;
  int Delta = delta;&#13;
}</pre></li>				<li>Now, you<a id="_idIndexMarker483"/> can define records for each operand type. Note that it exactly captures the differences observed in <span class="No-Break">the data:</span><pre class="source-code">&#13;
def RegOp : InstDesc&lt;"", "", 0&gt;;&#13;
def ImmOp : InstDesc&lt;"I", """, 1&gt;;&#13;
def MemOp : InstDesc"""","""", 2&gt;;</pre></li>				<li>Imagine you have a loop enumerating the numbers <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, and <strong class="source-inline">2</strong>, and you want to select one of the previously defined records based on the index. How can you do this? The solution is to create a <strong class="source-inline">getDesc</strong> class that takes the index as a parameter. It has a single field, <strong class="source-inline">ret</strong>, that you can interpret as a return value. To assign the correct value to this field, the <strong class="source-inline">!cond</strong> operator <span class="No-Break">is used:</span><pre class="source-code">&#13;
class getDesc&lt;int n&gt; {&#13;
  InstDesc ret = !cond(!eq(n, 0) : RegOp,&#13;
                       !eq(n, 1) : ImmOp,&#13;
                       !eq(n, 2) : MemOp);&#13;
}</pre><p class="list-inset">This operator works similarly to a <strong class="source-inline">switch</strong>/<strong class="source-inline">case</strong> statement <span class="No-Break">in C.</span></p></li>				<li>Now, you are ready to define the multiclass. The TableGen language has a <strong class="source-inline">loop</strong> statement, and it also allows us to define variables. But remember that there is no dynamic execution! As a consequence, the loop range is statically defined, and you can assign a value to a variable, but you cannot change that value later. However, this is enough to retrieve the data. Please note how the use of the <strong class="source-inline">getDesc</strong> class resembles a function call. But there is no function call! Instead, an anonymous<a id="_idIndexMarker484"/> record is created, and the values are taken from that record. Lastly, the past operator (<strong class="source-inline">#</strong>) performs a string concatenation, similar to the <strong class="source-inline">!strconcat</strong> operator <span class="No-Break">used earlier:</span><pre class="source-code">&#13;
multiclass InstWithOps&lt;string mnemonic, int opcode&gt; {&#13;
  foreach I = 0-2 in {&#13;
    defvar Name = getDesc&lt;I&gt;.ret.Name;&#13;
    defvar Suffix = getDesc&lt;I&gt;.ret.Suffix;&#13;
    defvar Delta = getDesc&lt;I&gt;.ret.Delta;&#13;
    def Name: Inst&lt;mnemonic # Suffix,&#13;
                   !add(opcode, Delta)&gt;;&#13;
  }&#13;
}</pre></li>				<li>Now, you use the multiclass as before to <span class="No-Break">define records:</span><pre class="source-code">&#13;
defm ADD : InstWithOps&lt;"add", 0xA0&gt;;</pre></li>			</ol>&#13;
			<p>Please run <strong class="source-inline">llvm-tblgen</strong> and examine the records. Besides the various <strong class="source-inline">ADD</strong> records, you will also see a couple of anonymous records generated by the use of the <span class="No-Break"><strong class="source-inline">getDesc</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p>This technique is used in the instruction definition of several LLVM backends. With the knowledge you have acquired, you should have no problem understanding <span class="No-Break">those files.</span></p>&#13;
			<p>The <strong class="source-inline">foreach</strong> statement used the syntax <strong class="source-inline">0-2</strong> to denote the bounds of the range. This is called a <strong class="bold">range piece</strong>. An<a id="_idIndexMarker485"/> alternative syntax is to use three dots (<strong class="source-inline">0...3</strong>), which is useful if the numbers are negative. Lastly, you are not restricted to numerical ranges; you can also loop over a list of elements, which allows you to use strings or previously defined records. For example, you may like the use of the <strong class="source-inline">foreach</strong> statement, but you think that using the <strong class="source-inline">getDesc</strong> class is too complicated. In this case, looping over the <strong class="source-inline">InstDesc</strong> records is <span class="No-Break">the solution:</span></p>&#13;
			<pre class="source-code">&#13;
multiclass InstWithOps&lt;string mnemonic, int opcode&gt; {&#13;
  foreach I = [RegOp, ImmOp, MemOp] in {&#13;
    defvar Name = I.Name;&#13;
    defvar Suffix = I.Suffix;&#13;
    defvar Delta = I.Delta;&#13;
    def Name: Inst&lt;mnemonic # Suffix, !add(opcode, Delta)&gt;;&#13;
  }&#13;
}</pre>			<p>So far, you <a id="_idIndexMarker486"/>only defined records in the TableGen language, using the most commonly used statements. In the next section, you’ll learn how to generate C++ source code from records defined in the <span class="No-Break">TableGen language.</span></p>&#13;
			<h1 id="_idParaDest-136"><a id="_idTextAnchor140"/>Generating C++ code from a TableGen file</h1>&#13;
			<p>In the <a id="_idIndexMarker487"/>previous section, you defined records in the TableGen language. To make use of those records, you need to write your own TableGen backend that can produce C++ source code or do other things using the records <span class="No-Break">as input.</span></p>&#13;
			<p>In <a href="B19561_03.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Turning the Source File into an Abstract Syntax Tree</em>, the implementation of the <strong class="source-inline">Lexer</strong> class uses a database file to define tokens and keywords. Various query functions make use of that database file. Besides that, the database file is used to implement a keyword filter. The keyword filter is a hash map, implemented using the <strong class="source-inline">llvm::StringMap</strong> class. Whenever an identifier is found, the keyword filter is called to find out if the identifier is actually a keyword. If you take a closer look at the implementation using the <strong class="source-inline">ppprofiler</strong> pass from <a href="B19561_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Advanced IR Generation</em>, then you will see that this function is called quite often. Therefore, it may be useful to experiment with different implementations to make that functionality as fast <span class="No-Break">as possible.</span></p>&#13;
			<p>However, this is not as easy as it seems. For example, you can try to replace the lookup in the hash map with a binary search. This requires that the keywords in the database file are sorted. Currently, this seems to be the case, but during development, a new keyword might be added in the wrong place undetected. The only way to make sure that the keywords are in the right order is to add some code that checks the order <span class="No-Break">at runtime.</span></p>&#13;
			<p>You can speed<a id="_idIndexMarker488"/> up the standard binary search by changing the memory layout. For example, instead of sorting the keywords, you can use the Eytzinger layout, which enumerates the search tree in breadth-first order. This layout increases the cache locality of the data and therefore speeds up the search. Personally speaking, maintaining the keywords in breadth-first order manually in the database file is <span class="No-Break">not possible.</span></p>&#13;
			<p>Another popular approach for searching is the generation of minimal perfect hash functions. If you insert a new key into a dynamic hash table such as <strong class="source-inline">llvm::StringMap</strong>, then that key might be mapped to an already occupied slot. This is called a <strong class="bold">key collision</strong>. Key collisions <a id="_idIndexMarker489"/>are unavoidable, and many strategies have been developed to mitigate that problem. However, if you know all the keys, then you can construct hash functions without key collisions. Such hash functions are called <strong class="bold">perfect</strong>. In case they do not require more slots than keys, then they are called minimal. Perfect hash functions <a id="_idIndexMarker490"/>can be generated efficiently – for example, with the <strong class="source-inline">gperf</strong> <span class="No-Break">GNU tool.</span></p>&#13;
			<p>In summary, there is some incentive to be able to generate a lookup function from keywords. So, let’s move the database file <span class="No-Break">to TableGen!</span></p>&#13;
			<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Defining data in the TableGen language</h2>&#13;
			<p>The <strong class="source-inline">TokenKinds.def</strong> database <a id="_idIndexMarker491"/>file defines three different macros. The <strong class="source-inline">TOK</strong> macro is used for tokens that do not have a fixed spelling – for example, for integer literals. The <strong class="source-inline">PUNCTUATOR</strong> macro is used for all kinds of punctuation marks and includes a preferred spelling. Lastly, the <strong class="source-inline">KEYWORD</strong> macro defines a keyword that is made up of a literal and a flag, which is used to indicate at which language level this literal is a keyword. For example, the <strong class="source-inline">thread_local</strong> keyword was added <span class="No-Break">to C++11.</span></p>&#13;
			<p>One way to express this in the TableGen language is to create a <strong class="source-inline">Token</strong> class that holds all the data. You can then add subclasses of that class to make the usage more comfortable. You also need a <strong class="source-inline">Flag</strong> class for flags defined together with a keyword. And last, you need a class to define a keyword filter. These classes define the basic data structure and can be potentially reused in other projects. Therefore, you create a <strong class="source-inline">Keyword.td</strong> file for it. Here are <span class="No-Break">the steps:</span></p>&#13;
			<ol>&#13;
				<li>A flag is<a id="_idIndexMarker492"/> modeled as a name and an associated value. This makes it easy to generate an enumeration from <span class="No-Break">this data:</span><pre class="source-code">&#13;
class Flag&lt;string name, int val&gt; {&#13;
    string Name = name;&#13;
    int Val = val;&#13;
}</pre></li>				<li>The <strong class="source-inline">Token</strong> class is used as the base class. It just carries a name. Please note that this class has <span class="No-Break">no parameters:</span><pre class="source-code">&#13;
class Token {&#13;
    string Name;&#13;
}</pre></li>				<li>The <strong class="source-inline">Tok</strong> class has the same function as the corresponding <strong class="source-inline">TOK</strong> macro from the database file. it represents a token without fixed spellings. It derives from the base class, <strong class="source-inline">Token</strong>, and just adds initialization for <span class="No-Break">the name:</span><pre class="source-code">&#13;
class Tok&lt;string name&gt; : Token {&#13;
    let Name = name;&#13;
}</pre></li>				<li>In the same way, the <strong class="source-inline">Punctuator</strong> class resembles the <strong class="source-inline">PUNCTUATOR</strong> macro. It adds a field for the spelling of <span class="No-Break">the token:</span><pre class="source-code">&#13;
class Punctuator&lt;string name, string spelling&gt; : Token {&#13;
    let Name = name;&#13;
    string Spelling = spelling;&#13;
}</pre></li>				<li>And last, the <strong class="source-inline">Keyword</strong> class needs a list <span class="No-Break">of flags:</span><pre class="source-code">&#13;
class Keyword&lt;string name, list&lt;Flag&gt; flags&gt; : Token {&#13;
    let Name = name;&#13;
    list&lt;Flag&gt; Flags = flags;&#13;
}</pre></li>				<li>With <a id="_idIndexMarker493"/>these definitions in place, you can now define a class for the keyword filter, called <strong class="source-inline">TokenFilter</strong>. It takes a list of tokens as <span class="No-Break">a parameter:</span><pre class="source-code">&#13;
class TokenFilter&lt;list&lt;Token&gt; tokens&gt; {&#13;
    string FunctionName;&#13;
    list&lt;Token&gt; Tokens = tokens;&#13;
}</pre></li>			</ol>&#13;
			<p>With these class definitions, you are certainly able to capture all the data from the <strong class="source-inline">TokenKinds.def</strong> database file. The TinyLang language does not utilize the flags, since there is only this version of the language. Real-world languages such as C and C++ have undergone a couple of revisions, and they usually require flags. Therefore, we use keywords from C and C++ as an example. Let’s create a <strong class="source-inline">KeywordC.td</strong> file, <span class="No-Break">as follows:</span></p>&#13;
			<ol>&#13;
				<li>First, you include the class definitions <span class="No-Break">created earlier:</span><pre class="source-code">&#13;
Include "Keyword.td"</pre></li>				<li>Next, you define flags. The value is the binary value of the flag. Note how the <strong class="source-inline">!or</strong> operator is used to create a value for the <span class="No-Break"><strong class="source-inline">KEYALL</strong></span><span class="No-Break"> flag:</span><pre class="source-code">&#13;
def KEYC99  : Flag&lt;"KEYC99", 0x1&gt;;&#13;
def KEYCXX  : Flag&lt;"KEYCXX", 0x2&gt;;&#13;
def KEYCXX11: Flag&lt;"KEYCXX11", 0x4&gt;;&#13;
def KEYGNU  : Flag&lt;"KEYGNU", 0x8&gt;;&#13;
def KEYALL  : Flag&lt;"KEYALL",&#13;
                   !or(KEYC99.Val, KEYCXX.Val,&#13;
                       KEYCXX11.Val , KEYGNU.Val)&gt;;</pre></li>				<li>There are tokens without a fixed spelling – for example, <span class="No-Break">a comment:</span><pre class="source-code">&#13;
def : Tok&lt;"comment"&gt;;</pre></li>				<li>Operators are defined using the <strong class="source-inline">Punctuator</strong> class, as in <span class="No-Break">this example:</span><pre class="source-code">&#13;
def : Punctuator&lt;"plus", "+"&gt;;&#13;
def : Punctuator&lt;"minus", "-"&gt;;</pre></li>				<li>Keywords need to use <span class="No-Break">different flags:</span><pre class="source-code">&#13;
def kw_auto: Keyword&lt;"auto", [KEYALL]&gt;;&#13;
def kw_inline: Keyword&lt;"inline", [KEYC99,KEYCXX,KEYGNU]&gt;;&#13;
def kw_restrict: Keyword&lt;"restrict", [KEYC99]&gt;;</pre></li>				<li>And last, here’s the definition of the <span class="No-Break">keyword filter:</span><pre class="source-code">&#13;
def : TokenFilter&lt;[kw_auto, kw_inline, kw_restrict]&gt;;</pre></li>			</ol>&#13;
			<p>Of course, this<a id="_idIndexMarker494"/> file does not include all tokens from C and C++. However, it demonstrates all possible usages of the defined <span class="No-Break">TableGen classes.</span></p>&#13;
			<p>Based on these TableGen files, you’ll implement a TableGen backend in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-138"><a id="_idTextAnchor142"/>Implementing a TableGen backend</h2>&#13;
			<p>Since<a id="_idIndexMarker495"/> parsing and creation of records are done through an LLVM library, you only need to care about the <a id="_idIndexMarker496"/>backend implementation, which consists mostly of generating C++ source code fragments based on the information in the records. First, you need to be clear about what source code to generate before you can put it into <span class="No-Break">the backend.</span></p>&#13;
			<h3>Sketching the source code to be generated</h3>&#13;
			<p>The output of <a id="_idIndexMarker497"/>the TableGen tool is a single file containing C++ fragments. The fragments are guarded by macros. The goal is to replace the <strong class="source-inline">TokenKinds.def</strong> database file. Based on the information in the TableGen file, you can generate <span class="No-Break">the following:</span></p>&#13;
			<ol>&#13;
				<li>The enumeration members used to define flags. The developer is free to name the type; however, it should be based on the <strong class="source-inline">unsigned</strong> type. If the generated file is named <strong class="source-inline">TokenKinds.inc</strong>, then the intended use <span class="No-Break">is this:</span><pre class="source-code">&#13;
enum Flags : unsigned {&#13;
#define GET_TOKEN_FLAGS&#13;
#include "TokenKinds.inc"&#13;
}</pre></li>				<li>The <strong class="source-inline">TokenKind</strong> enumeration, and the prototypes and definitions of the <strong class="source-inline">getTokenName()</strong>, <strong class="source-inline">getPunctuatorSpelling()</strong>, and <strong class="source-inline">getKeywordSpelling()</strong> functions. This code replaces the <strong class="source-inline">TokenKinds.def</strong> database file, most of the <strong class="source-inline">TokenKinds.h</strong> include file and the <strong class="source-inline">TokenKinds.cpp</strong>. <span class="No-Break">source file.</span></li>&#13;
				<li>A new <strong class="source-inline">lookupKeyword()</strong> function that can be used instead of the current implementation using the <strong class="source-inline">llvm::StringMap</strong>. type. This is the function you want <span class="No-Break">to optimize.</span></li>&#13;
			</ol>&#13;
			<p>Knowing what you want to generate, you can now turn to implementing <span class="No-Break">the backend.</span></p>&#13;
			<h3>Creating a new TableGen tool</h3>&#13;
			<p>A simple <a id="_idIndexMarker498"/>structure for your new tool is to have a driver that evaluates the command-line options and calls the generation functions and the actual generator functions in a different file. Let’s call the driver file <strong class="source-inline">TableGen.cpp</strong> and the file containing the generator <strong class="source-inline">TokenEmitter.cpp</strong>. You also need a <strong class="source-inline">TableGenBackends.h</strong> header file. Let’s begin the implementation with the generation of the C++ code in the <span class="No-Break"><strong class="source-inline">TokenEmitter.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>As usual, the file begins with including the required headers. The most important one is <strong class="source-inline">llvm/TableGen/Record.h</strong>, which defines a <strong class="source-inline">Record</strong> class, used to hold records generated by parsing the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">td</strong></span><span class="No-Break"> file:</span><pre class="source-code">&#13;
#include "TableGenBackends.h"&#13;
#include "llvm/Support/Format.h"&#13;
#include "llvm/TableGen/Record.h"&#13;
#include "llvm/TableGen/TableGenBackend.h"&#13;
#include &lt;algorithm&gt;</pre></li>				<li>To <a id="_idIndexMarker499"/>simplify coding, the <strong class="source-inline">llvm</strong> namespace <span class="No-Break">is imported:</span><pre class="source-code">&#13;
using namespace llvm;</pre></li>				<li>The <strong class="source-inline">TokenAndKeywordFilterEmitter</strong> class is responsible for generating the C++ source code. The <strong class="source-inline">emitFlagsFragment()</strong>, <strong class="source-inline">emitTokenKind()</strong>, and <strong class="source-inline">emitKeywordFilter()</strong> methods emit the source code, as described in the previous section, <em class="italic">Sketching the source code to be generated</em>. The only public method, <strong class="source-inline">run()</strong>, calls all the code-emitting methods. The records are held in an instance of <strong class="source-inline">RecordKeeper</strong>, which is passed as a parameter to the constructor. The class is inside an <span class="No-Break">anonymous namespace:</span><pre class="source-code">&#13;
namespace {&#13;
class TokenAndKeywordFilterEmitter {&#13;
  RecordKeeper &amp;Records;&#13;
public:&#13;
  explicit TokenAndKeywordFilterEmitter(RecordKeeper &amp;R)&#13;
      : Records(R) {}&#13;
  void run(raw_ostream &amp;OS);&#13;
private:&#13;
  void emitFlagsFragment(raw_ostream &amp;OS);&#13;
  void emitTokenKind(raw_ostream &amp;OS);&#13;
  void emitKeywordFilter(raw_ostream &amp;OS);&#13;
};&#13;
} // End anonymous namespace</pre></li>				<li>The <strong class="source-inline">run()</strong> method <a id="_idIndexMarker500"/>calls all the emitting methods. It also times the length of each phase. You specify the <strong class="source-inline">--time-phases</strong> option, and then the timing is shown after all code <span class="No-Break">is generated:</span><pre class="source-code">&#13;
void TokenAndKeywordFilterEmitter::run(raw_ostream &amp;OS) {&#13;
  // Emit Flag fragments.&#13;
  Records.startTimer("Emit flags");&#13;
  emitFlagsFragment(OS);&#13;
  // Emit token kind enum and functions.&#13;
  Records.startTimer("Emit token kind");&#13;
  emitTokenKind(OS);&#13;
  // Emit keyword filter code.&#13;
  Records.startTimer("Emit keyword filter");&#13;
  emitKeywordFilter(OS);&#13;
  Records.stopTimer();&#13;
}</pre></li>				<li>The <strong class="source-inline">emitFlagsFragment()</strong> method shows the typical structure of a function emitting C++ source code. The generated code is guarded by the <strong class="source-inline">GET_TOKEN_FLAGS</strong> macro. To emit the C++ source fragment, you loop over all records that are derived from the <strong class="source-inline">Flag</strong> class in the TableGen file. Having such a record, it is easy to query the record for the name and the value. Please note that the names <strong class="source-inline">Flag</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Val</strong> must be written exactly as in the TableGen file. If you rename <strong class="source-inline">Val</strong> to <strong class="source-inline">Value</strong> in the TableGen file, then you also need to <a id="_idIndexMarker501"/>change the string in this function. All the generated source code is written to the provided <span class="No-Break">stream, </span><span class="No-Break"><strong class="source-inline">OS</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
void TokenAndKeywordFilterEmitter::emitFlagsFragment(&#13;
    raw_ostream &amp;OS) {&#13;
  OS &lt;&lt; "#ifdef GET_TOKEN_FLAGS\n";&#13;
  OS &lt;&lt; "#undef GET_TOKEN_FLAGS\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Flag")) {&#13;
    StringRef Name = CC-&gt;getValueAsString("Name");&#13;
    int64_t Val = CC-&gt;getValueAsInt("Val");&#13;
    OS &lt;&lt; Name &lt;&lt; " = " &lt;&lt; format_hex(Val, 2) &lt;&lt; ",\n";&#13;
  }&#13;
  OS &lt;&lt; "#endif\n";&#13;
}</pre></li>				<li>The <strong class="source-inline">emitTokenKind()</strong> method emits a declaration and definition of token classification functions. Let’s have a look at emitting the declarations first. The overall structure is the same as the previous method – only more C++ source code is emitted. The generated source fragment is guarded by the <strong class="source-inline">GET_TOKEN_KIND_DECLARATION</strong> macro. Please note that this method tries to generate nicely formatted C++ code, using new lines and indentation as a human developer would do. In case the emitted source code is not correct, and you need <a id="_idIndexMarker502"/>to examine it to find the error, this will be tremendously helpful. It is also easy to make such errors: after all, you are writing a C++ function that emits C++ <span class="No-Break">source code.</span><p class="list-inset">First, the <strong class="source-inline">TokenKind</strong> enumeration is emitted. The name for a keyword should be prefixed with a <strong class="source-inline">kw_</strong> string. The loop goes over all records of the <strong class="source-inline">Token</strong> class, and you can query the records if they are also a subclass of the <strong class="source-inline">Keyword</strong> class, which enables you to emit <span class="No-Break">the prefix:</span></p><pre class="source-code">&#13;
  OS &lt;&lt; "#ifdef GET_TOKEN_KIND_DECLARATION\n"&#13;
     &lt;&lt; "#undef GET_TOKEN_KIND_DECLARATION\n"&#13;
     &lt;&lt; "namespace tok {\n"&#13;
     &lt;&lt; "  enum TokenKind : unsigned short {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Token")) {&#13;
    StringRef Name = CC-&gt;getValueAsString("Name");&#13;
    OS &lt;&lt; "    ";&#13;
    if (CC-&gt;isSubClassOf("Keyword"))&#13;
      OS &lt;&lt; "kw_";&#13;
    OS &lt;&lt; Name &lt;&lt; ",\n";&#13;
  }&#13;
  OS &lt;&lt; „    NUM_TOKENS\n"&#13;
     &lt;&lt; „  };\n";</pre></li>				<li>Next, the function declarations are emitted. This is only a constant string, so nothing exciting happens. This finishes emitting <span class="No-Break">the declarations:</span><pre class="source-code">&#13;
  OS &lt;&lt; "  const char *getTokenName(TokenKind Kind) "&#13;
        "LLVM_READNONE;\n"&#13;
     &lt;&lt; "  const char *getPunctuatorSpelling(TokenKind "&#13;
        "Kind) LLVM_READNONE;\n"&#13;
     &lt;&lt; "  const char *getKeywordSpelling(TokenKind "&#13;
        "Kind) "&#13;
        "LLVM_READNONE;\n"&#13;
     &lt;&lt; "}\n"&#13;
     &lt;&lt; "#endif\n";</pre></li>				<li>Now, let’s turn <a id="_idIndexMarker503"/>to emitting the definitions. Again, this generated code is guarded by a macro called <strong class="source-inline">GET_TOKEN_KIND_DEFINITION</strong>. First, the token names are emitted into a <strong class="source-inline">TokNames</strong> array, and the <strong class="source-inline">getTokenName()</strong> function uses that array to retrieve the name. Please note that the quote symbol must be escaped as <strong class="source-inline">\"</strong> when used inside <span class="No-Break">a string:</span><pre class="source-code">&#13;
  OS &lt;&lt; "#ifdef GET_TOKEN_KIND_DEFINITION\n";&#13;
  OS &lt;&lt; "#undef GET_TOKEN_KIND_DEFINITION\n";&#13;
  OS &lt;&lt; "static const char * const TokNames[] = {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Token")) {&#13;
    OS &lt;&lt; "  \"" &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; "\",\n";&#13;
  }&#13;
  OS &lt;&lt; "};\n\n";&#13;
  OS &lt;&lt; "const char *tok::getTokenName(TokenKind Kind) "&#13;
        "{\n"&#13;
     &lt;&lt; "  if (Kind &lt;= tok::NUM_TOKENS)\n"&#13;
     &lt;&lt; "    return TokNames[Kind];\n"&#13;
     &lt;&lt; "  llvm_unreachable(\"unknown TokenKind\");\n"&#13;
     &lt;&lt; "  return nullptr;\n"&#13;
     &lt;&lt; "};\n\n";</pre></li>				<li>Next, the <strong class="source-inline">getPunctuatorSpelling()</strong> function is emitted. The only notable<a id="_idIndexMarker504"/> difference to the other parts is that the loop goes over all records derived from the <strong class="source-inline">Punctuator</strong> class. Also, a <strong class="source-inline">switch</strong> statement is generated instead of <span class="No-Break">an array:</span><pre class="source-code">&#13;
  OS &lt;&lt; "const char "&#13;
        "*tok::getPunctuatorSpelling(TokenKind "&#13;
        "Kind) {\n"&#13;
     &lt;&lt; "  switch (Kind) {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Punctuator")) {&#13;
    OS &lt;&lt; "    " &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; ": return \""&#13;
       &lt;&lt; CC-&gt;getValueAsString("Spelling") &lt;&lt; "\";\n";&#13;
  }&#13;
  OS &lt;&lt; "    default: break;\n"&#13;
     &lt;&lt; "  }\n"&#13;
     &lt;&lt; "  return nullptr;\n"&#13;
     &lt;&lt; "};\n\n";</pre></li>				<li>And finally, the <strong class="source-inline">getKeywordSpelling()</strong> function is emitted. The coding is similar to <a id="_idIndexMarker505"/>emitting <strong class="source-inline">getPunctuatorSpelling()</strong>. This time, the loop goes over all records of the <strong class="source-inline">Keyword</strong> class, and the name is again prefixed <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">kw_</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
  OS &lt;&lt; "const char *tok::getKeywordSpelling(TokenKind "&#13;
        "Kind) {\n"&#13;
     &lt;&lt; "  switch (Kind) {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Keyword")) {&#13;
    OS &lt;&lt; "    kw_" &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; ": return \"" &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; "\";\n";&#13;
  }&#13;
  OS &lt;&lt; "    default: break;\n"&#13;
     &lt;&lt; "  }\n"&#13;
     &lt;&lt; "  return nullptr;\n"&#13;
     &lt;&lt; «};\n\n»;&#13;
  OS &lt;&lt; «#endif\n»;&#13;
}</pre></li>				<li>The <strong class="source-inline">emitKeywordFilter()</strong> method is more complex than the previous methods since emitting the filter requires collecting some data from the records. The generated source code uses the <strong class="source-inline">std::lower_bound()</strong> function, thus implementing a <span class="No-Break">binary search.</span><p class="list-inset">Now, let’s make a shortcut. There can be several records of the <strong class="source-inline">TokenFilter</strong> class defined in the TableGen file. For demonstration purposes, just emit at most one token <span class="No-Break">filter method:</span></p><pre class="source-code">&#13;
  std::vector&lt;Record *&gt; AllTokenFilter =&#13;
      Records.getAllDerivedDefinitionsIfDefined(&#13;
          "TokenFilter");&#13;
  if (AllTokenFilter.empty())&#13;
    return;</pre></li>				<li>The <a id="_idIndexMarker506"/>keywords used for the filter are in the list named <strong class="source-inline">Tokens</strong>. To get access to that list, you first need to look up the <strong class="source-inline">Tokens</strong> field in the record. This returns a pointer to an instance of the <strong class="source-inline">RecordVal</strong> class, from which you can retrieve the <strong class="source-inline">Initializer</strong> instance via the calling method, <strong class="source-inline">getValue()</strong>. The <strong class="source-inline">Tokens</strong> field is defined as a list, so you cast the initializer instance to <strong class="source-inline">ListInit</strong>. If this fails, then exit <span class="No-Break">the function:</span><pre class="source-code">&#13;
  ListInit *TokenFilter = dyn_cast_or_null&lt;ListInit&gt;(&#13;
      AllTokenFilter[0]&#13;
          -&gt;getValue("Tokens")&#13;
          -&gt;getValue());&#13;
  if (!TokenFilter)&#13;
    return;</pre></li>				<li>Now, you are ready to construct a filter table. For each keyword stored in the <strong class="source-inline">TokenFilter</strong>, list, you need the name and the value of the <strong class="source-inline">Flag</strong> field. That field is again defined as a list, so you need to loop over those elements to calculate the<a id="_idIndexMarker507"/> final value. The resulting name/flag value pair is stored in a <span class="No-Break"><strong class="source-inline">Table</strong></span><span class="No-Break"> vector:</span><pre class="source-code">&#13;
  using KeyFlag = std::pair&lt;StringRef, uint64_t&gt;;&#13;
  std::vector&lt;KeyFlag&gt; Table;&#13;
  for (size_t I = 0, E = TokenFilter-&gt;size(); I &lt; E;&#13;
       ++I) {&#13;
   Record *CC = TokenFilter-&gt;getElementAsRecord(I);&#13;
   StringRef Name = CC-&gt;getValueAsString("Name");&#13;
   uint64_t Val = 0;&#13;
   ListInit *Flags = nullptr;&#13;
   if (RecordVal *F = CC-&gt;getValue("Flags"))&#13;
      Flags = dyn_cast_or_null&lt;ListInit&gt;(F-&gt;getValue());&#13;
   if (Flags) {&#13;
      for (size_t I = 0, E = Flags-&gt;size(); I &lt; E; ++I) {&#13;
        Val |=&#13;
            Flags-&gt;getElementAsRecord(I)-&gt;getValueAsInt(&#13;
                "Val");&#13;
      }&#13;
   }&#13;
   Table.emplace_back(Name, Val);&#13;
  }</pre></li>				<li>To be able to perform a binary search, the table needs to be sorted. The comparison function is provided by a <span class="No-Break">lambda function:</span><pre class="source-code">&#13;
  llvm::sort(Table.begin(), Table.end(),&#13;
             [](const KeyFlag A, const KeyFlag B) {&#13;
               return A.first &lt; B.first;&#13;
             });</pre></li>				<li>Now, you <a id="_idIndexMarker508"/>can emit the C++ source code. First, you emit the sorted table containing the name of the keyword and the associated <span class="No-Break">flag value:</span><pre class="source-code">&#13;
  OS &lt;&lt; "#ifdef GET_KEYWORD_FILTER\n"&#13;
     &lt;&lt; "#undef GET_KEYWORD_FILTER\n";&#13;
  OS &lt;&lt; "bool lookupKeyword(llvm::StringRef Keyword, "&#13;
        "unsigned &amp;Value) {\n";&#13;
  OS &lt;&lt; "  struct Entry {\n"&#13;
     &lt;&lt; "    unsigned Value;\n"&#13;
     &lt;&lt; "    llvm::StringRef Keyword;\n"&#13;
     &lt;&lt; "  };\n"&#13;
     &lt;&lt; "static const Entry Table[" &lt;&lt; Table.size()&#13;
     &lt;&lt; "] = {\n";&#13;
  for (const auto &amp;[Keyword, Value] : Table) {&#13;
   OS &lt;&lt; "    { " &lt;&lt; Value &lt;&lt; ", llvm::StringRef(\""&#13;
      &lt;&lt; Keyword &lt;&lt; "\", " &lt;&lt; Keyword.size()&#13;
      &lt;&lt; ") },\n";&#13;
  }&#13;
  OS &lt;&lt; "  };\n\n";</pre></li>				<li>Next, you look up the keyword in the sorted table, using the <strong class="source-inline">std::lower_bound()</strong> standard C++ function. If the keyword is in the table, then the <strong class="source-inline">Value</strong> parameter receives the value of the flags associated with the keyword, and the function returns <strong class="source-inline">true</strong>. Otherwise, the function simply <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
  OS &lt;&lt; "  const Entry *E = "&#13;
        "std::lower_bound(&amp;Table[0], "&#13;
        "&amp;Table["&#13;
     &lt;&lt; Table.size()&#13;
     &lt;&lt; "], Keyword, [](const Entry &amp;A, const "&#13;
        "StringRef "&#13;
        "&amp;B) {\n";&#13;
  OS &lt;&lt; "    return A.Keyword &lt; B;\n";&#13;
  OS &lt;&lt; "  });\n";&#13;
  OS &lt;&lt; "  if (E != &amp;Table[" &lt;&lt; Table.size()&#13;
     &lt;&lt; "]) {\n";&#13;
  OS &lt;&lt; "    Value = E-&gt;Value;\n";&#13;
  OS &lt;&lt; "    return true;\n";&#13;
  OS &lt;&lt; "  }\n";&#13;
  OS &lt;&lt; "  return false;\n";&#13;
  OS &lt;&lt; "}\n";&#13;
  OS &lt;&lt; "#endif\n";&#13;
}</pre></li>				<li>The only<a id="_idIndexMarker509"/> missing part now is a way to call this implementation, for which you define a global function, <strong class="source-inline">EmitTokensAndKeywordFilter()</strong>. The <strong class="source-inline">emitSourceFileHeader()</strong> function declared in the <strong class="source-inline">llvm/TableGen/TableGenBackend.h</strong> header emits a comment at the top of the <span class="No-Break">generated file:</span><pre class="source-code">&#13;
void EmitTokensAndKeywordFilter(RecordKeeper &amp;RK,&#13;
                                raw_ostream &amp;OS) {&#13;
  emitSourceFileHeader("Token Kind and Keyword Filter "&#13;
                       "Implementation Fragment",&#13;
                       OS);&#13;
  TokenAndKeywordFilterEmitter(RK).run(OS);&#13;
}</pre></li>			</ol>&#13;
			<p>With that, you<a id="_idIndexMarker510"/> finished the implementation of the source emitter in the <strong class="source-inline">TokenEmitter.cpp</strong> file. Overall, the coding is not <span class="No-Break">too complicated.</span></p>&#13;
			<p>The <strong class="source-inline">TableGenBackends.h</strong> header file only contains the declaration of the <strong class="source-inline">EmitTokensAndKeywordFilter()</strong> function. To avoid including other files, you use forward declarations for the <strong class="source-inline">raw_ostream</strong> and <span class="No-Break"><strong class="source-inline">RecordKeeper</strong></span><span class="No-Break"> classes:</span></p>&#13;
			<pre class="source-code">&#13;
#ifndef TABLEGENBACKENDS_H&#13;
#define TABLEGENBACKENDS_H&#13;
namespace llvm {&#13;
class raw_ostream;&#13;
class RecordKeeper;&#13;
} // namespace llvm&#13;
void EmitTokensAndKeywordFilter(llvm::RecordKeeper &amp;RK,&#13;
                                llvm::raw_ostream &amp;OS);&#13;
#endif</pre>			<p>The missing part is the implementation of the driver. Its task is to parse the TableGen file and emit the records according to the command-line options. The implementation is in the <span class="No-Break"><strong class="source-inline">TableGen.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>As usual, the implementation begins with including the required headers. The most important one is <strong class="source-inline">llvm/TableGen/Main.h</strong> because this header declares the frontend <span class="No-Break">of TableGen:</span><pre class="source-code">&#13;
#include "TableGenBackends.h"&#13;
#include "llvm/Support/CommandLine.h"&#13;
#include "llvm/Support/PrettyStackTrace.h"&#13;
#include "llvm/Support/Signals.h"&#13;
#include "llvm/TableGen/Main.h"&#13;
#include "llvm/TableGen/Record.h"</pre></li>				<li>To<a id="_idIndexMarker511"/> simplify coding, the <strong class="source-inline">llvm</strong> namespace <span class="No-Break">is imported:</span><pre class="source-code">&#13;
using namespace llvm;</pre></li>				<li>The user can choose one action. The <strong class="source-inline">ActionType</strong> enumeration contains all <span class="No-Break">possible actions:</span><pre class="source-code">&#13;
enum ActionType {&#13;
  PrintRecords,&#13;
  DumpJSON,&#13;
  GenTokens,&#13;
};</pre></li>				<li>A single command-line option object called <strong class="source-inline">Action</strong> is used. The user needs to specify the <strong class="source-inline">--gen-tokens</strong> option to emit the token filter you implemented. The other two options, <strong class="source-inline">--print-records</strong> and <strong class="source-inline">--dump-json</strong>, are standard options to dump read records. Note that the object is in an <span class="No-Break">anonymous namespace:</span><pre class="source-code">&#13;
namespace {&#13;
cl::opt&lt;ActionType&gt; Action(&#13;
    cl::desc("Action to perform:"),&#13;
    cl::values(&#13;
        clEnumValN(&#13;
            PrintRecords, "print-records",&#13;
            "Print all records to stdout (default)"),&#13;
        clEnumValN(DumpJSON, "dump-json",&#13;
                   "Dump all records as "&#13;
                   "machine-readable JSON"),&#13;
        clEnumValN(GenTokens, "gen-tokens",&#13;
                   "Generate token kinds and keyword "&#13;
                   "filter")));</pre></li>				<li>The <strong class="source-inline">Main()</strong> function performs the requested action based on the value of <strong class="source-inline">Action</strong>. Most importantly, your <strong class="source-inline">EmitTokensAndKeywordFilter()</strong> function<a id="_idIndexMarker512"/> is called if <strong class="source-inline">--gen-tokens</strong> was specified on the command line. After the end of the function, the anonymous namespace <span class="No-Break">is closed:</span><pre class="source-code">&#13;
bool Main(raw_ostream &amp;OS, RecordKeeper &amp;Records) {&#13;
  switch (Action) {&#13;
  case PrintRecords:&#13;
    OS &lt;&lt; Records; // No argument, dump all contents&#13;
    break;&#13;
  case DumpJSON:&#13;
    EmitJSON(Records, OS);&#13;
    break;&#13;
  case GenTokens:&#13;
    EmitTokensAndKeywordFilter(Records, OS);&#13;
    break;&#13;
  }&#13;
  return false;&#13;
}&#13;
} // namespace</pre></li>				<li>And lastly, you <a id="_idIndexMarker513"/>define a <strong class="source-inline">main()</strong> function. After setting up the stack trace handler and parsing the command-line options, the <strong class="source-inline">TableGenMain()</strong> function is called to parse the TableGen file and create records. That function also calls your <strong class="source-inline">Main()</strong> function if there are <span class="No-Break">no errors:</span><pre class="source-code">&#13;
int main(int argc, char **argv) {&#13;
  sys::PrintStackTraceOnErrorSignal(argv[0]);&#13;
  PrettyStackTraceProgram X(argc, argv);&#13;
  cl::ParseCommandLineOptions(argc, argv);&#13;
  llvm_shutdown_obj Y;&#13;
  return TableGenMain(argv[0], &amp;Main);&#13;
}</pre></li>			</ol>&#13;
			<p>Your own TableGen tool is now implemented. After compiling, you can run it with the <strong class="source-inline">KeywordC.td</strong> sample input file <span class="No-Break">as follows:</span></p>&#13;
			<pre class="console">&#13;
$ tinylang-tblgen --gen-tokens –o TokenFilter.inc KeywordC.td</pre>			<p>The generated C++ source code is written to the <span class="No-Break"><strong class="source-inline">TokenFilter.inc</strong></span><span class="No-Break"> file.</span></p>&#13;
			<p class="callout-heading">Performance of the token filter</p>&#13;
			<p class="callout">Using a<a id="_idIndexMarker514"/> plain binary search for the keyword filter does not give a better performance than the implementation based on the <strong class="source-inline">llvm::StringMap</strong> type. To beat the performance of the current implementation, you need to generate a perfect <span class="No-Break">hash function.</span></p>&#13;
			<p class="callout">The classic algorithm from Czech, Havas, and Majewski can be easily implemented, and it gives you a very good performance. It is described in <em class="italic">An optimal algorithm for generating minimal perfect hash functions</em>, <em class="italic">Information Processing Letters</em>, <em class="italic">Volume 43</em>, <em class="italic">Issue 5</em>, <em class="italic">1992</em>. <span class="No-Break">See </span><span class="No-Break">https://www.sciencedirect.com/science/article/abs/pii/002001909290220P</span><span class="No-Break">.</span></p>&#13;
			<p class="callout">A state-of-the-art algorithm is PTHash from Pibiri and Trani, described in <em class="italic">PTHash: Revisiting FCH Minimal Perfect Hashing</em>, <em class="italic">SIGIR ’21</em>. <span class="No-Break">See </span><a href="https://arxiv.org/pdf/2104.10402.pdf"><span class="No-Break">https://arxiv.org/pdf/2104.10402.pdf</span></a><span class="No-Break">.</span></p>&#13;
			<p class="callout">Both algorithms are good candidates for generating a token filter that is actually faster <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">llvm::StringMap</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor143"/>Drawbacks of TableGen</h1>&#13;
			<p>Here are a few<a id="_idIndexMarker515"/> drawbacks <span class="No-Break">of TableGen:</span></p>&#13;
			<ul>&#13;
				<li>The TableGen language is built on a simple concept. As a consequence, it does not have the same computing capabilities as other DSLs. Obviously, some programmers would like to replace TableGen with a different, more powerful language, and this topic comes up from time to time in the LLVM <span class="No-Break">discussion forum.</span></li>&#13;
				<li>With the possibility of implementing your own backends, the TableGen language is very flexible. However, it also means that the semantics of a given definition are hidden inside the backend. Thus, you can create TableGen files that are basically not understandable by <span class="No-Break">other developers.</span></li>&#13;
				<li>And last, the <a id="_idIndexMarker516"/>backend implementation can be very complex if you try to solve a non-trivial task. It is reasonable to expect that this effort would be lower if the TableGen language were <span class="No-Break">more powerful.</span></li>&#13;
			</ul>&#13;
			<p>Even if not all developers are happy with the capabilities of TableGen, the tool is used widely in LLVM, and for a developer, it is important to <span class="No-Break">understand it.</span></p>&#13;
			<h1 id="_idParaDest-140"><a id="_idTextAnchor144"/>Summary</h1>&#13;
			<p>In this chapter, you first learned the main idea behind TableGen. Then, you defined your first classes and records in the TableGen language, and you acquired knowledge of the syntax of TableGen. Finally, you developed a TableGen backend emitting fragments of C++ source code, based on the TableGen classes <span class="No-Break">you defined.</span></p>&#13;
			<p>In the next chapter, we examine another unique feature of LLVM: generating and executing code in one step, also known as <strong class="bold">Just-In-Time</strong> (<span class="No-Break"><strong class="bold">JIT</strong></span><span class="No-Break">) compilation.</span></p>&#13;
		</div>&#13;
	</div></body></html>