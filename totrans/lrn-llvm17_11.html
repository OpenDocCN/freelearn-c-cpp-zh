<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-128" class="chapter-number"><a id="_idTextAnchor132"/>8</h1>&#13;
			<h1 id="_idParaDest-129"><a id="_idTextAnchor133"/>The TableGen Language</h1>&#13;
			<p>Large parts of backends in LLVM are written in the TableGen language, a special language used to<a id="_idIndexMarker457"/> generate fragments of C++ source code to avoid implementing code similar for each backend and to shorten the amount of source code. Having knowledge of TableGen is therefore important.</p>&#13;
			<p>In this chapter, you will learn the following:</p>&#13;
			<ul>&#13;
				<li>In <em class="italic">Understanding the TableGen language</em>, you will learn about the main idea behind TableGen</li>&#13;
				<li>In <em class="italic">Experimenting with the TableGen language</em>, you will define your own TableGen classes and records, and learn the syntax of the TableGen language</li>&#13;
				<li>In <em class="italic">Generating C++ code from a TableGen file</em>, you will develop your own TableGen backend</li>&#13;
				<li>Drawbacks of TableGen</li>&#13;
			</ul>&#13;
			<p>By the end of the chapter, you will be able to use existing TableGen classes to define your own records. You will also acquire knowledge of how to create TableGen classes and records from scratch, and how to develop a TableGen backend to emit source code.</p>&#13;
			<h1 id="_idParaDest-130"><a id="_idTextAnchor134"/>Technical requirements</h1>&#13;
			<p>You can find the source code used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08">https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08</a>.</p>&#13;
			<h1 id="_idParaDest-131"><a id="_idTextAnchor135"/>Understanding the TableGen language</h1>&#13;
			<p>LLVM comes <a id="_idIndexMarker458"/>with its own <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) called <strong class="bold">TableGen</strong>. It is<a id="_idIndexMarker459"/> used to generate C++ code for a wide range of use cases, thus reducing the amount of code a developer has to produce. The TableGen language is not a full-fledged programming language. It is only used to define records, which is a fancy word for a collection of names and values. To understand why such a restricted language is useful, let’s examine two examples.</p>&#13;
			<p>Typical data you need to define one machine instruction of a CPU is:</p>&#13;
			<ul>&#13;
				<li>The mnemonic of the instruction</li>&#13;
				<li>The bit pattern</li>&#13;
				<li>The number and types of operands</li>&#13;
				<li>Possible restrictions or side effects</li>&#13;
			</ul>&#13;
			<p>It is easy to see that<a id="_idIndexMarker460"/> this data can be represented as a record. For example, a field named <code>asmstring</code> could hold the value of the mnemonic; say, <code>"add"</code>. Also, a field named <code>opcode</code> could hold the binary representation of the instruction. Together, the record would describe an additional instruction. Each LLVM backend describes the instruction set in this way.</p>&#13;
			<p>Records are such a general concept that you can describe a wide variety of data with them. Another example is the definition of command-line options. A command-line option:</p>&#13;
			<ul>&#13;
				<li>Has a name</li>&#13;
				<li>May have an optional argument</li>&#13;
				<li>Has a help text</li>&#13;
				<li>May belong to a group of options</li>&#13;
			</ul>&#13;
			<p>Again, this data can be easily seen as a record. Clang uses this approach for the command-line options of the Clang driver.</p>&#13;
			<p class="callout-heading">The TableGen language</p>&#13;
			<p class="callout">In LLVM, the TableGen language is used for a variety of tasks. Large parts of a backend are written in the TableGen language; for example, the definition of a register file, all instructions with mnemonic and binary encoding, calling conventions, patterns for instruction selection, and scheduling models for instruction scheduling. Other uses of LLVM are the definition of intrinsic functions, the definition of attributes, and the definition of command-line options.</p>&#13;
			<p class="callout">You’ll find the <em class="italic">Programmer’s Reference</em> at <a href="https://llvm.org/docs/TableGen/ProgRef.html">https://llvm.org/docs/TableGen/ProgRef.html</a> and the <em class="italic">Backend Developer’s Guide</em> at <a href="https://llvm.org/docs/TableGen/BackGuide.html">https://llvm.org/docs/TableGen/BackGuide.html</a>.</p>&#13;
			<p>To achieve this<a id="_idIndexMarker461"/> flexibility, the parsing and the semantics of the TableGen language are implemented in a library. To generate C++ code from the records, you need to create a tool that takes the parsed records and generates C++ code from it. In LLVM, that tool is called <code>llvm-tblgen</code>, and in Clang, it is called <code>clang-tblgen</code>. Those tools contain the code generators required by the project. But they can also be used to learn more about the TableGen language, which is what we’ll do in the next section.</p>&#13;
			<h1 id="_idParaDest-132"><a id="_idTextAnchor136"/>Experimenting with the TableGen language</h1>&#13;
			<p>Very <a id="_idIndexMarker462"/>often, beginners feel overwhelmed by the TableGen language. But as soon as you start experimenting with the language, it becomes much easier.</p>&#13;
			<h2 id="_idParaDest-133"><a id="_idTextAnchor137"/>Defining records and classes</h2>&#13;
			<p>Let’s <a id="_idIndexMarker463"/>define a simple record for an instruction:</p>&#13;
			<pre class="source-code">&#13;
def ADD {&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 0xA0;&#13;
}</pre>			<p>The <code>def</code> keyword <a id="_idIndexMarker464"/>signals that you define a record. It is followed by the name of the record. The record body is surrounded by curly braces, and the body consists of field definitions, similar to a structure in C++.</p>&#13;
			<p>You can use the <code>llvm-tblgen</code> tool to see the generated records. Save the preceding source code in an <code>inst.td</code> file and run the following:</p>&#13;
			<pre class="console">&#13;
$ llvm-tblgen --print-records inst.td&#13;
------------- Classes -----------------&#13;
------------- Defs -----------------&#13;
def ADD {&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 160;&#13;
}</pre>			<p>This is not yet exciting; it only shows the defined record was parsed correctly.</p>&#13;
			<p>Defining <a id="_idIndexMarker465"/>instructions using single records is not very comfortable. A modern CPU has hundreds of instructions, and with this amount of records, it is <a id="_idIndexMarker466"/>very easy to introduce typing errors in the field names. And if you decide to rename a field or add a new field, then the number of records to change becomes a challenge. Therefore, a blueprint is needed. In C++, classes have a similar purpose, and in TableGen, it is also <a id="_idIndexMarker467"/>called a <code>Inst</code> class and two records based on that class:</p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
}&#13;
def ADD : Inst&lt;"add", 0xA0&gt;;&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;</pre>			<p>The syntax for classes is similar to that of records. The <code>class</code> keyword signals that a class is defined, followed by the name of the class. A class can have a parameter list. Here, the <code>Inst</code> class has two parameters, <code>mnemonic</code> and <code>opcode</code>, which are used to initialize the records’ fields. The values for those fields are given when the class is instantiated. The <code>ADD</code> and <code>SUB</code> records show two instantiations of the class. Again, let’s use <code>llvm-tblgen</code> to look at the records:</p>&#13;
			<pre class="console">&#13;
$ llvm-tblgen --print-records inst.td&#13;
------------- Classes -----------------&#13;
class Inst&lt;string Inst:mnemonic = ?, int Inst:opcode = ?&gt; {&#13;
  string Mnemonic = Inst:mnemonic;&#13;
  int Opcode = Inst:opcode;&#13;
}&#13;
------------- Defs -----------------&#13;
def ADD {       // Inst&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 160;&#13;
}&#13;
def SUB {       // Inst&#13;
  string Mnemonic = "sub";&#13;
  int Opcode = 176;&#13;
}</pre>			<p>Now, you <a id="_idIndexMarker468"/>have one class definition and two records. The name<a id="_idIndexMarker469"/> of the class used to define the records is shown as a comment. Please note that the arguments of the class have the default value <code>?</code>, which indicates <code>int</code> is uninitialized.</p>&#13;
			<p class="callout-heading">Tip for debugging</p>&#13;
			<p class="callout">To get a more detailed dump of the records, you can use the <code>–-print-detailed-records</code> option. The output includes the line numbers of record and class definitions, and where record fields are initialized. They can be very helpful if you try to track down why a record field was assigned a certain value.</p>&#13;
			<p>In general, the <code>ADD</code> and <code>SUB</code> instructions have a lot in common, but there is also a difference: addition is a commutative operation but subtraction is not. Let’s capture that fact in the record, too. A small challenge is that TableGen only supports a limited set of data types. You already used <code>string</code> and <code>int</code> in the examples. The other available data types are <code>bit</code>, <code>bits&lt;n&gt;</code>, <code>list&lt;type&gt;</code>, and <code>dag</code>. The <code>bit</code> type represents a single bit; that is, <code>0</code> or <code>1</code>. If you need a fixed number of bits, then you use the <code>bits&lt;n&gt;</code> type. For example, <code>bits&lt;5&gt;</code> is an integer type 5 bits wide. To define a list based on another type, you use the <code>list&lt;type&gt;</code> type. For example, <code>list&lt;int&gt;</code> is a list of integers, and <code>list&lt;Inst&gt;</code> is a list of records of the <code>Inst</code> class from the example. The <code>dag</code> type <a id="_idIndexMarker470"/>represents <strong class="bold">directed acyclic graph</strong> (<strong class="bold">DAG</strong>) nodes. This type is useful for defining patterns and operations and is used extensively in LLVM backends.</p>&#13;
			<p>To represent a<a id="_idIndexMarker471"/> flag, a single bit is sufficient, so you can use<a id="_idIndexMarker472"/> one to mark an instruction as commutable. The majority of instructions are not commutable, so you can take advantage of default values:</p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode, bit commutable = 0&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
  bit Commutable = commutable;&#13;
}&#13;
def ADD : Inst&lt;"add", 0xA0, 1&gt;;&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;</pre>			<p>You should run <code>llvm-tblgen</code> to verify that the records are defined as expected.</p>&#13;
			<p>There is no requirement for a class to have parameters. It is also possible to assign values later. For example, you can define that all instructions are not commutable:</p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
  bit Commutable = 0;&#13;
}&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;</pre>			<p>Using a <code>let</code> statement, you can overwrite that value:</p>&#13;
			<pre class="source-code">&#13;
let Commutable = 1 in&#13;
  def ADD : Inst&lt;"add", 0xA0&gt;;</pre>			<p>Alternatively, you can open a record body to overwrite the value:</p>&#13;
			<pre class="source-code">&#13;
def ADD : Inst&lt;"add", 0xA0&gt; {&#13;
  let Commutable = 1;&#13;
}</pre>			<p>Again, please use <code>llvm-tblgen</code> to verify that the <code>Commutable</code> flag is set to <code>1</code> in both cases.</p>&#13;
			<p>Classes <a id="_idIndexMarker473"/>and records can be inherited from multiple classes, and<a id="_idIndexMarker474"/> it is always possible to add new fields or overwrite the value of existing fields. You can use inheritance to introduce a new <code>CommutableInst</code> class:</p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
  bit Commutable = 0;&#13;
}&#13;
class CommutableInst&lt;string mnemonic, int opcode&gt;&#13;
  : Inst&lt;mnemonic, opcode&gt; {&#13;
  let Commutable = 1;&#13;
}&#13;
def SUB : Inst&lt;"sub", 0xB0&gt;;&#13;
def ADD : CommutableInst&lt;"add", 0xA0&gt;;</pre>			<p>The resulting records are always the same, but the language allows you to define records in different <a id="_idIndexMarker475"/>ways. Please note that, in the latter example, the <code>Commutable</code> flag may be superfluous: the <a id="_idIndexMarker476"/>code generator can query a record for the classes it is based on, and if that list contains the <code>CommutableInst</code> class, then it can set the flag internally.</p>&#13;
			<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Creating multiple records at once with multiclasses</h2>&#13;
			<p>Another <a id="_idIndexMarker477"/>often-used statement is <code>multiclass</code>. A multiclass allows you to define multiple records at once. Let’s expand the example to show why this can be useful.</p>&#13;
			<p>The definition of an <code>add</code> instruction is very simplistic. In reality, a CPU often has several <code>add</code> instructions. A common variant is that one instruction has two register operands while another instruction has one register operand and an immediate operand, which is a small number. Assume that for the instruction having an immediate operand, the designer of the instruction set decided to mark them with <code>i</code> as a suffix. So, we end up with the <code>add</code> and <code>addi</code> instructions. Further, assume that the opcodes differ by <code>1</code>. Many arithmetic and logical instructions follow this scheme; therefore, you want the definition to be as compact as possible.</p>&#13;
			<p>The first challenge is that you need to manipulate values. There is a limited number of operators that you can use to modify a value. For example, to produce the sum of <code>1</code> and the value of the field opcode, you write:</p>&#13;
			<pre class="source-code">&#13;
!add(opcode, 1)</pre>			<p>Such an expression is best used as an argument for a class. Testing a field value and then changing it based on the found value is generally not possible because it requires dynamic statements that are not available. Always remember that all calculations are done while the records are constructed!</p>&#13;
			<p>In a similar way, strings can be concatenated:</p>&#13;
			<pre class="source-code">&#13;
!strconcat(mnemonic,"i")</pre>			<p>Because all operators begin with an <a id="_idIndexMarker478"/>exclamation mark (<code>!</code>), they are also called <strong class="bold">bang operators</strong>. You find a full list of bang operators in the <em class="italic">Programmer’s </em><em class="italic">Reference</em>: <a href="https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators">https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators</a>.</p>&#13;
			<p>Now, you can define a multiclass. The <code>Inst</code> class serves again as the base:</p>&#13;
			<pre class="source-code">&#13;
class Inst&lt;string mnemonic, int opcode&gt; {&#13;
  string Mnemonic = mnemonic;&#13;
  int Opcode = opcode;&#13;
}</pre>			<p>The<a id="_idIndexMarker479"/> definition of a multiclass is a bit more involved, so let’s do it in steps:</p>&#13;
			<ol>&#13;
				<li>The definition of a multiclass uses a similar syntax to classes. The new multiclass is named <code>InstWithImm</code> and has two parameters, <code>mnemonic</code> and <code>opcode</code>:<pre class="source-code">&#13;
multiclass InstWithImm&lt;string mnemonic, int opcode&gt; {</pre></li>				<li>First, you define an instruction with two register operands. As in a normal record definition, you use the <code>def</code> keyword to define the record, and you use the <code>Inst</code> class to create the record content. You also need to define an empty name. We will explain later why this is necessary:<pre class="source-code">&#13;
  def "": Inst&lt;mnemonic, opcode&gt;;</pre></li>				<li>Next, you define an instruction with the immediate operand. You derive the values for the mnemonic and the opcode from the parameters of the multiclass, using bang operators. The record is named <code>I</code>:<pre class="source-code">&#13;
  def I: Inst&lt;!strconcat(mnemonic,"i"), !add(opcode, 1)&gt;;</pre></li>				<li>That is all; the class body can be closed, like so:<pre class="source-code">&#13;
}</pre></li>			</ol>&#13;
			<p>To instantiate the records, you must use the <code>defm</code> keyword:</p>&#13;
			<pre class="source-code">&#13;
defm ADD : InstWithImm&lt;"add", 0xA0&gt;;</pre>			<p>These statements result in the following:</p>&#13;
			<ol>&#13;
				<li>The <code>Inst&lt;"add", 0xA0&gt;</code> record is instantiated. The name of the record is the concatenation of the name following the <code>defm</code> keyword and of the name following <code>def</code> inside the multiclass statement, which results in the name <code>ADD</code>.</li>&#13;
				<li>The <code>Inst&lt;"addi", 0xA1&gt;</code> record is instantiated and, following the same scheme, is given the name <code>ADDI</code>.</li>&#13;
			</ol>&#13;
			<p>Let’s verify<a id="_idIndexMarker480"/> this claim with <code>llvm-tblgen</code>:</p>&#13;
			<pre class="console">&#13;
$ llvm-tblgen –print-records inst.td&#13;
------------- Classes -----------------&#13;
class Inst&lt;string Inst:mnemonic = ?, int Inst:opcode = ?&gt; {&#13;
  string Mnemonic = Inst:mnemonic;&#13;
  int Opcode = Inst:opcode;&#13;
}&#13;
------------- Defs -----------------&#13;
def ADD {       // Inst&#13;
  string Mnemonic = "add";&#13;
  int Opcode = 160;&#13;
}&#13;
def ADDI {      // Inst&#13;
  string Mnemonic = "addi";&#13;
  int Opcode = 161;&#13;
}</pre>			<p>Using a multiclass, it is very easy to generate multiple records at once. This feature is used very often!</p>&#13;
			<p>A record does not need to have a name. Anonymous records are perfectly fine. Omitting the name is all you need to do to define an anonymous record. The name of a record generated<a id="_idIndexMarker481"/> by a multiclass is made up of two names, and both names must be given to create a named record. If you omit the name after <code>defm</code>, then only anonymous records are created. Similarly, if the <code>def</code> inside the multiclass is not followed by a name, an anonymous record is created. This is the reason why the first definition in the multiclass example used the empty name <code>""</code>: without it, the record would be anonymous.</p>&#13;
			<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Simulating function calls</h2>&#13;
			<p>In some cases, using <a id="_idIndexMarker482"/>a multiclass like in the previous example can lead to repetitions. Assume that the CPU also supports memory operands, in a way similar to immediate operands. You can support this by adding a new record definition to the multiclass:</p>&#13;
			<pre class="source-code">&#13;
multiclass InstWithOps&lt;string mnemonic, int opcode&gt; {&#13;
  def "": Inst&lt;mnemonic, opcode&gt;;&#13;
  def "I": Inst&lt;!strconcat(mnemonic,"i"), !add(opcode, 1)&gt;;&#13;
  def "M": Inst&lt;!strconcat(mnemonic,"m"), !add(opcode, 2)&gt;;&#13;
}</pre>			<p>This is perfectly fine. But now, imagine you do not have 3 but 16 records to define, and you need to do this multiple times. A typical scenario where such a situation can arise is when the CPU supports many vector types, and the vector instructions vary slightly based on the used type.</p>&#13;
			<p>Please note that all three lines with the <code>def</code> statement have the same structure. The variation is only in the suffix of the name and of the mnemonic, and the delta value is added to the opcode. In C, you could put the data into an array and implement a function that returns the data based on an index value. Then, you could create a loop over the data instead of manually repeating statements.</p>&#13;
			<p>Amazingly, you can do something similar in the TableGen language! Here is how to transform the example:</p>&#13;
			<ol>&#13;
				<li>To store the data, you define a class with all required fields. The class is called <code>InstDesc</code>, because it describes some properties of an instruction:<pre class="source-code">&#13;
class InstDesc&lt;string name, string suffix, int delta&gt; {&#13;
  string Name = name;&#13;
  string Suffix = suffix;&#13;
  int Delta = delta;&#13;
}</pre></li>				<li>Now, you<a id="_idIndexMarker483"/> can define records for each operand type. Note that it exactly captures the differences observed in the data:<pre class="source-code">&#13;
def RegOp : InstDesc&lt;"", "", 0&gt;;&#13;
def ImmOp : InstDesc&lt;"I", """, 1&gt;;&#13;
def MemOp : InstDesc"""","""", 2&gt;;</pre></li>				<li>Imagine you have a loop enumerating the numbers <code>0</code>, <code>1</code>, and <code>2</code>, and you want to select one of the previously defined records based on the index. How can you do this? The solution is to create a <code>getDesc</code> class that takes the index as a parameter. It has a single field, <code>ret</code>, that you can interpret as a return value. To assign the correct value to this field, the <code>!cond</code> operator is used:<pre class="source-code">&#13;
class getDesc&lt;int n&gt; {&#13;
  InstDesc ret = !cond(!eq(n, 0) : RegOp,&#13;
                       !eq(n, 1) : ImmOp,&#13;
                       !eq(n, 2) : MemOp);&#13;
}</pre><p class="list-inset">This operator works similarly to a <code>switch</code>/<code>case</code> statement in C.</p></li>				<li>Now, you are ready to define the multiclass. The TableGen language has a <code>loop</code> statement, and it also allows us to define variables. But remember that there is no dynamic execution! As a consequence, the loop range is statically defined, and you can assign a value to a variable, but you cannot change that value later. However, this is enough to retrieve the data. Please note how the use of the <code>getDesc</code> class resembles a function call. But there is no function call! Instead, an anonymous<a id="_idIndexMarker484"/> record is created, and the values are taken from that record. Lastly, the past operator (<code>#</code>) performs a string concatenation, similar to the <code>!strconcat</code> operator used earlier:<pre class="source-code">&#13;
multiclass InstWithOps&lt;string mnemonic, int opcode&gt; {&#13;
  foreach I = 0-2 in {&#13;
    defvar Name = getDesc&lt;I&gt;.ret.Name;&#13;
    defvar Suffix = getDesc&lt;I&gt;.ret.Suffix;&#13;
    defvar Delta = getDesc&lt;I&gt;.ret.Delta;&#13;
    def Name: Inst&lt;mnemonic # Suffix,&#13;
                   !add(opcode, Delta)&gt;;&#13;
  }&#13;
}</pre></li>				<li>Now, you use the multiclass as before to define records:<pre class="source-code">&#13;
defm ADD : InstWithOps&lt;"add", 0xA0&gt;;</pre></li>			</ol>&#13;
			<p>Please run <code>llvm-tblgen</code> and examine the records. Besides the various <code>ADD</code> records, you will also see a couple of anonymous records generated by the use of the <code>getDesc</code> class.</p>&#13;
			<p>This technique is used in the instruction definition of several LLVM backends. With the knowledge you have acquired, you should have no problem understanding those files.</p>&#13;
			<p>The <code>foreach</code> statement used the syntax <code>0-2</code> to denote the bounds of the range. This is called a <code>0...3</code>), which is useful if the numbers are negative. Lastly, you are not restricted to numerical ranges; you can also loop over a list of elements, which allows you to use strings or previously defined records. For example, you may like the use of the <code>foreach</code> statement, but you think that using the <code>getDesc</code> class is too complicated. In this case, looping over the <code>InstDesc</code> records is the solution:</p>&#13;
			<pre class="source-code">&#13;
multiclass InstWithOps&lt;string mnemonic, int opcode&gt; {&#13;
  foreach I = [RegOp, ImmOp, MemOp] in {&#13;
    defvar Name = I.Name;&#13;
    defvar Suffix = I.Suffix;&#13;
    defvar Delta = I.Delta;&#13;
    def Name: Inst&lt;mnemonic # Suffix, !add(opcode, Delta)&gt;;&#13;
  }&#13;
}</pre>			<p>So far, you <a id="_idIndexMarker486"/>only defined records in the TableGen language, using the most commonly used statements. In the next section, you’ll learn how to generate C++ source code from records defined in the TableGen language.</p>&#13;
			<h1 id="_idParaDest-136"><a id="_idTextAnchor140"/>Generating C++ code from a TableGen file</h1>&#13;
			<p>In the <a id="_idIndexMarker487"/>previous section, you defined records in the TableGen language. To make use of those records, you need to write your own TableGen backend that can produce C++ source code or do other things using the records as input.</p>&#13;
			<p>In <a href="B19561_03.xhtml#_idTextAnchor055"><em class="italic">Chapter 3</em></a>, <em class="italic">Turning the Source File into an Abstract Syntax Tree</em>, the implementation of the <code>Lexer</code> class uses a database file to define tokens and keywords. Various query functions make use of that database file. Besides that, the database file is used to implement a keyword filter. The keyword filter is a hash map, implemented using the <code>llvm::StringMap</code> class. Whenever an identifier is found, the keyword filter is called to find out if the identifier is actually a keyword. If you take a closer look at the implementation using the <code>ppprofiler</code> pass from <a href="B19561_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Advanced IR Generation</em>, then you will see that this function is called quite often. Therefore, it may be useful to experiment with different implementations to make that functionality as fast as possible.</p>&#13;
			<p>However, this is not as easy as it seems. For example, you can try to replace the lookup in the hash map with a binary search. This requires that the keywords in the database file are sorted. Currently, this seems to be the case, but during development, a new keyword might be added in the wrong place undetected. The only way to make sure that the keywords are in the right order is to add some code that checks the order at runtime.</p>&#13;
			<p>You can speed<a id="_idIndexMarker488"/> up the standard binary search by changing the memory layout. For example, instead of sorting the keywords, you can use the Eytzinger layout, which enumerates the search tree in breadth-first order. This layout increases the cache locality of the data and therefore speeds up the search. Personally speaking, maintaining the keywords in breadth-first order manually in the database file is not possible.</p>&#13;
			<p>Another popular approach for searching is the generation of minimal perfect hash functions. If you insert a new key into a dynamic hash table such as <code>llvm::StringMap</code>, then that key might be mapped to an already occupied slot. This is called a <code>gperf</code> GNU tool.</p>&#13;
			<p>In summary, there is some incentive to be able to generate a lookup function from keywords. So, let’s move the database file to TableGen!</p>&#13;
			<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Defining data in the TableGen language</h2>&#13;
			<p>The <code>TokenKinds.def</code> database <a id="_idIndexMarker491"/>file defines three different macros. The <code>TOK</code> macro is used for tokens that do not have a fixed spelling – for example, for integer literals. The <code>PUNCTUATOR</code> macro is used for all kinds of punctuation marks and includes a preferred spelling. Lastly, the <code>KEYWORD</code> macro defines a keyword that is made up of a literal and a flag, which is used to indicate at which language level this literal is a keyword. For example, the <code>thread_local</code> keyword was added to C++11.</p>&#13;
			<p>One way to express this in the TableGen language is to create a <code>Token</code> class that holds all the data. You can then add subclasses of that class to make the usage more comfortable. You also need a <code>Flag</code> class for flags defined together with a keyword. And last, you need a class to define a keyword filter. These classes define the basic data structure and can be potentially reused in other projects. Therefore, you create a <code>Keyword.td</code> file for it. Here are the steps:</p>&#13;
			<ol>&#13;
				<li>A flag is<a id="_idIndexMarker492"/> modeled as a name and an associated value. This makes it easy to generate an enumeration from this data:<pre class="source-code">&#13;
class Flag&lt;string name, int val&gt; {&#13;
    string Name = name;&#13;
    int Val = val;&#13;
}</pre></li>				<li>The <code>Token</code> class is used as the base class. It just carries a name. Please note that this class has no parameters:<pre class="source-code">&#13;
class Token {&#13;
    string Name;&#13;
}</pre></li>				<li>The <code>Tok</code> class has the same function as the corresponding <code>TOK</code> macro from the database file. it represents a token without fixed spellings. It derives from the base class, <code>Token</code>, and just adds initialization for the name:<pre class="source-code">&#13;
class Tok&lt;string name&gt; : Token {&#13;
    let Name = name;&#13;
}</pre></li>				<li>In the same way, the <code>Punctuator</code> class resembles the <code>PUNCTUATOR</code> macro. It adds a field for the spelling of the token:<pre class="source-code">&#13;
class Punctuator&lt;string name, string spelling&gt; : Token {&#13;
    let Name = name;&#13;
    string Spelling = spelling;&#13;
}</pre></li>				<li>And last, the <code>Keyword</code> class needs a list of flags:<pre class="source-code">&#13;
class Keyword&lt;string name, list&lt;Flag&gt; flags&gt; : Token {&#13;
    let Name = name;&#13;
    list&lt;Flag&gt; Flags = flags;&#13;
}</pre></li>				<li>With <a id="_idIndexMarker493"/>these definitions in place, you can now define a class for the keyword filter, called <code>TokenFilter</code>. It takes a list of tokens as a parameter:<pre class="source-code">&#13;
class TokenFilter&lt;list&lt;Token&gt; tokens&gt; {&#13;
    string FunctionName;&#13;
    list&lt;Token&gt; Tokens = tokens;&#13;
}</pre></li>			</ol>&#13;
			<p>With these class definitions, you are certainly able to capture all the data from the <code>TokenKinds.def</code> database file. The TinyLang language does not utilize the flags, since there is only this version of the language. Real-world languages such as C and C++ have undergone a couple of revisions, and they usually require flags. Therefore, we use keywords from C and C++ as an example. Let’s create a <code>KeywordC.td</code> file, as follows:</p>&#13;
			<ol>&#13;
				<li>First, you include the class definitions created earlier:<pre class="source-code">&#13;
Include "Keyword.td"</pre></li>				<li>Next, you define flags. The value is the binary value of the flag. Note how the <code>!or</code> operator is used to create a value for the <code>KEYALL</code> flag:<pre class="source-code">&#13;
def KEYC99  : Flag&lt;"KEYC99", 0x1&gt;;&#13;
def KEYCXX  : Flag&lt;"KEYCXX", 0x2&gt;;&#13;
def KEYCXX11: Flag&lt;"KEYCXX11", 0x4&gt;;&#13;
def KEYGNU  : Flag&lt;"KEYGNU", 0x8&gt;;&#13;
def KEYALL  : Flag&lt;"KEYALL",&#13;
                   !or(KEYC99.Val, KEYCXX.Val,&#13;
                       KEYCXX11.Val , KEYGNU.Val)&gt;;</pre></li>				<li>There are tokens without a fixed spelling – for example, a comment:<pre class="source-code">&#13;
def : Tok&lt;"comment"&gt;;</pre></li>				<li>Operators are defined using the <code>Punctuator</code> class, as in this example:<pre class="source-code">&#13;
def : Punctuator&lt;"plus", "+"&gt;;&#13;
def : Punctuator&lt;"minus", "-"&gt;;</pre></li>				<li>Keywords need to use different flags:<pre class="source-code">&#13;
def kw_auto: Keyword&lt;"auto", [KEYALL]&gt;;&#13;
def kw_inline: Keyword&lt;"inline", [KEYC99,KEYCXX,KEYGNU]&gt;;&#13;
def kw_restrict: Keyword&lt;"restrict", [KEYC99]&gt;;</pre></li>				<li>And last, here’s the definition of the keyword filter:<pre class="source-code">&#13;
def : TokenFilter&lt;[kw_auto, kw_inline, kw_restrict]&gt;;</pre></li>			</ol>&#13;
			<p>Of course, this<a id="_idIndexMarker494"/> file does not include all tokens from C and C++. However, it demonstrates all possible usages of the defined TableGen classes.</p>&#13;
			<p>Based on these TableGen files, you’ll implement a TableGen backend in the next section.</p>&#13;
			<h2 id="_idParaDest-138"><a id="_idTextAnchor142"/>Implementing a TableGen backend</h2>&#13;
			<p>Since<a id="_idIndexMarker495"/> parsing and creation of records are done through an LLVM library, you only need to care about the <a id="_idIndexMarker496"/>backend implementation, which consists mostly of generating C++ source code fragments based on the information in the records. First, you need to be clear about what source code to generate before you can put it into the backend.</p>&#13;
			<h3>Sketching the source code to be generated</h3>&#13;
			<p>The output of <a id="_idIndexMarker497"/>the TableGen tool is a single file containing C++ fragments. The fragments are guarded by macros. The goal is to replace the <code>TokenKinds.def</code> database file. Based on the information in the TableGen file, you can generate the following:</p>&#13;
			<ol>&#13;
				<li>The enumeration members used to define flags. The developer is free to name the type; however, it should be based on the <code>unsigned</code> type. If the generated file is named <code>TokenKinds.inc</code>, then the intended use is this:<pre class="source-code">&#13;
enum Flags : unsigned {&#13;
#define GET_TOKEN_FLAGS&#13;
#include "TokenKinds.inc"&#13;
}</pre></li>				<li>The <code>TokenKind</code> enumeration, and the prototypes and definitions of the <code>getTokenName()</code>, <code>getPunctuatorSpelling()</code>, and <code>getKeywordSpelling()</code> functions. This code replaces the <code>TokenKinds.def</code> database file, most of the <code>TokenKinds.h</code> include file and the <code>TokenKinds.cpp</code>. source file.</li>&#13;
				<li>A new <code>lookupKeyword()</code> function that can be used instead of the current implementation using the <code>llvm::StringMap</code>. type. This is the function you want to optimize.</li>&#13;
			</ol>&#13;
			<p>Knowing what you want to generate, you can now turn to implementing the backend.</p>&#13;
			<h3>Creating a new TableGen tool</h3>&#13;
			<p>A simple <a id="_idIndexMarker498"/>structure for your new tool is to have a driver that evaluates the command-line options and calls the generation functions and the actual generator functions in a different file. Let’s call the driver file <code>TableGen.cpp</code> and the file containing the generator <code>TokenEmitter.cpp</code>. You also need a <code>TableGenBackends.h</code> header file. Let’s begin the implementation with the generation of the C++ code in the <code>TokenEmitter.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>As usual, the file begins with including the required headers. The most important one is <code>llvm/TableGen/Record.h</code>, which defines a <code>Record</code> class, used to hold records generated by parsing the <code>.</code><code>td</code> file:<pre class="source-code">&#13;
#include "TableGenBackends.h"&#13;
#include "llvm/Support/Format.h"&#13;
#include "llvm/TableGen/Record.h"&#13;
#include "llvm/TableGen/TableGenBackend.h"&#13;
#include &lt;algorithm&gt;</pre></li>				<li>To <a id="_idIndexMarker499"/>simplify coding, the <code>llvm</code> namespace is imported:<pre class="source-code">&#13;
using namespace llvm;</pre></li>				<li>The <code>TokenAndKeywordFilterEmitter</code> class is responsible for generating the C++ source code. The <code>emitFlagsFragment()</code>, <code>emitTokenKind()</code>, and <code>emitKeywordFilter()</code> methods emit the source code, as described in the previous section, <em class="italic">Sketching the source code to be generated</em>. The only public method, <code>run()</code>, calls all the code-emitting methods. The records are held in an instance of <code>RecordKeeper</code>, which is passed as a parameter to the constructor. The class is inside an anonymous namespace:<pre class="source-code">&#13;
namespace {&#13;
class TokenAndKeywordFilterEmitter {&#13;
  RecordKeeper &amp;Records;&#13;
public:&#13;
  explicit TokenAndKeywordFilterEmitter(RecordKeeper &amp;R)&#13;
      : Records(R) {}&#13;
  void run(raw_ostream &amp;OS);&#13;
private:&#13;
  void emitFlagsFragment(raw_ostream &amp;OS);&#13;
  void emitTokenKind(raw_ostream &amp;OS);&#13;
  void emitKeywordFilter(raw_ostream &amp;OS);&#13;
};&#13;
} // End anonymous namespace</pre></li>				<li>The <code>run()</code> method <a id="_idIndexMarker500"/>calls all the emitting methods. It also times the length of each phase. You specify the <code>--time-phases</code> option, and then the timing is shown after all code is generated:<pre class="source-code">&#13;
void TokenAndKeywordFilterEmitter::run(raw_ostream &amp;OS) {&#13;
  // Emit Flag fragments.&#13;
  Records.startTimer("Emit flags");&#13;
  emitFlagsFragment(OS);&#13;
  // Emit token kind enum and functions.&#13;
  Records.startTimer("Emit token kind");&#13;
  emitTokenKind(OS);&#13;
  // Emit keyword filter code.&#13;
  Records.startTimer("Emit keyword filter");&#13;
  emitKeywordFilter(OS);&#13;
  Records.stopTimer();&#13;
}</pre></li>				<li>The <code>emitFlagsFragment()</code> method shows the typical structure of a function emitting C++ source code. The generated code is guarded by the <code>GET_TOKEN_FLAGS</code> macro. To emit the C++ source fragment, you loop over all records that are derived from the <code>Flag</code> class in the TableGen file. Having such a record, it is easy to query the record for the name and the value. Please note that the names <code>Flag</code>, <code>Name</code>, and <code>Val</code> must be written exactly as in the TableGen file. If you rename <code>Val</code> to <code>Value</code> in the TableGen file, then you also need to <a id="_idIndexMarker501"/>change the string in this function. All the generated source code is written to the provided stream, <code>OS</code>:<pre class="source-code">&#13;
void TokenAndKeywordFilterEmitter::emitFlagsFragment(&#13;
    raw_ostream &amp;OS) {&#13;
  OS &lt;&lt; "#ifdef GET_TOKEN_FLAGS\n";&#13;
  OS &lt;&lt; "#undef GET_TOKEN_FLAGS\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Flag")) {&#13;
    StringRef Name = CC-&gt;getValueAsString("Name");&#13;
    int64_t Val = CC-&gt;getValueAsInt("Val");&#13;
    OS &lt;&lt; Name &lt;&lt; " = " &lt;&lt; format_hex(Val, 2) &lt;&lt; ",\n";&#13;
  }&#13;
  OS &lt;&lt; "#endif\n";&#13;
}</pre></li>				<li>The <code>emitTokenKind()</code> method emits a declaration and definition of token classification functions. Let’s have a look at emitting the declarations first. The overall structure is the same as the previous method – only more C++ source code is emitted. The generated source fragment is guarded by the <code>GET_TOKEN_KIND_DECLARATION</code> macro. Please note that this method tries to generate nicely formatted C++ code, using new lines and indentation as a human developer would do. In case the emitted source code is not correct, and you need <a id="_idIndexMarker502"/>to examine it to find the error, this will be tremendously helpful. It is also easy to make such errors: after all, you are writing a C++ function that emits C++ source code.<p class="list-inset">First, the <code>TokenKind</code> enumeration is emitted. The name for a keyword should be prefixed with a <code>kw_</code> string. The loop goes over all records of the <code>Token</code> class, and you can query the records if they are also a subclass of the <code>Keyword</code> class, which enables you to emit the prefix:</p><pre class="source-code">&#13;
  OS &lt;&lt; "#ifdef GET_TOKEN_KIND_DECLARATION\n"&#13;
     &lt;&lt; "#undef GET_TOKEN_KIND_DECLARATION\n"&#13;
     &lt;&lt; "namespace tok {\n"&#13;
     &lt;&lt; "  enum TokenKind : unsigned short {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Token")) {&#13;
    StringRef Name = CC-&gt;getValueAsString("Name");&#13;
    OS &lt;&lt; "    ";&#13;
    if (CC-&gt;isSubClassOf("Keyword"))&#13;
      OS &lt;&lt; "kw_";&#13;
    OS &lt;&lt; Name &lt;&lt; ",\n";&#13;
  }&#13;
  OS &lt;&lt; „    NUM_TOKENS\n"&#13;
     &lt;&lt; „  };\n";</pre></li>				<li>Next, the function declarations are emitted. This is only a constant string, so nothing exciting happens. This finishes emitting the declarations:<pre class="source-code">&#13;
  OS &lt;&lt; "  const char *getTokenName(TokenKind Kind) "&#13;
        "LLVM_READNONE;\n"&#13;
     &lt;&lt; "  const char *getPunctuatorSpelling(TokenKind "&#13;
        "Kind) LLVM_READNONE;\n"&#13;
     &lt;&lt; "  const char *getKeywordSpelling(TokenKind "&#13;
        "Kind) "&#13;
        "LLVM_READNONE;\n"&#13;
     &lt;&lt; "}\n"&#13;
     &lt;&lt; "#endif\n";</pre></li>				<li>Now, let’s turn <a id="_idIndexMarker503"/>to emitting the definitions. Again, this generated code is guarded by a macro called <code>GET_TOKEN_KIND_DEFINITION</code>. First, the token names are emitted into a <code>TokNames</code> array, and the <code>getTokenName()</code> function uses that array to retrieve the name. Please note that the quote symbol must be escaped as <code>\"</code> when used inside a string:<pre class="source-code">&#13;
  OS &lt;&lt; "#ifdef GET_TOKEN_KIND_DEFINITION\n";&#13;
  OS &lt;&lt; "#undef GET_TOKEN_KIND_DEFINITION\n";&#13;
  OS &lt;&lt; "static const char * const TokNames[] = {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Token")) {&#13;
    OS &lt;&lt; "  \"" &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; "\",\n";&#13;
  }&#13;
  OS &lt;&lt; "};\n\n";&#13;
  OS &lt;&lt; "const char *tok::getTokenName(TokenKind Kind) "&#13;
        "{\n"&#13;
     &lt;&lt; "  if (Kind &lt;= tok::NUM_TOKENS)\n"&#13;
     &lt;&lt; "    return TokNames[Kind];\n"&#13;
     &lt;&lt; "  llvm_unreachable(\"unknown TokenKind\");\n"&#13;
     &lt;&lt; "  return nullptr;\n"&#13;
     &lt;&lt; "};\n\n";</pre></li>				<li>Next, the <code>getPunctuatorSpelling()</code> function is emitted. The only notable<a id="_idIndexMarker504"/> difference to the other parts is that the loop goes over all records derived from the <code>Punctuator</code> class. Also, a <code>switch</code> statement is generated instead of an array:<pre class="source-code">&#13;
  OS &lt;&lt; "const char "&#13;
        "*tok::getPunctuatorSpelling(TokenKind "&#13;
        "Kind) {\n"&#13;
     &lt;&lt; "  switch (Kind) {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Punctuator")) {&#13;
    OS &lt;&lt; "    " &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; ": return \""&#13;
       &lt;&lt; CC-&gt;getValueAsString("Spelling") &lt;&lt; "\";\n";&#13;
  }&#13;
  OS &lt;&lt; "    default: break;\n"&#13;
     &lt;&lt; "  }\n"&#13;
     &lt;&lt; "  return nullptr;\n"&#13;
     &lt;&lt; "};\n\n";</pre></li>				<li>And finally, the <code>getKeywordSpelling()</code> function is emitted. The coding is similar to <a id="_idIndexMarker505"/>emitting <code>getPunctuatorSpelling()</code>. This time, the loop goes over all records of the <code>Keyword</code> class, and the name is again prefixed with <code>kw_</code>:<pre class="source-code">&#13;
  OS &lt;&lt; "const char *tok::getKeywordSpelling(TokenKind "&#13;
        "Kind) {\n"&#13;
     &lt;&lt; "  switch (Kind) {\n";&#13;
  for (Record *CC :&#13;
       Records.getAllDerivedDefinitions("Keyword")) {&#13;
    OS &lt;&lt; "    kw_" &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; ": return \"" &lt;&lt; CC-&gt;getValueAsString("Name")&#13;
       &lt;&lt; "\";\n";&#13;
  }&#13;
  OS &lt;&lt; "    default: break;\n"&#13;
     &lt;&lt; "  }\n"&#13;
     &lt;&lt; "  return nullptr;\n"&#13;
     &lt;&lt; «};\n\n»;&#13;
  OS &lt;&lt; «#endif\n»;&#13;
}</pre></li>				<li>The <code>emitKeywordFilter()</code> method is more complex than the previous methods since emitting the filter requires collecting some data from the records. The generated source code uses the <code>std::lower_bound()</code> function, thus implementing a binary search.<p class="list-inset">Now, let’s make a shortcut. There can be several records of the <code>TokenFilter</code> class defined in the TableGen file. For demonstration purposes, just emit at most one token filter method:</p><pre class="source-code">&#13;
  std::vector&lt;Record *&gt; AllTokenFilter =&#13;
      Records.getAllDerivedDefinitionsIfDefined(&#13;
          "TokenFilter");&#13;
  if (AllTokenFilter.empty())&#13;
    return;</pre></li>				<li>The <a id="_idIndexMarker506"/>keywords used for the filter are in the list named <code>Tokens</code>. To get access to that list, you first need to look up the <code>Tokens</code> field in the record. This returns a pointer to an instance of the <code>RecordVal</code> class, from which you can retrieve the <code>Initializer</code> instance via the calling method, <code>getValue()</code>. The <code>Tokens</code> field is defined as a list, so you cast the initializer instance to <code>ListInit</code>. If this fails, then exit the function:<pre class="source-code">&#13;
  ListInit *TokenFilter = dyn_cast_or_null&lt;ListInit&gt;(&#13;
      AllTokenFilter[0]&#13;
          -&gt;getValue("Tokens")&#13;
          -&gt;getValue());&#13;
  if (!TokenFilter)&#13;
    return;</pre></li>				<li>Now, you are ready to construct a filter table. For each keyword stored in the <code>TokenFilter</code>, list, you need the name and the value of the <code>Flag</code> field. That field is again defined as a list, so you need to loop over those elements to calculate the<a id="_idIndexMarker507"/> final value. The resulting name/flag value pair is stored in a <code>Table</code> vector:<pre class="source-code">&#13;
  using KeyFlag = std::pair&lt;StringRef, uint64_t&gt;;&#13;
  std::vector&lt;KeyFlag&gt; Table;&#13;
  for (size_t I = 0, E = TokenFilter-&gt;size(); I &lt; E;&#13;
       ++I) {&#13;
   Record *CC = TokenFilter-&gt;getElementAsRecord(I);&#13;
   StringRef Name = CC-&gt;getValueAsString("Name");&#13;
   uint64_t Val = 0;&#13;
   ListInit *Flags = nullptr;&#13;
   if (RecordVal *F = CC-&gt;getValue("Flags"))&#13;
      Flags = dyn_cast_or_null&lt;ListInit&gt;(F-&gt;getValue());&#13;
   if (Flags) {&#13;
      for (size_t I = 0, E = Flags-&gt;size(); I &lt; E; ++I) {&#13;
        Val |=&#13;
            Flags-&gt;getElementAsRecord(I)-&gt;getValueAsInt(&#13;
                "Val");&#13;
      }&#13;
   }&#13;
   Table.emplace_back(Name, Val);&#13;
  }</pre></li>				<li>To be able to perform a binary search, the table needs to be sorted. The comparison function is provided by a lambda function:<pre class="source-code">&#13;
  llvm::sort(Table.begin(), Table.end(),&#13;
             [](const KeyFlag A, const KeyFlag B) {&#13;
               return A.first &lt; B.first;&#13;
             });</pre></li>				<li>Now, you <a id="_idIndexMarker508"/>can emit the C++ source code. First, you emit the sorted table containing the name of the keyword and the associated flag value:<pre class="source-code">&#13;
  OS &lt;&lt; "#ifdef GET_KEYWORD_FILTER\n"&#13;
     &lt;&lt; "#undef GET_KEYWORD_FILTER\n";&#13;
  OS &lt;&lt; "bool lookupKeyword(llvm::StringRef Keyword, "&#13;
        "unsigned &amp;Value) {\n";&#13;
  OS &lt;&lt; "  struct Entry {\n"&#13;
     &lt;&lt; "    unsigned Value;\n"&#13;
     &lt;&lt; "    llvm::StringRef Keyword;\n"&#13;
     &lt;&lt; "  };\n"&#13;
     &lt;&lt; "static const Entry Table[" &lt;&lt; Table.size()&#13;
     &lt;&lt; "] = {\n";&#13;
  for (const auto &amp;[Keyword, Value] : Table) {&#13;
   OS &lt;&lt; "    { " &lt;&lt; Value &lt;&lt; ", llvm::StringRef(\""&#13;
      &lt;&lt; Keyword &lt;&lt; "\", " &lt;&lt; Keyword.size()&#13;
      &lt;&lt; ") },\n";&#13;
  }&#13;
  OS &lt;&lt; "  };\n\n";</pre></li>				<li>Next, you look up the keyword in the sorted table, using the <code>std::lower_bound()</code> standard C++ function. If the keyword is in the table, then the <code>Value</code> parameter receives the value of the flags associated with the keyword, and the function returns <code>true</code>. Otherwise, the function simply returns <code>false</code>:<pre class="source-code">&#13;
  OS &lt;&lt; "  const Entry *E = "&#13;
        "std::lower_bound(&amp;Table[0], "&#13;
        "&amp;Table["&#13;
     &lt;&lt; Table.size()&#13;
     &lt;&lt; "], Keyword, [](const Entry &amp;A, const "&#13;
        "StringRef "&#13;
        "&amp;B) {\n";&#13;
  OS &lt;&lt; "    return A.Keyword &lt; B;\n";&#13;
  OS &lt;&lt; "  });\n";&#13;
  OS &lt;&lt; "  if (E != &amp;Table[" &lt;&lt; Table.size()&#13;
     &lt;&lt; "]) {\n";&#13;
  OS &lt;&lt; "    Value = E-&gt;Value;\n";&#13;
  OS &lt;&lt; "    return true;\n";&#13;
  OS &lt;&lt; "  }\n";&#13;
  OS &lt;&lt; "  return false;\n";&#13;
  OS &lt;&lt; "}\n";&#13;
  OS &lt;&lt; "#endif\n";&#13;
}</pre></li>				<li>The only<a id="_idIndexMarker509"/> missing part now is a way to call this implementation, for which you define a global function, <code>EmitTokensAndKeywordFilter()</code>. The <code>emitSourceFileHeader()</code> function declared in the <code>llvm/TableGen/TableGenBackend.h</code> header emits a comment at the top of the generated file:<pre class="source-code">&#13;
void EmitTokensAndKeywordFilter(RecordKeeper &amp;RK,&#13;
                                raw_ostream &amp;OS) {&#13;
  emitSourceFileHeader("Token Kind and Keyword Filter "&#13;
                       "Implementation Fragment",&#13;
                       OS);&#13;
  TokenAndKeywordFilterEmitter(RK).run(OS);&#13;
}</pre></li>			</ol>&#13;
			<p>With that, you<a id="_idIndexMarker510"/> finished the implementation of the source emitter in the <code>TokenEmitter.cpp</code> file. Overall, the coding is not too complicated.</p>&#13;
			<p>The <code>TableGenBackends.h</code> header file only contains the declaration of the <code>EmitTokensAndKeywordFilter()</code> function. To avoid including other files, you use forward declarations for the <code>raw_ostream</code> and <code>RecordKeeper</code> classes:</p>&#13;
			<pre class="source-code">&#13;
#ifndef TABLEGENBACKENDS_H&#13;
#define TABLEGENBACKENDS_H&#13;
namespace llvm {&#13;
class raw_ostream;&#13;
class RecordKeeper;&#13;
} // namespace llvm&#13;
void EmitTokensAndKeywordFilter(llvm::RecordKeeper &amp;RK,&#13;
                                llvm::raw_ostream &amp;OS);&#13;
#endif</pre>			<p>The missing part is the implementation of the driver. Its task is to parse the TableGen file and emit the records according to the command-line options. The implementation is in the <code>TableGen.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>As usual, the implementation begins with including the required headers. The most important one is <code>llvm/TableGen/Main.h</code> because this header declares the frontend of TableGen:<pre class="source-code">&#13;
#include "TableGenBackends.h"&#13;
#include "llvm/Support/CommandLine.h"&#13;
#include "llvm/Support/PrettyStackTrace.h"&#13;
#include "llvm/Support/Signals.h"&#13;
#include "llvm/TableGen/Main.h"&#13;
#include "llvm/TableGen/Record.h"</pre></li>				<li>To<a id="_idIndexMarker511"/> simplify coding, the <code>llvm</code> namespace is imported:<pre class="source-code">&#13;
using namespace llvm;</pre></li>				<li>The user can choose one action. The <code>ActionType</code> enumeration contains all possible actions:<pre class="source-code">&#13;
enum ActionType {&#13;
  PrintRecords,&#13;
  DumpJSON,&#13;
  GenTokens,&#13;
};</pre></li>				<li>A single command-line option object called <code>Action</code> is used. The user needs to specify the <code>--gen-tokens</code> option to emit the token filter you implemented. The other two options, <code>--print-records</code> and <code>--dump-json</code>, are standard options to dump read records. Note that the object is in an anonymous namespace:<pre class="source-code">&#13;
namespace {&#13;
cl::opt&lt;ActionType&gt; Action(&#13;
    cl::desc("Action to perform:"),&#13;
    cl::values(&#13;
        clEnumValN(&#13;
            PrintRecords, "print-records",&#13;
            "Print all records to stdout (default)"),&#13;
        clEnumValN(DumpJSON, "dump-json",&#13;
                   "Dump all records as "&#13;
                   "machine-readable JSON"),&#13;
        clEnumValN(GenTokens, "gen-tokens",&#13;
                   "Generate token kinds and keyword "&#13;
                   "filter")));</pre></li>				<li>The <code>Main()</code> function performs the requested action based on the value of <code>Action</code>. Most importantly, your <code>EmitTokensAndKeywordFilter()</code> function<a id="_idIndexMarker512"/> is called if <code>--gen-tokens</code> was specified on the command line. After the end of the function, the anonymous namespace is closed:<pre class="source-code">&#13;
bool Main(raw_ostream &amp;OS, RecordKeeper &amp;Records) {&#13;
  switch (Action) {&#13;
  case PrintRecords:&#13;
    OS &lt;&lt; Records; // No argument, dump all contents&#13;
    break;&#13;
  case DumpJSON:&#13;
    EmitJSON(Records, OS);&#13;
    break;&#13;
  case GenTokens:&#13;
    EmitTokensAndKeywordFilter(Records, OS);&#13;
    break;&#13;
  }&#13;
  return false;&#13;
}&#13;
} // namespace</pre></li>				<li>And lastly, you <a id="_idIndexMarker513"/>define a <code>main()</code> function. After setting up the stack trace handler and parsing the command-line options, the <code>TableGenMain()</code> function is called to parse the TableGen file and create records. That function also calls your <code>Main()</code> function if there are no errors:<pre class="source-code">&#13;
int main(int argc, char **argv) {&#13;
  sys::PrintStackTraceOnErrorSignal(argv[0]);&#13;
  PrettyStackTraceProgram X(argc, argv);&#13;
  cl::ParseCommandLineOptions(argc, argv);&#13;
  llvm_shutdown_obj Y;&#13;
  return TableGenMain(argv[0], &amp;Main);&#13;
}</pre></li>			</ol>&#13;
			<p>Your own TableGen tool is now implemented. After compiling, you can run it with the <code>KeywordC.td</code> sample input file as follows:</p>&#13;
			<pre class="console">&#13;
$ tinylang-tblgen --gen-tokens –o TokenFilter.inc KeywordC.td</pre>			<p>The generated C++ source code is written to the <code>TokenFilter.inc</code> file.</p>&#13;
			<p class="callout-heading">Performance of the token filter</p>&#13;
			<p class="callout">Using a<a id="_idIndexMarker514"/> plain binary search for the keyword filter does not give a better performance than the implementation based on the <code>llvm::StringMap</code> type. To beat the performance of the current implementation, you need to generate a perfect hash function.</p>&#13;
			<p class="callout">The classic algorithm from Czech, Havas, and Majewski can be easily implemented, and it gives you a very good performance. It is described in <em class="italic">An optimal algorithm for generating minimal perfect hash functions</em>, <em class="italic">Information Processing Letters</em>, <em class="italic">Volume 43</em>, <em class="italic">Issue 5</em>, <em class="italic">1992</em>. See https://www.sciencedirect.com/science/article/abs/pii/002001909290220P.</p>&#13;
			<p class="callout">A state-of-the-art algorithm is PTHash from Pibiri and Trani, described in <em class="italic">PTHash: Revisiting FCH Minimal Perfect Hashing</em>, <em class="italic">SIGIR ’21</em>. See <a href="https://arxiv.org/pdf/2104.10402.pdf">https://arxiv.org/pdf/2104.10402.pdf</a>.</p>&#13;
			<p class="callout">Both algorithms are good candidates for generating a token filter that is actually faster than <code>llvm::StringMap</code>.</p>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor143"/>Drawbacks of TableGen</h1>&#13;
			<p>Here are a few<a id="_idIndexMarker515"/> drawbacks of TableGen:</p>&#13;
			<ul>&#13;
				<li>The TableGen language is built on a simple concept. As a consequence, it does not have the same computing capabilities as other DSLs. Obviously, some programmers would like to replace TableGen with a different, more powerful language, and this topic comes up from time to time in the LLVM discussion forum.</li>&#13;
				<li>With the possibility of implementing your own backends, the TableGen language is very flexible. However, it also means that the semantics of a given definition are hidden inside the backend. Thus, you can create TableGen files that are basically not understandable by other developers.</li>&#13;
				<li>And last, the <a id="_idIndexMarker516"/>backend implementation can be very complex if you try to solve a non-trivial task. It is reasonable to expect that this effort would be lower if the TableGen language were more powerful.</li>&#13;
			</ul>&#13;
			<p>Even if not all developers are happy with the capabilities of TableGen, the tool is used widely in LLVM, and for a developer, it is important to understand it.</p>&#13;
			<h1 id="_idParaDest-140"><a id="_idTextAnchor144"/>Summary</h1>&#13;
			<p>In this chapter, you first learned the main idea behind TableGen. Then, you defined your first classes and records in the TableGen language, and you acquired knowledge of the syntax of TableGen. Finally, you developed a TableGen backend emitting fragments of C++ source code, based on the TableGen classes you defined.</p>&#13;
			<p>In the next chapter, we examine another unique feature of LLVM: generating and executing code in one step, also known as <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) compilation.</p>&#13;
		</p>&#13;
	</div></body></html>