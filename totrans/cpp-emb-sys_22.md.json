["```cpp\n#include <cstdio>\n#include <cstdint>\nclass accelerometer {\npublic:\nstruct data {\n    float x;\n    float y;\n    float z;\n};\nenum class sampling_rate {\n    c_20_hz,\n    c_50_hz,\n    c_100_hz,\n};\nenum error {\n      ok,\n      not_supported\n};\nvirtual error set_sampling_rate(sampling_rate) = 0;\nvirtual data get_data() = 0;\n}; \n```", "```cpp\nclass i2c {\npublic:\nvirtual void write() = 0;\n};\nclass i2c_stm32 : public i2c {\npublic:\nvoid write() override {\n    printf(\"i2c::write...\\r\\n\");\n}\n};\nclass adxl_345 : public accelerometer {\npublic:\nadxl_345(i2c &i2c_obj) : i2c_(i2c_obj) {}\nerror set_sampling_rate(sampling_rate) override {\n    printf(\"adxl_345: setting sampling rate\\r\\n\");\n    i2c_.write();\n    return error::ok;\n}\ndata get_data() override {\n    return data{0.02f, 0.981f, 0.03f};\n}\nprivate:\ni2c &i2c_;\n}; \n```", "```cpp\nclass tap_detection_algo {\npublic:\ntap_detection_algo(accelerometer &accel) : accel_(accel) {\n    auto err = accel_.set_sampling_rate(\n        accelerometer::sampling_rate::c_100_hz);\n    if(err == accelerometer::error::not_supported) {\n    // try another sampling rate and adapt\n    }\n}\nbool run () {\n    auto accel_data = accel_.get_data();\n    printf(\"algo: x = %.2f, y = %.2f, z = %.2f\\r\\n\", accel_data.x, \n                                                     accel_data.y,\n                                                     accel_data.z);\n    // process data\nreturn false;\n}\nprivate:\n    accelerometer &accel_;\n}; \n```", "```cpp\nint main() {\n    i2c_stm32 i2c1;\n    adxl_345 accel(i2c1);\n\n    tap_detection_algo algo(accel);\n    algo.run();\n\n    return 0;\n} \n```", "```cpp\n#include <cmath>\n#include <algorithm>\nclass tap_detection_algo {\npublic:\ntap_detection_algo(accelerometer &accel)\n                    : accel_(accel), first_sample_(true) {}\nbool run() {\n    auto current = accel_.get_data();\n    if (first_sample_) {\n        prev_ = current;\n        first_sample_ = false;\n        return false;\n    }\n    bool tap = (std::fabs(current.x - prev_.x) > c_threshold) ||\n           (std::fabs(current.y - prev_.y) > c_threshold) ||\n               (std::fabs(current.z - prev_.z) > c_threshold);\n    prev_ = current;\t\n    return tap;\n}\nprivate:\nstatic constexpr float c_threshold = 0.5f;\naccelerometer &accel_;\naccelerometer::data prev_;\nbool first_sample_ = true;\n}; \n```", "```cpp\nclass fake_accel : public accelerometer {\npublic:\nfake_accel(const std::vector<data>& samples)\n: samples_(samples), index_(0) {}\nerror set_sampling_rate(sampling_rate) override {\n    return error::ok;\n}\ndata get_data() override {\n    if (index_ < samples_.size()) {\n        return samples_[index_++];\n    }\n    return samples_.back();\n}\nprivate:\nstd::vector<data> samples_;\nsize_t index_;\n}; \n```", "```cpp\nTEST(TapDetectionAlgoTest, DetectTapOnSuddenChange) {\nstd::vector<accelerometer::data> samples = {\n    {0.0f, 1.0f, 0.0f}, // initial reading\n    {0.0f, 1.0f, 0.0f}, // no change -> false\n    {0.0f, 2.0f, 0.0f} // significant change\n};\nfake_accel fakeAccel(samples);\ntap_detection_algo algo(fakeAccel);\nEXPECT_FALSE(algo.run());\nEXPECT_FALSE(algo.run());\nEXPECT_TRUE(algo.run());\n} \n```"]