["```cpp\nnamespace SmallWindows { \n  class NotaRationalNumber : public exception { \n    public: \n      NotaRationalNumber() {/* Empty. */} \n  }; \n\n```", "```cpp\n  class Rational { \n    public: \n      Rational(int numerator = 0, int denominator = 1); \n      Rational(const String& text); \n      Rational(const Rational &rational); \n      Rational operator=(const Rational &complex); \n      operator String() const; \n      bool operator==(const Rational &rational) const; \n      bool operator!=(const Rational &rational) const; \n      bool operator< (const Rational &rational) const; \n      bool operator<=(const Rational &rational) const; \n      bool operator> (const Rational &rational) const; \n      bool operator>=(const Rational &rational) const; \n      Rational operator+(const Rational &rational) const; \n      Rational operator-(const Rational &rational) const; \n      Rational operator*(const Rational &rational) const; \n      Rational operator/(const Rational &rational) const; \n\n```", "```cpp\n    private: \n      void Normalize(); \n      int GCD(int iNum1, int iNum2); \n      int numerator, denominator; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  Rational::Rational(int numerator /* = 0 */, \n                     int denominator /* = 1 */) \n   :numerator(numerator), \n    denominator(denominator) { \n    if (denominator == 0) { \n      throw NotaRationalNumber(); \n    } \n    Normalize(); \n  } \n\n```", "```cpp\n  Rational::Rational(const String& text) \n   :numerator(0), \n    denominator(1) { \n    String trimText(Trim(text)); \n\n```", "```cpp\n    { IStringStream totalStream(trimText); \n      TCHAR slash; \n      totalStream >> numerator >> setiosflags(ios::skipws) \n                  >> slash >> denominator; \n      if (totalStream.eof() && (denominator != 0) && \n          (slash == TEXT('/'))) { \n        Normalize(); \n        return; \n      } \n    } \n\n```", "```cpp\n    { IStringStream numeratorStream(trimText); \n      numeratorStream >> numerator; \n      if (numeratorStream.eof()) { \n        return; \n      } \n    } \n\n```", "```cpp\n    throw NotaRationalNumber(); \n  } \n\n```", "```cpp\n  Rational::Rational(const Rational &rational) \n   :numerator(rational.numerator), \n    denominator(rational.denominator) { \n    // Empty. \n  } \n\n```", "```cpp\n  Rational Rational::operator=(const Rational &rational) { \n    numerator = rational.numerator; \n    denominator = rational.denominator; \n    return *this; \n  } \n\n```", "```cpp\n  Rational::operator String() const { \n    OStringStream outStream; \n\n    if (denominator == 1) { \n      outStream << numerator; \n    } \n    else { \n      outStream << numerator << TEXT(\"/\") << denominator; \n    } \n\n    return outStream.str(); \n  } \n\n```", "```cpp\n  bool Rational::operator==(const Rational &rational) const { \n    return (numerator == rational.numerator) && \n           (denominator == rational.denominator); \n  } \n\n  bool Rational::operator!=(const Rational &rational) const { \n    return !(*this == rational); \n  } \n\n```", "```cpp\n  bool Rational::operator<(const Rational &rational) const { \n    return ((numerator * rational.denominator) < \n            (rational.numerator * denominator)); \n  } \n\n  bool Rational::operator<=(const Rational &rational) const { \n    return ((*this < rational) || (*this == rational)); \n  } \n\n  bool Rational::operator>(const Rational &rational) const { \n    return !(*this <= rational); \n  } \n\n  bool Rational::operator>=(const Rational &rational) const { \n    return !(*this < rational); \n  } \n\n```", "```cpp\n\n  Rational Rational::operator+(const Rational &rational) const { \n    Rational result((numerator * rational.denominator) + \n                    (rational.numerator * denominator), \n                    denominator * rational.denominator); \n    result.Normalize(); \n    return result; \n  } \n\n```", "```cpp\n\n  Rational Rational::operator-(const Rational &rational) const { \n    Rational result((numerator * rational.denominator) - \n                    (rational.numerator * denominator), \n                    denominator * rational.denominator); \n\n    result.Normalize(); \n    return result; \n  } \n\n```", "```cpp\n  Rational Rational::operator*(const Rational &rational) const { \n    Rational result(numerator * rational.numerator, \n                    denominator * rational.denominator); \n    result.Normalize(); \n    return result; \n  } \n\n```", "```cpp\n  Rational Rational::operator/(const Rational &rational) const { \n    assert(rational.numerator != 0); \n    Rational result(numerator * rational.denominator, \n                    denominator * rational.numerator); \n    result.Normalize(); \n    return result; \n  } \n\n```", "```cpp\n  void Rational::Normalize() { \n    if (numerator == 0) { \n      denominator = 1; \n      return; \n    } \n\n```", "```cpp\n    if (denominator < 0) { \n      numerator = -numerator; \n      denominator = -denominator; \n    } \n\n```", "```cpp\n    int gcd = GCD(abs(numerator), denominator); \n    numerator /= gcd; \n    denominator /= gcd; \n  } \n\n```", "```cpp\n  int Rational::GCD(int number1, int number2) { \n    if (number1 > number2) { \n      return GCD(number1 - number2, number2); \n    } \n    else if (number1 < number2) { \n      return GCD(number1, number2 - number1); \n    } \n    else { \n      return number1; \n    } \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class NotaComplexNumber : public exception { \n    public: \n      NotaComplexNumber() {/* Empty. */} \n  }; \n\n  extern double Square(double value); \n\n```", "```cpp\n  class Complex { \n    public: \n      Complex(double x = 0, double y = 0); \n      Complex(const Complex &complex); \n      Complex operator=(const Complex &complex); \n      bool ReadStream(const String& text); \n      Complex(const String& text); \n      operator String() const; \n\n```", "```cpp\n      bool operator==(const Complex &complex) const; \n      bool operator!=(const Complex &complex) const; \n      bool operator<(const Complex &complex) const; \n      bool operator<=(const Complex &complex) const; \n      bool operator>(const Complex &complex) const; \n      bool operator>=(const Complex &complex) const; \n\n```", "```cpp\n      Complex operator+=(double x); \n      Complex operator+=(Complex &complex); \n      friend Complex operator+(double x, const Complex &complex); \n      friend Complex operator+(const Complex &complex, double x); \n      friend Complex operator+(const Complex &complex1, \n                               const Complex &complex2); \n\n      Complex operator-=(double x); \n      Complex operator-=(Complex &complex); \n      friend Complex operator-(double x, const Complex &complex); \n      friend Complex operator-(const Complex &complex, double x); \n      friend Complex operator-(const Complex &complex1, \n                               const Complex &complex2); \n\n      Complex operator*=(double x); \n      Complex operator*=(Complex &complex); \n      friend Complex operator*(double x, const Complex &complex); \n      friend Complex operator*(const Complex &complex, double x); \n      friend Complex operator*(const Complex &complex1, \n                               const Complex &complex2); \n\n      Complex operator/=(double x); \n      Complex operator/=(Complex &complex); \n      friend Complex operator/(double x, const Complex &complex); \n      friend Complex operator/(const Complex &complex, double x); \n      friend Complex operator/(const Complex &complex1, \n                               const Complex &complex2); \n\n```", "```cpp\n      double Abs() const {return sqrt(Square(x) + Square(y));} \n      operator double() const {return Abs();} \n\n    private: \n      double x, y; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  double Square(double value) { \n    return value * value; \n  } \n\n  Complex::Complex(double x, double y) \n   :x(x), y(y) { \n    // Empty. \n  } \n\n  Complex::Complex(const Complex &complex) \n   :x(complex.x), \n    y(complex.y) { \n    // Empty. \n  } \n\n  Complex Complex::operator=(const Complex &complex) { \n    x = complex.x; \n    y = complex.y; \n    return *this; \n  } \n\n```", "```cpp\n  void ReadWhiteSpaces(IStringStream& inStream) { \n    while (true) { \n      TCHAR tChar = inStream.peek(); \n\n      if ((tChar >= 0) && (tChar <= 255) && isspace(tChar)) { \n        inStream.get(); \n      } \n      else { \n        break; \n      } \n    } \n  } \n\n```", "```cpp\n  TCHAR Peek(IStringStream& inStream) { \n    ReadWhiteSpaces(inStream); \n\n    if (inStream.eof()) { \n      return TEXT('\\0'); \n    } \n    else { \n      return (TCHAR) inStream.peek(); \n    } \n  } \n\n```", "```cpp\nbool ReadI(IStringStream& inStream) { \n    if (tolower(Peek(inStream)) == TEXT('i')) { \n      inStream.get(); \n      return true; \n    }  \n    return false; \n  } \n\n```", "```cpp\n  bool ReadSign(IStringStream& inStream, TCHAR& sign) { \n    TCHAR tChar = Peek(inStream); \n\n    switch (tChar) { \n      case TEXT('+'): \n        inStream.get(); \n        sign = TEXT('+'); \n        return true; \n\n      case TEXT('-'): \n        inStream.get(); \n        sign = TEXT('-'); \n        return true; \n\n      default: \n        return false; \n    } \n  } \n\n```", "```cpp\n  bool ReadValue(IStringStream& inStream, double& value) { \n    TCHAR tChar = Peek(inStream); \n\n    if ((tChar == TEXT('+')) || (tChar == TEXT('-'))) {       \n      inStream.get(); \n      tChar = Peek(inStream); \n      inStream.unget(); \n\n      if (isdigit(tChar) || (tChar == TEXT('.'))) {         \n        inStream >> value; \n        return true; \n      } \n    } \n    else if (isdigit(tChar) || (tChar == TEXT('.'))) { \n      inStream >> value; \n      return true; \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  bool EndOfLine(IStringStream& inStream) { \n    return Peek(inStream) == TEXT('\\0'); \n  } \n\n```", "```cpp\n  bool Complex::ReadStream(const String& text) { \n    IStringStream inStream(Trim(text)); \n    double value1, value2; \n    TCHAR sign1, sign2; \n\n```", "```cpp\n    if (ReadValue(inStream, value1)) { \n      if (ReadSign(inStream, sign1)) { \n        if (ReadValue(inStream, value2) && ReadI(inStream) && \n            EndOfLine(inStream)) { \n          x = value1; \n          y = (sign1 == TEXT('-')) ? -value2 : value2; \n          return true; \n        } \n\n```", "```cpp\n        else if (ReadSign(inStream, sign2)) { \n          if (ReadI(inStream) && EndOfLine(inStream)) { \n            x = value1; \n            y = (sign1 == TEXT('-')) ? -1 : 1; \n            y = (sign2 == TEXT('-')) ? -y : y; \n            return true; \n          } \n        } \n\n```", "```cpp\n        else if (ReadI(inStream) && EndOfLine(inStream)) { \n          x = value1; \n          y = (sign1 == TEXT('-')) ? -1 : 1; \n          return true; \n        } \n      } \n\n```", "```cpp\n      else if (ReadI(inStream)) { \n        if (ReadSign(inStream, sign1)) { \n          if (ReadValue(inStream, value2) && EndOfLine(inStream)){ \n            y = value1; \n            x = (sign1 == TEXT('-')) ? -value2 : value2; \n            return true; \n          } \n        } \n\n```", "```cpp\n        else if(EndOfLine(inStream)) { \n          y = value1; \n          x = 0; \n          return true; \n        } \n      } \n\n```", "```cpp\n      else if (EndOfLine(inStream)) { \n        x = value1; \n        y = 0; \n        return true; \n      } \n    } \n\n```", "```cpp\n    else if (ReadSign(inStream, sign1)) { \n      if (ReadI(inStream)) { \n        if (ReadSign(inStream, sign2)) { \n          if (ReadValue(inStream, value2) && EndOfLine(inStream)){ \n            y = (sign1 == TEXT('-')) ? -1 : 1; \n            x = (sign2 == TEXT('-')) ? -value2 : value2; \n            return true; \n          } \n        } \n\n```", "```cpp\n        else if (EndOfLine(inStream)) { \n          y = (sign1 == TEXT('-')) ? -1 : 1; \n          x = 0; \n          return true; \n        } \n      } \n    } \n\n```", "```cpp\n    else if (ReadI(inStream)) { \n      if (ReadSign(inStream, sign2)) { \n        if (ReadValue(inStream, value2) && EndOfLine(inStream)) { \n          y = 1; \n          x = (sign2 == TEXT('-')) ? -value2 : value2; \n          return true; \n        } \n      } \n\n```", "```cpp\n      else if (EndOfLine(inStream)) { \n        y = 1; \n        x = 0; \n        return true; \n      } \n    } \n\n```", "```cpp\n    return false; \n  } \n\n```", "```cpp\n  Complex::Complex(const String& text) { \n    if (!ReadStream(text)) { \n      throw NotaComplexNumber(); \n    } \n  } \n\n```", "```cpp\n  Complex::operator String() const { \n    OStringStream outStream; \n\n    if (x != 0) { \n      if (y == 1) { \n        outStream << x << TEXT(\"+i\"); \n      } \n      else if (y == -1) { \n        outStream << x << TEXT(\"-i\"); \n      } \n      else if (y != 0) { \n        outStream << x << setiosflags(ios::showpos) \n                  << y << TEXT(\"i\"); \n      } \n      else { \n        outStream << x; \n      } \n    } \n\n```", "```cpp\n    else { \n      if (y == 1) { \n        outStream << TEXT(\"i\"); \n      } \n      else if (y == -1) { \n        outStream << TEXT(\"-i\"); \n      } \n      else if (y != 0) { \n        outStream << y << TEXT(\"i\"); \n      } \n      else { \n        outStream << TEXT(\"0\"); \n      } \n    }  \n    return outStream.str(); \n  } \n\n```", "```cpp\n  bool Complex::operator==(const Complex &complex) const { \n    return ((x == complex.x) && (y == complex.y)); \n  } \n\n  bool Complex::operator!=(const Complex &complex) const { \n    return !(*this == complex); \n  } \n\n```", "```cpp\n  bool Complex::operator<(const Complex &complex) const { \n    return (Abs() < complex.Abs()); \n  } \n\n  bool Complex::operator<=(const Complex &complex) const { \n    return ((*this < complex) || (*this == complex)); \n  } \n\n  bool Complex::operator>(const Complex &complex) const { \n    return !(*this <= complex); \n  } \n\n  bool Complex::operator>=(const Complex &complex) const { \n    return !(*this < complex); \n  } \n\n```", "```cpp\n  Complex Complex::operator+=(double x) { \n    *this = (*this + Complex(x)); \n    return *this; \n  } \n\n  Complex Complex::operator+=(Complex &complex) { \n    *this = (*this + complex); \n    return *this; \n  } \n\n  Complex operator+(double x, const Complex &complex) { \n    return (Complex(x) + complex); \n  } \n\n  Complex operator+(const Complex &complex, double x) { \n    return (complex + Complex(x)); \n  } \n\n```", "```cpp\n  Complex operator+(const Complex &complex1, \n                    const Complex &complex2) { \n    return Complex(complex1.x + complex2.x, \n                   complex1.y + complex2.y); \n  } \n\n  Complex Complex::operator-=(double x) { \n    return (*this - Complex(x)); \n  } \n\n  Complex Complex::operator-=(Complex &complex) { \n    return (*this - complex); \n  } \n\n  Complex operator-(double x, const Complex &complex) { \n    return (Complex(x) - complex); \n  } \n\n  Complex operator-(const Complex &complex, double x) { \n    return (complex - Complex(x)); \n  } \n\n```", "```cpp\n  Complex operator-(const Complex &complex1, \n                    const Complex &complex2) { \n    return Complex(complex1.x - complex2.x, \n                   complex1.y - complex2.y); \n  } \n\n  Complex Complex::operator*=(double x) { \n    *this = (*this * Complex(x)); \n    return *this; \n  } \n\n  Complex Complex::operator*=(Complex &complex) { \n    *this = (*this * complex); \n    return *this; \n  } \n\n  Complex operator*(double x, const Complex &complex) { \n    return (Complex(x) * complex); \n  } \n\n  Complex operator*(const Complex &complex, double x) { \n    return (complex * Complex(x)); \n  } \n\n```", "```cpp\n  Complex operator*(const Complex &complex1, \n                    const Complex &complex2) { \n    return Complex((complex1.x * complex2.x) - \n                   (complex1.y * complex2.y), \n                   (complex1.x * complex2.y) + \n                   (complex2.x * complex1.y)); \n  } \n\n  Complex Complex::operator/=(double x) { \n    *this = (*this / Complex(x)); \n    return *this; \n  } \n\n  Complex Complex::operator/=(Complex &complex) { \n    *this = (*this / complex); \n    return *this; \n  } \n\n  Complex operator/(double x, const Complex &complex) { \n    return (Complex(x) / complex); \n  } \n\n  Complex operator/(const Complex &complex, double x) { \n    return (complex / Complex(x)); \n  } \n\n```", "```cpp\n  Complex operator/(const Complex &complex1, \n                    const Complex &complex2) { \n    double sum = Square(complex2.x) + Square(complex2.y); \n    double x = ((complex1.x * complex2.x) + \n                (complex1.y * complex2.y)) / sum,    \n           y = ((complex2.x * complex1.y) + \n                (complex1.x * complex2.y)) / sum; \n    return Complex(x, y); \n  } \n}; \n\n```"]