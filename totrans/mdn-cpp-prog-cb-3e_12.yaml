- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ 20 Core Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new C++20 standard is a major step in the development of the C++ language.
    C++20 brings many new features both to the language and to the standard library.
    Some of these have already been discussed in previous chapters, such as the text
    formatting library, the calendar extensions to the chrono library, the changes
    to the thread support library, and many others. However, the features that impact
    the language the most are modules, concepts, coroutines, and the new ranges library.
    The specification of these features is very lengthy, which makes it difficult
    to cover them in great detail in this book. Therefore, in this chapter, we will
    look at the most important aspects and use cases of these features. This chapter
    is intended to help you start using these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding module partitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying requirements on template arguments with concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using requires expressions and clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring abbreviated function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over collections with the ranges library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the standard range adaptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a range to a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own range view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constrained algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine task type for asynchronous computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine generator type for sequences of values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a sequence of values with the std::generator type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start this chapter by learning about modules, which are the most disruptive
    change that’s happened to the C++ language in decades.
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are one of the most important changes in the C++20 standard. They represent
    a fundamental change to the C++ language and the way we write and consume code.
    Modules are made available in source files that are compiled separately from the
    translation units that consume them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules provide multiple advantages, especially in comparison to the use of
    header files:'
  prefs: []
  type: TYPE_NORMAL
- en: They are only imported once, and the order they’re imported in does not matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not require splitting interfaces and implementation in different source
    files, although this is still possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules have the potential to reduce compilation time, in some cases significantly.
    The entities exported from a module are described in a binary file that the compiler
    can process faster than traditional precompiled headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, this file can potentially be used to build integrations and interoperability
    with C++ code from other languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to get started with modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the major compilers (VC++, Clang, and GCC) provide different
    levels of support for modules. Build systems, such as CMake, are lagging in terms
    of adoption for modules (although this is likely to change in the near future).
    Because different compilers have different ways of, and different compiler options
    for, supporting modules, this book will not provide details on how to build these
    samples. You are invited to consult online documentation for specific compilers.
  prefs: []
  type: TYPE_NORMAL
- en: The source code accompanying this book includes scripts for building the source
    code presented in this recipe and the next one, using the MSVC compiler (cl.exe)
    from Visual Studio 2019 16.8 and, respectively, Visual Studio 2022 17.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of module files: *module interface units*, *module
    interface partitions*, and *module implementation partitions*. In this recipe,
    we’ll refer solely to the first; the other two, we will learn about in the next
    recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you modularize your code, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import a module using the `import` directive, followed by the module name.
    The standard library is available in the `std` module, but only starting with
    C++23\. This allows us to write the following in C++23:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Export a module by creating a **module interface unit** (**MIU**) that can
    contain functions, types, constants, and even macros. Their declaration must be
    preceded by the keyword `export`. The module interface unit file must have the
    extension `.ixx` for VC++. Clang accepts different extensions, including `.cpp`,
    `.cppm`, and even `.ixx`. The following sample exports a class template called
    `point`, a function called `distance()` that computes the distance between two
    points, and a user-defined literal operator called `_ip` that creates objects
    of the type `point` from strings, in the form `"0,0"` or `"12,-3"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `import` directive to also import the content of a header. The example
    presented here uses the same type and functions seen in the preceding example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A module unit is composed of several parts, mandatory or optional:'
  prefs: []
  type: TYPE_NORMAL
- en: The *global module fragment*, introduced with a `module;` statement. This part
    is optional and, if present, may only contain preprocessor directives. Everything
    that is added here is said to belong to the *global module*, which is a collection
    of all the global module fragments and all the translation units that are not
    modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *module declaration*, which is a required statement of the form `export`
    `module name;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *module preamble*, which is optional and may only contain import declarations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *module purview*, which is the content of the unit, starting with the module
    declaration and extending to the end of the module unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a module unit containing all of the aforementioned
    parts. On the left side, we have the source code of the module, and on the right
    side, the module parts are explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: An example of a module (on the left side) with each part highlighted
    and explained (on the right side)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A module can export any entity, such as functions, classes, and constants.
    Every export must be preceded by the `export` keyword. This keyword is always
    the first keyword, preceding others such as `class`/`struct`, `template`, or `using`.
    Several examples have been provided in the **geometry** module shown in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: An E class template called `point`, which represents a point in the two-dimensional
    space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type alias for `point<int>` called `int_point`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compile-time constant called `int_point_zero`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function template, `distance()`, that computes the distance between two points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user-defined literal `_ip` that creates `int_point` objects from strings such
    as `"3,4"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A translation unit that uses modules instead of headers does not require any
    other changes, except for replacing `#include` preprocessor directives with `import`
    directives. Moreover, headers can also be imported as modules using the same `import`
    directive, as shown in an example earlier.
  prefs: []
  type: TYPE_NORMAL
- en: There is no relationship between modules and namespaces. These two are independent
    concepts. The module `geometry` exports the user-defined literal `""_ip` in the
    namespace `geometry_literals`, while all the other exports in the module are available
    in the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: There is also no relationship between the module names and the name of the unit
    file. The geometry module was defined in a file called `geometry.ixx`/`.cppm`,
    although any filename would have had the same result. It is recommended that you
    follow a consistent naming scheme and use the module name for the module filename
    too. On the other hand, the extension used for module units differs with each
    compiler, although this could be something that may change in the future when
    module support reaches maturity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to C++23, the standard library was not yet modularized. However, compilers
    have already made it available in modules. The Clang compiler provides a different
    module for each header. On the other hand, the Visual C++ compiler provides the
    following modules for the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std.regex`: The content of the `<regex>` header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.filesystem`: The content of the `<filesystem>` header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.memory`: The content of the `<memory>` header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.threading`: The content of the headers `<atomic>`, `<condition_variable>`,
    `<future>`, `<mutex>`, `<shared_mutex>`, and `<thread>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.core`: The rest of the C++ standard library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from these module names, such as `std.core` or `std.regex`, the
    name of the module can be a series of identifiers concatenated with a dot (`.`).
    The dot has no significance other than helping to split the name into parts representing
    a logical hierarchy, such as `company.project.module`. The use of a dot can arguably
    provide better readability compared to the use of an underscore (such as in `std_core`
    or `std_regex`), which is also legal, like anything else that may form an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++23 standard, on the other hand, provides two standardized named modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std`, which imports everything from the C++ standard headers (such as `<vector>`,
    `<string>`, `<algorithm>`, etc.) and C wrapper headers (such as `<cstdio>`) into
    the `std` namespace. You should use this module if you qualify everything with
    `std` and don’t want to pollute the global namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.compat`, which imports everything that `std` does and, in addition, the
    global namespace counterparts of the C wrapper headers. For instance, if `std`
    imports `std::fopen` and `std::fclose` (along with everything else) from `<cstdio>`,
    then `std.compat` imports `::fopen` and `::fclose`. You should use this module
    if you want to migrate code more easily without having to qualify names with the
    `std` namespace (such as `std::fopen` instead of `fopen`, `std::size_t` instead
    of `size_t`, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a programmer, you are familiar with the typical introductory program to
    any programming language called *“Hello, world!”* that simply prints this text
    to the console. In C++, the canonical form of this program used to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++23, with support for standardized modules and the new printing capabilities
    of the text formatting library, this program can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can check whether the standard modules `std` and `std.compat` are available
    using the `__cpp_lib_modules` feature macro.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding module partitions*, to learn about interface and implementation
    partitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding module partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code of a module may become large and difficult to maintain. Moreover,
    a module may be composed of logically separate parts. To help with scenarios such
    as these, modules support composition from parts called *partitions*. A module
    unit that is a partition that exports entities is called a *module interface partition*.
  prefs: []
  type: TYPE_NORMAL
- en: However, there could also be internal partitions that do not export anything.
    Such a partition unit is called a *module implementation partition*. In this recipe,
    you will learn how to work with interface and implementation partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the previous recipe, *Working with modules*, before continuing
    with this one. You will need both the module fundamentals we discussed there and
    the code examples that we will continue with in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we will use the `std` module, which is only available
    in C++23\. For previous versions, use `std.core` in VC++ or other particular modules
    supported by your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can split a module into several partitions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each partition unit must start with a statement of the form `export module`
    `modulename:partitionname;`. Only the global module fragment may precede this
    declaration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the primary module interface unit, import and then export the partitions
    with statements of the form `export import :partitionname`, such as in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code importing a module composed from multiple partitions only sees the
    module as a whole if it was built from a single module unit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is possible to create internal partitions that do not export anything but
    contain code that can be used in the same module. Such a partition must start
    with a statement of the form `module modulename:partitionname;` (without the keyword
    `export`). Different compilers may also require a different extension for the
    file containing an internal partition. For VC++, the extension must be `.cpp`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code shown earlier is a follow-up of the modules example presented in the
    previous recipe. The `geometry` module has been split into two different partitions
    called `core` and `literals`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you declare the partition, you must use the name in the form
    `modulename:partitionname`, such as in `geometry:core` and `geometry:literals`.
    This is not necessary when you import a partition elsewhere in the module. This
    can be seen both in the primary partition unit `geometry.ixx` and in the module
    interface partition `geometry-literals.ixx`. Here are the snippets again, for
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Although module partitions are distinct files, they are not available as separate
    modules or submodules to translation units using a module. They are exported together
    as a single, aggregated module. If you compare the source code in the `main.cpp`
    file with the one from the previous recipe, you will see no difference.
  prefs: []
  type: TYPE_NORMAL
- en: As with module interface units, there are no rules for naming the files containing
    partitions. However, compilers may require different extensions or support some
    particular naming schemes. For instance, VC++ uses the scheme `<module-name>-<partition-name>.ixx`,
    which simplifies build commands.
  prefs: []
  type: TYPE_NORMAL
- en: Partitions, just like modules, may contain code that is not exported from the
    module. A partition may contain no exports at all, in which case it is an internal
    partition only. Such a partition is called a *module implementation partition*.
    It is defined without using the `export` keyword in the module’s declaration.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an internal partition is the `geometry:details` partition shown
    earlier. It provides a helper function, called `split()`, to parse two integers
    separated with a comma from a string. This partition is then imported into the
    `geometry:literals` partitions, where the `split()` function is used to implement
    the user-defined literal `_ip`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Partitions are divisions of a module. However, they are not submodules. They
    do not logically exist outside of the module. There is no concept of a submodule
    in the C++ language. The code shown in this recipe using partitions could be written
    slightly differently using modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have three modules: `geometry.core`, `geometry.literals`,
    and `geometry`. Here, `geometry` imports and then re-exports the entire content
    of the first two. Because of this, the code in `main.cpp` does not need to change.'
  prefs: []
  type: TYPE_NORMAL
- en: By solely importing the `geometry` module, we get access to the content of the
    `geometry.core` and `geometry.literals` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we do not define the `geometry` module anymore, then we need to
    explicitly import the two modules, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Choosing between using partitions or multiple modules to componentize your source
    code should depend on the particularities of your project. If you use multiple
    smaller modules, you provide better granularity for imports. This can be important
    if you’re developing a large library because users should only import things they
    use (and not a very large module when they only need some functionalities).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with modules*, to explore the fundamentals of C++20 modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying requirements on template arguments with concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template metaprogramming is an important part of the C++ language, empowering
    the development of general-purpose libraries, including the standard library.
    However, template metaprogramming is not trivial. On the contrary, complex tasks
    could be tedious and difficult to get right without a lot of experience. In fact,
    the C++ Core Guidelines, an initiative created by Bjarne Stroustrup and Herb Sutter,
    have a rule called *Use template metaprogramming only when you really need to,*
    which reasons that:'
  prefs: []
  type: TYPE_NORMAL
- en: Template metaprogramming is hard to get right, slows down compilation, and is
    often very hard to maintain.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An important aspect concerning template metaprogramming has been the specification
    of constraints for type template parameters, in order to impose restrictions on
    the types that a template can be instantiated with. The C++20 concepts library
    is designed to solve this problem. A concept is a named set of constraints, and
    a constraint is a requirement for a template argument. These are used to select
    the appropriate function overloads and template specializations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can use C++20 concepts to specify requirements
    on template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin learning about concepts, let’s consider the following class
    template, called `NumericalValue`, which is supposed to hold a value of an integral
    or floating-point type. This C++11 implementation employs the use of `std::enable_if`
    to specify requirements for the `T` template argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This snippet will be the basis for the examples shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify requirements for template arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a concept using the `concept` keyword with the following form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can use one of the standard-defined concepts, available
    in the header `<concepts>` (or one of the other standard library headers):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the concept name instead of the `class` or `typename` keywords in function
    templates, class templates, or variable templates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate class templates and call function templates with no changes in
    syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A concept is a set of one or more constraints that is always defined in a namespace
    scope. The definition of a concept is similar to a variable template. The following
    snippet shows a concept being used for a variable template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Concepts cannot be constrained themselves, nor can they refer to themselves
    recursively. In the examples shown so far, the `Numerical` and `Real` concepts
    are composed of a single, atomic constraint. However, concepts can be created
    from multiple constraints. A constraint created from two constraints using the
    `&&` logical operator is called a *conjunction*, while a constraint created from
    two constraints using the `||` logical operator is called a *disjunction*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Numerical` concept defined in the *How to do it...* section was defined
    using the `std::is_arithmetic_v` type trait. However, we could have two concepts,
    `Real` and `Integral`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From these two, we can compose the `Numerical` concept, using the `||` logical
    operator. The result is a disjunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Semantically, there is no difference between these two versions of the `Numerical`
    concept, although they are defined in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand conjunctions, let’s look at another example. Consider two base
    classes, `IComparableToInt` and `IConvertibleToInt`, that are supposed to be derived
    by classes that should support comparison or conversion to `int`. These could
    be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Some classes can implement both of them, others only one or the other. The
    `SmartNumericalValue<T>` class here implements both, while `DullNumericalValue<T>`
    only implements the `IConvertibleToInt` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What we want to do is write a function template that only accepts arguments
    that are both comparable and can be converted to `int`. The `IComparableAndConvertible`
    concept shown here is a conjunction of the `IntComparable` and `IntConvertible`
    concepts. They can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Conjunctions and disjunctions are evaluated left to right and are short-circuited.
    This means that for a conjunction, the right constraint is evaluated only if the
    left one is satisfied, and for a disjunction, the right constraint is evaluated
    only if the left one is not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: The third category of constraints is *atomic constraints*. These are composed
    of an expression `E` and a mapping between the type parameters from `E` and the
    template arguments of the constrained entity, called *parameter mapping*. The
    atomic constraints are formed during *constraint normalization*, which is the
    process of transforming a constraint expression into a sequence of conjunctions
    and disjunctions of atomic constraints. An atomic constraint is checked by substituting
    the parameter mapping and the template arguments into the expression `E`. The
    result must be a valid prvalue constant expression of type `bool`; otherwise,
    the constraint is not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library defines a series of concepts that can be used to define
    compile-time requirements on template arguments. Although most of these concepts
    impose both syntactic and semantic requirements, the compiler can usually ensure
    only the former. When the semantic requirements are not met, the program is considered
    ill-formed, and the compiler is not required to provide any diagnostics about
    the problem. The standard concepts are available in several places:'
  prefs: []
  type: TYPE_NORMAL
- en: In the concepts library, in the `<concepts>` header and the `std` namespace.
    This includes core language concepts (such as `same_as`, `integral`, `floating_point`,
    `copy_constructible`, and `move_constructible`), comparison concepts (such as
    `equality_comparable` and `totally_ordered`), object concepts (such as `copyable`,
    `moveable`, and `regular`), and callable concepts (such as `invocable` and `predicate`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the algorithms library, in the `<iterator>` header and the `std` namespace.
    This includes algorithm requirements (such as `sortable`, `permutable`, and `mergeable`)
    and indirect callable concepts (such as `indirect_unary_predicate` and `indirect_binary_predicate`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the ranges library, in the `<ranges>` header and the `std::ranges` namespace.
    This includes concepts specific for ranges, such as `range`, `view`, `input_range`,
    `output_range`, `forward_range`, and `random_access_range`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concepts defined in this recipe used the already available type traits.
    However, there are many cases when requirements on template arguments cannot be
    described in this way. For this reason, concepts can be defined with a *requires
    expression*, which is a prvalue expression of type `bool`, describing a template
    argument requirement. This will be the topic of the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using requires expressions and clauses*, to learn about in-place constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using requires expressions and clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we introduced the topic of concepts and constraints,
    learning about them with the help of several examples that were solely based on
    already existing type traits. Moreover, we also used the terser syntax to specify
    concepts, with the concept name used instead of the `typename` or the `class`
    keyword in the template declaration. However, it is possible to define more complex
    concepts with the help of *requires expressions*. These are prvalues of the type
    `bool` that describe the constraints on some template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write requires expressions and an alternative
    way to specify constraints on template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class template `NumericalValue<T>` and the function template `wrap()` defined
    in the previous recipe will be used in the code snippets presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify requirements for template arguments, you can use requires expressions,
    introduced with the `requires` keyword, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a simple expression that the compiler validates for correctness. In the
    following snippet, the operator `+` must be overloaded for the `T` template argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a simple expression to require the existence of a particular function.
    In the following snippet, a function called `wrap()`, which is overloaded with
    a parameter of the `T` template argument, must exist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a type requirement, specified with the keyword `typename`, followed by
    the name of a type, optionally qualified, to specify requirements such as member
    names, class template specializations, or alias template substitutions. In the
    following snippet, the `T` template argument must have two inner types called
    `value_type` and `iterator`. Additionally, two functions, `begin()` and `end()`,
    which take a `T` argument, must be available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a compound requirement to specify the requirements of an expression, as
    well as the result of the evaluation of the expression. In the following example,
    there must be a function called `wrap()` that can be called with an argument of
    the `T` template argument type, and the result of calling the function must be
    of the `NumericalValue<T>` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Constraints on the template arguments can also be specified using a syntax,
    involving the `requires` keyword. These are called *requires clauses* and can
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a requires clause after the template parameter list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the requires clause after the last element of a function
    declarator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine a requires clause with a requires expression, instead of a named concept.
    In this case, the `requires` keyword appears twice, as shown in the following
    snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new `requires` keyword has multiple purposes. On one hand, it is used to
    introduce a requires clause that specifies constraints on template arguments.
    On the other hand, it is used to define a requires expression that is a prvalue
    of type `bool` used to define constraints on template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with C++ value categories (*lvalue*, *rvalue*, *prvalue*,
    *xvalue*, *glvalue*), you are recommended to check [https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category).
    The term *prvalue*, meaning *pure rvalue*, specifies an rvalue that is not an
    xvalue (expiring value). Examples of prvalues are literals, function calls whose
    return type is not a reference type, an enumerator, or the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: In a requires clause, the `requires` keyword must be followed by a constant
    expression of the type `bool`. The expression must be either a primary expression
    (such as `std::is_arithmetic_v<T>` or `std::integral<T>`), an expression in parentheses,
    or any sequence of such expressions joined with either the `&&` or the `||` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'A requires expression has the form `requires (parameters-list) { requirements
    }`. The parameters list is optional and can be entirely omitted (including the
    parentheses). The specified requirements may refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: The template parameters that are in scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local parameters introduced in `parameters-list`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other declarations that are visible from the enclosing context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The requirements sequence of the requires expression can contain requirements
    of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple requirements**: These are arbitrary expressions that do not start
    with the `requires` keyword. The compiler only checks its language correctness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type requirements**: These are expressions that start with the keyword `typename`
    followed by a type name, which must be valid. This enables the compiler to validate
    that a certain nested name exists, or that a class template specialization or
    an alias template substitution exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compound requirements**: They have the form `{expression} noexcept -> type-constraint`.
    The `noexcept` keyword is optional, in which case the expression must not be potentially
    throwing. The requirement for the return type, introduced with `->`, is also optional.
    However, if it is present, then `decltype(expression)` must satisfy the constraints
    imposed by `type-constraint`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested requirements**: These are more complex expressions that specify constraints
    defined as a requires expression, which can, in turn, be another nested requirement.
    A requirement that starts with the keyword `requires` is considered a nested requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before they are evaluated, the body of every name concept and every `requires`
    expression is substituted until a sequence of conjunctions and disjunctions of
    atomic constraints is obtained. This process is called *normalization*. The actual
    details of normalization and the analysis the compiler performs are beyond the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring abbreviated function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, we learned about function templates as well as lambda expressions,
    including generic and template lambdas. A generic lambda is a lambda expression
    that uses `auto` specified for one of its parameters. The result is a function
    object with a templated call operator. The same is produced as a result of defining
    a lambda template that has the advantage, over generic lambdas, of allowing better
    control over the types of the parameters. In C++20, this idea of using the `auto`
    specifier for parameter types is generalized for all functions.
  prefs: []
  type: TYPE_NORMAL
- en: This introduces a simplified syntax of defining function templates, and functions
    that are defined in this way are called **abbreviated function templates**. We
    will see in this recipe how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define the following categories of abbreviated function templates in
    C++20:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unconstrained abbreviated function templates that use the `auto` specifier
    to define parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Constrained abbreviated function templates that use concepts, specified before
    the `auto` specifier, to constrain the parameters of the function template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Constrained variadic abbreviated function templates that use the syntax seen
    above but with a parameter pack:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Constrained abbreviated lambda expressions that use the syntax seen above but
    with a lambda expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specializations of abbreviated function templates can be defined just as for
    function templates defined with the regular template syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The template syntax is considered by many rather cumbersome. Abbreviated function
    templates are meant to simplify writing some categories of function templates.
    They do so by using the `auto` specifier as a placeholder for parameter types,
    instead of the typical template syntax. The following two definitions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If the intention is to define a function template with both arguments of the
    same type, then this form of the abbreviated function template is not enough.
    These abbreviated function templates are called **unconstrained** because there
    are no constraints placed on the arguments of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such constraints can be defined with the help of concepts, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The category of abbreviated function templates is called **constrained**. The
    function above is equivalent to the following regular function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an abbreviated function template is a function template, it can also
    be specialized like any function declared with the standard template syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Constrained abbreviated function templates can also be variadic; that is, they
    have a variable number of arguments. There is nothing special about them, other
    than what we already learned in *Chapter 5*. Moreover, the syntax can also be
    used to define lambda templates. Examples of these were given in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Using generic lambdas*, to learn about the use of both generic
    lambdas and lambda templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Writing function templates* to explore the syntax for writing
    function templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Writing a function template with a variable number of arguments*,
    to see how you can write functions that take a variable number of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to learn how
    to constrain the arguments with a function template, with the help of concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over collections with the ranges library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard library provides three important pillars—containers, iterators,
    and algorithms—that enable us to work with collections. Because these algorithms
    are for general purposes and are designed to work with iterators, which define
    a range, they often require writing explicit and sometimes complex code to achieve
    simple tasks. The C++20 ranges library has been designed to solve this problem
    by providing components for handling ranges of elements. These components include
    range adapters (or views) and constrained algorithms that work with a range instead
    of iterators. In this recipe, we will look at some of these views and algorithms
    and see how they can simplify coding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following snippets, we will refer to a function called `is_prime()`,
    which takes an integer and returns a Boolean, indicating whether the number is
    prime or not. A simple implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For an efficient algorithm, which is beyond the scope of this recipe, I recommend
    the Miller–Rabin primality test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ranges library is available in the new `<ranges>` header, in the `std::ranges`
    namespace. For simplicity, the following namespace aliases will be used in this
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will explore various uses of the ranges library in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ranges library can be used to iterate through ranges with operations such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a sequence of consecutive integers with the `iota_view` / `views::iota`
    view. The following snippet prints all integers from 1 to 9:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Filter the elements of a range with `filter_view` / `views::filter`, by retaining
    only those that satisfy a predicate. The first snippet here prints all the prime
    numbers from 1 to 99\. However, the second snippet retains and prints all the
    prime numbers from a vector of integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transform the elements of a range with `transform_view` / `views::transform`
    by applying a unary function to each element. The following snippet prints the
    successor of all the prime numbers from 1 to 99:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retain only the first *N* elements of a view with `take_view` / `views::take`.
    The following snippet prints only the first 10 prime numbers from 1 and 99:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate a range in reverse order with `reverse_view` / `views::reverse`. The
    first snippet here prints the first 10 prime numbers from 99 to 1 (in descending
    order), while the second snippet prints the last 10 prime numbers from 1 to 99
    (in ascending order):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Skip the first *N* elements of a range with `drop_view` / `views::drop`. The
    snippet here prints, in ascending order, the prime numbers between 1 and 99, but
    it skips the first and last 10 primes in the sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The ranges library can also be used to call algorithms using a range instead
    of iterators. Most algorithms have overloads for this purpose. Examples are shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine the maximum element of a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sort a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy a range. The following snippet copies the elements of the range to the
    standard output stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reverse the elements of a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Count the elements of a range (that verify a predicate):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++20 ranges library provides various components for dealing with ranges
    of elements. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Range concepts, such as `range` and `view`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range access functions, such as `begin()`, `end()`, `size()`, `empty()`, and
    `data()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range factories that create sequences of elements, such as `empty_view`, `single_view`,
    and `iota_view`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range adaptors, or views, that create a lazy evaluated view from a range, such
    as `filter_view`, `transform_view`, `take_view`, and `drop_view`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A range is defined as a sequence of elements that can be iterated over with
    an iterator and an end sentinel. Ranges are of different types, depending on the
    capabilities of the iterators that define the range. The following concepts define
    types of ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **Iterator type** | **Capabilities** |'
  prefs: []
  type: TYPE_TB
- en: '| `input_range` | `input_iterator` | Can be iterated at least once for reading.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `output_range` | `output_iterator` | Can be iterated For writing. |'
  prefs: []
  type: TYPE_TB
- en: '| `forward_range` | `forward_iterator` | Can be iterated multiple times. |'
  prefs: []
  type: TYPE_TB
- en: '| `bidirectional_range` | `bidirectional_iterator` | Can be iterated also in
    reverse order. |'
  prefs: []
  type: TYPE_TB
- en: '| `random_access_range` | `random_access_iterator` | Elements can be accessed
    randomly in constant time. |'
  prefs: []
  type: TYPE_TB
- en: '| `contiguous_range` | `contiguous_iterator` | Elements are stored contiguously
    in memory. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: The list of concepts that define the types of ranges'
  prefs: []
  type: TYPE_NORMAL
- en: Because a `forward_iterator` satisfies the requirements of an `input_iterator`,
    and a `bidirectional_iterator` satisfies those of a `forward_iterator`, and so
    on (from top to bottom in the preceding table), so do the ranges. A `forward_range`
    satisfies the requirements of an `input_range`, and a `bidirectional_range` satisfies
    those of a `forward_range`, and so on. Apart from the range concepts listed in
    the preceding table, there are other range concepts. One worth mentioning is `sized_range`,
    which requires that a range must know its size in constant time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard containers meet the requirements of different range concepts.
    The most important of them are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Input range** | **Forward range** | **Bidirectional range** | **Random
    access range** | **Contiguous range** |'
  prefs: []
  type: TYPE_TB
- en: '| `forward_list` | ✓ | ✓ |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | ✓ | ✓ | ✓ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `dequeue` | ✓ | ✓ | ✓ | ✓ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `array` | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `vector` | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | ✓ | ✓ | ✓ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | ✓ | ✓ | ✓ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `multiset` | ✓ | ✓ | ✓ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `multimap` | ✓ | ✓ | ✓ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set` | ✓ | ✓ |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unordered_map` | ✓ | ✓ |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unordered_multiset` | ✓ | ✓ |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unordered_multimap` | ✓ | ✓ |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.2: A list of standard containers and the requirements they meet'
  prefs: []
  type: TYPE_NORMAL
- en: A central concept of the ranges library is the range *adaptor*, also called
    a *view*. A view is a non-owning wrapper of a range of elements that requires
    constant time to copy, move, or assign elements. Views are composable adaptations
    of ranges. However, these adaptations happen lazily, only when the view is iterated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we saw examples of using various views: filter, transform,
    take, drop, and reverse. There are a total of 16 views available in the library.
    All the views are available in the namespace `std::ranges` and have names such
    as `filter_view`, `transform_view`, `take_view`, `drop_view`, and `reverse_view`.
    However, for simplicity of use, these views can be used with expressions of the
    form `views::filter`, `views::take`, `views::reverse`, and so on. Notice that
    the types and values of these expressions are unspecified and are a compiler implementation
    detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the views work, let’s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The composition of views is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the following rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: If an adaptor `A` takes only one argument, a range `R`, then `A(R)` and `R|A`
    are equivalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an adaptor `A` takes multiple arguments, a range `R` and `args...`, then
    the following three are equivalent: `A(R, args...)`, `A(args...)(R)`, and `R|A(args...)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from ranges and range adaptors (or views), overloads of the general-purpose
    algorithms are also available in C++20, in the same `std::ranges` namespace. These
    overloads are called *constrained algorithms*. A range can be provided either
    as a single argument (as seen in the examples in this recipe) or as an iterator-sentinel
    pair. Also, for these overloads, the return type has been changed to provide additional
    information that’s computed during the execution of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard ranges library has been designed based on the **range-v3** library,
    created by Eric Niebler and available on GitHub at [https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3).
    This library provides a larger set of range adaptors (views), as well as actions
    that provide mutating operations (such as sorting, erasing, shuffling, and so
    on). The transition from the range-v3 library to the C++20 ranges library can
    be very smooth. In fact, all the samples provided in this recipe work with both
    libraries. All you have to do is include the appropriate header files and use
    the range-v3-specific namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: With these replacements, all the snippets from the *How to do it...* section
    will continue to work using a C++17-compliant compiler.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating your own range view*, to see how to extend the ranges library’s capabilities
    with user-defined range adaptors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the standard range adaptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at how the ranges library helps us simplify
    various tasks when working with collections (ranges), such as enumerating, filtering,
    transforming, and reversing. We did so with the help of range adaptors. However,
    we have only looked at a small set of adaptors. There are more available in the
    standard library, some included in C++20 and others in C++23\. In this recipe,
    we will explore all the adapters in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the snippets shown in this recipe, we will use the following namespace aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Also, to compile the snippets below, you need to include the `<ranges>` and
    `<algorithm>` headers (for the ranges library).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++20, the following adaptors are available to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ranges::filter_view` / `views::filter` represents a view of the underlying
    sequence but without the elements that do not satisfy a specified predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::transform_view` / `views::transform` represents a view of the underlying
    sequence after applying a specified function to each element of the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::take_view` / `views::take` represents a view of the underlying sequence,
    starting at the beginning and containing the specified number of elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::take_while_view` / `views::take_while` represents a view of the underlying
    sequence, starting at the beginning and containing all the consecutive elements
    that satisfy a given predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::drop_view` / `views::drop` represents a view of the underlying sequence
    after skipping the specified number of elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::drop_while_view` / `views::drop_while` represents a view of the underlying
    sequence after skipping all the consecutive elements (from the beginning) that
    satisfy a given predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::join_view` / `views::join` flattens a view of ranges; it represents
    a view consisting of all the elements of a sequence of sequences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::split_view` / `views::split` represents a view of subranges obtained
    by splitting a view with a specified delimiter. The delimiter is not part of the
    resulting subranges:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::lazy_split_view` / `views::lazy_split` is similar to `split`, except
    that it works in a *lazy mode*, meaning that it does not look ahead for the next
    delimiter until we iterate for the next element of the result. It works with constant
    ranges, which are not supported by `split_view`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::reverse_view` / `views::reverse` represents a view of an underlying
    sequence with the elements presented in the reverse order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::elements_view` / `views::elements` represents a view of the *N*th
    element of an underlying sequence of tuple-like values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::keys_view` / `views::keys` represent an alias for `ranges::elements_view<R,
    0>` and, respectively, an object of type `views::elements<0>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ranges::values_view` / `views::values` represent an alias for `ranges::elements_view<R,
    1>` and, respectively, an object of type `views::elements<1>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++23, the following adaptors were added to the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ranges::enumerate_view` / `views::enumerate` represents a view of tuples,
    with the first element being the zero-based index of the element of the underlying
    sequence, and the second element being a reference to the underlying element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::zip_view` / `views::zip` represents a view of tuples created from
    two or more underlying views, with the *N*th tuple created from the *N*th element
    of each underlying view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::zip_transform_view` / `views::` `zip_transform` represents a view
    of elements produced by applying a given function to two or more views. The *N*th
    element of the result view is produced from the *N*th element of all the specified
    underlying views:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::adjacent_view` / `views::adjacent` represents a view of tuples of
    *N* elements from an underlying view; each tuple is a window in the underlying
    view, the *i*th tuple containing the elements with the indexes in the range `[i,
    i + N - 1]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::adjacent_transform_view` / `views::adjacent_transform` represents
    a view of elements produced by applying a specified function to *N*-adjacent elements
    of an underlying view; the *i*th element of the resulting view is produced by
    applying the function to the elements of the underlying range with the indexes
    in the range `[i, i + N - 1]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::join_with_view` / `views::join_with` is similar to `join_view` because
    it flattens a view of ranges to a single view; however, it takes a delimiter that
    it inserts between the elements of the underlying ranges:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::slide_view` / `views::slide` is a range adaptor similar to `ranges::adjacent_view`
    / `views::adjacent`, except that the size of the windows from the underlying sequence
    is specified at runtime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::chunk_view` / `views::chunk` represents a view of sub-views of *N*
    elements of the underlying view. The last chunk may have fewer than *N* elements
    (if the size of the underlying view is not a multiple of *N*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::chunk_by_view` / `views::chunk_by` represents a view of sub-views
    of an underlying view, produced by splitting the underlying view each time a supplied
    binary predicate applied to two adjacent elements returns `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::stride_view` / `views::stride` is a view of some elements from an
    underlying view, starting with the first and advancing over *N* elements each
    time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ranges::cartesian_product_view` / `views::cartesian_product` represents a
    view of tuples computed as the cartesian product of 1 or more underlying views:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how range adaptors work in the previous recipe. In this section, we will
    only look at some of the details and differences between some adaptors that you
    should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: To start, let’s consider `adjacent_view` and `slide_view`. They are similar
    in the sense that they take one view and produce another view of sub-views of
    this underlying view. These sub-views are referred to as *windows* and have a
    specified size, *N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first window starts from the first element, the second from the second
    element, etc. However, they differ in two significant ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The size *N* of the windows is specified at compile time for `adjacent_view`
    and at runtime for `slide_view`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements of the view represented by `adjacent_view` are tuples, while the
    elements of the view represented by `slide_view` are other views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram presents a comparison of these two adaptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Comparison of adjacent_view<3>(R) and slide_view(R, 3)'
  prefs: []
  type: TYPE_NORMAL
- en: When the size of the windows is 2, you can use `views::pairwise` and `views::pairwise_transform`,
    which are objects of type `adjacent<2>` and `adjacent_transform<2>`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next pair of adaptors to look at are `split_view` and `lazy_split_view`.
    They both do the same thing: split a view into subranges based on a given delimiter,
    which can be either a single element or a view of elements. Neither of the two
    adaptors include the delimiter in the resulting subranges. These two, however,
    differ in a key aspect: the `lazy_split_view` adaptor is, as the name implies,
    *lazy*, meaning that it does not look ahead to the next delimiter until we iterate
    for the next element of the result, which `split_view` does. Moreover, `split_view`
    supports ranges of the `forward_range` type or higher but cannot split a constant
    range, while `lazy_split_view` supports ranges of the `input_range` type or higher
    and can split a constant range.'
  prefs: []
  type: TYPE_NORMAL
- en: The question that arises is which one to use and when? Typically, you should
    prefer `split_view` because it is more efficient than `lazy_split_view` (which
    has a less efficient iterator incrementation and comparison). However, if you
    need to split a constant range, then `split_view` is not an option, and you should
    use `lazy_split_view`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two adaptors, `join_view` (in C++20) and `join_with_view` (in C++23),
    that perform a join operation, transforming a range of ranges into a single (flattened)
    range. The difference between them is that the latter, `join_with_view`, takes
    a delimiter that is inserted in the result between the elements of two consecutive
    underlying ranges.
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the standard range adaptors, you can consult the online
    documentation available at [https://en.cppreference.com/w/cpp/ranges](https://en.cppreference.com/w/cpp/ranges).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using constrained algorithms*, to learn about the standard generic algorithms
    that work with ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a range to a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result of applying various range adapters to a range (such as a container)
    is a complex type that is difficult to type or remember. Typically, we’d use the
    `auto` specifier to indicate the type of the result of chaining adaptors, as we
    saw in the previous recipes. Ranges are lazy, which means they are evaluated,
    and they produce results only when we iterate over them. However, we often need
    to store the result of applying one or more range adaptors in a container, such
    as a vector or a map. Prior to C++23, this required explicit coding. However,
    C++23 provides a range conversion function, called `std::ranges::to`, which makes
    this an easy task. It also enables conversion between different containers. In
    this recipe, we will learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `is_prime()` function used in the following snippets was shown in the recipe
    *Exploring the standard range adaptors* and will not be listed again here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can convert a range to a container using the `std::ranges::to` range conversion
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert a range to a `std::vector`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert a range to a map type, such as `std::unordered_multimap`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert a range to a `std::string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::ranges::to` range conversion function is available in the `<ranges>`
    header, starting with C++23 (the feature-test macro `__cpp_lib_ranges_to_container`
    can be used to test whether it is supported or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the previous examples showed how to convert from one range to another,
    `std::ranges::to` can also be used to convert between different types of containers,
    such as a vector to a list, or a map to a vector of pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use the pipe (`|`) syntax, the parentheses are mandatory; otherwise,
    you will get compiler errors (which are difficult to read):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Exploring the standard range adaptors*, to learn about the range adaptors
    available in C++20 and C++23'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using constrained algorithms*, to learn about the standard generic algorithms
    that work with ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own range view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 ranges library simplifies the handling of ranges of elements. The
    16 range adaptors (views) defined in the library provide useful operations, as
    seen in the previous recipe. However, you can create your own view that can be
    used together with the standard ones. In this recipe, you will learn how to do
    that. We will create a view called `trim` that, given a range and a unary predicate,
    returns a new range without the front and back elements that satisfy the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the same namespace aliases used in the previous
    one, with `rg` as an alias for `std::ranges` and `rv` as an alias for `std::ranges::views`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a view, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class template, called `trim_view`, derived from `std::ranges::view_interface`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the internal state of the class, which, at a minimum, should include
    a begin and end iterator and the viewable range that is adapted by the view. For
    this adapter, we also need a predicate, as well as a Boolean variable to flag
    whether the iterators have been evaluated or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a default constructor (that can be defaulted) and a `constexpr` constructor
    with the required parameters. The first parameter is always the range. For this
    view, the other parameter is a predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide accessors to the internal data, such as the base range and the predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide functions to retrieve the begin and end iterators. To make sure the
    view is lazy, these iterators should only be evaluated by their first use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide other useful members, such as a function, to return the size of the
    range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put all together, the view appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the composability of this user-defined view with the standard ones,
    the following should also be done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a user-defined deduction guide for the class template argument deduction
    of the `trim_view` class template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create function objects that can instantiate the `trim_view` adaptor with the
    proper arguments. These can be made available in a separate namespace because
    they represent implementation details:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Overload the pipe operator for the `trim_view_range_adaptor_closure` class
    defined previously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an object of the `trim_view_range_adaptor` type that can be used to
    create `trim_view` instances. This can be done in a namespace called `views` to
    create a similarity with the namespaces of the ranges library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `trim_view` class template we defined here is derived from the `std::ranges::view_interface`
    class template. This is a helper class in the ranges library to define views,
    using the **curiously recurring template pattern** (**CRTP**). There are two template
    arguments for the `trim_view` class: the range type, which must satisfy the `std::ranges::input_range`
    concept, and the predicate type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `trim_view` class stores the base range and the predicate internally. Additionally,
    it requires a beginning and end (sentinel) iterator. These iterators must point
    to the first element and the ones past the last element of the range that do not
    satisfy the trimming predicate. However, because the view is a lazy object, these
    iterators should not be resolved before they are needed to iterate over the range.
    The following diagram shows the positions of these iterators in a range of integers,
    for when the view must trim the odd numbers from the beginning and end of the
    range `{1,1,2,3,5,6,4,7,7,9}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21549_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: A visual conceptual representation of the range and the position
    of the start and end iterators before the iteration starts (above) and when it
    starts (below)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `trim_view` class to write the following snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `trim_view` class, as well as composition with other views, is simplified
    through the use of the function objects declared in the `details` namespace, which
    represent implementation details. However, these, together with the overloaded
    pipe operator (`|`), make it possible to rewrite the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: It should be mentioned that the **range-v3** library does contain a range view
    called `trim`, but it was not ported to the C++20 ranges library. This may happen
    in a future version of the standard.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 10**, Static polymorphism with the curiously recurring template pattern*
    to see how the CRTP works'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constrained algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard library features over 100 generic-purpose algorithms (most
    of them in the `<algorithm>` header, and some of them in the `<numeric>` header).
    Some of these algorithms we saw in *Chapter 5*, over the course of several recipes,
    when we learned how to search elements in a range, sort a range, initialize a
    range, and more. The generic aspect of algorithms comes from the fact they work
    with iterators (a beginning and end iterator to a sequence of elements–a range)
    but this has the downside of requiring more explicit code that needs to be repeated
    over and over again. To ease the use of these algorithms, the C++20 standard provides
    matching algorithms in the `std::ranges` namespace that work with ranges (but
    also have overloads for iterators). These algorithms from the ranges library are
    called **constrained algorithms** and are available in the `<algorithm>` header.
    Although it’s not possible to look at all of them here, in this recipe we will
    see how to use several of them for initializing, sorting, and finding elements
    in a range.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform various operations on ranges, including initializing, finding,
    and sorting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::ranges::fill()` to assign a value to all the elements of a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::fill_n()` to assign a value to a specified number of elements
    of a range. The first element to be assigned is indicated by an output iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::generate_n()` to assign the value returned by successive
    invocations of a given function to a number of elements of a range. The first
    element is indicated by an iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::iota()` to assign sequentially increasing values to the elements
    of a range. The values are incremented using the prefix `operator++` from an initial
    specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::find()` to find a value in a range; this algorithm returns
    an iterator to the first element equal to the supplied value, if such a value
    exists, or an iterator equal to the end of the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::find_if()` to find a value in a range that meets the criteria
    defined by a unary predicate. The algorithm returns an iterator to the first element
    in the range for which the predicate returns `true`, or an iterator to the end
    of the range if no such element exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::find_first_of()` to search for the occurrence of any value
    from a range in another range; the algorithm returns an iterator to the first
    element (in the searched range) that is found, or one equal to the end of the
    range, otherwise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::sort()` to sort a range. You can supply a comparison function
    to be applied to the elements. This can include `std::ranges::greater`, `std::ranges::less`,
    and the other function objects from the `<functional>` header corresponding to
    the `<`, `<=`, `>`, `>=`, `==`, and `!=` operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::is_sorted()` to check that a range is sorted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::ranges::is_sorted_until()` to find a sorted subrange from the beginning
    of a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All but one of the constrained algorithms are located in the `<algorithm>`
    header. The exception is `std::ranges::iota()`, which is found in the `<numeric>`
    header. The algorithms listed in the *How to do it…* section are only a small
    selection of the available constrained algorithms. They are called constrained
    because there are requirements defined in their arguments with the help of concepts
    and constraints. Here is the definition of one of the overloads of `std::ranges::find()`
    that we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, there are some algorithms, such as `std::ranges::fill_n()`
    and `std::ranges::generate_n()`, seen earlier, that have a single overload that
    takes only one iterator, from the beginning of the range.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between the traditional algorithms and the constrained algorithms
    is that the latter do not have overloads to specify an execution policy, unlike
    the former, which do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constrained algorithms have several advantages over the traditional algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: There is less code to write because you don’t have to retrieve the beginning
    and ending iterator of a range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are constrained, using concepts and constraints, which help provide better
    error messages in case of misuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used with ranges/views as defined by the ranges library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of them have overloads that allow you to specify a projection to apply
    to the elements, on which, in turn, a specified predicate is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first see how the constrained algorithms interact with ranges. For this,
    we consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a vector of integers. From this vector, we filter out
    the even numbers, transform the rest by their square, and, finally, retain four
    of the resulting numbers. The result is a range. Its type is too complex to remember
    or write; therefore, we use the `auto` specifier and let the compiler infer it.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who wonder what the actual type is (in this previous example),
    it is `std::ranges::take_view<std::ranges::transform_view<std::ranges::filter_view<std::ranges::ref_view<std::vector<int>>,
    lambda [](int n)->bool>, lambda [](int n)->int>>`.
  prefs: []
  type: TYPE_NORMAL
- en: We want to print the resulting values to the console and find the first value
    greater than 10 (if any exists). For this purpose, we use `std::ranges::for_each()`
    and `std::ranges::find_if()`, passing the `range` object without having to deal
    directly with iterators.
  prefs: []
  type: TYPE_NORMAL
- en: The last advantage mentioned earlier in the list is the ability to specify a
    projection. A projection is a callable object (for instance, a function object,
    or a reference to a member). This projection is applied to the elements of the
    range. On the result of the projection, another predicate is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let’s consider a list of products with an ID,
    name, and price. From this list, we want to find the product with a certain price
    and print its name. The list is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'With the traditional algorithms, we need to use `std::find_if()` and pass a
    lambda function that performs the checking of each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'With constrained algorithms, we can use one of the overloads of `std::ranges::find()`
    that take a range, a value, and a projection, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Another similar example is sorting the range alphabetically (in ascending order)
    by the name of the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, these examples show there are compelling arguments to prefer, in
    general, the new C++20 constrained algorithms over the traditional ones. However,
    keep in mind that you cannot use constrained algorithms when you want to specify
    an execution policy (for instance, to parallelize or vectorize the execution of
    an algorithm), as such overloads are not available.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Finding elements in a range*, to learn about the standard algorithms
    to search through sequences of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Sorting a range*, to learn about the standard algorithms for
    sorting ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Initializing a range*, to explore the standard algorithms for
    filling a range with values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specify requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine task type for asynchronous computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major component of the C++20 standard is represented by coroutines. Simply
    put, coroutines are functions that can be suspended and resumed. Coroutines are
    an alternative to writing asynchronous code. They help simplify asynchronous I/O
    code, lazy computations, or event-driven applications. When a coroutine is suspended,
    the execution returns to the caller, and the data necessary to resume the coroutine
    is stored separately from the stack. For this reason, the C++20 coroutines are
    called *stackless*. Unfortunately, the C++20 standard does not define actual coroutine
    types and only a framework for building them. This makes writing asynchronous
    code with coroutines difficult without relying on third-party components.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to write a coroutine task type that represents
    an asynchronous computation, which starts executing when the task is awaited.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The several standard library types and functions that define the coroutine
    framework are available in the `<coroutine>` header, in the `std` namespace. However,
    you need to use a minimum compiler version to support coroutines: MSVC 19.28 (from
    Visual Studio 2019 16.8), Clang 17, or GCC 10.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to create a task type that enables us to write asynchronous
    functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a task type that supports coroutines that return nothing (`task<>`),
    a value (`task<T>`), or a reference (`task<T&>`), you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class called `promise_base` with the following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class template called `promise`, derived from `promise_base`, that
    adds the methods `get_return_object()` and `return_value()` and holds the value
    returned from the coroutine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specialize the `promise` class template for the `void` type, and provide implementations
    for the `get_return_object()` and `return_void()` methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specialize the `promise` class template for `T&`. Provide implementations for
    `get_return_object()` and `return_value()`, and store a pointer to the reference
    returned by the coroutine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class template called `task`, with the stub content shown below. This
    type must have an inner type called `promise_type` and hold a handle to the executing
    coroutine. The `task_awaiter` and the class members are listed here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an awaitable class called `task_awaiter` that implements the `await_ready()`,
    `await_suspend()`, and `await_resume()` methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide class members, including a conversion constructor, a move constructor
    and move assignment operator, a destructor, a `co_await` operator, a method to
    check whether the coroutine has completed, a method to resume a suspended coroutine,
    and a method to get the value returned from the coroutine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `get_return_object()` member of the `promise` primary template
    as well as its specializations. This must be done after the definition of the
    `task` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are blocks of code that execute one or more statements. You can assign
    them to variables, pass them as arguments, take their address, and, of course,
    invoke them. These features make them first-class citizens in the C++ language.
    Functions are sometimes called *subroutines*. Coroutines, on the other hand, are
    functions that support two additional operations: suspending and resuming their
    execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, a function is a coroutine if it uses any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `co_await` operator, which suspends the execution until resumed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `co_return` keyword, to complete the execution and optionally return a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `co_yield` keyword, to suspend the execution and return a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not every function, however, can be a coroutine. The following cannot be coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and destructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constexpr functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return `auto` or a concept type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A coroutine consists of the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A *promise object*, which is manipulated inside the coroutine and is used to
    pass the return value or an exception from the coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *coroutine handle*, which is manipulated outside the coroutine and is used
    to either resume the execution or destroy the coroutine frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *coroutine frame*, typically allocated on the heap and containing the promise
    object, the coroutine parameters copied by value, local variables, temporaries
    whose lifetimes exceed the current suspension point, and a representation of the
    suspension point so that resuming and destroying can be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The promise object can be any type that implements the following interface,
    as expected by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Default constructor** | **The promise must be default constructible** |'
  prefs: []
  type: TYPE_TB
- en: '| `initial_suspend()` | Indicates whether suspension happens at the initial
    suspend point. |'
  prefs: []
  type: TYPE_TB
- en: '| `final_suspend()` | Indicates whether suspension happens at the last suspend
    point. |'
  prefs: []
  type: TYPE_TB
- en: '| `unhandled_exception()` | Called when an exception propagates out of a coroutine
    block. |'
  prefs: []
  type: TYPE_TB
- en: '| `get_return_object()` | The return value of the function. |'
  prefs: []
  type: TYPE_TB
- en: '| `return_value(v)` | Enables the `co_return v` statement. Its return type
    must be `void`. |'
  prefs: []
  type: TYPE_TB
- en: '| `return_void()` | Enables the `co_return` statement. Its return type must
    be `void`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yield_value(v)` | Enables the `co_yield v` statement. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.3: The members of the interface implemented by a promise'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `initial_suspend()` and `final_suspend()` we have seen
    for the `promise` type implemented here returns an instance of `std::suspend_always`.
    This is one of the two trivial awaitables that the standard defines, the other
    being `std::suspend_never`. Their implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'These types implement the *awaitable* concept, which enables the use of the
    `co_await` operator. There are three functions required by this concept. These
    can be either free functions or class member functions. They are listed in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `await_ready()` | Indicates whether the result is ready. If the return value
    is `false` (or a value convertible to `false`), then `await_suspend()` is called.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `await_suspend()` | Schedules the coroutine to resume or to be destroyed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `await_resume()` | Provides the result for the entire `co_await e` expression.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.4: Functions that the awaitable concepts require'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `task<T>` type we built in this recipe has several members:'
  prefs: []
  type: TYPE_NORMAL
- en: An explicit constructor that takes an argument of the `std::coroutine_handle<T>`
    type, representing a non-owning handle to the coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destructor that destroys the coroutine frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move constructor and move assignment operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deleted copy constructor and copy assignment operator, making the class moveable-only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `co_await` operator, which returns a `task_awaiter` value that implements
    the awaitable concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_ready()`, a method that returns a Boolean value indicating whether the
    coroutine value is ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resume()`, a method that resumes the execution of the coroutine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value()`, a method that returns the value held by the promise object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inner promise type called `promise_type` (this name is mandatory).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an exception occurs during the execution of the coroutine, and this exception
    leaves the coroutine without being handled, then the `unhandled_exception()` method
    of the promise is invoked. In this simple implementation, this situation is not
    handled, and the program is abnormally terminated with a call to `std::terminate()`.
    In the following recipe, we will see an awaitable implementation that handles
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the following coroutine as an example to see how the compiler handles
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of all the mechanisms we built in this recipe, the compiler transforms
    this code into the following (this snippet is pseudocode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the `main()` function is one of the functions that cannot
    be a coroutine. For this reason, it is not possible to use the `co_await` operator
    in `main()`. This means that waiting for a coroutine to complete must be done
    differently in `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is handled with the help of a function template called `execute()` that
    runs the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This loop ensures that the coroutine is resumed after each suspension point,
    until its final completion.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++20 standard does not provide any coroutine types, and writing your own
    is a cumbersome task. Fortunately, third-party libraries can offer these abstractions.
    Such a library is **libcoro**, an open-source experimental library that provides
    a set of general-purpose primitives to make use of the coroutines described in
    the C++20 standard. The library is available at [https://github.com/jbaldwin/libcoro](https://github.com/jbaldwin/libcoro).
    Among the components it provides is the `task<T>` coroutine type, similar to what
    we built in this recipe. Using the `coro::task<T>` type, we can rewrite our examples
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is very similar to what we wrote in the first part
    of this recipe. The changes are minimal. By using this **libcoro** library or
    others that are similar, you do not need to be concerned with the details of implementing
    coroutine types and instead focus on their use.
  prefs: []
  type: TYPE_NORMAL
- en: Another library that was used in the second edition of the book was **cppcoro**,
    which is available at [https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro).
    However, the **cppcoro** library has not been maintained for several years. Although
    it’s still available on GitHub, it relies on the experimental implementation of
    technical specifications for coroutines. For instance, when using MSVC, this requires
    the use of the now obsolete `/await` compiler flag. You should only use this library
    as a source of inspiration to write coroutine primitives, such as the one we will
    see in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a coroutine generator type for sequences of values*, to learn how
    to enable the use of `co_yield` to return multiple values from a coroutine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine generator type for sequences of values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to create a coroutine task that enables asynchronous
    computations. We used the `co_await` operator to suspend execution until resumed
    and the `co_return` keyword to complete execution and return a value. However,
    another keyword, `co_yield`, also defines a function as a coroutine. It suspends
    the execution of the coroutine and returns a value. It enables a coroutine to
    return multiple values, one each time it is resumed. To support this feature,
    another type of coroutine is required. This type is called a *generator*. Conceptually,
    it’s like a stream that produces a sequence of values of type `T` in a lazy manner
    (when iterated). In this recipe, we will see how we can implement a simple generator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to create a generator coroutine type that enables
    us to write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you follow the previous recipe, *Creating a coroutine
    task type for asynchronous computations*, before you continue with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a generator coroutine type that supports synchronous lazy production
    of a sequence of values, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class template, called `generator`, with the following content (the
    details of each part are presented in the following bullet points):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an inner class called `promise_type` (the name is mandatory) with the
    following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an inner class called `iterator` with the following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide a default constructor, an explicit constructor from a `promise_type`
    object, a move constructor and a move assignment operator, and a destructor. Delete
    the copy constructor and copy assignment operator so that the type is moveable
    only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide the `begin()` and `end()` functions to enable iteration over the generator
    sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The promise type implemented in this recipe is similar to the one from the
    previous recipe, although there are some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It is implemented as an inner type, so the name is `promise_type`, since the
    coroutine framework requires the coroutine type to have an inner promise type
    with this name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports handling exceptions that leave the coroutine block uncaught. In
    the previous recipe, this situation was not treated, and an `unhandled_exception()`
    called `std::terminate()` to abnormally terminate the process. This implementation,
    however, retries a pointer to the current exception and stores it in an `std::exception_ptr`
    object. This exception is rethrown when iterating through the generated sequence
    (either when calling `begin()` or when incrementing the iterator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions `return_value()` and `return_void()` are not present, but replaced
    with `yield_value()`, which is called when the `co_yield expr` expression is resolved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generator class also bears some similarities to the task class from the
    previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: It is default-constructible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be constructed from a promise object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not copy-constructible and copyable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is move-constructible and moveable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its destructor destroys the coroutine frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class does not overload the `co_await` operator, as it does not make sense
    to wait on the generator; instead, it provides the functions `begin()` and `end()`,
    which return iterator objects that enable iterating over the sequence of values.
    This generator is said to be lazy because it does not produce new values until
    the coroutine is resumed, either by calling `begin()` or incrementing an iterator.
    The coroutine is created suspended, and its first execution begins only when calling
    the `begin()` function. The execution continues either until the first `co_yield`
    statement or until the coroutine completes its execution. Similarly, incrementing
    the iterator will resume the execution of the coroutine, which continues either
    until the next `co_yield` statement or until its completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a coroutine that produces several integer values.
    It does so not by using a loop but by repeating `co_yield` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is that the coroutine can only use the `co_yield`
    keyword and produce values synchronously. The use of the `co_await` operator within
    the coroutine is not supported with this particular implementation. To be able
    to suspend execution by using the `co_await` operator, a different implementation
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **libcoro** library, mentioned in the previous recipe, has a `generator<T>`
    type that can be used instead of the one we created here. In fact, by replacing
    our `generator<T>` with `coro::generator<T>`, the snippets of code shown previously
    will continue to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a coroutine task type for asynchronous computations*, for an introduction
    to the C++20 coroutines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a sequence of values with the std::generator type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++20 standard includes two major updates to the standard library: the
    ranges library and coroutines. However, with regard to the latter, the support
    is minimal. The C++20 standard only defines a framework for building coroutines.
    Because of this, libraries such as **libcoro**, which we have previously seen,
    were created to provide actual coroutines, such as `task` and `generator`, which
    we also saw in the previous two recipes. The C++23 standard introduces the first
    standard coroutine, called `std::generator`. This brings together ranges and coroutines
    because `std::generator` is a view that represents a synchronous coroutine generator.
    This is a standard implementation for what we explicitly built in the previous
    recipe, *Creating a coroutine generator type for sequences of values*. Let’s see
    how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, only GCC 14 supports this standard coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate a sequence of elements, in a lazy manner, write a coroutine that:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses `std::generator<T>` as the return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the `co_yield` statement to return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new `std::generator` class template is available in its own header, called
    `<generator>`. It derives from `std::ranges::view_interface`; therefore, it is
    a view of elements that are yielded from the evaluation of a coroutine (an interruptible
    function). The class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the coroutine is resumed and a `co_yield` statement is evaluated,
    a new element of a sequence is produced. The following is an example that contains
    a series of `co_yield` statements (not a loop). In total, this coroutine produces
    three elements. However, if the `get_values()` coroutine is only evaluated once,
    it will only produce one element. We call this a lazy evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The `std::generator` type is a synchronous generator; the coroutine can only
    use the `co_yield` statement to return values. It is not possible to use the `co_await`
    operator within the coroutine. A different kind of generator would be required
    for that, and such a generator is not currently available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of using the `std::generator` type to produce a sequence of
    values is the following, which generates the series of Fibonacci numbers. This
    is the same example that we saw in the previous recipe. The only change is that
    we replaced `generator<int>` (which we wrote) with `std::generator<int>`, which
    is available in the C++23 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a coroutine task type for asynchronous computations*, for an introduction
    to the C++20 coroutines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a coroutine generator type for sequences of values*, to learn how
    to enable the use of `co_yield` to return multiple values from a coroutine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_12.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
