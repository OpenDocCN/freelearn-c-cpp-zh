- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: C++ 20 Core Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 20 核心特性
- en: The new C++20 standard is a major step in the development of the C++ language.
    C++20 brings many new features both to the language and to the standard library.
    Some of these have already been discussed in previous chapters, such as the text
    formatting library, the calendar extensions to the chrono library, the changes
    to the thread support library, and many others. However, the features that impact
    the language the most are modules, concepts, coroutines, and the new ranges library.
    The specification of these features is very lengthy, which makes it difficult
    to cover them in great detail in this book. Therefore, in this chapter, we will
    look at the most important aspects and use cases of these features. This chapter
    is intended to help you start using these features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 C++20 标准是 C++ 语言发展中的一个重大步骤。C++20 为语言和标准库带来了许多新特性。其中一些已经在之前的章节中讨论过，例如文本格式化库、chrono
    库的日历扩展、线程支持库的更改等等。然而，对语言影响最大的特性是模块、概念、协程和新的 ranges 库。这些特性的规范非常长，这使得在本书中详细讨论它们变得困难。因此，在这一章中，我们将探讨这些特性的最重要的方面和用例。本章旨在帮助你开始使用这些特性。
- en: 'This chapter includes the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下菜谱：
- en: Working with modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模块一起工作
- en: Understanding module partitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块分区
- en: Specifying requirements on template arguments with concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用概念指定模板参数的要求
- en: Using requires expressions and clauses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式和子句
- en: Exploring abbreviated function templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索缩写函数模板
- en: Iterating over collections with the ranges library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ranges 库遍历集合
- en: Exploring the standard range adaptors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索标准范围适配器
- en: Converting a range to a container
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将范围转换为容器
- en: Creating your own range view
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的范围视图
- en: Using constrained algorithms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用约束算法
- en: Creating a coroutine task type for asynchronous computations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于异步计算的协程任务类型
- en: Creating a coroutine generator type for sequences of values
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于值序列的协程生成器类型
- en: Generating a sequence of values with the std::generator type
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 std::generator 类型生成值序列
- en: Let’s start this chapter by learning about modules, which are the most disruptive
    change that’s happened to the C++ language in decades.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习模块开始这一章，模块是数十年来对 C++ 语言影响最大的变革。
- en: Working with modules
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与模块一起工作
- en: Modules are one of the most important changes in the C++20 standard. They represent
    a fundamental change to the C++ language and the way we write and consume code.
    Modules are made available in source files that are compiled separately from the
    translation units that consume them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是 C++20 标准中最重要的一项变革之一。它们代表了 C++ 语言以及我们编写和消费代码方式的根本性变革。模块通过单独编译的源文件提供，这些源文件与使用它们的翻译单元分开编译。
- en: 'Modules provide multiple advantages, especially in comparison to the use of
    header files:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模块提供了多个优势，尤其是在与头文件使用相比时：
- en: They are only imported once, and the order they’re imported in does not matter.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只导入一次，导入的顺序并不重要。
- en: They do not require splitting interfaces and implementation in different source
    files, although this is still possible.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要在不同源文件中分割接口和实现，尽管这仍然是可能的。
- en: Modules have the potential to reduce compilation time, in some cases significantly.
    The entities exported from a module are described in a binary file that the compiler
    can process faster than traditional precompiled headers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块有可能减少编译时间，在某些情况下甚至可以显著减少。从模块导出的实体在二进制文件中描述，编译器可以比传统的预编译头更快地处理这些文件。
- en: Moreover, this file can potentially be used to build integrations and interoperability
    with C++ code from other languages.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，此文件可能被用于构建与其他语言 C++ 代码的集成和互操作性。
- en: In this recipe, you will learn how to get started with modules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何开始使用模块。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: At the time of writing, the major compilers (VC++, Clang, and GCC) provide different
    levels of support for modules. Build systems, such as CMake, are lagging in terms
    of adoption for modules (although this is likely to change in the near future).
    Because different compilers have different ways of, and different compiler options
    for, supporting modules, this book will not provide details on how to build these
    samples. You are invited to consult online documentation for specific compilers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，主要的编译器（VC++、Clang和GCC）为模块提供不同级别的支持。构建系统，如CMake，在模块的采用方面落后（尽管这可能在不久的将来发生变化）。由于不同的编译器有不同的方式和不同的编译器选项来支持模块，本书将不会提供如何构建这些示例的详细信息。您被邀请查阅特定编译器的在线文档。
- en: The source code accompanying this book includes scripts for building the source
    code presented in this recipe and the next one, using the MSVC compiler (cl.exe)
    from Visual Studio 2019 16.8 and, respectively, Visual Studio 2022 17.x.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随这本书的源代码包括使用Visual Studio 2019 16.8和Visual Studio 2022 17.x的MSVC编译器（cl.exe）构建本食谱和下一个食谱中展示的源代码的脚本。
- en: 'There are several types of module files: *module interface units*, *module
    interface partitions*, and *module implementation partitions*. In this recipe,
    we’ll refer solely to the first; the other two, we will learn about in the next
    recipe.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种类型的模块文件：**模块接口单元**、**模块接口分区**和**模块实现分区**。在本食谱中，我们将仅提及第一种；其他两种，我们将在下一个食谱中学习。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'When you modularize your code, you can do the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你模块化你的代码时，你可以做以下几件事情：
- en: 'Import a module using the `import` directive, followed by the module name.
    The standard library is available in the `std` module, but only starting with
    C++23\. This allows us to write the following in C++23:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import`指令和模块名称导入模块。标准库在`std`模块中可用，但仅从C++23开始。这允许我们在C++23中编写以下内容：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Export a module by creating a **module interface unit** (**MIU**) that can
    contain functions, types, constants, and even macros. Their declaration must be
    preceded by the keyword `export`. The module interface unit file must have the
    extension `.ixx` for VC++. Clang accepts different extensions, including `.cpp`,
    `.cppm`, and even `.ixx`. The following sample exports a class template called
    `point`, a function called `distance()` that computes the distance between two
    points, and a user-defined literal operator called `_ip` that creates objects
    of the type `point` from strings, in the form `"0,0"` or `"12,-3"`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建一个**模块接口单元**（**MIU**）来导出模块，该单元可以包含函数、类型、常量和甚至宏。它们的声明必须以关键字`export`开头。模块接口单元文件必须以`.ixx`扩展名结尾，适用于VC++。Clang接受不同的扩展名，包括`.cpp`、`.cppm`，甚至`.ixx`。以下示例导出了一个名为`point`的类模板，一个名为`distance()`的函数，该函数计算两点之间的距离，以及一个用户定义的文法操作符`_ip`，它可以从字符串创建`point`类型的对象，形式为`"0,0"`或`"12,-3"`：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `import` directive to also import the content of a header. The example
    presented here uses the same type and functions seen in the preceding example:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import`指令也可以导入头文件的内容。这里展示的例子使用了与前面示例中相同的类型和函数：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A module unit is composed of several parts, mandatory or optional:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 模块单元由几个部分组成，包括必需的或可选的部分：
- en: The *global module fragment*, introduced with a `module;` statement. This part
    is optional and, if present, may only contain preprocessor directives. Everything
    that is added here is said to belong to the *global module*, which is a collection
    of all the global module fragments and all the translation units that are not
    modules.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局模块片段**，通过`module;`语句引入。这部分是可选的，如果存在，可能只包含预处理器指令。这里添加的任何内容都被称为**全局模块**，它是所有全局模块片段和所有非模块的翻译单元的集合。'
- en: The *module declaration*, which is a required statement of the form `export`
    `module name;`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块声明**，这是一个必需的语句，形式为`export` `module name;`。'
- en: The *module preamble*, which is optional and may only contain import declarations.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块序言**，这是可选的，可能只包含导入声明。'
- en: The *module purview*, which is the content of the unit, starting with the module
    declaration and extending to the end of the module unit.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块范围**，即单元的内容，从模块声明开始，延伸到模块单元的末尾。'
- en: 'The following diagram shows a module unit containing all of the aforementioned
    parts. On the left side, we have the source code of the module, and on the right
    side, the module parts are explained:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了一个包含所有上述部分的模块单元。在左侧，我们有模块的源代码，在右侧，解释了模块的各个部分：
- en: '![](img/B21549_12_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_12_01.png)'
- en: 'Figure 12.1: An example of a module (on the left side) with each part highlighted
    and explained (on the right side)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：一个模块（左侧）的示例，每个部分都被突出显示并解释（右侧）
- en: 'A module can export any entity, such as functions, classes, and constants.
    Every export must be preceded by the `export` keyword. This keyword is always
    the first keyword, preceding others such as `class`/`struct`, `template`, or `using`.
    Several examples have been provided in the **geometry** module shown in the previous
    section:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以导出任何实体，例如函数、类和常量。每个导出都必须以 `export` 关键字开头。这个关键字始终是第一个关键字，位于 `class`/`struct`、`template`
    或 `using` 等其他关键字之前。前一个章节中展示的 **geometry** 模块中已经提供了几个示例：
- en: An E class template called `point`, which represents a point in the two-dimensional
    space
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `point` 的 E 类模板，表示二维空间中的一个点
- en: A type alias for `point<int>` called `int_point`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `int_point` 的 `point<int>` 类型别名
- en: A compile-time constant called `int_point_zero`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `int_point_zero` 的编译时常量
- en: A function template, `distance()`, that computes the distance between two points
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数模板 `distance()`，用于计算两点之间的距离
- en: A user-defined literal `_ip` that creates `int_point` objects from strings such
    as `"3,4"`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户自定义字面量 `_ip`，可以从 `"3,4"` 等字符串创建 `int_point` 对象
- en: A translation unit that uses modules instead of headers does not require any
    other changes, except for replacing `#include` preprocessor directives with `import`
    directives. Moreover, headers can also be imported as modules using the same `import`
    directive, as shown in an example earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块而不是头文件的翻译单元不需要进行任何其他更改，除了将 `#include` 预处理器指令替换为 `import` 指令。此外，也可以使用相同的
    `import` 指令将头文件导入为模块，如前一个示例所示。
- en: There is no relationship between modules and namespaces. These two are independent
    concepts. The module `geometry` exports the user-defined literal `""_ip` in the
    namespace `geometry_literals`, while all the other exports in the module are available
    in the global namespace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和命名空间之间没有关系。这两个是独立的概念。模块 `geometry` 在 `geometry_literals` 命名空间中导出了用户自定义字面量
    `""_ip`，而模块中的其他所有导出都在全局命名空间中可用。
- en: There is also no relationship between the module names and the name of the unit
    file. The geometry module was defined in a file called `geometry.ixx`/`.cppm`,
    although any filename would have had the same result. It is recommended that you
    follow a consistent naming scheme and use the module name for the module filename
    too. On the other hand, the extension used for module units differs with each
    compiler, although this could be something that may change in the future when
    module support reaches maturity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名称和单元文件名称之间也没有关系。几何模块是在一个名为 `geometry.ixx`/`.cppm` 的文件中定义的，尽管任何文件名都会产生相同的结果。建议您遵循一致的命名方案，并将模块名称用于模块文件名。另一方面，模块单元使用的扩展名因编译器而异，尽管这可能是当模块支持成熟时可能会发生变化的事情。
- en: 'Prior to C++23, the standard library was not yet modularized. However, compilers
    have already made it available in modules. The Clang compiler provides a different
    module for each header. On the other hand, the Visual C++ compiler provides the
    following modules for the standard library:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 之前，标准库尚未模块化。然而，编译器已经将其作为模块提供。Clang 编译器为每个头文件提供不同的模块。另一方面，Visual C++
    编译器为标准库提供了以下模块：
- en: '`std.regex`: The content of the `<regex>` header'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std.regex`: 头文件 `<regex>` 的内容'
- en: '`std.filesystem`: The content of the `<filesystem>` header'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std.filesystem`: 头文件 `<filesystem>` 的内容'
- en: '`std.memory`: The content of the `<memory>` header'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std.memory`: 头文件 `<memory>` 的内容'
- en: '`std.threading`: The content of the headers `<atomic>`, `<condition_variable>`,
    `<future>`, `<mutex>`, `<shared_mutex>`, and `<thread>`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std.threading`: 头文件 `<atomic>`, `<condition_variable>`, `<future>`, `<mutex>`,
    `<shared_mutex>`, 和 `<thread>` 的内容'
- en: '`std.core`: The rest of the C++ standard library'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std.core`: C++ 标准库的其余部分'
- en: As you can see from these module names, such as `std.core` or `std.regex`, the
    name of the module can be a series of identifiers concatenated with a dot (`.`).
    The dot has no significance other than helping to split the name into parts representing
    a logical hierarchy, such as `company.project.module`. The use of a dot can arguably
    provide better readability compared to the use of an underscore (such as in `std_core`
    or `std_regex`), which is also legal, like anything else that may form an identifier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些模块名称中可以看到，例如 `std.core` 或 `std.regex`，模块的名称可以是由一系列标识符通过点（`.`）连接而成的序列。点号除了帮助将名称分割成表示逻辑层次结构的部分（如
    `company.project.module`）之外，没有其他意义。使用点号在某种程度上可以提供比使用下划线（如 `std_core` 或 `std_regex`）更好的可读性，尽管下划线也是合法的，就像任何可能形成标识符的东西一样。
- en: 'The C++23 standard, on the other hand, provides two standardized named modules:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，C++23 标准提供了两个标准化命名的模块：
- en: '`std`, which imports everything from the C++ standard headers (such as `<vector>`,
    `<string>`, `<algorithm>`, etc.) and C wrapper headers (such as `<cstdio>`) into
    the `std` namespace. You should use this module if you qualify everything with
    `std` and don’t want to pollute the global namespace.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std`，它将 C++ 标准头文件（如 `<vector>`、`<string>`、`<algorithm>` 等）和 C 包装器头文件（如 `<cstdio>`）中的所有内容导入到
    `std` 命名空间。如果您使用 `std` 限定所有内容且不想污染全局命名空间，则应使用此模块。'
- en: '`std.compat`, which imports everything that `std` does and, in addition, the
    global namespace counterparts of the C wrapper headers. For instance, if `std`
    imports `std::fopen` and `std::fclose` (along with everything else) from `<cstdio>`,
    then `std.compat` imports `::fopen` and `::fclose`. You should use this module
    if you want to migrate code more easily without having to qualify names with the
    `std` namespace (such as `std::fopen` instead of `fopen`, `std::size_t` instead
    of `size_t`, etc.).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std.compat` 模块导入了 `std` 所有的内容，以及 C 包装器头文件的全球命名空间对应项。例如，如果 `std` 从 `<cstdio>`
    中导入了 `std::fopen` 和 `std::fclose`（以及其他所有内容），那么 `std.compat` 将导入 `::fopen` 和 `::fclose`。如果您想更容易地迁移代码而不必使用
    `std` 命名空间限定名称（如使用 `fopen` 而不是 `std::fopen`，使用 `size_t` 而不是 `std::size_t` 等），则应使用此模块。'
- en: 'As a programmer, you are familiar with the typical introductory program to
    any programming language called *“Hello, world!”* that simply prints this text
    to the console. In C++, the canonical form of this program used to be the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，您熟悉任何编程语言的典型入门程序，称为 *“Hello, world!”*，该程序简单地打印此文本到控制台。在 C++ 中，此程序的规范形式曾经如下所示：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In C++23, with support for standardized modules and the new printing capabilities
    of the text formatting library, this program can look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，随着标准化模块和新文本格式化库打印功能的支持，此程序可以如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can check whether the standard modules `std` and `std.compat` are available
    using the `__cpp_lib_modules` feature macro.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `__cpp_lib_modules` 功能宏来检查标准模块 `std` 和 `std.compat` 是否可用。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Understanding module partitions*, to learn about interface and implementation
    partitions'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解模块分区*，以了解接口和实现分区'
- en: Understanding module partitions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块分区
- en: The source code of a module may become large and difficult to maintain. Moreover,
    a module may be composed of logically separate parts. To help with scenarios such
    as these, modules support composition from parts called *partitions*. A module
    unit that is a partition that exports entities is called a *module interface partition*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模块源代码可能会变得很大且难以维护。此外，一个模块可能由逻辑上独立的几个部分组成。为了帮助处理这些情况，模块支持从称为 *分区* 的部分进行组合。一个作为分区且导出实体的模块单元称为
    *模块接口分区*。
- en: However, there could also be internal partitions that do not export anything.
    Such a partition unit is called a *module implementation partition*. In this recipe,
    you will learn how to work with interface and implementation partitions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可能存在不导出任何内容的内部分区。这样的分区单元称为 *模块实现分区*。在本食谱中，您将学习如何与接口和实现分区一起工作。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe, *Working with modules*, before continuing
    with this one. You will need both the module fundamentals we discussed there and
    the code examples that we will continue with in this recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读本食谱之前，您应该阅读之前的食谱 *使用模块*。您将需要我们在那里讨论的模块基础知识以及我们将在此食谱中继续使用的代码示例。
- en: In the following examples, we will use the `std` module, which is only available
    in C++23\. For previous versions, use `std.core` in VC++ or other particular modules
    supported by your compiler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用`std`模块，它仅在C++23中可用。对于之前的版本，在VC++或其他编译器支持的特定模块中使用`std.core`。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You can split a module into several partitions, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个模块拆分为几个分区，如下所示：
- en: 'Each partition unit must start with a statement of the form `export module`
    `modulename:partitionname;`. Only the global module fragment may precede this
    declaration:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个分区单元必须以`export module modulename:partitionname;`形式的声明开始。只有全局模块片段可以在此声明之前：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the primary module interface unit, import and then export the partitions
    with statements of the form `export import :partitionname`, such as in the following
    example:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主要模块接口单元中，使用`export import :partitionname`形式的声明导入并导出分区，如下例所示：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code importing a module composed from multiple partitions only sees the
    module as a whole if it was built from a single module unit:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入由多个分区组成的模块的代码只看到作为一个整体的模块，如果它是从一个单个模块单元构建的：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is possible to create internal partitions that do not export anything but
    contain code that can be used in the same module. Such a partition must start
    with a statement of the form `module modulename:partitionname;` (without the keyword
    `export`). Different compilers may also require a different extension for the
    file containing an internal partition. For VC++, the extension must be `.cpp`:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以创建不导出任何内容但包含可用于同一模块的代码的内部分区。这样的分区必须以`module modulename:partitionname;`形式的声明开始（不使用`export`关键字）。不同的编译器可能还需要为包含内部分区的文件使用不同的扩展名。对于VC++，扩展名必须是`.cpp`：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code shown earlier is a follow-up of the modules example presented in the
    previous recipe. The `geometry` module has been split into two different partitions
    called `core` and `literals`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的代码是之前菜谱中介绍的模块示例的后续。`geometry`模块已被拆分为两个不同的分区，分别称为`core`和`literals`。
- en: 'However, when you declare the partition, you must use the name in the form
    `modulename:partitionname`, such as in `geometry:core` and `geometry:literals`.
    This is not necessary when you import a partition elsewhere in the module. This
    can be seen both in the primary partition unit `geometry.ixx` and in the module
    interface partition `geometry-literals.ixx`. Here are the snippets again, for
    clarity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你声明分区时，你必须使用`modulename:partitionname`这种形式的名称，例如在`geometry:core`和`geometry:literals`中。在其他地方导入分区时，这并不是必需的。这可以在主要分区单元`geometry.ixx`和模块接口分区`geometry-literals.ixx`中看到。以下是一些清晰度更高的片段：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Although module partitions are distinct files, they are not available as separate
    modules or submodules to translation units using a module. They are exported together
    as a single, aggregated module. If you compare the source code in the `main.cpp`
    file with the one from the previous recipe, you will see no difference.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模块分区是独立的文件，但它们对于使用模块的翻译单元来说并不是作为单独的模块或子模块可用的。它们作为一个单一、聚合的模块一起导出。如果你比较`main.cpp`文件中的源代码和之前菜谱中的代码，你将看不到任何区别。
- en: As with module interface units, there are no rules for naming the files containing
    partitions. However, compilers may require different extensions or support some
    particular naming schemes. For instance, VC++ uses the scheme `<module-name>-<partition-name>.ixx`,
    which simplifies build commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块接口单元一样，没有命名包含分区的文件的规则。然而，编译器可能需要不同的扩展名或支持某些特定的命名方案。例如，VC++使用`<module-name>-<partition-name>.ixx`方案，这简化了构建命令。
- en: Partitions, just like modules, may contain code that is not exported from the
    module. A partition may contain no exports at all, in which case it is an internal
    partition only. Such a partition is called a *module implementation partition*.
    It is defined without using the `export` keyword in the module’s declaration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分区，就像模块一样，可能包含未从模块导出的代码。一个分区可能完全不包含导出项，在这种情况下，它仅是一个内部分区。这样的分区被称为*模块实现分区*。它是在模块声明中不使用`export`关键字定义的。
- en: An example of an internal partition is the `geometry:details` partition shown
    earlier. It provides a helper function, called `split()`, to parse two integers
    separated with a comma from a string. This partition is then imported into the
    `geometry:literals` partitions, where the `split()` function is used to implement
    the user-defined literal `_ip`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个内部分区的例子是前面展示的 `geometry:details` 分区。它提供了一个名为 `split()` 的辅助函数，用于从字符串中解析由逗号分隔的两个整数。然后，这个分区被导入到
    `geometry:literals` 分区中，其中 `split()` 函数被用来实现用户定义的文法 `_ip`。
- en: There’s more...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Partitions are divisions of a module. However, they are not submodules. They
    do not logically exist outside of the module. There is no concept of a submodule
    in the C++ language. The code shown in this recipe using partitions could be written
    slightly differently using modules:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是模块的划分。然而，它们不是子模块。它们在模块之外没有逻辑存在。C++ 语言中没有子模块的概念。在这个菜谱中展示的代码使用分区可以稍微不同地使用模块来编写：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we have three modules: `geometry.core`, `geometry.literals`,
    and `geometry`. Here, `geometry` imports and then re-exports the entire content
    of the first two. Because of this, the code in `main.cpp` does not need to change.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有三个模块：`geometry.core`、`geometry.literals` 和 `geometry`。在这里，`geometry`
    导入并重新导出了前两个模块的全部内容。正因为如此，`main.cpp` 中的代码不需要更改。
- en: By solely importing the `geometry` module, we get access to the content of the
    `geometry.core` and `geometry.literals` modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过导入 `geometry` 模块，我们就可以访问 `geometry.core` 和 `geometry.literals` 模块的内容。
- en: 'However, if we do not define the `geometry` module anymore, then we need to
    explicitly import the two modules, as shown in the following snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不再定义 `geometry` 模块，那么我们需要显式地导入这两个模块，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Choosing between using partitions or multiple modules to componentize your source
    code should depend on the particularities of your project. If you use multiple
    smaller modules, you provide better granularity for imports. This can be important
    if you’re developing a large library because users should only import things they
    use (and not a very large module when they only need some functionalities).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用分区或多个模块来组件化源代码之间进行选择应取决于你项目的特定性。如果你使用多个较小的模块，你提供了更好的导入粒度。如果你正在开发一个大型的库，这可能很重要，因为用户应该只导入他们使用的东西（而不是当他们只需要一些功能时导入一个非常大的模块）。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with modules*, to explore the fundamentals of C++20 modules'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与模块一起工作*，以探索 C++20 模块的基础知识'
- en: Specifying requirements on template arguments with concepts
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用概念指定模板参数的要求
- en: 'Template metaprogramming is an important part of the C++ language, empowering
    the development of general-purpose libraries, including the standard library.
    However, template metaprogramming is not trivial. On the contrary, complex tasks
    could be tedious and difficult to get right without a lot of experience. In fact,
    the C++ Core Guidelines, an initiative created by Bjarne Stroustrup and Herb Sutter,
    have a rule called *Use template metaprogramming only when you really need to,*
    which reasons that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程是 C++ 语言的重要组成部分，它赋予了开发通用库（包括标准库）的能力。然而，模板元编程并非易事。相反，没有丰富的经验，复杂任务可能会变得繁琐且难以正确实现。事实上，由
    Bjarne Stroustrup 和 Herb Sutter 创建的 C++ Core Guidelines 初始项目有一个规则叫做 *仅在真正需要时使用模板元编程*，该规则的理由是：
- en: Template metaprogramming is hard to get right, slows down compilation, and is
    often very hard to maintain.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模板元编程很难正确实现，会减慢编译速度，并且通常很难维护。
- en: An important aspect concerning template metaprogramming has been the specification
    of constraints for type template parameters, in order to impose restrictions on
    the types that a template can be instantiated with. The C++20 concepts library
    is designed to solve this problem. A concept is a named set of constraints, and
    a constraint is a requirement for a template argument. These are used to select
    the appropriate function overloads and template specializations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程的一个重要方面是针对类型模板参数的约束指定，以便对可以实例化的模板类型施加限制。C++20 概念库旨在解决这个问题。概念是一组命名的约束，约束是对模板参数的要求。这些用于选择合适的函数重载和模板特化。
- en: In this recipe, we will see how we can use C++20 concepts to specify requirements
    on template arguments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用 C++20 概念来指定模板参数的要求。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin learning about concepts, let’s consider the following class
    template, called `NumericalValue`, which is supposed to hold a value of an integral
    or floating-point type. This C++11 implementation employs the use of `std::enable_if`
    to specify requirements for the `T` template argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习概念之前，让我们考虑以下类模板，称为`NumericalValue`，它应该包含整型或浮点型的值。这个C++11实现使用了`std::enable_if`来指定`T`模板参数的要求：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This snippet will be the basis for the examples shown in this recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将是本食谱中展示的示例的基础。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You can specify requirements for template arguments as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以如下指定模板参数的要求：
- en: 'Create a concept using the `concept` keyword with the following form:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下形式的`concept`关键字创建一个概念：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you can use one of the standard-defined concepts, available
    in the header `<concepts>` (or one of the other standard library headers):'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以使用标准定义的概念之一，这些概念在头文件`<concepts>`（或标准库的其他头文件）中可用：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the concept name instead of the `class` or `typename` keywords in function
    templates, class templates, or variable templates:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数模板、类模板或变量模板中使用概念名称而不是`class`或`typename`关键字：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instantiate class templates and call function templates with no changes in
    syntax:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语法不变的方式实例化类模板和调用函数模板：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A concept is a set of one or more constraints that is always defined in a namespace
    scope. The definition of a concept is similar to a variable template. The following
    snippet shows a concept being used for a variable template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 概念是一组一个或多个约束，总是在命名空间范围内定义。概念的定义类似于变量模板。以下代码片段展示了如何使用概念作为变量模板：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Concepts cannot be constrained themselves, nor can they refer to themselves
    recursively. In the examples shown so far, the `Numerical` and `Real` concepts
    are composed of a single, atomic constraint. However, concepts can be created
    from multiple constraints. A constraint created from two constraints using the
    `&&` logical operator is called a *conjunction*, while a constraint created from
    two constraints using the `||` logical operator is called a *disjunction*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 概念本身不能被约束，也不能递归地引用自己。在前面展示的例子中，`Numerical`和`Real`概念由单个原子约束组成。然而，可以从多个约束创建概念。使用`&&`逻辑运算符从两个约束创建的约束称为*结合*，而使用`||`逻辑运算符从两个约束创建的约束称为*析取*。
- en: 'The `Numerical` concept defined in the *How to do it...* section was defined
    using the `std::is_arithmetic_v` type trait. However, we could have two concepts,
    `Real` and `Integral`, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分定义的`Numerical`概念使用了`std::is_arithmetic_v`类型特性。然而，我们可以有两个概念，`Real`和`Integral`，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From these two, we can compose the `Numerical` concept, using the `||` logical
    operator. The result is a disjunction:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个类中，我们可以使用`||`逻辑运算符组合出`Numerical`概念，结果是析取：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Semantically, there is no difference between these two versions of the `Numerical`
    concept, although they are defined in different ways.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上看，这两个版本的`Numerical`概念没有区别，尽管它们是以不同的方式定义的。
- en: 'To understand conjunctions, let’s look at another example. Consider two base
    classes, `IComparableToInt` and `IConvertibleToInt`, that are supposed to be derived
    by classes that should support comparison or conversion to `int`. These could
    be defined as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解结合，让我们看另一个例子。考虑两个基类，`IComparableToInt`和`IConvertibleToInt`，它们应该被支持比较或转换为`int`的类继承。这些可以定义如下：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Some classes can implement both of them, others only one or the other. The
    `SmartNumericalValue<T>` class here implements both, while `DullNumericalValue<T>`
    only implements the `IConvertibleToInt` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类可以实现这两个概念，而另一些类只实现其中一个或另一个。这里的`SmartNumericalValue<T>`类实现了这两个概念，而`DullNumericalValue<T>`只实现了`IConvertibleToInt`类：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we want to do is write a function template that only accepts arguments
    that are both comparable and can be converted to `int`. The `IComparableAndConvertible`
    concept shown here is a conjunction of the `IntComparable` and `IntConvertible`
    concepts. They can be implemented as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个函数模板，它只接受既是可比较的又可转换为`int`类型的参数。这里展示的`IComparableAndConvertible`概念是`IntComparable`和`IntConvertible`概念的结合。它们可以如下实现：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Conjunctions and disjunctions are evaluated left to right and are short-circuited.
    This means that for a conjunction, the right constraint is evaluated only if the
    left one is satisfied, and for a disjunction, the right constraint is evaluated
    only if the left one is not satisfied.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 合取和析取是从左到右评估的，并且是短路执行的。这意味着对于合取，只有当左边的约束满足时，才会评估右边的约束；对于析取，只有当左边的约束不满足时，才会评估右边的约束。
- en: The third category of constraints is *atomic constraints*. These are composed
    of an expression `E` and a mapping between the type parameters from `E` and the
    template arguments of the constrained entity, called *parameter mapping*. The
    atomic constraints are formed during *constraint normalization*, which is the
    process of transforming a constraint expression into a sequence of conjunctions
    and disjunctions of atomic constraints. An atomic constraint is checked by substituting
    the parameter mapping and the template arguments into the expression `E`. The
    result must be a valid prvalue constant expression of type `bool`; otherwise,
    the constraint is not satisfied.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类约束是*原子约束*。这些约束由一个表达式`E`以及从`E`的类型参数到约束实体的模板参数之间的映射组成，称为*参数映射*。原子约束是在*约束规范化*过程中形成的，这是一个将约束表达式转换成一系列原子约束的合取和析取的过程。通过将参数映射和模板参数代入表达式`E`来检查原子约束。结果必须是一个有效的`bool`类型的prvalue常量表达式；否则，约束不满足。
- en: 'The standard library defines a series of concepts that can be used to define
    compile-time requirements on template arguments. Although most of these concepts
    impose both syntactic and semantic requirements, the compiler can usually ensure
    only the former. When the semantic requirements are not met, the program is considered
    ill-formed, and the compiler is not required to provide any diagnostics about
    the problem. The standard concepts are available in several places:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库定义了一系列概念，可以用来定义对模板参数的编译时要求。尽管这些概念大多数都同时施加了语法和语义要求，但编译器通常只能确保前者。当语义要求不满足时，程序被认为是无效的，编译器不需要提供任何关于问题的诊断。标准概念可以在几个地方找到：
- en: In the concepts library, in the `<concepts>` header and the `std` namespace.
    This includes core language concepts (such as `same_as`, `integral`, `floating_point`,
    `copy_constructible`, and `move_constructible`), comparison concepts (such as
    `equality_comparable` and `totally_ordered`), object concepts (such as `copyable`,
    `moveable`, and `regular`), and callable concepts (such as `invocable` and `predicate`).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在概念库中，在`<concepts>`头文件和`std`命名空间中。这包括核心语言概念（如`same_as`、`integral`、`floating_point`、`copy_constructible`和`move_constructible`），比较概念（如`equality_comparable`和`totally_ordered`），对象概念（如`copyable`、`moveable`和`regular`），以及可调用概念（如`invocable`和`predicate`）。
- en: In the algorithms library, in the `<iterator>` header and the `std` namespace.
    This includes algorithm requirements (such as `sortable`, `permutable`, and `mergeable`)
    and indirect callable concepts (such as `indirect_unary_predicate` and `indirect_binary_predicate`).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在算法库中，在`<iterator>`头文件和`std`命名空间中。这包括算法要求（如`sortable`、`permutable`和`mergeable`）和间接可调用概念（如`indirect_unary_predicate`和`indirect_binary_predicate`）。
- en: In the ranges library, in the `<ranges>` header and the `std::ranges` namespace.
    This includes concepts specific for ranges, such as `range`, `view`, `input_range`,
    `output_range`, `forward_range`, and `random_access_range`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范围库中，在`<ranges>`头文件和`std::ranges`命名空间中。这包括针对范围的概念，如`range`、`view`、`input_range`、`output_range`、`forward_range`和`random_access_range`。
- en: There’s more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The concepts defined in this recipe used the already available type traits.
    However, there are many cases when requirements on template arguments cannot be
    described in this way. For this reason, concepts can be defined with a *requires
    expression*, which is a prvalue expression of type `bool`, describing a template
    argument requirement. This will be the topic of the next recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中定义的概念使用了已经可用的类型特性。然而，有许多情况下对模板参数的要求无法用这种方式描述。因此，可以使用*`requires`表达式*来定义概念，这是一个`bool`类型的prvalue表达式，描述了模板参数的要求。这将是下一个配方的主题。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using requires expressions and clauses*, to learn about in-place constraints'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`requires`表达式和子句*，了解就地约束'
- en: Using requires expressions and clauses
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`requires`表达式和子句
- en: In the previous recipe, we introduced the topic of concepts and constraints,
    learning about them with the help of several examples that were solely based on
    already existing type traits. Moreover, we also used the terser syntax to specify
    concepts, with the concept name used instead of the `typename` or the `class`
    keyword in the template declaration. However, it is possible to define more complex
    concepts with the help of *requires expressions*. These are prvalues of the type
    `bool` that describe the constraints on some template arguments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们介绍了概念和约束的主题，通过几个仅基于现有类型特征的示例来了解它们。此外，我们还使用了更简洁的语法来指定概念，在模板声明中使用概念名称代替`typename`或`class`关键字。然而，借助*requires表达式*可以定义更复杂的概念。这些是描述某些模板参数约束的`bool`类型的prvalue。
- en: In this recipe, we will learn how to write requires expressions and an alternative
    way to specify constraints on template arguments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何编写requires表达式以及指定模板参数约束的另一种方法。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The class template `NumericalValue<T>` and the function template `wrap()` defined
    in the previous recipe will be used in the code snippets presented in this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中展示的代码片段中，将使用上一个配方中定义的类模板`NumericalValue<T>`和函数模板`wrap()`。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To specify requirements for template arguments, you can use requires expressions,
    introduced with the `requires` keyword, such as the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定模板参数的要求，可以使用`requires`关键字引入的requires表达式，如下所示：
- en: 'Use a simple expression that the compiler validates for correctness. In the
    following snippet, the operator `+` must be overloaded for the `T` template argument:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个简单的表达式，编译器会验证其正确性。在下面的代码片段中，必须为`T`模板参数重载运算符`+`：
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use a simple expression to require the existence of a particular function.
    In the following snippet, a function called `wrap()`, which is overloaded with
    a parameter of the `T` template argument, must exist:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个简单的表达式来要求存在特定的函数。在以下代码片段中，必须存在一个名为`wrap()`的函数，该函数使用`T`模板参数的重载参数：
- en: '[PRE25]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use a type requirement, specified with the keyword `typename`, followed by
    the name of a type, optionally qualified, to specify requirements such as member
    names, class template specializations, or alias template substitutions. In the
    following snippet, the `T` template argument must have two inner types called
    `value_type` and `iterator`. Additionally, two functions, `begin()` and `end()`,
    which take a `T` argument, must be available:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型要求，通过`typename`关键字后跟类型名称（可选地带有限定符）来指定要求，例如成员名称、类模板特化或别名模板替换。在以下代码片段中，`T`模板参数必须有两个内部类型称为`value_type`和`iterator`。此外，还必须提供两个函数`begin()`和`end()`，它们接受`T`参数：
- en: '[PRE26]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use a compound requirement to specify the requirements of an expression, as
    well as the result of the evaluation of the expression. In the following example,
    there must be a function called `wrap()` that can be called with an argument of
    the `T` template argument type, and the result of calling the function must be
    of the `NumericalValue<T>` type:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复合要求来指定表达式的需求以及表达式的评估结果。在以下示例中，必须存在一个名为`wrap()`的函数，它可以接受`T`模板参数类型的参数，并且调用该函数的结果必须是`NumericalValue<T>`类型：
- en: '[PRE27]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Constraints on the template arguments can also be specified using a syntax,
    involving the `requires` keyword. These are called *requires clauses* and can
    be used as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数的约束也可以使用涉及`requires`关键字的语法来指定。这些称为*requires子句*，可以如下使用：
- en: 'Use a requires clause after the template parameter list:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板参数列表之后使用requires子句：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, use the requires clause after the last element of a function
    declarator:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，在函数声明符的最后一个元素之后使用requires子句：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Combine a requires clause with a requires expression, instead of a named concept.
    In this case, the `requires` keyword appears twice, as shown in the following
    snippet:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将requires子句与requires表达式结合，而不是使用命名概念。在这种情况下，`requires`关键字出现了两次，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The new `requires` keyword has multiple purposes. On one hand, it is used to
    introduce a requires clause that specifies constraints on template arguments.
    On the other hand, it is used to define a requires expression that is a prvalue
    of type `bool` used to define constraints on template arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`requires`关键字具有多个用途。一方面，它用于引入一个指定模板参数约束的requires子句。另一方面，它用于定义一个`bool`类型的prvalue的requires表达式，用于定义模板参数的约束。
- en: If you are not familiar with C++ value categories (*lvalue*, *rvalue*, *prvalue*,
    *xvalue*, *glvalue*), you are recommended to check [https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category).
    The term *prvalue*, meaning *pure rvalue*, specifies an rvalue that is not an
    xvalue (expiring value). Examples of prvalues are literals, function calls whose
    return type is not a reference type, an enumerator, or the `this` pointer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉C++值类别（*lvalue*、*rvalue*、*prvalue*、*xvalue*、*glvalue*），建议你检查[https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category)。术语*prvalue*，意为*纯右值*，指定了一个不是xvalue（即将过期的值）的右值。prvalue的例子包括字面量、返回类型不是引用类型的函数调用、枚举或`this`指针。
- en: In a requires clause, the `requires` keyword must be followed by a constant
    expression of the type `bool`. The expression must be either a primary expression
    (such as `std::is_arithmetic_v<T>` or `std::integral<T>`), an expression in parentheses,
    or any sequence of such expressions joined with either the `&&` or the `||` operator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`requires`子句中，`requires`关键字必须后跟一个类型为`bool`的常量表达式。该表达式必须是原始表达式（例如`std::is_arithmetic_v<T>`或`std::integral<T>`），括号内的表达式，或者任何这样的表达式的序列，这些表达式通过`&&`或`||`运算符连接。
- en: 'A requires expression has the form `requires (parameters-list) { requirements
    }`. The parameters list is optional and can be entirely omitted (including the
    parentheses). The specified requirements may refer to:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`requires`表达式的形式为`requires (parameters-list) { requirements }`。参数列表是可选的，并且可以完全省略（包括括号）。指定的需求可以引用：
- en: The template parameters that are in scope
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围内的模板参数
- en: The local parameters introduced in `parameters-list`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`parameters-list`中引入的局部参数
- en: Any other declarations that are visible from the enclosing context
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何从封装上下文中可见的其他声明
- en: 'The requirements sequence of the requires expression can contain requirements
    of the following types:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`表达式的需求序列可以包含以下类型的需求：'
- en: '**Simple requirements**: These are arbitrary expressions that do not start
    with the `requires` keyword. The compiler only checks its language correctness.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单需求**：这些是不以`requires`关键字开头的任意表达式。编译器只检查其语言正确性。'
- en: '**Type requirements**: These are expressions that start with the keyword `typename`
    followed by a type name, which must be valid. This enables the compiler to validate
    that a certain nested name exists, or that a class template specialization or
    an alias template substitution exists.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型需求**：这些是以关键字`typename`开头后跟一个类型名称的表达式，它必须是有效的。这使编译器能够验证是否存在某个嵌套名称，或者是否存在类模板特化或别名模板替换。'
- en: '**Compound requirements**: They have the form `{expression} noexcept -> type-constraint`.
    The `noexcept` keyword is optional, in which case the expression must not be potentially
    throwing. The requirement for the return type, introduced with `->`, is also optional.
    However, if it is present, then `decltype(expression)` must satisfy the constraints
    imposed by `type-constraint`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合需求**：它们的形式为`{expression} noexcept -> type-constraint`。`noexcept`关键字是可选的，在这种情况下，表达式不得是可能抛出异常的。使用`->`引入的返回类型需求也是可选的。然而，如果它存在，那么`decltype(expression)`必须满足`type-constraint`施加的约束。'
- en: '**Nested requirements**: These are more complex expressions that specify constraints
    defined as a requires expression, which can, in turn, be another nested requirement.
    A requirement that starts with the keyword `requires` is considered a nested requirement.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套需求**：这些是更复杂的表达式，它们指定了定义为requires表达式的约束，而这些表达式本身又可以是一个嵌套需求。以关键字`requires`开头的需求被视为嵌套需求。'
- en: Before they are evaluated, the body of every name concept and every `requires`
    expression is substituted until a sequence of conjunctions and disjunctions of
    atomic constraints is obtained. This process is called *normalization*. The actual
    details of normalization and the analysis the compiler performs are beyond the
    scope of this book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们被评估之前，每个名称概念和每个`requires`表达式的主体都会被替换，直到获得一系列原子约束的合取和析取。这个过程被称为*规范化*。规范化及其分析的实际细节超出了本书的范围。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用概念指定模板参数的需求*，以探索C++20概念的基础'
- en: Exploring abbreviated function templates
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索缩写函数模板
- en: In *Chapter 3*, we learned about function templates as well as lambda expressions,
    including generic and template lambdas. A generic lambda is a lambda expression
    that uses `auto` specified for one of its parameters. The result is a function
    object with a templated call operator. The same is produced as a result of defining
    a lambda template that has the advantage, over generic lambdas, of allowing better
    control over the types of the parameters. In C++20, this idea of using the `auto`
    specifier for parameter types is generalized for all functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*中，我们学习了函数模板以及lambda表达式，包括泛型和模板lambda。泛型lambda是一个使用`auto`指定符为其参数之一指定的lambda表达式。结果是具有模板调用操作符的函数对象。同样，定义具有更好参数类型控制优势的lambda模板也会产生相同的结果。在C++20中，这种为参数类型使用`auto`指定符的想法被推广到所有函数。
- en: This introduces a simplified syntax of defining function templates, and functions
    that are defined in this way are called **abbreviated function templates**. We
    will see in this recipe how to use them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了定义函数模板的简化语法，以这种方式定义的函数被称为**简化函数模板**。我们将在这个菜谱中看到如何使用它们。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'You can define the following categories of abbreviated function templates in
    C++20:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在C++20中定义以下类别的简化函数模板：
- en: 'Unconstrained abbreviated function templates that use the `auto` specifier
    to define parameters:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`指定符定义参数的非约束简化函数模板：
- en: '[PRE31]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Constrained abbreviated function templates that use concepts, specified before
    the `auto` specifier, to constrain the parameters of the function template:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在`auto`指定符之前指定的概念来约束函数模板参数的约束简化函数模板：
- en: '[PRE32]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Constrained variadic abbreviated function templates that use the syntax seen
    above but with a parameter pack:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上述语法但带有参数包的约束简化变长函数模板：
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Constrained abbreviated lambda expressions that use the syntax seen above but
    with a lambda expression:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上述语法但带有lambda表达式的约束简化lambda表达式：
- en: '[PRE34]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Specializations of abbreviated function templates can be defined just as for
    function templates defined with the regular template syntax:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化函数模板的特殊化可以像使用常规模板语法定义的函数模板一样定义：
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The template syntax is considered by many rather cumbersome. Abbreviated function
    templates are meant to simplify writing some categories of function templates.
    They do so by using the `auto` specifier as a placeholder for parameter types,
    instead of the typical template syntax. The following two definitions are equivalent:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模板语法被认为相当繁琐。简化函数模板旨在简化编写某些类别的函数模板。它们通过使用`auto`指定符作为参数类型的占位符来实现这一点，而不是典型的模板语法。以下两个定义是等价的：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the intention is to define a function template with both arguments of the
    same type, then this form of the abbreviated function template is not enough.
    These abbreviated function templates are called **unconstrained** because there
    are no constraints placed on the arguments of the function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意图是定义具有相同类型参数的函数模板，那么这种简化函数模板的形式就不够了。这些简化函数模板被称为**非约束**，因为函数的参数上没有放置任何约束。
- en: 'Such constraints can be defined with the help of concepts, as shown below:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用概念的帮助来定义这些约束，如下所示：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The category of abbreviated function templates is called **constrained**. The
    function above is equivalent to the following regular function template:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 约束简化函数模板的类别被称为**约束**。上面的函数等同于以下常规函数模板：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since an abbreviated function template is a function template, it can also
    be specialized like any function declared with the standard template syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简化函数模板是一个函数模板，因此它可以像使用标准模板语法声明的任何函数一样进行特殊化：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Constrained abbreviated function templates can also be variadic; that is, they
    have a variable number of arguments. There is nothing special about them, other
    than what we already learned in *Chapter 5*. Moreover, the syntax can also be
    used to define lambda templates. Examples of these were given in the previous
    section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 约束简化函数模板也可以是变长参数；也就是说，它们具有可变数量的参数。它们没有特别之处，除了我们在*第5章*中学到的那些。此外，该语法还可以用来定义lambda模板。这些示例在上一节中已经给出。
- en: See also
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 3*, *Using generic lambdas*, to learn about the use of both generic
    lambdas and lambda templates'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*，*使用泛型lambda*，了解泛型lambda和lambda模板的使用'
- en: '*Chapter 3*, *Writing function templates* to explore the syntax for writing
    function templates'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三章*，*编写函数模板*，以探索编写函数模板的语法'
- en: '*Chapter 3*, *Writing a function template with a variable number of arguments*,
    to see how you can write functions that take a variable number of arguments'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三章*，*编写具有可变数量参数的函数模板*，以了解您如何编写接受可变数量参数的函数'
- en: '*Specifying requirements on template arguments with concepts*, to learn how
    to constrain the arguments with a function template, with the help of concepts'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用概念指定模板参数的要求*，以了解如何使用函数模板和概念约束参数'
- en: Iterating over collections with the ranges library
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ranges 库遍历集合
- en: The C++ standard library provides three important pillars—containers, iterators,
    and algorithms—that enable us to work with collections. Because these algorithms
    are for general purposes and are designed to work with iterators, which define
    a range, they often require writing explicit and sometimes complex code to achieve
    simple tasks. The C++20 ranges library has been designed to solve this problem
    by providing components for handling ranges of elements. These components include
    range adapters (or views) and constrained algorithms that work with a range instead
    of iterators. In this recipe, we will look at some of these views and algorithms
    and see how they can simplify coding.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库提供了三个重要的支柱——容器、迭代器和算法——使我们能够处理集合。因为这些算法是通用的，并且设计为与迭代器一起工作，迭代器定义了范围，它们通常需要编写显式且有时复杂的代码来实现简单任务。C++20
    ranges 库已被设计用来解决这个问题，通过提供处理元素范围组件。这些组件包括范围适配器（或视图）和与范围一起工作的约束算法，而不是迭代器。在本食谱中，我们将查看一些这些视图和算法，并了解它们如何简化编码。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the following snippets, we will refer to a function called `is_prime()`,
    which takes an integer and returns a Boolean, indicating whether the number is
    prime or not. A simple implementation is shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将参考一个名为 `is_prime()` 的函数，它接受一个整数并返回一个布尔值，指示该数字是否为质数。这里展示了一个简单的实现：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For an efficient algorithm, which is beyond the scope of this recipe, I recommend
    the Miller–Rabin primality test.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个高效的算法（这超出了本食谱的范围），我推荐 Miller–Rabin 质数测试。
- en: 'The ranges library is available in the new `<ranges>` header, in the `std::ranges`
    namespace. For simplicity, the following namespace aliases will be used in this
    recipe:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ranges 库可在新的 `<ranges>` 头文件中找到，位于 `std::ranges` 命名空间中。为了简单起见，本食谱中将使用以下命名空间别名：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will explore various uses of the ranges library in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节探索 ranges 库的各种用法。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The ranges library can be used to iterate through ranges with operations such
    as the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ranges 库可用于通过以下操作迭代范围：
- en: 'Generate a sequence of consecutive integers with the `iota_view` / `views::iota`
    view. The following snippet prints all integers from 1 to 9:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `iota_view` / `views::iota` 视图生成连续整数的序列。以下代码片段打印出从 1 到 9 的所有整数：
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Filter the elements of a range with `filter_view` / `views::filter`, by retaining
    only those that satisfy a predicate. The first snippet here prints all the prime
    numbers from 1 to 99\. However, the second snippet retains and prints all the
    prime numbers from a vector of integers:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `filter_view` / `views::filter` 过滤范围中的元素，仅保留满足谓词的元素。这里的第一段代码打印出从 1 到 99 的所有质数。然而，第二段代码保留并打印出从整数向量中所有的质数：
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Transform the elements of a range with `transform_view` / `views::transform`
    by applying a unary function to each element. The following snippet prints the
    successor of all the prime numbers from 1 to 99:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `transform_view` / `views::transform` 通过对每个元素应用一元函数来转换范围中的元素。以下代码片段打印出从 1
    到 99 的所有质数的后继数：
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Retain only the first *N* elements of a view with `take_view` / `views::take`.
    The following snippet prints only the first 10 prime numbers from 1 and 99:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `take_view` / `views::take` 仅保留视图中的前 *N* 个元素。以下代码片段仅打印出从 1 和 99 的前 10 个质数：
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Iterate a range in reverse order with `reverse_view` / `views::reverse`. The
    first snippet here prints the first 10 prime numbers from 99 to 1 (in descending
    order), while the second snippet prints the last 10 prime numbers from 1 to 99
    (in ascending order):'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `reverse_view` / `views::reverse` 以逆序迭代范围。这里的第一个代码片段打印出从 99 到 1 的前 10 个质数（降序），而第二个代码片段打印出从
    1 到 99 的最后 10 个质数（升序）：
- en: '[PRE46]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Skip the first *N* elements of a range with `drop_view` / `views::drop`. The
    snippet here prints, in ascending order, the prime numbers between 1 and 99, but
    it skips the first and last 10 primes in the sequence:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `drop_view` / `views::drop` 跳过范围中的前 *N* 个元素。以下代码片段按升序打印1到99之间的素数，但跳过了序列中的前10个和最后10个素数：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The ranges library can also be used to call algorithms using a range instead
    of iterators. Most algorithms have overloads for this purpose. Examples are shown
    here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 范围库还可以用于使用范围而不是迭代器调用算法。大多数算法都有为此目的的重载。以下是一些示例：
- en: 'Determine the maximum element of a range:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定范围的最大元素：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sort a range:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对范围进行排序：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Copy a range. The following snippet copies the elements of the range to the
    standard output stream:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制范围。以下代码片段将范围中的元素复制到标准输出流：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Reverse the elements of a range:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转范围中的元素：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Count the elements of a range (that verify a predicate):'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算一个范围内的元素（验证谓词）：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The C++20 ranges library provides various components for dealing with ranges
    of elements. These include:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 范围库提供了处理元素范围的各种组件。这包括：
- en: Range concepts, such as `range` and `view`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围概念，如 `range` 和 `view`。
- en: Range access functions, such as `begin()`, `end()`, `size()`, `empty()`, and
    `data()`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围访问函数，如 `begin()`、`end()`、`size()`、`empty()` 和 `data()`。
- en: Range factories that create sequences of elements, such as `empty_view`, `single_view`,
    and `iota_view`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围工厂，用于创建元素序列，如 `empty_view`、`single_view` 和 `iota_view`。
- en: Range adaptors, or views, that create a lazy evaluated view from a range, such
    as `filter_view`, `transform_view`, `take_view`, and `drop_view`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围适配器或视图，它从范围创建一个延迟评估的视图，例如 `filter_view`、`transform_view`、`take_view` 和 `drop_view`。
- en: 'A range is defined as a sequence of elements that can be iterated over with
    an iterator and an end sentinel. Ranges are of different types, depending on the
    capabilities of the iterators that define the range. The following concepts define
    types of ranges:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 范围被定义为可以由迭代器和结束哨兵迭代的一系列元素。范围类型取决于定义范围的迭代器的功能。以下概念定义了范围类型：
- en: '| **Concept** | **Iterator type** | **Capabilities** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **迭代器类型** | **能力** |'
- en: '| `input_range` | `input_iterator` | Can be iterated at least once for reading.
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `input_range` | `input_iterator` | 至少可以迭代一次以进行读取。|'
- en: '| `output_range` | `output_iterator` | Can be iterated For writing. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `output_range` | `output_iterator` | 可以迭代以进行写入。|'
- en: '| `forward_range` | `forward_iterator` | Can be iterated multiple times. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `forward_range` | `forward_iterator` | 可以多次迭代。|'
- en: '| `bidirectional_range` | `bidirectional_iterator` | Can be iterated also in
    reverse order. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `bidirectional_range` | `bidirectional_iterator` | 也可以以相反的顺序迭代。|'
- en: '| `random_access_range` | `random_access_iterator` | Elements can be accessed
    randomly in constant time. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `random_access_range` | `random_access_iterator` | 元素可以在常数时间内随机访问。|'
- en: '| `contiguous_range` | `contiguous_iterator` | Elements are stored contiguously
    in memory. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `contiguous_range` | `contiguous_iterator` | 元素在内存中连续存储。|'
- en: 'Table 12.1: The list of concepts that define the types of ranges'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1：定义范围类型的概念列表
- en: Because a `forward_iterator` satisfies the requirements of an `input_iterator`,
    and a `bidirectional_iterator` satisfies those of a `forward_iterator`, and so
    on (from top to bottom in the preceding table), so do the ranges. A `forward_range`
    satisfies the requirements of an `input_range`, and a `bidirectional_range` satisfies
    those of a `forward_range`, and so on. Apart from the range concepts listed in
    the preceding table, there are other range concepts. One worth mentioning is `sized_range`,
    which requires that a range must know its size in constant time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `forward_iterator` 满足 `input_iterator` 的要求，`bidirectional_iterator` 满足 `forward_iterator`
    的要求，依此类推（从上表中的顶部到底部），所以范围也是如此。`forward_range` 满足 `input_range` 的要求，`bidirectional_range`
    满足 `forward_range` 的要求，依此类推。除了上表中列出的范围概念之外，还有其他范围概念。其中一个值得提的是 `sized_range`，它要求范围必须在常数时间内知道其大小。
- en: 'The standard containers meet the requirements of different range concepts.
    The most important of them are listed in the following table:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器满足不同范围概念的要求。其中最重要的列在以下表格中：
- en: '|  | **Input range** | **Forward range** | **Bidirectional range** | **Random
    access range** | **Contiguous range** |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  | **输入范围** | **前向范围** | **双向范围** | **随机访问范围** | **连续范围** |'
- en: '| `forward_list` | ✓ | ✓ |  |  |  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `forward_list` | ✓ | ✓ |  |  |  |'
- en: '| `list` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `list` | ✓ | ✓ | ✓ |  |  |'
- en: '| `dequeue` | ✓ | ✓ | ✓ | ✓ |  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `dequeue` | ✓ | ✓ | ✓ | ✓ |  |'
- en: '| `array` | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `array` | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `vector` | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `vector` | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| `set` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `set` | ✓ | ✓ | ✓ |  |  |'
- en: '| `map` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `map` | ✓ | ✓ | ✓ |  |  |'
- en: '| `multiset` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `multiset` | ✓ | ✓ | ✓ |  |  |'
- en: '| `multimap` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `multimap` | ✓ | ✓ | ✓ |  |  |'
- en: '| `unordered_set` | ✓ | ✓ |  |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set` | ✓ | ✓ |  |  |  |'
- en: '| `unordered_map` | ✓ | ✓ |  |  |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_map` | ✓ | ✓ |  |  |  |'
- en: '| `unordered_multiset` | ✓ | ✓ |  |  |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_multiset` | ✓ | ✓ |  |  |  |'
- en: '| `unordered_multimap` | ✓ | ✓ |  |  |  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_multimap` | ✓ | ✓ |  |  |  |'
- en: 'Table 12.2: A list of standard containers and the requirements they meet'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2：标准容器列表及其满足的要求
- en: A central concept of the ranges library is the range *adaptor*, also called
    a *view*. A view is a non-owning wrapper of a range of elements that requires
    constant time to copy, move, or assign elements. Views are composable adaptations
    of ranges. However, these adaptations happen lazily, only when the view is iterated.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 范围库的一个核心概念是范围*适配器*，也称为*视图*。视图是元素范围的非拥有包装器，复制、移动或赋值元素需要常数时间。视图是范围的组合适配。然而，这些适配是延迟发生的，仅在视图迭代时发生。
- en: 'In the previous section, we saw examples of using various views: filter, transform,
    take, drop, and reverse. There are a total of 16 views available in the library.
    All the views are available in the namespace `std::ranges` and have names such
    as `filter_view`, `transform_view`, `take_view`, `drop_view`, and `reverse_view`.
    However, for simplicity of use, these views can be used with expressions of the
    form `views::filter`, `views::take`, `views::reverse`, and so on. Notice that
    the types and values of these expressions are unspecified and are a compiler implementation
    detail.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了使用各种视图的示例：过滤、转换、取、丢弃和反转。库中共有16个视图可用。所有视图都位于`std::ranges`命名空间中，名称如`filter_view`、`transform_view`、`take_view`、`drop_view`和`reverse_view`。然而，为了使用简便，这些视图可以用`views::filter`、`views::take`、`views::reverse`等形式的表达式使用。请注意，这些表达式的类型和值是不指定的，是编译器实现细节。
- en: 'To understand how the views work, let’s take a look at the following example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解视图是如何工作的，让我们看看以下示例：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The composition of views is equivalent to the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的组合等同于以下：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In general, the following rules apply:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，以下规则适用：
- en: If an adaptor `A` takes only one argument, a range `R`, then `A(R)` and `R|A`
    are equivalent.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适配器`A`只接受一个参数，一个范围`R`，那么`A(R)`和`R|A`是等价的。
- en: 'If an adaptor `A` takes multiple arguments, a range `R` and `args...`, then
    the following three are equivalent: `A(R, args...)`, `A(args...)(R)`, and `R|A(args...)`.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适配器`A`接受多个参数，一个范围`R`和`args...`，那么以下三个是等价的：`A(R, args...)`、`A(args...)(R)`和`R|A(args...)`。
- en: Apart from ranges and range adaptors (or views), overloads of the general-purpose
    algorithms are also available in C++20, in the same `std::ranges` namespace. These
    overloads are called *constrained algorithms*. A range can be provided either
    as a single argument (as seen in the examples in this recipe) or as an iterator-sentinel
    pair. Also, for these overloads, the return type has been changed to provide additional
    information that’s computed during the execution of the algorithm.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了范围和范围适配器（或视图）之外，C++20中通用算法的重载也可用，位于相同的`std::ranges`命名空间中。这些重载被称为*约束算法*。范围可以提供一个单一参数（如本食谱中的示例所示）或一个迭代器-哨兵对。此外，对于这些重载，返回类型已更改，以提供在算法执行期间计算出的附加信息。
- en: There’s more...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The standard ranges library has been designed based on the **range-v3** library,
    created by Eric Niebler and available on GitHub at [https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3).
    This library provides a larger set of range adaptors (views), as well as actions
    that provide mutating operations (such as sorting, erasing, shuffling, and so
    on). The transition from the range-v3 library to the C++20 ranges library can
    be very smooth. In fact, all the samples provided in this recipe work with both
    libraries. All you have to do is include the appropriate header files and use
    the range-v3-specific namespaces:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 标准范围库是基于由Eric Niebler创建的**range-v3**库设计的，可在GitHub上找到[https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3)。这个库提供了一组更大的范围适配器（视图），以及提供突变操作的行动（如排序、删除、洗牌等）。从range-v3库到C++20范围库的过渡可以非常平滑。实际上，本食谱中提供的所有示例都适用于这两个库。你只需要包含适当的头文件并使用range-v3特定的命名空间：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With these replacements, all the snippets from the *How to do it...* section
    will continue to work using a C++17-compliant compiler.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些替换，*如何做到这一点…* 部分的所有代码片段将继续使用符合 C++17 的编译器工作。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating your own range view*, to see how to extend the ranges library’s capabilities
    with user-defined range adaptors'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自己的范围视图*，以了解如何通过用户定义的范围适配器扩展范围库的功能'
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用概念指定模板参数的要求*，以探索 C++20 概念的基础'
- en: Exploring the standard range adaptors
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索标准范围适配器
- en: In the previous recipe, we looked at how the ranges library helps us simplify
    various tasks when working with collections (ranges), such as enumerating, filtering,
    transforming, and reversing. We did so with the help of range adaptors. However,
    we have only looked at a small set of adaptors. There are more available in the
    standard library, some included in C++20 and others in C++23\. In this recipe,
    we will explore all the adapters in the standard library.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们探讨了范围库如何帮助我们简化使用集合（范围）时的各种任务，例如枚举、过滤、转换和反转。我们借助范围适配器做到了这一点。然而，我们只查看了一小部分适配器。标准库中还有更多适配器，其中一些包含在
    C++20 中，其他包含在 C++23 中。在本食谱中，我们将探索标准库中的所有适配器。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the snippets shown in this recipe, we will use the following namespace aliases:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中显示的代码片段中，我们将使用以下命名空间别名：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Also, to compile the snippets below, you need to include the `<ranges>` and
    `<algorithm>` headers (for the ranges library).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了编译下面的代码片段，您需要包含 `<ranges>` 和 `<algorithm>` 头文件（用于范围库）。
- en: How to do it…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In C++20, the following adaptors are available to use:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，以下适配器可供使用：
- en: '`ranges::filter_view` / `views::filter` represents a view of the underlying
    sequence but without the elements that do not satisfy a specified predicate:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::filter_view` / `views::filter` 表示底层序列的视图，但不包含不满足指定谓词的元素：'
- en: '[PRE57]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`ranges::transform_view` / `views::transform` represents a view of the underlying
    sequence after applying a specified function to each element of the range:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::transform_view` / `views::transform` 表示在将指定函数应用于范围中的每个元素之后，底层序列的视图：'
- en: '[PRE59]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`ranges::take_view` / `views::take` represents a view of the underlying sequence,
    starting at the beginning and containing the specified number of elements:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::take_view` / `views::take` 表示从序列的开始处开始，包含指定数量的元素的底层序列视图：'
- en: '[PRE61]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`ranges::take_while_view` / `views::take_while` represents a view of the underlying
    sequence, starting at the beginning and containing all the consecutive elements
    that satisfy a given predicate:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::take_while_view` / `views::take_while` 表示从开始处开始，包含所有满足给定谓词的连续元素的底层序列视图：'
- en: '[PRE63]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ranges::drop_view` / `views::drop` represents a view of the underlying sequence
    after skipping the specified number of elements:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::drop_view` / `views::drop` 表示跳过指定数量的元素之后的底层序列视图：'
- en: '[PRE65]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`ranges::drop_while_view` / `views::drop_while` represents a view of the underlying
    sequence after skipping all the consecutive elements (from the beginning) that
    satisfy a given predicate:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::drop_while_view` / `views::drop_while` 表示跳过所有满足给定谓词的连续元素（从开始处）之后的底层序列视图：'
- en: '[PRE67]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`ranges::join_view` / `views::join` flattens a view of ranges; it represents
    a view consisting of all the elements of a sequence of sequences:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::join_view` / `views::join` 展平范围视图；它表示由序列序列的所有元素组成的视图：'
- en: '[PRE69]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`ranges::split_view` / `views::split` represents a view of subranges obtained
    by splitting a view with a specified delimiter. The delimiter is not part of the
    resulting subranges:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::split_view` / `views::split` 表示通过使用指定分隔符拆分视图获得的子范围视图。分隔符不是结果子范围的一部分：'
- en: '[PRE71]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`ranges::lazy_split_view` / `views::lazy_split` is similar to `split`, except
    that it works in a *lazy mode*, meaning that it does not look ahead for the next
    delimiter until we iterate for the next element of the result. It works with constant
    ranges, which are not supported by `split_view`:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::lazy_split_view` / `views::lazy_split` 与 `split` 类似，但它以 *延迟模式* 运行，这意味着它不会在迭代下一个结果元素之前查找下一个分隔符。它与常量范围一起工作，这些范围不受
    `split_view` 支持：'
- en: '[PRE73]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`ranges::reverse_view` / `views::reverse` represents a view of an underlying
    sequence with the elements presented in the reverse order:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::reverse_view` / `views::reverse` 表示以逆序呈现元素的底层序列视图：'
- en: '[PRE75]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`ranges::elements_view` / `views::elements` represents a view of the *N*th
    element of an underlying sequence of tuple-like values:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::elements_view` / `views::elements` 表示对元组值底层序列的第 *N* 个元素的视图：'
- en: '[PRE77]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`ranges::keys_view` / `views::keys` represent an alias for `ranges::elements_view<R,
    0>` and, respectively, an object of type `views::elements<0>`.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::keys_view` / `views::keys` 是 `ranges::elements_view<R, 0>` 的别名，以及
    `views::elements<0>` 类型的对象：'
- en: '`ranges::values_view` / `views::values` represent an alias for `ranges::elements_view<R,
    1>` and, respectively, an object of type `views::elements<1>`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges::values_view` / `views::values` 是 `ranges::elements_view<R, 1>` 的别名，以及
    `views::elements<1>` 类型的对象：'
- en: '[PRE81]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In C++23, the following adaptors were added to the standard library:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，以下适配器被添加到标准库中：
- en: '`ranges::enumerate_view` / `views::enumerate` represents a view of tuples,
    with the first element being the zero-based index of the element of the underlying
    sequence, and the second element being a reference to the underlying element:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::enumerate_view` / `views::enumerate` 表示对元组的视图，其中第一个元素是底层序列元素的零基于索引，第二个元素是对底层元素的引用：'
- en: '[PRE85]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`ranges::zip_view` / `views::zip` represents a view of tuples created from
    two or more underlying views, with the *N*th tuple created from the *N*th element
    of each underlying view:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::zip_view` / `views::zip` 表示由两个或更多底层视图创建的元组视图，其中第 *N* 个元组是由每个底层视图的第
    *N* 个元素创建的：'
- en: '[PRE87]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`ranges::zip_transform_view` / `views::` `zip_transform` represents a view
    of elements produced by applying a given function to two or more views. The *N*th
    element of the result view is produced from the *N*th element of all the specified
    underlying views:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::zip_transform_view` / `views::zip_transform` 表示通过将给定的函数应用于两个或更多视图来生成的元素的视图。结果视图的第
    *N* 个元素是由所有指定底层视图的第 *N* 个元素生成的：'
- en: '[PRE89]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`ranges::adjacent_view` / `views::adjacent` represents a view of tuples of
    *N* elements from an underlying view; each tuple is a window in the underlying
    view, the *i*th tuple containing the elements with the indexes in the range `[i,
    i + N - 1]`:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::adjacent_view` / `views::adjacent` 表示从底层视图中的 *N* 个元素的元组视图；每个元组是底层视图中的一个窗口，第
    *i* 个元组包含索引在范围 `[i, i + N - 1]` 内的元素：'
- en: '[PRE91]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`ranges::adjacent_transform_view` / `views::adjacent_transform` represents
    a view of elements produced by applying a specified function to *N*-adjacent elements
    of an underlying view; the *i*th element of the resulting view is produced by
    applying the function to the elements of the underlying range with the indexes
    in the range `[i, i + N - 1]`:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::adjacent_transform_view` / `views::adjacent_transform` 表示通过将指定函数应用于底层视图的
    *N* 个相邻元素来生成的元素的视图；结果视图的第 *i* 个元素是通过将函数应用于底层范围中具有索引在范围 `[i, i + N - 1]` 内的元素生成的：'
- en: '[PRE93]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`ranges::join_with_view` / `views::join_with` is similar to `join_view` because
    it flattens a view of ranges to a single view; however, it takes a delimiter that
    it inserts between the elements of the underlying ranges:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::join_with_view` / `views::join_with` 与 `join_view` 类似，因为它将范围视图展平为单个视图；然而，它接受一个分隔符，该分隔符插入到底层范围元素之间：'
- en: '[PRE95]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`ranges::slide_view` / `views::slide` is a range adaptor similar to `ranges::adjacent_view`
    / `views::adjacent`, except that the size of the windows from the underlying sequence
    is specified at runtime:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::slide_view` / `views::slide` 是一个类似于 `ranges::adjacent_view` / `views::adjacent`
    的范围适配器，除了从底层序列中指定的窗口大小是在运行时指定的：'
- en: '[PRE97]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`ranges::chunk_view` / `views::chunk` represents a view of sub-views of *N*
    elements of the underlying view. The last chunk may have fewer than *N* elements
    (if the size of the underlying view is not a multiple of *N*):'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::chunk_view` / `views::chunk` 表示底层视图的 *N* 个元素的子视图。最后一个块可能少于 *N* 个元素（如果底层视图的大小不是
    *N* 的倍数）：'
- en: '[PRE99]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`ranges::chunk_by_view` / `views::chunk_by` represents a view of sub-views
    of an underlying view, produced by splitting the underlying view each time a supplied
    binary predicate applied to two adjacent elements returns `false`:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::chunk_by_view` / `views::chunk_by` 表示由底层视图的子视图组成的视图，每次当提供给两个相邻元素的二进制谓词返回
    `false` 时，都会分割底层视图：'
- en: '[PRE101]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '`ranges::stride_view` / `views::stride` is a view of some elements from an
    underlying view, starting with the first and advancing over *N* elements each
    time:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::stride_view` / `views::stride` 是从底层视图中的某些元素组成的视图，从第一个元素开始，每次前进 *N*
    个元素：'
- en: '[PRE103]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`ranges::cartesian_product_view` / `views::cartesian_product` represents a
    view of tuples computed as the cartesian product of 1 or more underlying views:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges::cartesian_product_view` / `views::cartesian_product` 表示通过计算 1 个或多个底层视图的笛卡尔积来生成的元组视图：'
- en: '[PRE105]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: How it works…
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We saw how range adaptors work in the previous recipe. In this section, we will
    only look at some of the details and differences between some adaptors that you
    should be aware of.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一道菜谱中看到了范围适配器是如何工作的。在本节中，我们将仅查看一些你应该注意的适配器的细节和差异。
- en: To start, let’s consider `adjacent_view` and `slide_view`. They are similar
    in the sense that they take one view and produce another view of sub-views of
    this underlying view. These sub-views are referred to as *windows* and have a
    specified size, *N*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑`adjacent_view`和`slide_view`。它们在某种程度上是相似的，因为它们接受一个视图并产生这个底层视图的子视图的另一个视图。这些子视图被称为*窗口*，并具有指定的尺寸*N*。
- en: 'The first window starts from the first element, the second from the second
    element, etc. However, they differ in two significant ways:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个窗口从第一个元素开始，第二个从第二个元素开始，等等。然而，它们在两个显著方面有所不同：
- en: The size *N* of the windows is specified at compile time for `adjacent_view`
    and at runtime for `slide_view`.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adjacent_view`和`slide_view`的窗口大小*N*在编译时指定，对于`adjacent_view`，在运行时指定`slide_view`。'
- en: The elements of the view represented by `adjacent_view` are tuples, while the
    elements of the view represented by `slide_view` are other views.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`adjacent_view`表示的视图的元素是元组，而由`slide_view`表示的视图的元素是其他视图。
- en: 'The following diagram presents a comparison of these two adaptors:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这两个适配器的比较：
- en: '![](img/B21549_12_02.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_12_02.png)'
- en: 'Figure 12.2: Comparison of adjacent_view<3>(R) and slide_view(R, 3)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：相邻视图<3>(R)和滑动视图(R, 3)的比较
- en: When the size of the windows is 2, you can use `views::pairwise` and `views::pairwise_transform`,
    which are objects of type `adjacent<2>` and `adjacent_transform<2>`, respectively.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口大小为2时，你可以使用`views::pairwise`和`views::pairwise_transform`，它们分别是类型`adjacent<2>`和`adjacent_transform<2>`的对象。
- en: 'The next pair of adaptors to look at are `split_view` and `lazy_split_view`.
    They both do the same thing: split a view into subranges based on a given delimiter,
    which can be either a single element or a view of elements. Neither of the two
    adaptors include the delimiter in the resulting subranges. These two, however,
    differ in a key aspect: the `lazy_split_view` adaptor is, as the name implies,
    *lazy*, meaning that it does not look ahead to the next delimiter until we iterate
    for the next element of the result, which `split_view` does. Moreover, `split_view`
    supports ranges of the `forward_range` type or higher but cannot split a constant
    range, while `lazy_split_view` supports ranges of the `input_range` type or higher
    and can split a constant range.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要查看的适配器对是`split_view`和`lazy_split_view`。它们都做同样的事情：根据给定的分隔符将视图分割成子范围，这个分隔符可以是单个元素或元素的视图。这两个适配器都不在结果子范围中包含分隔符。然而，这两个在关键方面有所不同：`lazy_split_view`适配器，正如其名称所暗示的，是*惰性的*，这意味着它不会在迭代下一个结果元素的下一个分隔符之前向前查看，而`split_view`会这样做。此外，`split_view`支持`forward_range`类型或更高类型的范围，但不能分割一个常量范围，而`lazy_split_view`支持`input_range`类型或更高类型的范围，并且可以分割一个常量范围。
- en: The question that arises is which one to use and when? Typically, you should
    prefer `split_view` because it is more efficient than `lazy_split_view` (which
    has a less efficient iterator incrementation and comparison). However, if you
    need to split a constant range, then `split_view` is not an option, and you should
    use `lazy_split_view`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的问题是什么来用以及何时使用？通常，你应该优先选择`split_view`，因为它比`lazy_split_view`（具有更高效的迭代器递增和比较）更高效。然而，如果你需要分割一个常量范围，那么`split_view`就不是一个选项，你应该使用`lazy_split_view`。
- en: There are two adaptors, `join_view` (in C++20) and `join_with_view` (in C++23),
    that perform a join operation, transforming a range of ranges into a single (flattened)
    range. The difference between them is that the latter, `join_with_view`, takes
    a delimiter that is inserted in the result between the elements of two consecutive
    underlying ranges.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个适配器，`join_view`（在C++20中）和`join_with_view`（在C++23中），它们执行连接操作，将范围的范围转换为单个（扁平化）范围。它们之间的区别在于后者，`join_with_view`，在两个连续的底层范围之间的元素之间插入一个分隔符。
- en: For more details about the standard range adaptors, you can consult the online
    documentation available at [https://en.cppreference.com/w/cpp/ranges](https://en.cppreference.com/w/cpp/ranges).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标准范围适配器的更多详细信息，您可以查阅在[https://en.cppreference.com/w/cpp/ranges](https://en.cppreference.com/w/cpp/ranges)提供的在线文档。
- en: See also
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ranges库迭代集合*，了解C++ ranges库的基本原理'
- en: '*Using constrained algorithms*, to learn about the standard generic algorithms
    that work with ranges'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用约束算法*，了解与范围一起工作的标准泛型算法'
- en: Converting a range to a container
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将范围转换为容器
- en: The result of applying various range adapters to a range (such as a container)
    is a complex type that is difficult to type or remember. Typically, we’d use the
    `auto` specifier to indicate the type of the result of chaining adaptors, as we
    saw in the previous recipes. Ranges are lazy, which means they are evaluated,
    and they produce results only when we iterate over them. However, we often need
    to store the result of applying one or more range adaptors in a container, such
    as a vector or a map. Prior to C++23, this required explicit coding. However,
    C++23 provides a range conversion function, called `std::ranges::to`, which makes
    this an easy task. It also enables conversion between different containers. In
    this recipe, we will learn how to use it.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将各种范围适配器应用于范围（如容器）的结果是一个复杂类型，难以类型化或记忆。通常，我们会使用`auto`指定符来指示链式适配器结果的类型，就像我们在前面的示例中看到的那样。范围是惰性的，这意味着它们只在迭代时才会被评估，并产生结果。然而，我们经常需要将一个或多个范围适配器应用于容器（如向量或映射）的结果存储起来。在C++23之前，这需要显式编码。但是，C++23提供了一个范围转换函数，称为`std::ranges::to`，这使得这项任务变得简单。它还允许在不同容器之间进行转换。在这个示例中，我们将学习如何使用它。
- en: Getting ready
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `is_prime()` function used in the following snippets was shown in the recipe
    *Exploring the standard range adaptors* and will not be listed again here.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中使用的`is_prime()`函数在*探索标准范围适配器*的示例中已展示，此处不再列出。
- en: How to do it…
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You can convert a range to a container using the `std::ranges::to` range conversion
    function, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`std::ranges::to`范围转换函数将范围转换为容器，如下所示：
- en: 'Convert a range to a `std::vector`:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将范围转换为`std::vector`：
- en: '[PRE107]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Convert a range to a map type, such as `std::unordered_multimap`:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将范围转换为映射类型，例如`std::unordered_multimap`：
- en: '[PRE108]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Convert a range to a `std::string`:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将范围转换为`std::string`：
- en: '[PRE109]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works…
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::ranges::to` range conversion function is available in the `<ranges>`
    header, starting with C++23 (the feature-test macro `__cpp_lib_ranges_to_container`
    can be used to test whether it is supported or not).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ranges::to`范围转换函数从C++23（功能测试宏`__cpp_lib_ranges_to_container`可以用来测试是否支持）的`<ranges>`头文件中可用。'
- en: 'Although the previous examples showed how to convert from one range to another,
    `std::ranges::to` can also be used to convert between different types of containers,
    such as a vector to a list, or a map to a vector of pairs:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的示例展示了如何从一个范围转换为另一个范围，但`std::ranges::to`也可以用于在不同类型的容器之间进行转换，例如从向量到列表，或者从映射到对向量：
- en: '[PRE110]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'When you use the pipe (`|`) syntax, the parentheses are mandatory; otherwise,
    you will get compiler errors (which are difficult to read):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用管道（`|`）语法时，括号是强制性的；否则，你将得到编译错误（这些错误难以阅读）：
- en: '[PRE112]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The correct syntax is the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的语法如下：
- en: '[PRE113]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: See also
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Exploring the standard range adaptors*, to learn about the range adaptors
    available in C++20 and C++23'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*探索标准范围适配器*，了解C++20和C++23中可用的范围适配器'
- en: '*Using constrained algorithms*, to learn about the standard generic algorithms
    that work with ranges'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用约束算法*，了解与范围一起工作的标准泛型算法'
- en: Creating your own range view
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的范围视图
- en: The C++20 ranges library simplifies the handling of ranges of elements. The
    16 range adaptors (views) defined in the library provide useful operations, as
    seen in the previous recipe. However, you can create your own view that can be
    used together with the standard ones. In this recipe, you will learn how to do
    that. We will create a view called `trim` that, given a range and a unary predicate,
    returns a new range without the front and back elements that satisfy the predicate.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的范围库简化了元素范围的处理。库中定义的16个范围适配器（视图）提供了有用的操作，如前一个示例中所示。然而，你可以创建自己的视图，这些视图可以与标准视图一起使用。在这个示例中，你将学习如何做到这一点。我们将创建一个名为`trim`的视图，它接受一个范围和一个一元谓词，返回一个没有满足谓词的前后元素的新范围。
- en: Getting ready
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the same namespace aliases used in the previous
    one, with `rg` as an alias for `std::ranges` and `rv` as an alias for `std::ranges::views`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用与上一个示例中相同的命名空间别名，其中`rg`是`std::ranges`的别名，`rv`是`std::ranges::views`的别名。
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a view, do the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个视图，请执行以下操作：
- en: 'Create a class template, called `trim_view`, derived from `std::ranges::view_interface`:'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`trim_view`的类模板，它从`std::ranges::view_interface`派生：
- en: '[PRE114]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Define the internal state of the class, which, at a minimum, should include
    a begin and end iterator and the viewable range that is adapted by the view. For
    this adapter, we also need a predicate, as well as a Boolean variable to flag
    whether the iterators have been evaluated or not:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类的内部状态，这至少应包括一个起始和结束迭代器以及视图所适配的可视化范围。对于这个适配器，我们还需要一个谓词，以及一个布尔变量来标记迭代器是否已被评估：
- en: '[PRE115]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Define a default constructor (that can be defaulted) and a `constexpr` constructor
    with the required parameters. The first parameter is always the range. For this
    view, the other parameter is a predicate:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个默认构造函数（可以省略）和一个带有所需参数的 `constexpr` 构造函数。第一个参数始终是范围。对于这个视图，其他参数是一个谓词：
- en: '[PRE116]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Provide accessors to the internal data, such as the base range and the predicate:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对内部数据的访问器，例如基本范围和谓词：
- en: '[PRE117]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Provide functions to retrieve the begin and end iterators. To make sure the
    view is lazy, these iterators should only be evaluated by their first use:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供函数以检索起始和结束迭代器。为了确保视图是惰性的，这些迭代器应该仅在第一次使用时进行评估：
- en: '[PRE118]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Provide other useful members, such as a function, to return the size of the
    range:'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供其他有用的成员，例如一个函数，用于返回范围的大小：
- en: '[PRE119]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Put all together, the view appears as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，视图看起来如下：
- en: '[PRE120]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To simplify the composability of this user-defined view with the standard ones,
    the following should also be done:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化用户定义视图与标准视图的组合性，以下也应执行：
- en: 'Create a user-defined deduction guide for the class template argument deduction
    of the `trim_view` class template:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `trim_view_range_adaptor_closure` 类创建用户定义的推导指南，用于类模板参数推导：
- en: '[PRE121]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Create function objects that can instantiate the `trim_view` adaptor with the
    proper arguments. These can be made available in a separate namespace because
    they represent implementation details:'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以实例化 `trim_view` 适配器的函数对象，并使用适当的参数。这些对象可以放在一个单独的命名空间中，因为它们代表实现细节：
- en: '[PRE122]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Overload the pipe operator for the `trim_view_range_adaptor_closure` class
    defined previously:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载之前定义的 `trim_view_range_adaptor_closure` 类的管道操作符：
- en: '[PRE123]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create an object of the `trim_view_range_adaptor` type that can be used to
    create `trim_view` instances. This can be done in a namespace called `views` to
    create a similarity with the namespaces of the ranges library:'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `trim_view_range_adaptor` 类型的对象，该对象可以用来创建 `trim_view` 实例。这可以在名为 `views`
    的命名空间中完成，以与范围库的命名空间相似：
- en: '[PRE124]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `trim_view` class template we defined here is derived from the `std::ranges::view_interface`
    class template. This is a helper class in the ranges library to define views,
    using the **curiously recurring template pattern** (**CRTP**). There are two template
    arguments for the `trim_view` class: the range type, which must satisfy the `std::ranges::input_range`
    concept, and the predicate type.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的 `trim_view` 类模板是从 `std::ranges::view_interface` 类模板派生的。这是范围库中的一个辅助类，用于定义视图，使用**怪异重复模板模式**（**CRTP**）。`trim_view`
    类有两个模板参数：范围类型，它必须满足 `std::ranges::input_range` 概念，以及谓词类型。
- en: 'The `trim_view` class stores the base range and the predicate internally. Additionally,
    it requires a beginning and end (sentinel) iterator. These iterators must point
    to the first element and the ones past the last element of the range that do not
    satisfy the trimming predicate. However, because the view is a lazy object, these
    iterators should not be resolved before they are needed to iterate over the range.
    The following diagram shows the positions of these iterators in a range of integers,
    for when the view must trim the odd numbers from the beginning and end of the
    range `{1,1,2,3,5,6,4,7,7,9}`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim_view` 类内部存储基本范围和谓词。此外，它需要一个起始和结束（哨兵）迭代器。这些迭代器必须指向不满足修剪谓词的范围中的第一个元素和最后一个元素之后的元素。然而，因为视图是一个惰性对象，这些迭代器在需要迭代范围之前不应被解析。以下图显示了这些迭代器在整数范围中的位置，当视图必须从范围的开始和结束处修剪奇数时
    `{1,1,2,3,5,6,4,7,7,9}`：'
- en: '![A screenshot of a computer  Description automatically generated](img/B21549_12_03.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21549_12_03.png)'
- en: 'Figure 12.3: A visual conceptual representation of the range and the position
    of the start and end iterators before the iteration starts (above) and when it
    starts (below)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：在迭代开始之前（上方）和开始时（下方）范围、起始和结束迭代器的视觉概念表示
- en: 'We can use the `trim_view` class to write the following snippets:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `trim_view` 类来编写以下代码片段：
- en: '[PRE125]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Using the `trim_view` class, as well as composition with other views, is simplified
    through the use of the function objects declared in the `details` namespace, which
    represent implementation details. However, these, together with the overloaded
    pipe operator (`|`), make it possible to rewrite the preceding code as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用在 `details` 命名空间中声明的函数对象，使用 `trim_view` 类以及与其他视图的组合被简化，这些函数对象代表实现细节。然而，这些以及重载的管道运算符（`|`）使得可以将前面的代码重写如下：
- en: '[PRE126]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: It should be mentioned that the **range-v3** library does contain a range view
    called `trim`, but it was not ported to the C++20 ranges library. This may happen
    in a future version of the standard.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，**range-v3** 库确实包含一个名为 `trim` 的范围视图，但它尚未移植到 C++20 范围库。这可能在标准的未来版本中发生。
- en: See also
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用范围库迭代集合*，了解 C++ 范围库的基础'
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用概念指定模板参数的要求*，以探索 C++20 概念的基础'
- en: '*Chapter 10**, Static polymorphism with the curiously recurring template pattern*
    to see how the CRTP works'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 10 章**，使用怪异重复模板模式进行静态多态，了解 CRTP 的工作原理'
- en: Using constrained algorithms
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用约束算法
- en: The C++ standard library features over 100 generic-purpose algorithms (most
    of them in the `<algorithm>` header, and some of them in the `<numeric>` header).
    Some of these algorithms we saw in *Chapter 5*, over the course of several recipes,
    when we learned how to search elements in a range, sort a range, initialize a
    range, and more. The generic aspect of algorithms comes from the fact they work
    with iterators (a beginning and end iterator to a sequence of elements–a range)
    but this has the downside of requiring more explicit code that needs to be repeated
    over and over again. To ease the use of these algorithms, the C++20 standard provides
    matching algorithms in the `std::ranges` namespace that work with ranges (but
    also have overloads for iterators). These algorithms from the ranges library are
    called **constrained algorithms** and are available in the `<algorithm>` header.
    Although it’s not possible to look at all of them here, in this recipe we will
    see how to use several of them for initializing, sorting, and finding elements
    in a range.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库具有超过 100 个通用算法（其中大多数在 `<algorithm>` 头文件中，一些在 `<numeric>` 头文件中）。我们在 *第五章*
    中看到了其中的一些算法，在多个菜谱中，我们学习了如何在范围内搜索元素、排序范围、初始化范围等。算法的通用性源于它们使用迭代器（一个元素序列的开始和结束迭代器——一个范围）的事实，但这也有一个缺点，即需要更多的显式代码，这些代码需要一次又一次地重复。为了简化这些算法的使用，C++20
    标准在 `std::ranges` 命名空间中提供了匹配的算法，这些算法与范围一起工作（但也为迭代器提供了重载）。这些范围库中的算法被称为 **约束算法**，并在
    `<algorithm>` 头文件中可用。尽管在这里不可能查看所有这些算法，但在这个菜谱中，我们将看到如何使用其中的一些来初始化、排序和查找范围内的元素。
- en: How to do it…
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can perform various operations on ranges, including initializing, finding,
    and sorting, as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对范围执行各种操作，包括初始化、查找和排序，如下所示：
- en: 'Use `std::ranges::fill()` to assign a value to all the elements of a range:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::fill()` 将一个值赋给一个范围内的所有元素：
- en: '[PRE127]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Use `std::ranges::fill_n()` to assign a value to a specified number of elements
    of a range. The first element to be assigned is indicated by an output iterator:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::fill_n()` 将一个值赋给一个范围内的指定数量的元素。要分配的第一个元素由一个输出迭代器指示：
- en: '[PRE128]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Use `std::ranges::generate_n()` to assign the value returned by successive
    invocations of a given function to a number of elements of a range. The first
    element is indicated by an iterator:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::generate_n()` 将给定函数连续调用返回的值赋给一个范围中的多个元素。第一个元素由一个迭代器指示：
- en: '[PRE129]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Use `std::ranges::iota()` to assign sequentially increasing values to the elements
    of a range. The values are incremented using the prefix `operator++` from an initial
    specified value:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::iota()` 将递增的值赋给一个范围内的元素。值使用前缀 `operator++` 从一个初始指定的值开始递增：
- en: '[PRE130]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Use `std::ranges::find()` to find a value in a range; this algorithm returns
    an iterator to the first element equal to the supplied value, if such a value
    exists, or an iterator equal to the end of the range:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::find()` 在一个范围内查找一个值；此算法返回一个指向第一个等于所提供值的元素的迭代器，如果存在这样的值，或者一个等于范围末尾的迭代器：
- en: '[PRE131]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Use `std::ranges::find_if()` to find a value in a range that meets the criteria
    defined by a unary predicate. The algorithm returns an iterator to the first element
    in the range for which the predicate returns `true`, or an iterator to the end
    of the range if no such element exists:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::find_if()` 在一个范围内找到一个满足由一元谓词定义的标准的值。算法返回指向范围内第一个使谓词返回 `true`
    的元素的迭代器，如果不存在这样的元素，则返回指向范围末尾的迭代器：
- en: '[PRE132]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Use `std::ranges::find_first_of()` to search for the occurrence of any value
    from a range in another range; the algorithm returns an iterator to the first
    element (in the searched range) that is found, or one equal to the end of the
    range, otherwise:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::find_first_of()` 在另一个范围中搜索来自一个范围的任何值的出现；算法返回指向第一个找到的元素的迭代器（在搜索范围内），或者等于范围末尾的迭代器，否则：
- en: '[PRE133]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Use `std::ranges::sort()` to sort a range. You can supply a comparison function
    to be applied to the elements. This can include `std::ranges::greater`, `std::ranges::less`,
    and the other function objects from the `<functional>` header corresponding to
    the `<`, `<=`, `>`, `>=`, `==`, and `!=` operators:'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::sort()` 对范围进行排序。你可以提供一个应用于元素的比较函数。这可以包括 `std::ranges::greater`、`std::ranges::less`
    以及来自 `<functional>` 头文件的其它函数对象，对应于 `<`、`<=`、`>`、`>=`、`==` 和 `!=` 操作符：
- en: '[PRE134]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Use `std::ranges::is_sorted()` to check that a range is sorted:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::is_sorted()` 检查一个范围是否已排序：
- en: '[PRE135]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Use `std::ranges::is_sorted_until()` to find a sorted subrange from the beginning
    of a range:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ranges::is_sorted_until()` 从范围的开始找到一个已排序的子范围：
- en: '[PRE136]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works…
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'All but one of the constrained algorithms are located in the `<algorithm>`
    header. The exception is `std::ranges::iota()`, which is found in the `<numeric>`
    header. The algorithms listed in the *How to do it…* section are only a small
    selection of the available constrained algorithms. They are called constrained
    because there are requirements defined in their arguments with the help of concepts
    and constraints. Here is the definition of one of the overloads of `std::ranges::find()`
    that we used previously:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个之外，所有约束算法都位于 `<algorithm>` 头文件中。例外的是 `std::ranges::iota()`，它在 `<numeric>`
    头文件中找到。在 *如何做…* 部分列出的算法只是可用约束算法的一小部分。它们被称为约束算法，因为它们的参数中定义了要求，这些要求是通过概念和约束来帮助实现的。以下是之前使用过的
    `std::ranges::find()` 之一重载的定义：
- en: '[PRE137]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: On the other hand, there are some algorithms, such as `std::ranges::fill_n()`
    and `std::ranges::generate_n()`, seen earlier, that have a single overload that
    takes only one iterator, from the beginning of the range.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些算法，如之前看到的 `std::ranges::fill_n()` 和 `std::ranges::generate_n()`，只有一个重载，它只接受一个从范围开始处的迭代器。
- en: Another difference between the traditional algorithms and the constrained algorithms
    is that the latter do not have overloads to specify an execution policy, unlike
    the former, which do.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 传统算法和约束算法之间的另一个区别是，后者没有指定执行策略的重载，而前者有。
- en: 'The constrained algorithms have several advantages over the traditional algorithms:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 约束算法相对于传统算法有以下几个优点：
- en: There is less code to write because you don’t have to retrieve the beginning
    and ending iterator of a range.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为不需要检索范围的开始和结束迭代器，所以需要编写的代码更少。
- en: They are constrained, using concepts and constraints, which help provide better
    error messages in case of misuse.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是受约束的，使用概念和约束，这有助于在误用时提供更好的错误信息。
- en: They can be used with ranges/views as defined by the ranges library.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与由范围库定义的 ranges/views 一起使用。
- en: Some of them have overloads that allow you to specify a projection to apply
    to the elements, on which, in turn, a specified predicate is applied.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一些有重载，允许你指定一个应用于元素的投影，然后在这个投影上应用指定的谓词。
- en: 'Let’s first see how the constrained algorithms interact with ranges. For this,
    we consider the following example:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看约束算法如何与范围交互。为此，我们考虑以下示例：
- en: '[PRE139]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In this example, we have a vector of integers. From this vector, we filter out
    the even numbers, transform the rest by their square, and, finally, retain four
    of the resulting numbers. The result is a range. Its type is too complex to remember
    or write; therefore, we use the `auto` specifier and let the compiler infer it.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个整数向量。从这个向量中，我们过滤出偶数，将剩余的元素通过它们的平方进行转换，最后保留四个结果数字。结果是范围。它的类型太复杂，难以记住或编写；因此，我们使用
    `auto` 说明符，让编译器推断它。
- en: For those of you who wonder what the actual type is (in this previous example),
    it is `std::ranges::take_view<std::ranges::transform_view<std::ranges::filter_view<std::ranges::ref_view<std::vector<int>>,
    lambda [](int n)->bool>, lambda [](int n)->int>>`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想知道实际类型是什么（在这个先前的例子中），它是`std::ranges::take_view<std::ranges::transform_view<std::ranges::filter_view<std::ranges::ref_view<std::vector<int>>,
    lambda [](int n)->bool>, lambda [](int n)->int>>`。
- en: We want to print the resulting values to the console and find the first value
    greater than 10 (if any exists). For this purpose, we use `std::ranges::for_each()`
    and `std::ranges::find_if()`, passing the `range` object without having to deal
    directly with iterators.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将结果值打印到控制台并找到第一个大于10的值（如果存在）。为此，我们使用`std::ranges::for_each()`和`std::ranges::find_if()`，传递`range`对象，而无需直接处理迭代器。
- en: The last advantage mentioned earlier in the list is the ability to specify a
    projection. A projection is a callable object (for instance, a function object,
    or a reference to a member). This projection is applied to the elements of the
    range. On the result of the projection, another predicate is applied.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中之前提到的最后一个优点是能够指定一个投影。投影是一个可调用对象（例如，一个函数对象，或成员的引用）。这个投影应用于范围中的元素。在投影的结果上，再应用另一个谓词。
- en: 'To understand how this works, let’s consider a list of products with an ID,
    name, and price. From this list, we want to find the product with a certain price
    and print its name. The list is defined as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们考虑一个包含ID、名称和价格的产品的列表。从这个列表中，我们希望找到具有特定价格的产品并打印其名称。列表定义如下：
- en: '[PRE140]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'With the traditional algorithms, we need to use `std::find_if()` and pass a
    lambda function that performs the checking of each element:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统算法，我们需要使用`std::find_if()`并传递一个lambda函数，该函数执行每个元素的检查：
- en: '[PRE141]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'With constrained algorithms, we can use one of the overloads of `std::ranges::find()`
    that take a range, a value, and a projection, as shown in the following snippet:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用约束算法，我们可以使用`std::ranges::find()`的一个重载，它接受一个范围、一个值和一个投影，如下面的代码片段所示：
- en: '[PRE142]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Another similar example is sorting the range alphabetically (in ascending order)
    by the name of the products:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的例子是按产品名称（升序）对范围进行字母排序：
- en: '[PRE143]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Hopefully, these examples show there are compelling arguments to prefer, in
    general, the new C++20 constrained algorithms over the traditional ones. However,
    keep in mind that you cannot use constrained algorithms when you want to specify
    an execution policy (for instance, to parallelize or vectorize the execution of
    an algorithm), as such overloads are not available.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些示例表明，在一般情况下，有充分的理由选择新的C++20约束算法而不是传统算法。然而，请注意，当您想要指定执行策略（例如，并行化或矢量化算法的执行）时，不能使用约束算法，因为这些重载不可用。
- en: See also
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 5*, *Finding elements in a range*, to learn about the standard algorithms
    to search through sequences of values'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第五章，在范围中查找元素*，了解搜索值序列的常规算法'
- en: '*Chapter 5*, *Sorting a range*, to learn about the standard algorithms for
    sorting ranges'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第五章，排序范围*，了解排序范围的常规算法'
- en: '*Chapter 5*, *Initializing a range*, to explore the standard algorithms for
    filling a range with values'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第五章，初始化范围*，探索填充范围值的常规算法'
- en: '*Specify requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用概念指定模板参数的要求*，探索C++20概念的基础'
- en: Creating a coroutine task type for asynchronous computations
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为异步计算创建协程任务类型
- en: A major component of the C++20 standard is represented by coroutines. Simply
    put, coroutines are functions that can be suspended and resumed. Coroutines are
    an alternative to writing asynchronous code. They help simplify asynchronous I/O
    code, lazy computations, or event-driven applications. When a coroutine is suspended,
    the execution returns to the caller, and the data necessary to resume the coroutine
    is stored separately from the stack. For this reason, the C++20 coroutines are
    called *stackless*. Unfortunately, the C++20 standard does not define actual coroutine
    types and only a framework for building them. This makes writing asynchronous
    code with coroutines difficult without relying on third-party components.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准的一个主要组成部分是协程。简单来说，协程是可以暂停和恢复的函数。协程是编写异步代码的替代方案。它们有助于简化异步 I/O 代码、延迟计算或事件驱动应用程序。当协程被暂停时，执行返回到调用者，并将恢复协程所需的数据存储在栈之外。因此，C++20
    协程被称为 *无栈*。不幸的是，C++20 标准没有定义实际的协程类型，只提供了一个构建它们的框架。这使得在没有依赖第三方组件的情况下使用协程编写异步代码变得困难。
- en: In this recipe, you will learn how to write a coroutine task type that represents
    an asynchronous computation, which starts executing when the task is awaited.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何编写表示异步计算的协程任务类型，该任务在任务被等待时开始执行。
- en: Getting ready
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The several standard library types and functions that define the coroutine
    framework are available in the `<coroutine>` header, in the `std` namespace. However,
    you need to use a minimum compiler version to support coroutines: MSVC 19.28 (from
    Visual Studio 2019 16.8), Clang 17, or GCC 10.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 定义协程框架的几个标准库类型和函数可在 `<coroutine>` 头文件中找到，在 `std` 命名空间中。然而，您需要使用最低编译器版本来支持协程：MSVC
    19.28（从 Visual Studio 2019 16.8）、Clang 17 或 GCC 10。
- en: 'The goal of this recipe is to create a task type that enables us to write asynchronous
    functions, as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目标是创建一个任务类型，使我们能够编写异步函数，如下所示：
- en: '[PRE144]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: How to do it...
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a task type that supports coroutines that return nothing (`task<>`),
    a value (`task<T>`), or a reference (`task<T&>`), you should do the following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个支持返回无值（`task<>`）、值（`task<T>`）或引用（`task<T&>`）的协程的任务类型，您应该执行以下操作：
- en: 'Create a class called `promise_base` with the following content:'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `promise_base` 的类，其内容如下：
- en: '[PRE145]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Create a class template called `promise`, derived from `promise_base`, that
    adds the methods `get_return_object()` and `return_value()` and holds the value
    returned from the coroutine:'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `promise` 的类模板，从 `promise_base` 派生，添加 `get_return_object()` 和 `return_value()`
    方法，并持有协程返回的值：
- en: '[PRE146]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Specialize the `promise` class template for the `void` type, and provide implementations
    for the `get_return_object()` and `return_void()` methods:'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `void` 类型特化 `promise` 类模板，并为 `get_return_object()` 和 `return_void()` 方法提供实现：
- en: '[PRE147]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Specialize the `promise` class template for `T&`. Provide implementations for
    `get_return_object()` and `return_value()`, and store a pointer to the reference
    returned by the coroutine:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `T&` 特化 `promise` 类模板。为 `get_return_object()` 和 `return_value()` 提供实现，并存储协程返回的引用的指针：
- en: '[PRE148]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Create a class template called `task`, with the stub content shown below. This
    type must have an inner type called `promise_type` and hold a handle to the executing
    coroutine. The `task_awaiter` and the class members are listed here:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `task` 的类模板，其内容如下所示。此类型必须有一个名为 `promise_type` 的内部类型，并持有执行协程的句柄。`task_awaiter`
    和类成员在此列出：
- en: '[PRE149]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Create an awaitable class called `task_awaiter` that implements the `await_ready()`,
    `await_suspend()`, and `await_resume()` methods:'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `task_awaiter` 的可等待类，实现 `await_ready()`、`await_suspend()` 和 `await_resume()`
    方法：
- en: '[PRE150]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Provide class members, including a conversion constructor, a move constructor
    and move assignment operator, a destructor, a `co_await` operator, a method to
    check whether the coroutine has completed, a method to resume a suspended coroutine,
    and a method to get the value returned from the coroutine:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类成员，包括转换构造函数、移动构造函数和移动赋值运算符、析构函数、`co_await` 运算符、检查协程是否完成的方法、恢复挂起协程的方法以及获取协程返回值的方法：
- en: '[PRE151]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Implement the `get_return_object()` member of the `promise` primary template
    as well as its specializations. This must be done after the definition of the
    `task` class:'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `promise` 原始模板的 `get_return_object()` 成员及其特化。这必须在 `task` 类的定义之后完成：
- en: '[PRE152]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: How it works...
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Functions are blocks of code that execute one or more statements. You can assign
    them to variables, pass them as arguments, take their address, and, of course,
    invoke them. These features make them first-class citizens in the C++ language.
    Functions are sometimes called *subroutines*. Coroutines, on the other hand, are
    functions that support two additional operations: suspending and resuming their
    execution.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是执行一个或多个语句的代码块。你可以将它们赋给变量、将它们作为参数传递、获取它们的地址，当然，也可以调用它们。这些特性使它们成为 C++ 语言中的第一类公民。函数有时被称为
    *子程序*。另一方面，协程是支持两个额外操作（挂起和恢复执行）的函数。
- en: 'In C++20, a function is a coroutine if it uses any of the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，如果一个函数使用了以下任何一个，则该函数是一个协程：
- en: The `co_await` operator, which suspends the execution until resumed
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_await` 操作符，它会在恢复执行之前挂起执行'
- en: The `co_return` keyword, to complete the execution and optionally return a value
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_return` 关键字，用于完成执行并可选地返回一个值'
- en: The `co_yield` keyword, to suspend the execution and return a value
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_yield` 关键字，用于挂起执行并返回一个值'
- en: 'Not every function, however, can be a coroutine. The following cannot be coroutines:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非每个函数都可以是协程。以下不能是协程：
- en: Constructors and destructors
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: Constexpr functions
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Constexpr 函数
- en: Functions with a variable number of arguments
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可变数量参数的函数
- en: Functions that return `auto` or a concept type
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `auto` 或概念类型的函数
- en: The `main()` function
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()` 函数'
- en: 'A coroutine consists of the following three parts:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 协程由以下三个部分组成：
- en: A *promise object*, which is manipulated inside the coroutine and is used to
    pass the return value or an exception from the coroutine.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *承诺对象*，在协程内部操作，用于传递协程的返回值或异常。
- en: A *coroutine handle*, which is manipulated outside the coroutine and is used
    to either resume the execution or destroy the coroutine frame.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *协程句柄*，在协程外部操作，用于恢复执行或销毁协程帧。
- en: The *coroutine frame*, typically allocated on the heap and containing the promise
    object, the coroutine parameters copied by value, local variables, temporaries
    whose lifetimes exceed the current suspension point, and a representation of the
    suspension point so that resuming and destroying can be performed.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协程帧*，通常在堆上分配，包含承诺对象、通过值复制的协程参数、局部变量、生命周期超过当前挂起点的临时变量，以及挂起点的表示，以便可以进行恢复和销毁。'
- en: 'The promise object can be any type that implements the following interface,
    as expected by the compiler:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺对象可以是任何实现了以下接口的类型，这是编译器所期望的：
- en: '| **Default constructor** | **The promise must be default constructible** |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| **默认构造函数** | **承诺必须是可默认构造的** |'
- en: '| `initial_suspend()` | Indicates whether suspension happens at the initial
    suspend point. |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `initial_suspend()` | 指示是否在初始挂起点发生挂起。 |'
- en: '| `final_suspend()` | Indicates whether suspension happens at the last suspend
    point. |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| `final_suspend()` | 指示是否在最后一个挂起点发生挂起。 |'
- en: '| `unhandled_exception()` | Called when an exception propagates out of a coroutine
    block. |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| `unhandled_exception()` | 当异常从协程块中传播出来时调用。 |'
- en: '| `get_return_object()` | The return value of the function. |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| `get_return_object()` | 函数的返回值。 |'
- en: '| `return_value(v)` | Enables the `co_return v` statement. Its return type
    must be `void`. |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `return_value(v)` | 启用 `co_return v` 语句。它的返回类型必须是 `void`。 |'
- en: '| `return_void()` | Enables the `co_return` statement. Its return type must
    be `void`. |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| `return_void()` | 启用 `co_return` 语句。它的返回类型必须是 `void`。 |'
- en: '| `yield_value(v)` | Enables the `co_yield v` statement. |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| `yield_value(v)` | 启用 `co_yield v` 语句。 |'
- en: 'Table 12.3: The members of the interface implemented by a promise'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.3：由承诺实现的接口成员
- en: 'The implementation of `initial_suspend()` and `final_suspend()` we have seen
    for the `promise` type implemented here returns an instance of `std::suspend_always`.
    This is one of the two trivial awaitables that the standard defines, the other
    being `std::suspend_never`. Their implementation is as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实现的 `promise` 类型的 `initial_suspend()` 和 `final_suspend()` 的实现返回 `std::suspend_always`
    的一个实例。这是标准定义的两个平凡的可等待类型之一，另一个是 `std::suspend_never`。它们的实现如下：
- en: '[PRE153]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'These types implement the *awaitable* concept, which enables the use of the
    `co_await` operator. There are three functions required by this concept. These
    can be either free functions or class member functions. They are listed in the
    following table:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型实现了 *可等待* 概念，它使得可以使用 `co_await` 操作符。这个概念需要三个函数。这些可以是自由函数或类成员函数。它们在以下表中列出：
- en: '| `await_ready()` | Indicates whether the result is ready. If the return value
    is `false` (or a value convertible to `false`), then `await_suspend()` is called.
    |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| `await_ready()` | 指示结果是否就绪。如果返回值是 `false`（或可转换为 `false` 的值），则调用 `await_suspend()`。|'
- en: '| `await_suspend()` | Schedules the coroutine to resume or to be destroyed.
    |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| `await_suspend()` | 安排协程恢复或销毁。|'
- en: '| `await_resume()` | Provides the result for the entire `co_await e` expression.
    |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| `await_resume()` | 为整个 `co_await e` 表达式提供结果。|'
- en: 'Table 12.4: Functions that the awaitable concepts require'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.4：可等待概念所需的函数
- en: 'The `task<T>` type we built in this recipe has several members:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本食谱中构建的 `task<T>` 类型有几个成员：
- en: An explicit constructor that takes an argument of the `std::coroutine_handle<T>`
    type, representing a non-owning handle to the coroutine.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显式构造函数，它接受 `std::coroutine_handle<T>` 类型的参数，表示对协程的非拥有句柄。
- en: A destructor that destroys the coroutine frame.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数用于销毁协程帧。
- en: A move constructor and move assignment operator.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个移动构造函数和移动赋值运算符。
- en: A deleted copy constructor and copy assignment operator, making the class moveable-only.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了复制构造函数和复制赋值运算符，使得类只能移动。
- en: The `co_await` operator, which returns a `task_awaiter` value that implements
    the awaitable concept.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个实现可等待概念的 `task_awaiter` 值的 `co_await` 操作符。
- en: '`is_ready()`, a method that returns a Boolean value indicating whether the
    coroutine value is ready.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_ready()`，一个返回布尔值的方法，指示协程值是否就绪。'
- en: '`resume()`, a method that resumes the execution of the coroutine.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume()`，一个用于恢复协程执行的方法。'
- en: '`value()`, a method that returns the value held by the promise object.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value()`，一个返回承诺对象所持有值的方法。'
- en: An inner promise type called `promise_type` (this name is mandatory).
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个内部承诺类型称为 `promise_type`（此名称是强制性的）。
- en: If an exception occurs during the execution of the coroutine, and this exception
    leaves the coroutine without being handled, then the `unhandled_exception()` method
    of the promise is invoked. In this simple implementation, this situation is not
    handled, and the program is abnormally terminated with a call to `std::terminate()`.
    In the following recipe, we will see an awaitable implementation that handles
    exceptions.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在协程执行过程中发生异常，并且这个异常没有在协程中被处理，那么将调用承诺的 `unhandled_exception()` 方法。在这个简单的实现中，这种情况没有被处理，程序会通过调用
    `std::terminate()` 而异常终止。在下面的示例中，我们将看到一种可等待的实现，它可以处理异常。
- en: 'Let’s take the following coroutine as an example to see how the compiler handles
    it:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下协程为例，看看编译器是如何处理它的：
- en: '[PRE154]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Because of all the mechanisms we built in this recipe, the compiler transforms
    this code into the following (this snippet is pseudocode):'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本食谱中构建的所有机制，编译器将此代码转换为以下内容（此片段是伪代码）：
- en: '[PRE155]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: As mentioned earlier, the `main()` function is one of the functions that cannot
    be a coroutine. For this reason, it is not possible to use the `co_await` operator
    in `main()`. This means that waiting for a coroutine to complete must be done
    differently in `main()`.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`main()` 函数是那些不能作为协程的函数之一。因此，在 `main()` 中无法使用 `co_await` 操作符。这意味着在 `main()`
    中等待协程完成必须以不同的方式完成。
- en: 'This is handled with the help of a function template called `execute()` that
    runs the following loop:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过一个名为 `execute()` 的函数模板来处理的，该模板运行以下循环：
- en: '[PRE156]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This loop ensures that the coroutine is resumed after each suspension point,
    until its final completion.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环确保协程在每个挂起点之后恢复，直到其最终完成。
- en: There’s more...
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The C++20 standard does not provide any coroutine types, and writing your own
    is a cumbersome task. Fortunately, third-party libraries can offer these abstractions.
    Such a library is **libcoro**, an open-source experimental library that provides
    a set of general-purpose primitives to make use of the coroutines described in
    the C++20 standard. The library is available at [https://github.com/jbaldwin/libcoro](https://github.com/jbaldwin/libcoro).
    Among the components it provides is the `task<T>` coroutine type, similar to what
    we built in this recipe. Using the `coro::task<T>` type, we can rewrite our examples
    as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准没有提供任何协程类型，自己编写是一个繁琐的任务。幸运的是，第三方库可以提供这些抽象。这样一个库是 **libcoro**，这是一个开源的实验性库，提供了一组通用原语，以利用
    C++20 标准中描述的协程。该库可在 [https://github.com/jbaldwin/libcoro](https://github.com/jbaldwin/libcoro)
    获取。它提供的组件之一是 `task<T>` 协程类型，类似于我们在本食谱中构建的类型。使用 `coro::task<T>` 类型，我们可以将我们的示例重写如下：
- en: '[PRE157]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: As you can see, the code is very similar to what we wrote in the first part
    of this recipe. The changes are minimal. By using this **libcoro** library or
    others that are similar, you do not need to be concerned with the details of implementing
    coroutine types and instead focus on their use.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码与我们在这道菜谱的第一部分所写的非常相似。变化很小。通过使用此 **libcoro** 库或其他类似的库，你不需要关心实现协程类型的细节，而是专注于它们的使用。
- en: Another library that was used in the second edition of the book was **cppcoro**,
    which is available at [https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro).
    However, the **cppcoro** library has not been maintained for several years. Although
    it’s still available on GitHub, it relies on the experimental implementation of
    technical specifications for coroutines. For instance, when using MSVC, this requires
    the use of the now obsolete `/await` compiler flag. You should only use this library
    as a source of inspiration to write coroutine primitives, such as the one we will
    see in the next recipe.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二版中使用的另一个库是 **cppcoro**，可在 [https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro)
    获取。然而，**cppcoro** 库已经多年未维护。尽管它仍然可在 GitHub 上找到，但它依赖于协程技术规范的实验性实现。例如，当使用 MSVC 时，这需要使用现在已过时的
    `/await` 编译器标志。你应该只将此库作为编写协程原语（如我们将在下一道菜谱中看到的）的灵感来源。
- en: See also
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a coroutine generator type for sequences of values*, to learn how
    to enable the use of `co_yield` to return multiple values from a coroutine'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个用于值序列的协程生成器类型*，了解如何启用使用 `co_yield` 从协程返回多个值'
- en: Creating a coroutine generator type for sequences of values
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于值序列的协程生成器类型
- en: In the previous recipe, we saw how to create a coroutine task that enables asynchronous
    computations. We used the `co_await` operator to suspend execution until resumed
    and the `co_return` keyword to complete execution and return a value. However,
    another keyword, `co_yield`, also defines a function as a coroutine. It suspends
    the execution of the coroutine and returns a value. It enables a coroutine to
    return multiple values, one each time it is resumed. To support this feature,
    another type of coroutine is required. This type is called a *generator*. Conceptually,
    it’s like a stream that produces a sequence of values of type `T` in a lazy manner
    (when iterated). In this recipe, we will see how we can implement a simple generator.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何创建一个协程任务，它能够实现异步计算。我们使用了 `co_await` 操作符来挂起执行直到恢复，并使用 `co_return`
    关键字来完成执行并返回一个值。然而，另一个关键字 `co_yield` 也将一个函数定义为协程。它挂起协程的执行并返回一个值。它使协程能够在每次恢复时返回多个值。为了支持此功能，需要另一种类型的协程。这种类型被称为
    *生成器*。从概念上讲，它就像一个流，以惰性方式（在迭代时）产生类型 `T` 的值序列。在这道菜谱中，我们将看到我们如何实现一个简单的生成器。
- en: Getting ready
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The goal of this recipe is to create a generator coroutine type that enables
    us to write code like the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这道菜谱的目标是创建一个生成器协程类型，使我们能够编写如下代码：
- en: '[PRE158]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: It is recommended that you follow the previous recipe, *Creating a coroutine
    task type for asynchronous computations*, before you continue with this one.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在继续进行这道菜谱之前，先遵循之前的菜谱，*创建一个用于异步计算的协程任务类型*。
- en: How to do it...
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a generator coroutine type that supports synchronous lazy production
    of a sequence of values, you should do the following:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个支持同步惰性生成值序列的生成器协程类型，你应该做以下事情：
- en: 'Create a class template, called `generator`, with the following content (the
    details of each part are presented in the following bullet points):'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个名为 `generator` 的类模板，其内容如下（每个部分的细节将在以下要点中介绍）： '
- en: '[PRE159]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Create an inner class called `promise_type` (the name is mandatory) with the
    following content:'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `promise_type` 的内部类（名称是强制性的），其内容如下：
- en: '[PRE160]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Create an inner class called `iterator` with the following content:'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `iterator` 的内部类，其内容如下：
- en: '[PRE161]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Provide a default constructor, an explicit constructor from a `promise_type`
    object, a move constructor and a move assignment operator, and a destructor. Delete
    the copy constructor and copy assignment operator so that the type is moveable
    only:'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供默认构造函数、从 `promise_type` 对象显式构造函数、移动构造函数和移动赋值运算符，以及析构函数。删除复制构造函数和复制赋值运算符，以便类型只能移动：
- en: '[PRE162]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Provide the `begin()` and `end()` functions to enable iteration over the generator
    sequence:'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供函数 `begin()` 和 `end()` 以启用对生成器序列的迭代：
- en: '[PRE163]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: How it works...
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The promise type implemented in this recipe is similar to the one from the
    previous recipe, although there are some differences:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中实现的承诺类型与先前的菜谱中的类似，尽管有一些差异：
- en: It is implemented as an inner type, so the name is `promise_type`, since the
    coroutine framework requires the coroutine type to have an inner promise type
    with this name.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被实现为一个内部类型，因此名称是 `promise_type`，因为协程框架要求协程类型有一个名为此的内部承诺类型。
- en: It supports handling exceptions that leave the coroutine block uncaught. In
    the previous recipe, this situation was not treated, and an `unhandled_exception()`
    called `std::terminate()` to abnormally terminate the process. This implementation,
    however, retries a pointer to the current exception and stores it in an `std::exception_ptr`
    object. This exception is rethrown when iterating through the generated sequence
    (either when calling `begin()` or when incrementing the iterator).
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持处理未捕获的异常。在先前的菜谱中，这种情况没有被处理，并且 `unhandled_exception()` 调用 `std::terminate()`
    以异常终止进程。然而，这个实现会重试当前异常的指针并将其存储在 `std::exception_ptr` 对象中。这个异常在遍历生成的序列时被重新抛出（无论是调用
    `begin()` 还是递增迭代器）。
- en: The functions `return_value()` and `return_void()` are not present, but replaced
    with `yield_value()`, which is called when the `co_yield expr` expression is resolved.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 `return_value()` 和 `return_void()` 不存在，但被 `yield_value()` 替换，当 `co_yield
    expr` 表达式解析时调用。
- en: 'The generator class also bears some similarities to the task class from the
    previous recipe:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器类也与之前菜谱中的任务类有一些相似之处：
- en: It is default-constructible
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是默认可构造的
- en: It can be constructed from a promise object
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以从一个承诺对象构造
- en: It is not copy-constructible and copyable
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是可复制构造的并且可复制
- en: It is move-constructible and moveable
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是可移动构造的并且可移动
- en: Its destructor destroys the coroutine frame
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的析构函数销毁协程帧
- en: This class does not overload the `co_await` operator, as it does not make sense
    to wait on the generator; instead, it provides the functions `begin()` and `end()`,
    which return iterator objects that enable iterating over the sequence of values.
    This generator is said to be lazy because it does not produce new values until
    the coroutine is resumed, either by calling `begin()` or incrementing an iterator.
    The coroutine is created suspended, and its first execution begins only when calling
    the `begin()` function. The execution continues either until the first `co_yield`
    statement or until the coroutine completes its execution. Similarly, incrementing
    the iterator will resume the execution of the coroutine, which continues either
    until the next `co_yield` statement or until its completion.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有重载 `co_await` 操作符，因为在生成器上等待没有意义；相反，它提供了 `begin()` 和 `end()` 函数，这些函数返回迭代器对象，使得可以遍历值的序列。这个生成器被称为懒生成器，因为它不会在协程被恢复（无论是通过调用
    `begin()` 还是递增迭代器）之前产生新值。协程是创建为挂起的，并且它的第一次执行只有在调用 `begin()` 函数时才开始。执行会继续，直到第一个
    `co_yield` 语句或直到协程完成执行。同样，递增迭代器将恢复协程的执行，它将继续，直到下一个 `co_yield` 语句或直到其完成。
- en: 'The following example shows a coroutine that produces several integer values.
    It does so not by using a loop but by repeating `co_yield` statements:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个生成多个整数值的协程。它不是通过使用循环，而是通过重复 `co_yield` 语句来实现的：
- en: '[PRE164]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: An important thing to note is that the coroutine can only use the `co_yield`
    keyword and produce values synchronously. The use of the `co_await` operator within
    the coroutine is not supported with this particular implementation. To be able
    to suspend execution by using the `co_await` operator, a different implementation
    is required.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，协程只能使用 `co_yield` 关键字并同步产生值。在这个特定实现中，协程内部不支持使用 `co_await` 操作符。要能够通过使用
    `co_await` 操作符挂起执行，需要不同的实现。
- en: There’s more...
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The **libcoro** library, mentioned in the previous recipe, has a `generator<T>`
    type that can be used instead of the one we created here. In fact, by replacing
    our `generator<T>` with `coro::generator<T>`, the snippets of code shown previously
    will continue to work as expected.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的菜谱中提到的 **libcoro** 库有一个 `generator<T>` 类型，可以用它来代替我们在这里创建的类型。实际上，通过将我们的 `generator<T>`
    替换为 `coro::generator<T>`，之前显示的代码片段将继续按预期工作。
- en: See also
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a coroutine task type for asynchronous computations*, for an introduction
    to the C++20 coroutines'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建异步计算的协程任务类型*，介绍 C++20 协程'
- en: Generating a sequence of values with the std::generator type
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::generator 类型生成值序列
- en: 'The C++20 standard includes two major updates to the standard library: the
    ranges library and coroutines. However, with regard to the latter, the support
    is minimal. The C++20 standard only defines a framework for building coroutines.
    Because of this, libraries such as **libcoro**, which we have previously seen,
    were created to provide actual coroutines, such as `task` and `generator`, which
    we also saw in the previous two recipes. The C++23 standard introduces the first
    standard coroutine, called `std::generator`. This brings together ranges and coroutines
    because `std::generator` is a view that represents a synchronous coroutine generator.
    This is a standard implementation for what we explicitly built in the previous
    recipe, *Creating a coroutine generator type for sequences of values*. Let’s see
    how it works.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准对标准库进行了两项主要更新：范围库和协程。然而，关于后者，支持非常有限。C++20 标准仅定义了构建协程的框架。因此，像 **libcoro**
    这样的库被创建出来，以提供实际的协程，例如我们在前两个菜谱中看到的 `task` 和 `generator`。C++23 标准引入了第一个标准协程，称为 `std::generator`。这汇集了范围和协程，因为
    `std::generator` 是一个表示同步协程生成器的视图。这是我们在上一个菜谱中明确构建的标准实现，*为值序列创建协程生成器类型*。让我们看看它是如何工作的。
- en: At the time of writing, only GCC 14 supports this standard coroutine.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，只有 GCC 14 支持此标准协程。
- en: How to do it…
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To generate a sequence of elements, in a lazy manner, write a coroutine that:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 要以惰性方式生成元素序列，编写一个协程：
- en: Uses `std::generator<T>` as the return type.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::generator<T>` 作为返回类型。
- en: Uses the `co_yield` statement to return a value.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `co_yield` 语句返回一个值。
- en: '[PRE165]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: How it works…
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The new `std::generator` class template is available in its own header, called
    `<generator>`. It derives from `std::ranges::view_interface`; therefore, it is
    a view of elements that are yielded from the evaluation of a coroutine (an interruptible
    function). The class is defined as follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `std::generator` 类模板在其自己的头文件中可用，称为 `<generator>`。它从 `std::ranges::view_interface`
    派生；因此，它是一个协程（可中断函数）评估产生的元素的视图。该类定义如下：
- en: '[PRE166]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Every time the coroutine is resumed and a `co_yield` statement is evaluated,
    a new element of a sequence is produced. The following is an example that contains
    a series of `co_yield` statements (not a loop). In total, this coroutine produces
    three elements. However, if the `get_values()` coroutine is only evaluated once,
    it will only produce one element. We call this a lazy evaluation:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 每次协程被恢复并评估 `co_yield` 语句时，都会生成序列的新元素。以下是一个包含一系列 `co_yield` 语句的示例（不是一个循环）。总共，这个协程生成了三个元素。然而，如果只评估一次
    `get_values()` 协程，它只会生成一个元素。我们称这为惰性评估：
- en: '[PRE167]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The `std::generator` type is a synchronous generator; the coroutine can only
    use the `co_yield` statement to return values. It is not possible to use the `co_await`
    operator within the coroutine. A different kind of generator would be required
    for that, and such a generator is not currently available.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::generator` 类型是一个同步生成器；协程只能使用 `co_yield` 语句来返回值。在协程内部无法使用 `co_await` 操作符。为此需要另一种类型的生成器，但目前尚无此类生成器。'
- en: 'Another example of using the `std::generator` type to produce a sequence of
    values is the following, which generates the series of Fibonacci numbers. This
    is the same example that we saw in the previous recipe. The only change is that
    we replaced `generator<int>` (which we wrote) with `std::generator<int>`, which
    is available in the C++23 standard:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::generator` 类型生成值序列的另一个示例如下，它生成斐波那契数列。这是我们在上一个菜谱中看到的相同示例。唯一的变化是我们将 `generator<int>`（我们编写的）替换为
    `std::generator<int>`，这是 C++23 标准中可用的：
- en: '[PRE168]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: See also
  id: totrans-663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用范围库迭代集合*，了解 C++ 范围库的基本知识'
- en: '*Creating a coroutine task type for asynchronous computations*, for an introduction
    to the C++20 coroutines'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为异步计算创建协程任务类型*，介绍 C++20 协程'
- en: '*Creating a coroutine generator type for sequences of values*, to learn how
    to enable the use of `co_yield` to return multiple values from a coroutine'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为值序列创建协程生成器类型*，了解如何启用从协程返回多个值的 `co_yield` 的使用'
- en: Learn more on Discord
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_12.xhtml)'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_12.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
