- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ 20 Core Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new C++20 standard is a major step in the development of the C++ language.
    C++20 brings many new features both to the language and to the standard library.
    Some of these have already been discussed in previous chapters, such as the text
    formatting library, the calendar extensions to the chrono library, the changes
    to the thread support library, and many others. However, the features that impact
    the language the most are modules, concepts, coroutines, and the new ranges library.
    The specification of these features is very lengthy, which makes it difficult
    to cover them in great detail in this book. Therefore, in this chapter, we will
    look at the most important aspects and use cases of these features. This chapter
    is intended to help you start using these features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding module partitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying requirements on template arguments with concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using requires expressions and clauses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring abbreviated function templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over collections with the ranges library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the standard range adaptors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a range to a container
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own range view
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constrained algorithms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine task type for asynchronous computations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine generator type for sequences of values
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a sequence of values with the std::generator type
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start this chapter by learning about modules, which are the most disruptive
    change that’s happened to the C++ language in decades.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are one of the most important changes in the C++20 standard. They represent
    a fundamental change to the C++ language and the way we write and consume code.
    Modules are made available in source files that are compiled separately from the
    translation units that consume them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules provide multiple advantages, especially in comparison to the use of
    header files:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: They are only imported once, and the order they’re imported in does not matter.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not require splitting interfaces and implementation in different source
    files, although this is still possible.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules have the potential to reduce compilation time, in some cases significantly.
    The entities exported from a module are described in a binary file that the compiler
    can process faster than traditional precompiled headers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, this file can potentially be used to build integrations and interoperability
    with C++ code from other languages.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to get started with modules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the major compilers (VC++, Clang, and GCC) provide different
    levels of support for modules. Build systems, such as CMake, are lagging in terms
    of adoption for modules (although this is likely to change in the near future).
    Because different compilers have different ways of, and different compiler options
    for, supporting modules, this book will not provide details on how to build these
    samples. You are invited to consult online documentation for specific compilers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The source code accompanying this book includes scripts for building the source
    code presented in this recipe and the next one, using the MSVC compiler (cl.exe)
    from Visual Studio 2019 16.8 and, respectively, Visual Studio 2022 17.x.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of module files: *module interface units*, *module
    interface partitions*, and *module implementation partitions*. In this recipe,
    we’ll refer solely to the first; the other two, we will learn about in the next
    recipe.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you modularize your code, you can do the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Import a module using the `import` directive, followed by the module name.
    The standard library is available in the `std` module, but only starting with
    C++23\. This allows us to write the following in C++23:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Export a module by creating a **module interface unit** (**MIU**) that can
    contain functions, types, constants, and even macros. Their declaration must be
    preceded by the keyword `export`. The module interface unit file must have the
    extension `.ixx` for VC++. Clang accepts different extensions, including `.cpp`,
    `.cppm`, and even `.ixx`. The following sample exports a class template called
    `point`, a function called `distance()` that computes the distance between two
    points, and a user-defined literal operator called `_ip` that creates objects
    of the type `point` from strings, in the form `"0,0"` or `"12,-3"`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `import` directive to also import the content of a header. The example
    presented here uses the same type and functions seen in the preceding example:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A module unit is composed of several parts, mandatory or optional:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The *global module fragment*, introduced with a `module;` statement. This part
    is optional and, if present, may only contain preprocessor directives. Everything
    that is added here is said to belong to the *global module*, which is a collection
    of all the global module fragments and all the translation units that are not
    modules.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *module declaration*, which is a required statement of the form `export`
    `module name;`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *module preamble*, which is optional and may only contain import declarations.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *module purview*, which is the content of the unit, starting with the module
    declaration and extending to the end of the module unit.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a module unit containing all of the aforementioned
    parts. On the left side, we have the source code of the module, and on the right
    side, the module parts are explained:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_12_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: An example of a module (on the left side) with each part highlighted
    and explained (on the right side)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'A module can export any entity, such as functions, classes, and constants.
    Every export must be preceded by the `export` keyword. This keyword is always
    the first keyword, preceding others such as `class`/`struct`, `template`, or `using`.
    Several examples have been provided in the **geometry** module shown in the previous
    section:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: An E class template called `point`, which represents a point in the two-dimensional
    space
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type alias for `point<int>` called `int_point`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compile-time constant called `int_point_zero`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function template, `distance()`, that computes the distance between two points
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user-defined literal `_ip` that creates `int_point` objects from strings such
    as `"3,4"`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A translation unit that uses modules instead of headers does not require any
    other changes, except for replacing `#include` preprocessor directives with `import`
    directives. Moreover, headers can also be imported as modules using the same `import`
    directive, as shown in an example earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: There is no relationship between modules and namespaces. These two are independent
    concepts. The module `geometry` exports the user-defined literal `""_ip` in the
    namespace `geometry_literals`, while all the other exports in the module are available
    in the global namespace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: There is also no relationship between the module names and the name of the unit
    file. The geometry module was defined in a file called `geometry.ixx`/`.cppm`,
    although any filename would have had the same result. It is recommended that you
    follow a consistent naming scheme and use the module name for the module filename
    too. On the other hand, the extension used for module units differs with each
    compiler, although this could be something that may change in the future when
    module support reaches maturity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to C++23, the standard library was not yet modularized. However, compilers
    have already made it available in modules. The Clang compiler provides a different
    module for each header. On the other hand, the Visual C++ compiler provides the
    following modules for the standard library:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`std.regex`: The content of the `<regex>` header'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.filesystem`: The content of the `<filesystem>` header'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.memory`: The content of the `<memory>` header'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.threading`: The content of the headers `<atomic>`, `<condition_variable>`,
    `<future>`, `<mutex>`, `<shared_mutex>`, and `<thread>`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.core`: The rest of the C++ standard library'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from these module names, such as `std.core` or `std.regex`, the
    name of the module can be a series of identifiers concatenated with a dot (`.`).
    The dot has no significance other than helping to split the name into parts representing
    a logical hierarchy, such as `company.project.module`. The use of a dot can arguably
    provide better readability compared to the use of an underscore (such as in `std_core`
    or `std_regex`), which is also legal, like anything else that may form an identifier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++23 standard, on the other hand, provides two standardized named modules:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`std`, which imports everything from the C++ standard headers (such as `<vector>`,
    `<string>`, `<algorithm>`, etc.) and C wrapper headers (such as `<cstdio>`) into
    the `std` namespace. You should use this module if you qualify everything with
    `std` and don’t want to pollute the global namespace.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std.compat`, which imports everything that `std` does and, in addition, the
    global namespace counterparts of the C wrapper headers. For instance, if `std`
    imports `std::fopen` and `std::fclose` (along with everything else) from `<cstdio>`,
    then `std.compat` imports `::fopen` and `::fclose`. You should use this module
    if you want to migrate code more easily without having to qualify names with the
    `std` namespace (such as `std::fopen` instead of `fopen`, `std::size_t` instead
    of `size_t`, etc.).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a programmer, you are familiar with the typical introductory program to
    any programming language called *“Hello, world!”* that simply prints this text
    to the console. In C++, the canonical form of this program used to be the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In C++23, with support for standardized modules and the new printing capabilities
    of the text formatting library, this program can look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can check whether the standard modules `std` and `std.compat` are available
    using the `__cpp_lib_modules` feature macro.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding module partitions*, to learn about interface and implementation
    partitions'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding module partitions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code of a module may become large and difficult to maintain. Moreover,
    a module may be composed of logically separate parts. To help with scenarios such
    as these, modules support composition from parts called *partitions*. A module
    unit that is a partition that exports entities is called a *module interface partition*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: However, there could also be internal partitions that do not export anything.
    Such a partition unit is called a *module implementation partition*. In this recipe,
    you will learn how to work with interface and implementation partitions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the previous recipe, *Working with modules*, before continuing
    with this one. You will need both the module fundamentals we discussed there and
    the code examples that we will continue with in this recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we will use the `std` module, which is only available
    in C++23\. For previous versions, use `std.core` in VC++ or other particular modules
    supported by your compiler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can split a module into several partitions, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Each partition unit must start with a statement of the form `export module`
    `modulename:partitionname;`. Only the global module fragment may precede this
    declaration:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the primary module interface unit, import and then export the partitions
    with statements of the form `export import :partitionname`, such as in the following
    example:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code importing a module composed from multiple partitions only sees the
    module as a whole if it was built from a single module unit:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is possible to create internal partitions that do not export anything but
    contain code that can be used in the same module. Such a partition must start
    with a statement of the form `module modulename:partitionname;` (without the keyword
    `export`). Different compilers may also require a different extension for the
    file containing an internal partition. For VC++, the extension must be `.cpp`:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code shown earlier is a follow-up of the modules example presented in the
    previous recipe. The `geometry` module has been split into two different partitions
    called `core` and `literals`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you declare the partition, you must use the name in the form
    `modulename:partitionname`, such as in `geometry:core` and `geometry:literals`.
    This is not necessary when you import a partition elsewhere in the module. This
    can be seen both in the primary partition unit `geometry.ixx` and in the module
    interface partition `geometry-literals.ixx`. Here are the snippets again, for
    clarity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Although module partitions are distinct files, they are not available as separate
    modules or submodules to translation units using a module. They are exported together
    as a single, aggregated module. If you compare the source code in the `main.cpp`
    file with the one from the previous recipe, you will see no difference.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: As with module interface units, there are no rules for naming the files containing
    partitions. However, compilers may require different extensions or support some
    particular naming schemes. For instance, VC++ uses the scheme `<module-name>-<partition-name>.ixx`,
    which simplifies build commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Partitions, just like modules, may contain code that is not exported from the
    module. A partition may contain no exports at all, in which case it is an internal
    partition only. Such a partition is called a *module implementation partition*.
    It is defined without using the `export` keyword in the module’s declaration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: An example of an internal partition is the `geometry:details` partition shown
    earlier. It provides a helper function, called `split()`, to parse two integers
    separated with a comma from a string. This partition is then imported into the
    `geometry:literals` partitions, where the `split()` function is used to implement
    the user-defined literal `_ip`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Partitions are divisions of a module. However, they are not submodules. They
    do not logically exist outside of the module. There is no concept of a submodule
    in the C++ language. The code shown in this recipe using partitions could be written
    slightly differently using modules:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we have three modules: `geometry.core`, `geometry.literals`,
    and `geometry`. Here, `geometry` imports and then re-exports the entire content
    of the first two. Because of this, the code in `main.cpp` does not need to change.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: By solely importing the `geometry` module, we get access to the content of the
    `geometry.core` and `geometry.literals` modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we do not define the `geometry` module anymore, then we need to
    explicitly import the two modules, as shown in the following snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Choosing between using partitions or multiple modules to componentize your source
    code should depend on the particularities of your project. If you use multiple
    smaller modules, you provide better granularity for imports. This can be important
    if you’re developing a large library because users should only import things they
    use (and not a very large module when they only need some functionalities).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with modules*, to explore the fundamentals of C++20 modules'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying requirements on template arguments with concepts
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template metaprogramming is an important part of the C++ language, empowering
    the development of general-purpose libraries, including the standard library.
    However, template metaprogramming is not trivial. On the contrary, complex tasks
    could be tedious and difficult to get right without a lot of experience. In fact,
    the C++ Core Guidelines, an initiative created by Bjarne Stroustrup and Herb Sutter,
    have a rule called *Use template metaprogramming only when you really need to,*
    which reasons that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Template metaprogramming is hard to get right, slows down compilation, and is
    often very hard to maintain.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An important aspect concerning template metaprogramming has been the specification
    of constraints for type template parameters, in order to impose restrictions on
    the types that a template can be instantiated with. The C++20 concepts library
    is designed to solve this problem. A concept is a named set of constraints, and
    a constraint is a requirement for a template argument. These are used to select
    the appropriate function overloads and template specializations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can use C++20 concepts to specify requirements
    on template arguments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin learning about concepts, let’s consider the following class
    template, called `NumericalValue`, which is supposed to hold a value of an integral
    or floating-point type. This C++11 implementation employs the use of `std::enable_if`
    to specify requirements for the `T` template argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This snippet will be the basis for the examples shown in this recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify requirements for template arguments as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a concept using the `concept` keyword with the following form:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you can use one of the standard-defined concepts, available
    in the header `<concepts>` (or one of the other standard library headers):'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the concept name instead of the `class` or `typename` keywords in function
    templates, class templates, or variable templates:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instantiate class templates and call function templates with no changes in
    syntax:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A concept is a set of one or more constraints that is always defined in a namespace
    scope. The definition of a concept is similar to a variable template. The following
    snippet shows a concept being used for a variable template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Concepts cannot be constrained themselves, nor can they refer to themselves
    recursively. In the examples shown so far, the `Numerical` and `Real` concepts
    are composed of a single, atomic constraint. However, concepts can be created
    from multiple constraints. A constraint created from two constraints using the
    `&&` logical operator is called a *conjunction*, while a constraint created from
    two constraints using the `||` logical operator is called a *disjunction*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Numerical` concept defined in the *How to do it...* section was defined
    using the `std::is_arithmetic_v` type trait. However, we could have two concepts,
    `Real` and `Integral`, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From these two, we can compose the `Numerical` concept, using the `||` logical
    operator. The result is a disjunction:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Semantically, there is no difference between these two versions of the `Numerical`
    concept, although they are defined in different ways.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand conjunctions, let’s look at another example. Consider two base
    classes, `IComparableToInt` and `IConvertibleToInt`, that are supposed to be derived
    by classes that should support comparison or conversion to `int`. These could
    be defined as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Some classes can implement both of them, others only one or the other. The
    `SmartNumericalValue<T>` class here implements both, while `DullNumericalValue<T>`
    only implements the `IConvertibleToInt` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we want to do is write a function template that only accepts arguments
    that are both comparable and can be converted to `int`. The `IComparableAndConvertible`
    concept shown here is a conjunction of the `IntComparable` and `IntConvertible`
    concepts. They can be implemented as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Conjunctions and disjunctions are evaluated left to right and are short-circuited.
    This means that for a conjunction, the right constraint is evaluated only if the
    left one is satisfied, and for a disjunction, the right constraint is evaluated
    only if the left one is not satisfied.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The third category of constraints is *atomic constraints*. These are composed
    of an expression `E` and a mapping between the type parameters from `E` and the
    template arguments of the constrained entity, called *parameter mapping*. The
    atomic constraints are formed during *constraint normalization*, which is the
    process of transforming a constraint expression into a sequence of conjunctions
    and disjunctions of atomic constraints. An atomic constraint is checked by substituting
    the parameter mapping and the template arguments into the expression `E`. The
    result must be a valid prvalue constant expression of type `bool`; otherwise,
    the constraint is not satisfied.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library defines a series of concepts that can be used to define
    compile-time requirements on template arguments. Although most of these concepts
    impose both syntactic and semantic requirements, the compiler can usually ensure
    only the former. When the semantic requirements are not met, the program is considered
    ill-formed, and the compiler is not required to provide any diagnostics about
    the problem. The standard concepts are available in several places:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In the concepts library, in the `<concepts>` header and the `std` namespace.
    This includes core language concepts (such as `same_as`, `integral`, `floating_point`,
    `copy_constructible`, and `move_constructible`), comparison concepts (such as
    `equality_comparable` and `totally_ordered`), object concepts (such as `copyable`,
    `moveable`, and `regular`), and callable concepts (such as `invocable` and `predicate`).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the algorithms library, in the `<iterator>` header and the `std` namespace.
    This includes algorithm requirements (such as `sortable`, `permutable`, and `mergeable`)
    and indirect callable concepts (such as `indirect_unary_predicate` and `indirect_binary_predicate`).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the ranges library, in the `<ranges>` header and the `std::ranges` namespace.
    This includes concepts specific for ranges, such as `range`, `view`, `input_range`,
    `output_range`, `forward_range`, and `random_access_range`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concepts defined in this recipe used the already available type traits.
    However, there are many cases when requirements on template arguments cannot be
    described in this way. For this reason, concepts can be defined with a *requires
    expression*, which is a prvalue expression of type `bool`, describing a template
    argument requirement. This will be the topic of the next recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using requires expressions and clauses*, to learn about in-place constraints'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using requires expressions and clauses
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we introduced the topic of concepts and constraints,
    learning about them with the help of several examples that were solely based on
    already existing type traits. Moreover, we also used the terser syntax to specify
    concepts, with the concept name used instead of the `typename` or the `class`
    keyword in the template declaration. However, it is possible to define more complex
    concepts with the help of *requires expressions*. These are prvalues of the type
    `bool` that describe the constraints on some template arguments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write requires expressions and an alternative
    way to specify constraints on template arguments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class template `NumericalValue<T>` and the function template `wrap()` defined
    in the previous recipe will be used in the code snippets presented in this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify requirements for template arguments, you can use requires expressions,
    introduced with the `requires` keyword, such as the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a simple expression that the compiler validates for correctness. In the
    following snippet, the operator `+` must be overloaded for the `T` template argument:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use a simple expression to require the existence of a particular function.
    In the following snippet, a function called `wrap()`, which is overloaded with
    a parameter of the `T` template argument, must exist:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use a type requirement, specified with the keyword `typename`, followed by
    the name of a type, optionally qualified, to specify requirements such as member
    names, class template specializations, or alias template substitutions. In the
    following snippet, the `T` template argument must have two inner types called
    `value_type` and `iterator`. Additionally, two functions, `begin()` and `end()`,
    which take a `T` argument, must be available:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use a compound requirement to specify the requirements of an expression, as
    well as the result of the evaluation of the expression. In the following example,
    there must be a function called `wrap()` that can be called with an argument of
    the `T` template argument type, and the result of calling the function must be
    of the `NumericalValue<T>` type:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Constraints on the template arguments can also be specified using a syntax,
    involving the `requires` keyword. These are called *requires clauses* and can
    be used as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a requires clause after the template parameter list:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, use the requires clause after the last element of a function
    declarator:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Combine a requires clause with a requires expression, instead of a named concept.
    In this case, the `requires` keyword appears twice, as shown in the following
    snippet:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new `requires` keyword has multiple purposes. On one hand, it is used to
    introduce a requires clause that specifies constraints on template arguments.
    On the other hand, it is used to define a requires expression that is a prvalue
    of type `bool` used to define constraints on template arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with C++ value categories (*lvalue*, *rvalue*, *prvalue*,
    *xvalue*, *glvalue*), you are recommended to check [https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category).
    The term *prvalue*, meaning *pure rvalue*, specifies an rvalue that is not an
    xvalue (expiring value). Examples of prvalues are literals, function calls whose
    return type is not a reference type, an enumerator, or the `this` pointer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In a requires clause, the `requires` keyword must be followed by a constant
    expression of the type `bool`. The expression must be either a primary expression
    (such as `std::is_arithmetic_v<T>` or `std::integral<T>`), an expression in parentheses,
    or any sequence of such expressions joined with either the `&&` or the `||` operator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'A requires expression has the form `requires (parameters-list) { requirements
    }`. The parameters list is optional and can be entirely omitted (including the
    parentheses). The specified requirements may refer to:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The template parameters that are in scope
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local parameters introduced in `parameters-list`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other declarations that are visible from the enclosing context
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The requirements sequence of the requires expression can contain requirements
    of the following types:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple requirements**: These are arbitrary expressions that do not start
    with the `requires` keyword. The compiler only checks its language correctness.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type requirements**: These are expressions that start with the keyword `typename`
    followed by a type name, which must be valid. This enables the compiler to validate
    that a certain nested name exists, or that a class template specialization or
    an alias template substitution exists.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compound requirements**: They have the form `{expression} noexcept -> type-constraint`.
    The `noexcept` keyword is optional, in which case the expression must not be potentially
    throwing. The requirement for the return type, introduced with `->`, is also optional.
    However, if it is present, then `decltype(expression)` must satisfy the constraints
    imposed by `type-constraint`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested requirements**: These are more complex expressions that specify constraints
    defined as a requires expression, which can, in turn, be another nested requirement.
    A requirement that starts with the keyword `requires` is considered a nested requirement.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before they are evaluated, the body of every name concept and every `requires`
    expression is substituted until a sequence of conjunctions and disjunctions of
    atomic constraints is obtained. This process is called *normalization*. The actual
    details of normalization and the analysis the compiler performs are beyond the
    scope of this book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring abbreviated function templates
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, we learned about function templates as well as lambda expressions,
    including generic and template lambdas. A generic lambda is a lambda expression
    that uses `auto` specified for one of its parameters. The result is a function
    object with a templated call operator. The same is produced as a result of defining
    a lambda template that has the advantage, over generic lambdas, of allowing better
    control over the types of the parameters. In C++20, this idea of using the `auto`
    specifier for parameter types is generalized for all functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: This introduces a simplified syntax of defining function templates, and functions
    that are defined in this way are called **abbreviated function templates**. We
    will see in this recipe how to use them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define the following categories of abbreviated function templates in
    C++20:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Unconstrained abbreviated function templates that use the `auto` specifier
    to define parameters:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Constrained abbreviated function templates that use concepts, specified before
    the `auto` specifier, to constrain the parameters of the function template:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Constrained variadic abbreviated function templates that use the syntax seen
    above but with a parameter pack:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Constrained abbreviated lambda expressions that use the syntax seen above but
    with a lambda expression:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Specializations of abbreviated function templates can be defined just as for
    function templates defined with the regular template syntax:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The template syntax is considered by many rather cumbersome. Abbreviated function
    templates are meant to simplify writing some categories of function templates.
    They do so by using the `auto` specifier as a placeholder for parameter types,
    instead of the typical template syntax. The following two definitions are equivalent:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the intention is to define a function template with both arguments of the
    same type, then this form of the abbreviated function template is not enough.
    These abbreviated function templates are called **unconstrained** because there
    are no constraints placed on the arguments of the function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Such constraints can be defined with the help of concepts, as shown below:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The category of abbreviated function templates is called **constrained**. The
    function above is equivalent to the following regular function template:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since an abbreviated function template is a function template, it can also
    be specialized like any function declared with the standard template syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Constrained abbreviated function templates can also be variadic; that is, they
    have a variable number of arguments. There is nothing special about them, other
    than what we already learned in *Chapter 5*. Moreover, the syntax can also be
    used to define lambda templates. Examples of these were given in the previous
    section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Using generic lambdas*, to learn about the use of both generic
    lambdas and lambda templates'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Writing function templates* to explore the syntax for writing
    function templates'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Writing a function template with a variable number of arguments*,
    to see how you can write functions that take a variable number of arguments'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to learn how
    to constrain the arguments with a function template, with the help of concepts'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over collections with the ranges library
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard library provides three important pillars—containers, iterators,
    and algorithms—that enable us to work with collections. Because these algorithms
    are for general purposes and are designed to work with iterators, which define
    a range, they often require writing explicit and sometimes complex code to achieve
    simple tasks. The C++20 ranges library has been designed to solve this problem
    by providing components for handling ranges of elements. These components include
    range adapters (or views) and constrained algorithms that work with a range instead
    of iterators. In this recipe, we will look at some of these views and algorithms
    and see how they can simplify coding.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following snippets, we will refer to a function called `is_prime()`,
    which takes an integer and returns a Boolean, indicating whether the number is
    prime or not. A simple implementation is shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For an efficient algorithm, which is beyond the scope of this recipe, I recommend
    the Miller–Rabin primality test.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The ranges library is available in the new `<ranges>` header, in the `std::ranges`
    namespace. For simplicity, the following namespace aliases will be used in this
    recipe:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will explore various uses of the ranges library in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ranges library can be used to iterate through ranges with operations such
    as the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a sequence of consecutive integers with the `iota_view` / `views::iota`
    view. The following snippet prints all integers from 1 to 9:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Filter the elements of a range with `filter_view` / `views::filter`, by retaining
    only those that satisfy a predicate. The first snippet here prints all the prime
    numbers from 1 to 99\. However, the second snippet retains and prints all the
    prime numbers from a vector of integers:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Transform the elements of a range with `transform_view` / `views::transform`
    by applying a unary function to each element. The following snippet prints the
    successor of all the prime numbers from 1 to 99:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Retain only the first *N* elements of a view with `take_view` / `views::take`.
    The following snippet prints only the first 10 prime numbers from 1 and 99:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Iterate a range in reverse order with `reverse_view` / `views::reverse`. The
    first snippet here prints the first 10 prime numbers from 99 to 1 (in descending
    order), while the second snippet prints the last 10 prime numbers from 1 to 99
    (in ascending order):'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Skip the first *N* elements of a range with `drop_view` / `views::drop`. The
    snippet here prints, in ascending order, the prime numbers between 1 and 99, but
    it skips the first and last 10 primes in the sequence:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The ranges library can also be used to call algorithms using a range instead
    of iterators. Most algorithms have overloads for this purpose. Examples are shown
    here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine the maximum element of a range:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sort a range:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Copy a range. The following snippet copies the elements of the range to the
    standard output stream:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Reverse the elements of a range:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Count the elements of a range (that verify a predicate):'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++20 ranges library provides various components for dealing with ranges
    of elements. These include:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Range concepts, such as `range` and `view`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range access functions, such as `begin()`, `end()`, `size()`, `empty()`, and
    `data()`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range factories that create sequences of elements, such as `empty_view`, `single_view`,
    and `iota_view`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range adaptors, or views, that create a lazy evaluated view from a range, such
    as `filter_view`, `transform_view`, `take_view`, and `drop_view`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A range is defined as a sequence of elements that can be iterated over with
    an iterator and an end sentinel. Ranges are of different types, depending on the
    capabilities of the iterators that define the range. The following concepts define
    types of ranges:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **Iterator type** | **Capabilities** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| `input_range` | `input_iterator` | Can be iterated at least once for reading.
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| `output_range` | `output_iterator` | Can be iterated For writing. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| `forward_range` | `forward_iterator` | Can be iterated multiple times. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `bidirectional_range` | `bidirectional_iterator` | Can be iterated also in
    reverse order. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| `random_access_range` | `random_access_iterator` | Elements can be accessed
    randomly in constant time. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| `contiguous_range` | `contiguous_iterator` | Elements are stored contiguously
    in memory. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: The list of concepts that define the types of ranges'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Because a `forward_iterator` satisfies the requirements of an `input_iterator`,
    and a `bidirectional_iterator` satisfies those of a `forward_iterator`, and so
    on (from top to bottom in the preceding table), so do the ranges. A `forward_range`
    satisfies the requirements of an `input_range`, and a `bidirectional_range` satisfies
    those of a `forward_range`, and so on. Apart from the range concepts listed in
    the preceding table, there are other range concepts. One worth mentioning is `sized_range`,
    which requires that a range must know its size in constant time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard containers meet the requirements of different range concepts.
    The most important of them are listed in the following table:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Input range** | **Forward range** | **Bidirectional range** | **Random
    access range** | **Contiguous range** |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| `forward_list` | ✓ | ✓ |  |  |  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| `list` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| `dequeue` | ✓ | ✓ | ✓ | ✓ |  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| `array` | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| `vector` | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| `set` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| `map` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| `multiset` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `multimap` | ✓ | ✓ | ✓ |  |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set` | ✓ | ✓ |  |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| `unordered_map` | ✓ | ✓ |  |  |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| `unordered_multiset` | ✓ | ✓ |  |  |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| `unordered_multimap` | ✓ | ✓ |  |  |  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: 'Table 12.2: A list of standard containers and the requirements they meet'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: A central concept of the ranges library is the range *adaptor*, also called
    a *view*. A view is a non-owning wrapper of a range of elements that requires
    constant time to copy, move, or assign elements. Views are composable adaptations
    of ranges. However, these adaptations happen lazily, only when the view is iterated.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we saw examples of using various views: filter, transform,
    take, drop, and reverse. There are a total of 16 views available in the library.
    All the views are available in the namespace `std::ranges` and have names such
    as `filter_view`, `transform_view`, `take_view`, `drop_view`, and `reverse_view`.
    However, for simplicity of use, these views can be used with expressions of the
    form `views::filter`, `views::take`, `views::reverse`, and so on. Notice that
    the types and values of these expressions are unspecified and are a compiler implementation
    detail.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the views work, let’s take a look at the following example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The composition of views is equivalent to the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In general, the following rules apply:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: If an adaptor `A` takes only one argument, a range `R`, then `A(R)` and `R|A`
    are equivalent.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an adaptor `A` takes multiple arguments, a range `R` and `args...`, then
    the following three are equivalent: `A(R, args...)`, `A(args...)(R)`, and `R|A(args...)`.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from ranges and range adaptors (or views), overloads of the general-purpose
    algorithms are also available in C++20, in the same `std::ranges` namespace. These
    overloads are called *constrained algorithms*. A range can be provided either
    as a single argument (as seen in the examples in this recipe) or as an iterator-sentinel
    pair. Also, for these overloads, the return type has been changed to provide additional
    information that’s computed during the execution of the algorithm.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard ranges library has been designed based on the **range-v3** library,
    created by Eric Niebler and available on GitHub at [https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3).
    This library provides a larger set of range adaptors (views), as well as actions
    that provide mutating operations (such as sorting, erasing, shuffling, and so
    on). The transition from the range-v3 library to the C++20 ranges library can
    be very smooth. In fact, all the samples provided in this recipe work with both
    libraries. All you have to do is include the appropriate header files and use
    the range-v3-specific namespaces:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With these replacements, all the snippets from the *How to do it...* section
    will continue to work using a C++17-compliant compiler.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating your own range view*, to see how to extend the ranges library’s capabilities
    with user-defined range adaptors'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the standard range adaptors
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at how the ranges library helps us simplify
    various tasks when working with collections (ranges), such as enumerating, filtering,
    transforming, and reversing. We did so with the help of range adaptors. However,
    we have only looked at a small set of adaptors. There are more available in the
    standard library, some included in C++20 and others in C++23\. In this recipe,
    we will explore all the adapters in the standard library.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the snippets shown in this recipe, we will use the following namespace aliases:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Also, to compile the snippets below, you need to include the `<ranges>` and
    `<algorithm>` headers (for the ranges library).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++20, the following adaptors are available to use:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '`ranges::filter_view` / `views::filter` represents a view of the underlying
    sequence but without the elements that do not satisfy a specified predicate:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`ranges::transform_view` / `views::transform` represents a view of the underlying
    sequence after applying a specified function to each element of the range:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`ranges::take_view` / `views::take` represents a view of the underlying sequence,
    starting at the beginning and containing the specified number of elements:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`ranges::take_while_view` / `views::take_while` represents a view of the underlying
    sequence, starting at the beginning and containing all the consecutive elements
    that satisfy a given predicate:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ranges::drop_view` / `views::drop` represents a view of the underlying sequence
    after skipping the specified number of elements:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`ranges::drop_while_view` / `views::drop_while` represents a view of the underlying
    sequence after skipping all the consecutive elements (from the beginning) that
    satisfy a given predicate:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`ranges::join_view` / `views::join` flattens a view of ranges; it represents
    a view consisting of all the elements of a sequence of sequences:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`ranges::split_view` / `views::split` represents a view of subranges obtained
    by splitting a view with a specified delimiter. The delimiter is not part of the
    resulting subranges:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`ranges::lazy_split_view` / `views::lazy_split` is similar to `split`, except
    that it works in a *lazy mode*, meaning that it does not look ahead for the next
    delimiter until we iterate for the next element of the result. It works with constant
    ranges, which are not supported by `split_view`:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`ranges::reverse_view` / `views::reverse` represents a view of an underlying
    sequence with the elements presented in the reverse order:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`ranges::elements_view` / `views::elements` represents a view of the *N*th
    element of an underlying sequence of tuple-like values:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`ranges::keys_view` / `views::keys` represent an alias for `ranges::elements_view<R,
    0>` and, respectively, an object of type `views::elements<0>`.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ranges::values_view` / `views::values` represent an alias for `ranges::elements_view<R,
    1>` and, respectively, an object of type `views::elements<1>`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In C++23, the following adaptors were added to the standard library:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '`ranges::enumerate_view` / `views::enumerate` represents a view of tuples,
    with the first element being the zero-based index of the element of the underlying
    sequence, and the second element being a reference to the underlying element:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`ranges::zip_view` / `views::zip` represents a view of tuples created from
    two or more underlying views, with the *N*th tuple created from the *N*th element
    of each underlying view:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`ranges::zip_transform_view` / `views::` `zip_transform` represents a view
    of elements produced by applying a given function to two or more views. The *N*th
    element of the result view is produced from the *N*th element of all the specified
    underlying views:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`ranges::adjacent_view` / `views::adjacent` represents a view of tuples of
    *N* elements from an underlying view; each tuple is a window in the underlying
    view, the *i*th tuple containing the elements with the indexes in the range `[i,
    i + N - 1]`:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`ranges::adjacent_transform_view` / `views::adjacent_transform` represents
    a view of elements produced by applying a specified function to *N*-adjacent elements
    of an underlying view; the *i*th element of the resulting view is produced by
    applying the function to the elements of the underlying range with the indexes
    in the range `[i, i + N - 1]`:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`ranges::join_with_view` / `views::join_with` is similar to `join_view` because
    it flattens a view of ranges to a single view; however, it takes a delimiter that
    it inserts between the elements of the underlying ranges:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`ranges::slide_view` / `views::slide` is a range adaptor similar to `ranges::adjacent_view`
    / `views::adjacent`, except that the size of the windows from the underlying sequence
    is specified at runtime:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`ranges::chunk_view` / `views::chunk` represents a view of sub-views of *N*
    elements of the underlying view. The last chunk may have fewer than *N* elements
    (if the size of the underlying view is not a multiple of *N*):'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`ranges::chunk_by_view` / `views::chunk_by` represents a view of sub-views
    of an underlying view, produced by splitting the underlying view each time a supplied
    binary predicate applied to two adjacent elements returns `false`:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '`ranges::stride_view` / `views::stride` is a view of some elements from an
    underlying view, starting with the first and advancing over *N* elements each
    time:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`ranges::cartesian_product_view` / `views::cartesian_product` represents a
    view of tuples computed as the cartesian product of 1 or more underlying views:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: How it works…
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how range adaptors work in the previous recipe. In this section, we will
    only look at some of the details and differences between some adaptors that you
    should be aware of.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: To start, let’s consider `adjacent_view` and `slide_view`. They are similar
    in the sense that they take one view and produce another view of sub-views of
    this underlying view. These sub-views are referred to as *windows* and have a
    specified size, *N*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The first window starts from the first element, the second from the second
    element, etc. However, they differ in two significant ways:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The size *N* of the windows is specified at compile time for `adjacent_view`
    and at runtime for `slide_view`.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements of the view represented by `adjacent_view` are tuples, while the
    elements of the view represented by `slide_view` are other views.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram presents a comparison of these two adaptors:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_12_02.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Comparison of adjacent_view<3>(R) and slide_view(R, 3)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: When the size of the windows is 2, you can use `views::pairwise` and `views::pairwise_transform`,
    which are objects of type `adjacent<2>` and `adjacent_transform<2>`, respectively.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'The next pair of adaptors to look at are `split_view` and `lazy_split_view`.
    They both do the same thing: split a view into subranges based on a given delimiter,
    which can be either a single element or a view of elements. Neither of the two
    adaptors include the delimiter in the resulting subranges. These two, however,
    differ in a key aspect: the `lazy_split_view` adaptor is, as the name implies,
    *lazy*, meaning that it does not look ahead to the next delimiter until we iterate
    for the next element of the result, which `split_view` does. Moreover, `split_view`
    supports ranges of the `forward_range` type or higher but cannot split a constant
    range, while `lazy_split_view` supports ranges of the `input_range` type or higher
    and can split a constant range.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The question that arises is which one to use and when? Typically, you should
    prefer `split_view` because it is more efficient than `lazy_split_view` (which
    has a less efficient iterator incrementation and comparison). However, if you
    need to split a constant range, then `split_view` is not an option, and you should
    use `lazy_split_view`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: There are two adaptors, `join_view` (in C++20) and `join_with_view` (in C++23),
    that perform a join operation, transforming a range of ranges into a single (flattened)
    range. The difference between them is that the latter, `join_with_view`, takes
    a delimiter that is inserted in the result between the elements of two consecutive
    underlying ranges.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the standard range adaptors, you can consult the online
    documentation available at [https://en.cppreference.com/w/cpp/ranges](https://en.cppreference.com/w/cpp/ranges).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using constrained algorithms*, to learn about the standard generic algorithms
    that work with ranges'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a range to a container
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result of applying various range adapters to a range (such as a container)
    is a complex type that is difficult to type or remember. Typically, we’d use the
    `auto` specifier to indicate the type of the result of chaining adaptors, as we
    saw in the previous recipes. Ranges are lazy, which means they are evaluated,
    and they produce results only when we iterate over them. However, we often need
    to store the result of applying one or more range adaptors in a container, such
    as a vector or a map. Prior to C++23, this required explicit coding. However,
    C++23 provides a range conversion function, called `std::ranges::to`, which makes
    this an easy task. It also enables conversion between different containers. In
    this recipe, we will learn how to use it.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `is_prime()` function used in the following snippets was shown in the recipe
    *Exploring the standard range adaptors* and will not be listed again here.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can convert a range to a container using the `std::ranges::to` range conversion
    function, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert a range to a `std::vector`:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Convert a range to a map type, such as `std::unordered_multimap`:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Convert a range to a `std::string`:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works…
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::ranges::to` range conversion function is available in the `<ranges>`
    header, starting with C++23 (the feature-test macro `__cpp_lib_ranges_to_container`
    can be used to test whether it is supported or not).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the previous examples showed how to convert from one range to another,
    `std::ranges::to` can also be used to convert between different types of containers,
    such as a vector to a list, or a map to a vector of pairs:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'When you use the pipe (`|`) syntax, the parentheses are mandatory; otherwise,
    you will get compiler errors (which are difficult to read):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The correct syntax is the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: See also
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Exploring the standard range adaptors*, to learn about the range adaptors
    available in C++20 and C++23'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using constrained algorithms*, to learn about the standard generic algorithms
    that work with ranges'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own range view
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 ranges library simplifies the handling of ranges of elements. The
    16 range adaptors (views) defined in the library provide useful operations, as
    seen in the previous recipe. However, you can create your own view that can be
    used together with the standard ones. In this recipe, you will learn how to do
    that. We will create a view called `trim` that, given a range and a unary predicate,
    returns a new range without the front and back elements that satisfy the predicate.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the same namespace aliases used in the previous
    one, with `rg` as an alias for `std::ranges` and `rv` as an alias for `std::ranges::views`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a view, do the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class template, called `trim_view`, derived from `std::ranges::view_interface`:'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Define the internal state of the class, which, at a minimum, should include
    a begin and end iterator and the viewable range that is adapted by the view. For
    this adapter, we also need a predicate, as well as a Boolean variable to flag
    whether the iterators have been evaluated or not:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Define a default constructor (that can be defaulted) and a `constexpr` constructor
    with the required parameters. The first parameter is always the range. For this
    view, the other parameter is a predicate:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Provide accessors to the internal data, such as the base range and the predicate:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Provide functions to retrieve the begin and end iterators. To make sure the
    view is lazy, these iterators should only be evaluated by their first use:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Provide other useful members, such as a function, to return the size of the
    range:'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Put all together, the view appears as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To simplify the composability of this user-defined view with the standard ones,
    the following should also be done:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a user-defined deduction guide for the class template argument deduction
    of the `trim_view` class template:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Create function objects that can instantiate the `trim_view` adaptor with the
    proper arguments. These can be made available in a separate namespace because
    they represent implementation details:'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Overload the pipe operator for the `trim_view_range_adaptor_closure` class
    defined previously:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create an object of the `trim_view_range_adaptor` type that can be used to
    create `trim_view` instances. This can be done in a namespace called `views` to
    create a similarity with the namespaces of the ranges library:'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `trim_view` class template we defined here is derived from the `std::ranges::view_interface`
    class template. This is a helper class in the ranges library to define views,
    using the **curiously recurring template pattern** (**CRTP**). There are two template
    arguments for the `trim_view` class: the range type, which must satisfy the `std::ranges::input_range`
    concept, and the predicate type.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'The `trim_view` class stores the base range and the predicate internally. Additionally,
    it requires a beginning and end (sentinel) iterator. These iterators must point
    to the first element and the ones past the last element of the range that do not
    satisfy the trimming predicate. However, because the view is a lazy object, these
    iterators should not be resolved before they are needed to iterate over the range.
    The following diagram shows the positions of these iterators in a range of integers,
    for when the view must trim the odd numbers from the beginning and end of the
    range `{1,1,2,3,5,6,4,7,7,9}`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21549_12_03.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: A visual conceptual representation of the range and the position
    of the start and end iterators before the iteration starts (above) and when it
    starts (below)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `trim_view` class to write the following snippets:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Using the `trim_view` class, as well as composition with other views, is simplified
    through the use of the function objects declared in the `details` namespace, which
    represent implementation details. However, these, together with the overloaded
    pipe operator (`|`), make it possible to rewrite the preceding code as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: It should be mentioned that the **range-v3** library does contain a range view
    called `trim`, but it was not ported to the C++20 ranges library. This may happen
    in a future version of the standard.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 10**, Static polymorphism with the curiously recurring template pattern*
    to see how the CRTP works'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constrained algorithms
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard library features over 100 generic-purpose algorithms (most
    of them in the `<algorithm>` header, and some of them in the `<numeric>` header).
    Some of these algorithms we saw in *Chapter 5*, over the course of several recipes,
    when we learned how to search elements in a range, sort a range, initialize a
    range, and more. The generic aspect of algorithms comes from the fact they work
    with iterators (a beginning and end iterator to a sequence of elements–a range)
    but this has the downside of requiring more explicit code that needs to be repeated
    over and over again. To ease the use of these algorithms, the C++20 standard provides
    matching algorithms in the `std::ranges` namespace that work with ranges (but
    also have overloads for iterators). These algorithms from the ranges library are
    called **constrained algorithms** and are available in the `<algorithm>` header.
    Although it’s not possible to look at all of them here, in this recipe we will
    see how to use several of them for initializing, sorting, and finding elements
    in a range.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform various operations on ranges, including initializing, finding,
    and sorting, as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::ranges::fill()` to assign a value to all the elements of a range:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Use `std::ranges::fill_n()` to assign a value to a specified number of elements
    of a range. The first element to be assigned is indicated by an output iterator:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Use `std::ranges::generate_n()` to assign the value returned by successive
    invocations of a given function to a number of elements of a range. The first
    element is indicated by an iterator:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Use `std::ranges::iota()` to assign sequentially increasing values to the elements
    of a range. The values are incremented using the prefix `operator++` from an initial
    specified value:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Use `std::ranges::find()` to find a value in a range; this algorithm returns
    an iterator to the first element equal to the supplied value, if such a value
    exists, or an iterator equal to the end of the range:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Use `std::ranges::find_if()` to find a value in a range that meets the criteria
    defined by a unary predicate. The algorithm returns an iterator to the first element
    in the range for which the predicate returns `true`, or an iterator to the end
    of the range if no such element exists:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Use `std::ranges::find_first_of()` to search for the occurrence of any value
    from a range in another range; the algorithm returns an iterator to the first
    element (in the searched range) that is found, or one equal to the end of the
    range, otherwise:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Use `std::ranges::sort()` to sort a range. You can supply a comparison function
    to be applied to the elements. This can include `std::ranges::greater`, `std::ranges::less`,
    and the other function objects from the `<functional>` header corresponding to
    the `<`, `<=`, `>`, `>=`, `==`, and `!=` operators:'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Use `std::ranges::is_sorted()` to check that a range is sorted:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Use `std::ranges::is_sorted_until()` to find a sorted subrange from the beginning
    of a range:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works…
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All but one of the constrained algorithms are located in the `<algorithm>`
    header. The exception is `std::ranges::iota()`, which is found in the `<numeric>`
    header. The algorithms listed in the *How to do it…* section are only a small
    selection of the available constrained algorithms. They are called constrained
    because there are requirements defined in their arguments with the help of concepts
    and constraints. Here is the definition of one of the overloads of `std::ranges::find()`
    that we used previously:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: On the other hand, there are some algorithms, such as `std::ranges::fill_n()`
    and `std::ranges::generate_n()`, seen earlier, that have a single overload that
    takes only one iterator, from the beginning of the range.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between the traditional algorithms and the constrained algorithms
    is that the latter do not have overloads to specify an execution policy, unlike
    the former, which do.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'The constrained algorithms have several advantages over the traditional algorithms:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: There is less code to write because you don’t have to retrieve the beginning
    and ending iterator of a range.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are constrained, using concepts and constraints, which help provide better
    error messages in case of misuse.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used with ranges/views as defined by the ranges library.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of them have overloads that allow you to specify a projection to apply
    to the elements, on which, in turn, a specified predicate is applied.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first see how the constrained algorithms interact with ranges. For this,
    we consider the following example:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In this example, we have a vector of integers. From this vector, we filter out
    the even numbers, transform the rest by their square, and, finally, retain four
    of the resulting numbers. The result is a range. Its type is too complex to remember
    or write; therefore, we use the `auto` specifier and let the compiler infer it.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who wonder what the actual type is (in this previous example),
    it is `std::ranges::take_view<std::ranges::transform_view<std::ranges::filter_view<std::ranges::ref_view<std::vector<int>>,
    lambda [](int n)->bool>, lambda [](int n)->int>>`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: We want to print the resulting values to the console and find the first value
    greater than 10 (if any exists). For this purpose, we use `std::ranges::for_each()`
    and `std::ranges::find_if()`, passing the `range` object without having to deal
    directly with iterators.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: The last advantage mentioned earlier in the list is the ability to specify a
    projection. A projection is a callable object (for instance, a function object,
    or a reference to a member). This projection is applied to the elements of the
    range. On the result of the projection, another predicate is applied.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let’s consider a list of products with an ID,
    name, and price. From this list, we want to find the product with a certain price
    and print its name. The list is defined as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'With the traditional algorithms, we need to use `std::find_if()` and pass a
    lambda function that performs the checking of each element:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'With constrained algorithms, we can use one of the overloads of `std::ranges::find()`
    that take a range, a value, and a projection, as shown in the following snippet:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Another similar example is sorting the range alphabetically (in ascending order)
    by the name of the products:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Hopefully, these examples show there are compelling arguments to prefer, in
    general, the new C++20 constrained algorithms over the traditional ones. However,
    keep in mind that you cannot use constrained algorithms when you want to specify
    an execution policy (for instance, to parallelize or vectorize the execution of
    an algorithm), as such overloads are not available.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Finding elements in a range*, to learn about the standard algorithms
    to search through sequences of values'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Sorting a range*, to learn about the standard algorithms for
    sorting ranges'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Initializing a range*, to explore the standard algorithms for
    filling a range with values'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specify requirements on template arguments with concepts*, to explore the
    fundamentals of C++20 concepts'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine task type for asynchronous computations
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major component of the C++20 standard is represented by coroutines. Simply
    put, coroutines are functions that can be suspended and resumed. Coroutines are
    an alternative to writing asynchronous code. They help simplify asynchronous I/O
    code, lazy computations, or event-driven applications. When a coroutine is suspended,
    the execution returns to the caller, and the data necessary to resume the coroutine
    is stored separately from the stack. For this reason, the C++20 coroutines are
    called *stackless*. Unfortunately, the C++20 standard does not define actual coroutine
    types and only a framework for building them. This makes writing asynchronous
    code with coroutines difficult without relying on third-party components.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to write a coroutine task type that represents
    an asynchronous computation, which starts executing when the task is awaited.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The several standard library types and functions that define the coroutine
    framework are available in the `<coroutine>` header, in the `std` namespace. However,
    you need to use a minimum compiler version to support coroutines: MSVC 19.28 (from
    Visual Studio 2019 16.8), Clang 17, or GCC 10.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to create a task type that enables us to write asynchronous
    functions, as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: How to do it...
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a task type that supports coroutines that return nothing (`task<>`),
    a value (`task<T>`), or a reference (`task<T&>`), you should do the following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class called `promise_base` with the following content:'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Create a class template called `promise`, derived from `promise_base`, that
    adds the methods `get_return_object()` and `return_value()` and holds the value
    returned from the coroutine:'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Specialize the `promise` class template for the `void` type, and provide implementations
    for the `get_return_object()` and `return_void()` methods:'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Specialize the `promise` class template for `T&`. Provide implementations for
    `get_return_object()` and `return_value()`, and store a pointer to the reference
    returned by the coroutine:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Create a class template called `task`, with the stub content shown below. This
    type must have an inner type called `promise_type` and hold a handle to the executing
    coroutine. The `task_awaiter` and the class members are listed here:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Create an awaitable class called `task_awaiter` that implements the `await_ready()`,
    `await_suspend()`, and `await_resume()` methods:'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Provide class members, including a conversion constructor, a move constructor
    and move assignment operator, a destructor, a `co_await` operator, a method to
    check whether the coroutine has completed, a method to resume a suspended coroutine,
    and a method to get the value returned from the coroutine:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Implement the `get_return_object()` member of the `promise` primary template
    as well as its specializations. This must be done after the definition of the
    `task` class:'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: How it works...
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are blocks of code that execute one or more statements. You can assign
    them to variables, pass them as arguments, take their address, and, of course,
    invoke them. These features make them first-class citizens in the C++ language.
    Functions are sometimes called *subroutines*. Coroutines, on the other hand, are
    functions that support two additional operations: suspending and resuming their
    execution.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, a function is a coroutine if it uses any of the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The `co_await` operator, which suspends the execution until resumed
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `co_return` keyword, to complete the execution and optionally return a value
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `co_yield` keyword, to suspend the execution and return a value
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not every function, however, can be a coroutine. The following cannot be coroutines:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and destructors
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constexpr functions
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with a variable number of arguments
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return `auto` or a concept type
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` function
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A coroutine consists of the following three parts:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: A *promise object*, which is manipulated inside the coroutine and is used to
    pass the return value or an exception from the coroutine.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *coroutine handle*, which is manipulated outside the coroutine and is used
    to either resume the execution or destroy the coroutine frame.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *coroutine frame*, typically allocated on the heap and containing the promise
    object, the coroutine parameters copied by value, local variables, temporaries
    whose lifetimes exceed the current suspension point, and a representation of the
    suspension point so that resuming and destroying can be performed.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The promise object can be any type that implements the following interface,
    as expected by the compiler:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '| **Default constructor** | **The promise must be default constructible** |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
- en: '| `initial_suspend()` | Indicates whether suspension happens at the initial
    suspend point. |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '| `final_suspend()` | Indicates whether suspension happens at the last suspend
    point. |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
- en: '| `unhandled_exception()` | Called when an exception propagates out of a coroutine
    block. |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
- en: '| `get_return_object()` | The return value of the function. |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
- en: '| `return_value(v)` | Enables the `co_return v` statement. Its return type
    must be `void`. |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
- en: '| `return_void()` | Enables the `co_return` statement. Its return type must
    be `void`. |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
- en: '| `yield_value(v)` | Enables the `co_yield v` statement. |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
- en: 'Table 12.3: The members of the interface implemented by a promise'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `initial_suspend()` and `final_suspend()` we have seen
    for the `promise` type implemented here returns an instance of `std::suspend_always`.
    This is one of the two trivial awaitables that the standard defines, the other
    being `std::suspend_never`. Their implementation is as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'These types implement the *awaitable* concept, which enables the use of the
    `co_await` operator. There are three functions required by this concept. These
    can be either free functions or class member functions. They are listed in the
    following table:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '| `await_ready()` | Indicates whether the result is ready. If the return value
    is `false` (or a value convertible to `false`), then `await_suspend()` is called.
    |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
- en: '| `await_suspend()` | Schedules the coroutine to resume or to be destroyed.
    |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
- en: '| `await_resume()` | Provides the result for the entire `co_await e` expression.
    |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
- en: 'Table 12.4: Functions that the awaitable concepts require'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'The `task<T>` type we built in this recipe has several members:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: An explicit constructor that takes an argument of the `std::coroutine_handle<T>`
    type, representing a non-owning handle to the coroutine.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destructor that destroys the coroutine frame.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move constructor and move assignment operator.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deleted copy constructor and copy assignment operator, making the class moveable-only.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `co_await` operator, which returns a `task_awaiter` value that implements
    the awaitable concept.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_ready()`, a method that returns a Boolean value indicating whether the
    coroutine value is ready.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resume()`, a method that resumes the execution of the coroutine.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value()`, a method that returns the value held by the promise object.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inner promise type called `promise_type` (this name is mandatory).
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an exception occurs during the execution of the coroutine, and this exception
    leaves the coroutine without being handled, then the `unhandled_exception()` method
    of the promise is invoked. In this simple implementation, this situation is not
    handled, and the program is abnormally terminated with a call to `std::terminate()`.
    In the following recipe, we will see an awaitable implementation that handles
    exceptions.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the following coroutine as an example to see how the compiler handles
    it:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Because of all the mechanisms we built in this recipe, the compiler transforms
    this code into the following (this snippet is pseudocode):'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: As mentioned earlier, the `main()` function is one of the functions that cannot
    be a coroutine. For this reason, it is not possible to use the `co_await` operator
    in `main()`. This means that waiting for a coroutine to complete must be done
    differently in `main()`.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'This is handled with the help of a function template called `execute()` that
    runs the following loop:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This loop ensures that the coroutine is resumed after each suspension point,
    until its final completion.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++20 standard does not provide any coroutine types, and writing your own
    is a cumbersome task. Fortunately, third-party libraries can offer these abstractions.
    Such a library is **libcoro**, an open-source experimental library that provides
    a set of general-purpose primitives to make use of the coroutines described in
    the C++20 standard. The library is available at [https://github.com/jbaldwin/libcoro](https://github.com/jbaldwin/libcoro).
    Among the components it provides is the `task<T>` coroutine type, similar to what
    we built in this recipe. Using the `coro::task<T>` type, we can rewrite our examples
    as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: As you can see, the code is very similar to what we wrote in the first part
    of this recipe. The changes are minimal. By using this **libcoro** library or
    others that are similar, you do not need to be concerned with the details of implementing
    coroutine types and instead focus on their use.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Another library that was used in the second edition of the book was **cppcoro**,
    which is available at [https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro).
    However, the **cppcoro** library has not been maintained for several years. Although
    it’s still available on GitHub, it relies on the experimental implementation of
    technical specifications for coroutines. For instance, when using MSVC, this requires
    the use of the now obsolete `/await` compiler flag. You should only use this library
    as a source of inspiration to write coroutine primitives, such as the one we will
    see in the next recipe.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a coroutine generator type for sequences of values*, to learn how
    to enable the use of `co_yield` to return multiple values from a coroutine'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coroutine generator type for sequences of values
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to create a coroutine task that enables asynchronous
    computations. We used the `co_await` operator to suspend execution until resumed
    and the `co_return` keyword to complete execution and return a value. However,
    another keyword, `co_yield`, also defines a function as a coroutine. It suspends
    the execution of the coroutine and returns a value. It enables a coroutine to
    return multiple values, one each time it is resumed. To support this feature,
    another type of coroutine is required. This type is called a *generator*. Conceptually,
    it’s like a stream that produces a sequence of values of type `T` in a lazy manner
    (when iterated). In this recipe, we will see how we can implement a simple generator.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to create a generator coroutine type that enables
    us to write code like the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: It is recommended that you follow the previous recipe, *Creating a coroutine
    task type for asynchronous computations*, before you continue with this one.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a generator coroutine type that supports synchronous lazy production
    of a sequence of values, you should do the following:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class template, called `generator`, with the following content (the
    details of each part are presented in the following bullet points):'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Create an inner class called `promise_type` (the name is mandatory) with the
    following content:'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Create an inner class called `iterator` with the following content:'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Provide a default constructor, an explicit constructor from a `promise_type`
    object, a move constructor and a move assignment operator, and a destructor. Delete
    the copy constructor and copy assignment operator so that the type is moveable
    only:'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Provide the `begin()` and `end()` functions to enable iteration over the generator
    sequence:'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: How it works...
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The promise type implemented in this recipe is similar to the one from the
    previous recipe, although there are some differences:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: It is implemented as an inner type, so the name is `promise_type`, since the
    coroutine framework requires the coroutine type to have an inner promise type
    with this name.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports handling exceptions that leave the coroutine block uncaught. In
    the previous recipe, this situation was not treated, and an `unhandled_exception()`
    called `std::terminate()` to abnormally terminate the process. This implementation,
    however, retries a pointer to the current exception and stores it in an `std::exception_ptr`
    object. This exception is rethrown when iterating through the generated sequence
    (either when calling `begin()` or when incrementing the iterator).
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions `return_value()` and `return_void()` are not present, but replaced
    with `yield_value()`, which is called when the `co_yield expr` expression is resolved.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generator class also bears some similarities to the task class from the
    previous recipe:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: It is default-constructible
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be constructed from a promise object
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not copy-constructible and copyable
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is move-constructible and moveable
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its destructor destroys the coroutine frame
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class does not overload the `co_await` operator, as it does not make sense
    to wait on the generator; instead, it provides the functions `begin()` and `end()`,
    which return iterator objects that enable iterating over the sequence of values.
    This generator is said to be lazy because it does not produce new values until
    the coroutine is resumed, either by calling `begin()` or incrementing an iterator.
    The coroutine is created suspended, and its first execution begins only when calling
    the `begin()` function. The execution continues either until the first `co_yield`
    statement or until the coroutine completes its execution. Similarly, incrementing
    the iterator will resume the execution of the coroutine, which continues either
    until the next `co_yield` statement or until its completion.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a coroutine that produces several integer values.
    It does so not by using a loop but by repeating `co_yield` statements:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: An important thing to note is that the coroutine can only use the `co_yield`
    keyword and produce values synchronously. The use of the `co_await` operator within
    the coroutine is not supported with this particular implementation. To be able
    to suspend execution by using the `co_await` operator, a different implementation
    is required.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **libcoro** library, mentioned in the previous recipe, has a `generator<T>`
    type that can be used instead of the one we created here. In fact, by replacing
    our `generator<T>` with `coro::generator<T>`, the snippets of code shown previously
    will continue to work as expected.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a coroutine task type for asynchronous computations*, for an introduction
    to the C++20 coroutines'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a sequence of values with the std::generator type
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++20 standard includes two major updates to the standard library: the
    ranges library and coroutines. However, with regard to the latter, the support
    is minimal. The C++20 standard only defines a framework for building coroutines.
    Because of this, libraries such as **libcoro**, which we have previously seen,
    were created to provide actual coroutines, such as `task` and `generator`, which
    we also saw in the previous two recipes. The C++23 standard introduces the first
    standard coroutine, called `std::generator`. This brings together ranges and coroutines
    because `std::generator` is a view that represents a synchronous coroutine generator.
    This is a standard implementation for what we explicitly built in the previous
    recipe, *Creating a coroutine generator type for sequences of values*. Let’s see
    how it works.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, only GCC 14 supports this standard coroutine.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate a sequence of elements, in a lazy manner, write a coroutine that:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Uses `std::generator<T>` as the return type.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the `co_yield` statement to return a value.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: How it works…
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new `std::generator` class template is available in its own header, called
    `<generator>`. It derives from `std::ranges::view_interface`; therefore, it is
    a view of elements that are yielded from the evaluation of a coroutine (an interruptible
    function). The class is defined as follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Every time the coroutine is resumed and a `co_yield` statement is evaluated,
    a new element of a sequence is produced. The following is an example that contains
    a series of `co_yield` statements (not a loop). In total, this coroutine produces
    three elements. However, if the `get_values()` coroutine is only evaluated once,
    it will only produce one element. We call this a lazy evaluation:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The `std::generator` type is a synchronous generator; the coroutine can only
    use the `co_yield` statement to return values. It is not possible to use the `co_await`
    operator within the coroutine. A different kind of generator would be required
    for that, and such a generator is not currently available.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of using the `std::generator` type to produce a sequence of
    values is the following, which generates the series of Fibonacci numbers. This
    is the same example that we saw in the previous recipe. The only change is that
    we replaced `generator<int>` (which we wrote) with `std::generator<int>`, which
    is available in the C++23 standard:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: See also
  id: totrans-663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Iterating over collections with the ranges library*, to learn about the fundamentals
    of the C++ ranges library'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a coroutine task type for asynchronous computations*, for an introduction
    to the C++20 coroutines'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a coroutine generator type for sequences of values*, to learn how
    to enable the use of `co_yield` to return multiple values from a coroutine'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_12.xhtml)'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
