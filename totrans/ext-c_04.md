# 第四章

# 进程内存结构

在本章中，我们将讨论进程内部的内存及其结构。对于 C 程序员来说，内存管理始终是一个关键话题，而应用最佳实践需要关于内存结构的基本知识。实际上，这不仅仅局限于 C。在许多编程语言（如 C++或 Java）中，你需要对内存及其工作方式有一个基本理解；否则，你可能会遇到一些严重的问题，这些问题难以追踪和修复。

你可能知道，在 C 语言中内存管理是完全手动的，而且不仅如此，程序员是唯一负责分配内存区域并在不再需要时释放它们的责任人。

在高级编程语言（如 Java 或 C#）中，内存管理是不同的，它部分由程序员完成，部分由底层语言平台完成，例如在使用 Java 时，底层平台是**Java 虚拟机**（**JVM**）。在这些语言中，程序员只负责发出内存分配的指令，但他们对释放操作不负责。一个称为*垃圾回收器*的组件负责释放和自动释放分配的内存。

由于 C 和 C++中没有这样的垃圾回收器，因此为内存管理相关的概念和问题设置一些专门的章节是必不可少的。这就是为什么我们专门用这一章和下一章来介绍与内存相关的概念，这两章合起来应该能给你一个关于 C/C++中内存如何工作的基本理解。

在本章中：

+   我们首先查看进程的典型内存结构。这将帮助我们了解进程的解剖结构和它与内存的交互方式。

+   我们讨论了静态和动态内存布局。

+   我们介绍了上述内存布局中发现的段。我们发现其中一些位于可执行对象文件中，其余的则在进程加载时创建。

+   我们介绍了可以帮助我们检测段及其内容的探测工具和命令，这些段既可以在对象文件内部，也可以在运行进程的深处看到。

作为本章的一部分，我们将了解两个称为*栈*和*堆*的部分。它们是进程动态内存布局的一部分，所有的分配和释放操作都发生在这两个部分中。在下一章中，我们将更详细地讨论栈和堆部分，因为实际上，它们是程序员与之交互最多的部分。

让我们从讨论*进程内存布局*开始这一章。这将让你对正在运行的进程的内存是如何分段的，以及每个部分用于什么有一个整体的概念。

# 进程内存布局

每次运行可执行文件时，操作系统都会创建一个新的进程。进程是一个活跃且正在运行的程序，它被加载到内存中，并具有一个唯一的**进程标识符**（**PID**）。操作系统是负责生成和加载新进程的唯一实体。

进程会一直运行，直到它正常退出，或者进程收到信号，如`SIGTERM`、`SIGINT`或`SIGKILL`，最终导致它退出。`SIGTERM`和`SIGINT`信号可以被忽略，但`SIGKILL`会立即且强制地终止进程。

**注意**：

上一个章节中提到的信号解释如下：

`SIGTERM`：这是终止信号。它允许进程进行清理。

`SIGINT`：这是中断信号，通常在按下`Ctrl` + `C`时发送给前台进程。

`SIGKILL`：这是终止信号，它会强制关闭进程，不允许它进行清理。

当创建进程时，操作系统首先做的事情之一是为进程分配一块专用的内存部分，然后应用预定义的内存布局。这种预定义的内存布局在不同的操作系统中大致相同，尤其是在类 Unix 操作系统中。

在本章中，我们将探讨这种内存布局的结构，并介绍一些重要且有用的术语。

普通进程的内存布局被划分为多个部分。每个部分被称为*段*。每个段是内存的一个区域，它具有特定的任务，并存储特定类型的数据。您可以看到以下列表中的段是运行进程内存布局的一部分：

+   未初始化的数据段或**块起始符号**（**BSS**）段

+   数据段

+   文本段或代码段

+   栈段

+   堆段

在接下来的章节中，我们将分别研究这些段，并讨论它们如何有助于程序的执行。在下一章中，我们将重点关注栈和堆段，并对其进行详细讨论。作为我们探索的一部分，让我们介绍一些帮助我们检查内存的工具，然后再深入研究上述段的具体细节。

# 发现内存结构

类 Unix 操作系统提供了一套工具来检查进程的内存段。在本节中，您将了解到其中一些段位于可执行目标文件中，而其他段是在进程生成时动态创建的。

如您从前两个章节中应该已经了解到的，可执行目标文件和进程不是同一件事，因此预期会有不同的工具来检查它们中的每一个。

从前面的章节中，我们知道可执行目标文件包含机器指令，并且是由编译器生成的。但进程是由执行可执行目标文件而生成的正在运行的程序，它消耗主内存的一部分，而 CPU 则不断获取并执行其指令。

进程是一个在操作系统内部执行的生命实体，而可执行目标文件只是一个包含预先制作初始布局的文件，该布局作为未来进程生成的依据。确实，在运行进程的内存布局中，一些段直接来自基本可执行目标文件，其余的则在进程加载时动态构建。前者布局称为**静态内存布局**，后者称为**动态内存布局**。

静态和动态内存布局都有一组预定义的段。静态内存布局的内容是由编译器在编译源代码时预先写入可执行目标文件的。另一方面，动态内存布局的内容是由分配变量和数组内存的进程指令写入的，并根据程序的逻辑对其进行修改。

就这样，我们可以通过仅查看源代码或编译后的目标文件来猜测静态内存布局的内容。但关于动态内存布局，这并不容易，因为它不能在没有运行程序的情况下确定。此外，同一可执行文件的多次运行可能导致动态内存布局中的内容不同。换句话说，进程的动态内容对该进程是唯一的，并且应该在进程仍在运行时进行调查。

让我们从检查进程的静态内存布局开始。

# 探测静态内存布局

用于检查静态内存布局的工具通常作用于目标文件。为了获得一些初步的见解，我们将从一个例子开始，即*示例 4.1*，这是一个没有包含任何变量或逻辑的最小 C 程序：

```cpp
int main(int argc, char** argv) {
  return 0;
}
```

Code Box 4-1 [ExtremeC_examples_chapter4_1.c]：一个最小的 C 程序

首先，我们需要编译前面的程序。我们使用 `gcc` 在 Linux 中编译它：

```cpp
$ gcc ExtremeC_examples_chapter4_1.c -o ex4_1-linux.out
$
```

Shell Box 4-1：在 Linux 中使用 gcc 编译 example 4.1

在成功编译并链接最终的可执行二进制文件后，我们得到一个名为 `ex4_1-linux.out` 的可执行目标文件。该文件包含一个特定于 Linux 操作系统的预定义静态内存布局，并且它将存在于基于此可执行文件启动的所有未来进程中。

`size` 命令是我们首先想要介绍的工具。它可以用来打印可执行目标文件的静态内存布局。

您可以通过以下方式查看 `size` 命令的用法，以查看作为静态内存布局一部分找到的各种段：

```cpp
$ size ex4_1-linux.out
   text    data     bss     dec     hex   filename
   1099     544       8    1651     673   ex4_1-linux.out
$
```

Shell Box 4-2：使用 size 命令查看 ex4_1-linux.out 的静态段

如你所见，静态布局中包含文本、数据和 BSS 段。显示的大小以字节为单位。

现在，让我们在不同的操作系统上编译相同的代码，*示例 4.1*。我们选择了 macOS，并将使用`clang`编译器：

```cpp
$ clang ExtremeC_examples_chapter4_1.c -o ex4_1-macos.out
$
```

Shell Box 4-3：在 macOS 中使用 clang 编译示例 4.1

由于 macOS 与 Linux 一样，是一个符合 POSIX 标准的操作系统，并且`size`命令被指定为 POSIX 实用程序的一部分，因此 macOS 也应该有`size`命令。因此，我们可以使用相同的命令来查看`ex4_1-macos.out`的静态内存段：

```cpp
$ size ex4_1-macos.out
__TEXT __DATA  __OBJC  others       dec         hex
4096   0       0       4294971392   4294975488  100002000
$ size -m ex4_1-macos.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 4096
    Section __text: 22
    Section __unwind_info: 72
    total 94
Segment __LINKEDIT: 4096
total 4294975488
$
```

Shell Box 4-4：使用 size 命令查看 ex4_1-macos.out 的静态段

在前面的 shell 框中，我们运行了`size`命令两次；第二次运行提供了关于找到的内存段的更多详细信息。你可能已经注意到，macOS 中与 Linux 一样，有文本和数据段，但没有 BSS 段。请注意，BSS 段在 macOS 中也是存在的，但在`size`输出中并未显示。由于 BSS 段包含未初始化的全局变量，不需要在对象文件中分配一些字节，知道存储这些全局变量所需的字节数就足够了。

在前面的 shell 框中，有一个需要注意的有趣点。在 Linux 中，文本段的大小为 1,099 字节，而在 macOS 中为 4 KB。还可以看到，对于最小化的 C 程序，Linux 中的数据段具有非零大小，但在 macOS 中为空。很明显，不同平台上的低级内存细节是不同的。

尽管 Linux 和 macOS 之间存在这些小小的差异，但我们可以看到，这两个平台都将文本、数据和 BSS 段作为它们静态布局的一部分。从现在开始，我们将逐步解释每个段的使用目的。在接下来的章节中，我们将分别讨论每个段，并为每个段提供一个与*示例 4.1*略有不同的示例，以便看到每个段如何对代码中的微小变化做出不同的反应。

## BSS 段

我们从 BSS 段开始。**BSS**代表**Block Started by Symbol**。从历史上看，这个名字被用来表示为未初始化的字保留的区域。基本上，这就是我们使用 BSS 段的目的；要么是未初始化的全局变量，要么是设置为 0 的全局变量。

让我们通过添加一些未初始化的全局变量来扩展*示例 4.1*。你会看到未初始化的全局变量将贡献到 BSS 段。以下代码框展示了*示例 4.2*：

```cpp
int global_var1;
int global_var2;
int global_var3 = 0;
int main(int argc, char** argv) {
  return 0;
}
```

代码框 4-2 [ExtremeC_examples_chapter4_2.c]：一个包含一些全局变量（未初始化或设置为 0）的最小化 C 程序

整数 `global_var1`、`global_var2` 和 `global_var3` 是未初始化的全局变量。为了观察与 *example 4.1* 相比，Linux 中生成的可执行目标文件中做出的更改，我们再次运行 `size` 命令：

```cpp
$ gcc ExtremeC_examples_chapter4_2.c -o ex4_2-linux.out
$ size ex4_2-linux.out
   text    data     bss     dec     hex   filename
   1099     544      16    1659     67b   ex4_2-linux.out
$
```

Shell Box 4-5：使用 size 命令查看 ex4_2-linux.out 的静态段

如果你将前面的输出与 *example 4.1* 的类似输出进行比较，你会注意到 BSS 段的大小已更改。换句话说，声明未初始化或设置为零的全局变量将累加到 BSS 段。这些特殊的全局变量是静态布局的一部分，当进程加载时，它们被预分配，并且只有在进程存活时才不会被释放。换句话说，它们具有静态生命周期。

**注意**:

由于设计考虑，我们通常更喜欢在我们的算法中使用局部变量。全局变量过多会增加二进制文件的大小。此外，在全局作用域中保留敏感数据可能会引入安全风险。并发问题，特别是数据竞争、命名空间污染、未知所有权以及在全局作用域中变量过多，是全球变量引入的一些复杂问题。

让我们在 macOS 中编译 *example 4.2* 并查看 `size` 命令的输出：

```cpp
$ clang ExtremeC_examples_chapter4_2.c -o ex4_2-macos.out
$ size ex4_2-macos.out 
__TEXT __DATA  __OBJC  others       dec         hex
4096   4096       0    4294971392   4294979584  100003000
$ size -m ex4_2-macos.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 4096
    Section __text: 22
    Section __unwind_info: 72
    total 94
Segment __DATA: 4096
    Section __common: 12
    total 12
Segment __LINKEDIT: 4096
total 4294979584
$
```

Shell Box 4-6：使用 size 命令查看 ex4_2-macos.out 的静态段

再次强调，这与 Linux 不同。在 Linux 中，我们没有全局变量时，为 BSS 段预分配了 8 个字节。在 *example 4.2* 中，我们添加了三个新的未初始化的全局变量，其大小总和为 12 个字节，Linux C 编译器将 BSS 段扩展了 8 个字节。但在 macOS 中，我们仍然没有 BSS 段作为 `size` 输出的一部分，但编译器已将 `data` 段从 0 字节扩展到 4KB，这是 macOS 中的默认页面大小。这意味着 `clang` 在布局内部为 `data` 段分配了一个新的内存页。再次强调，这仅仅显示了不同平台在内存布局细节上的差异有多大。

**注意**:

在分配内存时，程序需要分配多少字节并不重要。*分配器*总是以 *内存页* 为单位获取内存，直到总分配大小覆盖程序的需求。有关 Linux 内存分配器的更多信息，请参阅此处：[`www.kernel.org/doc/gorman/html/understand/understand009.html`](https://www.kernel.org/doc/gorman/html/understand/understand009.html)。

在 *Shell 框 4-6* 中，我们在 `_DATA` 段内部有一个名为 `__common` 的部分，它占 12 字节，实际上它指的是未在 `size` 输出中显示的 BSS 段。它指的是 3 个未初始化的全局整数变量或 12 字节（每个整数是 4 字节）。值得注意的是，未初始化的全局变量默认设置为 *零*。对于未初始化变量，没有其他可以想象出的值。

现在我们来谈谈静态内存布局中的下一个段；数据段。

## 数据段

为了显示存储在数据段中的变量类型，我们将声明更多的全局变量，但这次我们用非零值初始化它们。以下示例，*示例 4.3*，扩展了 *示例 4.2* 并添加了两个新的初始化全局变量：

```cpp
int global_var1;
int global_var2;
int global_var3 = 0;
double global_var4 = 4.5;
char global_var5 = 'A';
int main(int argc, char** argv) {
  return 0;
}
```

代码框 4-3 [ExtremeC_examples_chapter4_3.c]：一个包含已初始化和未初始化全局变量的最小 C 程序

以下 shell 框显示 Linux 中 `size` 命令的输出，以及 *示例 4.3*：

```cpp
$ gcc ExtremeC_examples_chapter4_3.c -o ex4_3-linux.out
$ size ex4_3-linux.out
   text    data     bss     dec     hex filename
   1099     553      20    1672     688 ex4_3-linux.out
$
```

Shell 框 4-7：使用 size 命令查看 ex4_3-linux.out 的静态段

我们知道数据段用于存储设置为非零值的初始化全局变量。如果你比较 *示例 4.2* 和 *4.3* 的 `size` 命令输出，你可以很容易地看到数据段增加了 9 字节，这是两个新添加的全局变量尺寸之和（一个 8 字节的 `double` 和一个 1 字节的 `char`）。

让我们看看 macOS 中的变化：

```cpp
$ clang ExtremeC_examples_chapter4_3.c -o ex4_3-macos.out
$ size ex4_3-macos.out 
__TEXT __DATA  __OBJC  others       dec         hex
4096   4096       0    4294971392   4294979584  100003000
$ size -m ex4_3-macos.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 4096
    Section __text: 22
    Section __unwind_info: 72
    total 94
Segment __DATA: 4096
    Section __data: 9
    Section __common: 12
    total 21
Segment __LINKEDIT: 4096
total 4294979584
$
```

Shell 框 4-8：使用 size 命令查看 ex4_3-macos.out 的静态段

在第一次运行中，我们没有看到任何变化，因为所有全局变量的总和仍然远低于 4KB。但在第二次运行中，我们看到 `_DATA` 段的一部分出现了一个新的部分；`__data` 部分。为这个部分分配的内存是 9 字节，这与新引入的初始化全局变量的尺寸相符合。而且，我们仍然有 12 字节用于未初始化的全局变量，就像在 *示例 4.2* 和 macOS 中一样。

进一步来说，`size` 命令只显示段的尺寸，但不显示其内容。有其他特定于每个操作系统的命令可以用来检查在对象文件中找到的段的内容。例如，在 Linux 中，你有 `readelf` 和 `objdump` 命令来查看 *ELF* 文件的内容。这些工具也可以用来探测对象文件内部的静态内存布局。作为前两章的一部分，我们探索了一些这些命令。

除了全局变量之外，我们还可以在函数内部声明一些静态变量。这些变量在多次调用同一函数时保留其值。这些变量可以存储在数据段或 BSS 段中，具体取决于平台以及它们是否已初始化。以下代码框演示了如何在函数内部声明一些静态变量：

```cpp
void func() {
  static int i;
  static int j = 1;
  ...
}
```

Code Box 4-4：两个静态变量的声明，一个已初始化，另一个未初始化

如你在*Code Box 4-4*中看到的，`i`和`j`变量是静态的。`i`变量未初始化，而`j`变量初始化为值`1`。无论你进入和离开`func`函数多少次，这些变量都保持它们最新的值。

为了更详细地说明这是如何完成的，在运行时，`func`函数可以访问位于 Data 段或 BSS 段中的这些变量，这些段具有静态生命周期。这就是为什么这些变量被称为*静态*的原因。我们知道`j`变量位于 Data 段，仅仅因为它有一个初始值，而`i`变量应该位于 BSS 段，因为它没有初始化。

现在，我们想介绍第二个命令来检查 BSS 段的内容。在 Linux 中，可以使用`objdump`命令打印出在目标文件中找到的内存段的内容。在 macOS 中对应的命令是`gobjdump`，需要首先安装。

作为*example 4.4*的一部分，我们试图检查生成的可执行目标文件，以找到写入 Data 段的某些全局变量的数据。以下代码框显示了*example 4.4*的代码：

```cpp
int     x = 33;            // 0x00000021
int     y = 0x12153467;
char z[6] = "ABCDE";
int main(int argc, char**argv) {
  return 0;
}
```

Code Box 4-5 [ExtremeC_examples_chapter4_4.c]：一些应该写入 Data 段的已初始化全局变量

前面的代码很容易理解。它只是声明了三个具有一些初始值的全局变量。在编译后，我们需要转储 Data 段的内容，以便找到写入的值。

以下命令将演示如何编译和使用`objdump`来查看 Data 段的内容：

```cpp
$ gcc ExtremeC_examples_chapter4_4.c -o ex4_4.out
$ objdump -s -j .data ex4_4.out
a.out:     file format elf64-x86-64
Contents of section .data:
 601020 00000000 00000000 00000000 00000000  ...............
 601030 21000000 67341512 41424344 4500      !....4..ABCDE.
$
```

Shell Box 4-9：使用`objdump`命令查看 Data 段的内容

让我们来解释一下前面的输出应该如何读取，尤其是关于`.data`部分的说明。最左侧的列是地址列。接下来的四列是内容列，每列显示`4`个字节数据。因此，在每一行中，我们都有 16 个字节的内容。最右侧的列显示了中间列中相同字节 ASCII 表示。点字符表示该字符无法使用字母数字字符显示。请注意，选项`-s`告诉`objdump`显示所选部分的全部内容，而选项`-j .data`告诉它显示`.data`部分的内容。

第一行是 16 个字节填充为零。这里没有存储变量，所以对我们来说没有什么特殊之处。第二行显示了从地址`0x601030`开始的 Data 段的内容。前 4 个字节是`example 4.4`中找到的`x`变量的值。接下来的 4 个字节也包含了`y`变量的值。最后的 6 个字节是`z`数组中的字符。`z`的内容在最后一列中可以清楚地看到。

如果你足够关注 *Shell Box 4-9* 中显示的内容，你会看到，尽管我们以十进制基数写作 33，作为 `0x00000021` 的十六进制基数，它在段中的存储方式不同。它被存储为 `0x21000000`。`y` 变量的内容也是如此。我们将其写作 `0x12153467`，但它以不同的方式存储为 `0x67341512`。这似乎是字节顺序被反转了。

解释的效果是由于**字节序**的概念。通常，我们有两种不同的字节序类型，**大端序**和**小端序**。值 `0x12153467` 是数字 `0x12153467` 的大端序表示，因为最大的字节 `0x12` 是第一个。但值 `0x67341512` 是数字 `0x12153467` 的小端序表示，因为最小的字节 `0x67` 是第一个。

无论字节序如何，我们总是在 C 中读取正确的值。字节序是 CPU 的属性，不同的 CPU 可能会在最终的目标文件中得到不同的字节序。这也是为什么你不能在不同的字节序硬件上运行可执行目标文件的原因之一。

在 macOS 机器上看到相同的输出将很有趣。以下 shell 框演示了如何使用 `gobjdump` 命令来查看数据段的内容：

```cpp
$ gcc ExtremeC_examples_chapter4_4.c -o ex4_4.out
$ gobjdump -s -j .data ex4_4.out
a.out:     file format mach-o-x86-64
Contents of section .data:
 100001000 21000000 67341512 41424344 4500      !...g4..ABCDE.
$
```

Shell Box 4-10：使用 macOS 中的 gobjdump 命令查看数据段的内容

应该像在 *Shell Code 4-9* 中找到的 Linux 输出一样精确地读取。正如你所见，在 macOS 中，数据段中没有 16 字节的零头。内容字节序也表明，二进制文件是为小端序处理器编译的。

在本节的最后，其他工具如 Linux 中的 `readelf` 和 macOS 中的 `dwarfdump` 可以用来检查目标文件的内容。目标文件的二进制内容也可以使用 `hexdump` 等工具读取。

在下一节中，我们将讨论文本段以及如何使用 `objdump` 检查它。

## 文本段

如我们从 *第二章*，*编译和链接* 中所知，链接器将生成的机器级指令写入最终的执行目标文件。由于文本段，或代码段，包含程序的所有机器级指令，它应该位于执行目标文件中，作为其静态内存布局的一部分。这些指令由处理器检索并在进程运行时执行。

要深入了解，让我们看看一个真实可执行目标文件的文本段。为此，我们提出一个新的例子。下面的代码框展示了 *示例 4.5*，正如你所见，它只是一个空的 `main` 函数：

```cpp
int main(int argc, char** argv) {
  return 0;
}
```

代码框 4-6 [ExtremeC_examples_chapter4_5.c]：一个最小的 C 程序

我们可以使用 `objdump` 命令转储生成的执行对象文件的各个部分。请注意，`objdump` 命令仅在 Linux 中可用，而其他操作系统有自己的命令集来完成相同的工作。

以下 Shell Box 展示了使用 `objdump` 命令提取由 *示例 4.5* 生成的可执行对象文件中存在的各个节的内容。请注意，输出被缩短了，只显示了 `main` 函数对应的节及其汇编指令：

```cpp
$ gcc ExtremeC_examples_chapter4_5.c -o ex4_5.out
$ objdump -S ex4_5.out
ex4_5.out:     file format elf64-x86-64
Disassembly of section .init:
0000000000400390 <_init>:
... truncated.
.
.
Disassembly of section .plt:
00000000004003b0 <__libc_start_main@plt-0x10>:
... truncated
00000000004004d6 <main>:
  4004d6:   55                      push   %rbp
  4004d7:   48 89 e5                mov    %rsp,%rbp
  4004da:   b8 00 00 00 00          mov    $0x0,%eax
  4004df:   5d                      pop    %rbp
  4004e0:   c3                      retq
  4004e1:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  4004e8:   00 00 00
  4004eb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
00000000004004f0 <__libc_csu_init>:
... truncated
.
.
.
0000000000400564 <_fini>:
... truncated
$
```

Shell Box 4-11：使用 objdump 显示与主函数对应的节的内容

如你在先前的 Shell Box 中所见，存在各种包含机器级指令的节：`.text`、`.init` 和 `.plt` 节以及其他一些节，所有这些节共同允许程序被加载并运行。所有这些节都是静态内存布局中可执行对象文件内的同一个文本段的一部分。

我们为 *示例 4.5* 编写的 C 程序只有一个函数，即 `main` 函数，但正如你所见，最终的执行对象文件中还有一打其他的函数。

先前的输出，作为 *Shell Box 4-11* 的一部分，显示 `main` 函数不是 C 程序中首先被调用的函数，并且在 `main` 之前和之后还有逻辑应该被执行。正如 *第二章* 中所解释的，在 Linux 中，这些函数通常是从 `glibc` 库中借用的，并且由链接器组合在一起形成最终的执行对象文件。

在下一节中，我们将开始探测进程的动态内存布局。

# 探测动态内存布局

动态内存布局实际上是进程的运行时内存，只要进程在运行，它就存在。当你执行一个可执行对象文件时，一个名为 *loader* 的程序负责执行。它启动一个新的进程，并创建初始的内存布局，这个布局应该是动态的。为了形成这个布局，静态布局中找到的段将从可执行对象文件中复制过来。不仅如此，还会添加两个新的段。只有这样，进程才能继续并运行。

简而言之，我们期望在运行进程的内存布局中有五个段。其中三个段直接从可执行对象文件中找到的静态布局复制而来。新增的两个段被称为栈段和堆段。这些段是动态的，并且只有在进程运行时才存在。这意味着你无法在可执行对象文件中找到它们的任何痕迹。

在本节中，我们的最终目标是探测栈和堆段，并介绍操作系统中的工具和位置，这些工具和位置可以用于此目的。不时地，我们可能会将这些段称为进程的动态内存布局，而不考虑从对象文件中复制的其他三个段，但你应该始终记住，进程的动态内存由这五个段共同组成。

栈段是我们从其中分配变量的默认内存区域。在大小方面，它是一个有限的区域，你不能在其中存放大型对象。相比之下，堆段是一个更大且可调整的内存区域，可以用来存放大型对象和巨大的数组。与堆段一起工作需要自己的 API，我们将在我们的讨论中介绍。

记住，动态内存布局与*动态内存分配*不同。你不应该混淆这两个概念，因为它们指的是两件不同的事情！随着我们的进展，我们将了解更多关于不同类型的内存分配，特别是动态内存分配。

进程动态内存中的五个部分指的是主内存中已经*分配*、*专用*和*私有*给运行进程的部分。这些部分，除了文本段，它是字面意义上的静态和常量，在某种程度上是动态的，因为它们的内 容在运行时总是变化的。这是由于这些部分不断地被进程执行的算法修改。

检查进程的动态内存布局需要特定的程序。这意味着在能够探测其动态内存布局之前，我们需要有一个正在运行的过程。这要求我们编写一些长时间运行以保持其动态内存不变的例子。然后，我们可以使用我们的检查工具来研究它们的动态内存结构。

在下一节中，我们给出了如何探测动态内存结构的示例。

## 内存映射

让我们从简单的例子开始。*示例 4.6* 将会运行一个不确定的时间长度。这样，我们就有了一个永远不会结束的过程，同时，我们可以在检查过程中探测其内存结构。当然，我们可以在检查完成后随时*终止*它。你可以在下面的代码框中找到这个例子：

```cpp
#include <unistd.h> // Needed for sleep function
int main(int argc, char** argv) {
  // Infinite loop
  while (1) {
    sleep(1); // Sleep 1 second
  };
  return 0;
}
```

代码框 4-6 [ExtremeC_examples_chapter4_6.c]：用于探测动态内存布局的示例 4.6

如你所见，代码只是一个无限循环，这意味着进程将永远运行。因此，我们有足够的时间检查进程的内存。让我们首先构建它。

**注意**：

`unistd.h` 头文件仅在类 Unix 操作系统上可用；更准确地说，在符合 POSIX 标准的操作系统中。这意味着在不符合 POSIX 标准的 Microsoft Windows 上，你必须包含 `windows.h` 头文件。

下面的 shell 框展示了如何在 Linux 中编译这个例子：

```cpp
$ gcc ExtremeC_examples_chapter4_6.c -o ex4_6.out
$
```

Shell Box 4-12：在 Linux 中编译示例 4.6

然后，我们按照以下方式运行它。为了在进程运行期间使用相同的提示符来发出进一步的命令，我们应该在后台启动进程：

```cpp
$ ./ ex4_6.out &
[1] 402
$
```

Shell Box 4-13：在后台运行示例 4.6

进程现在正在后台运行。根据输出，最近启动的进程的 PID 是 402，我们将使用这个 PID 在将来将其终止。每次运行程序时，PID 都会不同；因此，您可能在您的计算机上看到不同的 PID。请注意，每次您在后台运行进程时，shell 提示符都会立即返回，您可以发出进一步的命令。

**注意**：

如果您有一个进程的 PID（进程 ID），您可以使用 `kill` 命令轻松地结束它。例如，如果 PID 是 402，以下命令将在类 Unix 操作系统中生效：`kill -9 402`。

PID 是我们用来检查进程内存的标识符。通常，操作系统会提供自己的特定机制，根据 PID 查询进程的各种属性。但在这里，我们只对进程的动态内存感兴趣，我们将使用 Linux 中可用的机制来了解更多关于上述运行进程的动态内存结构。

在 Linux 机器上，进程的信息可以在 `/proc` 目录下的文件中找到。它使用一个称为 *procfs* 的特殊文件系统。这个文件系统不是一个普通的文件系统，用于保存实际的文件，而更像是一个查询单个进程或整个系统各种属性的分层接口。

**注意**：

procfs 不仅限于 Linux。它通常是类 Unix 操作系统的一部分，但并非所有类 Unix 操作系统都使用它。例如，FreeBSD 使用这个文件系统，但 macOS 不使用。

现在，我们将使用 procfs 来查看运行进程的内存结构。进程的内存由多个 *内存映射* 组成。每个内存映射代表一个专用的内存区域，该区域作为进程的一部分映射到特定的文件或段。简而言之，您将看到栈（Stack）和堆（Heap）段在每个进程中都有自己的内存映射。

您可以使用 procfs 做的事情之一是观察进程当前的内存映射。接下来，我们将展示这一点。

我们知道进程正在以 PID 402 运行。使用 `ls` 命令，我们可以看到 `/proc/402` 目录的内容，如下所示：

```cpp
$ ls -l /proc/402
total of 0
dr-xr-xr-x  2 root root 0 Jul 15 22:28 attr
-rw-r--r--  1 root root 0 Jul 15 22:28 autogroup
-r--------  1 root root 0 Jul 15 22:28 auxv
-r--r--r--  1 root root 0 Jul 15 22:28 cgroup
--w-------  1 root root 0 Jul 15 22:28 clear_refs
-r--r--r--  1 root root 0 Jul 15 22:28 cmdline
-rw-r--r--  1 root root 0 Jul 15 22:28 comm
-rw-r--r--  1 root root 0 Jul 15 22:28 coredump_filter
-r--r--r--  1 root root 0 Jul 15 22:28 cpuset
lrwxrwxrwx  1 root root 0 Jul 15 22:28 cwd -> /root/codes
-r--------  1 root root 0 Jul 15 22:28 environ
lrwxrwxrwx  1 root root 0 Jul 15 22:28 exe -> /root/codes/a.out
dr-x------  2 root root 0 Jul 15 22:28 fd
dr-x------  2 root root 0 Jul 15 22:28 fdinfo
-rw-r--r--  1 root root 0 Jul 15 22:28 gid_map
-r--------  1 root root 0 Jul 15 22:28 io
-r--r--r--  1 root root 0 Jul 15 22:28 limits
...
$
```

Shell Box 4-14：列出 /proc/402 的内容

如您所见，在 `/proc/402` 目录下有许多文件和目录。这些文件和目录中的每一个都对应于进程的特定属性。为了查询进程的内存映射，我们必须查看 PID 目录下 `maps` 文件的内容。我们使用 `cat` 命令来转储 `/proc/402/maps` 文件的内容。如下所示：

```cpp
$ cat /proc/402/maps
00400000-00401000 r-xp 00000000 08:01 790655              .../extreme_c/4.6/ex4_6.out
00600000-00601000 r--p 00000000 08:01 790655              .../extreme_c/4.6/ex4_6.out
00601000-00602000 rw-p 00001000 08:01 790655              .../extreme_c/4.6/ex4_6.out
7f4ee16cb000-7f4ee188a000 r-xp 00000000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so
7f4ee188a000-7f4ee1a8a000 ---p 001bf000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so
7f4ee1a8a000-7f4ee1a8e000 r--p 001bf000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so
7f4ee1a8e000-7f4ee1a90000 rw-p 001c3000 08:01 787362      /lib/x86_64-linux-gnu/libc-2.23.so
7f4ee1a90000-7f4ee1a94000 rw-p 00000000 00:00 0
7f4ee1a94000-7f4ee1aba000 r-xp 00000000 08:01 787342      /lib/x86_64-linux-gnu/ld-2.23.so
7f4ee1cab000-7f4ee1cae000 rw-p 00000000 00:00 0
7f4ee1cb7000-7f4ee1cb9000 rw-p 00000000 00:00 0
7f4ee1cb9000-7f4ee1cba000 r--p 00025000 08:01 787342      /lib/x86_64-linux-gnu/ld-2.23.so
7f4ee1cba000-7f4ee1cbb000 rw-p 00026000 08:01 787342      /lib/x86_64-linux-gnu/ld-2.23.so
7f4ee1cbb000-7f4ee1cbc000 rw-p 00000000 00:00 0
7ffe94296000-7ffe942b7000 rw-p 00000000 00:00 0           [stack]
7ffe943a0000-7ffe943a2000 r--p 00000000 00:00 0           [vvar]
7ffe943a2000-7ffe943a4000 r-xp 00000000 00:00 0           [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0   [vsyscall]
$
```

Shell Box 4-15：导出 /proc/402/maps 的内容

如你在 *Shell Box 4-15* 中所见，结果由多行组成。每一行代表一个内存映射，它指示一组内存地址（一个区域）被分配并映射到进程动态内存布局中的特定文件或段。每个映射由一个或多个空格分隔的字段组成。接下来，你可以从左到右找到这些字段的描述：

+   **地址范围**：这是映射范围的起始和结束地址。如果该区域映射到文件，则可以在它们前面找到文件路径。这是一种智能地映射在各个进程中加载的相同共享对象文件的方法。我们已经在 *第三章*，*对象文件* 中讨论了这一点。

+   **权限**：这表示内容是否可执行（`x`）、可读（`r`）或可修改（`w`）。该区域也可以由其他进程共享（`s`）或仅由拥有进程私有（`p`）。

+   **偏移量**：如果该区域映射到一个文件，这将是从文件开始的偏移量。如果该区域未映射到文件，则通常为 0。

+   **设备**：如果该区域映射到一个文件，这将是指示包含映射文件的设备号（形式为 m:n），表示包含映射文件的设备。例如，这将是指向包含共享对象文件的硬盘的设备号。

+   **inode**：如果该区域映射到一个文件，那么该文件应该位于一个文件系统上。然后，这个字段将是该文件系统中文件的 inode 号。*inode* 是在类似 *ext4* 这样的文件系统中的一个抽象概念，这些文件系统主要在类 Unix 操作系统中使用。每个 inode 可以代表文件和目录。每个 inode 都有一个用于访问其内容的数字。

+   **路径名或描述**：如果该区域映射到一个文件，这将是指向该文件的路径。否则，它将被留空，或者它将描述该区域的目的。例如，`[stack]` 表示该区域实际上是栈段。

`maps` 文件提供了有关进程动态内存布局的更多有用信息。我们需要一个新的例子来正确演示这一点。

## 栈段

首先，让我们更详细地谈谈栈段。栈是每个进程动态内存的一个关键部分，它几乎存在于所有架构中。你在描述为 `[stack]` 的内存映射中已经看到了它。

栈和堆段都具有动态内容，这些内容在进程运行过程中不断变化。查看这些段的动态内容并不容易，大多数时候你需要一个调试器，如 `gdb`，在进程运行时遍历内存字节并读取它们。

如前所述，栈段通常大小有限，不是一个存储大对象的好地方。如果栈段满了，由于函数调用机制严重依赖于栈段的功能，进程将无法进行任何进一步的函数调用。

如果一个进程的栈段满了，操作系统会终止该进程。"栈溢出"是一个著名的错误，当栈段满了时发生。我们将在未来的段落中讨论函数调用机制。

如前所述，栈段是默认的内存区域，变量是从这里分配的。假设你在函数内部声明了一个变量，如下所示：

```cpp
void func() {
  // The memory required for the following variable is
  // allocated from the stack segment.
  int a; 
  ... 
}
```

代码框 4-7：声明一个从栈段分配内存的局部变量

在前面的函数中，声明变量时，我们没有提到任何内容让编译器知道变量应该从哪个段分配。因此，编译器默认使用栈段。栈段是分配的第一个地方。

正如其名所示，它是一个*栈*。如果你声明一个局部变量，它就会分配在栈段顶部。当你离开声明局部变量的作用域时，编译器必须首先弹出局部变量，以便提升外部作用域中声明的局部变量。

**注意**：

栈在抽象形式上是一个**先进先出**（**FILO**）或**后进先出**（**LIFO**）的数据结构。无论实现细节如何，每个条目都是存储（推入）在栈顶的，并且将被后续条目覆盖。如果不先移除上面的条目，就无法弹出任何一个条目。

存储在栈段中的不仅仅是变量。每次你调用一个函数时，都会在栈段顶部放置一个新的条目，称为*栈帧*。否则，你无法返回调用函数或将结果返回给调用者。

拥有一个健康的堆栈机制对于拥有一个正常工作的程序至关重要。由于栈的大小有限，声明小变量在其中是一个好习惯。此外，不应让太多的栈帧填充栈，这是由于无限递归调用或过多的函数调用造成的。

从另一个角度来看，栈段是程序员用来存储数据和声明算法中使用的局部变量的区域，以及操作系统作为程序运行者用来存储执行程序所需的数据的区域。

在这个意义上，当你处理这个段时应该小心，因为误用它或损坏其数据可能会中断运行过程，甚至导致程序崩溃。堆段是仅由程序员管理的内存段。我们将在下一节中介绍堆段。

如果我们只使用我们介绍的工具来探测静态内存布局，那么从外部看到栈段的内容并不容易。这部分内存包含私有数据，可能很敏感。它也是进程私有的，其他进程无法读取或修改它。

因此，为了在栈内存中航行，必须将某个东西附加到进程上，并通过该进程的视角查看栈段。这可以通过使用 *调试器* 程序来完成。调试器附加到进程上，允许程序员控制目标进程并调查其内存内容。我们将在下一章中使用这项技术来检查栈内存。现在，我们将栈段留给讨论堆段。我们将在下一章回到栈。

## 堆段

以下示例，*示例 4.7*，展示了如何使用内存映射来找到为堆段分配的区域。它与 *示例 4.6* 非常相似，但在进入无限循环之前，它从堆段分配了一部分字节。

因此，就像我们对 *示例 4.6* 所做的那样，我们可以遍历运行进程的内存映射，看看哪个映射指向堆段。

以下代码框包含了 *示例 4.7* 的代码：

```cpp
#include <unistd.h> // Needed for sleep function
#include <stdlib.h> // Needed for malloc function
#include <stdio.h> // Needed for printf
int main(int argc, char** argv) {
  void* ptr = malloc(1024); // Allocate 1KB from heap
  printf("Address: %p\n", ptr);
  fflush(stdout); // To force the print
  // Infinite loop
  while (1) {
    sleep(1); // Sleep 1 second
  };
  return 0;
}
```

Code Box 4-8 [ExtremeC_examples_chapter4_7.c]：用于探测堆段的示例 4.7

在前面的代码中，我们使用了 `malloc` 函数。这是从堆段分配额外内存的主要方式。它接受应该分配的字节数，并返回一个通用指针。

作为提醒，通用指针（或空指针）包含一个内存地址，但它不能被 *解引用* 并直接使用。在使用之前，它应该被转换为特定的指针类型。

在 *示例 4.7* 中，我们在进入循环之前分配了 1024 字节（或 1KB）。程序还在开始循环之前打印了从 `malloc` 接收到的指针的地址。让我们编译这个示例并像对 *示例 4.7* 那样运行它：

```cpp
$ g++ ExtremeC_examples_chapter4_7.c -o ex4_7.out
$ ./ex4_7.out &
[1] 3451
Address: 0x19790010
$
```

Shell Box 4-16：编译和运行示例 4.7

现在，进程在后台运行，并且已经获得了 PID 3451。

让我们通过查看其 `maps` 文件来查看这个进程映射了哪些内存区域：

```cpp
$ cat /proc/3451/maps
00400000-00401000 r-xp 00000000 00:2f 176521             .../extreme_c/4.7/ex4_7.out
00600000-00601000 r--p 00000000 00:2f 176521             .../extreme_c/4.7/ex4_7.out
00601000-00602000 rw-p 00001000 00:2f 176521             .../extreme_c/4.7/ex4_7.out
01979000-0199a000 rw-p 00000000 00:00 0                  [heap]
7f7b32f12000-7f7b330d1000 r-xp 00000000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so
7f7b330d1000-7f7b332d1000 ---p 001bf000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so
7f7b332d1000-7f7b332d5000 r--p 001bf000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so
7f7b332d5000-7f7b332d7000 rw-p 001c3000 00:2f 30         /lib/x86_64-linux-gnu/libc-2.23.so
7f7b332d7000-7f7b332db000 rw-p 00000000 00:00 0 
7f7b332db000-7f7b33301000 r-xp 00000000 00:2f 27        /lib/x86_64-linux-gnu/ld-2.23.so
7f7b334f2000-7f7b334f5000 rw-p 00000000 00:00 0 
7f7b334fe000-7f7b33500000 rw-p 00000000 00:00 0 
7f7b33500000-7f7b33501000 r--p 00025000 00:2f 27         /lib/x86_64-linux-gnu/ld-2.23.so
7f7b33501000-7f7b33502000 rw-p 00026000 00:2f 27         /lib/x86_64-linux-gnu/ld-2.23.so
7f7b33502000-7f7b33503000 rw-p 00000000 00:00 0 
7ffdd63c2000-7ffdd63e3000 rw-p 00000000 00:00 0          [stack]
7ffdd63e7000-7ffdd63ea000 r--p 00000000 00:00 0          [vvar]
7ffdd63ea000-7ffdd63ec000 r-xp 00000000 00:00 0          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]
$
```

Shell Box 4-17：导出 /proc/3451/maps 的内容

如果你仔细查看 *Shell Box 4-17*，你会看到一个新映射被突出显示，并且它被描述为 `[heap]`。这个区域是由于使用了 `malloc` 函数而被添加的。如果你计算这个区域的大小，它是 `0x21000` 字节或 132 KB。这意味着为了在代码中只分配 1 KB，已经分配了一个大小为 132 KB 的区域。

这通常是为了防止未来再次使用 `malloc` 时进一步分配内存。这仅仅是因为从堆段分配内存并不便宜，并且它既有内存开销也有时间开销。

如果你回顾一下*代码框 4-8*中显示的代码，`ptr`指针所指向的地址也很有趣。堆的内存映射，如*Shell 框 4-17*所示，是从地址`0x01979000`到`0x0199a000`分配的，而存储在`ptr`中的地址是`0x19790010`，这显然在堆范围内，位于偏移量`16`字节的位置。

堆段可以增长到远大于 132 KB 的大小，甚至达到数十吉字节，通常它用于永久、全局和非常大的对象，如数组和位流。

正如之前指出的那样，在堆段内进行分配和释放需要程序调用 C 标准提供的特定函数。虽然你可以在栈段顶部有局部变量，并且可以直接使用它们与内存交互，但堆内存只能通过指针访问，这也是为什么了解指针并且能够使用它们对于每个 C 程序员来说至关重要。让我们来看一下*示例 4.8*，它展示了如何使用指针访问堆空间：

```cpp
#include <stdio.h>   // For printf function
#include <stdlib.h>  // For malloc and free function
void fill(char* ptr) {
  ptr[0] = 'H';
  ptr[1] = 'e';
  ptr[2] = 'l';
  ptr[3] = 'l';
  ptr[5] = 0;
}
int main(int argc, char** argv) {
  void* gptr = malloc(10 * sizeof(char));
  char* ptr = (char*)gptr;
  fill(ptr);
  printf("%s!\n", ptr);
  free(ptr);
  return 0;
}
```

代码框 4-9 [ExtremeC_examples_chapter4_8.c]: 使用指针与堆内存交互

前面的程序使用`malloc`函数从堆空间分配了 10 个字节。`malloc`函数接收应该分配的字节数，并返回一个指向分配内存块第一个字节的通用指针。

为了使用返回的指针，我们必须将其转换为适当的指针类型。由于我们打算使用分配的内存来存储一些字符，我们选择将其转换为`char`指针。转换是在调用`fill`函数之前完成的。

注意，局部指针变量`gptr`和`ptr`是从栈中分配的。这些指针需要内存来存储它们的值，而这部分内存来自栈段。但是它们所指向的地址位于堆段内部。这是处理堆内存时的主题。你有从栈段分配的局部指针，但实际上它们指向的是从堆段分配的区域。我们将在下一章中展示更多这样的例子。

注意，`fill`函数内部的`ptr`指针也是从栈中分配的，但它处于不同的作用域，并且与`main`函数中声明的`ptr`指针不同。

当涉及到堆内存时，程序（或者实际上是程序员）负责内存分配。当不再需要时，程序也负责释放内存。有一块分配的堆内存是不可*访问*的，这被认为是*内存泄漏*。这里的不可访问是指没有指针可以用来定位那个区域。

内存泄漏对程序是致命的，因为持续的内存泄漏最终会耗尽整个允许的内存空间，这可能导致进程死亡。这就是为什么程序在从`main`函数返回之前调用`free`函数的原因。对`free`函数的调用将释放所获得的堆内存块，程序不应再使用这些堆地址。

下一章将详细介绍栈和堆段。

# 摘要

本章的初始目标是提供一个在类 Unix 操作系统中进程内存结构的概述。由于本章涵盖了大量的内容，请花一分钟时间回顾我们所经历的内容，因为你现在应该能够舒适地理解我们所取得的成果：

+   我们描述了运行进程的动态内存结构以及可执行对象文件的静态内存结构。

+   我们观察到静态内存布局位于可执行对象文件内部，并被分割成称为段的各个部分。我们发现文本、数据和 BSS 段是静态内存布局的一部分。

+   我们看到文本段或代码段用于存储在从当前可执行对象文件中生成新进程时将要执行的机器级指令。

+   我们看到 BSS 段用于存储未初始化或设置为零的全局变量。

+   我们解释说数据段用于存储初始化的全局变量。

+   我们使用了`size`和`objdump`命令来探测对象文件的内部结构。我们还可以使用对象文件转储工具，如`readelf`，以在对象文件中找到这些段。

+   我们探测了进程的动态内存布局。我们看到所有段都是从静态内存布局复制到进程的动态内存中的。然而，在动态内存布局中有两个新的段；栈段和堆段。

+   我们解释说栈段是默认的内存区域，用于分配。

+   我们了解到局部变量始终分配在栈区域顶部。

+   我们还观察到函数调用的秘密在于栈段及其工作方式。

+   我们看到，为了分配和释放堆内存区域，我们必须使用特定的 API 或一系列函数。这个 API 由 C 标准库提供。

+   我们讨论了内存泄漏及其在堆内存区域中可能发生的情况。

下一章将专门介绍栈和堆段。它将使用本章中涵盖的主题，并在此基础上添加更多内容。将给出更多示例，并介绍新的探测工具；这将完成我们对 C 中内存管理的讨论。
