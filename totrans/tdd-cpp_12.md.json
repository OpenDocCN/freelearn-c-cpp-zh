["```cpp\nTEST(\"Test string and string literal confirms\")\n{\n    std::string result = \"abc\";\n    CONFIRM(\"abc\", result);\n}\nTEST(\"Test float confirms\")\n{\n    float f1 = 0.1f;\n    float f2 = 0.2f;\n    float sum = f1 + f2;\n    float expected = 0.3f;\n    CONFIRM(expected, sum);\n}\n```", "```cpp\nTEST(\"Test can use hamcrest style confirm\")\n{\n    int ten = 10;\n    CONFIRM_THAT(ten, Equals(10));\n}\n```", "```cpp\ntemplate <typename T>\nvoid confirm (\n    T const & expected,\n    T const & actual,\n    int line)\n{\n    if (actual != expected)\n    {\n        throw ActualConfirmException(\n            std::to_string(expected),\n            std::to_string(actual),\n            line);\n    }\n}\n```", "```cpp\ninline void confirm (\n    std::string_view expected,\n    std::string_view actual,\n    int line)\n{\n    if (actual != expected)\n    {\n        throw ActualConfirmException(\n            expected,\n            actual,\n            line);\n    }\n}\ninline void confirm (\n    std::string const & expected,\n    std::string const & actual,\n    int line)\n{\n    confirm(\n        std::string_view(expected),\n        std::string_view(actual),\n        line);\n}\n```", "```cpp\ninline std::string to_string (std::string const & str)\n{\n    return str;\n}\ntemplate <typename ExpectedT, typename ActualT>\nvoid confirm (\n    ExpectedT const & expected,\n    ActualT const & actual,\n    int line)\n{\n    using std::to_string;\n    using MereTDD::to_string;\n    if (actual != expected)\n    {\n        throw ActualConfirmException(\n            to_string(expected),\n            to_string(actual),\n            line);\n    }\n}\n```", "```cpp\nTEST(\"Test string and string literal confirms\")\n{\n    std::string result = \"abc\";\n    CONFIRM(\"abc\", result);\n}\n```", "```cpp\nMereTDD project root folder\n    Test.h\n    tests folder\n        main.cpp\n        Confirm.cpp\n        Creation.cpp\n        Hamcrest.cpp\n        Setup.cpp\n```", "```cpp\n#include \"../Test.h\"\nTEST(\"Test can use hamcrest style confirm\")\n{\n    int ten = 10;\n    CONFIRM_THAT(ten, Equals(10));\n}\n```", "```cpp\n#define CONFIRM_FALSE( actual ) \\\n    MereTDD::confirm(false, actual, __LINE__)\n#define CONFIRM_TRUE( actual ) \\\n    MereTDD::confirm(true, actual, __LINE__)\n#define CONFIRM( expected, actual ) \\\n    MereTDD::confirm(expected, actual, __LINE__)\n#define CONFIRM_THAT( actual, matcher ) \\\n    MereTDD::confirm_that(actual, matcher, __LINE__)\n```", "```cpp\ntemplate <typename ExpectedT, typename ActualT>\nvoid confirm (\n    ExpectedT const & expected,\n    ActualT const & actual,\n    int line)\n{\n    using std::to_string;\n    using MereTDD::to_string;\n    if (actual != expected)\n    {\n        throw ActualConfirmException(\n            to_string(expected),\n            to_string(actual),\n            line);\n    }\n}\ntemplate <typename ActualT, typename MatcherT>\ninline void confirm_that (\n    ActualT const & actual,\n    MatcherT const & matcher,\n    int line)\n{\n    using std::to_string;\n    using MereTDD::to_string;\n    if (not matcher.pass(actual))\n    {\n        throw ActualConfirmException(\n            to_string(matcher),\n            to_string(actual),\n            line);\n    }\n}\n```", "```cpp\nclass Matcher\n{\npublic:\n    virtual ~Matcher () = default;\n    Matcher (Matcher const & other) = delete;\n    Matcher (Matcher && other) = delete;\n    virtual std::string to_string () const = 0;\n    Matcher & operator = (Matcher const & rhs) = delete;\n    Matcher & operator = (Matcher && rhs) = delete;\nprotected:\n    Matcher () = default;\n};\ninline std::string to_string (Matcher const & matcher)\n{\n    return matcher.to_string();\n}\n```", "```cpp\ntemplate <typename T>\nclass Equals : public Matcher\n{\npublic:\n    Equals (T const & expected)\n    : mExpected(expected)\n    { }\n    bool pass (T const & actual) const\n    {\n        return actual == mExpected;\n    }\n    std::string to_string () const override\n    {\n        using std::to_string;\n        using MereTDD::to_string;\n        return to_string(mExpected);\n    }\nprivate:\n    T mExpected;\n};\n```", "```cpp\n#include \"../Test.h\"\nusing namespace MereTDD;\nTEST(\"Test can use hamcrest style confirm\")\n{\n    int ten = 10;\n    CONFIRM_THAT(ten, Equals(10));\n}\n```", "```cpp\nTEST(\"Test hamcrest style confirm failure\")\n{\n    int ten = 10;\n    CONFIRM_THAT(ten, Equals(9));\n}\n```", "```cpp\nTEST(\"Test hamcrest style confirm failure\")\n{\n    std::string reason = \"    Expected: 9\\n\";\n    reason += \"    Actual  : 10\";\n    setExpectedFailureReason(reason);\n    int ten = 10;\n    CONFIRM_THAT(ten, Equals(9));\n}\n```", "```cpp\n------- Test: Test can use hamcrest style confirm\nPassed\n------- Test: Test hamcrest style confirm failure\nExpected failure\n    Expected: 9\n    Actual  : 10\n```", "```cpp\nTEST(\"Test other hamcrest style integer confirms\")\n{\n    char c1 = 'A';\n    char c2 = 'A';\n    CONFIRM_THAT(c1, Equals(c2));\n    CONFIRM_THAT(c1, Equals('A'));\n    short s1 = 10;\n    short s2 = 10;\n    CONFIRM_THAT(s1, Equals(s2));\n    CONFIRM_THAT(s1, Equals(10));\n    unsigned int ui1 = 3'000'000'000;\n    unsigned int ui2 = 3'000'000'000;\n    CONFIRM_THAT(ui1, Equals(ui2));\n    CONFIRM_THAT(ui1, Equals(3'000'000'000));\n    long long ll1 = 5'000'000'000'000LL;\n    long long ll2 = 5'000'000'000'000LL;\n    CONFIRM_THAT(ll1, Equals(ll2));\n    CONFIRM_THAT(ll1, Equals(5'000'000'000'000LL));\n}\n```", "```cpp\nTEST(\"Test hamcrest style bool confirms\")\n{\n    bool b1 = true;\n    bool b2 = true;\n    CONFIRM_THAT(b1, Equals(b2));\n    // This works but probably won't be used much.\n    CONFIRM_THAT(b1, Equals(true));\n    // When checking a bool variable for a known value,\n    // the classic style is probably better.\n    CONFIRM_TRUE(b1);\n}\n```", "```cpp\nTEST(\"Test hamcrest style string confirms\")\n{\n    std::string s1 = \"abc\";\n    std::string s2 = \"abc\";\n    CONFIRM_THAT(s1, Equals(s2));     // string vs. string\n    CONFIRM_THAT(s1, Equals(\"abc\"));  // string vs. literal\n    CONFIRM_THAT(\"abc\", Equals(s1));  // literal vs. string\n}\n```", "```cpp\nMereTDD/tests/../Test.h: In instantiation of 'MereTDD::Equals<T>::Equals(const T&) [with T = char [4]]':\nMereTDD/tests/Hamcrest.cpp:63:5:   required from here\nMereTDD/tests/../Test.h:209:7: error: array used as initializer\n  209 |     : mExpected(expected)\n      |       ^~~~~~~~~~~~~~~~~~~\n```", "```cpp\n    Equals (T const & expected)\n    : mExpected(expected)\n    { }\n```", "```cpp\n    CONFIRM_THAT(s1, Equals(\"abc\"));  // string vs. literal\n```", "```cpp\ntemplate <typename T, std::size_t N> requires (\n    std::is_same<char, std::remove_const_t<T>>::value)\nclass Equals<T[N]> : public Matcher\n{\npublic:\n    Equals (char const (& expected)[N])\n    {\n        memcpy(mExpected, expected, N);\n    }\n    bool pass (std::string const & actual) const\n    {\n        return actual == mExpected;\n    }\n    std::string to_string () const override\n    {\n        return std::string(mExpected);\n    }\nprivate:\n    char mExpected[N];\n};\n```", "```cpp\n#include <cstring>\n#include <map>\n#include <ostream>\n#include <string_view>\n#include <type_traits>\n#include <vector>\n```", "```cpp\nTEST(\"Test hamcrest style string confirms\")\n{\n    std::string s1 = \"abc\";\n    std::string s2 = \"abc\";\n    CONFIRM_THAT(s1, Equals(s2));       // string vs. string\n    CONFIRM_THAT(s1, Equals(\"abc\"));    // string vs. literal\n    CONFIRM_THAT(\"abc\", Equals(s1));    // literal vs. string\n    // Probably not needed, but this works too.\n    CONFIRM_THAT(\"abc\", Equals(\"abc\")); // literal vs. Literal\n}\n```", "```cpp\nTEST(\"Test hamcrest style string pointer confirms\")\n{\n    char const * sp1 = \"abc\";\n    std::string s1 = \"abc\";\n    char const * sp2 = s1.c_str();    // avoid sp1 and sp2 being same\n    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer\n    CONFIRM_THAT(sp2, Equals(\"abc\")); // pointer vs. literal\n    CONFIRM_THAT(\"abc\", Equals(sp2)); // literal vs. pointer\n    CONFIRM_THAT(sp1, Equals(s1));    // pointer vs. string\n    CONFIRM_THAT(s1, Equals(sp1));    // string vs. pointer\n}\n```", "```cpp\n------- Test: Test hamcrest style string pointer confirms\nFailed confirm on line 75\n    Expected: abc\n    Actual  : abc\n```", "```cpp\n    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer\n```", "```cpp\ntemplate <typename T> requires (\n    std::is_same<char, std::remove_const_t<T>>::value)\nclass Equals<T *> : public Matcher\n{\npublic:\n    Equals (char const * expected)\n    : mExpected(expected)\n    { }\n    bool pass (std::string const & actual) const\n    {\n        return actual == mExpected;\n    }\n    std::string to_string () const override\n    {\n        return mExpected;\n    }\nprivate:\n    std::string mExpected;\n};\n```"]