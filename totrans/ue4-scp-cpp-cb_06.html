<html><head></head><body>
        

                            
                    <h1 class="header-title">Input and Collision</h1>
                
            
            
                
<p>This chapter covers recipes surrounding game control input (keyboard, mouse, and gamepad), and collisions with obstacles.</p>
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character</li>
<li>Axis Mappings – normalized input</li>
<li>Action Mappings – one-button responses for an FPS character</li>
<li>Adding Axis and Action Mappings from C++</li>
<li>Mouse UI input handling</li>
<li>UMG keyboard UI shortcut keys</li>
<li>Collision – letting objects pass through one another using Ignore</li>
<li>Collision – picking up objects using Overlap</li>
<li>Collision – preventing interpenetration using Block</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Good input controls are extremely important in your game. Providing all of the keyboard, mouse, and especially gamepad input is going to make your game much more palatable to users.</p>
<div><img src="img/79860469-0fa4-4790-bc3c-53efc1f3c422.png" style="width:3.58em;height:1.58em;"/> You can use Xbox 360 and PlayStation controllers on your Windows PC – they have USB input. Check your local electronics shops for USB game controllers to find some good ones. You can also use a wireless controller with the proper receiver to connect to your PC.</div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character</h1>
                
            
            
                
<p>There are two types of input mapping: <strong>Axis mappings</strong> and <strong>Action mappings</strong>. Axis mappings are inputs that you hold down for an extended period of time to get their effect (for example, holding the <em>W</em> key to move the player forward), while Action mappings are one-off inputs (such as pressing the <em>A</em> button on the gamepad or spacebar on the keyboard to make the player jump). In this recipe, we'll cover how to set up keyboard, mouse, and gamepad axis-mapped input controls to move an FPS character.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You must have a UE4 project, which has a main character player in it and a ground plane to walk on, ready for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a C++ class and select <kbd>Character</kbd> as the parent class. Then, hit <kbd>Next</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9341ddb3-a54d-4733-905b-6a49fbfd43bb.png"/></p>
<ol start="2">
<li>Under the Name property, type in <kbd>Warrior</kbd>, and then click on Create Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d443a1e9-8f02-4ee1-9572-4c22c0457ccb.png"/></p>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 60px">We will dive into doing the implementation after we do some setup inside UE4.</p>
<ol start="3">
<li>Launch UE4 and right-click on the Warrior class. Then, select Create Blueprint class based on Warrior:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/80b8efda-da55-4d8c-a1d1-fa188e117e7f.png"/></p>
<ol start="4">
<li>From the menu that pops up, set the name to <kbd>BP_Warrior</kbd> and then select Create Blueprint Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5161b2d-dae5-400d-aec0-9620df861b22.png"/></p>
<ol start="5">
<li>Close the Blueprints menu that was just opened.</li>
<li>Create and select a new Blueprint for your <kbd>GameMode</kbd> class, by going to Settings | Project Settings | Maps &amp; Modes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5c90fe1-9f45-4ca6-b7ff-b5047325f24f.png"/></p>
<ol start="7">
<li>Click on the + icon beside the default GameMode drop-down menu, which will create a new Blueprint of the <kbd>GameMode</kbd> class. Put a name of your choice (say, <kbd>BP_GameMode</kbd>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ef3f7b68-b9a3-4c57-8ef3-41a4b818ae9e.png" style="width:27.75em;height:14.17em;"/></p>
<ol start="8">
<li>Double-click the new <kbd>BP_GameMode</kbd> Blueprint class that you created to edit it. It can be found in the <kbd>Contents\Blueprints</kbd> folder from the Content Browser.<br/>
<ol start="1"/>
</li>
<li>Once your <kbd>BP_GameMode</kbd> blueprint is opened, select your Blueprinted <kbd>BP_Warrior</kbd> class as the Default Pawn Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/264fec32-0e72-4195-8ea1-b732a7b731d8.png"/></p>
<p>The location of the Default Pawn Class property.</p>
<ol start="10">
<li>To set up the keyboard's input, which will drive the player, open Settings | Project Settings | Input. (Input can be found under the Engine subsection.) In the following steps, we will complete the process that drives the player forward in the game.</li>
<li>Click on the + icon beside the Axis Mappings heading:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f23a8d03-3707-4ca2-9380-432bdcb8ba78.png"/></p>
<p>Axis Mappings supports continuous (button-held) input, while Action Mappings supports one-off events.</p>
<ol start="12">
<li>Give a name to the Axis mapping. This first example will show how to move the player forward, so name it something like <kbd>Forward</kbd>.</li>
<li>Underneath Forward, select a keyboard key to assign to this Axis mapping, such as <em>W</em>.</li>
</ol>
<ol start="14">
<li>Click on the + icon beside Forward and select a game controller input to map so that you can move the player forward (such as Gamepad Left Thumbstick Up):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb847eef-39cf-4d97-8023-028dc25d6d52.png"/></p>
<ol start="15">
<li>Complete Axis Mappings for Back, Left, and Right with keyboard, gamepad, and, optionally, mouse input bindings for each:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/58185746-bbc4-45b6-8bc1-8f2241951473.png"/></p>
<ol start="16">
<li>Now, return to the <kbd>.h</kbd> file. We will need to add some new function definitions, which we will be writing:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Character.h"<br/>#include "Warrior.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_06_API AWarrior : public ACharacter<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    // Sets default values for this character's properties<br/>    AWarrior();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>    // Called to bind functionality to input<br/>    virtual void SetupPlayerInputComponent(class UInputComponent* <br/>                                        PlayerInputComponent) override;<br/><br/>    <strong>// Movement functions</strong><br/><strong>    void Forward(float amount);</strong><br/><strong>    void Back(float amount);</strong><br/><strong>    void Right(float amount);</strong><br/><strong>    void Left(float amount);</strong><br/><br/>};</pre>
<ol start="17">
<li>From your C++ code, override the <kbd>SetupPlayerInputComponent</kbd> function for the <kbd>AWarrior</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">#include "Components/InputComponent.h"<br/><br/>// ...<br/><br/>// Called to bind functionality to input<br/>void AWarrior::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)<br/>{<br/>    Super::SetupPlayerInputComponent(PlayerInputComponent);<br/><br/>    check(PlayerInputComponent);<br/>    PlayerInputComponent-&gt;BindAxis("Forward", this, <br/>                                   &amp;AWarrior::Forward);<br/>    PlayerInputComponent-&gt;BindAxis("Back", this, &amp;AWarrior::Back);<br/>    PlayerInputComponent-&gt;BindAxis("Right", this, &amp;AWarrior::Right);<br/>    PlayerInputComponent-&gt;BindAxis("Left", this, &amp;AWarrior::Left);<br/>}</pre>
<ol start="18">
<li>Provide a <kbd>Forward</kbd> function inside your <kbd>AWarrior</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">void AWarrior::Forward(float amount)<br/>{<br/>    // Moves the player forward by an amount in forward <br/>    // direction<br/>    AddMovementInput(GetActorForwardVector(), amount);<br/>}</pre>
<ol start="19">
<li>Write and complete functions for the rest of the input directions, that is, <kbd>AWarrior::Back</kbd>, <kbd>AWarrior::Left</kbd>, and <kbd>AWarrior::Right</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AWarrior::Back(float amount)<br/>{<br/>    AddMovementInput(-GetActorForwardVector(), amount);<br/>}<br/><br/>void AWarrior::Right(float amount)<br/>{<br/>    AddMovementInput(GetActorRightVector(), amount);<br/>}<br/><br/>void AWarrior::Left(float amount)<br/>{<br/>    AddMovementInput(-GetActorRightVector(), amount);<br/>}</pre>
<ol start="20">
<li>Return to Unreal and compile your code. Afterwards, play and game and confirm that you can now move with both the keyboard and the left thumbstick on your gamepad:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9ffd2ff0-6c1f-440a-8b80-6ba07b10605b.png" style="width:34.83em;height:16.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The UE4 Engine allows wire-up input events directly to C++ function calls. The functions that are called by an input event are member functions of some class. In the preceding example, we routed both the pressing of the <em>W</em> key and holding of the gamepad's Left Thumbstick Up to the <kbd>AWarrior::Forward</kbd> C++ function. The instance to call <kbd>AWarrior::Forward</kbd> on is the instance that routed the controller's input. That is controlled by the object set as the player's avatar in the <kbd>GameMode</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Instead of entering the input axis bindings in the UE4 editor, you can actually code it in from C++. We'll describe this in detail in a later recipe, <em>Adding Axis and Action Mappings from C++.</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Axis Mappings – normalized input</h1>
                
            
            
                
<p>As you may have noticed, inputs of 1.0 right and 1.0 forward will actually sum to a total of 2.0 units of speed. This means it is possible to move faster diagonally than it is to move in purely forward, backward, left, or right directions. What we really should do is clamp off any input value that results in speed in excess of 1.0 units while maintaining the direction of input indicated. We can do this by storing the previous input values and overriding the <kbd>::Tick()</kbd> function.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To work on this recipe, you must have completed the previous one with our <kbd>Warrior</kbd> class as we will be adding to it. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Go to your <kbd>Warrior.h</kbd> file and add the following property:</li>
</ol>
<pre style="padding-left: 60px">protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/><strong>    // The movement from the previous frame</strong><br/><strong>    FVector2D lastInput;</strong></pre>
<ol start="2">
<li>We will then need to initialize the variable inside of the class constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AWarrior::AWarrior()<br/>{<br/>    // Set this character to call Tick() every frame. You can turn  <br/>    // this off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    <strong>lastInput = FVector2D::ZeroVector;</strong><br/>}</pre>
<ol start="3">
<li>Update the <kbd>::Forward</kbd>, <kbd>::Back</kbd>, <kbd>::Right</kbd>, and <kbd>::Left</kbd> functions, as follows:</li>
</ol>
<pre style="padding-left: 60px">void AWarrior::Forward(float amount)<br/>{<br/>    // We use a += of the amount added so that when the other  <br/>    // function modifying .Y (::Back()) affects lastInput, it won't   <br/>    // overwrite with 0's <br/>    lastInput.Y += amount;<br/>}<br/><br/>void AWarrior::Back(float amount)<br/>{<br/>    // In this case we are using -= since we are moving backwards<br/>    lastInput.Y -= amount;<br/>}<br/><br/>void AWarrior::Right(float amount)<br/>{<br/>    lastInput.X += amount;<br/>}<br/><br/>void AWarrior::Left(float amount)<br/>{<br/>    lastInput.X -= amount;<br/>}</pre>
<ol start="4">
<li>In the <kbd>AWarrior::Tick()</kbd> function, modify the input values after normalizing any oversize in the input vector:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void AWarrior::Tick(float DeltaSeconds)<br/>{<br/>    Super::Tick(DeltaSeconds);<br/><br/>    <strong>float len = lastInput.Size();</strong><br/><br/><strong>    // If the player's input is greater than 1, normalize it</strong><br/><strong>    if (len &gt; 1.f)</strong><br/><strong>    {</strong><br/><strong>        lastInput /= len;</strong><br/><strong>    }</strong><br/><strong>            </strong><br/><strong>    AddMovementInput(GetActorForwardVector(), lastInput.Y);</strong><br/><strong>    AddMovementInput(GetActorRightVector(), lastInput.X);</strong><br/><br/><strong>    // Zero off last input values</strong><br/><strong>    lastInput = FVector2D(0.f, 0.f);</strong><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We normalize the input vector when it is over a magnitude of 1.0. This constricts the maximum input velocity to 1.0 units (rather than 2.0 units when full up and full right are pressed, for example).</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Action Mappings – one-button responses for an FPS character</h1>
                
            
            
                
<p>An Action mapping is for handling single-button pushes (not buttons that are held down). For buttons that should be held down, be sure to use an Axis mapping instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Have a UE4 project ready with the actions that you need to complete, such as <kbd>Jump</kbd> or <kbd>ShootGun</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Settings | Project Settings | Input.</li>
<li>Go to the Action Mappings heading and click on the + icon beside it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a65fdfd6-0f69-4512-8ba5-82d282b9e325.png"/></p>
<ol start="3">
<li>Start to type in the actions that should be mapped to button pushes. For example, type in <kbd>Jump</kbd> for the first Action.</li>
</ol>
<ol start="4">
<li>Click on the arrow to the left of the action to open up the menu and then select a key to press for that action to occur, for example, Space Bar.</li>
<li>If you would like the same action triggered by another key push, click on the + beside your Action Mappings name and select another key to trigger the Action.</li>
<li>If you want the Shift, Ctrl, Alt, or Cmd keys to be held down for the Action to occur, be sure to indicate that in the checkboxes to the right of the key selection box:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a79a026-ca19-4dc7-9c1c-8b274c320eff.png"/></p>
<ol start="7">
<li>To link your Action to a C++ code function, you need to override the <kbd>SetupPlayerInputComponent(UInputControl* control )</kbd> function. Enter the following code inside that function:</li>
</ol>
<pre style="padding-left: 60px">// Called to bind functionality to input<br/>void AWarrior::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)<br/>{<br/>    Super::SetupPlayerInputComponent(PlayerInputComponent);<br/><br/>    check(PlayerInputComponent);<br/>    PlayerInputComponent-&gt;BindAxis("Forward", this, <br/>                                                   &amp;AWarrior::Forward);<br/>    PlayerInputComponent-&gt;BindAxis("Back", this, &amp;AWarrior::Back);<br/>    PlayerInputComponent-&gt;BindAxis("Right", this, &amp;AWarrior::Right);<br/>    PlayerInputComponent-&gt;BindAxis("Left", this, &amp;AWarrior::Left);<br/><br/>    <strong>PlayerInputComponent-&gt;BindAction("Jump", IE_Pressed, this, <br/>                                                      &amp;AWarrior::Jump);</strong><br/>}</pre>
<ol start="8">
<li>Compile your script and play the game. Whenever you press the <em>spacebar</em>, you should see the player jump in the air! Refer to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2d487813-cd64-4250-a1cc-8bb083d862f8.png" style="width:42.42em;height:19.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><strong>Action Mappings</strong> are single-button-push events that fire off C++ code to run in response to them. You can define any number of actions that you wish in the UE4 Editor, but be sure to tie up Action Mappings to actual key pushes in C++.</p>
<p>You may notice that the <kbd>Jump</kbd> function we are calling, when we use our action, already exists when we added a reference to it. That is because the <kbd>Character</kbd> class already contains an implementation for it. Note that the default implementation doesn't feel like a usual jump – it's more of a rise and float action.</p>
<p>You can find more information on the <kbd>Character</kbd> class and the pre-built functions it has at <a href="https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html">https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html</a>.<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/ACharacter/index.html"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can list the Actions that you want mapped from C++ code. See the following recipe, <em>Adding Axis and Action Mappings from C++</em>, for this.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Axis and Action Mappings from C++</h1>
                
            
            
                
<p>Axis Mappings and Action Mappings can be added to your game via the UE4 Editor and is often how designers will do it, but we can also add them directly from C++ code. Since the connections to C++ functions is from C++ code anyway, you may find it more convenient to define your Axis and Action Mappings in C++ as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need a UE4 project that you'd like to add some Axis and Action mappings to. You can delete the existing Axis and Action mappings listed in Settings | Project Settings | Input if you are adding them via C++ code.</p>
<p>To add your custom Axis and Action Mappings, there are two C++ functions that you need to know about: <kbd>UPlayerInput::AddAxisMapping</kbd> and <kbd>UPlayerInput:: AddActionMapping</kbd>. These are member functions that are available on the <kbd>UPlayerInput</kbd> object. The <kbd>UPlayerInput</kbd> object is inside the <kbd>PlayerController</kbd> object, and is accessible via the following code:</p>
<pre>GetWorld()-&gt;GetFirstPlayerController()-&gt;PlayerInput </pre>
<p>You can also use the two static member functions of <kbd>UPlayerInput</kbd> to create your Axis and Action Mappings if you'd prefer not to access player controllers individually:</p>
<pre>UPlayerInput::AddEngineDefinedAxisMapping() 
UPlayerInput::AddEngineDefinedActionMapping() </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To begin, we need to define our <kbd>FInputAxisKeyMapping</kbd> or <kbd>FInputActionKeyMapping</kbd> objects, depending on whether you are hooking up an Axis key mapping (for buttons that are held down for input) or an Action key mapping (for one-off-event buttons that are pressed once for input).
<ol>
<li>To use either of the following classes, we will need to include the following <kbd>.h</kbd> file:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">#include "GameFramework/PlayerInput.h" </pre>
<ol>
<li style="list-style-type: none">
<ol start="2">
<li>For Axis key mappings, we define an <kbd>FInputAxisKeyMapping</kbd> object, as follows:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">FInputAxisKeyMapping backKey( "Back", EKeys::S, 1.f ); </pre>
<ol>
<li style="list-style-type: none">
<ol start="3">
<li>This will include the string name for the action, the key to press (use the EKeys <kbd>enum</kbd>), and whether or not <em>Shift</em>, <em>Ctrl</em>, <em>Alt</em>, or <em>cmd</em> (Mac) should be held to trigger the event.</li>
<li>For action key mappings, define <kbd>FInputActionKeyMapping</kbd>, as follows:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 90px">FInputActionKeyMapping jump("Jump", EKeys::SpaceBar, 0, 0, 0, 0); </pre>
<ol>
<li style="list-style-type: none">
<ol start="5">
<li>This will include the string name for the action, the key to press, and whether or not <em>Shift</em>, <em>Ctrl</em>, <em>Alt</em>, or <em>cmd</em> (Mac) should be held to trigger the event.</li>
</ol>
</li>
</ol>
<ol start="2">
<li>In your player <kbd>Pawn</kbd> class's <kbd>SetupPlayerInputComponent</kbd> function, register your Axis and Action key mappings to the following:</li>
</ol>
<ol>
<li style="list-style-type: none">
<ol>
<li>The <kbd>PlayerInput</kbd> object connected to a specific controller:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 60px">GetWorld()-&gt;GetFirstPlayerController()-&gt;PlayerInput<br/> -&gt;AddAxisMapping( backKey ); // specific to a controller</pre>
<ol>
<li style="list-style-type: none">
<ol start="2">
<li>Alternatively, you could register to the static member functions of the <kbd>UPlayerInput</kbd> object directly:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 60px">UPlayerInput::AddEngineDefinedActionMapping(jump );</pre>
<p>Ensure that you're using the correct function for Axis versus Action Mappings!</p>
<ol start="3">
<li>Register your Action and Axis Mappings to C++ functions using C++ code, just like we did in the preceding two recipes, for example:</li>
</ol>
<pre style="padding-left: 60px">PlayerInputComponent-&gt;BindAxis("Back", this, &amp;AWarrior::Back); 
PlayerInputComponent-&gt;BindAction("Jump", IE_Pressed, this, &amp;AWarrior::Jump <br/>           );</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Action and Axis Mapping registration functions allow you to set up your input mappings from C++ code directly. The C++ coded input mappings are essentially the same as entering the input mappings in the Settings | Project Settings | Input dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mouse UI input handling</h1>
                
            
            
                
<p>When using the <strong>Unreal Motion Graphics</strong> (<strong>UMG</strong>) toolkit, you will find that mouse events are very easy to handle. We can register C++ functions to run after mouse clicks or other types of interactions with the UMG components.</p>
<p>Usually, event registration will be via Blueprints; however, in this recipe, we will outline how to write and wire up C++ functions to UMG events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a UMG canvas in your UE4 project. From there, we'll register event handlers for the <kbd>OnClicked</kbd>, <kbd>OnPressed</kbd>, and <kbd>OnReleased</kbd> events.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Right-click in your Content Browser (or click on Add New) and select User Interface | Widget Blueprint, as shown in the following screenshot. This will add an editable widget blueprint to your project:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/451daeed-ffb0-4715-9eea-28085c8b1096.png"/></p>
<ol start="2">
<li>Double-click on your Widget Blueprint to edit it.</li>
<li>Add a button to the interface by dragging it from the palette on the left:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4bd1c07c-a8bd-493a-95f6-db057cb0b315.png"/></p>
<ol start="4">
<li>Scroll down the Details panel for your button until you find the Events subsection.</li>
<li>Click on the + icon beside any event that you'd like to handle:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b0d70320-f08a-4d4d-80e5-b026be6eeb6c.png"/></p>
<p class="mce-root"/>
<ol start="6">
<li>Connect the event that appears in Blueprints to any C++ <kbd>UFUNCTION()</kbd> that has the <kbd>BlueprintCallable</kbd> tag in the macro. For example, in your <kbd>GameModeBase</kbd> class derivative, you could include a function such as the following one:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_06_API AChapter_06GameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/>  <br/><strong>public:</strong><br/><strong>    UFUNCTION(BlueprintCallable, Category = UIFuncs)</strong><br/><strong>    void ButtonClicked()</strong><br/><strong>    {</strong><br/><strong>        UE_LOG(LogTemp, Warning, TEXT("UI Button Clicked"));</strong><br/><strong>    }</strong><br/>};</pre>
<ol start="7">
<li>Trigger the function call by routing to it in the Blueprint diagram under the event of your choice. For example, I used the <kbd>OnClick</kbd> function. Once created, I used the Get Game Mode node to get our current game mode and then <kbd>Cast to Chapter06_GameModeBase</kbd> to gain access to the <kbd>ButtonClicked</kbd> function:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8f4f3430-4d15-4359-ad22-e5abb7091743.png"/></p>
<p>Note that for this to work, ensure that you have set the Game Mode for the level/project as <kbd>Chapter_06GameModeBase</kbd>.</p>
<ol start="8">
<li>Construct and display your UI by calling Create Widget, followed by Add to Viewport in the <kbd>BeginPlay</kbd> function of your <kbd>GameModeBase</kbd> (or any such main object) or through the Level Blueprint.</li>
</ol>
<p> </p>
<ol start="9">
<li>To do this via C++, you'll need to go to the <kbd>Chapter_06.Build.cs</kbd> file and modify the following line:</li>
</ol>
<pre style="padding-left: 60px">PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore"<strong>, "UMG", "Slate", "SlateCore"</strong> });</pre>
<ol start="10">
<li>Afterwards, add the following property and function to the <kbd>Chapter_06GameModeBase.h</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">public:<br/>    UFUNCTION(BlueprintCallable, Category = UIFuncs)<br/>    void ButtonClicked()<br/>    {<br/>        UE_LOG(LogTemp, Warning, TEXT("UI Button Clicked"));<br/>    }<br/><br/><strong>    void BeginPlay();</strong><br/><br/><strong>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "UI")</strong><br/><strong>    TSubclassOf&lt;class UUserWidget&gt; Widget;</strong></pre>
<ol start="11">
<li>Then, update the C++ file:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_06GameModeBase.h"<br/>#include "Blueprint/UserWidget.h"<br/><br/>void AChapter_06GameModeBase::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    if(Widget)<br/>    {<br/>        UUserWidget* Menu = CreateWidget&lt;UUserWidget&gt;(GetWorld(), <br/>        Widget);<br/><br/>        if(Menu)<br/>        {<br/>            Menu-&gt;AddToViewport();<br/>       GetWorld()-&gt;GetFirstPlayerController()-&gt;bShowMouseCursor = <br/>       true;<br/>        }<br/>        <br/>    }<br/>    <br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="12">
<li>Now, we need to set Widget to our created menu. To do that, from the Content Browser, right-click on the <kbd>Chapter06_GameModeBase</kbd> from the C++ <kbd>Classes\Chapter_06</kbd> folder and create a new Blueprint from it. Once at the Blueprints menu, go to the Details tab and under the UI section, set the Widget to the item you wish to display:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a99bff0f-a8cb-43ef-b2a6-c9cfb004d3ef.png"/></p>
<div><ol start="13">
<li>Finally, go to Settings | World Settings. From there, change the Game Mode Override to your Blueprint version of the GameMode:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1a52c677-c0a4-4edd-95a3-ca9712391c4a.png"/></p>
<p class="mce-root"/>
<ol start="14">
<li>Then, open the Output Log by going to Window | Developer Tools | Output Log and then play the game. You should see the button displayed on your screen. If you click on it, you should see a message displayed on the Output Log!</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/60719194-7e50-46ce-961f-af9231f654a5.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Your widget's Blueprint button events can be easily connected to Blueprint events, or C++ functions by creating  a <kbd>UFUNCTION()</kbd> that has the <kbd>BlueprintCallable</kbd> tag in the macro.</p>
<p>For more information on using UMG and building simple menus and displaying them using Blueprints, check out <a href="https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets">https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/CreatingWidgets</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">UMG keyboard UI shortcut keys</h1>
                
            
            
                
<p>Every user interface needs shortcut keys associated with it. To program these into your UMG interface, you can simply wire up certain key combinations to an Action Mapping. When the Action triggers, just invoke the same Blueprints function that the UI button itself triggers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You should have a UMG interface created already, as shown in the previous recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>In Settings | Project Settings | Input, define a new Action Mapping for your hot key event, for example, <kbd>HotKey_UIButton_Spell</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/70e3025e-174f-4ae7-8be2-139b9ae12850.png"/></p>
<p class="mce-root"/>
<ol start="2">
<li>Wire up the event to your UI's function call either in Blueprints or in C++ code. In our case, I will add it to the <kbd>AWarrior</kbd> class we created previously by adding it to the <kbd>SetupPlayerInputComponent</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_06GameModeBase.h"<br/><br/>// ...<br/><br/>// Called to bind functionality to input<br/>void AWarrior::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)<br/>{<br/>    Super::SetupPlayerInputComponent(PlayerInputComponent);<br/><br/>    check(PlayerInputComponent);<br/>    PlayerInputComponent-&gt;BindAxis("Forward", this, <br/>    &amp;AWarrior::Forward);<br/>    PlayerInputComponent-&gt;BindAxis("Back", this, &amp;AWarrior::Back);<br/>    PlayerInputComponent-&gt;BindAxis("Right", this, &amp;AWarrior::Right);<br/>    PlayerInputComponent-&gt;BindAxis("Left", this, &amp;AWarrior::Left);<br/><br/>    PlayerInputComponent-&gt;BindAction("Jump", IE_Pressed, this, <br/>    &amp;AWarrior::Jump);<br/><br/>    // Example of adding bindings via code instead of the <br/>    //  editor<br/>    FInputAxisKeyMapping backKey("Back", EKeys::S, 1.f);<br/>    FInputActionKeyMapping jump("Jump", EKeys::SpaceBar, 0, 0, <br/>    0, 0);<br/><br/>    GetWorld()-&gt;GetFirstPlayerController()-&gt;PlayerInput-<br/>    &gt;AddAxisMapping(backKey);<br/>    GetWorld()-&gt;GetFirstPlayerController()-&gt;PlayerInput-<br/>    &gt;AddActionMapping(jump);<br/><br/><strong>    // Calling function for HotKey</strong><br/><strong>    auto GameMode = Cast&lt;AChapter_06GameModeBase&gt;(GetWorld()-<br/>    &gt;GetAuthGameMode());</strong><br/><strong>    auto Func = &amp;AChapter_06GameModeBase::ButtonClicked;</strong><br/><br/><strong>    if(GameMode &amp;&amp; Func)</strong><br/><strong>    {</strong><br/><strong>        PlayerInputComponent-&gt;BindAction("HotKey_UIButton_Spell", <br/>                                         IE_Pressed, GameMode,  <br/>                                         Func);</strong><br/><strong>    }</strong><br/><strong>    </strong><br/>}</pre>
<ol start="3">
<li>Compile your script and then open the World Settings by going to Settings | World Settings. Under Selected GameMode, set the Default Pawn Class to <kbd>BP_Warrior</kbd>. You should now notice that you can either press your key or press the button to execute the <kbd>ButtonClicked</kbd> function we created in the previous recipe!</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Wiring up an Action Mapping with a short circuit to the function that's called by the UI will allow you to implement hot keys in your game program nicely.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Collision – letting objects pass through one another using Ignore</h1>
                
            
            
                
<p>Collision settings are fairly easy to get started with. There are three classes of intersection for collisions:</p>
<ul>
<li><kbd>Ignore</kbd>: Collisions that pass through each other without any notification.</li>
<li><kbd>Overlap</kbd>: Collisions that trigger the <kbd>OnBeginOverlap</kbd> and <kbd>OnEndOverlap</kbd> events. Interpenetration of objects with an <kbd>Overlap</kbd> setting is allowed.</li>
<li><kbd>Block</kbd>: Collisions that prevent all interpenetration, and prevent objects from overlapping each other at all.</li>
</ul>
<p>Objects are classed into one of many Object Types. The Collision settings for a particular Blueprint's Component allow you to class the object as an Object Type of your choice, as well as specify how that object collides with all other objects of all other types. This takes a tabular format in the Details | Collision section of the Blueprint Editor.</p>
<p class="mce-root"/>
<p>For example, the following screenshot shows the Collision settings for a character's <kbd>CapsuleComponent</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e187ec4e-1e2f-4603-8cf9-b4eddcf6ae3c.png" style="width:29.25em;height:29.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You should have a UE4 project with some objects that you'd like to program intersections for.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open the Blueprint Editor for the object that you'd like other objects to simply pass through and ignore. Under the Components listing, select the component that you'd like to program settings for.</li>
</ol>
<p> </p>
<ol start="2">
<li>With your component selected, see your Details tab (usually on the right). Under Collision Presets, select either the NoCollision or Custom... presets:</li>
</ol>
<ul>
<li style="padding-left: 30px">If you select the NoCollision preset, you can just leave it at that, and all collisions will be ignored.</li>
<li style="padding-left: 30px">If you select the Custom... preset, then choose either of the following:
<ul>
<li>NoCollision under the Collision Enabled drop-down menu.</li>
<li>Select a collision mode under Collision Enabled involving Queries, and be sure to check the Ig</li>
</ul>
</li>
<li>nore checkbox for each Object Type that you'd like it to ignore collisions with.</li>
</ul>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Ignored collisions will not fire any events or prevent interpenetrations between objects marked as such. Note that if Object A is set to ignore Object B, it does not matter whether Object B is set to ignore Object A or not. They will ignore each other as long as one of them is set to ignore the other.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Collision – picking up objects using Overlap</h1>
                
            
            
                
<p>Item pickup is a pretty important thing to do cleanly. In this recipe, we'll outline how to get item pickups working using Overlap events on Actor Component primitives.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The previous recipe, <em>Collisions – Letting objects pass through each other using Ignore</em>, describes the basics of collisions. You should read it for background before beginning this recipe. What we'll do here is create a New Object Channel... to identify <kbd>Item</kbd> class objects so that they can be programmed for overlaps, but only with the player avatar's collision volume.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Start by creating a unique collision Channel for the <kbd>Item</kbd> object's collision primitive. This is under Settings | Project Settings | Collision:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1c91758c-6e3b-454b-932d-0fa3f8e59e4a.png"/></p>
<ol start="2">
<li>Once there, create a new Object Channel by going to New Object Channel....</li>
<li>Name the new Object Channel <kbd>Item</kbd> and set the Default Response to Overlap. Afterwards, hit the Accept button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/aa9ee232-de0e-4b2b-8900-1910ce95c00d.png" style="width:14.25em;height:8.67em;"/></p>
<ol start="4">
<li>Take your <kbd>Item</kbd> actor and select the primitive component on it that is used to intersect for pickup with the player avatar. From the Details tab, go to the Collision section and under Collision Presets, change the option to Custom.... Afterwards, set the Object Type of that primitive to <kbd>Item</kbd>.</li>
</ol>
<ol start="5">
<li>Check the Overlap checkbox against the <kbd>Pawn</kbd> class Object Type, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/37f20568-fa11-4711-baca-e6b1b0f521ed.png"/></p>
<p class="mce-root"/>
<ol start="6">
<li>Ensure that the Generate Overlap Events checkbox is checked:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/21f4abc7-1789-47a8-98ef-99654ed333d0.png"/></p>
<p>Location of the Generate Overlap Events property.</p>
<ol start="7">
<li>Take the player actor who will pick up the items (BP_Warrior for this example) and select the component on them that feels for the items. Usually, this will be their <kbd>CapsuleComponent</kbd>. Check Overlap with the <kbd>Item</kbd> object:</li>
</ol>
<div><img src="img/c1a57159-25c1-4944-9692-917dd14f30ea.png" style="width:62.83em;height:42.67em;"/></div>
<p class="mce-root"/>
<ol start="8">
<li>Now, the Player overlaps the item, and the item overlaps the player pawn. We do have to signal overlaps both ways (<kbd>Item</kbd> overlaps <kbd>Pawn</kbd> and <kbd>Pawn</kbd> Overlaps <kbd>Item</kbd>) for it to work properly. Ensure that Generate Overlap Events is also checked for the <kbd>Pawn</kbd> intersecting component.</li>
<li>Next, we have to complete the <kbd>OnComponentBeginOverlap</kbd> event for either the item or the Player's pickup volume, using either Blueprints or C++ code:
<ol>
<li>If you prefer Blueprints, in the Events section of the Details pane of the Items's intersectable Component, click on the + icon beside the On Component Begin Overlap event:</li>
</ol>
</li>
</ol>
<div><img src="img/6dee9413-e593-4c0a-922e-71eab50057a9.png" style="width:27.25em;height:7.00em;"/></div>
<ol>
<li style="list-style-type: none">
<ol start="2">
<li>Use the <kbd>OnComponentBeginOverlap</kbd> event that appears in your <kbd>Actor</kbd> Blueprint diagram to wire in Blueprints code to run when an overlap with the Player's capsule volume occurs.</li>
<li>If you prefer C++, you can write and attach a C++ function to the <kbd>CapsuleComponent</kbd>. Write a member function in your player's <kbd>Character</kbd> class (for example, the <kbd>Warrior.h</kbd> file) with a signature, as follows:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 90px"><br/>UFUNCTION(BlueprintNativeEvent, Category = Collision)<br/>void OnOverlapsBegin(UPrimitiveComponent* Comp,<br/>                        AActor* OtherActor, <br/>                        UPrimitiveComponent* OtherComp,<br/>                        int32 OtherBodyIndex,<br/>                        bool bFromSweep, <br/>                        const FHitResult&amp;SweepResult);<br/><br/>UFUNCTION(BlueprintNativeEvent, Category = Collision)<br/>void OnOverlapsEnd(UPrimitiveComponent* Comp,<br/>                    AActor* OtherActor, <br/>                    UPrimitiveComponent* OtherComp,<br/>                    int32 OtherBodyIndex);<br/><br/>virtual void PostInitializeComponents() override;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol>
<li style="list-style-type: none">
<ol start="4">
<li>Complete the implementation of the <kbd>OnOverlapsBegin()</kbd> function in your <kbd>.cpp</kbd> file, making sure to end the function name with <kbd>_Implementation</kbd>:</li>
</ol>
</li>
</ol>
<ol>
<li style="list-style-type: none">
<ol start="4"/>
</li>
</ol>
<pre style="padding-left: 90px">void AWarrior::OnOverlapsBegin_Implementation(<br/>    UPrimitiveComponent* Comp,<br/>    AActor* OtherActor, UPrimitiveComponent* OtherComp,<br/>    int32 OtherBodyIndex,<br/>    bool bFromSweep, const FHitResult&amp;SweepResult)<br/>{<br/>    UE_LOG(LogTemp, Warning, TEXT("Overlaps warrior<br/>    began"));<br/>}<br/><br/>void AWarrior::OnOverlapsEnd_Implementation(<br/>    UPrimitiveComponent* Comp,<br/>    AActor* OtherActor, UPrimitiveComponent* OtherComp,<br/>    int32 OtherBodyIndex)<br/>{<br/>    UE_LOG(LogTemp, Warning, TEXT("Overlaps warrior<br/>    ended"));<br/>}</pre>
<ol>
<li style="list-style-type: none">
<ol start="5">
<li>Then, provide a <kbd>PostInitializeComponents()</kbd> override to connect the <kbd>OnOverlapsBegin()</kbd> function with overlaps to the capsule in your avatar's class, as follows:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 90px">#include "Components/CapsuleComponent.h"<br/><br/>// ...<br/><br/>void AWarrior::PostInitializeComponents()<br/>{<br/>    Super::PostInitializeComponents();<br/><br/>    if (RootComponent)<br/>    {<br/>        // Attach contact function to all bounding components. <br/>        GetCapsuleComponent()-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AWarrior::OnOverlapsBegin);<br/>        GetCapsuleComponent()-&gt;OnComponentEndOverlap.AddDynamic(this, &amp;AWarrior::OnOverlapsEnd);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="10">
<li>Compile your script and then run your project. You should see log messages when you enter and leave the object! Refer to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/98a6d7a0-dcf9-4da6-bc7b-50f130efa029.png" style="width:52.67em;height:42.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Overlap event that's raised by the engine allows code to run when two UE4 <kbd>Actor</kbd> Components overlap, without preventing interpenetration of the objects.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Collision – preventing interpenetration using Block</h1>
                
            
            
                
<p>Blocking means that the <kbd>Actor</kbd> components will be prevented from interpenetration in the engine, and any collision between two primitive shapes will be resolved, and not overlapping, after collisions are found.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Begin with a UE4 project that has some objects with Actors that have collision primitives attached to them (<kbd>SphereComponents</kbd>, <kbd>CapsuleComponents</kbd>, or <kbd>BoxComponents</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open the Blueprint of an actor that you want to block another actor with. For example, we want the Player actor to block other Player actor instances.</li>
<li>Mark primitives inside the actor that you do not want interpenetrating with other components as blocking those components in the Details pane:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/15215060-daac-41c6-a9db-c7b95e1be796.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When objects b</p>
<p>lock one another, they will not be allowed to interpenetrate. Any interpenetration will be automatically resolved, and the objects will be pushed off each other. This is one of the details that often causes lots of headaches. For objects to actually block each other, they both have to be set to block.</p>
<p>For more information, check out the official UE4 blog post on the subject: <a href="https://www.unrealengine.com/en-US/blog/collision-filtering">https://www.unrealengine.com/en-US/blog/collision-filtering</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You can override the <kbd>OnComponentHit</kbd> function to run code when two objects hit each other. This is distinct from the <kbd>OnComponentBeginOverlap</kbd> event.</p>


            

            
        
    </body></html>