<html><head></head><body>
		<div><h1 id="_idParaDest-194"><a id="_idTextAnchor200"/><em class="italic">Chapter 9</em>: C++ References, Sprite Sheets, and Vertex Arrays </h1>
			<p>In <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a>,<em class="italic"> Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>, we talked about scope. This is the concept that variables declared in a function or inner block of code only have scope (that is, can be <em class="italic">seen</em> or used) in that function or block. Using only the C++ knowledge we have currently, this can cause a problem. What do we do if we need to work on a few complex objects that are needed in the <code>main</code> function? This could imply all the code must be in the <code>main</code> function.</p>
			<p>In this chapter, we will explore C++ <strong class="bold">references</strong>, which allow us to work on variables and objects that are otherwise out of scope. In addition to this, these references will help us avoid having to pass large objects between functions, which is a slow process. It is slow because each time we do this, a copy of the variable or object must be made.</p>
			<p>Armed with this new knowledge of references, we will look at the SFML <code>VertexArray</code> class, which allows us to build up a large image that can be quickly and efficiently drawn to the screen using multiple parts in a single image file. By the end of this chapter, we will have a scalable, random, scrolling background that's been made using references and a <code>VertexArray</code> object.</p>
			<p>In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>C++ references</li>
				<li>SFML vertex arrays</li>
				<li>Coding a random, scrolling background</li>
			</ul>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor201"/>C++ references</h1>
			<p>When we pass values to a function or return values from a function, that is exactly what we are doing – passing/returning by <strong class="bold">value</strong>. What happens is that a copy of the value held by the variable is made and then sent to the function, where it is used. </p>
			<p>The significance of this is twofold:</p>
			<ol>
				<li>If we want the function to make a permanent change to a variable, this system is no good to us.</li>
				<li>When a copy is made to pass in as an argument or returned from the function, processing power and memory are consumed. For a simple <code>int</code>, or even perhaps a <code>Sprite</code>, this is insignificant. However, for a complex object, perhaps an entire game world (or background), the copying process will seriously affect our game's performance.</li>
			</ol>
			<p>References are the solution to these two problems. A <strong class="bold">reference</strong> is a special type of variable. A reference <em class="italic">refers</em> to another variable. Here is an example to help you understand this better:</p>
			<pre>int numZombies = 100;
int&amp; rNumZombies = numZombies;</pre>
			<p>In the preceding code, we declare and initialize a regular <code>int</code> called <code>numZombies</code>. We then declare and initialize an <code>int</code> reference called <code>rNumZombies</code>. The reference operator, <code>&amp;</code>, which follows the type, determines that a reference is being declared.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <code>r</code> prefix at the front of the reference name is optional but is useful for remembering that we are dealing with a reference.</p>
			<p>Now, we have an <code>int</code> variable called <code>numZombies</code>, which stores the value 100, and an <code>int</code> reference called <code>rNumZombies</code>, which refers to <code>numZombies</code>.</p>
			<p>Anything we do to <code>numZombies</code> can be seen through <code>rNumZombies</code>, and anything we do to <code>rNumZombies</code> we are actually doing to <code>numZombies</code>. Take a look at the following code:</p>
			<pre>int score = 10;
int&amp; rScore = score;
score ++;
rScore ++;</pre>
			<p>In the previous code, we declare an <code>int</code> called <code>score</code>. Next, we declare an <code>int</code> reference called <code>rScore</code> that refers to <code>score</code>. Remember that anything we do to <code>score</code> can be seen by <code>rScore</code> and anything we do to <code>rScore</code> is actually being done to <code>score</code>.</p>
			<p>Therefore, consider what happens when we increment <code>score</code> like this:</p>
			<pre>score ++;</pre>
			<p>The <code>score</code> variable now stores the value 11. In addition to this, if we were to output <code>rScore</code>, it would also output 11. The next line of code is as follows:</p>
			<pre>rScore ++;</pre>
			<p>Now, <code>score</code> actually holds the value 12 because anything we do to <code>rScore</code> is actually done to <code>score</code>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to know <em class="italic">how</em> this works, then more will be revealed in the next chapter when we discuss <strong class="bold">pointers</strong>. But simply put, you can consider a reference as storing a place/address in the computer's memory. That place in memory is the same place where the variable it refers to stores its value. Therefore, an operation on either the reference or the variable has exactly the same effect.</p>
			<p>For now, it is much more important to talk about the <em class="italic">why</em> of references. There are two reasons to use references, and we have already mentioned them. Here they are, summarized again:</p>
			<ol>
				<li value="1">Changing/reading the value of a variable/object in another function, which is otherwise out of scope.</li>
				<li>Passing/returning to/from a function without making a copy (and, therefore, more efficiently).</li>
			</ol>
			<p>Study the following code and then we will discuss it:</p>
			<pre>void add(int n1, int n2, int a);
void referenceAdd(int n1, int n2, int&amp; a);
int main()
{
    int number1 = 2;
    int number2 = 2;
    int answer = 0;
    
    add(number1, number2, answer);
    // answer still equals zero because it is passed as a copy
    // Nothing happens to answer in the scope of main
    referenceAdd(number1, number2, answer);
    // Now answer equals 4 because it was passed by reference
    // When the referenceAdd function did this:
    // answer = num1 + num 2;
    // It is actually changing the value stored by answer
    return 0;
}
// Here are the two function definitions
// They are exactly the same except that
// the second passes a reference to a
void add(int n1, int n2, int a)
{
    a = n1 + n2;
    // a now equals 4
    // But when the function returns a is lost forever
}
void referenceAdd(int n1, int n2, int&amp; a)
{
    a = n1 + n2;
    // a now equals 4
    // But a is a reference!
    // So, it is actually answer, back in main, that equals 4
}</pre>
			<p>The previous code begins with the prototypes of two functions: <code>add</code> and <code>referenceAdd</code>. The <code>add</code> function takes three <code>int</code> variables while the <code>referenceAdd</code> function takes two <code>int</code> variables and an <code>int</code> reference.</p>
			<p>When the <code>add</code> function is called and the <code>number1</code>, <code>number2</code>, and <code>answer</code> variables are passed in, a copy of the values is made and new variables local to <code>add</code> (that is, <code>n1</code>, <code>n2</code>, and <code>a</code>) are manipulated. As a result of this, <code>answer</code>, back in <code>main</code>, remains at zero.</p>
			<p>When the <code>referenceAdd</code> function is called, <code>number1</code> and <code>number2</code> are again passed by value. However, <code>answer</code> is passed by reference. When the value of <code>n1</code> that's added to <code>n2</code> is assigned to the reference, <code>a</code>, what is really happening is that the value is assigned to <code>answer</code> back in the <code>main</code> function.</p>
			<p>It is probably obvious that we would never need to use a reference for something this simple. It does, however, demonstrate the mechanics of passing by reference.</p>
			<p>Let's summarize what we know about references.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor202"/>References summary</h2>
			<p>The previous code demonstrated how a reference can be used to alter the value of a variable in one scope using code in another. As well as being extremely convenient, passing by reference is also very efficient because no copy is made. Our example, that is, using a reference to an <code>int</code>, is a bit ambiguous because, as an <code>int</code> is so small, there is no real efficiency gain. Later on in this chapter, we will use a reference to pass an entire level layout and the efficiency gain will be significant.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There is one gotcha with references! You must assign the reference to a variable at the time you create it. This means it is not completely flexible. Don't worry about this for now. We will explore references further alongside their more flexible (and slightly more complicated) relations, such as <strong class="bold">pointers</strong>, in the next chapter.</p>
			<p>This is largely irrelevant for an <code>int</code>, but potentially significant for a large object of a class. We will use this exact technique when we implement the scrolling background of the Zombie Arena game later on in this chapter.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor203"/>SFML vertex arrays and sprite sheets</h1>
			<p>We are nearly ready to implement the scrolling background. We just need to learn about SFML vertex arrays and sprite sheets.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor204"/>What is a sprite sheet?</h2>
			<p>A <strong class="bold">sprite sheet</strong> is a set of images, either frames of animation, or totally individual graphics contained in one image file. Take a closer look at this sprite sheet, which contains four separate images that will be used to draw the background in our Zombie Arena game:</p>
			<div><div><img src="img/B14278_09_01.jpg" alt=""/>
				</div>
			</div>
			<p>SFML allows us to load a sprite sheet as a regular texture, in the same way we have done for every texture in this book so far. When we load multiple images as a single texture, the GPU can handle it much more efficiently.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Actually, a modern PC could handle these four textures without using a sprite sheet. It is worth learning these techniques, however, as our games are going to start getting progressively more demanding on our hardware.</p>
			<p>What we need to do when we draw an image from the sprite sheet is make sure we refer to the precise pixel coordinates of the part of the sprite sheet we require, like so:</p>
			<div><div><img src="img/B14278_09_02.jpg" alt=""/>
				</div>
			</div>
			<p>The previous diagram labels each part/tile with the coordinates and their position within the sprite sheet. These coordinates are called <strong class="bold">texture coordinates</strong>. We will use these texture coordinates in our code to draw just the right parts that we require.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor205"/>What is a vertex array?</h2>
			<p>First, we need to ask, what is a vertex? A <strong class="bold">vertex </strong>is a single graphical point, that is, a coordinate. This point is defined by a horizontal and vertical position. The plural of vertex is vertices. A vertex array, then, is a whole collection of vertices.</p>
			<p>In SFML, each vertex in a vertex array also has a color and a related additional vertex (that is, a pair of coordinates) called <strong class="bold">texture coordinates</strong>. Texture coordinates are the position of the image we want to use in terms of a sprite sheet. Later, we will see how we can position graphics and choose a part of the sprite sheet to display at each position, all with a single vertex array.</p>
			<p>The SFML <code>VertexArray</code> class can hold different types of vertex sets. But each <code>VertexArray</code> should only hold one type of set. We use the type of set that suits the occasion.</p>
			<p>Common scenarios in video games include, but are not limited to, the following <strong class="bold">primitive</strong> types:</p>
			<ul>
				<li><strong class="bold">Point</strong>: A single vertex per point.</li>
				<li><strong class="bold">Line</strong>: Two vertices per set that define the start and endpoint of the line.</li>
				<li><strong class="bold">Triangle</strong>: Three vertices per point. This is the most commonly used (in the thousands) for complex 3D models, or in pairs to create a simple rectangle such as a sprite.</li>
				<li><strong class="bold">Quad</strong>: Four vertices per set. This is a convenient way to map rectangular areas from a sprite sheet.</li>
			</ul>
			<p>We will use quads in this project.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor206"/>Building a background from tiles</h2>
			<p>The Zombie Arena background will be made up of a random arrangement of square images. You can think of this arrangement like tiles on a floor. </p>
			<p>In this project, we will be using vertex arrays with <strong class="bold">quad</strong> sets. Each vertex will be part of a set of four (that is, a quad). Each vertex will define one corner of a tile from our background, while each texture coordinate will hold an appropriate value based on a specific image from the sprite sheet.</p>
			<p>Let's look at some code to get us started. This isn't the exact code we will use in the project, but it is close and allows us to study vertex arrays before we move on to the actual implementation we will use.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor207"/>Building a vertex array</h2>
			<p>As we do when we create an instance of a class, we declare our new object. The following code declares a new object of the <code>VertexArray</code> type, called <code>background</code>:</p>
			<pre>// Create a vertex array
VertexArray background;</pre>
			<p>We want to let our instance of <code>VertexArray</code> know which type of primitive we will be using. Remember that points, lines, triangles, and quads all have a different number of vertices. By setting the <code>VertexArray</code> instance to hold a specific type, it will be possible to know the start of each primitive. In our case, we want quads. Here is the code that will do this:</p>
			<pre>// What primitive type are we using
background.setPrimitiveType(Quads);</pre>
			<p>As with regular C++ arrays, a <code>VertexArray</code> instance needs to be set to a particular size. The <code>VertexArray</code> class is more flexible than a regular array, however. It allows us to change its size while the game is running. The size could be configured at the same time as the declaration, but our background needs to expand with each wave. The <code>VertexArray</code> class provides this functionality with the <code>resize</code> function. Here is the code that would set the size of our arena to a 10 by 10 tile size:</p>
			<pre>// Set the size of the vertex array
background.resize(10 * 10 * 4);</pre>
			<p>In the previous line of code, the first <code>10</code> is the width, the second <code>10</code> is the height, and 4 is the number of vertices in a quad. We could have just passed in 400, but showing the calculation like this makes it clear what we are doing. When we code the project for real, we will go a step further to aid clarity and declare variables for each part of the calculation.</p>
			<p>We now have a <code>VertexArray</code> instance ready to have its hundreds of vertices configured. Here is how we set the position coordinates on the first four vertices (that is, the first quad):</p>
			<pre>// Position each vertex in the current quad
background[0].position = Vector2f(0, 0);
background[1].position = Vector2f(49, 0);
background[2].position = Vector2f(49,49);
background[3].position = Vector2f(0, 49);</pre>
			<p>Here is how we set the texture coordinates of these same vertices to the first image in the sprite sheet. These coordinates in the image file are from 0,0 (in the top-left corner) to 49,49 (in the bottom-right corner):</p>
			<pre>// Set the texture coordinates of each vertex
background[0].texCoords = Vector2f(0, 0);
background[1].texCoords = Vector2f(49, 0);
background[2].texCoords = Vector2f(49, 49);
background[3].texCoords = Vector2f(0, 49);</pre>
			<p>If we wanted to set the texture coordinates to the second image in the sprite sheet, we would have written the code like this:</p>
			<pre>// Set the texture coordinates of each vertex
background[0].texCoords = Vector2f(0, 50);
background[1].texCoords = Vector2f(49, 50);
background[2].texCoords = Vector2f(49, 99);
background[3].texCoords = Vector2f(0, 99);</pre>
			<p>Of course, if we define each and every vertex like this individually, then we are going to be spending a long time configuring even a simple 10 by 10 arena.</p>
			<p>When we implement our background for real, we will devise a set of nested <code>for</code> loops that loop through each quad, pick a random background image, and assign the appropriate texture coordinates.</p>
			<p>The code will need to be quite smart. It will need to know when it is an edge tile so that it can use the wall image from the sprite sheet. It will also need to use appropriate variables that know the position of each background tile in the sprite sheet, as well as the overall size of the required arena.</p>
			<p>We will make this complexity manageable by putting all the code in both a separate function and a separate file. We will make the <code>VertexArray</code> instance usable in <code>main</code> by using a C++ reference.</p>
			<p>We will examine these details later. You may have noticed that at no point have we associated a texture (the sprite sheet with the vertex array). Let's see how to do that now.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor208"/>Using the vertex array to draw</h2>
			<p>We can load the sprite sheet as a texture in the same way that we load any other texture, as shown in the following code:</p>
			<pre>// Load the texture for our background vertex array
Texture textureBackground;
textureBackground.loadFromFile("graphics/background_sheet.png");</pre>
			<p>We can then draw the entire <code>VertexArray</code> with one call to <code>draw</code>: </p>
			<pre>// Draw the background
window.draw(background, &amp;textureBackground);</pre>
			<p>The previous code is much more efficient than drawing every tile as an individual sprite.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Before we move on, notice the slightly odd-looking <code>&amp;</code> notation before the <code>textureBackground</code> code. Your immediate thought might be that this has something to do with references. What is going on here is we are passing the address of the <code>Texture</code> instance instead of the actual <code>Texture</code> instance. We will learn more about this in the next chapter.</p>
			<p>We are now able to use our knowledge of references and vertex arrays to implement the next stage of the Zombie Arena project.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor209"/>Creating a randomly generated scrolling background</h1>
			<p>In this section, we will create a function that makes a background in a separate file. We will ensure the background will be available (in scope) to the <code>main</code> function by using a vertex array reference.</p>
			<p>As we will be writing other functions that share data with the <code>main</code> function, we will write them all in their own <code>.cpp</code> files. We will provide prototypes for these functions in a new header file that we will include (with an <code>#include</code> directive) in <code>ZombieArena.cpp</code>. </p>
			<p>To achieve this, let's make a new header file called <code>ZombieArena.h</code>. We are now ready to code the header file for our new function.</p>
			<p>In this new <code>ZombieArena.h</code> header file, add the following highlighted code, including the function prototype:</p>
			<pre>#pragma once
<strong class="bold">using namespace sf;</strong>
<strong class="bold">int createBackground(VertexArray&amp; rVA, IntRect arena);</strong></pre>
			<p>The previous code allows us to write the definition of a function called <code>createBackground</code>. To match the prototype, the function definition must return an <code>int</code> value, and receive a <code>VertexArray</code> reference and an <code>IntRect</code> object as parameters.</p>
			<p>Now, we can create a new <code>.cpp</code> file in which we will code the function definition. Create a new file called <code>CreateBackground.cpp</code>. We are now ready to code the function definition that will create our background.</p>
			<p>Add the following code to the <code>CreateBackground.cpp</code> file, and then we will review it:</p>
			<pre>#include "ZombieArena.h"
int createBackground(VertexArray&amp; rVA, IntRect arena)
{
    // Anything we do to rVA we are really doing
    // to background (in the main function)
    
    // How big is each tile/texture
    const int TILE_SIZE = 50;
    const int TILE_TYPES = 3;
    const int VERTS_IN_QUAD = 4;
    int worldWidth = arena.width / TILE_SIZE;
    int worldHeight = arena.height / TILE_SIZE;
    // What type of primitive are we using?
    rVA.setPrimitiveType(Quads);
    // Set the size of the vertex array
    rVA.resize(worldWidth * worldHeight * VERTS_IN_QUAD);
    // Start at the beginning of the vertex array
    int currentVertex = 0;
    return TILE_SIZE;
}</pre>
			<p>In the previous code, we write the function signature as well as the opening and closing curly brackets that mark the function body. </p>
			<p>Within the function body, we declare and initialize three new <code>int</code> constants to hold values that we will need to refer to throughout the rest of the function. They are <code>TILE_SIZE</code>, <code>TILE_TYPES</code>, and <code>VERTS_IN_QUAD</code>. </p>
			<p>The <code>TILE_SIZE</code> constant refers to the size in pixels of each tile within the sprite sheet. The <code>TILE_TYPES</code> constant refers to the number of different tiles within the sprite sheet. We could add more tiles into our sprite sheet and change <code>TILE_TYPES</code> to match the change, and the code we are about to write would still work. <code>VERTS_IN_QUAD</code> refers to the fact that there are four vertices in every quad. It is less error-prone to use this constant compared to always typing the number <code>4</code>, which is less clear.</p>
			<p>We then declare and initialize two <code>int</code> variables: <code>worldWidth</code> and <code>worldHeight</code>. These variables might appear obvious as to their use. They are betrayed by their names, but it is worth pointing out that they refer to the width and height of the world in the number of tiles, not pixels. The <code>worldWidth</code> and <code>worldHeight</code> variables are initialized by dividing the height and width of the passed-in arena by the <code>TILE_SIZE</code> constant.</p>
			<p>Next, we get to use our reference for the first time. Remember that anything we do to <code>rVA</code>, we are really doing to the variable that was passed in, which is in scope in the <code>main</code> function (or will be when we code it).</p>
			<p>Then, we prepare the vertex array to use quads using <code>rVA.setType</code> and then we make it just the right size by calling <code>rVA.resize</code>. To the <code>resize</code> function, we pass in the result of <code>worldWidth * worldHeight * VERTS_IN_QUAD</code>, which equates to exactly the number of vertices that our vertex array will have when we are done preparing it.</p>
			<p>The last line of code declares and initializes <code>currentVertex</code> to zero. We will use <code>currentVertex</code> as we loop through the vertex array, initializing all the vertices.</p>
			<p>We can now write the first part of a nested <code>for</code> loop that will prepare the vertex array. Add the following highlighted code and, based on what we have learned about vertex arrays, try and work out what it does:</p>
			<pre>    // Start at the beginning of the vertex array
    int currentVertex = 0;
<strong class="bold">    for (int w = 0; w &lt; worldWidth; w++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        for (int h = 0; h &lt; worldHeight; h++)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // Position each vertex in the current quad</strong>
<strong class="bold">            rVA[currentVertex + 0].position = </strong>
<strong class="bold">                Vector2f(w * TILE_SIZE, h * TILE_SIZE);</strong>
<strong class="bold">                </strong>
<strong class="bold">            rVA[currentVertex + 1].position =</strong>
<strong class="bold">                Vector2f((w * TILE_SIZE) + TILE_SIZE, h * TILE_SIZE);</strong>
<strong class="bold">                </strong>
<strong class="bold">            rVA[currentVertex + 2].position =</strong>
<strong class="bold">                Vector2f((w * TILE_SIZE) + TILE_SIZE, (h * TILE_SIZE) </strong>
<strong class="bold">                + TILE_SIZE);</strong>
<strong class="bold">                </strong>
<strong class="bold">            rVA[currentVertex + 3].position =</strong>
<strong class="bold">                Vector2f((w * TILE_SIZE), (h * TILE_SIZE) </strong>
<strong class="bold">                + TILE_SIZE);</strong>
<strong class="bold">                </strong>
<strong class="bold">            </strong>
<strong class="bold">            // Position ready for the next four vertices</strong>
<strong class="bold">            currentVertex = currentVertex + VERTS_IN_QUAD;</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    return TILE_SIZE;
}</pre>
			<p>The code that we just added steps through the vertex array by using a nested <code>for</code> loop, which first steps through the first four vertices: <code>currentVertex + 1</code>,<code> currentVertex + 2</code>, and so on. </p>
			<p>We access each vertex in the array using the array notation, <code>rvA[currentVertex + 0]..</code>, and so on. Using the array notation, we call the <code>position</code> function, <code>rvA[currentVertex + 0].position...</code>.</p>
			<p>To the <code>position</code> function, we pass the horizontal and vertical coordinates of each vertex. We can work these coordinates out programmatically by using a combination of <code>w</code>, <code>h</code>, and <code>TILE_SIZE</code>. </p>
			<p>At the end of the previous code, we position <code>currentVertex</code>, ready for the next pass through the nested <code>for</code> loop by advancing it four places (that is, adding four) with the code, that is, <code>currentVertex = currentVertex + VERTS_IN_QUAD</code>.</p>
			<p>Of course, all this does is set the coordinates of our vertices; it doesn't assign a texture coordinate from the sprite sheet. This is what we will do next.</p>
			<p>To make it absolutely clear where the new code goes, I have shown it in context, along with all the code that we wrote a moment ago. Add and study the following highlighted code:</p>
			<pre>for (int w = 0; w &lt; worldWidth; w++)
    {
        for (int h = 0; h &lt; worldHeight; h++)
        {
            // Position each vertex in the current quad
            rVA[currentVertex + 0].position = 
                Vector2f(w * TILE_SIZE, h * TILE_SIZE);
                
            rVA[currentVertex + 1].position =
                Vector2f((w * TILE_SIZE) + TILE_SIZE, h * TILE_SIZE);
                
            rVA[currentVertex + 2].position =
                Vector2f((w * TILE_SIZE) + TILE_SIZE, (h * TILE_SIZE) 
                + TILE_SIZE);
                
            rVA[currentVertex + 3].position =
                Vector2f((w * TILE_SIZE), (h * TILE_SIZE) 
                + TILE_SIZE);
                
            
<strong class="bold">            // Define the position in the Texture for current quad</strong>
<strong class="bold">            // Either grass, stone, bush or wall</strong>
<strong class="bold">            if (h == 0 || h == worldHeight-1 || </strong>
<strong class="bold">                w == 0 || w == worldWidth-1)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                // Use the wall texture</strong>
<strong class="bold">                rVA[currentVertex + 0].texCoords = </strong>
<strong class="bold">                    Vector2f(0, 0 + TILE_TYPES * TILE_SIZE);</strong>
<strong class="bold">                    </strong>
<strong class="bold">                rVA[currentVertex + 1].texCoords = </strong>
<strong class="bold">                    Vector2f(TILE_SIZE, 0 + </strong>
<strong class="bold">                    TILE_TYPES * TILE_SIZE);</strong>
<strong class="bold">                    </strong>
<strong class="bold">                rVA[currentVertex + 2].texCoords = </strong>
<strong class="bold">                    Vector2f(TILE_SIZE, TILE_SIZE + </strong>
<strong class="bold">                    TILE_TYPES * TILE_SIZE);</strong>
<strong class="bold">                    </strong>
<strong class="bold">                rVA[currentVertex + 3].texCoords = </strong>
<strong class="bold">                    Vector2f(0, TILE_SIZE + </strong>
<strong class="bold">                    TILE_TYPES * TILE_SIZE);</strong>
<strong class="bold">            }</strong>
            
            // Position ready for the next for vertices
            currentVertex = currentVertex + VERTS_IN_QUAD;
        }
    }
    return TILE_SIZE;
}</pre>
			<p>The preceding highlighted code sets up the coordinates within the sprite sheet that each vertex is related to. Notice the somewhat long <code>if</code> condition. The condition checks whether the current quad is either one of the very first or the very last quads in the arena. If it is (one of the first or last), then this means it is part of the boundary. We can then use a simple formula using <code>TILE_SIZE</code> and <code>TILE_TYPES</code> to target the wall texture from the sprite sheet.</p>
			<p>The array notation and the <code>texCoords</code> member are initialized for each vertex, in turn, to assign the appropriate corner of the wall texture within the sprite sheet.</p>
			<p>The following code is wrapped in an <code>else</code> block. This means that it will run through the nested <code>for</code> loop each time the quad does not represent a border/wall tile. Add the following highlighted code among the existing code, and then we will examine it:</p>
			<pre>            // Define position in Texture for current quad
            // Either grass, stone, bush or wall
            if (h == 0 || h == worldHeight-1 ||
                w == 0 || w == worldWidth-1)
            {
                // Use the wall texture
                rVA[currentVertex + 0].texCoords = 
                    Vector2f(0, 0 + TILE_TYPES * TILE_SIZE);
                    
                rVA[currentVertex + 1].texCoords = 
                    Vector2f(TILE_SIZE, 0 + 
                    TILE_TYPES * TILE_SIZE);
                    
                rVA[currentVertex + 2].texCoords = 
                    Vector2f(TILE_SIZE, TILE_SIZE + 
                    TILE_TYPES * TILE_SIZE);
                    
                rVA[currentVertex + 3].texCoords = 
                    Vector2f(0, TILE_SIZE + 
                    TILE_TYPES * TILE_SIZE);
            }
<strong class="bold">            else</strong>
<strong class="bold">            {</strong>
<strong class="bold">                // Use a random floor texture</strong>
<strong class="bold">                srand((int)time(0) + h * w - h);</strong>
<strong class="bold">                int mOrG = (rand() % TILE_TYPES);</strong>
<strong class="bold">                int verticalOffset = mOrG * TILE_SIZE;</strong>
<strong class="bold">                rVA[currentVertex + 0].texCoords = </strong>
<strong class="bold">                    Vector2f(0, 0 + verticalOffset);</strong>
<strong class="bold">                    </strong>
<strong class="bold">                rVA[currentVertex + 1].texCoords = </strong>
<strong class="bold">                    Vector2f(TILE_SIZE, 0 + verticalOffset);</strong>
<strong class="bold">                    </strong>
<strong class="bold">                rVA[currentVertex + 2].texCoords = </strong>
<strong class="bold">                    Vector2f(TILE_SIZE, TILE_SIZE + verticalOffset);</strong>
<strong class="bold">                    </strong>
<strong class="bold">                rVA[currentVertex + 3].texCoords = </strong>
<strong class="bold">                    Vector2f(0, TILE_SIZE + verticalOffset);</strong>
<strong class="bold">            }            </strong>
            // Position ready for the next for vertices
            currentVertex = currentVertex + VERTS_IN_QUAD;
        }
    }
    return TILE_SIZE;
}</pre>
			<p>The preceding highlighted code starts by seeding the random number generator with a formula that will be different in each pass through the loop. Then, the <code>mOrG</code> variable is initialized with a number between 0 and <code>TILE_TYPES</code>. This is just what we need to pick one of the tile types randomly. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><code>mOrG</code> stands for "mud or grass". The name is arbitrary.</p>
			<p>Now, we declare and initialize a variable called <code>verticalOffset</code> by multiplying <code>mOrG</code> by <code>TileSize</code>. We now have a vertical reference point within the sprite sheet to the starting height of the randomly chosen texture for the current quad.</p>
			<p>Now, we use a simple formula involving <code>TILE_SIZE</code> and <code>verticalOffset</code> to assign the precise coordinates of each corner of the texture to the appropriate vertex.</p>
			<p>We can now put our new function to work in the game engine.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor210"/>Using the background</h1>
			<p>We have done the tricky stuff, so this will be simple. There are three steps, as follows: </p>
			<ol>
				<li value="1">Create a <code>VertexArray</code>.</li>
				<li>Initialize it after leveling up each wave.</li>
				<li>Draw it in each frame. </li>
			</ol>
			<p>Add the following highlighted code to declare a <code>VertexArray</code> instance called <code>background</code> and load the <code>background_sheet.png</code> file as a texture:</p>
			<pre>// Create an instance of the Player class
Player player;
// The boundaries of the arena
IntRect arena;
<strong class="bold">// Create the background</strong>
<strong class="bold">VertexArray background;</strong>
<strong class="bold">// Load the texture for our background vertex array</strong>
<strong class="bold">Texture textureBackground;</strong>
<strong class="bold">textureBackground.loadFromFile("graphics/background_sheet.png");</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>Add the following code to call the <code>createBackground</code> function, passing in <code>background</code> as a reference and <code>arena</code> by value. Notice that, in the highlighted code, we have also modified the way that we initialize the <code>tileSize</code> variable. Add the highlighted code exactly as shown:</p>
			<pre>if (state == State::PLAYING)
{
    // Prepare the level
    // We will modify the next two lines later
    arena.width = 500;
    arena.height = 500;
    arena.left = 0;
    arena.top = 0;
<strong class="bold">    // Pass the vertex array by reference </strong>
<strong class="bold">    // to the createBackground function</strong>
<strong class="bold">    int tileSize = createBackground(background, arena);</strong>
    // We will modify this line of code later
<strong class="bold">    // int tileSize = 50;</strong>
    // Spawn the player in the middle of the arena
    player.spawn(arena, resolution, tileSize);
    // Reset the clock so there isn't a frame jump
    clock.restart();
}</pre>
			<p>Note that we have replaced the <code>int tileSize = 50</code> line of code because we get the value directly from the return value of the <code>createBackground</code> function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For the sake of future code clarity, you should delete the <code>int tileSize = 50</code> line of code and its related comment. I just commented it out to give the new code a clearer context.</p>
			<p>Finally, it is time to do the drawing. This is really simple. All we do is call <code>window.draw</code> and pass the <code>VertexArray</code> instance, along with the <code>textureBackground</code> texture:</p>
			<pre>/*
 **************
 Draw the scene
 **************
 */
if (state == State::PLAYING)
{
    window.clear();
    // Set the mainView to be displayed in the window
    // And draw everything related to it
    window.setView(mainView);
<strong class="bold">    // Draw the background</strong>
<strong class="bold">    window.draw(background, &amp;textureBackground);</strong>
    // Draw the player
    window.draw(player.getSprite());
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are wondering what is going on with the odd-looking <code>&amp;</code> sign in front of <code>textureBackground</code>, then all will be made clear in the next chapter.</p>
			<p>You can now run the game. You will see the following output:</p>
			<div><div><img src="img/B14278_09_03.jpg" alt=""/>
				</div>
			</div>
			<p>He<a id="_idTextAnchor211"/>re, note how the player sprite glides and rotates smoothly within the arena's confines. Although the current code in the <code>main</code> function draws a small arena, the <code>CreateBackground</code> function can create an arena of any size. We will see arenas bigger than the screen in <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>,<em class="italic"> Sound Effects, File I/O, and Finishing the Game</em>.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor212"/>Summary</h1>
			<p>In this chapter, we discovered C++ references, which are special variables that act as an alias to another variable. When we pass a variable by reference instead of by value, then anything we do on the reference happens to the variable back in the calling function.</p>
			<p>We also learned about vertex arrays and created a vertex array full of quads to draw the tiles from a sprite sheet as a background.</p>
			<p>The elephant in the room, of course, is that our zombie game doesn't have any zombies. We'll fix that in the next chapter by learning about C++ pointers and the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>).</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor213"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) Can you summarize these references again?</p>
			<p>A) You must initialize a reference immediately, and it cannot be changed to reference another variable. Use references with functions so you are not working on a copy. This is good for efficiency because it avoids making copies and helps us abstract our code into functions more easily.</p>
			<p>Q) Is there an easy way to remember the main benefit of using references?</p>
			<p>A) To help you remember what a reference is used for, consider this short rhyme: </p>
			<p><em class="italic">        Moving large objects can make our games choppy, </em></p>
			<p><em class="italic">        passing by reference is faster than copy.</em></p>
		</div>
	</body></html>