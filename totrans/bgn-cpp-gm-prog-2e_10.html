<html><head></head><body>
		<div id="_idContainer068">
			<h1 id="_idParaDest-194"><a id="_idTextAnchor200"/><em class="italic">Chapter 9</em>: C++ References, Sprite Sheets, and Vertex Arrays </h1>
			<p>In <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a>,<em class="italic"> Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>, we talked about scope. This is the concept that variables declared in a function or inner block of code only have scope (that is, can be <em class="italic">seen</em> or used) in that function or block. Using only the C++ knowledge we have currently, this can cause a problem. What do we do if we need to work on a few complex objects that are needed in the <strong class="source-inline">main</strong> function? This could imply all the code must be in the <strong class="source-inline">main</strong> function.</p>
			<p>In this chapter, we will explore C++ <strong class="bold">references</strong>, which allow us to work on variables and objects that are otherwise out of scope. In addition to this, these references will help us avoid having to pass large objects between functions, which is a slow process. It is slow because each time we do this, a copy of the variable or object must be made.</p>
			<p>Armed with this new knowledge of references, we will look at the SFML <strong class="source-inline">VertexArray</strong> class, which allows us to build up a large image that can be quickly and efficiently drawn to the screen using multiple parts in a single image file. By the end of this chapter, we will have a scalable, random, scrolling background that's been made using references and a <strong class="source-inline">VertexArray</strong> object.</p>
			<p>In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>C++ references</li>
				<li>SFML vertex arrays</li>
				<li>Coding a random, scrolling background</li>
			</ul>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor201"/>C++ references</h1>
			<p>When we pass values to a function or return values from a function, that is exactly what we are doing – passing/returning by <strong class="bold">value</strong>. What happens is that a copy of the value held by the variable is made and then sent to the function, where it is used. </p>
			<p>The significance of this is twofold:</p>
			<ol>
				<li>If we want the function to make a permanent change to a variable, this system is no good to us.</li>
				<li>When a copy is made to pass in as an argument or returned from the function, processing power and memory are consumed. For a simple <strong class="source-inline">int</strong>, or even perhaps a <strong class="source-inline">Sprite</strong>, this is insignificant. However, for a complex object, perhaps an entire game world (or background), the copying process will seriously affect our game's performance.</li>
			</ol>
			<p>References are the solution to these two problems. A <strong class="bold">reference</strong> is a special type of variable. A reference <em class="italic">refers</em> to another variable. Here is an example to help you understand this better:</p>
			<p class="source-code">int numZombies = 100;</p>
			<p class="source-code">int&amp; rNumZombies = numZombies;</p>
			<p>In the preceding code, we declare and initialize a regular <strong class="source-inline">int</strong> called <strong class="source-inline">numZombies</strong>. We then declare and initialize an <strong class="source-inline">int</strong> reference called <strong class="source-inline">rNumZombies</strong>. The reference operator, <strong class="source-inline">&amp;</strong>, which follows the type, determines that a reference is being declared.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">r</strong> prefix at the front of the reference name is optional but is useful for remembering that we are dealing with a reference.</p>
			<p>Now, we have an <strong class="source-inline">int</strong> variable called <strong class="source-inline">numZombies</strong>, which stores the value 100, and an <strong class="source-inline">int</strong> reference called <strong class="source-inline">rNumZombies</strong>, which refers to <strong class="source-inline">numZombies</strong>.</p>
			<p>Anything we do to <strong class="source-inline">numZombies</strong> can be seen through <strong class="source-inline">rNumZombies</strong>, and anything we do to <strong class="source-inline">rNumZombies</strong> we are actually doing to <strong class="source-inline">numZombies</strong>. Take a look at the following code:</p>
			<p class="source-code">int score = 10;</p>
			<p class="source-code">int&amp; rScore = score;</p>
			<p class="source-code">score ++;</p>
			<p class="source-code">rScore ++;</p>
			<p>In the previous code, we declare an <strong class="source-inline">int</strong> called <strong class="source-inline">score</strong>. Next, we declare an <strong class="source-inline">int</strong> reference called <strong class="source-inline">rScore</strong> that refers to <strong class="source-inline">score</strong>. Remember that anything we do to <strong class="source-inline">score</strong> can be seen by <strong class="source-inline">rScore</strong> and anything we do to <strong class="source-inline">rScore</strong> is actually being done to <strong class="source-inline">score</strong>.</p>
			<p>Therefore, consider what happens when we increment <strong class="source-inline">score</strong> like this:</p>
			<p class="source-code">score ++;</p>
			<p>The <strong class="source-inline">score</strong> variable now stores the value 11. In addition to this, if we were to output <strong class="source-inline">rScore</strong>, it would also output 11. The next line of code is as follows:</p>
			<p class="source-code">rScore ++;</p>
			<p>Now, <strong class="source-inline">score</strong> actually holds the value 12 because anything we do to <strong class="source-inline">rScore</strong> is actually done to <strong class="source-inline">score</strong>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to know <em class="italic">how</em> this works, then more will be revealed in the next chapter when we discuss <strong class="bold">pointers</strong>. But simply put, you can consider a reference as storing a place/address in the computer's memory. That place in memory is the same place where the variable it refers to stores its value. Therefore, an operation on either the reference or the variable has exactly the same effect.</p>
			<p>For now, it is much more important to talk about the <em class="italic">why</em> of references. There are two reasons to use references, and we have already mentioned them. Here they are, summarized again:</p>
			<ol>
				<li value="1">Changing/reading the value of a variable/object in another function, which is otherwise out of scope.</li>
				<li>Passing/returning to/from a function without making a copy (and, therefore, more efficiently).</li>
			</ol>
			<p>Study the following code and then we will discuss it:</p>
			<p class="source-code">void add(int n1, int n2, int a);</p>
			<p class="source-code">void referenceAdd(int n1, int n2, int&amp; a);</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    int number1 = 2;</p>
			<p class="source-code">    int number2 = 2;</p>
			<p class="source-code">    int answer = 0;</p>
			<p class="source-code">    </p>
			<p class="source-code">    add(number1, number2, answer);</p>
			<p class="source-code">    // answer still equals zero because it is passed as a copy</p>
			<p class="source-code">    // Nothing happens to answer in the scope of main</p>
			<p class="source-code">    referenceAdd(number1, number2, answer);</p>
			<p class="source-code">    // Now answer equals 4 because it was passed by reference</p>
			<p class="source-code">    // When the referenceAdd function did this:</p>
			<p class="source-code">    // answer = num1 + num 2;</p>
			<p class="source-code">    // It is actually changing the value stored by answer</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p class="source-code">// Here are the two function definitions</p>
			<p class="source-code">// They are exactly the same except that</p>
			<p class="source-code">// the second passes a reference to a</p>
			<p class="source-code">void add(int n1, int n2, int a)</p>
			<p class="source-code">{</p>
			<p class="source-code">    a = n1 + n2;</p>
			<p class="source-code">    // a now equals 4</p>
			<p class="source-code">    // But when the function returns a is lost forever</p>
			<p class="source-code">}</p>
			<p class="source-code">void referenceAdd(int n1, int n2, int&amp; a)</p>
			<p class="source-code">{</p>
			<p class="source-code">    a = n1 + n2;</p>
			<p class="source-code">    // a now equals 4</p>
			<p class="source-code">    // But a is a reference!</p>
			<p class="source-code">    // So, it is actually answer, back in main, that equals 4</p>
			<p class="source-code">}</p>
			<p>The previous code begins with the prototypes of two functions: <strong class="source-inline">add</strong> and <strong class="source-inline">referenceAdd</strong>. The <strong class="source-inline">add</strong> function takes three <strong class="source-inline">int</strong> variables while the <strong class="source-inline">referenceAdd</strong> function takes two <strong class="source-inline">int</strong> variables and an <strong class="source-inline">int</strong> reference.</p>
			<p>When the <strong class="source-inline">add</strong> function is called and the <strong class="source-inline">number1</strong>, <strong class="source-inline">number2</strong>, and <strong class="source-inline">answer</strong> variables are passed in, a copy of the values is made and new variables local to <strong class="source-inline">add</strong> (that is, <strong class="source-inline">n1</strong>, <strong class="source-inline">n2</strong>, and <strong class="source-inline">a</strong>) are manipulated. As a result of this, <strong class="source-inline">answer</strong>, back in <strong class="source-inline">main</strong>, remains at zero.</p>
			<p>When the <strong class="source-inline">referenceAdd</strong> function is called, <strong class="source-inline">number1</strong> and <strong class="source-inline">number2</strong> are again passed by value. However, <strong class="source-inline">answer</strong> is passed by reference. When the value of <strong class="source-inline">n1</strong> that's added to <strong class="source-inline">n2</strong> is assigned to the reference, <strong class="source-inline">a</strong>, what is really happening is that the value is assigned to <strong class="source-inline">answer</strong> back in the <strong class="source-inline">main</strong> function.</p>
			<p>It is probably obvious that we would never need to use a reference for something this simple. It does, however, demonstrate the mechanics of passing by reference.</p>
			<p>Let's summarize what we know about references.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor202"/>References summary</h2>
			<p>The previous code demonstrated how a reference can be used to alter the value of a variable in one scope using code in another. As well as being extremely convenient, passing by reference is also very efficient because no copy is made. Our example, that is, using a reference to an <strong class="source-inline">int</strong>, is a bit ambiguous because, as an <strong class="source-inline">int</strong> is so small, there is no real efficiency gain. Later on in this chapter, we will use a reference to pass an entire level layout and the efficiency gain will be significant.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There is one gotcha with references! You must assign the reference to a variable at the time you create it. This means it is not completely flexible. Don't worry about this for now. We will explore references further alongside their more flexible (and slightly more complicated) relations, such as <strong class="bold">pointers</strong>, in the next chapter.</p>
			<p>This is largely irrelevant for an <strong class="source-inline">int</strong>, but potentially significant for a large object of a class. We will use this exact technique when we implement the scrolling background of the Zombie Arena game later on in this chapter.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor203"/>SFML vertex arrays and sprite sheets</h1>
			<p>We are nearly ready to implement the scrolling background. We just need to learn about SFML vertex arrays and sprite sheets.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor204"/>What is a sprite sheet?</h2>
			<p>A <strong class="bold">sprite sheet</strong> is a set of images, either frames of animation, or totally individual graphics contained in one image file. Take a closer look at this sprite sheet, which contains four separate images that will be used to draw the background in our Zombie Arena game:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B14278_09_01.jpg" alt=""/>
				</div>
			</div>
			<p>SFML allows us to load a sprite sheet as a regular texture, in the same way we have done for every texture in this book so far. When we load multiple images as a single texture, the GPU can handle it much more efficiently.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Actually, a modern PC could handle these four textures without using a sprite sheet. It is worth learning these techniques, however, as our games are going to start getting progressively more demanding on our hardware.</p>
			<p>What we need to do when we draw an image from the sprite sheet is make sure we refer to the precise pixel coordinates of the part of the sprite sheet we require, like so:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B14278_09_02.jpg" alt=""/>
				</div>
			</div>
			<p>The previous diagram labels each part/tile with the coordinates and their position within the sprite sheet. These coordinates are called <strong class="bold">texture coordinates</strong>. We will use these texture coordinates in our code to draw just the right parts that we require.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor205"/>What is a vertex array?</h2>
			<p>First, we need to ask, what is a vertex? A <strong class="bold">vertex </strong>is a single graphical point, that is, a coordinate. This point is defined by a horizontal and vertical position. The plural of vertex is vertices. A vertex array, then, is a whole collection of vertices.</p>
			<p>In SFML, each vertex in a vertex array also has a color and a related additional vertex (that is, a pair of coordinates) called <strong class="bold">texture coordinates</strong>. Texture coordinates are the position of the image we want to use in terms of a sprite sheet. Later, we will see how we can position graphics and choose a part of the sprite sheet to display at each position, all with a single vertex array.</p>
			<p>The SFML <strong class="source-inline">VertexArray</strong> class can hold different types of vertex sets. But each <strong class="source-inline">VertexArray</strong> should only hold one type of set. We use the type of set that suits the occasion.</p>
			<p>Common scenarios in video games include, but are not limited to, the following <strong class="bold">primitive</strong> types:</p>
			<ul>
				<li><strong class="bold">Point</strong>: A single vertex per point.</li>
				<li><strong class="bold">Line</strong>: Two vertices per set that define the start and endpoint of the line.</li>
				<li><strong class="bold">Triangle</strong>: Three vertices per point. This is the most commonly used (in the thousands) for complex 3D models, or in pairs to create a simple rectangle such as a sprite.</li>
				<li><strong class="bold">Quad</strong>: Four vertices per set. This is a convenient way to map rectangular areas from a sprite sheet.</li>
			</ul>
			<p>We will use quads in this project.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor206"/>Building a background from tiles</h2>
			<p>The Zombie Arena background will be made up of a random arrangement of square images. You can think of this arrangement like tiles on a floor. </p>
			<p>In this project, we will be using vertex arrays with <strong class="bold">quad</strong> sets. Each vertex will be part of a set of four (that is, a quad). Each vertex will define one corner of a tile from our background, while each texture coordinate will hold an appropriate value based on a specific image from the sprite sheet.</p>
			<p>Let's look at some code to get us started. This isn't the exact code we will use in the project, but it is close and allows us to study vertex arrays before we move on to the actual implementation we will use.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor207"/>Building a vertex array</h2>
			<p>As we do when we create an instance of a class, we declare our new object. The following code declares a new object of the <strong class="source-inline">VertexArray</strong> type, called <strong class="source-inline">background</strong>:</p>
			<p class="source-code">// Create a vertex array</p>
			<p class="source-code">VertexArray background;</p>
			<p>We want to let our instance of <strong class="source-inline">VertexArray</strong> know which type of primitive we will be using. Remember that points, lines, triangles, and quads all have a different number of vertices. By setting the <strong class="source-inline">VertexArray</strong> instance to hold a specific type, it will be possible to know the start of each primitive. In our case, we want quads. Here is the code that will do this:</p>
			<p class="source-code">// What primitive type are we using</p>
			<p class="source-code">background.setPrimitiveType(Quads);</p>
			<p>As with regular C++ arrays, a <strong class="source-inline">VertexArray</strong> instance needs to be set to a particular size. The <strong class="source-inline">VertexArray</strong> class is more flexible than a regular array, however. It allows us to change its size while the game is running. The size could be configured at the same time as the declaration, but our background needs to expand with each wave. The <strong class="source-inline">VertexArray</strong> class provides this functionality with the <strong class="source-inline">resize</strong> function. Here is the code that would set the size of our arena to a 10 by 10 tile size:</p>
			<p class="source-code">// Set the size of the vertex array</p>
			<p class="source-code">background.resize(10 * 10 * 4);</p>
			<p>In the previous line of code, the first <strong class="source-inline">10</strong> is the width, the second <strong class="source-inline">10</strong> is the height, and 4 is the number of vertices in a quad. We could have just passed in 400, but showing the calculation like this makes it clear what we are doing. When we code the project for real, we will go a step further to aid clarity and declare variables for each part of the calculation.</p>
			<p>We now have a <strong class="source-inline">VertexArray</strong> instance ready to have its hundreds of vertices configured. Here is how we set the position coordinates on the first four vertices (that is, the first quad):</p>
			<p class="source-code">// Position each vertex in the current quad</p>
			<p class="source-code">background[0].position = Vector2f(0, 0);</p>
			<p class="source-code">background[1].position = Vector2f(49, 0);</p>
			<p class="source-code">background[2].position = Vector2f(49,49);</p>
			<p class="source-code">background[3].position = Vector2f(0, 49);</p>
			<p>Here is how we set the texture coordinates of these same vertices to the first image in the sprite sheet. These coordinates in the image file are from 0,0 (in the top-left corner) to 49,49 (in the bottom-right corner):</p>
			<p class="source-code">// Set the texture coordinates of each vertex</p>
			<p class="source-code">background[0].texCoords = Vector2f(0, 0);</p>
			<p class="source-code">background[1].texCoords = Vector2f(49, 0);</p>
			<p class="source-code">background[2].texCoords = Vector2f(49, 49);</p>
			<p class="source-code">background[3].texCoords = Vector2f(0, 49);</p>
			<p>If we wanted to set the texture coordinates to the second image in the sprite sheet, we would have written the code like this:</p>
			<p class="source-code">// Set the texture coordinates of each vertex</p>
			<p class="source-code">background[0].texCoords = Vector2f(0, 50);</p>
			<p class="source-code">background[1].texCoords = Vector2f(49, 50);</p>
			<p class="source-code">background[2].texCoords = Vector2f(49, 99);</p>
			<p class="source-code">background[3].texCoords = Vector2f(0, 99);</p>
			<p>Of course, if we define each and every vertex like this individually, then we are going to be spending a long time configuring even a simple 10 by 10 arena.</p>
			<p>When we implement our background for real, we will devise a set of nested <strong class="source-inline">for</strong> loops that loop through each quad, pick a random background image, and assign the appropriate texture coordinates.</p>
			<p>The code will need to be quite smart. It will need to know when it is an edge tile so that it can use the wall image from the sprite sheet. It will also need to use appropriate variables that know the position of each background tile in the sprite sheet, as well as the overall size of the required arena.</p>
			<p>We will make this complexity manageable by putting all the code in both a separate function and a separate file. We will make the <strong class="source-inline">VertexArray</strong> instance usable in <strong class="source-inline">main</strong> by using a C++ reference.</p>
			<p>We will examine these details later. You may have noticed that at no point have we associated a texture (the sprite sheet with the vertex array). Let's see how to do that now.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor208"/>Using the vertex array to draw</h2>
			<p>We can load the sprite sheet as a texture in the same way that we load any other texture, as shown in the following code:</p>
			<p class="source-code">// Load the texture for our background vertex array</p>
			<p class="source-code">Texture textureBackground;</p>
			<p class="source-code">textureBackground.loadFromFile("graphics/background_sheet.png");</p>
			<p>We can then draw the entire <strong class="source-inline">VertexArray</strong> with one call to <strong class="source-inline">draw</strong>: </p>
			<p class="source-code">// Draw the background</p>
			<p class="source-code">window.draw(background, &amp;textureBackground);</p>
			<p>The previous code is much more efficient than drawing every tile as an individual sprite.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Before we move on, notice the slightly odd-looking <strong class="source-inline">&amp;</strong> notation before the <strong class="source-inline">textureBackground</strong> code. Your immediate thought might be that this has something to do with references. What is going on here is we are passing the address of the <strong class="source-inline">Texture</strong> instance instead of the actual <strong class="source-inline">Texture</strong> instance. We will learn more about this in the next chapter.</p>
			<p>We are now able to use our knowledge of references and vertex arrays to implement the next stage of the Zombie Arena project.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor209"/>Creating a randomly generated scrolling background</h1>
			<p>In this section, we will create a function that makes a background in a separate file. We will ensure the background will be available (in scope) to the <strong class="source-inline">main</strong> function by using a vertex array reference.</p>
			<p>As we will be writing other functions that share data with the <strong class="source-inline">main</strong> function, we will write them all in their own <strong class="source-inline">.cpp</strong> files. We will provide prototypes for these functions in a new header file that we will include (with an <strong class="source-inline">#include</strong> directive) in <strong class="source-inline">ZombieArena.cpp</strong>. </p>
			<p>To achieve this, let's make a new header file called <strong class="source-inline">ZombieArena.h</strong>. We are now ready to code the header file for our new function.</p>
			<p>In this new <strong class="source-inline">ZombieArena.h</strong> header file, add the following highlighted code, including the function prototype:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code"><strong class="bold">using namespace sf;</strong></p>
			<p class="source-code"><strong class="bold">int createBackground(VertexArray&amp; rVA, IntRect arena);</strong></p>
			<p>The previous code allows us to write the definition of a function called <strong class="source-inline">createBackground</strong>. To match the prototype, the function definition must return an <strong class="source-inline">int</strong> value, and receive a <strong class="source-inline">VertexArray</strong> reference and an <strong class="source-inline">IntRect</strong> object as parameters.</p>
			<p>Now, we can create a new <strong class="source-inline">.cpp</strong> file in which we will code the function definition. Create a new file called <strong class="source-inline">CreateBackground.cpp</strong>. We are now ready to code the function definition that will create our background.</p>
			<p>Add the following code to the <strong class="source-inline">CreateBackground.cpp</strong> file, and then we will review it:</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">int createBackground(VertexArray&amp; rVA, IntRect arena)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Anything we do to rVA we are really doing</p>
			<p class="source-code">    // to background (in the main function)</p>
			<p class="source-code">    </p>
			<p class="source-code">    // How big is each tile/texture</p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p class="source-code">    const int TILE_TYPES = 3;</p>
			<p class="source-code">    const int VERTS_IN_QUAD = 4;</p>
			<p class="source-code">    int worldWidth = arena.width / TILE_SIZE;</p>
			<p class="source-code">    int worldHeight = arena.height / TILE_SIZE;</p>
			<p class="source-code">    // What type of primitive are we using?</p>
			<p class="source-code">    rVA.setPrimitiveType(Quads);</p>
			<p class="source-code">    // Set the size of the vertex array</p>
			<p class="source-code">    rVA.resize(worldWidth * worldHeight * VERTS_IN_QUAD);</p>
			<p class="source-code">    // Start at the beginning of the vertex array</p>
			<p class="source-code">    int currentVertex = 0;</p>
			<p class="source-code">    return TILE_SIZE;</p>
			<p class="source-code">}</p>
			<p>In the previous code, we write the function signature as well as the opening and closing curly brackets that mark the function body. </p>
			<p>Within the function body, we declare and initialize three new <strong class="source-inline">int</strong> constants to hold values that we will need to refer to throughout the rest of the function. They are <strong class="source-inline">TILE_SIZE</strong>, <strong class="source-inline">TILE_TYPES</strong>, and <strong class="source-inline">VERTS_IN_QUAD</strong>. </p>
			<p>The <strong class="source-inline">TILE_SIZE</strong> constant refers to the size in pixels of each tile within the sprite sheet. The <strong class="source-inline">TILE_TYPES</strong> constant refers to the number of different tiles within the sprite sheet. We could add more tiles into our sprite sheet and change <strong class="source-inline">TILE_TYPES</strong> to match the change, and the code we are about to write would still work. <strong class="source-inline">VERTS_IN_QUAD</strong> refers to the fact that there are four vertices in every quad. It is less error-prone to use this constant compared to always typing the number <strong class="source-inline">4</strong>, which is less clear.</p>
			<p>We then declare and initialize two <strong class="source-inline">int</strong> variables: <strong class="source-inline">worldWidth</strong> and <strong class="source-inline">worldHeight</strong>. These variables might appear obvious as to their use. They are betrayed by their names, but it is worth pointing out that they refer to the width and height of the world in the number of tiles, not pixels. The <strong class="source-inline">worldWidth</strong> and <strong class="source-inline">worldHeight</strong> variables are initialized by dividing the height and width of the passed-in arena by the <strong class="source-inline">TILE_SIZE</strong> constant.</p>
			<p>Next, we get to use our reference for the first time. Remember that anything we do to <strong class="source-inline">rVA</strong>, we are really doing to the variable that was passed in, which is in scope in the <strong class="source-inline">main</strong> function (or will be when we code it).</p>
			<p>Then, we prepare the vertex array to use quads using <strong class="source-inline">rVA.setType</strong> and then we make it just the right size by calling <strong class="source-inline">rVA.resize</strong>. To the <strong class="source-inline">resize</strong> function, we pass in the result of <strong class="source-inline">worldWidth * worldHeight * VERTS_IN_QUAD</strong>, which equates to exactly the number of vertices that our vertex array will have when we are done preparing it.</p>
			<p>The last line of code declares and initializes <strong class="source-inline">currentVertex</strong> to zero. We will use <strong class="source-inline">currentVertex</strong> as we loop through the vertex array, initializing all the vertices.</p>
			<p>We can now write the first part of a nested <strong class="source-inline">for</strong> loop that will prepare the vertex array. Add the following highlighted code and, based on what we have learned about vertex arrays, try and work out what it does:</p>
			<p class="source-code">    // Start at the beginning of the vertex array</p>
			<p class="source-code">    int currentVertex = 0;</p>
			<p class="source-code"><strong class="bold">    for (int w = 0; w &lt; worldWidth; w++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        for (int h = 0; h &lt; worldHeight; h++)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // Position each vertex in the current quad</strong></p>
			<p class="source-code"><strong class="bold">            rVA[currentVertex + 0].position = </strong></p>
			<p class="source-code"><strong class="bold">                Vector2f(w * TILE_SIZE, h * TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                </strong></p>
			<p class="source-code"><strong class="bold">            rVA[currentVertex + 1].position =</strong></p>
			<p class="source-code"><strong class="bold">                Vector2f((w * TILE_SIZE) + TILE_SIZE, h * TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                </strong></p>
			<p class="source-code"><strong class="bold">            rVA[currentVertex + 2].position =</strong></p>
			<p class="source-code"><strong class="bold">                Vector2f((w * TILE_SIZE) + TILE_SIZE, (h * TILE_SIZE) </strong></p>
			<p class="source-code"><strong class="bold">                + TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                </strong></p>
			<p class="source-code"><strong class="bold">            rVA[currentVertex + 3].position =</strong></p>
			<p class="source-code"><strong class="bold">                Vector2f((w * TILE_SIZE), (h * TILE_SIZE) </strong></p>
			<p class="source-code"><strong class="bold">                + TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                </strong></p>
			<p class="source-code"><strong class="bold">            </strong></p>
			<p class="source-code"><strong class="bold">            // Position ready for the next four vertices</strong></p>
			<p class="source-code"><strong class="bold">            currentVertex = currentVertex + VERTS_IN_QUAD;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    return TILE_SIZE;</p>
			<p class="source-code">}</p>
			<p>The code that we just added steps through the vertex array by using a nested <strong class="source-inline">for</strong> loop, which first steps through the first four vertices: <strong class="source-inline">currentVertex + 1</strong>,<strong class="source-inline"> currentVertex + 2</strong>, and so on. </p>
			<p>We access each vertex in the array using the array notation, <strong class="source-inline">rvA[currentVertex + 0]..</strong>, and so on. Using the array notation, we call the <strong class="source-inline">position</strong> function, <strong class="source-inline">rvA[currentVertex + 0].position...</strong>.</p>
			<p>To the <strong class="source-inline">position</strong> function, we pass the horizontal and vertical coordinates of each vertex. We can work these coordinates out programmatically by using a combination of <strong class="source-inline">w</strong>, <strong class="source-inline">h</strong>, and <strong class="source-inline">TILE_SIZE</strong>. </p>
			<p>At the end of the previous code, we position <strong class="source-inline">currentVertex</strong>, ready for the next pass through the nested <strong class="source-inline">for</strong> loop by advancing it four places (that is, adding four) with the code, that is, <strong class="source-inline">currentVertex = currentVertex + VERTS_IN_QUAD</strong>.</p>
			<p>Of course, all this does is set the coordinates of our vertices; it doesn't assign a texture coordinate from the sprite sheet. This is what we will do next.</p>
			<p>To make it absolutely clear where the new code goes, I have shown it in context, along with all the code that we wrote a moment ago. Add and study the following highlighted code:</p>
			<p class="source-code">for (int w = 0; w &lt; worldWidth; w++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int h = 0; h &lt; worldHeight; h++)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Position each vertex in the current quad</p>
			<p class="source-code">            rVA[currentVertex + 0].position = </p>
			<p class="source-code">                Vector2f(w * TILE_SIZE, h * TILE_SIZE);</p>
			<p class="source-code">                </p>
			<p class="source-code">            rVA[currentVertex + 1].position =</p>
			<p class="source-code">                Vector2f((w * TILE_SIZE) + TILE_SIZE, h * TILE_SIZE);</p>
			<p class="source-code">                </p>
			<p class="source-code">            rVA[currentVertex + 2].position =</p>
			<p class="source-code">                Vector2f((w * TILE_SIZE) + TILE_SIZE, (h * TILE_SIZE) </p>
			<p class="source-code">                + TILE_SIZE);</p>
			<p class="source-code">                </p>
			<p class="source-code">            rVA[currentVertex + 3].position =</p>
			<p class="source-code">                Vector2f((w * TILE_SIZE), (h * TILE_SIZE) </p>
			<p class="source-code">                + TILE_SIZE);</p>
			<p class="source-code">                </p>
			<p class="source-code">            </p>
			<p class="source-code"><strong class="bold">            // Define the position in the Texture for current quad</strong></p>
			<p class="source-code"><strong class="bold">            // Either grass, stone, bush or wall</strong></p>
			<p class="source-code"><strong class="bold">            if (h == 0 || h == worldHeight-1 || </strong></p>
			<p class="source-code"><strong class="bold">                w == 0 || w == worldWidth-1)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                // Use the wall texture</strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 0].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(0, 0 + TILE_TYPES * TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                    </strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 1].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(TILE_SIZE, 0 + </strong></p>
			<p class="source-code"><strong class="bold">                    TILE_TYPES * TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                    </strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 2].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(TILE_SIZE, TILE_SIZE + </strong></p>
			<p class="source-code"><strong class="bold">                    TILE_TYPES * TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">                    </strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 3].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(0, TILE_SIZE + </strong></p>
			<p class="source-code"><strong class="bold">                    TILE_TYPES * TILE_SIZE);</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code">            </p>
			<p class="source-code">            // Position ready for the next for vertices</p>
			<p class="source-code">            currentVertex = currentVertex + VERTS_IN_QUAD;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return TILE_SIZE;</p>
			<p class="source-code">}</p>
			<p>The preceding highlighted code sets up the coordinates within the sprite sheet that each vertex is related to. Notice the somewhat long <strong class="source-inline">if</strong> condition. The condition checks whether the current quad is either one of the very first or the very last quads in the arena. If it is (one of the first or last), then this means it is part of the boundary. We can then use a simple formula using <strong class="source-inline">TILE_SIZE</strong> and <strong class="source-inline">TILE_TYPES</strong> to target the wall texture from the sprite sheet.</p>
			<p>The array notation and the <strong class="source-inline">texCoords</strong> member are initialized for each vertex, in turn, to assign the appropriate corner of the wall texture within the sprite sheet.</p>
			<p>The following code is wrapped in an <strong class="source-inline">else</strong> block. This means that it will run through the nested <strong class="source-inline">for</strong> loop each time the quad does not represent a border/wall tile. Add the following highlighted code among the existing code, and then we will examine it:</p>
			<p class="source-code">            // Define position in Texture for current quad</p>
			<p class="source-code">            // Either grass, stone, bush or wall</p>
			<p class="source-code">            if (h == 0 || h == worldHeight-1 ||</p>
			<p class="source-code">                w == 0 || w == worldWidth-1)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                // Use the wall texture</p>
			<p class="source-code">                rVA[currentVertex + 0].texCoords = </p>
			<p class="source-code">                    Vector2f(0, 0 + TILE_TYPES * TILE_SIZE);</p>
			<p class="source-code">                    </p>
			<p class="source-code">                rVA[currentVertex + 1].texCoords = </p>
			<p class="source-code">                    Vector2f(TILE_SIZE, 0 + </p>
			<p class="source-code">                    TILE_TYPES * TILE_SIZE);</p>
			<p class="source-code">                    </p>
			<p class="source-code">                rVA[currentVertex + 2].texCoords = </p>
			<p class="source-code">                    Vector2f(TILE_SIZE, TILE_SIZE + </p>
			<p class="source-code">                    TILE_TYPES * TILE_SIZE);</p>
			<p class="source-code">                    </p>
			<p class="source-code">                rVA[currentVertex + 3].texCoords = </p>
			<p class="source-code">                    Vector2f(0, TILE_SIZE + </p>
			<p class="source-code">                    TILE_TYPES * TILE_SIZE);</p>
			<p class="source-code">            }</p>
			<p class="source-code"><strong class="bold">            else</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                // Use a random floor texture</strong></p>
			<p class="source-code"><strong class="bold">                srand((int)time(0) + h * w - h);</strong></p>
			<p class="source-code"><strong class="bold">                int mOrG = (rand() % TILE_TYPES);</strong></p>
			<p class="source-code"><strong class="bold">                int verticalOffset = mOrG * TILE_SIZE;</strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 0].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(0, 0 + verticalOffset);</strong></p>
			<p class="source-code"><strong class="bold">                    </strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 1].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(TILE_SIZE, 0 + verticalOffset);</strong></p>
			<p class="source-code"><strong class="bold">                    </strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 2].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(TILE_SIZE, TILE_SIZE + verticalOffset);</strong></p>
			<p class="source-code"><strong class="bold">                    </strong></p>
			<p class="source-code"><strong class="bold">                rVA[currentVertex + 3].texCoords = </strong></p>
			<p class="source-code"><strong class="bold">                    Vector2f(0, TILE_SIZE + verticalOffset);</strong></p>
			<p class="source-code"><strong class="bold">            }            </strong></p>
			<p class="source-code">            // Position ready for the next for vertices</p>
			<p class="source-code">            currentVertex = currentVertex + VERTS_IN_QUAD;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return TILE_SIZE;</p>
			<p class="source-code">}</p>
			<p>The preceding highlighted code starts by seeding the random number generator with a formula that will be different in each pass through the loop. Then, the <strong class="source-inline">mOrG</strong> variable is initialized with a number between 0 and <strong class="source-inline">TILE_TYPES</strong>. This is just what we need to pick one of the tile types randomly. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="source-inline">mOrG</strong> stands for "mud or grass". The name is arbitrary.</p>
			<p>Now, we declare and initialize a variable called <strong class="source-inline">verticalOffset</strong> by multiplying <strong class="source-inline">mOrG</strong> by <strong class="source-inline">TileSize</strong>. We now have a vertical reference point within the sprite sheet to the starting height of the randomly chosen texture for the current quad.</p>
			<p>Now, we use a simple formula involving <strong class="source-inline">TILE_SIZE</strong> and <strong class="source-inline">verticalOffset</strong> to assign the precise coordinates of each corner of the texture to the appropriate vertex.</p>
			<p>We can now put our new function to work in the game engine.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor210"/>Using the background</h1>
			<p>We have done the tricky stuff, so this will be simple. There are three steps, as follows: </p>
			<ol>
				<li value="1">Create a <strong class="source-inline">VertexArray</strong>.</li>
				<li>Initialize it after leveling up each wave.</li>
				<li>Draw it in each frame. </li>
			</ol>
			<p>Add the following highlighted code to declare a <strong class="source-inline">VertexArray</strong> instance called <strong class="source-inline">background</strong> and load the <strong class="source-inline">background_sheet.png</strong> file as a texture:</p>
			<p class="source-code">// Create an instance of the Player class</p>
			<p class="source-code">Player player;</p>
			<p class="source-code">// The boundaries of the arena</p>
			<p class="source-code">IntRect arena;</p>
			<p class="source-code"><strong class="bold">// Create the background</strong></p>
			<p class="source-code"><strong class="bold">VertexArray background;</strong></p>
			<p class="source-code"><strong class="bold">// Load the texture for our background vertex array</strong></p>
			<p class="source-code"><strong class="bold">Texture textureBackground;</strong></p>
			<p class="source-code"><strong class="bold">textureBackground.loadFromFile("graphics/background_sheet.png");</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>Add the following code to call the <strong class="source-inline">createBackground</strong> function, passing in <strong class="source-inline">background</strong> as a reference and <strong class="source-inline">arena</strong> by value. Notice that, in the highlighted code, we have also modified the way that we initialize the <strong class="source-inline">tileSize</strong> variable. Add the highlighted code exactly as shown:</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Prepare the level</p>
			<p class="source-code">    // We will modify the next two lines later</p>
			<p class="source-code">    arena.width = 500;</p>
			<p class="source-code">    arena.height = 500;</p>
			<p class="source-code">    arena.left = 0;</p>
			<p class="source-code">    arena.top = 0;</p>
			<p class="source-code"><strong class="bold">    // Pass the vertex array by reference </strong></p>
			<p class="source-code"><strong class="bold">    // to the createBackground function</strong></p>
			<p class="source-code"><strong class="bold">    int tileSize = createBackground(background, arena);</strong></p>
			<p class="source-code">    // We will modify this line of code later</p>
			<p class="source-code"><strong class="bold">    // int tileSize = 50;</strong></p>
			<p class="source-code">    // Spawn the player in the middle of the arena</p>
			<p class="source-code">    player.spawn(arena, resolution, tileSize);</p>
			<p class="source-code">    // Reset the clock so there isn't a frame jump</p>
			<p class="source-code">    clock.restart();</p>
			<p class="source-code">}</p>
			<p>Note that we have replaced the <strong class="source-inline">int tileSize = 50</strong> line of code because we get the value directly from the return value of the <strong class="source-inline">createBackground</strong> function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For the sake of future code clarity, you should delete the <strong class="source-inline">int tileSize = 50</strong> line of code and its related comment. I just commented it out to give the new code a clearer context.</p>
			<p>Finally, it is time to do the drawing. This is really simple. All we do is call <strong class="source-inline">window.draw</strong> and pass the <strong class="source-inline">VertexArray</strong> instance, along with the <strong class="source-inline">textureBackground</strong> texture:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> Draw the scene</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.clear();</p>
			<p class="source-code">    // Set the mainView to be displayed in the window</p>
			<p class="source-code">    // And draw everything related to it</p>
			<p class="source-code">    window.setView(mainView);</p>
			<p class="source-code"><strong class="bold">    // Draw the background</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(background, &amp;textureBackground);</strong></p>
			<p class="source-code">    // Draw the player</p>
			<p class="source-code">    window.draw(player.getSprite());</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are wondering what is going on with the odd-looking <strong class="source-inline">&amp;</strong> sign in front of <strong class="source-inline">textureBackground</strong>, then all will be made clear in the next chapter.</p>
			<p>You can now run the game. You will see the following output:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B14278_09_03.jpg" alt=""/>
				</div>
			</div>
			<p>He<a id="_idTextAnchor211"/>re, note how the player sprite glides and rotates smoothly within the arena's confines. Although the current code in the <strong class="source-inline">main</strong> function draws a small arena, the <strong class="source-inline">CreateBackground</strong> function can create an arena of any size. We will see arenas bigger than the screen in <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>,<em class="italic"> Sound Effects, File I/O, and Finishing the Game</em>.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor212"/>Summary</h1>
			<p>In this chapter, we discovered C++ references, which are special variables that act as an alias to another variable. When we pass a variable by reference instead of by value, then anything we do on the reference happens to the variable back in the calling function.</p>
			<p>We also learned about vertex arrays and created a vertex array full of quads to draw the tiles from a sprite sheet as a background.</p>
			<p>The elephant in the room, of course, is that our zombie game doesn't have any zombies. We'll fix that in the next chapter by learning about C++ pointers and the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>).</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor213"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) Can you summarize these references again?</p>
			<p>A) You must initialize a reference immediately, and it cannot be changed to reference another variable. Use references with functions so you are not working on a copy. This is good for efficiency because it avoids making copies and helps us abstract our code into functions more easily.</p>
			<p>Q) Is there an easy way to remember the main benefit of using references?</p>
			<p>A) To help you remember what a reference is used for, consider this short rhyme: </p>
			<p><em class="italic">        Moving large objects can make our games choppy, </em></p>
			<p><em class="italic">        passing by reference is faster than copy.</em></p>
		</div>
	</body></html>