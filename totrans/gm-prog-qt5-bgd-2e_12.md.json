["```cpp\nimport QtQuick 2.9\nimport QtQuick.Window 2.2\n\nWindow {\n    visible: true\n    width: 640\n    height: 480\n    title: qsTr(\"Hello World\")\n\n    Rectangle {\n        id: button\n        anchors.centerIn: parent\n        border { width: 1; color: \"black\" }\n        radius: 5\n        width: 100; height: 30\n        gradient: Gradient {\n            GradientStop { position: 0; color: \"#eeeeee\" }\n            GradientStop { position: 1; color: \"#777777\" }\n        }\n    }\n}\n```", "```cpp\nRectangle {\n    id: button\n    anchors.centerIn: parent\n    border { width: 1; color: \"black\" }\n    radius: 5\n    gradient: Gradient {\n        GradientStop { position: 0; color: \"#eeeeee\" }\n        GradientStop { position: 1; color: \"#777777\" }\n    }\n    width: buttonContent.width + 8\n    height: buttonContent.height + 8\n\n    Row {\n        id: buttonContent\n        anchors.centerIn: parent\n        spacing: 4\n\n        Image {\n            id: buttonIcon\n            source: \"qrc:/edit-undo.png\"\n        }\n        Text {\n            id: buttonText\n            text: \"ButtonText\"\n        }\n    }\n}\n```", "```cpp\nclip: true\nimplicitWidth: Math.max(buttonContent.implicitWidth + 8, 80)\nimplicitHeight: buttonContent.implicitHeight + 8 \n```", "```cpp\nWindow {\n    visible: true\n    width: 640\n    height: 480\n    title: qsTr(\"Hello World\")\n\n    Button {\n        id: button\n        anchors.centerIn: parent\n    }\n}\n```", "```cpp\nimport \"Bar\" \n```", "```cpp\nimport \"Foo/Bar\" \n```", "```cpp\nRectangle {\n    id: button\n    // ...\n    Row { ... }\n    MouseArea {\n        id: buttonMouseArea\n        anchors.fill: parent\n        onClicked: button.clicked()\n    }\n} \n```", "```cpp\nRectangle {\n    id: button\n    signal clicked()\n    // ...\n} \n```", "```cpp\nButton {\n    id: button\n    anchors.centerIn: parent\n    onClicked: console.log(\"Clicked!\")\n}\n```", "```cpp\nRow {\n    id: buttonContent\n    // ...\n    anchors.verticalCenterOffset: buttonMouseArea.pressed ? 1 : 0\n    anchors.horizontalCenterOffset: buttonMouseArea.pressed ? 1 : 0\n    // ...\n} \n```", "```cpp\nhoverEnabled: true \n```", "```cpp\nText {\n  id: buttonText\n  text: \"ButtonText\"\n  color: buttonMouseArea.containsMouse ? \"white\" : \"black\"\n} \n```", "```cpp\nMouseArea {\n    id: buttonMouseArea\n    anchors.fill: parent\n    hoverEnabled: true\n    acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton\n    onClicked: {\n        switch(mouse.button) {\n            case Qt.LeftButton:\n                console.log(\"Left button clicked\"); break;\n            case Qt.MiddleButton:\n                console.log(\"Middle button clicked\"); break;\n            case Qt.RightButton:\n                console.log(\"Right button clicked\"); break;\n        }\n    }\n    onPositionChanged: {\n        console.log(\"Position: [\" + mouse.x + \"; \" + mouse.y + \"]\");\n    }\n} \n```", "```cpp\nRectangle {\n    id: button\n    property color topColor: \"#eeeeee\"\n    property color bottomColor: \"#777777\"\n    property color textColor: \"black\"\n    property color textPressedColor: \"white\"\n    signal clicked() \n```", "```cpp\ngradient: Gradient {\n    GradientStop { position: 0; color: button.topColor }\n    GradientStop { position: 1; color: button.bottomColor }\n} \n```", "```cpp\nText {\n    id: buttonText\n    text: \"ButtonText\"\n    color: buttonMouseArea.pressed ?\n        button.textPressedColor : button.textColor\n} \n```", "```cpp\nproperty alias pressed: buttonMouseArea.pressed \n```", "```cpp\nproperty int foo: someobject.prop\nproperty alias bar: someobject.prop \n```", "```cpp\n  foo = 7\n  bar = 7 \n```", "```cpp\nButton {\n    // ...\n\n    onPressedChanged: {\n        console.log(\"The button is currently \" +\n                    (pressed ? \"\" : \"not \") + \"pressed\")\n    }\n}\n```", "```cpp\nRectangle {\n    id: circle\n    width: 60; height: width\n    radius: width / 2\n    color: \"red\"\n} \n```", "```cpp\nRectangle {\n    //...\n    MouseArea {\n        anchors.fill: parent\n        drag.target: circle\n    }\n}\n```", "```cpp\nImage {\n    id: image\n    anchors.centerIn: parent\n    source: \"qrc:/wilanow.jpg\"\n}\n```", "```cpp\nPinchArea {\n    anchors.fill: parent\n    pinch {\n        target: image\n        minimumScale: 0.2\n        maximumScale: 2.0\n        minimumRotation: -90\n        maximumRotation: 90\n    }\n}\n```", "```cpp\nfocus: true \n```", "```cpp\nRectangle {\n    focus: true\n    color: \"black\"\n    width: 100\n    height: 100\n    Keys.onPressed: {\n        if(event.key === Qt.Key_Space) {\n             color = \"red\";\n        }\n    }\n    Keys.onReleased: {\n        if(event.key === Qt.Key_Space) {\n            color = \"blue\";\n        }\n    }\n}\n```", "```cpp\nRectangle {\n    //...\n    focus: true\n    Keys.onSpacePressed:      color = \"purple\"\n    Keys.onReturnPressed:     color = \"navy\"\n    Keys.onVolumeUpPressed:   color = \"blue\"\n    Keys.onRightPressed:      color = \"green\"\n    Keys.onEscapePressed:     color = \"yellow\"\n    Keys.onTabPressed:        color = \"orange\"\n    Keys.onDigit0Pressed:     color = \"red\"\n} \n```", "```cpp\nItem {\n    id: item\n    property int number: 0\n    width: 200; height: width\n    focus: true\n Keys.onSpacePressed: {\n number++;\n }\n    Text {\n        text: item.number\n        anchors.centerIn: parent\n    }\n}\n```", "```cpp\nKeys.onSpacePressed: {\n    if(!event.isAutoRepeat) {\n        number++;\n    }\n}\n```", "```cpp\nKeys.onPressed: {\n    if(event.key === Qt.Key_Space) {\n        color = \"blue\";\n        event.accepted = true;\n    }\n}\n```", "```cpp\nRow {\n    spacing: 5\n    Rectangle {\n        id: first\n        width: 50; height: width\n        color: focus ? \"blue\" : \"lightgray\"\n        focus: true\n        KeyNavigation.right: second\n    }\n    Rectangle {\n        id: second\n        width: 50; height: width\n        color: focus ? \"blue\" : \"lightgray\"\n        KeyNavigation.right: third\n    }\n    Rectangle {\n        id: third\n        width: 50; height: width\n        color: focus ? \"blue\" : \"lightgray\"\n    }\n} \n```", "```cpp\nTextInput {\n    id: ipAddress\n    width: 100\n    validator: RegExpValidator {\n        // four numbers separated by dots\n        regExp: /\\d+\\.\\d+\\.\\d+\\.\\d+/\n    }\n    focus: true\n} \n```", "```cpp\nRectangle {\n  id: textInputFrame\n  width: 200\n  height: 40\n  border { color: \"black\"; width: 2 }\n  radius: 10\n  antialiasing: true\n  color: \"darkGray\"\n}\nTextInput {\n  id: textInput\n  anchors.fill: textInputFrame\n  anchors.margins: 5\n  font.pixelSize: height-2\n  verticalAlignment: TextInput.AlignVCenter\n  clip: true\n} \n```", "```cpp\nimport QtGamepad 1.0\n```", "```cpp\n Gamepad {\n     id: gamepad\n     deviceId: GamepadManager.connectedGamepads.length > 0 ? \n         GamepadManager.connectedGamepads[0] : -1\n }\n```", "```cpp\n    Connections {\n        target: GamepadManager\n        onGamepadConnected: gamepad.deviceId = deviceId\n    }\n```", "```cpp\nText {\n    text: gamepad.buttonStart ? \"Start!\" : \"\"\n}\n```", "```cpp\nGamepad {\n    //...\n    onButtonStartChanged: {\n        if (value) {\n            console.log(\"start pressed\");\n        } else {\n            console.log(\"start released\");\n        }\n    }\n}\n```", "```cpp\nGamepadKeyNavigation {\n    gamepad: gamepad\n    active: true\n    buttonStartKey: Qt.Key_S\n}\n```", "```cpp\nimport QtSensors 5.0\n```", "```cpp\nimport QtQuick 2.9\nimport QtQuick.Window 2.2\nimport QtSensors 5.0\nWindow {\n    visible: true\n    width: 640\n    height: 480\n    title: qsTr(\"Hello World\")\n    Text {\n        anchors.centerIn: parent\n        text: {\n            if (!tiltSensor.reading) {\n                return \"No data\";\n            }\n            var x = tiltSensor.reading.xRotation;\n            var y = tiltSensor.reading.yRotation;\n            return \"X: \" + Math.round(x) +\n                   \" Y: \" + Math.round(y)\n        }\n    }\n    TiltSensor {\n        id: tiltSensor\n        active: true\n        onReadingChanged: {\n            // process new reading\n        }\n    }\n}\n```", "```cpp\nimport QtQuick 2.9\nimport QtQuick.Window 2.2\nimport QtPositioning 5.0\nWindow {\n    visible: true\n    width: 640\n    height: 480\n    title: qsTr(\"Hello World\")\n    Text {\n        anchors.centerIn: parent\n        text: {\n            var pos = positionSource.position;\n            var coordinate = pos.coordinate;\n            return \"latitude: \" + coordinate.latitude +\n              \"\\nlongitude: \" + coordinate.longitude;\n        }\n    }\n    PositionSource {\n        id: positionSource\n        active: true\n        onPositionChanged: {\n            console.log(\"pos changed\",\n                        position.coordinate.latitude,\n                        position.coordinate.longitude);\n        }\n    }\n}\n```", "```cpp\nWindow {\n    visible: true\n    width: 640\n    height: 480\n    title: qsTr(\"Hello World\")\n\n    Clock {\n        id: clock\n        anchors {\n            fill: parent\n            margins: 20\n        }\n    }\n}\n```", "```cpp\nimport QtQuick 2.9\n\nItem {\n    id: clock\n\n    property color color: \"lightgray\"\n\n    Rectangle {\n        id: plate\n\n        anchors.centerIn: parent\n        width: Math.min(clock.width, clock.height)\n        height: width\n        radius: width / 2\n        color: clock.color\n        border.color: Qt.darker(color)\n        border.width: 2\n    }\n} \n```", "```cpp\nRepeater {\n    model: 12\n\n    Item {\n        id: hourContainer\n\n        property int hour: index\n        height: plate.height / 2\n        transformOrigin: Item.Bottom\n        rotation: index * 30\n        x: plate.width/2\n        y: 0\n\n        Rectangle {\n            width: 2\n            height: (hour % 3 == 0) ? plate.height * 0.1\n                                    : plate.height * 0.05\n            color: plate.border.color\n            antialiasing: true\n            anchors.horizontalCenter: parent.horizontalCenter\n            anchors.top: parent.top\n            anchors.topMargin: 4\n        }\n    }\n} \n```", "```cpp\nimport QtQuick 2.9\n\nRectangle {\n    id: root\n\n    property int value: 0\n    property int granularity: 60\n    property alias length: root.height\n\n    width: 2\n    height: parent.height / 2\n    radius: width / 2\n    antialiasing: true\n    anchors.bottom: parent.verticalCenter\n    anchors.horizontalCenter: parent.horizontalCenter\n    transformOrigin: Item.Bottom\n    rotation: 360 / granularity * (value % granularity)\n} \n```", "```cpp\nNeedle {\n    length: plate.height * 0.3\n    color: \"blue\"\n    value: clock.hours\n    granularity: 12\n}\nNeedle {\n    length: plate.height * 0.4\n    color: \"darkgreen\"\n    value: clock.minutes\n    granularity: 60\n}\nNeedle {\n    width: 1\n    length: plate.height * 0.45\n    color: \"red\"\n    value: clock.seconds\n    granularity: 60\n} \n```", "```cpp\nproperty int hours: 0\nproperty int minutes: 0\nproperty int seconds: 0 \n```", "```cpp\nimport QtQuick 2.9\n\nClock {\n    //...\n    hours: 7\n    minutes: 42\n    seconds: 17\n} \n```", "```cpp\nvar currentDate = new Date();\nvar hours   = currentDate.getHours();\nvar minutes = currentDate.getMinutes();\nvar seconds = currentDate.getSeconds();\n```", "```cpp\nItem {\n    id: clock\n    property int hours:   currentDate.getHours()\n    property int minutes: currentDate.getMinutes()\n    property int seconds: currentDate.getSeconds()\n    property date currentDate: new Date()\n    // ...\n} \n```", "```cpp\nItem {\n    id: clock\n    //...\n    property alias running: timer.running\n    Timer {\n        id: timer\n        repeat: true\n        interval: 500\n        running: true\n        onTriggered: clock.currentDate = new Date()\n    }\n    //...\n} \n```", "```cpp\nComponent {\n    id: circleComponent\n    Item {\n        //...\n    }\n} \n```", "```cpp\nimport QtQuick 2.9\nItem {\n    property int diameter: 20\n    property alias color: rect.color\n    property alias border: rect.border\n\n    implicitWidth: diameter\n    implicitHeight: diameter\n\n    Rectangle {\n        id: rect\n        width: radius\n        height: radius\n        radius: diameter / 2\n        anchors.centerIn: parent\n    }\n}\n```", "```cpp\nvar circleComponent = Qt.createComponent(\"Circle.qml\"); \n```", "```cpp\nWindow {\n    //...\n    Component.onCompleted: {\n        var circleComponent = Qt.createComponent(\"Circle.qml\");\n if(circleComponent.status === Component.Ready) {\n addCircles(circleComponent);\n } else {\n circleComponent.statusChanged.connect(function() {\n if(circleComponent.status === Component.Ready) {\n addCircles(circleComponent);\n }\n });\n }\n    }\n}\n```", "```cpp\nif(circleComponent.status === Component.Error) {\n    console.warn(circleComponent.errorString());\n} \n```", "```cpp\nWindow {\n    //...\n    ColumnLayout {\n        id: layout\n        anchors.fill: parent\n    }\n    function addCircles(circleComponent) {\n        [\"red\", \"yellow\", \"green\"].forEach(function(color) {\n var circle = circleComponent.createObject(layout);\n circle.color = color;\n circle.Layout.alignment = Qt.AlignCenter;\n        });\n    }\n    //...\n}\n```", "```cpp\nvar circle = circleComponent.createObject(layout,\n    { diameter: 20, color: 'red' });\n```", "```cpp\nLoader {\n    id: loader\n}\n//...\nonSomeSignal: loader.source = \"Circle.qml\"\n```", "```cpp\nLoader {\n    id: loader\n    sourceComponent: shouldBeLoaded ? circleComponent : undefined\n} \n```", "```cpp\nLoader {\n    anchors {\n        left: parent.left\n        leftMargin: 0.2 * parent.width\n        right: parent.right\n        verticalCenter: parent.verticalCenter\n    }\n    height: 250\n    source: \"Circle.qml\"\n} \n```", "```cpp\nWindow {\n    //...\n    Canvas {\n        id: canvas\n\n        implicitWidth: 600\n        implicitHeight: 300\n\n        onPaint: {\n            var ctx = canvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.strokeRect(50, 50, 100, 100);\n        }\n    }\n}\n```", "```cpp\nproperty int lineWidth: 2\nproperty var points: []\nproperty real arg: -Math.PI \n```", "```cpp\nTimer {\n    interval: 10\n    repeat: true\n    running: true\n    onTriggered: {\n        canvas.arg += Math.PI / 180;\n        while(canvas.arg >= Math.PI) {\n            canvas.arg -= 2 * Math.PI;\n        }\n    }\n}\n```", "```cpp\nonArgChanged: {\n    points.push(func(arg));\n    points = points.slice(-canvas.width);\n    canvas.requestPaint();\n}\n```", "```cpp\nfunction func(argument) {\n    var a = (2 * Math.PI / 10);\n    var b = 4 * Math.PI / 5;\n    return Math.sin(20 * argument) * (\n        Math.exp(-Math.pow(argument / a, 2)) +\n        Math.exp(-Math.pow((argument - b) / a, 2)) +\n        Math.exp(-Math.pow((argument + b) / a, 2))\n    );\n}\n```", "```cpp\nonPaint: {\n    var ctx = canvas.getContext(\"2d\");\n    ctx.reset();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    var pointsToDraw = points.slice(-canvas.width);\n    ctx.translate(0, canvas.height / 2);\n    ctx.beginPath();\n    ctx.moveTo(0, -pointsToDraw[0] * canvas.height / 2);\n    for(var i = 1; i < pointsToDraw.length; i++) {\n        ctx.lineTo(i, -pointsToDraw[i] * canvas.height / 2);\n    }\n    ctx.lineWidth = canvas.lineWidth;\n    ctx.stroke();\n}\n```", "```cpp\nCanvas {\n    id: canvas\n    property int lineWidth: 2\n    //...\n    QtObject {\n        id: d\n        property var points: []\n        property real arg: -Math.PI\n\n        function func(argument) { /* ... */ }\n        onArgChanged: { /* ... */ }\n    }\n    //...\n}\n```", "```cpp\nonTriggered: {\n    d.arg += Math.PI / 180;\n    while(d.arg >= Math.PI) {\n        d.arg -= 2 * Math.PI;\n    }\n}\n```", "```cpp\nproperty color color: \"black\"\nproperty color topColor: \"red\"\nproperty color bottomColor: \"blue\"\n```", "```cpp\nonPaint: {\n    //...\n    // fill:\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    var i;\n    for(i = 0; i < pointsToDraw.length; i++) {\n        ctx.lineTo(i, -pointsToDraw[i] * canvas.height/2);\n    }\n    ctx.lineTo(i, 0);\n    var gradient = ctx.createLinearGradient(\n            0, -canvas.height / 2, 0, canvas.height / 2);\n    gradient.addColorStop(0.1, canvas.topColor);\n    gradient.addColorStop(0.5, Qt.rgba(1, 1, 1, 0));\n    gradient.addColorStop(0.9, canvas.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fill();\n\n    // stroke:\n    ctx.beginPath();\n    ctx.moveTo(0, -pointsToDraw[0] * canvas.height / 2);\n    for(i = 1; i < pointsToDraw.length; i++) {\n        ctx.lineTo(i, -pointsToDraw[i] * canvas.height / 2);\n    }\n    ctx.lineWidth = canvas.lineWidth;\n    ctx.strokeStyle = canvas.color;\n    ctx.stroke();\n}\n```", "```cpp\nclass CarInfo : public QWidget {\n    Q_OBJECT\n    Q_PROPERTY(int rpm READ rpm NOTIFY rpmChanged)\n    Q_PROPERTY(int gear READ gear NOTIFY gearChanged)\n    Q_PROPERTY(int speed READ speed NOTIFY speedChanged)\n    Q_PROPERTY(double distance READ distance NOTIFY distanceChanged)\n    //...\n};\n```", "```cpp\nint CarInfo::speed() const {\n    return m_speed;\n}\nvoid CarInfo::setSpeed(int newSpeed) {\n    if(m_speed == newSpeed) {\n        return;\n    }\n    m_speed = newSpeed;\n    emit speedChanged(m_speed);\n} \n```", "```cpp\nqreal CarInfo::distance() const\n{\n    return ui->distanceBox->value();\n}\n```", "```cpp\nvoid CarInfo::setDistance(qreal newDistance)\n{\n    ui->distanceBox->setValue(newDistance);\n}\n```", "```cpp\nconnect(ui->distanceBox, SIGNAL(valueChanged(double)),\n        this,            SIGNAL(distanceChanged(double)));   \n```", "```cpp\nint main(int argc, char **argv) {\n    QApplication app(argc, argv);\n    CarInfo cinfo;\n    cinfo.show();\n    return app.exec();\n}; \n```", "```cpp\nint main(int argc, char **argv) {\n    QApplication app(argc, argv);\n    CarInfo cinfo;\n    QQmlApplicationEngine engine;\n    engine.rootContext()->setContextProperty(\"carData\", &cinfo);\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n    if (engine.rootObjects().isEmpty())\n        return -1;\n    cinfo.show();\n    return app.exec();\n}\n```", "```cpp\nimport QtQuick 2.9\nimport QtQuick.Window 2.3\n\nWindow {\n    visible: true\n    width: backgroundImage.width\n    height: backgroundImage.height\n\n    Image {\n        id: backgroundImage\n        source: \"qrc:/dashboard.png\"\n        Item {\n            id: leftContainer\n            anchors.centerIn: parent\n            anchors.horizontalCenterOffset: -550\n            width: 400; height: width\n        }\n        Item {\n            id: middleContainer\n            anchors.centerIn: parent\n            width: 700; height: width\n        }\n        Item {\n            id: rightContainer\n            anchors.centerIn: parent\n            anchors.horizontalCenterOffset: 525\n            width: 400; height: width\n        }\n    }\n}\n```", "```cpp\nimport QtQuick 2.9\n\nItem {\n    id: root\n    property int length: parent.width * 0.4\n    property color color: \"white\"\n    property color middleColor: \"red\"\n    property int size: 2\n\n    Rectangle { //needle\n        width: root.size\n        height: length + 20\n        color: root.color\n        anchors.horizontalCenter: parent.horizontalCenter\n        anchors.bottom: parent.bottom\n        anchors.bottomMargin: -20\n        antialiasing: true\n    }\n\n    Rectangle { //fixing\n        anchors.centerIn: parent\n        width: 8 + root.size\n        height: width\n        radius: width / 2\n        color: root.color\n        Rectangle { //middle dot\n            anchors {\n                fill: parent\n                margins: parent.width * 0.25\n            }\n            color: root.middleColor\n        }\n    }\n}\n```", "```cpp\nfunction calculatePosition(angle, radius) {\n    if(radius === undefined) {\n        radius = width / 2 * 0.8;\n    }\n    var a = angle * Math.PI / 180;\n    var px = width / 2 + radius * Math.cos(a);\n    var py = width / 2 + radius * Math.sin(a);\n    return Qt.point(px, py);\n}\n```", "```cpp\nItem {\n    id: middleContainer\n    // ...\n    function calculatePosition(angle, radius) { /* ... */ }\n    Repeater {\n        model: 24 / 2\n        Item {\n            property point pt:\n            middleContainer.calculatePosition(120 + index * 12 * 2)\n            x: pt.x\n            y: pt.y\n            Label {\n                anchors.centerIn: parent\n                text: index * 20\n            }\n        }\n    }\n    Needle {\n        anchors.centerIn: parent\n        length: parent.width * 0.35\n        size: 4\n        rotation: 210 + (carData.speed * 12 / 10)\n        color: \"yellow\"\n    }\n} \n```", "```cpp\nimport QtQuick 2.9\n\nText {\n    color: \"white\"\n    font.pixelSize: 24\n} \n```", "```cpp\nRepeater {\n    model: 120 - 4\n\n    Item {\n        property point pt: middleContainer.calculatePosition(\n            120 + index * 1.2 * 2, middleContainer.width * 0.35\n        )\n        x: pt.x\n        y: pt.y\n        Rectangle {\n            width: 2\n            height: index % 5 ? 5 : 10\n            color: \"white\"\n            rotation: 210 + index * 1.2 * 2\n            anchors.centerIn: parent\n            antialiasing: true\n        }\n    }\n} \n```", "```cpp\nText {\n    anchors.centerIn: parent\n    anchors.verticalCenterOffset: 40\n    text: \"SPEED\\n[kph]\"\n    horizontalAlignment: Text.AlignHCenter\n    color: \"#aaa\"\n    font.pixelSize: 16\n} \n```", "```cpp\nItem {\n    id: gearContainer\n    anchors.centerIn: parent\n    anchors.horizontalCenterOffset: 10\n    anchors.verticalCenterOffset: -10\n\n    Text {\n        id: gear\n        property int value: carData.gear\n        property var gears: [\n \"R\", \"N\",\n \"1<sup>st</sup>\", \"2<sup>nd</sup>\", \"3<sup>rd</sup>\",\n \"4<sup>th</sup>\", \"5<sup>th</sup>\"\n ]\n text: gears[value + 1]\n        anchors.left: parent.left\n        anchors.bottom: parent.bottom\n        color: \"yellow\"\n        font.pixelSize: 32\n        textFormat: Text.RichText\n    }\n} \n```", "```cpp\nQ_PROPERTY(QObject* engine READ engine NOTIFY engineChanged) \n```", "```cpp\n    QObject* engine() const { return m_engine; }\nprivate:\n    CarInfoEngine *m_engine; \n```", "```cpp\nsignals:\n    void engineChanged(); \n```", "```cpp\nm_engine = new CarInfoEngine(this); \n```", "```cpp\nItem {\n    id: leftContainer\n    // ...\n\n    Item {\n        id: gearContainer\n        Text {\n            id: gear\n            property int value: carData.engine.gear\n            // ...\n        }\n    }\n    Needle {\n        anchors.centerIn: parent\n        length: parent.width * 0.35\n        rotation: 210 + (carData.engine.rpm * 35)\n    }\n} \n```", "```cpp\nqmlRegisterType<FooClass>(\"foo.bar.baz\", 1, 0, \"Foo\"); \n```", "```cpp\nimport QtQuick 2.9\nimport foo.bar.baz 1.0\n\nItem {\n    Foo {\n        id: foo\n    }\n} \n```", "```cpp\nimport QtQuick 2.9\nimport CarInfo 1.0\n\nImage {\n    source: \"dashboard.png\"\n\n    CarInfo {\n        id: carData\n        visible: true // make the widget visible\n    }\n  // ...\n} \n```", "```cpp\nint main(int argc, char **argv) {\n    QGuiApplication app(argc, argv);\n    QQmlApplicationEngine engine;\n    // this code does not work\n    qmlRegisterType<CarInfo>(\"CarInfo\", 1, 0, \"CarInfo\");\n    //...\n} \n```", "```cpp\nclass CarInfoProxy : public QObject {\n    Q_OBJECT\n    Q_PROPERTY(QObject *engine READ engine NOTIFY engineChanged)\n    Q_PROPERTY(int speed READ speed WRITE setSpeed NOTIFY speedChanged)\n    // ... \n```", "```cpp\n  Q_PROPERTY(bool visible READ visible WRITE setVisible \n                          NOTIFY visibleChanged)\n```", "```cpp\nprivate:\n    CarInfo m_car; \n```", "```cpp\npublic:\n    CarInfoProxy(QObject *parent = nullptr) : QObject(parent) {\n        connect(&m_car, &CarInfo::engineChanged,\n                this, &CarInfoProxy::engineChanged);\n        connect(&m_car, &CarInfo::speedChanged,\n                this, &CarInfoProxy::speedChanged);\n    }\n    QObject *engine() const { \n        return m_car.engine(); \n    }\n    bool visible() const { \n        return m_car.isVisible(); \n    }\n    void setVisible(bool v) {\n        if(v == visible()) return;\n        m_car.setVisible(v);\n        emit visibleChanged(v);\n    }\n    int speed() const { \n        return m_car.speed(); \n    }\n    void setSpeed(int v) { \n        m_car.setSpeed(v); \n    }\nsignals:\n    void engineChanged();\n    void visibleChanged(bool);\n    void speedChanged(int);\n}; \n```", "```cpp\n  qmlRegisterType<CarInfoProxy>(\"CarInfo\", 1, 0, \"CarInfo\"); \n```", "```cpp\nCarInfo {\n    id: carData\n    visible: true\n engine.gear: 3\n}\n```", "```cpp\nCannot assign to non-existent property \"gear\"\n             engine.gear: 3\n                    ^ \n```", "```cpp\nQ_PROPERTY(CarInfoEngine* engine READ engine NOTIFY engineChanged) \n```", "```cpp\nCarInfoEngine* engine() const { \n    return m_engine; \n}\n```", "```cpp\nQString msg = QStringLiteral(\"Objects of type CarInfoEngine cannot be created\");\nqmlRegisterUncreatableType<CarInfoEngine>(\"CarInfo\", 1, 0, \"CarInfoEngine\", msg);\n```"]