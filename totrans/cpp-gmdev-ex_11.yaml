- en: Enhancing Your Game with Collision, Loops, and Lighting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过碰撞、循环和光照增强您的游戏
- en: In this chapter, we will learn how to add collision to detect contact between
    the ball and the enemy; this will determine the lose condition. We will also check
    the contact between the ball and the ground to find out whether the player can
    jump or not. Then, we will finalize the gameplay loop.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何添加碰撞以检测球和敌人之间的接触；这将确定失败条件。我们还将检查球和地面之间的接触，以确定玩家是否可以跳跃。然后，我们将完成游戏循环。
- en: Once the gameplay loop is complete, we will be able to add text rendering to
    show the player their score. To display the necessary text, we will use the FreeType
    library. This will load in the characters from the font file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏循环完成，我们就能添加文本渲染来显示玩家的得分。为了显示必要的文本，我们将使用FreeType库。这将从字体文件中加载字符。
- en: We will also add some basic lighting to the objects in the scene. Lighting will
    be calculated using the Phong lighting model, and we will cover how this is implemented
    in practice. To finish the gameplay loop, we will have to add an enemy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向场景中的对象添加一些基本光照。光照将使用Phong光照模型进行计算，我们将介绍如何在实践中实现这一点。为了完成游戏循环，我们必须添加一个敌人。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding a `RigidBody` name
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`RigidBody`名称
- en: Adding an enemy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加敌人
- en: Moving the enemy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动敌人
- en: Checking collision
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查碰撞
- en: Adding keyboard controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加键盘控制
- en: Gameloop and scoring
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏循环和得分
- en: Text rendering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本渲染
- en: Adding lighting
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加光照
- en: Adding a RigidBody name
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加刚体名称
- en: 'To identify the different rigid bodies we are going to be adding to the scene,
    we will add a property to the `MeshRenderer` class that will specify each object
    being rendered. Let''s look at how to do this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别我们将要添加到场景中的不同刚体，我们将在`MeshRenderer`类中添加一个属性，该属性将指定每个被渲染的对象。让我们看看如何做到这一点：
- en: 'In the `MeshRenderer.h` class, which can be found within the `MeshRenderer`
    class, change the constructor of the class to take in a string as the name for
    the object, as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MeshRenderer.h`类中，该类位于`MeshRenderer`类内部，将类的构造函数修改为接受一个字符串作为对象的名称，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a new public property called `name` of the `std::string` type and initialize
    it, as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`name`的新公共属性，其类型为`std::string`，并初始化它，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, in the `MeshRenderer.cpp` file, modify the constructor implementation,
    as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`MeshRenderer.cpp`文件中，修改构造函数的实现，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have successfully added the `name` property to the `MeshRenderer` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功将`name`属性添加到`MeshRenderer`类中。
- en: Adding an enemy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌人
- en: 'Before we add an enemy to the scene, let''s clean up our code a little bit
    and create a new function called `addRigidBodies` in `main.cpp` so that all the
    rigid bodies will be created in a single function. To do so, follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将敌人添加到场景之前，让我们稍微整理一下代码，并在`main.cpp`中创建一个名为`addRigidBodies`的新函数，以便所有刚体都在一个函数中创建。为此，请按照以下步骤操作：
- en: In the source of the `main.cpp` file, create a new function called `addRigidBodies`
    above the `main()` function.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件的源代码中，在`main()`函数上方创建一个名为`addRigidBodies`的新函数。
- en: 'Add the following code to the `addRigidBodies` function. This will add the
    sphere and ground. We are doing this instead of putting all the game code in the
    `main()` function:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`addRigidBodies`函数中。这将添加球体和地面。我们这样做是为了避免将所有游戏代码放入`main()`函数中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that some of the values have been changed to suit our game. We have also
    disabled deactivation on the sphere because, if we don't, then the sphere will
    be unresponsive when we want it to jump for us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些值已被更改以适应我们的游戏。我们还将禁用球体的去激活，因为我们不这样做的话，当我们需要球体为我们跳跃时，球体将无响应。
- en: 'To access the name of the rendered mesh, we can set this instance as a property
    of the rigid body by using the `setUserPointer` property of the `RigidBody` class.
    `setUserPointer` takes a void pointer, so any kind of data can be passed into
    it. For the sake of convenience, we are just passing the instance of the `MeshRenderer`
    class itself. In this function, we will also add the enemy''s rigid body to the
    scene, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问渲染网格的名称，我们可以通过使用`RigidBody`类的`setUserPointer`属性将该实例设置为刚体的一个属性。`setUserPointer`接受一个void指针，因此可以传递任何类型的数据。为了方便起见，我们只是传递`MeshRenderer`类的实例本身。在这个函数中，我们还将添加敌人的刚体到场景中，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add the enemy in the same way that we added the sphere and the ground. Since
    the shape of the enemy object is a cube, we use`btBoxShape` to set the shape of
    the box for the rigid body. We set the location to 18 units' distance in the *X*-axis
    and one unit's distance in the *Y*-axis. Then, we set the friction and restitution
    values.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与我们添加球体和地面的相同方式添加敌人。由于敌人对象的形状是立方体，我们使用`btBoxShape`为刚体设置盒子的形状。我们将位置设置为沿*X*轴18个单位距离和沿*Y*轴1个单位距离。然后，我们设置摩擦和恢复值。
- en: For the type of the rigid body, we set its collision flag to `NO_CONTACT_RESPONSE`
    instead of `KINEMATIC_OBJECT`. We could have set the type to `KINEMATIC_OBJECT`,
    but then the enemy object would exert force on other objects, such as the sphere,
    when it comes in contact with it. To avoid this, we use `NO_CONTACT_RESPONSE`,
    which will just check if there was an overlap between the enemy rigid body and
    another body, instead of applying force to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚体的类型，我们将它的碰撞标志设置为`NO_CONTACT_RESPONSE`而不是`KINEMATIC_OBJECT`。我们本来可以将类型设置为`KINEMATIC_OBJECT`，但那样的话，当敌人对象与之接触时，它会对其他对象，如球体，施加力。为了避免这种情况，我们使用`NO_CONTACT_RESPONSE`，它只会检查敌人刚体和另一个物体之间是否有重叠，而不是对其施加力。
- en: You can uncomment the `KINEMATIC_OBJECT` line of code and comment on the `NO_CONTACT_RESPONSE` line
    of code to see how using either changes the way the object behaves in the physics
    simulation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以取消注释`KINEMATIC_OBJECT`代码行的注释，并注释掉`NO_CONTACT_RESPONSE`代码行，以查看使用任一方式如何改变物体在物理模拟中的行为。
- en: Once we have created the rigid body, we add the rigid body to the world, set
    the mesh renderer for the enemy object, and name it **enemy**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了刚体，我们将刚体添加到世界中，为敌人对象设置网格渲染器，并将其命名为**敌人**。
- en: Moving the enemy
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动敌人
- en: To update the enemy's movement, we will add a tick function that will be called
    by the rigid body world. In this tick function, we will update the position of
    the enemy so that the enemy cube moves from the right of the screen to the left.
    We will also check whether the enemy has gone beyond the left-hand side of the
    screen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新敌人的移动，我们将添加一个由刚体世界调用的`tick`函数。在这个`tick`函数中，我们将更新敌人的位置，使其从屏幕的右侧移动到左侧。我们还将检查敌人是否已经超过了屏幕的左侧边界。
- en: 'If it has, then we will reset its position to the right of the screen. To do
    so, follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经超过，那么我们将将其位置重置为屏幕的右侧。为此，请按照以下步骤操作：
- en: 'In this update function, we will also update our gameplay logic and scoring,
    as well as how we check for contact between the sphere and the enemy and the sphere
    and the ground. Add the tick function callback prototype to the top of the `Main.cpp`
    file, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个更新函数中，我们将更新我们的游戏逻辑和得分，以及我们如何检查球体与敌人以及球体与地面的接触。将`tick`函数回调原型添加到`Main.cpp`文件的顶部，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `TickCallback` function, update the position of the enemy, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TickCallback`函数中更新敌人的位置，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `myTickCallback` function, we get the current transform and store it
    in a variable, `t`. Then, we set the origin, which is the position of the transform,
    by getting the current position, moving it 15 units to the left, and multiplying
    it by the current timestep (which is the difference between the previous and current
    time).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`myTickCallback`函数中，我们获取当前的变换并将其存储在一个变量`t`中。然后，我们通过获取当前位置，将其向左移动15个单位，并将其乘以当前时间步长（即前一个时间和当前时间之间的差异）来设置原点，即变换的位置。
- en: Once we get the updated location, we check that the current location is less
    than 18 units. If it is, then the current location is beyond the screen bounds
    on the left of the screen. Consequently, we set the current location back to the
    right of the viewport and make the object wrap around the screen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到更新后的位置，我们检查当前位置是否小于18个单位。如果是，那么当前位置已经超出了屏幕左侧的边界。因此，我们将当前位置设置回视口的右侧，并使物体在屏幕上环绕。
- en: Then, we update the location of the object itself to this new location by updating
    the `worldTransform` of the rigid body and the motion state of the object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过更新刚体的`worldTransform`和物体的运动状态来更新物体本身的位置到这个新位置。
- en: 'Set the tick function as the default `TickCallback` of the dynamic world in
    the `init` function, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`函数中将`tick`函数设置为动态世界的默认`TickCallback`，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Build and run the project to see the cube enemy spawn at the right of the screen,
    followed by it passing through the sphere and moving toward the left of the screen.
    When the enemy goes offscreen, it will be looped around to the right of the screen,
    as shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目，以查看屏幕右侧生成的立方体敌人，然后它穿过球体并向屏幕左侧移动。当敌人离开屏幕时，它将循环回到屏幕右侧，如下面的截图所示：
- en: '![](img/ec234c82-a108-4331-bfa9-e8c8fe7eab04.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ec234c82-a108-4331-bfa9-e8c8fe7eab04.png)'
- en: 'If we set the `collisionFlag` of the enemy to `KINEMATIC_OBJECT`, you will
    see that the enemy doesn''t go through the sphere but pushes it off the ground,
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将敌人的`collisionFlag`设置为`KINEMATIC_OBJECT`，你会看到敌人不会穿过球体，而是将其推离地面，如下所示：
- en: '![](img/ab66fea4-7ddd-4c3d-b00c-caf95c27b182.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ab66fea4-7ddd-4c3d-b00c-caf95c27b182.png)'
- en: This is not what we want as we don't want the enemy to physically interact with
    any objects. Change the collision flag of the enemy back to `NO_CONTACT_RESPONSE` to
    amend this.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不是我们想要的，因为我们不希望敌人与任何对象进行物理交互。将敌人的碰撞标志改回`NO_CONTACT_RESPONSE`以修正此问题。
- en: Checking collision
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查碰撞
- en: 'In the tick function, we need to check for collision between the sphere and
    the enemy, as well as the sphere and the ground. Follow these steps to do so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在tick函数中，我们需要检查球体与敌人以及球体与地面的碰撞。按照以下步骤进行：
- en: To check the number of contacts between objects, we will use the `getNumManifolds`
    property of the dynamic world object. The manifold will contain information regarding
    all the contacts in the scene per update cycle.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查对象之间的接触数，我们将使用动态世界对象的`getNumManifolds`属性。在每次更新周期中，流形将包含有关场景中所有接触的信息。
- en: 'We need to check whether the number of contacts is greater than zero. If it
    is, then we check which pairs of objects were in contact with each other. After
    updating the enemy object, add the following code to check for contact between
    the hero and the enemy:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要检查联系人数是否大于零。如果是，那么我们检查哪些对象对彼此接触。在更新敌人对象后，添加以下代码以检查英雄与敌人之间的接触：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we get the number of contact manifolds or contact pairs. Then, for each
    contact manifold, we check whether the number of contacts is greater than zero.
    If it is greater than zero, then it means there has been a contact in the current
    update.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们获取接触流形或接触对的数量。然后，对于每个接触流形，我们检查接触数是否大于零。如果是大于零，那么这意味着在当前更新中已经发生了接触。
- en: Then, we get both collision objects and assign them to `ObjA` and `ObjB`. After
    this, we get the user pointer for both objects and typecast it to `MeshRenderer`
    to access the name of the objects we assigned. When checking for contact between
    two objects, object A can be in contact with object B or the other way around.
    If there has been contact between the sphere and the enemy, we set the position
    of the enemy back to the right of the viewport. We also check for contact between
    the sphere and the ground. If there is contact, we just print out that there has
    been contact.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取两个碰撞对象并将它们分配给`ObjA`和`ObjB`。之后，我们获取两个对象的用户指针并将它们转换为`MeshRenderer`类型，以访问我们分配的对象的名称。在检查两个对象之间的接触时，对象A可以与对象B接触，或者反之亦然。如果球体与敌人之间有接触，我们将敌人位置设置回视口的右侧。我们还检查球体与地面的接触。如果有接触，我们只需打印出有接触即可。
- en: Adding keyboard controls
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加键盘控制
- en: 'Let''s add some keyboard controls so that we can interact with the sphere.
    We will set it so that, when we press the up key on the keyboard, the sphere jumps.
    We will add the jump feature by applying an impulse to the sphere. To do so, follow
    these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些键盘控制，以便我们可以与球体交互。我们将设置，当我们按下键盘上的上键时，球体会跳跃。我们将通过向球体应用冲量来添加跳跃功能。为此，请按照以下步骤操作：
- en: 'First, we''ll use `GLFW`, which has a keyboard callback function so that we
    can add interaction with the keyboard for the game. Before we begin with the `main()`
    function, we will set this keyboard callback  function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`GLFW`，它有一个键盘回调函数，这样我们就可以为游戏添加键盘交互。在我们开始`main()`函数之前，我们将设置此键盘回调函数：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The two main parameters that we are concerned with are the key and action. With
    key, we get which key is pressed, and with action, we can retrieve what action
    was performed on that key. In the function, we check whether the *Esc* key was
    pressed using the `glfwGetKey` function. If so, then we close the window using
    the `glfwSetWindowShouldClose` function by passing true as the second parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的两个主要参数是键和动作。通过键，我们可以获取哪个键被按下，通过动作，我们可以检索对该键执行了什么操作。在函数中，我们使用`glfwGetKey`函数检查是否按下了*Esc*键。如果是，则使用`glfwSetWindowShouldClose`函数通过传递`true`作为第二个参数来关闭窗口。
- en: To make the sphere jump, we check whether the up key was pressed. If it was,
    we create a new Boolean member variable called `grounded`, which describes a state
    if the sphere is touching the ground. If this is true, we set the Boolean value
    to `false` and apply an impulse of `100` units on the sphere's rigid body origin
    in the Y direction by calling the `applyImpulse` function of `rigidbody`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使球体跳跃，我们检查是否按下了向上键。如果是，我们创建一个新的布尔成员变量`grounded`，它描述了球体接触地面时的状态。如果是真的，我们将布尔值设置为`false`，并通过调用`rigidbody`的`applyImpulse`函数在Y方向上对球体的刚体原点施加`100`单位的冲量。
- en: 'In the tick function, before we get the number of manifolds, we set the `grounded`
    Boolean to false, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tick`函数中，在我们获取流形数量之前，我们将`grounded`布尔值设置为`false`，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We set the `grounded` Boolean value to true when there is contact between the
    sphere and the ground, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当球体和地面接触时，我们将`grounded`布尔值设置为`true`，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the main function, set `updateKeyboard` as the callback using `glfwSetKeyCallback`,
    as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，使用`glfwSetKeyCallback`将`updateKeyboard`设置为回调，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, build and run the application. Press the up key to see the sphere jump,
    but only when it is grounded, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行应用程序。按下向上键以查看球体跳跃，但只有当它接触地面时，如下所示：
- en: '![](img/e9392898-a6a3-4ddf-ae97-46d496b357c3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9392898-a6a3-4ddf-ae97-46d496b357c3.png)'
- en: Game loop and scoring
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环和计分
- en: 'Let''s wrap this up by adding scoring and finishing the game loop:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加计分和完成游戏循环来结束这个话题：
- en: 'Along with the `grounded` Boolean, add another Boolean and check for `gameover`.
    After doing this, add an `int` called `score` and initialize it to `0` at the
    top of the `main.cpp` file, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`grounded`布尔值外，再添加另一个布尔值并检查`gameover`。完成这些后，在`main.cpp`文件顶部添加一个名为`score`的`int`，并将其初始化为`0`，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, in the tick function, the enemy should only move when the game is not
    over. So we wrap the update for the position of the enemy inside an **if** statement
    to check whether or not the game is over. If the game is not over, then we update
    the position of the enemy, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`tick`函数中，敌人只有在游戏未结束时才会移动。因此，我们将敌人的位置更新包裹在一个`if`语句中，以检查游戏是否结束。如果游戏未结束，则更新敌人的位置，如下所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also increment the score if the enemy goes beyond the left of the screen.
    Still in the tick function, if there is contact between the sphere and the enemy,
    we set the score to `0` and set `gameover` to `true`, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果敌人超出屏幕的左侧，我们也增加分数。仍然在`tick`函数中，如果球体和敌人之间有接触，我们将分数设置为`0`并将`gameover`设置为`true`，如下所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the update keyboard function, when the up keyboard key is pressed, we check
    whether the game is over. If it is, we set the `gameover` Boolean to false, which
    will start the game. Now, when the player presses the up key again, the character
    will jump. This way, the same key can be used for starting the game and also making
    the character jump.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updateKeyboard`函数中，当按下向上键盘键时，我们检查游戏是否结束。如果是，我们将`gameover`布尔值设置为`false`，这将开始游戏。现在，当玩家再次按下向上键时，角色将跳跃。这样，相同的键可以用来开始游戏，也可以用来使角色跳跃。
- en: 'Make the required changes to the `updateKeyboard` function, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下要求修改`updateKeyboard`函数，如下所示：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although we are calculating the score, the user still cannot see what the score
    is, so let's add text rendering to the game.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们在计算分数，但用户仍然看不到分数是多少，所以让我们给游戏添加文本渲染。
- en: Text rendering
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本渲染
- en: For rendering text, we will use a library called FreeType, load in the font,
    and read the characters from it. FreeType can load a popular font format called
    TrueType. TrueType fonts have a `.ttf` extension.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本渲染，我们将使用一个名为FreeType的库，加载字体并从中读取字符。FreeType可以加载一个流行的字体格式，称为TrueType。TrueType字体具有`.ttf`扩展名。
- en: TTFs contain vector information called glyphs that can be used to store any
    data. One use case is, of course, to represent characters with them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: TTFs包含称为glyphs的矢量信息，可以用来存储任何数据。一个用例当然是使用它们来表示字符。
- en: So, when we want to render a particular glyph, we load the character glyph by
    specifying its size; the character will be generated without there being a loss
    in quality.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们想要渲染特定的字形时，我们将通过指定其大小来加载字符字形；字符将以不损失质量的方式生成。
- en: The source of the FreeType library can be downloaded from their website at [https://www.freetype.org/](https://www.freetype.org/)
    and the library can be built from it. The precompiled libraries can also be downloaded
    from [https://github.com/ubawurinna/freetype-windows-binaries](https://github.com/ubawurinna/freetype-windows-binaries).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: FreeType 库的源代码可以从他们的网站 [https://www.freetype.org/](https://www.freetype.org/)
    下载，并从中构建库。也可以从 [https://github.com/ubawurinna/freetype-windows-binaries](https://github.com/ubawurinna/freetype-windows-binaries)
    下载预编译的库。
- en: 'Let''s add the library to our project. Since we are developing for the 64-bit
    OS, we are interested in the `include` directory and the `win64` directory; they
    contain the `freetype.lib` and `freetype.dll` files for our version of the project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将库添加到我们的项目中。由于我们正在为 64 位操作系统开发，我们感兴趣的是 `include` 目录和 `win64` 目录；它们包含我们项目版本的
    `freetype.lib` 和 `freetype.dll` 文件：
- en: 'Create a folder called `freetype` in your dependencies folder and extract the
    files into it, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的依赖文件夹中创建一个名为 `freetype` 的文件夹，并将文件提取到其中，如下所示：
- en: '![](img/26c04855-bd22-4ccd-a0b7-9ba34233dcff.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26c04855-bd22-4ccd-a0b7-9ba34233dcff.png)'
- en: 'Open the project''s properties and, under C/C++ in Additional Include Directory,
    add the `freetype` include directory location, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目的属性，在 C/C++ 下的 Additional Include Directory（附加包含目录）中添加 `freetype` 包含目录的位置，如下所示：
- en: '![](img/57339f31-2a05-43dc-aeaf-9155d6d2a478.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57339f31-2a05-43dc-aeaf-9155d6d2a478.png)'
- en: 'Under Configuration Properties | Linker | General | Additional Library Directories,
    add the freetype `win64` directory, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Configuration Properties | Linker | General | Additional Library Directories（配置属性
    | 链接器 | 一般 | 附加库目录）下，添加 freetype `win64` 目录，如下所示：
- en: '![](img/c02482b4-37c3-4a6d-b849-a0bd9501f4dc.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c02482b4-37c3-4a6d-b849-a0bd9501f4dc.png)'
- en: 'In the project directory, copy the `Freetype.dll` file from the `win64` directory
    and paste it here:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中，从 `win64` 目录复制 `Freetype.dll` 文件并将其粘贴到这里：
- en: '![](img/2c29c11e-af9c-4aa1-a429-2e7802f3d41f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c29c11e-af9c-4aa1-a429-2e7802f3d41f.png)'
- en: With the prep work out of the way, we can start working on the project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备工作完成之后，我们可以开始着手进行项目工作了。
- en: 'Create a class called `TextRenderer`, as well as a file called `TextRenderer.h`
    and a file called `TextRenderer.cpp`. We will add the functionality for text rendering
    to these files. In  `TextRenderer.h`, include the usual include headers for `GL`
    and `glm` as `b`, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TextRenderer` 的类，以及一个名为 `TextRenderer.h` 的文件和一个名为 `TextRenderer.cpp`
    的文件。我们将向这些文件添加文本渲染的功能。在 `TextRenderer.h` 中，包含 `GL` 和 `glm` 的常用包含头文件，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will include the headers for `freetype.h`, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将包含 `freetype.h` 的头文件，如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `FT_FREETYPE_H` macro just includes `freetype.h` in the `freetype` directory.
    Then, we will `include <map>` as we will have to map each character''s location,
    size, and other information. We will also `include <string>` and pass a string
    into the class to be rendered, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FT_FREETYPE_H` 宏仅仅在 `freetype` 目录中包含了 `freetype.h`。然后，我们将 `include <map>`，因为我们需要映射每个字符的位置、大小和其他信息。我们还将
    `include <string>` 并将一个字符串传递给要渲染的类，如下所示：'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For each glyph, we will need to keep track of certain properties. For this,
    we will create a `struct` called `Character`, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个字形，我们需要跟踪某些属性。为此，我们将创建一个名为 `Character` 的 `struct`，如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For each glyph, we will store the texture ID of the texture we create for each
    character. We store the size of it, the bearing, which is the distance from the
    top left corner of the glyph from the baseline of the glyph, and the ID of the
    next glyph in the font file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字形，我们将存储我们为每个字符创建的纹理的纹理 ID。我们存储它的大小、基线，即字形顶部左角到字形基线的距离，以及字体文件中下一个字形的 ID。
- en: 'This is what a font file looks like when it has all the character glyphs in
    it:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是包含所有字符字形的字体文件的外观：
- en: '![](img/1f02801f-784a-4cca-9cb5-1af8ca0ac180.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f02801f-784a-4cca-9cb5-1af8ca0ac180.png)'
- en: 'Information regarding each character is stored in relation to the character
    adjacent to it, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符的信息都是相对于其相邻字符存储的，如下所示：
- en: '![](img/c492e9ab-55b9-45ab-97b1-736e587acda3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c492e9ab-55b9-45ab-97b1-736e587acda3.png)'
- en: Each of these properties can be accessed on a per glyph basis after we load
    the font face of the `FT_Face` type. The width and height of each glyph can be
    accessed using the glyph property per font face, that is, `face->glyph as face->glyph->bitmap.width`
    and `face->glyph->bitmap.rows`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 `FT_Face` 类型的字体面之后，我们可以逐个访问这些属性。每个字形的宽度和高度可以通过每个字形的属性访问，即 `face->glyph->bitmap.width`
    和 `face->glyph->bitmap.rows`。
- en: The image data is available per glyph using the `bitmap.buffer` property, which
    we will be using when we create the texture for each glyph. The following code
    shows how all of this is implemented.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字形的图像数据可以通过 `bitmap.buffer` 属性访问，我们在创建每个字形的纹理时将使用它。以下代码显示了所有这些是如何实现的。
- en: The next glyph in the font file can be accessed using the `advance.x` property
    of the glyph if the font is horizontally aligned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字体是水平对齐的，可以通过字形的 `advance.x` 属性访问字体文件中的下一个字形。
- en: That's enough theory about the library. If you are interested in finding out
    more, the necessary documentation is available on FreeType's website: [https://www.freetype.org/freetype2/docs/tutorial/step2.html#section-1](https://www.freetype.org/freetype2/docs/tutorial/step2.html#section-1).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于库的理论就到这里。如果你有兴趣了解更多，必要的文档可以在 FreeType 的网站上找到：[https://www.freetype.org/freetype2/docs/tutorial/step2.html#section-1](https://www.freetype.org/freetype2/docs/tutorial/step2.html#section-1)。
- en: 'Let''s continue with the `TextRenderer.h` file and create the `TextRenderer`
    class, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续处理 `TextRenderer.h` 文件，并创建 `TextRenderer` 类，如下所示：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the class under the public section, we add the constructor and destructor.
    In the constructor, we pass in the string we want to draw, the file we want to
    use, the size and color of the text we want to draw in, and pass in a shader program
    to use while drawing the font.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共部分下的类中，我们添加构造函数和析构函数。在构造函数中，我们传入要绘制的字符串、要使用的文件、要绘制的文本的大小和颜色，以及传入在绘制字体时使用的着色器程序。
- en: Then, we have the `draw` function to draw the text, a couple of setters to set
    the position, and a `setText` function to set a new string to draw if needed.
    In the private section, we have local variables for the text string, scale, color,
    and position. We also have member variables for `VAO`, `VBO`, and `program` so
    that we can draw the text string. At the end of the class, we create a map to
    store all the loaded characters and assign each `GLchar` to a character `struct`
    in the map. This is all we need to do for the `TextRenderer.h` file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有 `draw` 函数来绘制文本，几个设置器来设置位置，以及一个 `setText` 函数，如果需要，可以设置新的字符串进行绘制。在私有部分，我们有用于文本字符串、缩放、颜色和位置的局部变量。我们还有
    `VAO`、`VBO` 和 `program` 的成员变量，这样我们就可以绘制文本字符串。在类的末尾，我们创建一个映射来存储所有加载的字符，并将每个 `GLchar`
    分配到映射中的字符 `struct`。这就是 `TextRenderer.h` 文件需要做的所有事情。
- en: 'In the `TextRenderer.cpp` file, include the `TextRenderer.h` file at the top
    of the file and perform the following steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TextRenderer.cpp` 文件中，将 `TextRenderer.h` 文件包含在文件顶部，并执行以下步骤：
- en: 'Add the `TextRenderer` constructor implementation, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `TextRenderer` 构造函数的实现，如下所示：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the constructor, we will add the functionally for loading all the characters
    and prep the class for drawing the text.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将添加加载所有字符的功能，并为绘制文本准备类。
- en: 'Let''s initialize the local variables, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们初始化局部变量，如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to set the projection matrix. For text, we specify the orthographic
    projection since it doesn''t have any depth, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置投影矩阵。对于文本，我们指定正交投影，因为它没有深度，如下所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The projection is created using the `glm::ortho` function, which takes origin
    x, window width, origin y, and window height as the parameters for creating the
    orthographic projection matrix. We will use the current program and pass the value
    for the projection matrix to a location called projection, and then pass this
    on to the shader. Since this value will never change, it is called and assigned
    once in the constructor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 投影是通过 `glm::ortho` 函数创建的，它接受原点 x、窗口宽度、原点 y 和窗口高度作为创建正交投影矩阵的参数。我们将使用当前程序并将投影矩阵的值传递到名为
    projection 的位置，然后将其传递给着色器。由于这个值永远不会改变，它将在构造函数中调用并赋值一次。
- en: 'Before we load the font itself, we have to initialize the FreeType library,
    as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载字体本身之前，我们必须初始化 FreeType 库，如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can load the font face itself, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以加载字体本身，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, set the font size in pixels and disable the byte alignment restriction.
    If we don''t restrict the byte alignment, the font will be drawn jumbled, so don''t
    forget to add this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置字体大小（以像素为单位）并禁用字节对齐限制。如果我们不对字节对齐进行限制，字体将被绘制得混乱，所以别忘了添加这个：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we will load the first `128` characters into the font we loaded and create
    and assign the texture ID, size, bearing, and advance. After, we will store the
    font in the characters map, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将加载我们加载的字体中的前`128`个字符，并创建和分配纹理ID、大小、基线和进位。之后，我们将字体存储在字符映射中，如下所示：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the characters have been loaded, we can unbind the texture and destroy
    the font face and FreeType library, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦加载了字符，我们可以解绑纹理并销毁字体外观和FreeType库，如下所示：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each character will be drawn as a texture on a separate quad, so set the `VAO`/`VBO`
    for a quad, create a position attribute, and enable it, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个字符都将作为一个单独的四边形上的纹理来绘制，因此为四边形设置`VAO`/`VBO`，创建一个位置属性并启用它，如下所示：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we need to unbind `VBO` and `VAO`, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要解绑`VBO`和`VAO`，如下所示：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s all for the constructor. Now, we can move on to the draw function.
    Let''s take a look:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数就到这里。现在，我们可以继续到绘制函数。让我们看看：
- en: 'First, create the draw function''s  implementation, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建绘制函数的实现，如下所示：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will add the functionality for drawing to this function. First, we''ll get
    the position where the text needs to start drawing, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向这个函数添加绘制功能。首先，我们将获取文本需要开始绘制的位置，如下所示：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we have to enable blending. If we don''t enable blending, the whole quad
    for the text will be colored instead of just the area where the text is present,
    as shown in the image on the left:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须启用混合。如果我们不启用混合，整个文本的四边形将被着色，而不是仅着色文本存在的区域，如左边的图像所示：
- en: '![](img/4b5c4d13-726e-4ea5-b2cb-b6f3c6784d9b.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b5c4d13-726e-4ea5-b2cb-b6f3c6784d9b.png)'
- en: In the image on the left, where the S is supposed to be, we can see the whole
    quad colored in red, including the pixels where it is supposed to be transparent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的图像中，S应该出现的地方，我们可以看到整个四边形被红色着色，包括应该透明的像素。
- en: 'By enabling blending, we set the final color value as a pixel using the following
    equation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用混合，我们使用以下方程式将最终颜色值设置为像素：
- en: '*Color[final] = Color[Source] * Alpha[Source] + Color[Destination] * 1- Alpha[Source]*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*颜色[最终] = 颜色[源] * Alpha[源] + 颜色[目标] * 1- Alpha[源]*'
- en: Here, source color and source alpha are the color and alpha values of the text
    at a certain pixel location, while the destination color and alpha are the values
    of the color and alpha at the color buffer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，源颜色和源alpha是文本在某个像素位置的颜色和alpha值，而目标颜色和alpha是颜色缓冲区中颜色和alpha的值。
- en: In this example, since we draw the text later, the destination color will be
    yellow, and the source color, which is the text, will be red. The destination
    alpha value is 1.0 while the yellow color is opaque. For the text, if we take
    a look at the S glyph, for example, within the S, which is the red area, it is
    opaque, but it is transparent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于我们稍后绘制文本，目标颜色将是黄色，而源颜色，即文本，将是红色。目标alpha值为1.0，而黄色是不透明的。对于文本，如果我们看一下S字母，例如，在S内部，即红色区域，它是完全不透明的，但它是透明的。
- en: 'Using this formula, let''s calculate the final pixel color around the S where
    it is transparent using the following equation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个公式，让我们计算S周围透明区域的最终像素颜色，如下所示：
- en: '*Color[final] = (1.0f, 0.0f, 0.0f, 0.0f) * 0.0 + (1.0f, 1.0f, 0.0f, 1.0f) *
    (1.0f- 0.0f)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*颜色[最终] = (1.0f, 0.0f, 0.0f, 0.0f) * 0.0 + (1.0f, 1.0f, 0.0f, 1.0f) * (1.0f-
    0.0f)*'
- en: = (1.0f, 1.0f, 0.0f, 1.0f);*
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: = (1.0f, 1.0f, 0.0f, 1.0f);*
- en: This is just the yellow background color.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是黄色背景颜色。
- en: 'Conversely, within the S glyph, it is not transparent, so the alpha value is
    1 at that pixel location. So, when we apply the same formula, we get the final
    color, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在S字母内部，它不是透明的，所以该像素位置的alpha值为1。因此，当我们应用相同的公式时，我们得到最终颜色，如下所示：
- en: '*Color[final] = (1.0f, 0.0f, 0.0f, 1.0f) * 1.0 + (1.0f, 1.0f, 0.0f, 1.0f) *
    (1.0f- 1.0f)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*颜色[最终] = (1.0f, 0.0f, 0.0f, 1.0f) * 1.0 + (1.0f, 1.0f, 0.0f, 1.0f) * (1.0f-
    1.0f)*'
- en: '*= (1.0f, 0.0f, 0.0f, 1.0f)*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*= (1.0f, 0.0f, 0.0f, 1.0f)*'
- en: 'This is just the red text color, as shown in the following diagram:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是红色文本颜色，如下面的图所示：
- en: '![](img/299dfb78-cf0f-4fac-97ca-908b9309fee7.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/299dfb78-cf0f-4fac-97ca-908b9309fee7.png)'
- en: Let's see how this is implemented in practice.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在实践中是如何实现的。
- en: 'The `blend` function is as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`blend`函数如下：'
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to set the source and destination blending factors, that is, `GL_SRC_ALPHA`.
    For the source pixel, we use its alpha value as-is, whereas, for the destination,
    we set the alpha to `GL_ONE_MINUS_SRC_ALPHA`, which is the source alpha minus
    one, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置源和目标混合因子，即 `GL_SRC_ALPHA`。对于源像素，我们使用其 alpha 值不变，而对于目标，我们将 alpha 设置为
    `GL_ONE_MINUS_SRC_ALPHA`，即源 alpha 减去一，如下所示：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By default, the value source and destination values are added. You can subtract,
    add, and divide as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，源值和目标值被添加。你也可以进行减法、加法和除法操作。
- en: 'Now, we need to call the `glUSeProgram` function to set the program, set the
    text color to the uniform location, and set the default texture, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要调用 `glUseProgram` 函数来设置程序，将文本颜色设置为统一位置，并设置默认纹理，如下所示：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we need to bind the `VAO`, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要绑定 `VAO`，如下所示：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s go through all the characters in the text we want to draw and get their
    size, the bearing, so that we can set the position, and the texture ID of each
    glyph we want to draw, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们遍历我们要绘制的文本中的所有字符，获取它们的大小、偏移量，以便我们可以设置每个要绘制的字符的位置和纹理 ID，如下所示：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will now bind the  `VBO` and pass in the vertex data for all the quads to
    be drawn using `glBufferSubData`. Once bound, the quads are drawn using `glDrawArrays`
    and we pass in `6` for the number of vertices to be drawn.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将绑定 `VBO` 并使用 `glBufferSubData` 将所有要绘制的四边形的顶点数据传递进去。一旦绑定，四边形将通过 `glDrawArrays`
    绘制，我们传递 `6` 作为要绘制的顶点数。
- en: Then, we calculate `textPos.x`, which will determine where the next glyph will
    be drawn. We get this distance by multiplying the advance of the current glyph
    by the scale and adding it to the current text position's `x` component. A bit
    shift of `6` is done to `advance`, to get the value in pixels.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算 `textPos.x`，这将决定下一个字符将被绘制的位置。我们通过将当前字符的进位乘以缩放并添加到当前文本位置的 `x` 分量来获取这个距离。对
    `advance` 进行 `6` 比特的位移，以获取像素值。
- en: 'At the end of the draw function, we unbind the vertex array and the texture,
    and then disable blending, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在绘制函数的末尾，我们解绑顶点数组和纹理，然后禁用混合，如下所示：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we add the implementation of the `setPOsiton` and `setString` functions,
    as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加 `setPOsiton` 和 `setString` 函数的实现，如下所示：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re finally done with the `TextRenderer` class. Now, let''s learn how we
    can display the text in our game:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终完成了 `TextRenderer` 类。现在，让我们学习如何在我们的游戏中显示文本：
- en: 'In the `main.cpp` file, include`TextRenderer.h` at the top of the file and
    create a new object of the class called `label`, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 文件中，在文件顶部包含 `TextRenderer.h` 并创建一个名为 `label` 的类的新对象，如下所示：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new `GLuint` for the text shader program, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文本着色程序创建一个新的 `GLuint`，如下所示：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, create the new shaded program for the text, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建文本的新着色程序，如下所示：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `text.vs` and `text.fs` files are placed in the `Assets` directory under
    `Shaders.text.vs`, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`text.vs` 和 `text.fs` 文件放置在 `Assets` 目录下的 `Shaders.text.vs` 中，如下所示：'
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We get the vertex position as an attribute and the projection matrix as a uniform.
    The texture coordinate is set in the main function and is sent out to the next
    shader stage. The position of the vertex of the quad is set by multiplying the
    local coordinates by the orthographic projection matrix in the `main()` function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从属性中获取顶点位置和投影矩阵作为统一变量。纹理坐标在主函数中设置，并发送到下一个着色器阶段。四边形的顶点位置通过在 `main()` 函数中将局部坐标乘以正交投影矩阵来设置。
- en: 'Next, we''ll move on to the fragment shader, as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进入片段着色器，如下所示：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We get the texture coordinate from the vertex shader and the texture and color
    as uniforms. A new out `vec4` is created called color to send out color information.
    In the `main()` function, we create a new `vec4` called sampled and store the
    r,g, and b values as `1`. We also store the red color as the alpha value to draw
    only the opaque part of the text. Then, a new `vec4` called color is created,
    in which the white color is replaced with the color we want the text to be drawn
    in, and we assign the color variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从顶点着色器获取纹理坐标和纹理以及颜色作为统一变量。创建一个新的 `vec4` 叫做颜色，用于发送颜色信息。在 `main()` 函数中，我们创建一个新的
    `vec4` 叫做 sampled，并将 r、g 和 b 值存储为 `1`。我们还把红色颜色作为 alpha 值来绘制文本的不透明部分。然后，创建一个新的
    `vec4` 叫做颜色，其中将白色颜色替换为我们想要文本绘制的颜色，并分配颜色变量。
- en: 'Let''s continue with the text label implementation. After the `addRigidBody`
    function in the `init` function, initialize the `label` object, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续实现文本标签。在`init`函数中的`addRigidBody`函数之后，初始化`label`对象，如下所示：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the constructor, we set the string we want to render, pass in the location
    of the font file, and pass in the text height, the text color, and the text program.
    Then, we use the `setPosition` function to set the position of the text.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们设置要渲染的字符串，传入字体文件的路径，传入文本高度、文本颜色和文本程序。然后，我们使用`setPosition`函数设置文本的位置。
- en: 'Next, in the tick function, where we update the score, we update the text as
    well, as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`tick`函数中，我们更新分数时，也更新文本，如下所示：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the tick function, we reset the string when the game is over, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tick`函数中，当游戏结束时，我们重置字符串，如下所示：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `render` function, we call the `draw` function to draw the text, as
    follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`函数中，我们调用`draw`函数来绘制文本，如下所示：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because of alpha blending, the text has to be drawn at the end, after all the
    other objects have been drawn.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于alpha混合，文本必须在所有其他对象绘制完毕后绘制。
- en: 'Finally, make sure the font file has been added to the `Assets` folder under
    `Fonts`, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保字体文件已经添加到`Fonts`文件夹下的`Assets`文件夹中，如下所示：
- en: '![](img/3662e148-2020-4b4d-9b6f-31ff70aebe80.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3662e148-2020-4b4d-9b6f-31ff70aebe80.png)'
- en: 'A few font files have been provided that you can experiment with. More free
    fonts can be downloaded from [https://www.1001freefonts.com/](https://www.1001freefonts.com/)
    and [https://www.dafont.com/](https://www.dafont.com/). Build and run the game
    to see the text being drawn and updated:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一些字体文件，您可以进行实验。更多免费字体可以从[https://www.1001freefonts.com/](https://www.1001freefonts.com/)和[https://www.dafont.com/](https://www.dafont.com/)下载。构建并运行游戏以查看绘制的文本和更新：
- en: '![](img/72630a6f-c8f6-4ab4-be2e-90c46938acc1.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72630a6f-c8f6-4ab4-be2e-90c46938acc1.png)'
- en: Adding lighting
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加光照
- en: 'Finally, let''s add some lighting to the objects in the scene, just to make
    the objects more interesting to look at. We''ll do this by allowing the light
    renderer to be drawn in the scene. Here, the light is originating from the center
    of this sphere. Using the position of the light source, we will calculate whether
    a pixel is lit or not, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们给场景中的对象添加一些光照，以使对象看起来更有趣。我们将通过允许光照渲染器在场景中绘制来实现这一点。在这里，光照来自这个球体的中心。使用光源的位置，我们将计算像素是否被照亮，如下所示：
- en: '![](img/b87c3061-eb22-4f78-b700-678bff35778c.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b87c3061-eb22-4f78-b700-678bff35778c.png)'
- en: The picture on the left shows the scene unlit. In contrast, the scene on the
    right is lit with the earth sphere and the ground is affected by the light source.
    The surface that is facing the light is brightest, for example, at the top of
    the sphere. This creates a **Specular** at the top of the sphere. Since the surface
    is farther from/at an angle to the light source, those pixel values slowly diffuse.
    Then, there are surfaces that are not facing the light source at all, such as
    the side of the ground facing us. However, they are still not completely black
    as they are still being lit by the light from the source, which bounces around
    and becomes part of the ambient light. **Ambient**, **Diffuse,** and **Specular**
    become major parts of the lighting model when we wish to light up an object. Lighting
    models are used to simulate lighting in computer graphics because, unlike the
    real world, we are limited by the processing power of our hardware.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图片显示了未照亮的场景。相比之下，右侧的场景使用了地球球体照明，地面受到光源的影响。面向光源的表面最亮，例如球体的顶部。这就在球体的顶部创建了一个**镜面反射**。由于表面离光源较远/与光源成角度，这些像素值逐渐扩散。然后，还有一些完全未面向光源的表面，例如面向我们的地面侧面。然而，它们仍然不是完全黑色，因为它们仍然受到来自光源的光照，这些光照反射并成为环境光的一部分。**环境光**、**漫反射**和**镜面反射**成为我们想要照亮物体时照明模型的主要部分。照明模型用于在计算机图形中模拟光照，因为我们受限于硬件的处理能力，这与现实世界不同。
- en: 'The formula for the final color of the pixel according to the Phong shading
    model is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Phong着色模型的像素最终颜色公式如下：
- en: '*C = ka* Lc+ Lc * max(0, n l) + ks * Lc * max(0, v r) p*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*C = ka* Lc+ Lc * max(0, n l) + ks * Lc * max(0, v r) p*'
- en: 'Here, we have the following attributes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下属性：
- en: '*k*[*a* ]is the ambient strength.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*k*[*a* ]是环境强度。'
- en: '*L[c]* is the light color.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*L[c]*是光颜色。'
- en: '*n* is the surface normal.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*是表面法线。'
- en: '*l* is the light direction.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*是光方向。'
- en: '*k[s]* is the specular strength.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*k[s]*是镜面反射强度。'
- en: '*v* is the view direction.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*v*是视图方向。'
- en: '*r* is the reflected light direction about the normal of the surface.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r* 是关于表面法线的反射光方向。'
- en: '*p* is the Phong exponent, which will determine how shiny a surface is.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p* 是 Phong 指数，它将决定表面的光泽度。'
- en: 'For the **n**, **l**, **v** and **r** vectors, refer to the following diagram:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **n**、**l**、**v** 和 **r** 向量，请参考以下图表：
- en: '![](img/d0e6daa6-231d-4983-91eb-50bad4fbdbf3.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0e6daa6-231d-4983-91eb-50bad4fbdbf3.png)'
- en: 'Let''s look at how to implement this in practice:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在实践中实现这一点：
- en: 'All the lighting calculations are done in the fragment shader of the object,
    since this affects the final color of the object, depending on the light source
    and camera position. For each object to be lit, we also need to pass in the light
    color, diffuse, and specular strength. In the `MeshRenderer.h` file, change the
    constructor so that it takes the light source, diffuse, and specular strengths,
    as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的光照计算都是在对象的片段着色器中完成的，因为这将影响物体的最终颜色，这取决于光源和相机位置。对于每个要照明的物体，我们还需要传入光颜色、漫反射和镜面强度。在
    `MeshRenderer.h` 文件中，更改构造函数，使其接受光源、漫反射和镜面强度，如下所示：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Include `lightRenderer.h` at the top of the file, as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部包含 `lightRenderer.h`，如下所示：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the private section of the class, add an object for `LightRenderer` and
    floats to store the ambient and specular `Strength`, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的私有部分添加一个 `LightRenderer` 对象以及用于存储环境光和镜面强度的浮点数，如下所示：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `MeshRenderer.cpp` file, change the implementation of the constructor
    and assign the variables that were passed into the local variables, as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MeshRenderer.cpp` 文件中，更改构造函数的实现，并将传入的变量分配给局部变量，如下所示：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the constructor, we also need to add a new normal attribute, as we will
    need the surface normal information for lighting calculations, as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们还需要添加一个新的法线属性，因为我们需要表面法线信息来进行光照计算，如下所示：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the `Draw` function, we pass the camera position, light position, light
    color, specular strength, and ambient strength as uniforms to the shader, as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Draw` 函数中，我们将相机位置、光源位置、光源颜色、镜面强度和环境强度作为统一变量传递给着色器，如下所示：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also need to create new vertex and fragment shaders for the effect to take
    place. Let''s create a new vertex shader called `LitTexturedModel.vs`, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为效果创建新的顶点和片段着色器。让我们创建一个新的顶点着色器，称为 `LitTexturedModel.vs`，如下所示：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We add the new location layout in order to receive the normal attribute.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加新的位置布局以接收法线属性。
- en: Create a new out `vec3` so that we can send the normal information to the fragment
    shader. We will also create a new out `vec3` to send the world coordinates of
    a fragment. In the `main()` function, we calculate the world position of the fragment
    by multiplying the local position by the world matrix and store it in the `fragWorldPos`
    variable. The normal is also converted into world space. Unlike how we multiplied
    the local position, the model matrix that's used to convert into the normal world
    space needs to be treated differently. The normal is multiplied by the inverse
    of the model matrix and is stored in the normal variable. That's all for the vertex
    shader. Now, let's look at `LitTexturedModel.fs`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `out vec3`，以便我们可以将法线信息发送到片段着色器。我们还将创建一个新的 `out vec3` 来发送片段的世界坐标。在 `main()`
    函数中，我们通过将局部位置乘以世界矩阵来计算片段的世界位置，并将其存储在 `fragWorldPos` 变量中。法线也被转换为世界空间。与我们将局部位置相乘的方式不同，用于将法线转换为法线世界空间的模型矩阵需要以不同的方式处理。法线乘以模型矩阵的逆矩阵，并存储在法线变量中。这就是顶点着色器的内容。现在，让我们看看
    `LitTexturedModel.fs`。
- en: 'In the fragment shader, we get the texture coordinate, normal, and fragment
    world position. Next, we get the camera position, light position and color, specular
    and ambient strength uniforms, and the texture as uniform as well. The final pixel
    value will be stored in the out `vec4` called color, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们获取纹理坐标、法线和片段世界位置。接下来，我们获取相机位置、光源位置和颜色、镜面和环境强度统一变量，以及作为统一变量的纹理。最终的像素值将存储在名为
    `color` 的 `out vec4` 中，如下所示：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the `main()` function of the shader, we add the lighting calculation, as
    shown in the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器的 `main()` 函数中，我们添加了光照计算，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We get the normal and object color first. Then, as per the formula equation,
    we calculate the ambient part of the equation by multiplying the ambient strength
    and light color and store it in a `vec3` called ambient. For the diffuse part
    of the equation, we calculate the light direction from the position of the pixel
    in the world space by subtracting the two positions. The resulting vector is normalized
    and saved in `vec3 lightDir`. Then, we get the dot product of the normal and light
    directions.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先获取法线和物体颜色。然后，根据公式方程，我们通过乘以环境强度和光颜色来计算方程的环境部分，并将其存储在名为`ambient`的`vec3`中。对于方程的漫反射部分，我们通过从世界空间中像素的位置减去两个位置来计算光方向。结果向量被归一化并保存在`vec3
    lightDir`中。然后，我们计算法线和光方向之间的点积。
- en: After this, we get the resultant value or `0`, whichever is bigger, and store
    it in a float called `diff`. This is multiplied by the light color and stored
    in `vec3` to get the diffuse color. For the specular part of the equation, we
    calculate the view direction by subtracting the camera position from the fragment
    world position.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们获取结果值或`0`中的较大值，并将其存储在名为`diff`的浮点数中。这个值乘以光颜色并存储在`vec3`中以获得漫反射颜色。对于方程的镜面反射部分，我们通过从相机位置减去片段世界位置来计算视图方向。
- en: The resulting vector is normalized and stored in `vec3 specDir`. Then, the reflected
    light vector regarding the surface normal is calculated by using the reflect `glsl`
    intrinsic function and passing in the `viewDir` and surface normal.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果向量被归一化并存储在`vec3 specDir`中。然后，通过使用反射`glsl`内建函数并传入`viewDir`和表面法线来计算相对于表面法线的反射光向量。
- en: Then, the dot product of the view and reflected vector is calculated. The bigger
    value of the calculated value and `0` is chosen. The resulting float value is
    raised to the power of `128`. The value can be from *0 to 256*. The bigger the
    value, the shinier the object will appear. The specular value is calculated by
    multiplying the specular strength, the calculated spec value, and the light color
    stored in the specular `vec3`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，计算视图和反射向量的点积。选择计算值和`0`中的较大值。将得到的浮点值提高到`128`次幂。值可以从`0`到`256`。值越大，物体看起来越亮。通过将镜面反射强度、计算的镜面反射值和存储在镜面`vec3`中的光颜色相乘来计算镜面反射值。
- en: Finally, the total shading is calculated by adding the three ambient, diffuse,
    and specular values together and then multiplying this by the object color. The
    object color is a `vec4`, so we convert it into a `vec3`. The total color is assigned
    to the color variable by converting `totalColor` into a `vec4`. To implement this
    in the project, create a new shader program called `litTexturedShaderProgram`,
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将三个环境、漫反射和镜面反射值相加，然后乘以对象颜色来计算总的着色。对象颜色是一个`vec4`，所以我们将其转换为`vec3`。总颜色通过将`totalColor`转换为`vec4`分配给颜色变量。要在项目中实现这一点，创建一个新的着色程序，称为`litTexturedShaderProgram`。
- en: 'as follows:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下方式：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the add `rigidBody` function, change the shaders for the sphere, ground,
    and enemy, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加`rigidBody`函数中，按照以下方式更改球体、地面和敌人的着色器：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Build and run the project to see the lighting shader take effect:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目以查看光照着色器生效：
- en: '![](img/b06faca5-471a-44ba-ac28-74bdc467bf34.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b06faca5-471a-44ba-ac28-74bdc467bf34.png)'
- en: As an exercise, try adding a texture to the background, just like we did in
    the SFML game.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试向背景添加纹理，就像我们在SFML游戏中做的那样。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we can add collision detection between the game
    objects, and then we finished the game loop by adding controls and scoring. Using
    the font loading library FreeType, we loaded the TrueType font into our game to
    add scoring text to the game. Finally, to top it all off, we added lighting to
    the scene by adding the Phong lighting model to the objects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何添加游戏对象之间的碰撞检测，然后通过添加控制和得分来完成了游戏循环。使用字体加载库FreeType，我们将TrueType字体加载到我们的游戏中，以添加得分文本。最后，为了锦上添花，我们通过向对象添加Phong光照模型来添加场景中的光照。
- en: There is still a lot that can be added graphically to add more realism to our
    game, such as framebuffers that add postprocessing effects. We could also add
    particle effects such as dust and rain. To find out more, I would highly recommend
    [learnopengl.com](http://learnopengl.com), as it is an amazing source if you wish
    to learn more about OpenGL.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形上，我们还可以添加很多内容来增加游戏的真实感，例如添加后处理效果的帧缓冲区。我们还可以添加如灰尘和雨的粒子效果。要了解更多信息，我强烈推荐[learnopengl.com](http://learnopengl.com)，如果你希望了解更多关于OpenGL的信息，它是一个惊人的资源。
- en: In the next chapter, we will start exploring the Vulkan Rendering API and look
    at how it is different from OpenGL.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索 Vulkan 渲染 API，并查看它与 OpenGL 的不同之处。
