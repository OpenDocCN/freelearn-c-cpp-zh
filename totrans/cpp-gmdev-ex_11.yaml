- en: Enhancing Your Game with Collision, Loops, and Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to add collision to detect contact between
    the ball and the enemy; this will determine the lose condition. We will also check
    the contact between the ball and the ground to find out whether the player can
    jump or not. Then, we will finalize the gameplay loop.
  prefs: []
  type: TYPE_NORMAL
- en: Once the gameplay loop is complete, we will be able to add text rendering to
    show the player their score. To display the necessary text, we will use the FreeType
    library. This will load in the characters from the font file.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add some basic lighting to the objects in the scene. Lighting will
    be calculated using the Phong lighting model, and we will cover how this is implemented
    in practice. To finish the gameplay loop, we will have to add an enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a `RigidBody` name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an enemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the enemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding keyboard controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gameloop and scoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a RigidBody name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To identify the different rigid bodies we are going to be adding to the scene,
    we will add a property to the `MeshRenderer` class that will specify each object
    being rendered. Let''s look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MeshRenderer.h` class, which can be found within the `MeshRenderer`
    class, change the constructor of the class to take in a string as the name for
    the object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new public property called `name` of the `std::string` type and initialize
    it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `MeshRenderer.cpp` file, modify the constructor implementation,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully added the `name` property to the `MeshRenderer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add an enemy to the scene, let''s clean up our code a little bit
    and create a new function called `addRigidBodies` in `main.cpp` so that all the
    rigid bodies will be created in a single function. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the source of the `main.cpp` file, create a new function called `addRigidBodies`
    above the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `addRigidBodies` function. This will add the
    sphere and ground. We are doing this instead of putting all the game code in the
    `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that some of the values have been changed to suit our game. We have also
    disabled deactivation on the sphere because, if we don't, then the sphere will
    be unresponsive when we want it to jump for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the name of the rendered mesh, we can set this instance as a property
    of the rigid body by using the `setUserPointer` property of the `RigidBody` class.
    `setUserPointer` takes a void pointer, so any kind of data can be passed into
    it. For the sake of convenience, we are just passing the instance of the `MeshRenderer`
    class itself. In this function, we will also add the enemy''s rigid body to the
    scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add the enemy in the same way that we added the sphere and the ground. Since
    the shape of the enemy object is a cube, we use`btBoxShape` to set the shape of
    the box for the rigid body. We set the location to 18 units' distance in the *X*-axis
    and one unit's distance in the *Y*-axis. Then, we set the friction and restitution
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the type of the rigid body, we set its collision flag to `NO_CONTACT_RESPONSE`
    instead of `KINEMATIC_OBJECT`. We could have set the type to `KINEMATIC_OBJECT`,
    but then the enemy object would exert force on other objects, such as the sphere,
    when it comes in contact with it. To avoid this, we use `NO_CONTACT_RESPONSE`,
    which will just check if there was an overlap between the enemy rigid body and
    another body, instead of applying force to it.
  prefs: []
  type: TYPE_NORMAL
- en: You can uncomment the `KINEMATIC_OBJECT` line of code and comment on the `NO_CONTACT_RESPONSE` line
    of code to see how using either changes the way the object behaves in the physics
    simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the rigid body, we add the rigid body to the world, set
    the mesh renderer for the enemy object, and name it **enemy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving the enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the enemy's movement, we will add a tick function that will be called
    by the rigid body world. In this tick function, we will update the position of
    the enemy so that the enemy cube moves from the right of the screen to the left.
    We will also check whether the enemy has gone beyond the left-hand side of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it has, then we will reset its position to the right of the screen. To do
    so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this update function, we will also update our gameplay logic and scoring,
    as well as how we check for contact between the sphere and the enemy and the sphere
    and the ground. Add the tick function callback prototype to the top of the `Main.cpp`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `TickCallback` function, update the position of the enemy, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `myTickCallback` function, we get the current transform and store it
    in a variable, `t`. Then, we set the origin, which is the position of the transform,
    by getting the current position, moving it 15 units to the left, and multiplying
    it by the current timestep (which is the difference between the previous and current
    time).
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the updated location, we check that the current location is less
    than 18 units. If it is, then the current location is beyond the screen bounds
    on the left of the screen. Consequently, we set the current location back to the
    right of the viewport and make the object wrap around the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we update the location of the object itself to this new location by updating
    the `worldTransform` of the rigid body and the motion state of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the tick function as the default `TickCallback` of the dynamic world in
    the `init` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project to see the cube enemy spawn at the right of the screen,
    followed by it passing through the sphere and moving toward the left of the screen.
    When the enemy goes offscreen, it will be looped around to the right of the screen,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec234c82-a108-4331-bfa9-e8c8fe7eab04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we set the `collisionFlag` of the enemy to `KINEMATIC_OBJECT`, you will
    see that the enemy doesn''t go through the sphere but pushes it off the ground,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab66fea4-7ddd-4c3d-b00c-caf95c27b182.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not what we want as we don't want the enemy to physically interact with
    any objects. Change the collision flag of the enemy back to `NO_CONTACT_RESPONSE` to
    amend this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the tick function, we need to check for collision between the sphere and
    the enemy, as well as the sphere and the ground. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: To check the number of contacts between objects, we will use the `getNumManifolds`
    property of the dynamic world object. The manifold will contain information regarding
    all the contacts in the scene per update cycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to check whether the number of contacts is greater than zero. If it
    is, then we check which pairs of objects were in contact with each other. After
    updating the enemy object, add the following code to check for contact between
    the hero and the enemy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the number of contact manifolds or contact pairs. Then, for each
    contact manifold, we check whether the number of contacts is greater than zero.
    If it is greater than zero, then it means there has been a contact in the current
    update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we get both collision objects and assign them to `ObjA` and `ObjB`. After
    this, we get the user pointer for both objects and typecast it to `MeshRenderer`
    to access the name of the objects we assigned. When checking for contact between
    two objects, object A can be in contact with object B or the other way around.
    If there has been contact between the sphere and the enemy, we set the position
    of the enemy back to the right of the viewport. We also check for contact between
    the sphere and the ground. If there is contact, we just print out that there has
    been contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding keyboard controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some keyboard controls so that we can interact with the sphere.
    We will set it so that, when we press the up key on the keyboard, the sphere jumps.
    We will add the jump feature by applying an impulse to the sphere. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll use `GLFW`, which has a keyboard callback function so that we
    can add interaction with the keyboard for the game. Before we begin with the `main()`
    function, we will set this keyboard callback  function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The two main parameters that we are concerned with are the key and action. With
    key, we get which key is pressed, and with action, we can retrieve what action
    was performed on that key. In the function, we check whether the *Esc* key was
    pressed using the `glfwGetKey` function. If so, then we close the window using
    the `glfwSetWindowShouldClose` function by passing true as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To make the sphere jump, we check whether the up key was pressed. If it was,
    we create a new Boolean member variable called `grounded`, which describes a state
    if the sphere is touching the ground. If this is true, we set the Boolean value
    to `false` and apply an impulse of `100` units on the sphere's rigid body origin
    in the Y direction by calling the `applyImpulse` function of `rigidbody`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the tick function, before we get the number of manifolds, we set the `grounded`
    Boolean to false, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `grounded` Boolean value to true when there is contact between the
    sphere and the ground, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, set `updateKeyboard` as the callback using `glfwSetKeyCallback`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and run the application. Press the up key to see the sphere jump,
    but only when it is grounded, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e9392898-a6a3-4ddf-ae97-46d496b357c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Game loop and scoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s wrap this up by adding scoring and finishing the game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the `grounded` Boolean, add another Boolean and check for `gameover`.
    After doing this, add an `int` called `score` and initialize it to `0` at the
    top of the `main.cpp` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the tick function, the enemy should only move when the game is not
    over. So we wrap the update for the position of the enemy inside an **if** statement
    to check whether or not the game is over. If the game is not over, then we update
    the position of the enemy, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also increment the score if the enemy goes beyond the left of the screen.
    Still in the tick function, if there is contact between the sphere and the enemy,
    we set the score to `0` and set `gameover` to `true`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the update keyboard function, when the up keyboard key is pressed, we check
    whether the game is over. If it is, we set the `gameover` Boolean to false, which
    will start the game. Now, when the player presses the up key again, the character
    will jump. This way, the same key can be used for starting the game and also making
    the character jump.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the required changes to the `updateKeyboard` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Although we are calculating the score, the user still cannot see what the score
    is, so let's add text rendering to the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For rendering text, we will use a library called FreeType, load in the font,
    and read the characters from it. FreeType can load a popular font format called
    TrueType. TrueType fonts have a `.ttf` extension.
  prefs: []
  type: TYPE_NORMAL
- en: TTFs contain vector information called glyphs that can be used to store any
    data. One use case is, of course, to represent characters with them.
  prefs: []
  type: TYPE_NORMAL
- en: So, when we want to render a particular glyph, we load the character glyph by
    specifying its size; the character will be generated without there being a loss
    in quality.
  prefs: []
  type: TYPE_NORMAL
- en: The source of the FreeType library can be downloaded from their website at [https://www.freetype.org/](https://www.freetype.org/)
    and the library can be built from it. The precompiled libraries can also be downloaded
    from [https://github.com/ubawurinna/freetype-windows-binaries](https://github.com/ubawurinna/freetype-windows-binaries).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the library to our project. Since we are developing for the 64-bit
    OS, we are interested in the `include` directory and the `win64` directory; they
    contain the `freetype.lib` and `freetype.dll` files for our version of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `freetype` in your dependencies folder and extract the
    files into it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26c04855-bd22-4ccd-a0b7-9ba34233dcff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the project''s properties and, under C/C++ in Additional Include Directory,
    add the `freetype` include directory location, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57339f31-2a05-43dc-aeaf-9155d6d2a478.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under Configuration Properties | Linker | General | Additional Library Directories,
    add the freetype `win64` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c02482b4-37c3-4a6d-b849-a0bd9501f4dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the project directory, copy the `Freetype.dll` file from the `win64` directory
    and paste it here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2c29c11e-af9c-4aa1-a429-2e7802f3d41f.png)'
  prefs: []
  type: TYPE_IMG
- en: With the prep work out of the way, we can start working on the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class called `TextRenderer`, as well as a file called `TextRenderer.h`
    and a file called `TextRenderer.cpp`. We will add the functionality for text rendering
    to these files. In  `TextRenderer.h`, include the usual include headers for `GL`
    and `glm` as `b`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will include the headers for `freetype.h`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FT_FREETYPE_H` macro just includes `freetype.h` in the `freetype` directory.
    Then, we will `include <map>` as we will have to map each character''s location,
    size, and other information. We will also `include <string>` and pass a string
    into the class to be rendered, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For each glyph, we will need to keep track of certain properties. For this,
    we will create a `struct` called `Character`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For each glyph, we will store the texture ID of the texture we create for each
    character. We store the size of it, the bearing, which is the distance from the
    top left corner of the glyph from the baseline of the glyph, and the ID of the
    next glyph in the font file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a font file looks like when it has all the character glyphs in
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f02801f-784a-4cca-9cb5-1af8ca0ac180.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Information regarding each character is stored in relation to the character
    adjacent to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c492e9ab-55b9-45ab-97b1-736e587acda3.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of these properties can be accessed on a per glyph basis after we load
    the font face of the `FT_Face` type. The width and height of each glyph can be
    accessed using the glyph property per font face, that is, `face->glyph as face->glyph->bitmap.width`
    and `face->glyph->bitmap.rows`.
  prefs: []
  type: TYPE_NORMAL
- en: The image data is available per glyph using the `bitmap.buffer` property, which
    we will be using when we create the texture for each glyph. The following code
    shows how all of this is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The next glyph in the font file can be accessed using the `advance.x` property
    of the glyph if the font is horizontally aligned.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough theory about the library. If you are interested in finding out
    more, the necessary documentation is available on FreeType's website: [https://www.freetype.org/freetype2/docs/tutorial/step2.html#section-1](https://www.freetype.org/freetype2/docs/tutorial/step2.html#section-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the `TextRenderer.h` file and create the `TextRenderer`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the class under the public section, we add the constructor and destructor.
    In the constructor, we pass in the string we want to draw, the file we want to
    use, the size and color of the text we want to draw in, and pass in a shader program
    to use while drawing the font.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `draw` function to draw the text, a couple of setters to set
    the position, and a `setText` function to set a new string to draw if needed.
    In the private section, we have local variables for the text string, scale, color,
    and position. We also have member variables for `VAO`, `VBO`, and `program` so
    that we can draw the text string. At the end of the class, we create a map to
    store all the loaded characters and assign each `GLchar` to a character `struct`
    in the map. This is all we need to do for the `TextRenderer.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TextRenderer.cpp` file, include the `TextRenderer.h` file at the top
    of the file and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `TextRenderer` constructor implementation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we will add the functionally for loading all the characters
    and prep the class for drawing the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s initialize the local variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set the projection matrix. For text, we specify the orthographic
    projection since it doesn''t have any depth, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The projection is created using the `glm::ortho` function, which takes origin
    x, window width, origin y, and window height as the parameters for creating the
    orthographic projection matrix. We will use the current program and pass the value
    for the projection matrix to a location called projection, and then pass this
    on to the shader. Since this value will never change, it is called and assigned
    once in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we load the font itself, we have to initialize the FreeType library,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can load the font face itself, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the font size in pixels and disable the byte alignment restriction.
    If we don''t restrict the byte alignment, the font will be drawn jumbled, so don''t
    forget to add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will load the first `128` characters into the font we loaded and create
    and assign the texture ID, size, bearing, and advance. After, we will store the
    font in the characters map, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the characters have been loaded, we can unbind the texture and destroy
    the font face and FreeType library, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Each character will be drawn as a texture on a separate quad, so set the `VAO`/`VBO`
    for a quad, create a position attribute, and enable it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to unbind `VBO` and `VAO`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for the constructor. Now, we can move on to the draw function.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the draw function''s  implementation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the functionality for drawing to this function. First, we''ll get
    the position where the text needs to start drawing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to enable blending. If we don''t enable blending, the whole quad
    for the text will be colored instead of just the area where the text is present,
    as shown in the image on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b5c4d13-726e-4ea5-b2cb-b6f3c6784d9b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the image on the left, where the S is supposed to be, we can see the whole
    quad colored in red, including the pixels where it is supposed to be transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'By enabling blending, we set the final color value as a pixel using the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Color[final] = Color[Source] * Alpha[Source] + Color[Destination] * 1- Alpha[Source]*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, source color and source alpha are the color and alpha values of the text
    at a certain pixel location, while the destination color and alpha are the values
    of the color and alpha at the color buffer.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, since we draw the text later, the destination color will be
    yellow, and the source color, which is the text, will be red. The destination
    alpha value is 1.0 while the yellow color is opaque. For the text, if we take
    a look at the S glyph, for example, within the S, which is the red area, it is
    opaque, but it is transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this formula, let''s calculate the final pixel color around the S where
    it is transparent using the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Color[final] = (1.0f, 0.0f, 0.0f, 0.0f) * 0.0 + (1.0f, 1.0f, 0.0f, 1.0f) *
    (1.0f- 0.0f)'
  prefs: []
  type: TYPE_NORMAL
- en: = (1.0f, 1.0f, 0.0f, 1.0f);*
  prefs: []
  type: TYPE_NORMAL
- en: This is just the yellow background color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, within the S glyph, it is not transparent, so the alpha value is
    1 at that pixel location. So, when we apply the same formula, we get the final
    color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Color[final] = (1.0f, 0.0f, 0.0f, 1.0f) * 1.0 + (1.0f, 1.0f, 0.0f, 1.0f) *
    (1.0f- 1.0f)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= (1.0f, 0.0f, 0.0f, 1.0f)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just the red text color, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/299dfb78-cf0f-4fac-97ca-908b9309fee7.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how this is implemented in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blend` function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to set the source and destination blending factors, that is, `GL_SRC_ALPHA`.
    For the source pixel, we use its alpha value as-is, whereas, for the destination,
    we set the alpha to `GL_ONE_MINUS_SRC_ALPHA`, which is the source alpha minus
    one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: By default, the value source and destination values are added. You can subtract,
    add, and divide as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to call the `glUSeProgram` function to set the program, set the
    text color to the uniform location, and set the default texture, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to bind the `VAO`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through all the characters in the text we want to draw and get their
    size, the bearing, so that we can set the position, and the texture ID of each
    glyph we want to draw, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We will now bind the  `VBO` and pass in the vertex data for all the quads to
    be drawn using `glBufferSubData`. Once bound, the quads are drawn using `glDrawArrays`
    and we pass in `6` for the number of vertices to be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we calculate `textPos.x`, which will determine where the next glyph will
    be drawn. We get this distance by multiplying the advance of the current glyph
    by the scale and adding it to the current text position's `x` component. A bit
    shift of `6` is done to `advance`, to get the value in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the draw function, we unbind the vertex array and the texture,
    and then disable blending, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the implementation of the `setPOsiton` and `setString` functions,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re finally done with the `TextRenderer` class. Now, let''s learn how we
    can display the text in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.cpp` file, include`TextRenderer.h` at the top of the file and
    create a new object of the class called `label`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `GLuint` for the text shader program, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the new shaded program for the text, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `text.vs` and `text.fs` files are placed in the `Assets` directory under
    `Shaders.text.vs`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We get the vertex position as an attribute and the projection matrix as a uniform.
    The texture coordinate is set in the main function and is sent out to the next
    shader stage. The position of the vertex of the quad is set by multiplying the
    local coordinates by the orthographic projection matrix in the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll move on to the fragment shader, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We get the texture coordinate from the vertex shader and the texture and color
    as uniforms. A new out `vec4` is created called color to send out color information.
    In the `main()` function, we create a new `vec4` called sampled and store the
    r,g, and b values as `1`. We also store the red color as the alpha value to draw
    only the opaque part of the text. Then, a new `vec4` called color is created,
    in which the white color is replaced with the color we want the text to be drawn
    in, and we assign the color variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the text label implementation. After the `addRigidBody`
    function in the `init` function, initialize the `label` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we set the string we want to render, pass in the location
    of the font file, and pass in the text height, the text color, and the text program.
    Then, we use the `setPosition` function to set the position of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the tick function, where we update the score, we update the text as
    well, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the tick function, we reset the string when the game is over, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` function, we call the `draw` function to draw the text, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because of alpha blending, the text has to be drawn at the end, after all the
    other objects have been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make sure the font file has been added to the `Assets` folder under
    `Fonts`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3662e148-2020-4b4d-9b6f-31ff70aebe80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few font files have been provided that you can experiment with. More free
    fonts can be downloaded from [https://www.1001freefonts.com/](https://www.1001freefonts.com/)
    and [https://www.dafont.com/](https://www.dafont.com/). Build and run the game
    to see the text being drawn and updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72630a6f-c8f6-4ab4-be2e-90c46938acc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s add some lighting to the objects in the scene, just to make
    the objects more interesting to look at. We''ll do this by allowing the light
    renderer to be drawn in the scene. Here, the light is originating from the center
    of this sphere. Using the position of the light source, we will calculate whether
    a pixel is lit or not, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b87c3061-eb22-4f78-b700-678bff35778c.png)'
  prefs: []
  type: TYPE_IMG
- en: The picture on the left shows the scene unlit. In contrast, the scene on the
    right is lit with the earth sphere and the ground is affected by the light source.
    The surface that is facing the light is brightest, for example, at the top of
    the sphere. This creates a **Specular** at the top of the sphere. Since the surface
    is farther from/at an angle to the light source, those pixel values slowly diffuse.
    Then, there are surfaces that are not facing the light source at all, such as
    the side of the ground facing us. However, they are still not completely black
    as they are still being lit by the light from the source, which bounces around
    and becomes part of the ambient light. **Ambient**, **Diffuse,** and **Specular**
    become major parts of the lighting model when we wish to light up an object. Lighting
    models are used to simulate lighting in computer graphics because, unlike the
    real world, we are limited by the processing power of our hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for the final color of the pixel according to the Phong shading
    model is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C = ka* Lc+ Lc * max(0, n l) + ks * Lc * max(0, v r) p*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*k*[*a* ]is the ambient strength.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*L[c]* is the light color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* is the surface normal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* is the light direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*k[s]* is the specular strength.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*v* is the view direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r* is the reflected light direction about the normal of the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p* is the Phong exponent, which will determine how shiny a surface is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the **n**, **l**, **v** and **r** vectors, refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0e6daa6-231d-4983-91eb-50bad4fbdbf3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at how to implement this in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the lighting calculations are done in the fragment shader of the object,
    since this affects the final color of the object, depending on the light source
    and camera position. For each object to be lit, we also need to pass in the light
    color, diffuse, and specular strength. In the `MeshRenderer.h` file, change the
    constructor so that it takes the light source, diffuse, and specular strengths,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Include `lightRenderer.h` at the top of the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the private section of the class, add an object for `LightRenderer` and
    floats to store the ambient and specular `Strength`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MeshRenderer.cpp` file, change the implementation of the constructor
    and assign the variables that were passed into the local variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we also need to add a new normal attribute, as we will
    need the surface normal information for lighting calculations, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Draw` function, we pass the camera position, light position, light
    color, specular strength, and ambient strength as uniforms to the shader, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create new vertex and fragment shaders for the effect to take
    place. Let''s create a new vertex shader called `LitTexturedModel.vs`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We add the new location layout in order to receive the normal attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new out `vec3` so that we can send the normal information to the fragment
    shader. We will also create a new out `vec3` to send the world coordinates of
    a fragment. In the `main()` function, we calculate the world position of the fragment
    by multiplying the local position by the world matrix and store it in the `fragWorldPos`
    variable. The normal is also converted into world space. Unlike how we multiplied
    the local position, the model matrix that's used to convert into the normal world
    space needs to be treated differently. The normal is multiplied by the inverse
    of the model matrix and is stored in the normal variable. That's all for the vertex
    shader. Now, let's look at `LitTexturedModel.fs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the fragment shader, we get the texture coordinate, normal, and fragment
    world position. Next, we get the camera position, light position and color, specular
    and ambient strength uniforms, and the texture as uniform as well. The final pixel
    value will be stored in the out `vec4` called color, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function of the shader, we add the lighting calculation, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We get the normal and object color first. Then, as per the formula equation,
    we calculate the ambient part of the equation by multiplying the ambient strength
    and light color and store it in a `vec3` called ambient. For the diffuse part
    of the equation, we calculate the light direction from the position of the pixel
    in the world space by subtracting the two positions. The resulting vector is normalized
    and saved in `vec3 lightDir`. Then, we get the dot product of the normal and light
    directions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we get the resultant value or `0`, whichever is bigger, and store
    it in a float called `diff`. This is multiplied by the light color and stored
    in `vec3` to get the diffuse color. For the specular part of the equation, we
    calculate the view direction by subtracting the camera position from the fragment
    world position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resulting vector is normalized and stored in `vec3 specDir`. Then, the reflected
    light vector regarding the surface normal is calculated by using the reflect `glsl`
    intrinsic function and passing in the `viewDir` and surface normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the dot product of the view and reflected vector is calculated. The bigger
    value of the calculated value and `0` is chosen. The resulting float value is
    raised to the power of `128`. The value can be from *0 to 256*. The bigger the
    value, the shinier the object will appear. The specular value is calculated by
    multiplying the specular strength, the calculated spec value, and the light color
    stored in the specular `vec3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the total shading is calculated by adding the three ambient, diffuse,
    and specular values together and then multiplying this by the object color. The
    object color is a `vec4`, so we convert it into a `vec3`. The total color is assigned
    to the color variable by converting `totalColor` into a `vec4`. To implement this
    in the project, create a new shader program called `litTexturedShaderProgram`,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the add `rigidBody` function, change the shaders for the sphere, ground,
    and enemy, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project to see the lighting shader take effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b06faca5-471a-44ba-ac28-74bdc467bf34.png)'
  prefs: []
  type: TYPE_IMG
- en: As an exercise, try adding a texture to the background, just like we did in
    the SFML game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can add collision detection between the game
    objects, and then we finished the game loop by adding controls and scoring. Using
    the font loading library FreeType, we loaded the TrueType font into our game to
    add scoring text to the game. Finally, to top it all off, we added lighting to
    the scene by adding the Phong lighting model to the objects.
  prefs: []
  type: TYPE_NORMAL
- en: There is still a lot that can be added graphically to add more realism to our
    game, such as framebuffers that add postprocessing effects. We could also add
    particle effects such as dust and rain. To find out more, I would highly recommend
    [learnopengl.com](http://learnopengl.com), as it is an amazing source if you wish
    to learn more about OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start exploring the Vulkan Rendering API and look
    at how it is different from OpenGL.
  prefs: []
  type: TYPE_NORMAL
