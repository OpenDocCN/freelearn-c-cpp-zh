["```cpp\n#include <iostream>\n#include <memory>\n#include \"Person.h\"\nusing std::cout;   // preferred to: using namespace std;\nusing std::endl;\nusing std::unique_ptr;\n// We will create unique pointers, with and without using\n// the make_unique (safe wrapper) interface\nint main()\n{\n    unique_ptr<int> p1(new int(100));\n    cout << *p1 << endl;\n    unique_ptr<Person> pers1(new Person(\"Renee\",\n                             \"Alexander\",'K', \"Dr.\"));\n    (*pers1).Print();      // or use: pers1->Print();\n    unique_ptr<Person> pers2; // currently uninitialized\n    pers2 = move(pers1);// take over another unique\n                           // pointer's resource\n    pers2->Print();        // or use: (*pers2).Print();  \n    // make_unique provides a safe wrapper, eliminating\n    // obvious use of heap allocation with new()\n    auto pers3 = make_unique<Person>(\"Giselle\", \"LeBrun\",\n                                      'R', \"Ms.\");\n    pers3->Print();        \n    return 0;\n}\n```", "```cpp\n100\nDr. Renee K. Alexander\nDr. Renee K. Alexander\nMs. Giselle LeBrun\nPerson destructor\nPerson destructor\n```", "```cpp\n#include <iostream>\n#include <memory>\n#include \"Person.h\"\nusing std::cout;   // preferred to: using namespace std;\nusing std::endl;\nusing std::shared_ptr;\nint main()\n{\n    shared_ptr<int> p1 = std::make_shared<int>(100);\n    // alternative to preferred, previous line of code:\n    // shared_ptr<int> p1(new int(100));\n    shared_ptr<int> p2;// currently uninitialized (caution)\n    p2 = p1; // p2 now shares the same memory as p1\n    cout << *p1 << \" \" << *p2 << endl;\n    shared_ptr<Person> pers1 = std::make_shared<Person>\n                          (\"Gabby\", \"Doone\", 'A', \"Miss\");\n    // alternative to preferred, previous lines of code:\n    // shared_ptr<Person> pers1(new Person(\"Gabby\",\n    //                              \"Doone\",'A', \"Miss\"));\n    shared_ptr<Person> pers2 = pers1;  // initialized\n    pers1->Print();   // or use: (*pers1).Print();\n    pers2->Print();   \n    pers1->ModifyTitle(\"Dr.\"); // changes shared instance\n    pers2->Print();   \n    cout << \"Number of references: \" << pers1.use_count();\n    return 0;\n}\n```", "```cpp\n100 100\nMiss Gabby Doone\nMiss Gabby Doone\nDr. Gabby Doone\nNumber of references: 2\nPerson destructor\n```", "```cpp\n#include <iostream>\n#include <memory>\n#include \"Person.h\"\nusing std::cout;   // preferred to: using namespace std;\nusing std::endl;\nusing std::weak_ptr;\nusing std::shared_ptr;\nint main()\n{\n    // construct the resource using a shared pointer\n    shared_ptr<Person> pers1 = std::make_shared<Person>\n                           (\"Gabby\", \"Doone\", 'A', \"Miss\");\n    pers1->Print(); // or alternatively: (*pers1).Print();\n    // Downgrade resource to a weak pointer\n    weak_ptr<Person> wpers1(pers1); \n    // weak pointer cannot access the resource; \n    // must convert to a shared pointer to do so\n    // wpers1->Print();   // not allowed! operator-> is not\n                          // overloaded in weak_ptr class\n    cout << \"# references: \" << pers1.use_count() << endl;\n    cout << \"# references: \" << wpers1.use_count() << endl;\n    // establish a new shared pointer to the resource\n    shared_ptr<Person> pers2 = wpers1.lock();  \n    pers2->Print();\n    pers2->ModifyTitle(\"Dr.\");   // modify the resource\n    pers2->Print();\n    cout << \"# references: \" << pers1.use_count() << endl;\n    cout << \"# references: \" << wpers1.use_count() << endl;\n    cout << \"# references: \" << pers2.use_count() << endl;\n    return 0;\n}\n```", "```cpp\nMiss Gabby Doone\n# references: 1\n# references: 1\nMiss Gabby Doone\nDr. Gabby Doone\n# references: 2\n# references: 2\n# references: 2\nPerson destructor\n```", "```cpp\n#include <vector>  \nusing std::vector;  \n// Assume additional #include/using as typically included\n// Assume classes Person, Student are as typically defined\n// In this const member function, no part of 'this' will\n// be modified. Student::Print() can be called by const\n// instances of Student, including const iterators \nvoid Student::Print() const\n{   // need to use access functions as these data members\n    // are defined in Person as private\n    cout << GetTitle() << \" \" << GetFirstName() << \" \";\n    cout << GetMiddleInitial() << \". \" << GetLastName();\n    cout << \" with id: \" << studentId << \" GPA: \";\n    cout << setprecision(3) <<  \" \" << gpa;\n    cout << \" Course: \" << currentCourse << endl;\n}\nint main()\n{   // Utilize STL::vector instead of more native C++ data\n    // structures (such as an array of pointers to Student)\n    // There's less chance for us to make an error with\n    // memory allocation, deallocation, deep copies, etc.\n    vector<Student> studentBody;  \n    studentBody.push_back(Student(\"Hana\", \"Sato\", 'U', \n                           \"Miss\", 3.8, \"C++\", \"178PSU\"));\n    studentBody.push_back(Student(\"Sam\", \"Kato\", 'B', \n                           \"Mr.\", 3.5, \"C++\", \"272PSU\"));\n    studentBody.push_back(Student(\"Giselle\", \"LeBrun\", 'R',\n                           \"Ms.\", 3.4, \"C++\", \"299TU\"));\n    // Notice that our first loop uses traditional notation\n    // to loop through each element of the vector.\n    // Compare this loop to next loop using an iterator and\n    // also to the preferred range-for loop further beyond\n    // Note: had we used MAX instead of studentBody.size(),\n    // we'd have a potential error – what if MAX isn't the\n    // same as studentBody.size()? \n    for (int i = 0; i < studentBody.size(); i++)   \n        studentBody1[i].Print();  \n    // Notice auto keyword simplifies iterator declaration\n    // However, an iterator is still not the most\n    // preferred looping mechanism. \n    // Note, iterator type is: vector<Student>::iterator\n    // the use of auto replaces this type, simplifying as: \n    for (auto iter = studentBody.begin(); \n              iter != studentBody.end(); iter++)\n        (*iter).EarnPhD();\n    // Preferred range-for loop \n    // Uses auto to simplify type and const to ensure no\n    // modification. As a const iterator, student may only\n    // call const member fns on the set it iterates thru\n    for (const auto &student : studentBody)\n        student.Print();\n    return 0;\n}\n```", "```cpp\nMiss Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++\nMr. Sam B. Kato with id: 272PSU GPA:  3.5 Course: C++\nMs. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++\nEveryone to earn a PhD\nDr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++\nDr. Sam B. Kato with id: 272PSU GPA:  3.5 Course: C++\nDr. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++\n```", "```cpp\nclass Person\n{\nprivate: \n   string firstName; // str mbrs are default constructed so\n   string lastName;  // we don't need in-class initializers\n   char middleInitial = '\\0';  // in-class initialization\n   string title;  \nprotected: \n   void ModifyTitle(const string &); \npublic:\n   Person() = default;   // default constructor\n   Person(const string &, const string &, char, \n          const string &);  \n   // use default copy constructor and default destructor\n   // inline function definitions\n   const string &GetFirstName() const { return firstName; }\n   const string &GetLastName() const { return lastName; }\n   const string &GetTitle() const { return title; } \n   char GetMiddleInitial() const { return middleInitial; }\n};\n// With in-class initialization, it often not necessary to\n// write the default constructor yourself – there's often\n// nothing remaining to initialize!\n// alternate constructor\n// Note use of member init list to initialize data members\nPerson::Person(const string &fn, const string &ln, char mi,\n               const string &t): firstName(fn),\n               lastName(ln), middleInitial(mi), title(t)\n{\n    // no need to assign values in body of method –\n    // initialization has handled everything!\n}\n```", "```cpp\nclass Person\n{\nprivate: \n    string firstName;\n    string lastName;\n    char middleInitial = '\\0';  // in-class initialization\n    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.\nprotected:\n    void ModifyTitle(const string &); \npublic:\n    Person() = default;   // default constructor\n    Person(const string &, const string &, char, \n           const string &); \n    virtual ~Person();  // virtual destructor\n    const string &GetFirstName() const \n        { return firstName; } \n    const string &GetLastName() const { return lastName; }\n    const string &GetTitle() const { return title; } \n    char GetMiddleInitial() const { return middleInitial; }\n    virtual void Print() const; // polymorphic operations\n    virtual void IsA() const;   // introduced at this level\n    virtual void Greeting(const string &) const;\n};\n// Assume the non-inline member functions for Person \n// follow and are as we are accustomed to seeing\nclass Student: public Person\n{\nprivate: \n    float gpa = 0.0;   // in-class initialization\n    string currentCourse;\n    const string studentId; \n    static int numStudents;  // static data member\npublic:\n    Student();  // default constructor\n    Student(const string &, const string &, char, \n            const string &, float, const string &, \n            const string &); \n    Student(const Student &);  // copy constructor\n    ~Student() override;  // virtual destructor\n    void EarnPhD();  \n    // inline function definitions\n    float GetGpa() const { return gpa; }\n    const string &GetCurrentCourse() const\n        { return currentCourse; }\n    const string &GetStudentId() const \n        { return studentId; }\n    void SetCurrentCourse(const string &); // proto. only\n\n    // In the derived class, keyword virtual is optional, \n    // and not currently recommended. Use override instead.\n    void Print() const final; // override is optional here\n    void IsA() const override;\n    // note, we choose not to redefine (override):\n    // Person::Greeting(const string &) const\n    static int GetNumberStudents(); // static mbr. function\n};\n// definition for static data member \nint Student::numStudents = 0;  // notice initial value of 0\n// Assume the non-inline, non-static member functions for\n// Students follow and are as we are accustomed to seeing\n```"]