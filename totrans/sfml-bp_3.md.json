["```cpp\nconst int _x, const _y;\n```", "```cpp\nGame(int x=800, int y=600);\n```", "```cpp\nGame::Game(int x, int y) : _window(sf::VideoMode(x,y),\"03_Asteroid\"),x(x),y(y){\n     _player.setPosition(100,100);\n}\n```", "```cpp\nvoid Game::update(sf::Time deltaTime)\n{\n  _player.update(deltaTime);\n  sf::Vector2f player_pos = _player.getPosition();\n  if(player_pos.x < 0){\n    player_pos.x = _x;\n    player_pos.y = _y - player_pos.y;\n  } else if (player_pos.x > _x){\n    player_pos.x = 0;\n    player_pos.y = _y - player_pos.y;\n  }\n  if(player_pos.y < 0)\n  player_pos.y = _y;\n  else if(player_pos.y > _y)\n  player_pos.y = 0;\n  _player.setPosition(player_pos);\n}\n```", "```cpp\nconst sf::Vector2f& Player::getPosition()const{return _ship.getPosition();}\n```", "```cpp\nclass World : public sf::Drawable\n{\n  public:\n  World(const World&) = delete;\n  World& operator=(const World&) = delete;\n  World(float x,float y);\n  ~World();\n  void add(Entity* entity);\n  void clear();\n  bool isCollide(const Entity& other);\n  int size();\n\n  void add(Configuration::Sounds sound_id);\n\n  const std::list<Entity*> getEntities()const;\n  int getX()const;\n  int getY()const;\n  void update(sf::Time deltaTime);\n  private:\n  std::list<Entity*>  _entities; \n  std::list<Entity*>  _entities_tmp;\n\n  std::list<std::unique_ptr<sf::Sound>> _sounds;\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates \n  states) const override;\n\n  const int _x;\n  const int _y;\n};\n```", "```cpp\nWorld::World(float x,float y): _x(x),_y(y){}\nWorld::~World(){clear();}\n```", "```cpp\nvoid World::add(Entity* entity) {\n    _entities_tmp.push_back(entity);\n}\n```", "```cpp\nvoid World::clear()\n{\n  for(Entity* entity :_entities)\n  delete entity;\n  _entities.clear();\n  for(Entity* entity :_entities_tmp)\n  delete entity;\n  _entities_tmp.clear();\n  _sounds.clear();\n}\n```", "```cpp\nvoid World::add(Configuration::Sounds sound_id)\n{\n  std::unique_ptr<sf::Sound> sound(new sf::Sound(Configuration::sounds.get(sound_id)));\n  sound->setAttenuation(0);\n  sound->play();\n  _sounds.emplace_back(std::move(sound));\n}\n```", "```cpp\nbool World::isCollide(const Entity& other)\n{\n    for(Entity* entity_ptr : _entities)\n        if(other.isCollide(*entity_ptr))\n            return true;\n    return false;\n}\n```", "```cpp\nint World::size(){return _entities.size() + _entities_tmp.size();}\nint World::getX()const{return _x;}\nint World::getY()const {return _y;}\nconst std::list<Entity*> World::getEntities()const {return _entities;}\n```", "```cpp\nvoid World::update(sf::Time deltaTime)\n{\n  if(_entities_tmp.size() > 0)\n  _entities.merge(_entities_tmp);\n  for(Entity* entity_ptr : _entities)\n  {\n    Entity& entity = *entity_ptr; \n    entity.update(deltaTime);    \n    sf::Vector2f pos = entity.getPosition();\n    if(pos.x < 0)\n    {\n      pos.x = _x;\n      pos.y = _y - pos.y;\n    } else if (pos.x > _x) {\n      pos.x = 0;\n      pos.y = _y - pos.y;\n    }\n    if(pos.y < 0)\n    pos.y = _y;\n    else if(pos.y > _y)\n    pos.y = 0;\n    entity.setPosition(pos);\n  }\n  const auto end = _entities.end();\n  for(auto it_i = _entities.begin(); it_i != end; ++it_i)\n  {\n    Entity& entity_i = **it_i;\n    auto it_j = it_i;\n    it_j++;\n    for(; it_j != end;++it_j)\n    {\n      Entity& entity_j = **it_j;\n      if(entity_i.isAlive() and entity_i.isCollide(entity_j))\n      entity_i.onDestroy();\n      if(entity_j.isAlive() and entity_j.isCollide(entity_i))\n      entity_j.onDestroy();\n    }\n  }\n  for(auto it = _entities.begin(); it != _entities.end();)\n  {\n    if(not (*it)->isAlive())\n    {\n      delete *it;\n      it = _entities.erase(it);\n    }\n    else\n    ++it;\n  }\n  _sounds.remove_if([](const std::unique_ptr<sf::Sound>& sound) -> bool {\n    return sound->getStatus() != sf::SoundSource::Status::Playing;\n  });\n}\n```", "```cpp\nvoid World::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  for(Entity* entity : _entities)\n  target.draw(*entity,states);\n}\n```", "```cpp\nclass Collision\n{\n  public:\n    Collision() = delete;\n    Collision(const Collision&) = delete;\n    Collision& operator=(const Collision&) = delete;\n    static bool circleTest(const sf::Sprite& first, const sf::Sprite& second);\n};\n```", "```cpp\nbool Collision::circleTest(const sf::Sprite& first, const sf::Sprite& second)\n{\n  sf::Vector2f first_rect(first.getTextureRect().width,\n  first.getTextureRect().height);\n  first_rect.x *= first.getScale().x;\n  first_rect.y *= first.getScale().y;\n\n  sf::Vector2f second_rect(second.getTextureRect().width, \n  second.getTextureRect().height);\n  second_rect.x *= second.getScale().x;\n  second_rect.y *= second.getScale().y;\n\n  float radius1 = (first_rect.x + first_rect.y) / 4;\n  float radius2 = (second_rect.x + second_rect.y) / 4;\n  float xd = first.getPosition().x - second.getPosition().x;\n  float yd = first.getPosition().y - second.getPosition().y;\n\n  return std::sqrt(xd * xd + yd * yd) <= radius1 + radius2;\n}\n```", "```cpp\nclass Entity :  public sf::Drawable\n{\n  public:\n//Constructors\n  Entity(const Entity&) = delete;\n  Entity& operator=(const Entity&) = delete;\n  Entity(Configuration::Textures tex_id,World& world);\n  virtual ~Entity();\n\n//Helpers\n  virtual bool isAlive()const;\n\n  const sf::Vector2f& getPosition()const;\n  template<typename ... Args>\n  void setPosition(Args&& ... args);\n  virtual bool isCollide(const Entity& other)const = 0;\n\n//Updates\n  virtual void update(sf::Time deltaTime) = 0;\n  virtual void onDestroy();\n\n  protected:\n  sf::Sprite _sprite;\n  sf::Vector2f _impulse;\n  World& _world;\n  bool _alive;\n\n  private :\n  virtual void draw(sf::RenderTarget& target, sf::RenderStates \n  states) const override;\n};\n```", "```cpp\nEntity::Entity(Configuration::Textures tex_id,World& world) : _world(world),_alive(true)\n{\n  sf::Texture& texture = Configuration::textures.get(tex_id);\n  _sprite.setTexture(texture);\n  _sprite.setOrigin(texture.getSize().x/2.f,texture.getSize().y/2.f);\n}\n```", "```cpp\nconst sf::Vector2f& Entity::getPosition()const {return _sprite.getPosition();}\nvoid Entity::draw(sf::RenderTarget& target, sf::RenderStates states) const {target.draw(_sprite,states);}\n```", "```cpp\nbool Entity::isAlive()const {return _alive;}\nvoid Entity::onDestroy(){_alive = false;}\n```", "```cpp\nclass Player : public Entity , public ActionTarget<int>\n{\n  public:\n  Player(const Player&) = delete;\n  Player& operator=(const Player&) = delete;\n  Player(World& world);\n\n  virtual bool isCollide(const Entity& other)const;\n  virtual void update(sf::Time deltaTime);\n  void processEvents();\n  void shoot();\n  void goToHyperspace();\n  virtual void onDestroy();\n\n  private:\n  bool _isMoving;\n  int _rotation;\n  sf::Time _timeSinceLastShoot;\n}\n```", "```cpp\nPlayer::Player(World& world) : Entity(Configuration::Textures::Player,world),ActionTarget(Configuration::player_inputs),_isMoving(false),_rotation(0)\n{\n  //bind ..     \n  bind(Configuration::PlayerInputs::Shoot,[this](const sf::Event&){\n    shoot();\n  });\n  bind(Configuration::PlayerInputs::Hyperspace,[this](const sf::Event&){\n    goToHyperspace();\n  });\n}\n```", "```cpp\nbool Player::isCollide(const Entity& other)const\n{\n  if(dynamic_cast<const ShootPlayer*>(&other) == nullptr) {\n    return Collision::circleTest(_sprite,other._sprite);\n  }\n  return false;\n}\n```", "```cpp\nvoid Player::shoot()\n{\n  if(_timeSinceLastShoot > sf::seconds(0.3))\n  {\n    _world.add(new ShootPlayer(*this));\n    _timeSinceLastShoot = sf::Time::Zero;\n  }\n}\n```", "```cpp\nvoid Player::goToHyperspace()\n{\n  _impulse = sf::Vector2f(0,0);\n  setPosition(random(0,_world.getX()),random(0,_world.getY()));\n  _world.add(Configuration::Sounds::Jump);\n}\n```", "```cpp\nvoid Player::update(sf::Time deltaTime)\n{\n  float seconds = deltaTime.asSeconds();\n  _timeSinceLastShoot += deltaTime;\n  if(_rotation != 0)\n  {\n    float angle = _rotation*250*seconds;\n    _sprite.rotate(angle);\n  }\n\n  if(_isMoving)\n  {\n    float angle = _sprite.getRotation() / 180 * M_PI - M_PI / 2;\n    _impulse += sf::Vector2f(std::cos(angle),std::sin(angle)) * 300.f * \n    seconds;\n  }\n  _sprite.move(seconds * _impulse);\n}\n```", "```cpp\nvoid Player::onDestroy()\n{\n  Entity::onDestroy();\n  Configuration::lives--;\n  _world.add(Configuration::Sounds::Boom);\n}\n```", "```cpp\nclass Enemy : public Entity\n{\n  public:\n  Enemy(const Enemy&) = delete;\n  Enemy& operator=(const Enemy&) = delete;\n  Enemy(Configuration::Textures tex_id,World& world);\n\n  virtual int getPoints()const = 0;\n  virtual void onDestroy();\n};\n```", "```cpp\nEnemy::Enemy(Configuration::Textures tex_id,World& world) : \n  Entity(tex_id,world)\n{\n  float angle = random(0.f,2.f*M_PI);\n  _impulse = sf::Vector2f(std::cos(angle),std::sin(angle));\n}\n```", "```cpp\nvoid Enemy::onDestroy()\n{\n  Entity::onDestroy();\n  Configuration::addScore(getPoints());\n}\n```", "```cpp\nclass Saucer : public Enemy\n{\n  public:\n  Saucer(const Saucer&) = delete;\n  Saucer& operator=(const Saucer&) = delete;\n  using Enemy::Enemy;\n\n  virtual bool isCollide(const Entity& other)const;\n  virtual void update(sf::Time deltaTime);\n  virtual void onDestroy();\n  static void newSaucer(World& world);\n};\n```", "```cpp\nbool Saucer::isCollide(const Entity& other)const\n{\n  if(dynamic_cast<const ShootSaucer*>(&other) == nullptr) {\n    return Collision::circleTest(_sprite,other._sprite);\n  }\n  return false;\n}\n```", "```cpp\nvoid Saucer::update(sf::Time deltaTime)\n{\n  float seconds = deltaTime.asSeconds();\n  Entity* near = nullptr;\n  float near_distance = 300;\n  for(Entity* entity_ptr : _world.getEntities())\n  {\n    if(entity_ptr != this and(dynamic_cast<const \n      Meteor*>(entity_ptr) or dynamic_cast<const \n        ShootPlayer*>(entity_ptr)))\n    {\n      float x = getPosition().x - entity_ptr->getPosition().x;\n      float y = getPosition().y - entity_ptr->getPosition().y;\n      float dist = std::sqrt(x*x + y*y);\n      if(dist < near_distance) {\n\n           near_distance = dist;\n           near = entity_ptr;\n     }\n  }\n}\nif(near != nullptr) \n{\n  sf::Vector2f pos = near->getPosition() - getPosition();\n  float angle_rad = std::atan2(pos.y,pos.x);\n  _impulse -= \n    sf::Vector2f(std::cos(angle_rad),std::sin(angle_rad)) * 300.f \n      * seconds;\n} else {\n  sf::Vector2f pos = Configuration::player->getPosition() - \n    getPosition();\n  float angle_rad = std::atan2(pos.y,pos.x);\n  _impulse += \n    sf::Vector2f(std::cos(angle_rad),std::sin(angle_rad)) * 100.f \n      * seconds;\n  }\n_sprite.move(seconds * _impulse);\n}\n```", "```cpp\n    void Saucer::onDestroy()\n    {\n        Enemy::onDestroy();\n        _world.add(Configuration::Sounds::Boom2);\n    }\n    ```", "```cpp\n    void Saucer::newSaucer(World& world)\n    {\n      Saucer* res = nullptr;\n      if(book::random(0.f,1.f) > Configuration::getScore()/ 40000.f)\n      res = new BigSaucer(world);\n      else\n      res = new SmallSaucer(world);\n      res->setPosition(random(0,1)*world.getX(),random(0.f,(float)world.getY()));\n      world.add(res);\n    }\n    ```", "```cpp\nclass SmallSaucer : public Saucer\n{\n  public :\n  SmallSaucer(World& world);\n  virtual int getPoints()const;\n  virtual void update(sf::Time deltaTime);\n  private:\n  sf::Time_timeSinceLastShoot;\n};\n```", "```cpp\nSmallSaucer::SmallSaucer(World& world) : Saucer(Configuration::Textures::SmallSaucer,world)\n{\n  _timeSinceLastShoot = sf::Time::Zero;\n  _world.add(Configuration::Sounds::SaucerSpawn2);\n  _impulse *= 400.f;\n}\n```", "```cpp\nint SmallSaucer::getPoints()const {return 200;}\n```", "```cpp\nvoid SmallSaucer::update(sf::Time deltaTime)\n{\n  Saucer::update(deltaTime);\n  _timeSinceLastShoot += deltaTime;\n  if(_timeSinceLastShoot > sf::seconds(1.5))\n  {\n    if(Configuration::player != nullptr)\n    _world.add(new ShootSaucer(*this));\n    _timeSinceLastShoot = sf::Time::Zero;\n  }\n}\n```", "```cpp\nclass Meteor : public Enemy\n{\n  public:\n  Meteor(const Meteor&) = delete;\n  Meteor& operator=(const Meteor&) = delete;\n  using Enemy::Enemy;\n\n  virtual bool isCollide(const Entity& other)const;\n  virtual void update(sf::Time deltaTime);\n};\n```", "```cpp\nbool Meteor::isCollide(const Entity& other)const\n{\n  if(dynamic_cast<const Meteor*>(&other) == nullptr) {\n    return Collision::circleTest(_sprite,other._sprite);\n  }\n  return false;\n}\n```", "```cpp\nvoid Meteor::update(sf::Time deltaTime)\n{\n  float seconds = deltaTime.asSeconds();\n  _sprite.move(seconds * _impulse);\n}\n```", "```cpp\nclass BigMeteor : public Meteor\n{\n  public :\n  BigMeteor(World& world);\n  virtual int getPoints()const;\n  virtual void onDestroy();\n};\n```", "```cpp\nBigMeteor::BigMeteor(World& world) : Meteor((Configuration::Textures)random(Configuration::Textures::BigMeteor1,Configuration::Textures::BigMeteor4),world)\n{\n  _impulse *= 100.f;\n}\n```", "```cpp\nint BigMeteor::getPoints()const {return 20;h}\nvoid BigMeteor::onDestroy()\n{\n  Meteor::onDestroy();\n  int nb = book::random(2,3);\n  for(int i=0;i<nb;++i)\n  {\n    MediumMeteor* meteor = new MediumMeteor(_world);\n    meteor->setPosition(getPosition());\n    _world.add(meteor);\n  }\n  _world.add(Configuration::Sounds::Explosion1);\n}\n```", "```cpp\nclass Shoot : public Entity\n{\n  public:\n  Shoot(const Shoot&) = delete;\n  Shoot& operator=(const Shoot&) = delete;\n  using Entity::Entity;\n  virtual void update(sf::Time deltaTime);\n  protected:\n  sf::Time _duration;\n};\n```", "```cpp\nvoid Shoot::update(sf::Time deltaTime)\n{\n  float seconds = deltaTime.asSeconds();\n  _sprite.move(seconds * _impulse);\n  _duration -= deltaTime;\n  if(_duration < sf::Time::Zero)\n  _alive = false;\n}\n```", "```cpp\nclass ShootPlayer : public Shoot\n{\n  public :\n  ShootPlayer(const ShootPlayer&) = delete;\n  ShootPlayer& operator=(const ShootPlayer&) = delete;\n  ShootPlayer(Player& from);\n\n  virtual bool isCollide(const Entity& other)const;\n};\n```", "```cpp\nShootPlayer::ShootPlayer(Player& from) : Shoot(Configuration::Textures::ShootPlayer,from._world)\n{\n  _duration = sf::seconds(5);\n  float angle = from._sprite.getRotation() / 180 * M_PI - M_PI / 2;\n  _impulse = sf::Vector2f(std::cos(angle),std::sin(angle)) * 500.f;\n  setPosition(from.getPosition());\n  _sprite.setRotation(from._sprite.getRotation());\n  _world.add(Configuration::Sounds::LaserPlayer);\n}\n```", "```cpp\nShootSaucer::ShootSaucer(SmallSaucer& from) : Shoot(Configuration::Textures::ShootSaucer,from._world)\n{\n  _duration = sf::seconds(5); \n  sf::Vector2f pos = Configuration::player->getPosition() - from.getPosition();\n  float accuracy_lost = book::random(-1.f,1.f)*M_PI/((200+Configuration::getScore())/100.f);\n  float angle_rad = std::atan2(pos.y,pos.x) + accuracy_lost;\n  float angle_deg = angle_rad * 180 / M_PI;\n\n  _impulse = sf::Vector2f(std::cos(angle_rad),std::sin(angle_rad)) * 500.f;\n  setPosition(from.getPosition());\n  _sprite.setRotation(angle_deg + 90);\n  _world.add(Configuration::Sounds::LaserEnemy);\n}\n```", "```cpp\nclass Stats : public sf::Transformable,public sf::Drawable\n{\n  public:\n  Stats();\n  void addLines(int lines);\n  unsigned int getLvl()const;\n  void gameOver();\n\n  private:\n  virtual void draw(sf::RenderTarget& target,sf::RenderStates states=sf::RenderStates::Default) const override;\n\n  unsigned int _nbRows;\n  unsigned int _nbScore;\n  unsigned int _nbLvl;\n  bool _isGameOver;\n\n  sf::Text _textRows;\n  sf::Text _textScore;\n  sf::Text _textLvl;\n  sf::Text _textGameOver;\n  sf::Font _font;\n};\n```", "```cpp\nconstexpr int  FONT_SIZE 24;\nStats::Stats() : _nbRows(0), _nbScore(0), _nbLvl(0), _isGameOver(false)\n{\n  _font.loadFromFile(\"media/fonts/trs-million.ttf\");\n  _textRows.setFont(_font);\n  _textRows.setString(\"rows : 0\");\n  _textRows.setCharacterSize(FONT_SIZE);\n  _textRows.setPosition(0,0);\n\n  _textScore.setFont(_font);\n  _textScore.setString(\"score : 0\");\n  _textScore.setCharacterSize(FONT_SIZE);\n  _textScore.setPosition(0,FONT_SIZE + 1);\n\n  _textLvl.setFont(_font);\n  _textLvl.setString(\"lvl : 0\");\n  _textLvl.setCharacterSize(FONT_SIZE);\n  _textLvl.setPosition(0,(FONT_SIZE + 1)*2);\n\n  _textGameOver.setFont(_font);\n  _textGameOver.setString(\"Game Over\");\n  _textGameOver.setCharacterSize(72);\n  _textGameOver.setPosition(0,0);\n}\n```", "```cpp\nvoid Stats::gameOver(){_isGameOver = true;}\n```", "```cpp\nvoid Stats::addLines(int lines)\n{\n  if(lines > 0)\n  {\n    _nbRows += lines;\n    _textRows.setString(\"rows : \"+std::to_string(_nbRows));\n    _textScore.setString(\"score : \"+std::to_string(_nbScore));\n    switch (lines)\n    {\n      case 1 : _nbScore += 40 * (_nbLvl+1);break;\n      case 2 : _nbScore += 100 * (_nbLvl+1);break;\n      case 3 : _nbScore += 300 * (_nbLvl+1);break;\n      case 4 : _nbScore += 1200 * (_nbLvl+1);break;\n      default :break;\n    }\n    _nbLvl = _nbRows / 10;\n    _textLvl.setString(\"lvl : \"+std::to_string(_nbLvl));\n  }\n}\n```", "```cpp\nunsigned int Stats::getLvl()const{return _nbLvl;}\nvoid Stats::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n  if(not _isGameOver)\n  {\n    states.transform *= getTransform();\n    target.draw(_textRows,states);\n    target.draw(_textScore,states);\n    target.draw(_textLvl,states);\n  }\n  else\n  target.draw(_textGameOver,states);\n}\n```", "```cpp\nclass Piece\n{\n  public:\n  static const unsigned short int NB_ROTATIONS = 4; //< number of rotations\n  static const unsigned short int MATRIX_SIZE = 4; //< size of the matrix\n  static const unsigned int PIVOT_Y = 1;\n  static const unsigned int PIVOT_X = 2;\n  enum TetriminoTypes {O=0,I,S,Z,L,J,T,SIZE}; //< different kind of pieces\n  static const sf::Color TetriminoColors[TetriminoTypes::SIZE]; //< different colors for each kind of piece\n  static const char TetriminoPieces[TetriminoTypes::SIZE][NB_ROTATIONS][MATRIX_SIZE][MATRIX_SIZE];//< store all the different shapes\n\n  Piece(const Piece&) = delete;\n  Piece& operator=(const Piece&) = delete;\n  Piece(TetriminoTypes type,short int rotation); \n  TetriminoTypes getType()const;\n  void setRotation(short int rotation); //< set the rotation\n  short int getRotation()const;\n  void setPosition(int x,int y);//< set the position in the\n  //board\n\n  int getPosX()const;\n  int getPosY()const;\n  sf::Time getTimeSinceLastMove()const;\n\n  private:\n  const TetriminoTypes _type; //< the piece type\n  short int _rotation; //< the piece rotation\n  int _positionX; //< position in the board\n  int _positionY;//< position in the board\n  sf::Clock _clockSinceLastMove;\n};\n```", "```cpp\nconst sf::Color Piece::TetriminoColors[Piece::TetriminoTypes::SIZE]= {\n  sf::Color::Blue,\n  sf::Color::Red,\n  sf::Color::Green,\n  sf::Color::Cyan,\n  sf::Color::Magenta,\n  sf::Color::White,\n  sf::Color(195,132,58)\n}\n```", "```cpp\nconst char Piece::TetriminoPieces[Piece::TetriminoTypes::SIZE][Piece::NB_ROTATIONS][Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {\n    { // O\n        {\n            {0,0,0,0},\n            {0,1,2,0},\n            {0,1,1,0},\n            {0,0,0,0}\n        },\n        //...\n        {\n            {0,0,0,0},\n            {0,1,2,0},\n            {0,1,1,0},\n            {0,0,0,0}\n        }\n    },\n    {//I\n        {\n            {0,0,0,0},\n            {1,1,2,1},\n            {0,0,0,0},\n            {0,0,0,0}\n        },\n        {\n            {0,0,1,0},\n            {0,0,2,0},\n            {0,0,1,0},\n            {0,0,1,0}\n        },\n        {\n            {0,0,0,0},\n            {1,1,2,1},\n            {0,0,0,0},\n            {0,0,0,0}\n        },\n        {\n            {0,0,1,0},\n            {0,0,2,0},\n            {0,0,1,0},\n            {0,0,1,0}\n        } \n    },\n    //...\n};\n```", "```cpp\nPiece::Piece(TetriminoTypes type,short int rotation) : _type(type), _rotation(rotation), _positionX(0), _positionY(0) {assert(rotation >= 0 and rotation < NB_ROTATIONS);}\n```", "```cpp\nPiece::TetriminoTypes Piece::getType()const {return _type;}\n\nshort int Piece::getRotation()const {return _rotation;}\n\nint Piece::getPosX()const {return _positionX;}\n\nint Piece::getPosY()const {return _positionY;}\nsf::Time Piece::getTimeSinceLastMove()const {return _clockSinceLastMove.getElapsedTime();}\n\nvoid Piece::setRotation(short int rotation)\n{\n  assert(rotation >= 0 and rotation < NB_ROTATIONS);\n  _rotation = rotation;\n  _clockSinceLastMove.restart();\n}\n\nvoid Piece::setPosition(int x,int y)\n{\n  _positionX = x;\n  _positionY = y;\n  _clockSinceLastMove.restart();\n}\n```", "```cpp\nclass Board : public sf::Transformable,public sf::Drawable {\n  public:\n  static const int DEFAULT_BOARD_COLUMNS = 10; \n  static const int DEFAULT_BOARD_LINE = 20;\n  static const int DEFAULT_CELL_X = 24;\n  static const int DEFAULT_CELL_Y = 24;\n\n  Board(int columns=DEFAULT_BOARD_COLUMNS,int \n    line=DEFAULT_BOARD_LINE,int cell_x=DEFAULT_CELL_X,int \n      cell_y=DEFAULT_CELL_Y);\n  ~Board();\n\n  void spawn(Piece& piece);\n  bool move(Piece& piece, int delta_x,int delta_y);\n  bool isFallen(const Piece& piece);\n  void drop(Piece& piece);\n  bool rotateLeft(Piece& piece);\n  bool rotateRight(Piece& piece);\n  bool isGameOver();\n  int clearLines(const Piece& piece); //< clear all possible lines\n\n  private:\n  bool rotate(Piece& piece,int rotation);\n  void draw(const Piece& piece);\n  void clear(const Piece& piece);\n  virtual void draw(sf::RenderTarget& target,sf::RenderStates \n    states=sf::RenderStates::Default) const override; \n  void flood(const Piece& piece,int value);\n\n        void flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::Tetrimino_Types type,int rotation,bool visited[][Piece::MATRIX_SIZE],int value);\n        void flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::Tetrimino_Types type,int rotation,bool visited[][Piece::MATRIX_SIZE],bool& flag);\n\n        void clearLine(int y); //< clear a line\n\n        const int _columns;\n        const int _lines;\n        const int _cellX;\n        const int _cellY;\n\n        bool _isGameOver;\n\n        sf::VertexArray _grid;//< grid borders\n        int* _gridContent;//< lines * columns\n};\n```", "```cpp\nconstexpr int  CELL_EMPTY -1;\nBoard::Board(int columns,int lines,int cell_x,int cell_y): _columns(columns),_lines(lines),_cellX(cell_x),_cellY(cell_y), _gridContent(nullptr),_isGameOver(false)\n{\n    _gridContent = new int[_lines*_columns];\n    std::memset(_gridContent,CELL_EMPTY,_lines*_columns*sizeof(int));\n\n    sf::Color gridColor(55,55,55);\n    _grid = sf::VertexArray(sf::Lines,(_lines+1+_columns+1)*2);\n    for(int i=0;i<=_lines;++i)\n    {\n        _grid[i*2] = sf::Vertex(sf::Vector2f(0,i*_cellY));\n        _grid[i*2+1] = sf::Vertex(sf::Vector2f(_columns*_cellX,i*_cellY));\n\n        _grid[i*2].color = gridColor;\n        _grid[i*2+1].color = gridColor;\n    }\n\n    for(int i=0;i<=columns;++i)\n    {\n        _grid[(_lines+1)*2 + i*2] = sf::Vertex(sf::Vector2f(i*_cellX,0));\n        _grid[(_lines+1)*2 + i*2+1] = sf::Vertex(sf::Vector2f(i*_cellX,_lines*_cellY));\n\n        _grid[(_lines+1)*2 + i*2].color = gridColor;\n        _grid[(_lines+1)*2 + i*2+1].color = gridColor;\n    }\n}\n```", "```cpp\nBoard::~Board() {delete _gridContent;}\n\nvoid Board::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n    states.transform *= getTransform();\n\n    for(int y=0; y<_lines; ++y)\n        for(int x=0; x<_columns; ++x) {\n            if(_gridContent[y*_columns + x] != CELL_EMPTY) {\n                sf::RectangleShape rectangle(sf::Vector2f(_cellX,_cellY));\n                rectangle.setFillColor(Piece::TetriminoColors[_gridContent[y*_columns + x]]);\n                rectangle.setPosition(x*_cellX,y*_cellY);\n                target.draw(rectangle,states);\n            }\n        }\n    target.draw(_grid,states);\n}\n```", "```cpp\nvoid Board::spawn(Piece& piece)\n{\n    piece.setPosition(_columns/2,0);\n    for(int x=0;x<_columns;++x)\n        if(_gridContent[x] != CELL_EMPTY) {\n            _isGameOver = true;\n            break;\n        }\n    draw(piece);\n}\n```", "```cpp\nbool Board::move(Piece& piece, int delta_x, int delta_y)\n{\n  delta_x += piece.getPosX();\n  delta_y + piece.getPosY();\n  clear(piece);\n  bool visited[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};\n  bool movable = true\n  flood(delta_x,delta_y, (int)Piece::PIVOT_X,(int)Piece::PIVOT_Y,\n  piece.getType(),piece.getRotation(),\n  visisted, movable);\n  if (movable)\n  piece.setPosition(delta_x,delta_y);\n  draw(piece);\n  return movable;\n}\n```", "```cpp\nbool Board::isFallen(const Piece& piece)\n{\n  clear(piece);\n  bool vision[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};\n  bool fallen = true;\n  flood(piece.getPosX(),piece.getPosY()+1\n  (int)Piece::PIVOT_X,(int)Piece::PIVOT_Y,\n  piece.getType(),piece.getRotation(),\n  visited,fallen);\n  draw(piece)\n  return fallen;\n}\n```", "```cpp\nvoid Board::drop(Piece& piece) {while(move(piece,0,1));}\n```", "```cpp\nbool Board::rotateLeft(Piece& piece)\n{\n  int rotation = piece.getRotation();\n  if(rotation > 0)\n  --rotation;\n  else\n  rotation = Piece::NB_ROTATIONS - 1;\n  return rotate(piece,rotation);\n}\n\nbool Board::rotateRight(Piece& piece)\n{\n  int rotation = piece.getRotation();\n  if(rotation < Piece::NB_ROTATIONS -1)\n  ++rotation;\n  else\n  rotation = 0;\n  return rotate(piece,rotation);\n}\n```", "```cpp\nbool Board::isGameOver(){return _isGameOver;}\nbool Board::rotate(Piece& piece,int rotation)\n{\n  assert(rotation >= 0 and rotation < Piece::NB_ROTATIONS);\n  clear(piece);\n  bool visited[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};\n  bool rotable = true;\n  flood((int)piece.getPosX(),(int)piece.getPosY(),\n  (int)Piece::PIVOT_X,(int)Piece::PIVOT_Y,\n  piece.getType(),rotation,\n  visited,rotable);\n  if(rotable)\n  piece.setRotation(rotation);\n  draw(piece);\n  return rotable;\n}\n```", "```cpp\nvoid Board::draw(const Piece& piece){flood(piece,piece.getType());}\nvoid Board::clear(const Piece& piece){flood(piece,CELL_EMPTY);}\n```", "```cpp\nvoid Board::flood(const Piece& piece,int value)\n{\n  bool visited[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};\n  flood((int)piece.getPosX(),\n  (int)piece.getPosY(),(int)Piece::PIVOT_X,\n  (int)Piece::PIVOT_Y,\n  piece.getType(),piece.getRotation(),\n  visited,value);\n}\n\nvoid Board::flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::TetriminoTypes type,int rotation,bool visited[][Piece::MATRIX_SIZE],int value)\n{\n  if(piece_x < 0 or piece_x >= Piece::MATRIX_SIZE\n  or piece_y < 0 or piece_y > Piece::MATRRIX_SIZE Pieces[type][rotation][piece_y][piece_x] == 0)\n  return;\nvisited[piece_y][piece_x] = true;\n  _gridContent[grid_y*_columns + grid_x] = value;\n  flood(grid_x, grid_y-1, piece_x, piece_y-1, type, rotation, visited, value);\n  flood(grid_x+1, grid_y, piece_x+1, piece_y, type, rotation, visited, value);\n  flood(grid_x, grid_y+1, piece_x, piece_y+1, type, rotation, visited, value);\n  flood(grid_x-1, grid_y, piece_x-1, piece_y, type, rotation, visited, value);\n}\n\nvoid Board::flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::TetriminoTypes type,int rotation,bool visited[][Piece::MATRIX_SIZE],bool& flag)\n{\n  if(piece_x < 0 or piece_x >= Piece::MATRIX_SIZE\n  or piece_y < 0 or piece_y >= Piece::MATRIX_SIZE\n  or visited[piece_y][piece_x] == true\n  or Piece::TetriminoPieces[type][rotation][piece_y][piece_x] == 0)\n  return;\n  visited[piece_y][piece_x] = true;\n  if(grid_x < 0 or grid_x >= (int)_columns\n  or grid_y < 0 or grid_y >= (int)_lines\n  or _gridContent[grid_y*_columns + grid_x] != CELL_EMPTY) {\n    flag = false;\n    return;\n  }\n  flood(grid_x, grid_y-1, piece_x, piece_y-1, type, rotation, visited, flag);\n  flood(grid_x+1, grid_y, piece_x+1, piece_y, type, rotation, visited, flag);\n  flood(grid_x, grid_y+1, piece_x, piece_y+1, type, rotation, visited, flag);\n  flood(grid_x-1, grid_y, piece_x-1, piece_y, type, rotation, visited, flag);\n}\n```", "```cpp\nvoid Board::clearLine(int yy)\n{\n  assert(yy < _lines);\n  for(int y=yy; y>0; --y)\n  for(int x=0; x<_columns; ++x)\n  _gridContent[y*_columns + x] = _gridContent[(y-1)*_columns + x];\n}\nint Board::clearLines(const Piece& piece)\n{\n  int nb_delete = 0;\n  clear(piece);\n  for(int y=0; y<_lines; ++y)\n  {\n    int x =0;\n    for(;_gridContent[y*_columns + x] != CELL_EMPTY and x<_columns; ++x);\n    if(x == _columns) {\n      clearLine(y);\n      ++nb_delete;\n    }\n  }\n  draw(piece);\n  return nb_delete;\n}\n```", "```cpp\nclass Game\n{\n  public:\n  Game(); //< constructor\n  void run(int minimum_frame_per_seconds);\n\n  private:\n  void processEvents();//< Process events\n  void update(sf::Time deltaTime); //< do some updates\n  void render();//< draw all the stuff\n  void newPiece();\n\n  sf::RenderWindow _window; //< the window used to display the game\n  std::unique_ptr<Piece> _currentPiece; //< the current piece\n  Board _board; //< the game board\n  Stats _stats; //< stats printer\n  sf::Time _nextFall;\n};\n```", "```cpp\nGame::Game() : _window(sf::VideoMode(800, 600),\"SFML Tetris\"),_board()\n{\n  rand_init()\n  _board.setPosition(10,10);\n  _stats.setPosition(300,10);\n  newPiece();\n}\n```", "```cpp\nvoid Game::run(int minimum_frame_per_seconds)\n{\n  sf::Clock clock;\n  sf::Time timeSinceLastUpdate;\n  sf::Time TimePerFrame = sf::seconds(1.f/minimum_frame_per_seconds);\n  while (_window.isOpen())\n  {\n    processEvents();\n    timeSinceLastUpdate = clock.restart();\n    while (timeSinceLastUpdate > TimePerFrame)\n    {\n      timeSinceLastUpdate -= TimePerFrame;\n      update(TimePerFrame);\n    }\n    update(timeSinceLastUpdate);\n    render();\n  }\n}\nvoid Game::processEvents()\n{\n  sf::Event event;\n  while(_window.pollEvent(event))\n  {\n    if (event.type == sf::Event::Closed)//Close window\n    _window.close();\n    else if (event.type == sf::Event::KeyPressed) //keyboard input\n    {\n      if (event.key.code == sf::Keyboard::Escape) {\n        _window.close();\n      } else if (event.key.code == sf::Keyboard::Down) {\n        _board.move(*_currentPiece,0,1);\n      } else if (event.key.code == sf::Keyboard::Up) {\n        _board.move(*_currentPiece,0,-1);\n      } else if (event.key.code == sf::Keyboard::Left) {\n        _board.move(*_currentPiece,-1,0);\n      } else if (event.key.code == sf::Keyboard::Right) {\n        _board.move(*_currentPiece,1,0);\n      } else if (event.key.code == sf::Keyboard::Space) {\n        _board.drop(*_currentPiece);\n        newPiece();\n      } else if (event.key.code == sf::Keyboard::S) {\n        _board.rotateRight(*_currentPiece);\n      } else if (event.key.code == sf::Keyboard::D) {\n        _board.rotateLeft(*_currentPiece);\n      }\n    }\n  }\n}\nvoid Game::update(sf::Time deltaTime)\n{\n  if(not _board.isGameOver())\n  {\n  _stats.addLines(_board.clearLines(*_currentPiece));\n  _nextFall += deltaTime;\n  if((not _board.isFallen(*_currentPiece)) and (_currentPiece->getTimeSinceLastMove() > sf::seconds(1.f)))\n  newPiece();\n  sf::Time max_time = sf::seconds(std::max(0.1,0.6-0.005*_stats.getLvl()));\n  while(_nextFall > max_time)\n  {\n    _nextFall -= max_time;\n    _board.move(*_currentPiece,0,1);\n  }\n    } else {\n      _stats.gameOver();\n    }\n}\n```", "```cpp\n    void Game::render()\n    {\n      _window.clear();\n      if(not _board.isGameOver())\n      _window.draw(_board);\n      _window.draw(_stats);\n      _window.display();\n    }\n    ```", "```cpp\n    void Game::newPiece()\n    {\n      _currentPiece.reset(new Piece((Piece::TetriminoTypes)random(0,Piece::TetriminoTypes::SIZE-1),0));\n      _board.spawn(*_currentPiece);\n    }\n    ```"]