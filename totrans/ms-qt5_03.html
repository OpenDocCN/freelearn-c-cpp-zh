<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0; Dividing Your Project and Ruling Your Code"><div class="titlepage" id="aid-10DJ42"><div><div><h1 class="title"><a id="ch03"/>Chapter 3.  Dividing Your Project and Ruling Your Code </h1></div></div></div><p>The last chapter delved into qmake to study what lies beneath the signal/slot system and covered a reasonable approach to implementing platform-specific code. This chapter wants to show you how a project can be properly divided to enjoy the maximum leverage from the Qt framework.</p><p>To do this, you will create a gallery application that handles albums and pictures. You will be able to create, read, update and delete any album and display the pictures in a grid of thumbnails or in full resolution. Everything will be persisted in a SQL database.</p><p>This chapter lays the foundations of the gallery by creating a core library that will be used in the following two chapters: <span><a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a></span>, <span class="emphasis"><em>Conquering the Desktop UI</em></span>, and <span><a class="link" title="Chapter 5.  Dominating the Mobile UI" href="part0048.xhtml#aid-1DOR02">Chapter 5</a></span>, <span class="emphasis"><em>Dominating the Mobile UI</em></span>.</p><p>This chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Application/library project separation</li><li class="listitem">Database interaction with Qt</li><li class="listitem">Smart pointers with C++14</li><li class="listitem">Model/View architecture in Qt with an implementation of the model</li></ul></div><div class="section" title="Designing a maintainable project"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Designing a maintainable project</h1></div></div></div><p>The first step in designing a maintainable project is to properly split it in clearly defined modules. A common approach is to separate the engine from the user interface. This separation forces you to reduce coupling between the different parts of your code and make it more modular.</p><p>This is exactly the approach we will take with the <code class="literal">gallery</code> application. The project will be divided into three sub-projects:</p><div class="mediaobject"><img src="../Images/image00366.jpeg" alt="Designing a maintainable project"/></div><p style="clear:both; height: 1em;"> </p><p>The sub-projects are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>gallery-core</strong></span>: This is a library containing the core of the application logic: the data classes (or business classes), persistent storage (in SQL), and the model that makes the storage available to the UI through a single entry point.</li><li class="listitem"><span class="strong"><strong>gallery-desktop</strong></span>: This is a Qt widgets application that will depend on the <code class="literal">gallery-core</code> library to retrieve data and display it to the user. This project will be covered in <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2"><span>Chapter 4</span></a>, <span class="emphasis"><em>Conquering the Desktop UI</em></span>.</li><li class="listitem"><span class="strong"><strong>gallery-mobile</strong></span>: This is a QML application targeted at mobile platforms (Android and iOS). It will also rely on <code class="literal">gallery-core</code>. This project will be covered in <span><a class="link" title="Chapter 5.  Dominating the Mobile UI" href="part0048.xhtml#aid-1DOR02">Chapter 5</a></span>, <span class="emphasis"><em>Dominating the Mobile UI</em></span>.</li></ul></div><p>As you can see, each layer has a single responsibility. This principle is applied to both the project structure and the code organization. Throughout these three projects, we will endeavor to live up to the motto of the chapter: "Divide your project and rule your code".</p><p>To separate your Qt project this way, we will create a different kind of project, a <span class="strong"><strong>Subdirs</strong></span> project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New </strong></span><span class="strong"><strong>File </strong></span><span class="strong"><strong>or </strong></span><span class="strong"><strong>Project</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Projects</strong></span> types, select <span class="strong"><strong>Other Project</strong></span> | <span class="strong"><strong>Subdirs Project</strong></span> | <span class="strong"><strong>Choose</strong></span>.</li><li class="listitem">Name it <code class="literal">ch03-gallery-core</code> and then click on <span class="strong"><strong>Choose</strong></span>.</li><li class="listitem">Select your latest Qt Desktop Kit, and then click on <span class="strong"><strong>Next</strong></span> | <span class="strong"><strong>Finish &amp; Add Subproject</strong></span>.</li></ol><div style="height:10px; width: 1px"/></div><p>Here, Qt Creator created the parent project, <code class="literal">ch03-gallery-core</code>, which will host our three sub-projects (<code class="literal">gallery-core</code>, <code class="literal">gallery-desktop</code>, and <code class="literal">gallery-mobile</code>). The parent project has neither code nor a compilation unit in itself, it is simply a convenient way to group multiple <code class="literal">.pro</code> projects and express the dependencies between them.</p><p>The next step is to create the first <code class="literal">subdir</code> project, which Qt Creator proposed immediately when you clicked on <span class="strong"><strong>Finish &amp; Add Subproject</strong></span>. We will start with <code class="literal">gallery-core</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>Library</strong></span> in the <span class="strong"><strong>Projects</strong></span> tab.</li><li class="listitem">Select <span class="strong"><strong>C++ Library</strong></span>.</li><li class="listitem">Choose the <span class="strong"><strong>Shared Library</strong></span> type, and name it <code class="literal">gallery-core</code>, and click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Select the modules, <span class="strong"><strong>QtCore</strong></span>, and <span class="strong"><strong>QtSql</strong></span>, and then click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Type <span class="strong"><strong>Album</strong></span> in the <span class="strong"><strong>Class name</strong></span> field, and click on <span class="strong"><strong>Next</strong></span>. Qt Creator will generate the basic skeleton of a library with this class as an example.</li><li class="listitem">Check that the project is properly added as a sub-project of <code class="literal">ch03-gallery-core.pro</code> and click on <span class="strong"><strong>Finish</strong></span>.</li></ol><div style="height:10px; width: 1px"/></div><p>Before delving into <code class="literal">gallery-core</code> code, let's study what Qt Creator just made for us. Open the parent <code class="literal">.pro</code> file, <code class="literal">ch03-gallery-core.pro</code>:</p><pre class="programlisting">TEMPLATE = subdirs 
 
SUBDIRS += \ 
    gallery-core 
</pre><p>Until now, we used the <code class="literal">TEMPLATE = app</code> syntax in our <code class="literal">.pro</code> files. The <code class="literal">subdirs</code> project template indicates to Qt that it should search for sub-projects to compile. When we added the <code class="literal">gallery-core</code> project to <code class="literal">ch03-gallery-core.pro</code>, Qt Creator added it to the <code class="literal">SUBDIRS</code> variable. As you can see, <code class="literal">SUBDIRS</code> is a list, so you can add as many sub-projects as you want.</p><p>When compiling <code class="literal">ch03-gallery-core.pro</code>, Qt will scan each <code class="literal">SUBDIRS</code> value to compile them. We can now switch to <code class="literal">gallery-core.pro</code>:</p><pre class="programlisting">QT       += sql 
QT       -= gui 
 
TARGET = gallery-core 
TEMPLATE = lib 
 
DEFINES += GALLERYCORE_LIBRARY 
SOURCES += Album.cpp 
HEADERS += Album.h\ 
        gallery-core_global.h 
 
unix { 
    target.path = /usr/lib 
    INSTALLS += target 
} 
</pre><p>Let's see how this works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">QT</code> has appended the <code class="literal">sql</code> module and removed the <code class="literal">gui</code> module. By default, <span class="strong"><strong>QtGui</strong></span> is always included and has to be removed explicitly.</li><li class="listitem">The <code class="literal">TEMPLATE</code> value is different, again. We use <code class="literal">lib</code> to tell qmake to generate a Makefile that will output a shared library named <code class="literal">gallery-core</code> (as specified by the <code class="literal">TARGET</code> variable).</li><li class="listitem">The <code class="literal">DEFINES += GALLERY_CORE_LIBRARY</code> syntax is a compilation flag that lets the compiler know when it should import or export library symbols. We will come back soon to this notion.</li><li class="listitem">The <code class="literal">HEADERS</code> contains our first class <code class="literal">Album.h</code>, but also another generated header: <code class="literal">gallery-core_global.h</code>. This file is syntactic sugar provided by Qt to ease the pain of a cross-platform library.</li><li class="listitem">The <code class="literal">unix { ... }</code> scope specifies the installation destination of the library. This platform scope is generated because we created the project on Linux. By default it will try to install the library in the system library path (<code class="literal">/usr/lib</code>).</li></ul></div><p>Please remove the <code class="literal">unix</code> scope altogether, we don't need to make the library available system-wide.</p><p>To have a better understanding of the cross-platform shared object issue, you can open <code class="literal">gallery-core_global.h</code>:</p><pre class="programlisting">#include &lt;QtCore/qglobal.h&gt; 
 
#if defined(GALLERYCORE_LIBRARY) 
#  define GALLERYCORESHARED_EXPORT Q_DECL_EXPORT 
#else 
#  define GALLERYCORESHARED_EXPORT Q_DECL_IMPORT 
#endif 
</pre><p>We encounter again the <code class="literal">GALLERYCORE_LIBRARY</code> defined in <code class="literal">gallery-core.pro</code> file. Qt Creator generated a useful piece of code for us: the cross-platform way to handle symbol visibility in a shared library.</p><p>When your application links to a shared library, symbol functions, variables, or classes must be marked in a special way to be visible by the application using the shared library. The default visibility of a symbol depends on the platform. Some platforms will hide symbols by default, other platforms will make them public. Of course, each platform and compiler has its own macros to express this public/private notion.</p><p>To obviate the whole <code class="literal">#ifdef windows #else</code> boilerplate code, Qt provides a <code class="literal">Q_DECL_EXPORT</code> (if we are compiling the library) and <code class="literal">Q_DECL_IMPORT</code> (if we are compiling your application using the shared library). Thus, throughout the symbols you want to mark as public, you just have to use the <code class="literal">GALLERYCORESHARED_EXPORT</code> macro.</p><p>An example is available in the <code class="literal">Album.h</code> file:</p><pre class="programlisting">#ifndef ALBUM_H 
#define ALBUM_H 
 
#include "gallery-core_global.h" 
 
class GALLERYCORESHARED_EXPORT Album 
{ 
 
public: 
    Album(); 
}; 
 
#endif // ALBUM_H 
</pre><p>You include the proper <code class="literal">gallery-core_global.h</code> file to have access to the macro and you use it just after the <code class="literal">class</code> keyword. It does not pollute your code too much and is still cross-platform.</p><div class="note" title="Note"><h3 class="title"><a id="note20"/>Note</h3><p>Another possibility is to make a <span class="strong"><strong>Statically Linked Library</strong></span>. This path is interesting if you want fewer dependencies to handle (a single binary is always easier to deploy). There are several downsides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Increased compilation time: each time you modify the library, the application will have to be recompiled as well.</li><li class="listitem">Tighter coupling, multiple applications cannot link to your library. Each one of them must embed it.</li></ul></div></div></div></div>
<div class="section" title="Defining data classes" id="aid-11C3M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Defining data classes</h1></div></div></div><p>We are building our gallery from the ground up. We will start with the implementation of our data classes to be able to properly write the database layer. The application aims to organize pictures into albums. Hence, the two obvious classes are <code class="literal">Album</code> and <code class="literal">Picture</code>. In our example, an album simply has a name. A <code class="literal">Picture</code> class must belong to an <code class="literal">Album</code> class and has a file path (the path on your filesystem where the original file is located).</p><p>The <code class="literal">Album</code> class has already been created on project creation. Open the <code class="literal">Album.h</code> file and update it to include the following implementation:</p><pre class="programlisting">#include &lt;QString&gt; 
 
#include "gallery-core_global.h" 
 
class GALLERYCORESHARED_EXPORT Album 
{ 
public: 
    explicit Album(const QString&amp; name = ""); 
 
    int id() const; 
    void setId(int id); 
    QString name() const; 
    void setName(const QString&amp; name); 
 
private: 
    int mId; 
    QString mName; 
}; 
</pre><p>As you can see, the <code class="literal">Album</code> class contains only a <code class="literal">mId</code> variable (the database ID) and a <code class="literal">mName</code> variable. In a typical <span class="strong"><strong>OOP</strong></span> (<span class="strong"><strong>Object Oriented Paradigm</strong></span>) fashion, the <code class="literal">Album</code> class would have had a <code class="literal">QVector&lt;Picture&gt;mPictures</code> field. We did not do it on purpose. By decoupling these two objects, we will have more flexibility when we want to load an album without pulling the potential thousands of associated pictures. The other problem in having <code class="literal">mPictures</code> in the <code class="literal">Album</code> class is that the developer (you or anybody else) using this code will ask himself: when is <code class="literal">mPictures</code> loaded? Should I do a partial load of the <code class="literal">Album</code> and have an incomplete <code class="literal">Album</code> or should I always load <code class="literal">Album</code> with every picture in it?</p><p>By completely removing the field, the question ceases to exist, and the code is simpler to grasp. The developer knows intuitively that he will have to explicitly load the pictures if he want them; otherwise, he can continue with this simple <code class="literal">Album</code> class.</p><p>The getters and setters are obvious enough; we will let you implement them without showing them to you. We will only take a look at the <code class="literal">Album</code> class' constructor in <code class="literal">Album.cpp</code>:</p><pre class="programlisting">Album::Album(const QString&amp; name) : 
    mId(-1), 
    mName(name) 
{ 
} 
</pre><p>The <code class="literal">mId</code> variable is initialized to <code class="literal">-1</code> to be sure that, by default, an invalid id is used, and the <code class="literal">mName</code> variable is assigned a <code class="literal">name</code> value.</p><p>We can now proceed to the <code class="literal">Picture</code> class. Create a new C++ class named <code class="literal">Picture</code> and open <code class="literal">Picture.h</code> to modify it like so:</p><pre class="programlisting">#include &lt;QUrl&gt; 
#include &lt;QString&gt; 
 
#include "gallery-core_global.h" 
 
class GALLERYCORESHARED_EXPORT Picture 
{ 
public: 
    Picture(const QString&amp; filePath = ""); 
    Picture(const QUrl&amp; fileUrl); 
 
    int id() const; 
    void setId(int id); 
 
    int albumId() const; 
    void setAlbumId(int albumId); 
 
    QUrl fileUrl() const; 
    void setFileUrl(const QUrl&amp; fileUrl); 
private: 
    int mId; 
    int mAlbumId; 
    QUrl mFileUrl; 
}; 
</pre><p>Do not forget to add the <code class="literal">GALLERYCORESHARED_EXPORT</code> macro right before the <code class="literal">class</code> keyword to export the class from the library. As a data structure, <code class="literal">Picture</code> has a <code class="literal">mId</code> variable, belongs to a <code class="literal">mAlbumId</code> variable, and has a <code class="literal">mUrl</code> value. We use the <code class="literal">QUrl</code> type to make path manipulation easier to use depending on the platform (desktop or mobile).</p><p>Let's take a look at <code class="literal">Picture.cpp</code>:</p><pre class="programlisting">#include "Picture.h" 
Picture::Picture(const QString&amp; filePath) : 
    Picture(QUrl::fromLocalFile(filePath)) 
{ 
} 
 
Picture::Picture(const QUrl&amp; fileUrl) : 
    mId(-1), 
    mAlbumId(-1), 
    mFileUrl(fileUrl) 
{ 
} 
 
QUrl Picture::fileUrl() const 
{ 
    return mFileUrl; 
} 
 
void Picture::setFileUrl(const QUrl&amp; fileUrl) 
{ 
    mFileUrl = fileUrl; 
} 
</pre><p>In the first constructor, the static function, <code class="literal">QUrl::fromLocalFile</code>, is called to provide a <code class="literal">QUrl</code> object to the other constructor, which takes a <code class="literal">QUrl</code> parameter.</p><p>The ability to call other constructors is a nice addition in C++11.</p></div>
<div class="section" title="Storing your data in a database"><div class="titlepage" id="aid-12AK82"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Storing your data in a database</h1></div></div></div><p>Now that the data classes are ready, we can proceed to implement the database layer. Qt provides a ready-to-use <code class="literal">sql</code> module. Various databases are supported in Qt using SQL database drivers. In <code class="literal">gallery-desktop</code>, we will use the <code class="literal">SQLITE3</code> driver, which is included in the <code class="literal">sql</code> module and perfectly fits the use case:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>A very simple database schema</strong></span>: No need for complex queries</li><li class="listitem"><span class="strong"><strong>Very few or no concurrent transactions</strong></span>: No need for a complex transaction model</li><li class="listitem"><span class="strong"><strong>A single-purpose database</strong></span>: No need to spawn a system service, the database is stored in a single file and does not need to be accessed by multiple applications</li></ul></div><p>The database will be accessed from multiple locations; we need to have a single entry point for it. Create a new C++ class named <code class="literal">DatabaseManager</code> and modify <code class="literal">DatabaseManager.h</code> to look like this:</p><pre class="programlisting">#include &lt;QString&gt; 
 
class QSqlDatabase; 
 
const QString DATABASE_FILENAME = "gallery.db"; 
 
class DatabaseManager 
{ 
public: 
    static DatabaseManager&amp; instance(); 
    ~DatabaseManager(); 
 
protected: 
    DatabaseManager(const QString&amp; path = DATABASE_FILENAME); 
    DatabaseManager&amp; operator=(const DatabaseManager&amp; rhs); 
 
private: 
    QSqlDatabase* mDatabase; 
}; 
</pre><p>The first thing to notice is that we implement the singleton pattern in the <code class="literal">DatabaseManager</code> class, like we did in the <span class="emphasis"><em>Transforming SysInfo in a singleton</em></span> section from <span><a class="link" title="Chapter 2.  Discovering QMake Secrets" href="part0025.xhtml#aid-NQU22">Chapter 2</a></span>, <span class="emphasis"><em>Discovering QMake Secrets</em></span>. The <code class="literal">DatabaseManager</code> class will open the connection in the <code class="literal">mDatabase</code> field and lend it to other possible classes.</p><p>Also, <code class="literal">QSqlDatabase</code> is forward-declared and used as a pointer for the <code class="literal">mDatabase</code> field. We could have included the <code class="literal">QSqlDatabase</code> header, but we would have had a non-desired side-effect: every file, which includes <code class="literal">DatabaseManager</code>, must also include <code class="literal">QSqlDatabase</code>. Thus, if we ever have some transitive inclusion in our application (which links to the <code class="literal">gallery-core</code> library), the application is forced to enable the <code class="literal">sql</code> module. As a consequence, the storage layer leaks through the library. The application should not have any knowledge about the storage layer implementation. For all the application cares, it could be in SQL, XML, or anything else; the library is a black box that should honor the contract and persist the data.</p><p>Let's switch to <code class="literal">DatabaseManager.cpp</code> and open the database connection:</p><pre class="programlisting">#include "DatabaseManager.h" 
 
#include &lt;QSqlDatabase&gt; 
 
DatabaseManager&amp; DatabaseManager::instance() 
{ 
    static DatabaseManager singleton; 
    return singleton; 
} 
 
DatabaseManager::DatabaseManager(const QString&amp; path) : 
    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase("QSQLITE"))) 
{ 
    mDatabase-&gt;setDatabaseName(path); 
    mDatabase-&gt;open(); 
} 
 
DatabaseManager::~DatabaseManager() 
{ 
    mDatabase-&gt;close(); 
    delete mDatabase; 
} 
</pre><p>The correct database driver is selected on the <code class="literal">mDatabase</code> field initialization with the <code class="literal">QSqlDatabase::addDatabase("QSQLITE")</code> function call. The following steps are just a matter of configuring the database name (which is incidentally the file path in SQLITE3) and opening the connection with the <code class="literal">mDatabase-&gt;open()</code> function. In the <code class="literal">DatabaseManager</code> destructor, the connection is closed and the <code class="literal">mDatabase</code> pointer is properly deleted.</p><p>The database link is now opened; all we have to do is to execute our <code class="literal">Album</code> and <code class="literal">Picture</code> queries. Implementing the <span class="strong"><strong>CRUD</strong></span> (<span class="strong"><strong>Create</strong></span>/<span class="strong"><strong>Read</strong></span>/<span class="strong"><strong>Update</strong></span>/<span class="strong"><strong>Delete</strong></span>) for both our data classes in <code class="literal">DatabaseManager</code> would quickly push <code class="literal">DatabaseManager.cpp</code> to be several hundreds of lines long. Add a few more tables and you can already see what a monster <code class="literal">DatabaseManager</code> would turn into.</p><p>For this reason, each of our data classes will have a dedicated database class, responsible for all the database CRUD operations. We will start with the <code class="literal">Album</code> class; create a new C++ class named <code class="literal">AlbumDao</code> (data access object) and update <code class="literal">AlbumDao.h</code>:</p><pre class="programlisting">class QSqlDatabase; 
 
class AlbumDao 
{ 
public: 
    AlbumDao(QSqlDatabase&amp; database); 
    void init() const; 
 
private: 
    QSqlDatabase&amp; mDatabase; 
}; 
</pre><p>The <code class="literal">AlbumDao</code> class's constructor takes a <code class="literal">QSqlDatabase&amp;</code> parameter. This parameter is the database connection that will be used for all the SQL queries done by the <code class="literal">AlbumDao</code> class. The <code class="literal">init()</code> function aims to create the <code class="literal">albums</code> table and should be called when <code class="literal">mDatabase</code> is opened.</p><p>Let's see the implementation of <code class="literal">AlbumDao.cpp</code>:</p><pre class="programlisting">#include &lt;QSqlDatabase&gt; 
#include &lt;QSqlQuery&gt; 
 
#include "DatabaseManager.h" 
 
AlbumDao::AlbumDao(QSqlDatabase&amp; database) : 
    mDatabase(database) 
{ 
} 
 
void AlbumDao::init() const 
{ 
    if (!mDatabase.tables().contains("albums")) { 
        QSqlQuery query(mDatabase); 
        query.exec("CREATE TABLE albums (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)"); 
    } 
} 
</pre><p>As usual, the <code class="literal">mDatabase</code> field is initialized with the database parameter. In the <code class="literal">init()</code> function, we can see a real SQL request in action. If the table <code class="literal">albums</code> class does not exist, a <code class="literal">QSqlQuery</code> query is created that will use the <code class="literal">mDatabase</code> connection to be executed. If you omit <code class="literal">mDatabase</code>, the query will use a default anonymous connection. The <code class="literal">query.exec()</code> function is the simplest manner of executing a query: you simply pass the <code class="literal">QString</code> type of your query and it's done. Here we create the <code class="literal">albums</code> table with the fields matching the data class <code class="literal">Album</code> (<code class="literal">id</code> and <code class="literal">name</code>).</p><div class="note" title="Note"><h3 class="title"><a id="tip21"/>Tip</h3><p>The <code class="literal">QSqlQuery::exec()</code> function returns a <code class="literal">bool</code> value that indicates if the request has been successful. In your production code, always check this value. You can further investigate the error with <code class="literal">QSqlQuery::lastError()</code>. An example is available in the source code of the chapter in <code class="literal">DatabaseManager::debugQuery()</code>.</p></div><p>The skeleton of <code class="literal">AlbumDao</code> class is done. The next step is to link it to the <code class="literal">DatabaseManager</code> class. Update the <code class="literal">DatabaseManager</code> class like so:</p><pre class="programlisting">// In DatabaseManager.h 
#include "AlbumDao.h" 
 
... 
 
private: 
    QSqlDatabase* mDatabase; 
 
public: 
    const AlbumDao albumDao; 
}; 
 
// In DatabaseManager.cpp 
DatabaseManager::DatabaseManager(const QString&amp; path) : 
    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase("QSQLITE"))), 
    albumDao(*mDatabase) 
{ 
    mDatabase-&gt;setDatabaseName(path); 
    mDatabase-&gt;open(); 
 
    albumDao.init(); 
} 
</pre><p>The <code class="literal">albumDao</code> field is declared as a <code class="literal">public const AlbumDao</code> in the <code class="literal">DatabaseManager.h</code> file. This needs some explanation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">public</code> visibility is to give access to <code class="literal">DatabaseManager</code> clients to the <code class="literal">albumDao</code> field. The API becomes intuitive enough; if you want to make a database operation on an <code class="literal">album</code>, just call <code class="literal">DatabaseManager::instance().albumDao</code>.</li><li class="listitem">The <code class="literal">const</code> keyword is to make sure that nobody can modify <code class="literal">albumDao</code>. Because it is <code class="literal">public</code>, we cannot guarantee the safety of the object (anybody could modify the object). As a side-effect, we force every public function of <code class="literal">AlbumDao</code> to be <code class="literal">const</code>. This makes sense; after all, the <code class="literal">AlbumDao</code> field could have been a namespace with a bunch of functions. It is more convenient for it to be a class because we can keep the reference to the database connection with the <code class="literal">mDatabase</code> field.</li></ul></div><p>In the <code class="literal">DatabaseManager</code> constructor, the <code class="literal">albumDao</code> class is initialized with the <code class="literal">mDatabase</code> dereferenced pointer. The <code class="literal">albumDao.init()</code> function is called after the database connection has opened.</p><p>We can now proceed to implement more interesting SQL queries. We can start with the creation of a new album in the <code class="literal">AlbumDao</code> class:</p><pre class="programlisting">// In AlbumDao.h 
class QSqlDatabase; 
class Album; 
 
class AlbumDao 
{ 
public: 
    AlbumDao(QSqlDatabase&amp; database); 
    void init() const; 
     
    void addAlbum(Album&amp; album) const; 
    ... 
}; 
 
// In AlbumDao.cpp 
 
#include &lt;QSqlDatabase&gt; 
#include &lt;QSqlQuery&gt; 
#include &lt;QVariant&gt; 
 
... 
 
void AlbumDao::addAlbum(Album&amp; album) const 
{ 
    QSqlQuery query(mDatabase); 
    query.prepare("INSERT INTO albums (name) VALUES (:name)"); 
    query.bindValue(":name", album.name()); 
    query.exec(); 
    album.setId(query.lastInsertId().toInt()); 
} 
</pre><p>The <code class="literal">addAlbum()</code> function takes an <code class="literal">album</code> parameter to extract its information and execute the corresponding query. Here, we approach the prepared query notion: the <code class="literal">query.prepare()</code> function takes a <code class="literal">query</code> parameter which contains placeholders for parameters provided later. We will provide the <code class="literal">name</code> parameter with the syntax <code class="literal">:name</code>. Two syntaxes are supported: Oracle style with a colon-name (for example, <code class="literal">:name</code>) or ODBC style with a question mark (for example, <code class="literal">?name</code>).</p><p>We then bind the bind <code class="literal">:name</code> syntax to the value of the <code class="literal">album.name()</code> function. Because <code class="literal">QSqlQuery::bind()</code> expects a <code class="literal">QVariant</code> as a parameter value, we have to add the <code class="literal">include</code> directive to this class.</p><p>In a nutshell, a <code class="literal">QVariant</code> is a generic data holder that accepts a wide range of primitive types (<code class="literal">char</code>, <code class="literal">int</code>, <code class="literal">double</code>, and so on) and complex types (<code class="literal">QString</code>, <code class="literal">QByteArray</code>, <code class="literal">QUrl</code>, and so on).</p><p>When the <code class="literal">query.exec()</code> function is executed, the bound values are properly replaced. The <code class="literal">prepare()</code> statement technique makes the code more robust to SQL injection (injecting a hidden request would fail) and more readable.</p><p>The execution of the query modifies the state of the object query itself. The <code class="literal">QSqlQuery</code> query is not simply a SQL query executor, it also contains the state of the active query. We can retrieve information about the query with the <code class="literal">query.lastInsertId()</code> function, which returns a <code class="literal">QVariant</code> value containing the ID of the album row we just inserted. This <code class="literal">id</code> is given to the <code class="literal">album</code> provided in the <code class="literal">addAlbum()</code> parameter. Because we modify <code class="literal">album</code>, we cannot mark the parameter as <code class="literal">const</code>. Being strict about the <code class="literal">const</code> correctness of your code is a good hint for a fellow developer, who can deduce that your function might (or not) modify the passed parameter.</p><p>The remaining update and delete operations follow strictly the same pattern used for <code class="literal">addAlbum()</code>. We will just provide the expected function signatures in the next code snippet. Please refer to the source code of the chapter for the complete implementation. However, we need to implement the request to retrieve all the albums in the database. This one deserves a closer look:</p><pre class="programlisting">// In AlbumDao.h 
#include &lt;QVector&gt; 
 
    ... 
    void addAlbum(Album&amp; album) const; 
    void updateAlbum(const Album&amp; album) const; 
    void removeAlbum(int id) const; 
    QVector&lt;Album*&gt; albums() const; 
    ... 
}; 
 
// In AlbumDao.cpp 
QVector&lt;Album*&gt; AlbumDao::albums() const 
{ 
    QSqlQuery query("SELECT * FROM albums", mDatabase); 
    query.exec(); 
    QVector&lt;Album*&gt; list; 
    while(query.next()) { 
        Album* album = new Album(); 
        album-&gt;setId(query.value("id").toInt()); 
        album-&gt;setName(query.value("name").toString()); 
        list.append(album); 
    } 
    return list; 
} 
</pre><p>The <code class="literal">albums()</code> function must return a <code class="literal">QVector&lt;Album*&gt;</code> value. If we take a look at the body of the function, we see yet another property of <code class="literal">QSqlQuery</code>. To walk through multiple rows for a given request, <code class="literal">query</code> handles an internal cursor pointing to the current row. We can then proceed to create a <code class="literal">new Album*()</code> function and fill it with the row data with the <code class="literal">query.value()</code> statement, which takes a column name parameter and returns a <code class="literal">QVariant</code> value that is casted to the proper type. This new <code class="literal">album</code> parameter is appended to the <code class="literal">list</code> and, finally, this <code class="literal">list</code> is returned to the caller.</p><p>The <code class="literal">PictureDao</code> class is very similar to the <code class="literal">AlbumDao</code> class, both in usage and implementation. The main difference is that a picture has a foreign key to an album. The <code class="literal">PictureDao</code> function must be conditioned by an <code class="literal">albumId</code> parameter. The following code snippet shows the <code class="literal">PictureDao</code> header and the <code class="literal">init()</code> function:</p><pre class="programlisting">// In PictureDao.h 
#include &lt;QVector&gt; 
 
class QSqlDatabase; 
class Picture; 
 
class PictureDao 
{ 
public: 
    explicit PictureDao(QSqlDatabase&amp; database); 
    void init() const; 
 
    void addPictureInAlbum(int albumId, Picture&amp; picture) const; 
    void removePicture(int id) const; 
    void removePicturesForAlbum(int albumId) const; 
    QVector&lt;Picture*&gt; picturesForAlbum(int albumId) const; 
 
private: 
    QSqlDatabase&amp; mDatabase; 
}; 
 
// In PictureDao.cpp 
void PictureDao::init() const 
{ 
    if (!mDatabase.tables().contains("pictures")) { 
        QSqlQuery query(mDatabase); 
        query.exec(QString("CREATE TABLE pictures") 
        + " (id INTEGER PRIMARY KEY AUTOINCREMENT, " 
        + "album_id INTEGER, " 
        + "url TEXT)"); 
    } 
} 
</pre><p>As you can see, multiple functions take an <code class="literal">albumId</code> parameter to make the link between the picture and the owning <code class="literal">album</code> parameter. In the <code class="literal">init()</code> function, the foreign key is expressed in the <code class="literal">album_id INTEGER</code> syntax. SQLITE3 does not have a proper foreign key type. It is a very simple database and there is no strict constraint for this type of field; a simple integer is used.</p><p>Finally, the <code class="literal">PictureDao</code> function is added in the <code class="literal">DatabaseManager</code> class exactly as we did for <code class="literal">albumDao</code>. One could argue that, if there are a lot of <code class="literal">Dao</code> classes, adding a <code class="literal">const Dao</code> member in the <code class="literal">DatabaseManager</code> class and calling the <code class="literal">init()</code> function quickly becomes cumbersome.</p><p>A possible solution could be to make an abstract <code class="literal">Dao</code> class, with a pure virtual <code class="literal">init()</code> function. The <code class="literal">DatabaseManager</code> class would have a <code class="literal">Dao</code> registry, which maps each <code class="literal">Dao</code> to a <code class="literal">QString</code> key with a <code class="literal">QHash&lt;QString, const Dao&gt; mDaos</code>. The <code class="literal">init()</code> function call would then be called in a <code class="literal">for</code> loop and a <code class="literal">Dao</code> object would be accessed using the <code class="literal">QString</code> key. This is outside the scope of this project, but is nevertheless an interesting approach.</p></div>
<div class="section" title="Protecting your code with a smart pointer"><div class="titlepage" id="aid-1394Q2"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Protecting your code with a smart pointer</h1></div></div></div><p>The code we just described is fully functional, but, it can be strengthened, specifically with the function, <code class="literal">AlbumDao::albums()</code>. In this function, we iterate through the database rows and create a new <code class="literal">Album</code> to fill a list. We can zoom in on this specific code section:</p><pre class="programlisting">QVector&lt;Album*&gt; list; 
while(query.next()) { 
    Album* album = new Album(); 
    album-&gt;setId(query.value("id").toInt()); 
    album-&gt;setName(query.value("name").toString()); 
    list.append(album); 
} 
return list; 
</pre><p>Let's say that the <code class="literal">name</code> column has been renamed to <code class="literal">title</code>. If you forget to update <code class="literal">query.value("name")</code>, you might run into trouble. The Qt framework does not rely on exceptions, but this cannot be said for every API available in the wild. An exception here would cause a memory leak: the <code class="literal">Album* album</code> function has been allocated on the heap but not released. To handle this, you would have to surround the risky code with a <code class="literal">try</code> <code class="literal">catch</code> statement and deallocate the <code class="literal">album</code> parameter if an exception has been thrown. Maybe this error should bubble up; hence, your <code class="literal">try</code><code class="literal">catch</code> statement is only there to handle the potential memory leak. Can you picture the spaghetti code weaving in front of you?</p><p>The real issue with pointers is the uncertainty of their ownership. Once it has been allocated, who is the owner of a pointer? Who is responsible for deallocating the object? When you pass a pointer as a parameter, when does the caller retain the ownership or release it to the callee?</p><p>Since C++11, a major milestone has been reached in memory management: the smart pointer feature has been stabilized and can greatly improve the safety of your code. The goal is to explicitly indicate the ownership of a pointer through simple template semantics. There are three types of smart pointer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">unique_ptr</code> pointer indicates that the owner is the only owner of the pointer</li><li class="listitem">The <code class="literal">shared_ptr</code> pointer indicates that the pointer's ownership is shared among several clients</li><li class="listitem">The <code class="literal">weak_ptr</code> pointer indicates that the pointer does not belong to the client</li></ul></div><p>For now, we will focus on the  <code class="literal">unique_ptr</code> pointer to understand smart pointer mechanics.</p><p>A <code class="literal">unique_ptr</code> pointer is simply a variable allocated on the stack that takes the ownership of the pointer you provide with it. Let's allocate an <code class="literal">Album</code> with this semantic:</p><pre class="programlisting">#include &lt;memory&gt; 
void foo() 
{ 
    Album* albumPointer = new Album(); 
    std::unique_ptr&lt;Album&gt; album(albumPointer); 
    album-&gt;setName("Unique Album"); 
} 
</pre><p>The whole smart pointer API is available in the <code class="literal">memory</code> header. When we declared <code class="literal">album</code> as a <code class="literal">unique_ptr</code>, we did two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We allocated on the stack a <code class="literal">unique_ptr&lt;Album&gt;</code>. The <code class="literal">unique_ptr</code> pointer relies on templates to check at compile time the validity of the pointer type.</li><li class="listitem">We granted the ownership of <code class="literal">albumPointer</code> memory to <code class="literal">album</code>. From this point on, <code class="literal">album</code> is the owner of the pointer.</li></ul></div><p>This simple line has important ramifications. First and foremost, you do not have to worry anymore about the pointer life cycle. Because a <code class="literal">unique_ptr</code> pointer is allocated on the stack, it will be destroyed as soon as it goes out of scope. In this example, when we exit <code class="literal">foo()</code>, <code class="literal">album </code>will be removed from the stack. The <code class="literal">unique_ptr</code> implementation will take care of calling the <code class="literal">Album</code> destructor and deallocating the memory.</p><p>Secondly, you explicitly indicate the ownership of your pointer at compile time. Nobody can deallocate the <code class="literal">albumPointer</code> content if they do not voluntarily fiddle with your <code class="literal">unique_ptr</code> pointer. Your fellow developers will also know with a single glance who is the owner of your pointer.</p><p>Note that, even though <code class="literal">album</code> is a type of <code class="literal">unique_ptr&lt;Album&gt;</code>, you can still call <code class="literal">Album</code> functions (for example, <code class="literal">album-&gt;setName()</code>) using the <code class="literal">-&gt;</code> operator. This is possible thanks to the overload of this operator. The usage of the <code class="literal">unique_ptr</code> pointer becomes transparent.</p><p>Well, this use case is nice, but the purpose of a pointer is to be able to allocate a chunk of memory and share it. Let's say the <code class="literal">foo()</code> function allocates the <code class="literal">album unique_ptr</code> pointer and then transfers the ownership to <code class="literal">bar()</code>. This would look like this:</p><pre class="programlisting">void foo() 
{ 
    std::unique_ptr&lt;Album&gt; album(new Album()); 
    bar(std::move(album)); 
} 
 
void bar(std::unique_ptr&lt;Album&gt; barAlbum) 
{ 
   qDebug() &lt;&lt; "Album name" &lt;&lt; barAlbum-&gt;name(); 
} 
</pre><p>Here, we introduce the <code class="literal">std::move()</code> function: its goal is to transfer the ownership of a <code class="literal">unique_ptr</code> function. Once <code class="literal">bar(std::move(album))</code> has been called, <code class="literal">album</code> becomes invalid. You can test it with a simple <code class="literal">if</code> statement: <code class="literal">if (album) { ... }</code>.</p><p>From now on, the <code class="literal">bar()</code> function becomes the owner of the pointer (through <code class="literal">barAlbum</code>) by allocating a new <code class="literal">unique_ptr</code> on the stack and it will deallocate the pointer on its exit. You do not have to worry about the cost of a <code class="literal">unique_ptr</code> pointer, as these objects are very lightweight and it is unlikely that they will affect the performance of your application.</p><p>Again, the signature of <code class="literal">bar()</code> tells the developer that this function expects to take the ownership of the passed <code class="literal">Album</code>. Trying to pass around <code class="literal">unique_ptr</code> without the <code class="literal">move()</code> function will lead to a compile error.</p><p>Another thing to note is the different meanings of the <code class="literal">.</code> (dot) and the <code class="literal">-&gt;</code> (arrow) when working with a <code class="literal">unique_ptr</code> pointer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">-&gt;</code> operator dereferences to the pointer members and lets your call function on your real object</li><li class="listitem">The <code class="literal">.</code> operator gives you access to the <code class="literal">unique_ptr</code> object functions</li></ul></div><p>The <code class="literal">unique_ptr</code> pointer provides various functions. Among the most important are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">get()</code> function returns the raw pointer. The <code class="literal">album.get()</code> returns an <code class="literal">Album*</code> value.</li><li class="listitem">The <code class="literal">release()</code> function releases the ownership of the pointer and returns the raw pointer. The <code class="literal">album.release()</code> function returns an <code class="literal">Album*</code> value.</li><li class="listitem">The <code class="literal">reset(pointer p = pointer())</code> function destroys the currently managed pointer and takes ownership of the given parameter. An example would be the <code class="literal">barAlbum.reset()</code> function, which destroys the currently owned <code class="literal">Album*</code>. With a parameter, <code class="literal">barAlbum.reset(new Album())</code> also destroys the owned object and takes the ownership of the provided parameter.</li></ul></div><p>Finally, you can dereference the object with the <code class="literal">*</code> operation, meaning <code class="literal">*album</code> will return an <code class="literal">Album&amp;</code> value. This dereferencing is convenient, but you will see that the more a smart pointer is used, the less you will need it. Most of the time, you will replace a raw pointer with the following syntax:</p><pre class="programlisting">void bar(std::unique_ptr&lt;Album&gt;&amp; barAlbum); 
</pre><p>Because we pass the <code class="literal">unique_ptr</code> by reference, <code class="literal">bar()</code> does not take ownership of the pointer and will not try do deallocate it upon its exit. With this, there is no need to use <code class="literal">move(album)</code> in <code class="literal">foo()</code>; the <code class="literal">bar()</code> function will just do operations on the <code class="literal">album</code> parameter but will not take its ownership.</p><p>Now, let's consider <code class="literal">shared_ptr</code>. A <code class="literal">shared_ptr</code> pointer keeps a reference counter on a pointer. Each time a <code class="literal">shared_ptr</code> pointer references the same object, the counter is incremented; when this <code class="literal">shared_ptr</code> pointer goes out of scope, the counter is decremented. When the counter reaches zero, the object is deallocated.</p><p>Let's rewrite our <code class="literal">foo()</code>/<code class="literal">bar()</code> example with a <code class="literal">shared_ptr</code> pointer:</p><pre class="programlisting">#include &lt;memory&gt; 
void foo() 
{ 
    std::shared_ptr&lt;Album&gt; album(new Album()); // ref counter = 1 
    bar(album); // ref counter = 2 
} // ref counter = 0 
 
void bar(std::shared_ptr&lt;Album&gt; barAlbum) 
{ 
   qDebug() &lt;&lt; "Album name" &lt;&lt; barAlbum-&gt;name(); 
} // ref counter = 1 
</pre><p>As you can see, the syntax is very similar to the <code class="literal">unique_ptr</code> pointer. The reference counter is incremented each time a new <code class="literal">shared_ptr</code> pointer is allocated and points to the same data, and is decremented on the function exit. You can check the current count by calling the <code class="literal">album.use_count()</code> function.</p><p>The last smart pointer we will cover is the <code class="literal">weak_ptr</code> pointer. As the name suggests, it does not take any ownership or increment the reference counter. When a function specifies a <code class="literal">weak_ptr</code>, it indicates to the callers that it is just a client and not an owner of the pointer. If we re implement <code class="literal">bar()</code> with a <code class="literal">weak_ptr</code> pointer, we get:</p><pre class="programlisting">#include &lt;memory&gt; 
void foo() 
{ 
    std::shared_ptr&lt;Album&gt; album(new Album()); // ref counter = 1 
    bar(std::weak_ptr&lt;Album&gt;(album)); // ref counter = 1 
} // ref counter = 0 
 
void bar(std::weak_ptr&lt;Album&gt; barAlbum) 
{ 
   qDebug() &lt;&lt; "Album name" &lt;&lt; barAlbum-&gt;name(); 
} // ref counter = 1 
</pre><p>If the story stopped here, there would not be any interest in using a <code class="literal">weak_ptr</code> versus a raw pointer. The <code class="literal">weak_ptr</code> has a major advantage for the dangling pointer issue. If you are building a cache, you typically do not want to keep strong references to your object. On the other hand, you want to know if the objects are still valid. By using <code class="literal">weak_ptr</code>, you know when an object has been deallocated. Now, consider the raw pointer approach: your pointer might be invalid but you do not know the state of the memory.</p><p>There is another semantic introduced in C++14 that we have to cover: <code class="literal">make_unique</code>. This keyword aims to replace the <code class="literal">new</code> keyword and construct a <code class="literal">unique_ptr</code> object in an exception-safe manner. This is how it is used:</p><pre class="programlisting">unique_ptr&lt;Album&gt; album = make_unique&lt;Album&gt;(); 
</pre><p>The <code class="literal">make_unique</code> keyword wraps the <code class="literal">new</code> keyword to make it exception-safe, specifically in this situation:</p><pre class="programlisting">foo(new Album(), new Picture()) 
</pre><p>This code will be executed in the following order:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Allocate and construct the <code class="literal">Album</code> function.</li><li class="listitem">Allocate and construct the <code class="literal">Picture</code> function.</li><li class="listitem">Execute the <code class="literal">foo()</code> function.</li></ol><div style="height:10px; width: 1px"/></div><p>If <code class="literal">new Picture()</code> throws an exception, the memory allocated by <code class="literal">new Album()</code> will be leaked. This is fixed by using the <code class="literal">make_unique</code> keyword:</p><pre class="programlisting">foo(make_unique&lt;Album&gt;(), make_unique&lt;Picture&gt;()) 
</pre><p>The <code class="literal">make_unique</code> keyword returns a <code class="literal">unique_ptr</code> pointer; the C++ standard committee also provided an equivalent for <code class="literal">shared_ptr</code> in the form of <code class="literal">make_shared</code>, which follows the same principle.</p><p>All these new C++ semantics try very hard to get rid of <code class="literal">new</code> and <code class="literal">delete</code>. Yet, it may be cumbersome to write all the <code class="literal">unique_ptr</code> and <code class="literal">make_unique</code> stuff. The <code class="literal">auto</code> keyword comes to the rescue in our <code class="literal">album</code> creation:</p><pre class="programlisting">auto album = make_unique&lt;Album&gt;() 
</pre><p>This is a radical departure from the common C++ syntax. The variable type is deduced, there is no explicit pointer, and the memory is automatically managed. After some time with smart pointers, you will see fewer and fewer raw pointers in your code (and even fewer <code class="literal">delete</code>, which is such a relief). The remaining raw pointers will simply indicate that a client is using the pointer but does not own it.</p><p>Overall, C++11 and C++14 smart pointers are a real step up in C++ code writing. Before them, the bigger the code base, the more insecure we felt about memory management. Our brain is just bad at properly grasping complexity at such a level. Smart pointers simply make you feel safe about what you write. On the other hand, you retain full control of the memory. For performance-critical code, you can always handle the memory yourself. For everything else, smart pointers are an elegant way of explicitly indicating your object's ownership and freeing your mind.</p><p>We are now equipped to rewrite the little insecure snippet in the <code class="literal">AlbumDao::albums()</code> function. Update <code class="literal">AlbumDao::albums()</code> like so:</p><pre class="programlisting">// In AlbumDao.h 
std::unique_ptr&lt;std::vector&lt;std::unique_ptr&lt;Album&gt;&gt;&gt; albums() const; 
 
// In AlbumDao.cpp 
unique_ptr&lt;vector&lt;unique_ptr&lt;Album&gt;&gt;&gt; AlbumDao::albums() const 
{ 
    QSqlQuery query("SELECT * FROM albums", mDatabase); 
    query.exec(); 
    unique_ptr&lt;vector&lt;unique_ptr&lt;Album&gt;&gt;&gt; list(new vector&lt;unique_ptr&lt;Album&gt;&gt;()); 
    while(query.next()) { 
        unique_ptr&lt;Album&gt; album(new Album()); 
        album-&gt;setId(query.value("id").toInt()); 
        album-&gt;setName(query.value("name").toString()); 
        list-&gt;push_back(move(album)); 
    } 
    return list; 
} 
</pre><p>Wow! The signature of the <code class="literal">album()</code> function has turned into something very peculiar. Smart pointers are supposed to make your life easier, right? Let's break it down to understand a major point of smart pointers with Qt: container behavior.</p><p>The initial goal of the rewrite was to secure the creation of <code class="literal">album</code>. We want the <code class="literal">list</code> to be the explicit owner of the <code class="literal">album</code>. This would have changed our <code class="literal">list</code> type (that is <code class="literal">albums()</code> return type) to <code class="literal">QVector&lt;unique_ptr&lt;Album&gt;&gt;</code>. However, when the <code class="literal">list</code> type is returned, its elements will be copied (remember, we previously defined the return type to <code class="literal">QVector&lt;Album&gt;</code>). A natural way out of this would be to return a <code class="literal">QVector&lt;unique_ptr&lt;Album&gt;&gt;*</code> type to retain the uniqueness of our <code class="literal">Album</code> elements.</p><p>Behold, here lies a major pain: the <code class="literal">QVector</code> class overloads the copy operator. Hence, when the <code class="literal">list</code> type is returned, the uniqueness of our <code class="literal">unique_ptr</code> elements cannot be guaranteed by the compiler and it will throw a compile error. This is why we have to resort to a <code class="literal">vector</code> object coming from the standard library and write the long type: <code class="literal">unique_ptr&lt;vector&lt;unique_ptr&lt;Album&gt;&gt;&gt;</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note22"/>Note</h3><p>Take a look at the official response for support of the <code class="literal">unique_ptr</code> pointer in the Qt container. It is clear beyond any possible doubt: <span><a class="ulink" href="http://lists.qt-project.org/pipermail/interest/2013-July/007776.html">http://lists.qt-project.org/pipermail/interest/2013-July/007776.html</a></span>.
The short answer is: no, it will never be done. Do not even mention it. Ever.</p></div><p>If we translate this new <code class="literal">albums()</code> signature into plain English it will read: the <code class="literal">album()</code> function returns a vector of <code class="literal">Album</code>. This vector is the owner of the <code class="literal">Album</code> elements it contains and you will be the owner of the vector.</p><p>To finish covering this implementation of <code class="literal">albums()</code>, you may notice that we did not use the <code class="literal">auto</code> and <code class="literal">make_unique</code> keywords for the <code class="literal">list</code> declaration. Our library will be used on a mobile in <span><a class="link" title="Chapter 5.  Dominating the Mobile UI" href="part0048.xhtml#aid-1DOR02">Chapter 5</a></span>, <span class="emphasis"><em>Dominating the Mobile UI</em></span>, and C++14 is not yet supported on this platform. Therefore, we have to restrain our code to C++11.</p><p>We also encounter the use of the <code class="literal">move</code> function in the instruction <code class="literal">list-&gt;push_back(move(album))</code>. Until that line, the <code class="literal">album</code> is "owned" by the <code class="literal">while</code> scope, the move gives the ownership to the list. At the last instruction, <code class="literal">return list</code>, we should have written <code class="literal">move(list)</code>, but C++11 accepts the direct return and will automatically make the <code class="literal">move()</code> function for us.</p><p>What we covered in this section is that the <code class="literal">AlbumDao</code> class is completely matched in <code class="literal">PictureDao</code>. Please refer to the source code of the chapter to see the full <code class="literal">PictureDao</code> class implementation.</p></div>
<div class="section" title="Implementing the model"><div class="titlepage" id="aid-147LC2"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Implementing the model</h1></div></div></div><p>The data is ready to be exposed to potential clients (the applications that will display and edit its content). However, a direct connection between the client and the database will make a very strong coupling. If we decide to switch to another storage type, the view would have to be rewritten, partially at least.</p><p>This is where the model comes to our rescue. It is an abstract layer that communicates with the data (our database) and exposes this data to the client in a data-specific, implementation-agnostic form. This approach is a direct offspring of the <span class="strong"><strong>MVC</strong></span> (<span class="strong"><strong>Model View Controller</strong></span>) concept. Let's recapitulate how MVC works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The Model manages the data. It is responsible for requesting for the data and updating it.</li><li class="listitem">The View displays the data to the user.</li><li class="listitem">The Controller interacts with both the Model and the View. It is responsible for feeding the View with the correct data and sending commands to the Model based on the user interaction received from the View.</li></ul></div><p>This paradigm enables swapping various parts without disturbing the others. Multiple views can display the same data, the data layer can be changed, and the upper parts will not be aware of it.</p><p>Qt combines the View and the Controller to form the Model/View architecture. The separation of the storage and the presentation is retained while being simpler to implement than a full MVC approach. To allow editing and view customization, Qt introduces the concept of Delegate, which is connected to both the Model and the View:</p><div class="mediaobject"><img src="../Images/image00367.jpeg" alt="Implementing the model"/></div><p style="clear:both; height: 1em;"> </p><p>The Qt documentation about Model/View is truly plethoric. It is nevertheless easy to get lost in the details; it feels sometimes a bit overwhelming. We will try to clear things up by implementing the <code class="literal">AlbumModel</code> class and seeing how it works.</p><p>Qt offers various Model sub-classes that all extend from <code class="literal">QAbstractItemModel</code>. Before starting the implementation, we have to carefully choose which base class will be extended. Keep in mind that our data are variations on lists: we will have a list of albums, and each album will have a list of pictures. Let's see what Qt offers us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">QAbstractItemModel</code>: This class is the most abstract, and therefore, the most complex, to implement. We will have to redefine a lot of functions to properly use it.</li><li class="listitem"><code class="literal">QStringListModel</code>: This class is a model that supplies strings to views. It is too simple. Our model is more complex (we have custom objects).</li><li class="listitem"><code class="literal">QSqlTableModel</code> (or <code class="literal">QSqLQueryModel</code>): This class is a very interesting contender. It automatically handles multiple SQL queries. On the other hand, it works only for very simple table schemas. In the <code class="literal">pictures</code> table, for example, the <code class="literal">album_id</code> foreign key makes it very hard to fit this model. You might save some lines of code, but if feels like trying to shoehorn a round peg into a square hole.</li><li class="listitem"><code class="literal">QAbstractListModel</code>: This class provides a model that offers one-dimensional lists. This fits nicely with our requirements, saves a lot of key strokes, and is still flexible enough.</li></ul></div><p>We will go with the <code class="literal">QabstractListModel</code> class and create a new C++ class named <code class="literal">AlbumModel</code>. Update the <code class="literal">AlbumModel.h</code> file to look like this:</p><pre class="programlisting">#include &lt;QAbstractListModel&gt; 
#include &lt;QHash&gt; 
#include &lt;vector&gt; 
#include &lt;memory&gt; 
 
#include "gallery-core_global.h" 
#include "Album.h" 
#include "DatabaseManager.h" 
 
class GALLERYCORESHARED_EXPORT AlbumModel : public QAbstractListModel 
{ 
    Q_OBJECT 
public: 
 
    enum Roles { 
        IdRole = Qt::UserRole + 1, 
        NameRole, 
    }; 
 
    AlbumModel(QObject* parent = 0); 
 
    QModelIndex addAlbum(const Album&amp; album); 
 
    int rowCount(const QModelIndex&amp; parent = QModelIndex()) const override; 
    QVariant data(const QModelIndex&amp; index, int role = Qt::DisplayRole) const override; 
    bool setData(const QModelIndex&amp; index, const QVariant&amp; value, int role) override; 
    bool removeRows(int row, int count, const QModelIndex&amp; parent) override; 
    QHash&lt;int, QByteArray&gt; roleNames() const override; 
 
private: 
    bool isIndexValid(const QModelIndex&amp; index) const; 
 
private: 
    DatabaseManager&amp; mDb; 
    std::unique_ptr&lt;std::vector&lt;std::unique_ptr&lt;Album&gt;&gt;&gt; mAlbums; 
}; 
</pre><p>The <code class="literal">AlbumModel</code> class extends the <code class="literal">QAbstractListModel</code> class and has only two members:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mDb</code>: This is the link to the database. In the Model/View schema, the model will communicate with the data layer through <code class="literal">mDb</code>.</li><li class="listitem"><code class="literal">mAlbums</code>: This acts as a buffer that will avoid hitting the database too much. The type should remind you of what we wrote for <code class="literal">AlbumDao::albums()</code> with the smart pointers.</li></ul></div><p>The only specific functions the <code class="literal">AlbumModel</code> class has are <code class="literal">addAlbum()</code> and <code class="literal">isIndexValid()</code>. The rest are overrides of <code class="literal">QAbstractListModel</code> functions. We will go through each of these functions to understand how a model works.</p><p>First, let's see how the <code class="literal">AlbumModel</code> class is constructed in the <code class="literal">AlbumModel.cpp</code> file:</p><pre class="programlisting">AlbumModel::AlbumModel(QObject* parent) : 
    QAbstractListModel(parent), 
    mDb(DatabaseManager::instance()), 
    mAlbums(mDb.albumDao.albums()) 
{ 
} 
</pre><p>The <code class="literal">mDb</code> file is initialized with the <code class="literal">DatabaseManager</code> singleton address, and, after that, we see the now famous <code class="literal">AlbumDao::albums()</code> in action.</p><p>The <code class="literal">vector</code> type is returned and initializes <code class="literal">mAlbums</code>. This syntax make the ownership transfer automatic without any need for an explicit call to the <code class="literal">std::move()</code> function. If there are any stored albums in the database, <code class="literal">mAlbums</code> is immediately filled with those.</p><p>Each time the model interacts with the view (to notify us about changes or to serve data), <code class="literal">mAlbums</code> will be used. Because it is in memory only, reading will be very fast. Of course, we have to be careful about maintaining <code class="literal">mAlbum</code> coherently with the database state, but everything will stay inside the <code class="literal">AlbumModel</code> inner mechanics.</p><p>As we said earlier, the model aims to be the central point to interact with the data. Each time the data changes, the model will emit a signal to notify the view; each time the view wants to display data, it will request the model for it. The <code class="literal">AlbumModel</code> class overrides everything needed for read and write access. The read functions are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">rowCount()</code>: This function is used to get the list size</li><li class="listitem"><code class="literal">data()</code>: This function is used to get a specific piece of information about the data to display</li><li class="listitem"><code class="literal">roleNames()</code>: This function is used to indicate to the framework the name for each "role". We will explain in a few paragraphs what a role is</li></ul></div><p>The editing functions are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">setData()</code>: This function is used to update data</li><li class="listitem"><code class="literal">removeRows()</code>: This function is used to remove data</li></ul></div><p>We will start with the read part, where the view asks the model for the data.</p><p>Because we will display a list of albums, the first thing the view should know is how many items are available. This is done in the <code class="literal">rowCount()</code> function:</p><pre class="programlisting">int AlbumModel::rowCount(const QModelIndex&amp; parent) const 
{ 
    return mAlbums-&gt;size(); 
} 
</pre><p>Being our buffer object, using <code class="literal">mAlbums-&gt;size()</code> is perfect. There is no need to query the database, as <code class="literal">mAlbums</code> is already filled with all the albums of the database. The <code class="literal">rowCount()</code> function has an unknown parameter: a <code class="literal">const QModelIndex&amp; parent</code>. Here, it is not used, but we have to explain what lies beneath this type before continuing our journey in the <code class="literal">AlbumModel</code> class.</p><p>The <code class="literal">QModelIndex</code> class is a central notion of the Model/View framework in Qt. It is a lightweight object used to locate data within a model. We use a simple <code class="literal">QAbstractListModel</code> class, but Qt is able to handle three representation types:</p><div class="mediaobject"><img src="../Images/image00368.jpeg" alt="Implementing the model"/><div class="caption"><p>There is no better explanation than an official Qt diagram</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's now see the models in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>List Model</strong></span>: In this model, the data is stored in a one-dimensional array (rows)</li><li class="listitem"><span class="strong"><strong>Table Model</strong></span>: In this model, the data is stored in a two-dimensional array (rows and columns)</li><li class="listitem"><span class="strong"><strong>Tree Model</strong></span>: In this model, the data is stored in a hierarchical relationship (parent/children)</li></ul></div><p>To handle all these model types, Qt came up with the <code class="literal">QModelIndex</code> class, which is an abstract way of dealing with them. The <code class="literal">QModelIndex</code> class has the functions for each of the use cases: <code class="literal">row()</code>, <code class="literal">column()</code>, and <code class="literal">parent()</code>/<code class="literal">child()</code>. Each instance of a <code class="literal">QModelIndex</code> is meant to be short-lived: the model might be updated and thus the index will become invalid.</p><p>The model will produce indexes according to its data type and will provide these indexes to the view. The view will then use them to query back new data to the model without needing to know if an <code class="literal">index.row()</code> function corresponds to a database row or a <code class="literal">vector</code> index.</p><p>We can see the <code class="literal">index</code> parameter in action with the implementation of <code class="literal">data()</code>:</p><pre class="programlisting">QVariant AlbumModel::data(const QModelIndex&amp; index, int role) const 
{ 
    if (!isIndexValid(index)) { 
        return QVariant(); 
    } 
    const Album&amp; album = *mAlbums-&gt;at(index.row()); 
 
    switch (role) { 
        case Roles::IdRole: 
            return album.id(); 
 
        case Roles::NameRole: 
        case Qt::DisplayRole: 
            return album.name(); 
 
        default: 
            return QVariant(); 
    } 
} 
</pre><p>The view will ask for data with two parameters: an <code class="literal">index</code> and a <code class="literal">role</code>. As we have already covered the <code class="literal">index</code>, we can focus on the <code class="literal">role</code> responsibility.</p><p>When the data is displayed, it will probably be an aggregation of multiple data. For example, displaying the picture will consist of a thumbnail and the picture name. Each one of these data elements needs to be retrieved by the view. The <code class="literal">role</code> parameter fills this need, it associates each data element to a tag for the view to know what category of data is shown.</p><p>Qt provides various default roles (<code class="literal">DisplayRole</code>, <code class="literal">DecorationRole</code>, <code class="literal">EditRole</code>, and so on) and you can define your own if needed. This is what we did in the <code class="literal">AlbumModel.h</code> file with the <code class="literal">enum Roles</code>: we added an <code class="literal">IdRole</code> and a <code class="literal">NameRole</code>.</p><p>The body of the <code class="literal">data()</code> function is now within our reach! We first test the validity of the <code class="literal">index</code> with a helper function, <code class="literal">isIndexValid()</code>. Take a look at the source code of the chapter to see what it does in detail. The view asked for data at a specific <code class="literal">index</code>: we retrieve the <code class="literal">album</code> row at the given <code class="literal">index</code> with <code class="literal">*mAlbums-&gt;at(index.row())</code>.</p><p>This returns a <code class="literal">unique_ptr&lt;Album&gt;</code> value at the <code class="literal">index.row()</code> index and we dereference it to have an <code class="literal">Album&amp;</code>. The <code class="literal">const</code> modifier is interesting here because we are in a read function, and it makes no sense to modify the <code class="literal">album</code> row. The <code class="literal">const</code> modifier adds this check at compile time.</p><p>The <code class="literal">switch</code> on the <code class="literal">role</code> parameter tells us what data category should be returned. The <code class="literal">data()</code> function returns a <code class="literal">QVariant</code> value, which is the Awiss Army Knife of types in Qt. We can safely return the <code class="literal">album.id()</code>, <code class="literal">album.name()</code>, or a default <code class="literal">QVariant()</code> if we do not handle the specified role.</p><p>The last read function to cover is <code class="literal">roleNames()</code>:</p><pre class="programlisting">QHash&lt;int, QByteArray&gt; AlbumModel::roleNames() const 
{ 
    QHash&lt;int, QByteArray&gt; roles; 
    roles[Roles::IdRole] = "id"; 
    roles[Roles::NameRole] = "name"; 
    return roles; 
} 
</pre><p>At this level of abstraction, we do not know what type of view will be used to display our data. If the views are written in QML, they will need some meta-information about the data structure. The <code class="literal">roleNames()</code> function provides this information so the role names can be accessed via QML. If you are writing for a desktop widget view only, you can safely ignore this function. The library we are currently building will be used for QML; this is why we override this function.</p><p>The reading part of the model is now over. The client view has everything it needs to properly query and display the data. We shall now investigate the editing part of <code class="literal">AlbumModel</code>.</p><p>We will start with the creation of a new album. The view will build a new <code class="literal">Album</code> object and pass it to <code class="literal">Album::addAlbum()</code> to be properly persisted:</p><pre class="programlisting">QModelIndex AlbumModel::addAlbum(const Album&amp; album) 
{ 
    int rowIndex = rowCount(); 
    beginInsertRows(QModelIndex(), rowIndex, rowIndex); 
    unique_ptr&lt;Album&gt; newAlbum(new Album(album)); 
    mDb.albumDao.addAlbum(*newAlbum); 
    mAlbums-&gt;push_back(move(newAlbum)); 
    endInsertRows(); 
    return index(rowIndex, 0); 
} 
</pre><p>Indexes are a way to navigate within the model data. This first thing we do is to determinate what will be the index of this new album by getting the <code class="literal">mAlbums</code> size with <code class="literal">rowCount()</code>.</p><p>From here, we start to use specific model functions: <code class="literal">beginInsertRows()</code> and <code class="literal">endInsertRows()</code>. These functions wrap real data modifications. Their purpose is to automatically trigger signals for whoever might be interested:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">beginInsertRows()</code>: This function informs that rows are about to change for the given indexes</li><li class="listitem"><code class="literal">endInsertRows()</code>: This function informs that rows have been changed</li></ul></div><p>The first parameter of the <code class="literal">beginInsertRows()</code> function is the <code class="literal">parent</code> for this new element. The root for a model is always an empty <code class="literal">QModelIndex()</code> constructor. Because we do not handle any hierarchical relationship in <code class="literal">AlbumModel</code>, it is safe to always add the new element to the root. The following parameters are the first and last modified indexes. We insert a single element per call, so we provide <code class="literal">rowIndex</code> twice. To illustrate the usage of this signal, a view might, for example, display a loading message telling the user "Saving 5 new albums".</p><p>For <code class="literal">endInsertRows()</code>, the interested view might hide the saving message and display "Save finished".</p><p>This may look strange at first, but it enables Qt to handle automatically a lot of signaling for us and in a generic way. You will see very soon how well this works when designing the UI of the application in <span><a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a></span>, <span class="emphasis"><em>Conquering the Desktop UI</em></span>.</p><p>The real insertion begins after the <code class="literal">beginInsertRows()</code> instruction. We start by creating a copy of the <code class="literal">album</code> row with <code class="literal">unique_ptr&lt;Album&gt; newAlbum</code>. This object is then inserted in the database with <code class="literal">mDb.albumDao.addAlbum(*newAlbum)</code>. Do not forget that the <code class="literal">AlbumDao::addAlbum()</code> function also modifies the passed album by setting its <code class="literal">mId</code> to the last SQLITE3-inserted ID.</p><p>Finally, <code class="literal">newAlbum</code> is added to <code class="literal">mAlbums</code> and its ownership is transferred as well with <code class="literal">std::move()</code>. The return gives the index object of this new album, which is simply the row wrapped in a <code class="literal">QModelIndex</code> object.</p><p>Let's continue the editing functions with <code class="literal">setData()</code>:</p><pre class="programlisting">bool AlbumModel::setData(const QModelIndex&amp; index, const QVariant&amp; value, int role) 
{ 
    if (!isIndexValid(index) 
            || role != Roles::NameRole) { 
        return false; 
    } 
    Album&amp; album = *mAlbums-&gt;at(index.row()); 
    album.setName(value.toString()); 
    mDb.albumDao.updateAlbum(album); 
    emit dataChanged(index, index); 
    return true; 
} 
</pre><p>This function is called when the view wants to update the data. The signature is very similar to <code class="literal">data()</code>, with the additional parameter value.</p><p>The body also follows the same logic. Here, the <code class="literal">album</code> row is an <code class="literal">Album&amp;</code>, without the <code class="literal">const</code> keyword. The only possible value to edit is the name, which is done on the object and then persisted to the database.</p><p>We have to emit ourselves the <code class="literal">dataChanged()</code> signal to notify whoever is interested that a row changed for the given indexes (the start index and end index). This powerful mechanism centralizes all the states of the data, enabling possible views (album list and current album detail for example) to be automatically refreshed.</p><p>The return of the function simply indicates if the data update was successful. In a production application, you should test the database processing success and return the relevant value.</p><p>Finally, the last editing function we will cover is <code class="literal">removeRows()</code>:</p><pre class="programlisting">bool AlbumModel::removeRows(int row, int count, const QModelIndex&amp; parent) 
{ 
    if (row &lt; 0 
            || row &gt;= rowCount() 
            || count &lt; 0 
            || (row + count) &gt; rowCount()) { 
        return false; 
    } 
    beginRemoveRows(parent, row, row + count - 1); 
    int countLeft = count; 
    while (countLeft--) { 
        const Album&amp; album = *mAlbums-&gt;at(row + countLeft); 
        mDb.albumDao.removeAlbum(album.id()); 
    } 
    mAlbums-&gt;erase(mAlbums-&gt;begin() + row, 
                  mAlbums-&gt;begin() + row + count); 
    endRemoveRows(); 
    return true; 
} 
</pre><p>The function signature should start to look familiar by now. When a view wants to remove rows, it has to provide the starting row, the number of rows to delete, and the parent of the row.</p><p>After that, just as we did for <code class="literal">addAlbum()</code>, we wrap the effective removal with two functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">beginRemoveRows()</code> function, which expects the parent, the starting index, and the last index</li><li class="listitem">The <code class="literal">endRemoveRows()</code> function, which simply triggers automatic signals in the model framework</li></ul></div><p>The rest of the function is not very hard to follow. We loop on the rows left to delete and, for each one, we delete it from the database and remove it from <code class="literal">mAlbums</code>. We simply retrieve the album from our in-memory <code class="literal">mAlbums</code> vector and process the real database deletion with <code class="literal">mDb.albumDao.removeAlbum(album.id())</code>.</p><p>The <code class="literal">AlbumModel</code> class is now completely covered. You can now create a new C++ class and name it <code class="literal">PictureModel</code>.</p><p>We will not cover the <code class="literal">PictureModel</code> class in so much detail. The major parts are the same (you simply swap the data class <code class="literal">Album</code> for <code class="literal">Picture</code>). There is however one main difference: <code class="literal">PictureModel</code> always handles pictures for a given album. This design choice illustrates how two models can be linked with only some simple signals.</p><p>Here is the updated version of <code class="literal">PictureModel.h</code>:</p><pre class="programlisting">#include &lt;memory&gt; 
#include &lt;vector&gt; 
 
#include &lt;QAbstractListModel&gt; 
 
#include "gallery-core_global.h" 
#include "Picture.h" 
 
class Album; 
class DatabaseManager; 
class AlbumModel; 
 
class GALLERYCORESHARED_EXPORT PictureModel : public QAbstractListModel 
{ 
    Q_OBJECT 
public: 
 
    enum PictureRole { 
        FilePathRole = Qt::UserRole + 1 
    }; 
    PictureModel(const AlbumModel&amp; albumModel, QObject* parent = 0); 
 
    QModelIndex addPicture(const Picture&amp; picture); 
 
    int rowCount(const QModelIndex&amp; parent = QModelIndex()) const override; 
    QVariant data(const QModelIndex&amp; index, int role) const override; 
    bool removeRows(int row, int count, const QModelIndex&amp; parent) override; 
 
    void setAlbumId(int albumId); 
    void clearAlbum(); 
 
public slots: 
    void deletePicturesForAlbum(); 
 
private: 
    void loadPictures(int albumId); 
    bool isIndexValid(const QModelIndex&amp; index) const; 
 
private: 
    DatabaseManager&amp; mDb; 
    int mAlbumId; 
    std::unique_ptr&lt;std::vector&lt;std::unique_ptr&lt;Picture&gt;&gt;&gt; mPictures; 
}; 
</pre><p>The interesting parts are those concerning the album. As you can see, the constructor expects an <code class="literal">AlbumModel</code>. This class also stores the current <code class="literal">mAlbumId</code> to be able to request the pictures for a given album only. Let's see what the constructor really does:</p><pre class="programlisting">PictureModel::PictureModel(const AlbumModel&amp; albumModel, QObject* parent) : 
    QAbstractListModel(parent), 
    mDb(DatabaseManager::instance()), 
    mAlbumId(-1), 
    mPictures(new vector&lt;unique_ptr&lt;Picture&gt;&gt;()) 
{ 
    connect(&amp;albumModel, &amp;AlbumModel::rowsRemoved, 
            this, &amp;PictureModel::deletePicturesForAlbum); 
} 
</pre><p>As you can see, the <code class="literal">albumModel</code> class is used only to connect a signal to our slot <code class="literal">deletePicturesForAlbum()</code> which is self-explanatory. This makes sure that the database is always valid: a picture should be deleted if the owning album is deleted. This will be done automatically when <code class="literal">AlbumModel</code> emits the <code class="literal">rowsRemoved</code> signal.</p><p>Now, <code class="literal">mPictures</code> is not initialized with all the pictures of the database. Because we chose to restrict <code class="literal">PictureModel</code> to work on the pictures for a given album, we do not know at the construction of <code class="literal">PictureModel</code> which album to choose. The loading can only be done when the album is selected, in <code class="literal">setAlbumId()</code>:</p><pre class="programlisting">void PictureModel::setAlbumId(int albumId) 
{ 
    beginResetModel(); 
    mAlbumId = albumId; 
    loadPictures(mAlbumId); 
    endResetModel(); 
} 
</pre><p>When the album changes, we completely reload <code class="literal">PictureModel</code>. The reloading phase is wrapped with the <code class="literal">beginResetModel()</code> and <code class="literal">endResetModel()</code> functions. They notify any attached views that their state should be reset as well. Any previous data (for example, <code class="literal">QModelIndex</code>) reported from the model becomes invalid.</p><p>The <code class="literal">loadPictures()</code> function is quite straightforward:</p><pre class="programlisting">void PictureModel::loadPictures(int albumId) 
{ 
    if (albumId &lt;= 0) { 
         mPictures.reset(new vector&lt;unique_ptr&lt;Picture&gt;&gt;()); 
        return; 
    } 
    mPictures = mDb.pictureDao.picturesForAlbum(albumId); 
} 
</pre><p>By convention, we decided that, if a negative <code class="literal">album id</code> is provided, we clear the pictures. To do it, we reinitialize <code class="literal">mPictures</code> with the call <code class="literal">mPictures.reset(new vector&lt;unique_ptr&lt;Picture&gt;&gt;())</code>. This will call the destructor on the owned vector, which in turn will do the same for the <code class="literal">Picture</code> elements. We force <code class="literal">mPictures</code> to always have a valid vector object to avoid any possible null reference (in <code class="literal">PictureModel::rowCount()</code> for example).</p><p>After that, we simply assign the database pictures for the given <code class="literal">albumId</code> to <code class="literal">mPictures</code>. Because we work with smart pointers at every level, we do not even see any specific semantics here. Still, <code class="literal">mPicture</code> is a <code class="literal">unique_ptr&lt;vector&lt;unique_ptr&lt;Picture&gt;&gt;&gt;</code>. When the <code class="literal">=</code> operator is called, the <code class="literal">unique_ptr</code> pointer overloads it and two things happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The ownership of the right-hand side (the pictures retrieved from the database) is transferred to <code class="literal">mPictures</code></li><li class="listitem">The old content of <code class="literal">mPictures</code> is automatically deleted</li></ul></div><p>It is effectively the same as calling <code class="literal">mPictures.reset()</code> and then <code class="literal">mPictures = move(mDb.pictureDao.picturesForAlbum(albumId))</code>. With the <code class="literal">=</code> overload, everything is streamlined and much more pleasant to read.</p><p>The <code class="literal">PictureModel</code> shows you how flexible the model paradigm can be. You can easily adapt it to your own use case without making any strong coupling. After all, the <code class="literal">albumModel</code> is only used to connect to a single signal; there are no retained references. The remainder of the class is available in the source code of the chapter.</p></div>
<div class="section" title="Summary" id="aid-1565U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>The chapter was a journey to create a well-defined <code class="literal">gallery-core</code> library. We studied advanced techniques with <code class="literal">.pro</code> files to split your project into sub-modules, persisted data in a SQLITE3 database with the help of smart pointers, and finally studied how the Model/View architecture works in Qt.</p><p>From now on, a project organization with Qt should hold no terrors for you. The next chapter will continue right where we stopped: the library is ready, now let's make great QWidgets to have a stunning gallery application and look at the other side of the model: the View layer.</p></div></body></html>