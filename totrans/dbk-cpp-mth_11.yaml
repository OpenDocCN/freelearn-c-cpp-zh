- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: C++ Is Backward Compatible ...Even with C
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++向后兼容...甚至与C
- en: '*And of course, with C, and B ... and even A ... and @* *maybe?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，还有C，B...甚至A...和@* *也许吧？*'
- en: 'In the beginning, there was the word, and the word was used in BCPL. Pronounced
    like Basic Combined Programming Language, not Baltimore County Public Library.
    It was the first of its kind that ruled the land of compilers with an iron syntax
    for several iterations. However, the trials of time were not kind to it. New features,
    doctrines, and syntax passed through and soon a new heir to the throne rose from
    the bits: *B* . Not too many considered *B* ’s typeless nature and advantage and
    soon *B* ceased to be, as a new contender to the throne of programming languages
    replaced *B* : *C* [1](B22235_11.xhtml#footnote-029) .'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，有语言，语言在BCPL中使用。发音为Basic Combined Programming Language，而不是巴尔的摩县公共图书馆。它是第一种以铁的语法统治编译器王国的语言，经过几轮迭代。然而，时间的考验并不善待它。新特性、教义和语法通过，不久一个新的继承人从比特中崛起：*B*。不是很多人考虑*B*的无类型性质和优势，不久*B*就消失了，因为一个新的编程语言竞争者取代了*B*：*C*
    [1](B22235_11.xhtml#footnote-029)。
- en: '[1](B22235_11.xhtml#footnote-029-backlink) [https://www.bell-labs.com/usr/dmr/www/chist.html](https://www.bell-labs.com/usr/dmr/www/chist.html)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_11.xhtml#footnote-029-backlink) [https://www.bell-labs.com/usr/dmr/www/chist.html](https://www.bell-labs.com/usr/dmr/www/chist.html)'
- en: The rest is history. *C* became the de-facto language of low-level system programming,
    and its syntax crept into all popular programming languages of the last and this
    century (hello, curly braces). *C* is like glue, binding together various programming
    languages to perform sacred rites in Computerlandia.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的都是历史。*C*成为了底层系统编程的事实上的语言，其语法渗透到上个世纪和这个世纪的几乎所有流行编程语言中（你好，花括号）。*C*就像胶水，将各种编程语言粘合在一起，在计算机王国中执行神圣的仪式。
- en: And the programmers looked and saw that it was good.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员们看了看，觉得它很好。
- en: 'Except for one Prometheus [2](B22235_11.xhtml#footnote-028) , a bringer of
    classes into *C* , soon to give people, *C with classes* , and *Cfront* , the
    first ever compiler that digested C++ code and spat out C code which sadly is
    long gone from our realm, but its legacy remains. The language, the dozens of
    C++ standard-compliant compilers (each, in their time was standard conformant...
    more or less), several hundreds of undefined behavior cases, and various iterations
    of the standard over the last three decades (the last working one being C++23,
    while the committee is laboring the latest and greatest C++26) are all here and
    constitute the programming language we all love: C++.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个普罗米修斯 [2](B22235_11.xhtml#footnote-028) ，一个将类引入*C*的人，很快就会给人们带来*C with classes*和*Cfront*，这是第一个能够消化C++代码并吐出C代码的编译器，遗憾的是它已经从我们的领域消失，但它的遗产仍然存在。这种语言，数十个C++标准兼容的编译器（每个在其时代都是标准兼容的...或多或少），数百个未定义行为案例，以及过去三十年中标准的各种迭代（最后一个有效的是C++23，而委员会正在努力最新的C++26）都在这里，构成了我们所有人都爱的编程语言：C++。
- en: '[2](B22235_11.xhtml#footnote-028-backlink) Yes, Bjarne, we are talking about
    you'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](B22235_11.xhtml#footnote-028-backlink) 是的，Bjarne，我们在谈论你'
- en: 'This chapter will have you glued to your seat – like traffic at rush hour –
    with the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将让你坐得如痴如醉——就像高峰时段的交通——以下是一些主题：
- en: Is C++ really backward-compatible with C ?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++真的与C向后兼容吗？
- en: Is C++ really backward-compatible with C++?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++真的与C++向后兼容吗？
- en: Is C really forward-compatible with C++?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C真的与C++向前兼容吗？
- en: This chapter will be a bit of exploration, covering most of the banally boring
    bothersome beliefs concerning whether C++ is really backward compatible with C.
    As we were indoctrinated through the decades by our tutors, teachers, and trainers,
    C++ is mostly backward compatible with C. This means that much of C code can be
    compiled and run in C++ with little modification, as they share similar syntax
    and standard libraries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将进行一些探索，涵盖大多数关于C++是否真的与C向后兼容的陈词滥调。正如我们几十年来被导师、教师和培训师灌输的那样，C++主要与C向后兼容。这意味着大部分C代码可以在C++中经过少量修改后编译和运行，因为它们具有相似的语法和标准库。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: C and C++ may be closely related, like two siblings in a dysfunctional family,
    but still have many differences, leading to a love-hate relationship when it comes
    to compatibility. However, over time, the two languages have diverged significantly.
    According to the core rules, C is more permissive with looser typing rules, especially
    around pointers, and allows constructs like implicit pointer conversions, which
    C++ strictly forbids. For instance, in C, you can assign a **void*** to any other
    pointer type without a cast, while C++ will demand an explicit cast to maintain
    type safety.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 虽然可能关系密切，就像一个功能失调的家庭中的两个兄弟姐妹，但仍然存在许多差异，导致在兼容性方面产生爱恨交加的关系。然而，随着时间的推移，这两种语言已经显著分化。根据核心规则，C
    在类型规则上更为宽松，特别是关于指针的部分，允许像隐式指针转换这样的结构，而 C++ 则严格禁止。例如，在 C 中，你可以将 **void*** 赋值给任何其他指针类型而不需要类型转换，而
    C++ 则会要求显式转换以保持类型安全。
- en: 'Similarly, C++ (especially the newer iterations of the language) has stricter
    rules regarding enumerations, making them distinct types, whereas in C, enums
    are simply treated as **int** . This difference extends to many other areas: variable
    initialization, type qualifiers, and even memory allocation ( ***alloc()** ) work
    differently between the two. This is especially true of functions such as **malloc**
    , **calloc** , and so on. While in C they’re just your run-of-the-mill functions,
    as mundane as your morning cup of coffee, if they occur in any kind of C++ code,
    suddenly it’s like opening a portal to the seven circles of developer hell. This
    is particularly true during code reviews where acolyte C++ programmers are clutching
    their keyboards in terror, pointing out how you should not use C functions in
    C++ code when you have perfectly valid **new** and **delete** . They might also
    ask why you even need to allocate memory. It’s 2024. We have smart pointers. Or
    at least, if you can restrain yourself, we beg you not to use C-style casting.
    That’s because there are perfectly functioning cast operators introduced in the
    C++ standard more than a decade ago.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，C++（尤其是语言的新版本）在枚举方面有更严格的规则，使它们成为不同的类型，而在 C 中，枚举只是被简单地视为 **int** 。这种差异扩展到许多其他领域：变量初始化、类型限定符，甚至内存分配（***alloc()**）在两种语言中工作方式也不同。这尤其适用于像
    **malloc**、**calloc** 等函数。在 C 中，它们只是普通的函数，就像你早晨的一杯咖啡一样平凡，但如果它们出现在任何 C++ 代码中，突然就像打开了一个通往开发者地狱七圈的传送门。这在代码审查期间尤其如此，当时年轻的
    C++ 程序员们紧张地抓着键盘，指出你不应该在有完全有效的 **new** 和 **delete** 的情况下使用 C 函数。他们还可能问为什么你需要分配内存。现在是
    2024 年。我们有智能指针。或者至少，如果你能控制自己，我们恳求你不要使用 C 风格的类型转换。那是因为 C++ 标准在十多年前就引入了完全功能的类型转换运算符。
- en: According to what was just discussed (but not exclusively), while young C++
    emphasizes stricter type rules and more predictable, safe programming practices,
    granddaddy C remains the pragmatic and flexible, albeit riskier, option.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据刚才讨论的内容（但不仅限于此），虽然年轻的 C++ 强调更严格的类型规则和更可预测、更安全的编程实践，但老牌的 C 仍然是一个实用且灵活的选项，尽管风险更大。
- en: To the horror of C++ acolytes, the two languages are often used together, especially
    in C++ projects that need to use libraries written in C, but ensure code compatibility
    between the two languages. Oh, the nightmares of software development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让 C++ 程序员感到恐惧的是，这两种语言经常一起使用，尤其是在需要使用用 C 编写的库的 C++ 项目中，但确保两种语言之间的代码兼容性。哦，软件开发的噩梦。
- en: To aid the preceding scenario, developers often have to use **extern "C"** declarations,
    which prevent C++’s name mangling and allow smooth function linking across libraries
    written in various dialects. This is because, despite their similarities, the
    object files generated by C and C++ compilers are handled differently (yes, name
    mangling, we’re talking about you).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助上述情况，开发者通常必须使用 **extern "C"** 声明，这防止了 C++ 的名称修饰，并允许在不同方言编写的库之间平滑地链接函数。这是因为，尽管它们有相似之处，但
    C 和 C++ 编译器生成的目标文件的处理方式不同（是的，我们谈论的是名称修饰）。
- en: To top the previous flat facts, in addition, there are a plethora of C99-specific
    keywords, such as **_Alignas** , **_Alignof** , **_Atomic** , **_Bool** , **_Complex**
    , **_Generic** , **_Imaginary** , **_Noreturn** , and **_Static_assert** , that
    are not part of standard C++, though some may have C++ equivalents or be available
    through compiler extensions. To make life more interesting, these were actually
    retired starting from C23, due to some efforts to bring C closer to C++.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的平实事实之上，此外，还有许多C99特定的关键字，如**_Alignas**、**_Alignof**、**_Atomic**、**_Bool**、**_Complex**、**_Generic**、**_Imaginary**、**_Noreturn**和**_Static_assert**，它们不是标准C++的一部分，尽管一些可能有C++等价项或可以通过编译器扩展获得。为了使生活更有趣，这些关键字实际上从C23开始就被废弃了，这是为了使C语言更接近C++。
- en: And we didn’t even mention designated initializers. Too late for them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至还没有提到指定初始化器。对他们来说太晚了。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, C was certainly not thought up with the idea that someday, there would
    be a future programming language called C++. That’s why the following C code is
    perfectly valid while all law-abiding C++ compilers (and pure C++ developers too)
    will choke on it heavily:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C语言的设计肯定不是基于这样的想法：将来会有一种名为C++的编程语言。这就是为什么下面的C代码完全有效，而所有遵纪守法的C++编译器（以及纯C++开发者）都会对它感到难以忍受：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While looking like the nightmare out of the C pits, regardless of it, this
    piece of pure C code is perfectly valid, and what a surprise, it even calculates
    the Fibonacci numbers. But let’s not be overly fiendish towards you, dear reader
    (although considering what other mythical code snippets you had to suffer through
    this book till you reached this chapter, I hardly doubt this piece of code may
    come as a shock to you ... no worries, this is the penultimate chapter, so the
    suffering is almost over ... till then, however: do you remember in [*Chapter
    9*](B22235_09.xhtml#_idTextAnchor096) where we defined main to be return and return
    to be main?), and let us present another interesting feature of C, that was not
    ported over to C++.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来像是C语言深坑中的噩梦，但不管怎样，这段纯C代码是完全有效的，而且令人惊讶的是，它甚至可以计算斐波那契数列。但让我们不要对你这个亲爱的读者太过苛刻（尽管考虑到你在这本书中不得不忍受的其他神话般的代码片段，直到你到达这一章，我几乎怀疑这段代码可能会给你带来震惊……不用担心，这是倒数第二章，所以痛苦几乎结束了……然而：你还记得在[*第9章*](B22235_09.xhtml#_idTextAnchor096)中我们定义main为return，并将return定义为main吗？），让我们再介绍C语言的一个有趣特性，这个特性没有被移植到C++中。
- en: No, we are not talking about variable length arrays, regardless of the fact
    that just due to the peculiar syntax of **void funny_fun(int n, int array[][*])**
    , they also deserve a litany of their own (the syntax is an exemplification of
    how to pass in a 2D variable length array to a function in the declaration of
    its prototype). Variable length arrays have been discussed [3](B22235_11.xhtml#footnote-027)
    in detail [4](B22235_11.xhtml#footnote-026) throughout the last decade by authorities
    who are much more qualified to discuss this than our humble person. Regardless
    of those discussions, they (the VLAs) still did not make it into the C++ standard,
    so there must be a valid reason behind this decision (not just the potential stack-related
    issues, of assuming a theoretically unlimited stack, and the type mayhem the non-compile
    time type deduction might induce with VLAs, but also that in C++ there are much
    better mechanisms to handle this specific use case).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们不是在谈论变长数组，尽管仅仅由于**void funny_fun(int n, int array[][*])**这种特殊的语法，它们也值得有一系列自己的规则（这种语法是说明如何在函数原型声明中传递二维变长数组的例子）。变长数组在上一个十年中已经被权威人士详细讨论过[3](B22235_11.xhtml#footnote-027)，他们比我们这个谦逊的人更有资格讨论这个问题。不管那些讨论如何，它们（变长数组）仍然没有进入C++标准，所以这个决定背后肯定有合理的理由（不仅仅是潜在的与栈相关的問題，假设理论上无限的栈，以及非编译时类型推导与变长数组可能引起的类型混乱，还有在C++中存在处理这种特定用例的更好机制）。
- en: '[3](B22235_11.xhtml#footnote-027-backlink) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](B22235_11.xhtml#footnote-027-backlink) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf)'
- en: '[4](B22235_11.xhtml#footnote-026-backlink) [https://nullprogram.com/blog/2019/10/27/](https://nullprogram.com/blog/2019/10/27/)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](B22235_11.xhtml#footnote-026-backlink) [https://nullprogram.com/blog/2019/10/27/](https://nullprogram.com/blog/2019/10/27/)'
- en: For this chapter of the book, we will discuss some C-specific features that
    the author finds highly useful, but that sadly still did not make it into the
    C++ standard in their original form.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的这一章节，我们将讨论一些作者认为非常有用的C特定特性，但遗憾的是，这些特性在其原始形式中仍未纳入C++标准。
- en: The magic of the parameter list
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数列表的魔法
- en: Let’s start with a simple function, the simplest of all, which is **int foo()**
    . It’s not a very sophisticated function, but it does its job as expected, whatever
    that might be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的函数开始，那就是**int foo()**。这不是一个非常复杂的函数，但它按照预期完成了工作，无论那是什么。
- en: When compiled as C, a function with an empty parameter list means the function
    can take an unspecified number of arguments, which can lead to ambiguity and potential
    errors if arguments are passed to the function. That’s because the compiler will
    not enforce parameter constraints.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当以C语言编译时，空参数列表的函数意味着该函数可以接受一个未指定的参数数量，如果传递参数给函数，可能会导致歧义和潜在的错误。这是因为编译器不会强制参数约束。
- en: To explicitly specify that a function takes no arguments in C, we must use **void**
    in the parameter list, as in **int foo(void)** , which clearly indicates that
    the function accepts no arguments and passing any would result in a compile-time
    error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，要明确指定一个函数不接受任何参数，我们必须在参数列表中使用**void**，例如**int foo(void)**，这清楚地表明该函数不接受任何参数，传递任何参数都会导致编译时错误。
- en: In contrast, C++ simplifies this by treating an empty parameter list as equivalent
    to specifying **void** , meaning that **int foo()** in C++ denotes a function
    that takes no arguments, just like **int foo(void)** , making the use of the **void**
    optional in C++.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，C++通过将空参数列表视为指定**void**的等效方式来简化这一点，这意味着C++中的**int foo()**表示一个不接受任何参数的函数，就像**int
    foo(void)**一样，这使得在C++中使用**void**变得可选。
- en: This makes the syntax cleaner in C++, where functions with no parameters can
    simply be declared with empty parentheses. While C still requires **void** for
    clarity and correctness, C++ allows both forms, though the typical practice is
    to omit **void** and use the simpler **int foo()** . Neat, isn’t it?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得C++的语法更简洁，其中无参数的函数可以简单地通过空括号声明。虽然C仍然需要**void**以保持清晰和正确性，但C++允许两种形式，尽管典型做法是省略**void**并使用更简单的**int
    foo()**。这不是很整洁吗？
- en: However, what if we want to add some parameters to our function? Let’s modify
    it in the form of **int foo(int** **array[static 10])** .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想给我们的函数添加一些参数呢？让我们以**int foo(int array[static 10])**的形式修改它。
- en: The **int foo(int array[static 10])** declaration is a feature introduced in
    *C99* that provides additional information to the compiler about the parameters
    passed to a function, specifically when dealing with arrays.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**int foo(int array[static 10])**的声明是C99引入的特性，它向编译器提供了有关传递给函数的参数的额外信息，特别是在处理数组时。'
- en: In this case, the **static** keyword within the array parameter indicates to
    the compiler that the **fun** function is expected to be called with an array
    that has at least 10 elements. The number 10 specifies the minimum size of the
    array that will be passed to the function, which can help the compiler make certain
    assumptions, such as enabling optimizations based on the guaranteed size of the
    array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数组参数中的**static**关键字向编译器表明，**fun**函数预期将使用至少包含10个元素的数组进行调用。数字10指定了将传递给函数的数组的最低大小，这可以帮助编译器做出某些假设，例如基于数组的保证大小启用优化。
- en: Additionally, when using static in the array parameter like this, the compiler
    assumes that the array pointer cannot be **NULL** . That’s because a null pointer
    would imply that there are no valid elements, which violates the condition that
    the array must have at least 10 elements. This provides an extra layer of safety
    and clarity, as it eliminates the need for the function to check whether the array
    is **NULL** before proceeding, which can reduce runtime overhead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当以这种方式在数组参数中使用**static**时，编译器假定数组指针不能是**NULL**。这是因为空指针意味着没有有效的元素，这违反了数组必须至少包含10个元素的条件。这提供了一层额外的安全性和清晰性，因为它消除了函数在继续之前检查数组是否为**NULL**的需要，这可以减少运行时开销。
- en: 'Decent Recent versions of **clang** (well, basically all above 3.1.0) even
    emit a warning if you call a function having this very specific declaration, with
    the infamous **NULL** pointer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 近期版本的**clang**（基本上是3.1.0以上的版本）甚至会在你调用具有这种非常特定声明的函数时发出警告，使用臭名昭著的**NULL**指针：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sadly, this very handy feature did not make it into any of the C++ standards,
    nor can all today’s C compilers digest it (we could not convince MSVC to successfully
    compile this piece of code, regardless of the requested C standard). Regardless,
    for programmers not targeting these platforms, this might indeed come in as a
    great help in times of need.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这个非常实用的特性并没有被任何C++标准所采纳，而且并非所有的现代C编译器都能消化它（我们无法说服MSVC成功编译这段代码，无论请求的C标准是什么）。无论如何，对于不针对这些平台的程序员来说，在需要的时候这确实可能是一种巨大的帮助。
- en: Another handy feature restricted to the circles of C programmers is the **restrict**
    keyword, introduced in C99, which is a type qualifier that provides hints to the
    compiler for optimizing memory access involving pointers. It tells the compiler
    that the pointer to which **restrict** is applied is the only means by which the
    referenced object (memory) will be accessed in the current scope. This allows
    the compiler to make aggressive optimizations because it can assume that no other
    pointer will alias or reference the same memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个仅限于C程序员圈子中的实用特性是C99中引入的**restrict**关键字，它是一个类型限定符，为编译器提供有关优化涉及指针的内存访问的提示。它告诉编译器，应用了**restrict**的指针是当前作用域中访问引用对象（内存）的唯一方式。这允许编译器进行积极的优化，因为它可以假设没有其他指针会别名或引用相同的内存。
- en: When you use the **restrict** qualifier on a pointer, you are promising the
    compiler that, for the lifetime of that pointer, the object it points to will
    not be accessed by any other pointer. This enables the compiler to generate more
    efficient code by avoiding unnecessary memory reloads or re-fetches, which might
    otherwise be required due to potential aliasing (multiple pointers pointing to
    the same memory).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在指针上使用**restrict**限定符时，你是在向编译器承诺，在指针的生命周期内，它所指向的对象不会被任何其他指针访问。这使编译器能够通过避免不必要的内存重新加载或重新检索来生成更高效的代码，否则这些操作可能由于潜在的别名（多个指针指向同一内存）而需要。
- en: Without **restrict** , the compiler must assume that any two pointers may reference
    the same memory, limiting its ability to optimize code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用**restrict**，编译器必须假设任何两个指针都可能引用相同的内存，这限制了它优化代码的能力。
- en: 'For example, let’s consider the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the compiler must assume that ***a** and ***b** could alias each
    other, so it may reload ***a** or ***b** from memory just in case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器必须假设***a**和***b**可能会相互别名，因此它可能需要从内存中重新加载***a**或***b**。
- en: 'Here is its counterpart with **restrict** :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的**restrict**对应版本：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, we have told the compiler that ***a** and ***b** do not alias,
    so it can optimize without worrying about memory aliasing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们告诉编译器***a**和***b**不会别名，因此它可以优化而不必担心内存别名。
- en: 'The following listings (generated by **GCC** 14.2, using **–O3** optimization)
    are the assembly code generated for the two different functions, with some explanation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表（由**GCC** 14.2生成，使用**–O3**优化）是两个不同函数生成的汇编代码，其中包含一些解释：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the other one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Surprisingly, the one with **restrict** has a few more instructions, but once
    we go through the generated code, we can easily spot the effect of the **restrict**
    keyword. Supposedly, the parameters to the function are at the memory locations
    pointed at by **[rsi]** and **[rdi]** . The first one (without **restrict** )
    has to do all the addition work in memory, thus leading to slightly slower code,
    while the second one can delegate these costly operations to two ultra-fast register-based
    additions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，带有**restrict**的那个版本有更多的指令，但一旦我们查看生成的代码，我们就可以轻松地发现**restrict**关键字的效果。据称，函数的参数位于由**[rsi]**和**[rdi]**指向的内存位置。第一个（没有**restrict**）必须在内存中完成所有加法工作，这导致代码略微变慢，而第二个可以将这些昂贵的操作委托给两个基于寄存器的超快速加法操作。
- en: Also, a big difference between these two is that the second one ( **update2**
    , with **restrict** ) can assume that the value of the second parameter will not
    change after the first operation, so the carefully crafted register initializations
    and additions can play a vital part. The first one needs to consider that the
    ***a = *a + *b;** operation might change the value of **b** too (found at **[rsi]**
    ). Hence, it needs to perform the operations in memory, always making the current
    value available to the upcoming operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这两个标准之间的一大区别是，第二个（**update2**，带有**restrict**）可以假设第二个参数的值在第一次操作后不会改变，因此精心设计的寄存器初始化和加法可以发挥至关重要的作用。第一个需要考虑**a
    = *a + *b;**操作可能会改变**b**的值（见**[rsi]**）。因此，它需要在内存中执行操作，始终使当前值对即将进行的操作可用。
- en: While for a simple operation like these simple additions, the effects, and the
    outcoming result might not be as spectacular as for a larger example which would
    not have had enough space in this book, we still have enough evidence that the
    **restrict** keyword has factual effects on the generated code. Too bad this didn’t
    make it into C++ either.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这些简单的加法这样的简单操作，效果和结果可能不如更大示例那样引人注目，这个更大示例在这个书中没有足够的空间，但我们仍然有足够的证据表明**restrict**关键字对生成的代码有实际的影响。遗憾的是，这个特性也没有被纳入C++。
- en: However, that’s enough bashing of C++ and its lack of compatibility with C.
    They were never meant to compete, but rather, they complement each other. Let’s
    move on to more interesting fields. Is C++ really compatible with itself?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对C++及其与C的不兼容性的批评已经足够了。它们从未打算相互竞争，而是相互补充。让我们转向更有趣的领域。C++真的与自身兼容吗？
- en: Whitespace matters – until it doesn’t
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空白字符很重要——直到它们不重要
- en: 'The following piece of code is not an extraordinarily complicated snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段并不特别复杂：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The not-so-complex code defines a series of macros to manipulate strings and
    concatenate tokens. **STR_I(x)** stringifies its argument, **STR(x)** ensures
    full macro expansion before stringification, **JOIN(x,y)** concatenates two arguments
    with a space, and **Hello(x)** is defined but, strangely, unused.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段不太复杂的代码定义了一系列宏来操作字符串和连接标记符。**STR_I(x)**将它的参数字符串化，**STR(x)**确保在字符串化之前进行完整的宏展开，**JOIN(x,y)**通过空格连接两个参数，而**Hello(x)**被定义了，但奇怪的是，没有被使用。
- en: What comes up are two most important **printf** calls in the lifetime of this
    short program. In the first **printf** call, **JOIN(Hello, World)** expands to
    **(Hello World)** , which is then stringified to **"(Hello World)"** . That’s
    nothing overly complicated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短程序的生命周期中，最关键的两次**printf**调用出现了。在第一次**printf**调用中，**JOIN(Hello, World)**展开为**(Hello
    World)**，然后被字符串化为**"(Hello World)"**。这并不复杂。
- en: 'However, the fun part comes now: in the second **printf** call, **JOIN(Hello,World)**
    (without the space between the comma and **World** ) behaves differently depending
    on the GCC version.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的部分现在来了：在第二个**printf**调用中，**JOIN(Hello,World)**（在逗号和**World**之间没有空格）的行为取决于GCC版本。
- en: In GCC 9.4 (and below), this results in **(HelloWorld)** without a space, while
    in GCC 9.5 (and above), the preprocessor adds a space between the tokens, making
    both **printf** calls produce **"(** **Hello World)"** .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCC 9.4（及以下版本）中，这会导致**(HelloWorld)**没有空格，而在GCC 9.5（及以上版本）中，预处理程序在标记符之间添加空格，使得两个**printf**调用都产生**"(**
    **Hello World)"**。
- en: This difference between GCC 9.4 and 9.5 stems from how each version handles
    token concatenation and whitespace between macro arguments, with GCC 9.4 not inserting
    spaces where none are explicitly given, and GCC 9.5 handling them more consistently
    by adding a space even when omitted in the macro invocation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 9.4和9.5之间的这种差异源于每个版本处理标记符连接和宏参数之间的空白字符的方式，GCC 9.4在没有明确给出空白字符的地方不会插入空格，而GCC
    9.5通过在宏调用中省略空格时也添加空格，使其处理更加一致。
- en: While the C and C++ standards do not explicitly say “whitespace is ignored between
    macro arguments and commas,” it is implied by the way the preprocessor handles
    tokenization and macro expansion. Regardless, the rules state that arguments are
    separated by commas, and whitespace does not affect this separation. It seems
    that GCC (before 9.4) had a somewhat liberal interpretation of the lack of specification,
    which was re-interpreted in GCC 9.5 and after.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C和C++标准没有明确说明“宏参数和逗号之间的空白字符被忽略”，但这是通过预处理程序处理标记化和宏展开的方式暗示的。无论如何，规则规定参数通过逗号分隔，空白字符不影响这种分隔。似乎GCC（在9.4之前）对缺乏规定的解释比较宽松，这在GCC
    9.5及以后版本中被重新解释。
- en: The whole misunderstanding is caused by the presence of the **Hello** macro,
    defined as a function-like macro, but used as a plain old replacement macro. It’s
    highly possible that the main issue is (or rather, was) a bug in older GCC, which
    certainly we do not use anymore, because we all know, that newer compilers are
    more standard compliant, and certainly, we all write standard compliant code,
    don’t we?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 整个误解是由一个名为**Hello**的宏的存在引起的，它被定义为一个函数式宏，但被用作一个普通的替换宏。高度可能的是，主要问题（或者更确切地说，曾经是）是较旧
    GCC 的一个错误，因为我们确实不再使用它了，因为我们都清楚，新的编译器更符合标准，而且我们当然都编写符合标准的代码，不是吗？
- en: That’s an interesting piece of historical forward compatibility.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段有趣的历史性向前兼容性。
- en: The 11th guest
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11位客人
- en: C++11 brought a range of new features while maintaining backward compatibility
    with C++98, ensuring that developers could adopt the modern capabilities incrementally
    without breaking existing code. One of the most transformative additions was **move
    semantics** , which introduced some new syntax that C++98 compilers could not
    digest. This was facilitated by rvalue references, a syntax again not supported
    by older compilers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 带来了一系列新特性，同时保持了与 C++98 的向后兼容性，确保开发人员可以增量地采用现代功能，而不会破坏现有代码。其中最具变革性的新增功能之一是**移动语义**，它引入了一些
    C++98 编译器无法处理的语法。这得益于右值引用的语法，这种语法同样不被旧编译器支持。
- en: 'Similarly, the **auto** keyword simplified type declarations by automatically
    inferring types, yet developers could continue using it to explicitly specify
    that the variable has automatic storage, like they never did in C++98. This choice
    was made because let’s admit it, no one ever used auto as it was intended for
    in the C language (from where it was inherited, but even there it was still useless,
    unless in the B language, where it originated, as correctly denoting the storage
    for a variable: the stack).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**auto**关键字通过自动推断类型简化了类型声明，但开发人员仍然可以继续使用它来显式指定变量具有自动存储，就像他们在 C++98 中从未这样做过一样。这个选择是因为，让我们承认吧，没有人真正使用过
    auto，就像它在 C 语言中（它从中继承而来，即使在 C 语言中它也毫无用处，除非在它起源的 B 语言中，它正确地表示变量的存储：栈）。
- en: New syntax such as **range-based for loops** allowed for cleaner iteration over
    containers, but the classic **for** loops from C++98 remained fully functional,
    thankfully, because lots of people still use them. The introduction of **nullptr**
    replaced the old **NULL** macro with a type-safe alternative, though **NULL**
    was still supported for backward compatibility, regardless of the fact that it
    was not that different from 0.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法，如**基于范围的 for 循环**，允许对容器进行更简洁的迭代，但幸运的是，C++98 的经典**for**循环仍然完全有效，因为很多人还在使用它们。**nullptr**的引入用类型安全的替代品替换了旧的**NULL**宏，尽管为了向后兼容，**NULL**仍然被支持，尽管它与0并没有太大的不同。
- en: In addition to these core language improvements, C++11 introduced modern functional
    programming features such as **lambda expressions** , which allowed anonymous
    functions to be written inline, facilitating cleaner and more concise code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些核心语言改进之外，C++11 引入了现代函数式编程特性，如**lambda 表达式**，这使得匿名函数可以内联编写，从而简化了代码，使其更加简洁。
- en: The new **constexpr** feature allowed certain functions to be evaluated at compile
    time, offering performance improvements, but developers could still rely on the
    C++98 approach of runtime function evaluation if needed with the use of overly
    complicated templated recursions because, well, **constexpr** is not supported
    by old compilers either.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**constexpr**特性允许某些函数在编译时进行评估，从而提供性能改进，但开发人员仍然可以通过使用过于复杂的模板递归来依赖 C++98 的运行时函数评估方法，因为，嗯，**constexpr**也不被旧编译器支持。
- en: However, none of those groundbreaking changes can be more confusing to older
    users of C++ than the change of parsing for the C++ templates double right-angle
    brackets. In C++98, when using nested template arguments, the parser required
    spaces between consecutive right-angle brackets ( **> >** ) to distinguish them
    from the shift operator ( **>>** ). This was necessary because, in C++98, the
    parser would interpret two consecutive **>** symbols as the bitwise right-shift
    operator rather than as the closing of two nested templates.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 C++ 的老用户来说，没有一个突破性的变化比 C++ 模板的双右尖括号解析变化更令人困惑。在 C++98 中，当使用嵌套模板参数时，解析器需要在连续的右尖括号（**>>**）之间要求空格，以区分它们与位移运算符（**>>**）。这是必要的，因为在
    C++98 中，解析器会将两个连续的**>**符号解释为位右移运算符，而不是两个嵌套模板的结束。
- en: 'In C++11 and later, the compiler is smart enough to recognize that in this
    context, **>>** refers to closing two nested template brackets, not performing
    a right-shift operation. This makes the syntax cleaner and less error-prone, as
    developers no longer need to manually add spaces between right-angle brackets
    in nested template expressions. However, this also unfortunately means that the
    following program will display two different values depending on whether it was
    compiled with a compiler supporting C++11 standard, or with a compiler that only
    supports C++98:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 及以后的版本中，编译器足够智能，能够识别在这个上下文中，**>>** 指的是关闭两个嵌套模板括号，而不是执行右移操作。这使得语法更简洁，更不容易出错，因为开发者不再需要在嵌套模板表达式中手动添加空格。然而，这也不幸地意味着以下程序将根据它是否是用支持
    C++11 标准的编译器还是只支持 C++98 的编译器编译而显示不同的值：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we dig deeper into the intricacies of the program, it is perfectly clear
    why it has this strange behavior. If it is still not clear yet, let’s break it
    down.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入挖掘程序的复杂性时，它为什么会有这种奇怪的行为是非常清晰的。如果还不清楚，让我们来分解一下。
- en: OK, let’s not break down the entire program. That would be too long. Instead,
    we’ll focus on just **D<C< ::value>>::value>::value>::value** , which is the key
    to all the feature identification.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们就不分解整个程序了。那会太长了。相反，我们将专注于 **D<C< ::value>>::value>::value>::value** ，这是所有功能识别的关键。
- en: 'Using C++98 syntax, this will be parsed as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++98 语法，这将按以下方式解析：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, it all boils down to the value of **D<int>::value** due to the fact that
    **::value>>::value** will be parsed as **1 >> 1** , resulting in **0** . This
    goes into **C<0>::value** , which is a plain **typedef** to **int** . From there,
    we reach **D<int>::value** .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这一切都归结为 **D<int>::value** 的值，因为 **::value>>::value** 将被解析为 **1 >> 1** ，结果为
    **0** 。这进入 **C<0>::value** ，它是一个简单的 **typedef** 到 **int** 。从那里，我们到达 **D<int>::value**
    。
- en: Since we have defined it to be **2** , **if** certainly will be **true** , and
    we have executed the C++98 identification branch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将其定义为 **2** ，**if** 当然是 **true** ，并且我们已经执行了 C++98 识别分支。
- en: 'However, when parsing the code with a C++11-compliant compiler, the expression
    will be parsed as the following, slightly more complex expression:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当用符合 C++11 标准的编译器解析代码时，表达式将被解析为以下稍微复杂一些的表达式：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As may not be obvious from the long and complex set of right-angle brackets,
    in the end, this will be parsed like two comparisons. That’s because the following
    **D<C<1>>::value** turns out to be **2** (because **C<1>** is also a type by itself,
    so we end up in a specialization of the **D** class with **C<1>** ). Then, this
    is compared to **::value** , which will turn out to be true **(2>1)** . From this,
    in the end, after a series of interesting conversions, the end result will look
    like **1>1** . This turns out to be **false** ; hence, we enter the C++11 branch.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长而复杂的右尖括号集合可能不明显，最终，这将被解析为两个比较。这是因为接下来的 **D<C<1>>::value** 结果为 **2**（因为 **C<1>**
    也是一个类型，所以我们最终进入了一个具有 **C<1>** 的 **D** 类的特化）。然后，它与 **::value** 进行比较，结果为真 **(2>1)**
    。从这个结果出发，经过一系列有趣的转换，最终结果看起来像 **1>1** 。这结果是 **false**；因此，我们进入 C++11 分支。
- en: With this in place, we have a nice and short, albeit overly complicated and
    useless, way to identify whether our code was compiled with a C++11 conforming
    compiler. However, checking for the value of **__cplusplus** is much easier than
    this and should be used in any production-ready code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一种既简洁又短，尽管过于复杂且无用的方法来识别我们的代码是否是用符合 C++11 标准的编译器编译的。然而，检查 **__cplusplus**
    的值比这要简单得多，并且应该在任何生产就绪的代码中使用。
- en: The auto surprise
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动惊喜
- en: If you, dear reader, do remember that in [*Chapter 9*](B22235_09.xhtml#_idTextAnchor096)
    , we had an interesting section called *The definition of zero* , then all is
    good. That’s because our next pitch will be about this highly influential number
    again. If you don’t remember that chapter, then life is still good, because hopefully,
    you have purchased a full book with all the chapters inside, and you can turn
    the pages back to read it (again).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你，亲爱的读者，还记得在 [*第 9 章*](B22235_09.xhtml#_idTextAnchor096) 中，我们有一个有趣的章节叫做 *零的定义*
    ，那么一切都很顺利。那是因为我们的下一个话题将再次涉及这个极具影响力的数字。如果你不记得那章，那么生活仍然很好，因为希望你已经购买了一本包含所有章节的全书，你可以翻到那一页再读一遍（再次）。
- en: 'Let’s consider the following program:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下程序：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The program is not an overly complicated one again. It just uses the fancy
    **auto** keyword and initializes variables to **0** using all kinds of mechanisms,
    mostly presented in the chapter mentioned earlier. If you do not know what the
    **auto** keyword does, then here is a short recap: the **auto** keyword in C++11
    was hijacked from C, and its new role is to allow automatic type inference, enabling
    the compiler to deduce the type of a variable based on its initializer. This simplifies
    code by removing the need for explicit type declarations, and shortens the handling
    of complex or verbose types, such as iterators or templated types.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 程序并不是特别复杂。它只是使用了花哨的 **auto** 关键字，并使用各种机制将变量初始化为 **0**，这些机制主要在前面提到的章节中介绍。如果你不知道
    **auto** 关键字的作用，这里有一个简短的回顾：C++11 中的 **auto** 关键字是从 C 中劫持的，它的新角色是允许自动类型推断，使编译器能够根据初始化器推导出变量的类型。这通过消除显式类型声明的需要来简化代码，并缩短处理复杂或冗长的类型（如迭代器或模板类型）的处理。
- en: 'Anyway, back to our code. After careful consideration, we can conclude the
    following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，回到我们的代码。经过仔细考虑，我们可以得出以下结论：
- en: '**auto a1 = 0;** : For this simple case, **a1** is deduced to be **int** since
    0 is an integer literal. This is a straightforward copy initialization.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**auto a1 = 0;** : 对于这个简单的情况，**a1** 被推导为 **int** 类型，因为 0 是一个整型字面量。这是一个直接的复制初始化。'
- en: '**auto a2(0);** : Again, a simple one, **a2** is also deduced to be **int**
    because 0 is directly initialized as an integer literal.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**auto a2(0);** : 再次，这是一个简单的例子，**a2** 也被推导为 **int** 类型，因为 0 是直接初始化为一个整型字面量。'
- en: '**auto a3 {0};** : Then, **a3** is deduced to be **int** , as the **{0}** list
    initialization initializes it to an integer.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**auto a3 {0};** : 然后，**a3** 被推导为 **int** 类型，因为 **{0}** 列表初始化将其初始化为一个整数。'
- en: '**auto a4 = {0};** : This is a bit tricky, however. For this case, **a4** is
    deduced to be **std::initializer_list<int>** because **auto** with brace initialization
    deduces an **initializer_list** . This is a special rule for **auto** when used
    with brace-enclosed initializers.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**auto a4 = {0};** : 然而，这个例子有点棘手。在这种情况下，**a4** 被推导为 **std::initializer_list<int>**
    类型，因为使用花括号初始化的 **auto** 会推导出一个 **initializer_list**。这是 **auto** 与花括号包围的初始化器一起使用时的一个特殊规则。'
- en: 'The output of the program using MSVC is the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MSVC 编译的程序输出如下：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using GCC (recent/decent versions), the output will be a bit less verbose,
    but you get the idea:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GCC（较新/较好的版本），输出将稍微简洁一些，但你的想法应该是这样的：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, there is a catch. If we compile this piece of code with GCC versions
    older than version 5.0 we get an ugly surprise. The output is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个陷阱。如果我们用版本低于 5.0 的 GCC 编译这段代码，我们会得到一个令人不快的惊喜。输出如下：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What an unexpected surprise of backward compatibility. The real help comes
    from clang (3.7), however. If we compile the program with it, we get the following
    rather helpful message:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 多么意外的向后兼容性惊喜。真正的帮助来自 clang（3.7）。如果我们用它编译程序，我们会得到以下相当有用的消息：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, it seems that at some stage during its evolution, the meaning of **{x}**
    combined with **auto** but not **=** , in this very specific scenario, has changed
    (around the birth date of C++17). However, thankfully, early compilers had thought
    of this peculiar scenario, with this very specific and direct warning. Very backward
    compatible, isn’t it?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，似乎在其演变过程中，**{x}** 与 **auto** 结合但不是 **=** 的意义在特定场景下发生了变化（大约在 C++17 诞生之时）。然而，幸运的是，早期的编译器已经考虑了这种特殊场景，并给出了非常具体且直接的警告。这不是非常向后兼容，对吧？
- en: 'So, with all this in mind, it should not come as a huge surprise that the following
    code does not even compile (considering that we are still in the confines of our
    previous short program):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，考虑到所有这些，以下代码甚至无法编译（考虑到我们仍然在我们之前的简短程序的限制内）并不令人惊讶：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Why should it? Which type would **{0}** be deduced to, considering all the
    chaos and mayhem with the preceding syntax? Would it be deduced to an **int**
    type? Or maybe to an **initializer_list** type? Would it be a null pointer ( **nullptr**
    )? Or an object that can be built from a number, like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它为什么会这样？考虑到前面的语法混乱和混乱，**{0}** 会推导为哪种类型？会是 **int** 类型吗？或者可能是 **initializer_list**
    类型？它会是空指针（**nullptr**）吗？或者是一个可以从数字构建的对象，如下所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Or is this not so fun anymore?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这不再那么有趣了吗？
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned that C++ has evolved and diverged significantly
    from its humble C (as well as B and BCPL) origins. We learned that C++ has introduced
    modern features and stricter rules to enhance safety and efficiency, and to support
    modern programming paradigms. While it maintains much of C’s syntax, the two languages
    have heavily branched off over time, leading to compatibility challenges, especially
    when mixing older C code with features requiring newer C++ standards. We discussed
    this extensively in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到 C++ 已经与其谦逊的 C（以及 B 和 BCPL）起源发生了显著的发展和分歧。我们了解到 C++ 引入了现代特性和更严格的规则，以增强安全性和效率，并支持现代编程范式。尽管它保持了
    C 的大部分语法，但随着时间的推移，这两种语言已经严重分叉，导致兼容性挑战，尤其是在将较老的 C 代码与需要较新 C++ 标准的功能混合时。我们在这章中对此进行了广泛讨论。
- en: Within modern C++ itself, the introduction of features such as move semantics,
    stricter template parsing, and changes in the behavior of keywords such as **auto**
    have added layers of complexity (not that there were not enough). We also learned
    this in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 C++ 本身中，引入了诸如移动语义、更严格的模板解析以及诸如 **auto** 等关键字行为的变化，这些都增加了复杂性（尽管之前并不缺乏）。我们也在本章中学到了这一点。
- en: Despite these challenges, we explored the fact that C++ continues to build on
    its rich legacy, offering powerful tools for developers while requiring careful
    attention to evolving standards and backward compatibility without incurring too
    much contradiction with its previous self. It remains a language where tradition
    and innovation meet, often in unexpected and fascinating ways.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管面临这些挑战，我们探讨了这样一个事实：C++ 仍然在构建其丰富的遗产之上，为开发者提供强大的工具，同时需要仔细关注不断发展的标准和向后兼容性，而不会与其先前的自我产生太多矛盾。它仍然是一种传统与创新交汇的语言，常常以意想不到且令人着迷的方式相遇。
- en: But for how long? Will it survive the surfacing threat of the new kid on the
    block? Will Rust replace C++? That’s up to you, dear reader, and it will be detailedly
    debated by Alex in our next chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会持续多久呢？它能否经受住新来者的威胁？Rust 会取代 C++ 吗？这取决于您，亲爱的读者，而 Alex 将在下一章中详细讨论这一点。
